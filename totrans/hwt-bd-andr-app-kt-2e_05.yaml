- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Essential Libraries: Retrofit, Moshi, and Glide'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the steps needed to present app users with dynamic
    content fetched from remote servers. You will be introduced to the different libraries
    required to retrieve and handle this dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to fetch data from a network endpoint
    using Retrofit, parse JSON payloads into Kotlin data objects using Moshi, and
    load images into `ImageView` using Glide.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to implement navigation in our app.
    In this chapter, we will learn how to present dynamic content to the user as they
    navigate around our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing REST, API, JSON, and XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching data from a network endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a JSON response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading images from a remote URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/Uqtjm](https://packt.link/Uqtjm)
  prefs: []
  type: TYPE_NORMAL
- en: Introducing REST, API, JSON, and XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data presented to users can come from different sources. It can be hardcoded
    into an app, but that comes with limitations. To change hardcoded data, we have
    to publish an update to our app. Some data, such as currency exchange rates, the
    real-time availability of assets, and the current weather, cannot be hardcoded
    by its nature. Other data may become outdated, such as the terms of use of an
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such cases, you usually fetch the relevant data from a server. One of the
    most common architectures for serving such data is **representational state transfer**
    (**REST**) architecture. REST architecture is defined by a set of six constraints:
    client-server architecture, statelessness, cacheability, a layered system, code
    on demand (optional), and a uniform interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To read more about REST, visit [https://packt.link/YsSRV](https://packt.link/YsSRV).
  prefs: []
  type: TYPE_NORMAL
- en: When applied to a web service **application programming interface** (**API**),
    we get a **Hypertext Transfer Protocol** (**HTTP**)-based RESTful API. The HTTP
    protocol is the foundation of data communication for the World Wide Web, hosted
    on and accessible via the **internet**. It is the protocol used by servers all
    around the world to serve websites to users in the form of HTML documents, images,
    style sheets, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An interesting article on this topic can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview).
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs rely on the standard HTTP methods – `GET`, `POST`, `PUT`, `DELETE`,
    and `PATCH` – to fetch and transform data. These methods allow us to fetch, store,
    delete, and update data entities on remote servers.
  prefs: []
  type: TYPE_NORMAL
- en: We can rely on the built-in Java `HttpURLConnection` class to execute these
    HTTP methods. Alternatively, we can use a library such as `OkHttp`, which offers
    additional features such as gzipping (compressing and decompressing), redirects,
    retries, and both synchronous and asynchronous calls. Interestingly, from Android
    4.4, `HttpURLConnection` is just a wrapper around `OkHttp`. If we choose `OkHttp`,
    we might as well go for **Retrofit** (as we will in this chapter), the current
    industry standard. We can then benefit from its type-safety, which is better suited
    for handling REST calls.
  prefs: []
  type: TYPE_NORMAL
- en: Most commonly, data is represented by **JavaScript Object Notation** (**JSON**).
    JSON is a text-based data transfer format. As the name implies, it was derived
    from JavaScript. However, it has since become one of the most popular standards
    for data transfer, and its most modern programming languages have libraries that
    encode or decode data to or from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple JSON payload may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common data structure used by RESTful services is **Extensible Markup
    Language** (**XML**), which encodes documents in a format that is human- and machine-readable.
    XML is considerably more verbose than JSON. The same data structure as the previous
    in XML would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we will focus on JSON.
  prefs: []
  type: TYPE_NORMAL
- en: When obtaining a JSON payload, we essentially receive a string. To convert that
    string into a data object, we have a few options, the most popular ones being
    libraries such as `org.json` package. For its lightweight nature, we will focus
    on Moshi.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will look into loading images from the web. Doing so will allow
    us to provide up-to-date images and load the right images for the user’s device.
    It will also let us only load the images when we need them, thus keeping our APK
    size smaller.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from a network endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of this section, we will use The Cat API ([https://thecatapi.com/](https://thecatapi.com/)).
    This RESTful API offers us vast data about, well…cats.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we will create a new project. We then have to grant our app
    internet access permission. This is done by adding the following code to your
    `AndroidManifest.xml` file right before the `Application` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to set up our app to include Retrofit. Retrofit is a type-safe
    library provided by Square, which is built on top of the `OkHttp` HTTP client.
    Retrofit helps us generate **Uniform Resource Locators** (**URLs**), which are
    the addresses of the server endpoints we want to access. It also makes the decoding
    of JSON payloads easier by providing integration with several parsing libraries.
    Sending data to the server is also easier with Retrofit, as it helps with encoding
    the requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about Retrofit here [https://square.github.io/retrofit/](https://square.github.io/retrofit/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To add Retrofit to our project, we need to add the following code to the `dependencies`
    block of the `build.gradle` file of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find the latest version here [https://github.com/square/retrofit](https://github.com/square/retrofit).
  prefs: []
  type: TYPE_NORMAL
- en: With Retrofit included in our project, we can proceed to set it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, to access an HTTP(S) endpoint, we start by defining the contract with
    that endpoint. A contract to access the `https://api.thecatapi.com/v1/images/search`
    endpoint looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to note here. First, you will notice that the contract
    is implemented as an interface. This is how you define contracts for Retrofit.
    Next, you will notice that the name of the interface implies that this interface
    can, eventually, cover all calls made to `TheCatAPIService`.
  prefs: []
  type: TYPE_NORMAL
- en: It is a bit unfortunate that Square chose `Service` as the conventional suffix
    for these contracts, as the term service has a different meaning in the Android
    world, as you will see in [*Chapter 8*](B19411_08.xhtml#_idTextAnchor471), *Services,
    WorkManager, and Notifications*. Nevertheless, this is the convention.
  prefs: []
  type: TYPE_NORMAL
- en: To define our endpoint, we start by stating the method with which the call will
    be made using the appropriate annotation—in our case, `@GET`. The parameter passed
    to the annotation is the path of the endpoint to access. You’ll notice that `https://api.thecatapi.com/v1/`
    is stripped from that path.
  prefs: []
  type: TYPE_NORMAL
- en: That is because this is the common address for all of the endpoints of `TheCatAPI`,
    and so it will be passed to our Retrofit instance at construction time instead.
    Next, we choose a meaningful name for our function—in this case, we'll call the
    image search endpoint, so `searchImages` seems appropriate. The parameters of
    the `searchImages` function define the values we can pass to the API when we make
    the calls.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways in which we can transfer data to the API. `@Query`
    allows us to define values added to the query of our request URL (that’s the optional
    part of the URL that comes after the question mark). It takes a key-value pair
    (in our case, we have `limit` and `size`) and a data type. If the data type is
    not a string, the value of that type will be transformed into a string. Any value
    passed will be URL-encoded for us.
  prefs: []
  type: TYPE_NORMAL
- en: Another such way is using `@Path`. This annotation can be used to replace a
    token in our path wrapped in curly brackets with a provided value. The `@Header`,
    `@Headers`, and `@HeaderMap` annotations will allow us to add or remove HTTP headers
    from the request. `@Body` can be used to pass content in the body of the `POST`
    and `PUT` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have a return type. To keep things simple at this stage, we will
    accept the response as a string. We wrapped our string in a `Call` interface.
    `Call` is Retrofit’s mechanism for executing network requests synchronously (via
    `execute()`) or asynchronously (via `enqueue(Callback)`). When using coroutines,
    we can make the function a `suspend` function and omit the `Call` wrapper (see
    [*Chapter 14*](B19411_14.xhtml#_idTextAnchor751)*, Coroutines and Flow*, for more
    information on coroutines).
  prefs: []
  type: TYPE_NORMAL
- en: 'With our contract defined, we can get Retrofit to implement our service interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run our app with this code, our app will crash with an `IllegalArgumentException`.
    This is because Retrofit needs us to tell the app how to process the server response
    to a string. This processing is done with what Retrofit calls `ConverterFactory`
    instance to our `retrofit` instance, we need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For our project to recognize `ScalarsConverterFactory`, we need to update our
    app’s `build.gradle` file by adding another dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can obtain a `Call` instance by calling `val call = theCatApiService.searchImages(1,
    "full")`. With the instance obtained in this fashion, we can execute an async
    request by calling `call.enqueue(Callback)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Callback` implementation will have two methods: `onFailure(Call, Throwable)`
    and `onResponse(Call, Response)`. Note that we are not guaranteed to have a successful
    response if `onResponse` is called. `onResponse` is called whenever we successfully
    receive *any* response from the server, and no unexpected exception occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: So, to confirm that the response is successful, we should check the `response.isSuccessful`
    property. The `onFailure` function will be called in the case of a network error
    or an unexpected exception somewhere along the way.
  prefs: []
  type: TYPE_NORMAL
- en: So, where should we implement the Retrofit code? In clean architecture, data
    is provided by repositories. Repositories, in turn, have data sources. One such
    data source can be a network data source. This is where we will implement our
    network calls. Our ViewModels will then request data from repositories via use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of **Model-View-ViewModel** (**MVVM**), the ViewModel is an abstraction
    of the view that exposes properties and commands.
  prefs: []
  type: TYPE_NORMAL
- en: For our implementation, we will simplify the process by instantiating Retrofit
    and the service in the Activity. This is not good practice. *Do not do this in
    a production app*. It does not scale well and is very difficult to test. Instead,
    adopt an architecture that decouples your views from your business logic and your
    data. See [*Chapter 15*](B19411_15.xhtml#_idTextAnchor789), *Architecture Patterns*,
    for some ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.01 – reading data from an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following chapters, we will develop an app for an imaginary secret agency
    with a worldwide network of agents saving the world from countless dangers. The
    secret agency in question is quite unique: it operates secret cat agents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will create an app that presents us with one random secret
    cat agent from The Cat API. Before you can present data from an API to your user,
    you first must fetch that data. Let’s start with that here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Empty Activity** project (**File** | **New** | **New Project**
    | **Empty Activity**). Click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your application `Cat` `Agent Profile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your package name is `com.example.catagentprofile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set **Save location** to where you want to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave everything else at its default values and click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you are on the **Android** view in your **Project** pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The Android view in the Project pane](img/B19411_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – The Android view in the Project pane
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `AndroidManifest.xml` file. Add internet permissions to your app
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To add Retrofit and the scalars converter to your app, open the `build.gradle`
    app module, (`Gradle Scripts` | `build.gradle (Module: app)`), and add the following
    lines anywhere inside the `dependencies` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your `dependencies` block should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Between the time of writing and when you carry out this exercise, some dependencies
    may have changed. You should still only add the lines in bold from the preceding
    code block. These will add Retrofit and support for reading server responses as
    single strings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that Retrofit now requires, as a minimum, Android API 21
    or Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Sync Project with Gradle Files** button in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your `activity_main.xml` file in the **Text** mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To be able to use your label to present the latest server response, you need
    to assign an ID to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `com.example.catagentprofile`), then select **New** | **Package**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your package `api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on the newly created package (`com.example.catagentprofile.api`),
    then select **New** | **Kotlin File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your new file `TheCatApiService`. For **Kind**, choose **Interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to the `interface` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines the image search endpoint. Make sure to import all the required
    Retrofit dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Open your `MainActivity` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the `MainActivity` class block, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will instantiate Retrofit and the API service. We use `lazy` to make sure
    the instances are only created when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `serverResponseView` as a field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will look up the view with the `main_server_response` ID the first time
    `serverResponseView` is accessed and then keep a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the `getCatImageResponse()` function after the `onCreate(Bundle?)`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will fire off the search request and handle the possible outcomes—a
    successful response, an error response, and any other thrown exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke a call to `getCatImageResponse()` in `onCreate()`. This will trigger
    the call as soon as the activity is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the missing imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your app by clicking the **Run ‘app’** button or pressing *Ctrl* + *R*.
    On the emulator, it should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – The app presenting the server response JSON](img/B19411_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – The app presenting the server response JSON
  prefs: []
  type: TYPE_NORMAL
- en: Because every time you run your app, a new call is made, and a random response
    is returned, your result will likely differ. However, whatever your result, if
    successful, it should be a JSON payload. Next, we will learn how to parse that
    JSON payload and extract the data we want from it.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing a JSON response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have successfully retrieved a JSON response from an API, it is time
    to learn how to use the data we have obtained. To do so, we need to parse the
    JSON payload. This is because the payload is a plain string representing the data
    object, and we are interested in the specific properties of that object. If you
    look closely at *Figure 5**.2*, you may notice that the JSON contains breed information,
    an image URL, and some other bits of information. However, for our code to use
    that information, first, we must extract it.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the introduction, multiple libraries exist that will parse a
    JSON payload for us. The most popular ones are Google’s GSON (see [https://github.com/google/gson](https://github.com/google/gson))
    and, more recently, Square’s Moshi (see [https://github.com/square/moshi](https://github.com/square/moshi)).
    Moshi is very lightweight, which is why we have chosen to use it in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What do JSON libraries do? Basically, they help us convert data classes into
    JSON strings (serialization) and vice versa (deserialization). This helps us communicate
    with servers that understand JSON strings while allowing us to use meaningful
    data structures in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Moshi with Retrofit, we need to add the Moshi Retrofit converter to
    our project. This is done by adding the following line to the `dependencies` block
    of our app’s `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Since we will no longer the responses as strings, we can go ahead and remove
    the scalars Retrofit converter. Next, we need to create a data class to map the
    server JSON response to. One convention is to suffix the names of API response
    data classes with `Data`—so we’ll call our data class `ImageResultData`. Another
    common suffix is `Entity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we design our server response data classes, we need to take two factors
    into account: the structure of the JSON response and our data requirements. The
    first will affect our data types and field names, while the second will allow
    us to omit fields we do not currently need. JSON libraries ignore data in fields
    we have not defined in our data classes.'
  prefs: []
  type: TYPE_NORMAL
- en: One more thing JSON libraries do for us is automatically map JSON data to fields
    if they happen to have the exact same name. While this is a nice feature, it carries
    risk. If we rely solely on it, our data classes (and the code accessing them)
    will be tightly coupled to the API naming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because not all APIs are designed well, you might end up with meaningless field
    names, such as `fn` or `last`, or inconsistent naming. Luckily, there is a solution
    to this problem. Moshi provides us with an `@Json` annotation. It can be used
    to map a JSON field name to a meaningful field name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `field:` prefix is used to ensure the generated Java field is annotated
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Some consider it better practice to include the annotation even when the API
    name is the same as the field name for the sake of consistency. We prefer the
    conciseness of direct conversion when the field name is clear enough. This approach
    can be challenged when obfuscating our code. If we do, we must either exclude
    our data classes or make sure to annotate all fields.
  prefs: []
  type: TYPE_NORMAL
- en: While we are not always lucky enough to have properly documented APIs, when
    we do, it is best to consult the documentation when designing our model. Our model
    would be a data class into which the JSON data from all calls we make will be
    decoded. The documentation for the image search endpoint of The Cat API can be
    found at [https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/](https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You will often find documentation is or inaccurate. If this happens to be the
    case, the best thing you can do is contact the owners of the API and request that
    they update the documentation. You may have to resort to experimenting with an
    endpoint, unfortunately. This is risky because undocumented fields or structures
    are not guaranteed to remain the same, so when possible, try and get the documentation
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the response schema obtained from the preceding link, we can define
    our model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the response structure is that of a list of results. This means we
    need our responses mapped to `List<ImageResultData>`, not simply `ImageResultData`.
    Now, we need to update `TheCatApiService`. Instead of `Call<String>`, we can now
    have `Call<List<ImageResultData>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to update the construction of our Retrofit instance. Instead
    of `ScalarsConverterFactory`, we will now have `MoshiConverterFactory`. Lastly,
    we need to update our callback since it should no longer handle string calls but
    `List<ImageResultData>` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 5.02 – extracting the image URL from the API response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we have a server response as a string. Now, we want to extract the image
    URL from that string and present only that URL on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the app’s `build.gradle` file and replace the scalars converter implementation
    with a Moshi converter one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the **Sync Project with Gradle** **Files** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under your app package (`com.example.catagentprofile`), create a `model` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `com.example.catagentprofile.model` package, create a new Kotlin
    file named `CatBreedData`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Populate the newly created file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create `ImageResultData` under the same package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set its contents to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the `TheCatApiService` file and update the `searchImages` return type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, open `MainActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the Retrofit initialization block to use the Moshi converter to deserialize
    JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `getCatImageResponse()` function to handle the `List<ImageResultData>`
    requests and responses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you need to check for a successful response and that there is at least
    one `ImageResultData` instance. You can then read the `imageUrl` property of that
    instance and present it to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your app. It should now look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The app presenting the parsed image URL](img/B19411_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – The app presenting the parsed image URL
  prefs: []
  type: TYPE_NORMAL
- en: Again, due to the random nature of the API responses, your URL will likely be
    different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now successfully extracted a specific property from an API response.
    Next, we will learn how to load the image from the URL provided to us by the API.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images from a remote URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just learned how to extract data from an API response. That data often includes
    URLs to images we want to present to the user. There is quite a bit of work involved
    in achieving that. First, you must fetch the image as a binary stream from the
    URL. Then, you need to transform that binary stream into an image (it could be
    a GIF, JPEG, or one of a few other image formats).
  prefs: []
  type: TYPE_NORMAL
- en: Then, you need to convert it into a bitmap instance, potentially resizing it
    to use less memory. You may also want to apply other transformations to it at
    that point. Then, you need to set it to `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds like a lot of work, doesn’t it? Well, luckily for us, there are a few
    libraries that do all of that (and more) for us. The most commonly used libraries
    are Square’s **Picasso** (see [https://square.github.io/picasso/](https://square.github.io/picasso/))
    and **Glide** by Bump Technologies (see [https://github.com/bumptech/glide](https://github.com/bumptech/glide)).
    Facebook’s **Fresco** (see [https://frescolib.org/](https://frescolib.org/)) is
    somewhat less popular. A library that’s gained traction recently is **Coil** (see
    [https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/)).
  prefs: []
  type: TYPE_NORMAL
- en: We will proceed with Glide because it is consistently the fastest of the two
    popular options for loading images, whether from the internet or the cache. However,
    it’s worth noting that Picasso is more lightweight, so it is a trade-off, and
    both libraries are quite useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include Glide in your project, add it to the `dependencies` block of your
    app’s `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, because we might change our minds at a later point, this is a great
    opportunity to abstract away the concrete library to have a simpler interface
    of our own. So, let’s start by defining our `ImageLoader` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is a naïve implementation. In a production implementation, you might want
    to add arguments (or multiple functions) to support options such as different
    cropping strategies or loading states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation of the interface will rely on Glide, so it will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We prefix our class name with `Glide` to differentiate it from other potential
    implementations. Constructing `GlideImageLoader` with `context` allows us to implement
    the clean `loadImage(String, ImageView)` interface without having to worry about
    the context, which Glide requires for image loading.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Glide is smart about the Android context. That means we could have
    separate implementations for the `Activity` and `Fragment` scopes, and Glide would
    know when an image-loading request went beyond the relevant scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we haven’t yet added an `ImageView` to our layout, let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will add an `ImageView` with an ID of `main_profile_image` below our `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create an instance of `GlideImageLoader` in `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In a production app, you would inject the dependency, rather than creating it
    inline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we tell our Glide loader to load the image and, once loaded, center-crop
    it inside the provided `ImageView`. This means the image will be scaled up or
    down to fully fill the `ImageView`, with any excess content cut off (cropped).
    Since we already obtained an image URL before, all we need to do is make the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to ensure the result contains a string that is not empty or made of
    spaces (`isBlank()` in the preceding code block). Then, we can safely load the
    URL into `ImageView`. And we’re done. If we run our app now, we should see something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Server response image URL with the actual image](img/B19411_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Server response image URL with the actual image
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the API returns random results, so the actual image is likely
    to be different. If we’re lucky, we might even get an animated GIF, which we would
    then see animated.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.03 – loading the image from the obtained URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, we extracted the image URL from the API response.
    Now, we will use that URL to fetch an image from the web and display it in our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the app’s `build.gradle` file and add the Glide dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Synchronize your project with the Gradle files.
  prefs: []
  type: TYPE_NORMAL
- en: On the left `com.example.catagentprofile`) and select **New** | **Kotlin File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in `ImageLoader` in the **Name** field. For **Kind**, choose **Interface**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the newly created `ImageLoader.kt` file and update it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be your interface for any image loader in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the project package name again and select **New** | **Kotlin
    File/Class**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `GlideImageLoader` and select **Class** for **Kind**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the newly created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `activity_main.xml` and update it like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add an `ImageView` named `main_profile_image` below `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MainActivity.kt` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a field for your newly added `ImageView` at the top of your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define `ImageLoader` just above the `onCreate(Bundle?)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update your `getCatImageResponse()` function like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, once you have a non-blank URL, it will be loaded into `profileImageView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Exercise outcome showing a random image and its source URL](img/B19411_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Exercise outcome showing a random image and its source URL
  prefs: []
  type: TYPE_NORMAL
- en: The following are bonus steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your layout like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add an `Agent breed` label and tidy up the view layout. Now, your
    layout looks a bit more like a proper cat agent profile app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.kt`, locate the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the preceding lines with the following to look up the new name field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `getCatImageResponse()` like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is done to load the first breed returned from the API into `agentNameView`,
    with a fallback to `Unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, not many pictures in The Cat API have breed data. However,
    if you run your app enough times, you will end up seeing something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Showing the cat agent image and breed](img/B19411_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Showing the cat agent image and breed
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to fetch data from a remote API. We then learned
    how to process that data and extract the information we needed from it. Lastly,
    we learned how to present an image on the screen when given an image URL.
  prefs: []
  type: TYPE_NORMAL
- en: In the following activity, we will apply our knowledge to develop an app that
    tells the user the current weather in New York, presenting the user with a relevant
    weather icon.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 5.01 – displaying the current weather
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say we want to build an app that shows the current weather in New York.
    Furthermore, we also want to display an icon representing the current weather.
  prefs: []
  type: TYPE_NORMAL
- en: This activity aims to create an app that polls an API endpoint for the current
    weather in JSON format, transforms that data into a local model, and uses that
    model to present the current weather. It also extracts the URL to an icon representing
    the current weather and fetches that icon to be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the free OpenWeatherMap API for the purpose of this activity. The
    documentation can be found at [https://openweathermap.org/api](https://openweathermap.org/api).
    To sign up for an API token, please go to [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up).
    You can find your keys and generate new ones as needed at [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys).
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grant internet permissions to the app in order to be able to make API and image
    requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Retrofit, the Moshi converter, and Glide to the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the app layout to support the presentation of the weather in a textual
    form (a short and long description) as well as a weather icon image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the model. Create classes that will contain the server response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Retrofit service for the OpenWeatherMap API,[https://api.openweathermap.org/data/2.5/weather](https://api.openweathermap.org/data/2.5/weather).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Retrofit instance with a Moshi converter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the API service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the successful server response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle the different failure scenarios.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.7 – The final we\uFEFF\uFEFFather app](img/B19411_05_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The final weather app
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to fetch data from an API using Retrofit. We
    then learned how to handle JSON responses, as well as plain text responses, using
    Moshi. We also saw how different error scenarios could be handled.
  prefs: []
  type: TYPE_NORMAL
- en: We later learned how to load images from URLs using Glide and how to present
    them to the user via `ImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few popular libraries for fetching data from APIs and for
    loading images. We only covered some of the most popular ones. You might want
    to try out some of the other libraries to find out which ones fit your purposes
    best.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be introduced to `RecyclerView`, which is a powerful
    UI component that we can use to present our users with lists of items.
  prefs: []
  type: TYPE_NORMAL
