- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: 'Essential Libraries: Retrofit, Moshi, and Glide'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 必要的库：Retrofit、Moshi和Glide
- en: In this chapter, we will cover the steps needed to present app users with dynamic
    content fetched from remote servers. You will be introduced to the different libraries
    required to retrieve and handle this dynamic data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍向应用用户提供从远程服务器获取的动态内容的步骤。您将了解用于检索和处理这些动态数据的不同库。
- en: By the end of this chapter, you will be able to fetch data from a network endpoint
    using Retrofit, parse JSON payloads into Kotlin data objects using Moshi, and
    load images into `ImageView` using Glide.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够使用Retrofit从网络端点获取数据，使用Moshi将JSON有效载荷解析为Kotlin数据对象，并使用Glide将图片加载到`ImageView`中。
- en: In the previous chapter, we learned how to implement navigation in our app.
    In this chapter, we will learn how to present dynamic content to the user as they
    navigate around our app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在应用中实现导航。在本章中，我们将学习如何在用户在应用中导航时向用户展示动态内容。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Introducing REST, API, JSON, and XML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍REST、API、JSON和XML
- en: Fetching data from a network endpoint
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络端点获取数据
- en: Parsing a JSON response
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析JSON响应
- en: Loading images from a remote URL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从远程URL加载图片
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/Uqtjm](https://packt.link/Uqtjm)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有练习和活动的完整代码可在GitHub上找到，链接为[https://packt.link/Uqtjm](https://packt.link/Uqtjm)。
- en: Introducing REST, API, JSON, and XML
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍REST、API、JSON和XML
- en: Data presented to users can come from different sources. It can be hardcoded
    into an app, but that comes with limitations. To change hardcoded data, we have
    to publish an update to our app. Some data, such as currency exchange rates, the
    real-time availability of assets, and the current weather, cannot be hardcoded
    by its nature. Other data may become outdated, such as the terms of use of an
    app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 呈现给用户的数据可以来自不同的来源。它可能被硬编码到应用中，但这会带来限制。要更改硬编码的数据，我们必须发布应用的更新。某些数据，如货币汇率、资产实时可用性和当前天气，由于其本质不能被硬编码。其他数据可能会过时，如应用的使用条款。
- en: 'In such cases, you usually fetch the relevant data from a server. One of the
    most common architectures for serving such data is **representational state transfer**
    (**REST**) architecture. REST architecture is defined by a set of six constraints:
    client-server architecture, statelessness, cacheability, a layered system, code
    on demand (optional), and a uniform interface.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您通常会从服务器获取相关数据。为这种数据提供服务最常见的一种架构是**表示状态转移**（**REST**）架构。REST架构由一组六个约束定义：客户端-服务器架构、无状态、可缓存性、分层系统、按需代码（可选）和统一接口。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To read more about REST, visit [https://packt.link/YsSRV](https://packt.link/YsSRV).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于REST的信息，请访问[https://packt.link/YsSRV](https://packt.link/YsSRV)。
- en: When applied to a web service **application programming interface** (**API**),
    we get a **Hypertext Transfer Protocol** (**HTTP**)-based RESTful API. The HTTP
    protocol is the foundation of data communication for the World Wide Web, hosted
    on and accessible via the **internet**. It is the protocol used by servers all
    around the world to serve websites to users in the form of HTML documents, images,
    style sheets, and so forth.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于**应用程序编程接口**（**API**）的Web服务时，我们得到基于**超文本传输协议**（**HTTP**）的RESTful API。HTTP协议是万维网数据通信的基础，它托管在互联网上，并通过互联网访问。它是全球服务器用于以HTML文档、图片、样式表等形式向用户提供服务所使用的协议。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An interesting article on this topic can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的一篇有趣的文章可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)找到。
- en: RESTful APIs rely on the standard HTTP methods – `GET`, `POST`, `PUT`, `DELETE`,
    and `PATCH` – to fetch and transform data. These methods allow us to fetch, store,
    delete, and update data entities on remote servers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API依赖于标准的HTTP方法——`GET`、`POST`、`PUT`、`DELETE`和`PATCH`——来获取和转换数据。这些方法允许我们从远程服务器获取、存储、删除和更新数据实体。
- en: We can rely on the built-in Java `HttpURLConnection` class to execute these
    HTTP methods. Alternatively, we can use a library such as `OkHttp`, which offers
    additional features such as gzipping (compressing and decompressing), redirects,
    retries, and both synchronous and asynchronous calls. Interestingly, from Android
    4.4, `HttpURLConnection` is just a wrapper around `OkHttp`. If we choose `OkHttp`,
    we might as well go for **Retrofit** (as we will in this chapter), the current
    industry standard. We can then benefit from its type-safety, which is better suited
    for handling REST calls.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依赖内置的 Java `HttpURLConnection` 类来执行这些 HTTP 方法。或者，我们可以使用像 `OkHttp` 这样的库，它提供了额外的功能，如
    gzip（压缩和解压缩）、重定向、重试以及同步和异步调用。有趣的是，从 Android 4.4 开始，`HttpURLConnection` 只是 `OkHttp`
    的包装器。如果我们选择 `OkHttp`，我们不妨选择 **Retrofit**（正如本章所做的那样），这是当前行业标准。然后我们可以从其类型安全中受益，这对于处理
    REST 调用来说更适合。
- en: Most commonly, data is represented by **JavaScript Object Notation** (**JSON**).
    JSON is a text-based data transfer format. As the name implies, it was derived
    from JavaScript. However, it has since become one of the most popular standards
    for data transfer, and its most modern programming languages have libraries that
    encode or decode data to or from JSON.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况下，数据是通过 **JavaScript 对象表示法**（**JSON**）表示的。JSON 是一种基于文本的数据传输格式。正如其名所示，它源自
    JavaScript。然而，它已经成为了数据传输中最流行的标准之一，并且其最现代的编程语言都有库来编码或解码数据到或从 JSON。
- en: 'A simple JSON payload may look something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 JSON 有效负载可能看起来像这样：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another common data structure used by RESTful services is **Extensible Markup
    Language** (**XML**), which encodes documents in a format that is human- and machine-readable.
    XML is considerably more verbose than JSON. The same data structure as the previous
    in XML would look something like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个由 RESTful 服务常用的数据结构是 **可扩展标记语言**（**XML**），它以人类和机器可读的格式编码文档。XML 比JSON更冗长。在
    XML 中与之前相同的数据结构看起来可能像这样：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this chapter, we will focus on JSON.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于 JSON。
- en: When obtaining a JSON payload, we essentially receive a string. To convert that
    string into a data object, we have a few options, the most popular ones being
    libraries such as `org.json` package. For its lightweight nature, we will focus
    on Moshi.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取 JSON 有效负载时，我们实际上接收的是一个字符串。要将该字符串转换为数据对象，我们有几种选择，最受欢迎的包括 `org.json` 包等库。由于其轻量级特性，我们将关注
    Moshi。
- en: Finally, we will look into loading images from the web. Doing so will allow
    us to provide up-to-date images and load the right images for the user’s device.
    It will also let us only load the images when we need them, thus keeping our APK
    size smaller.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨从网络加载图片。这样做将允许我们提供最新的图片，并为用户的设备加载正确的图片。它还将允许我们仅在需要时加载图片，从而保持我们的 APK
    大小更小。
- en: Fetching data from a network endpoint
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络端点获取数据
- en: For the purpose of this section, we will use The Cat API ([https://thecatapi.com/](https://thecatapi.com/)).
    This RESTful API offers us vast data about, well…cats.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本节的目的，我们将使用 The Cat API ([https://thecatapi.com/](https://thecatapi.com/))。这个
    RESTful API 为我们提供了关于，嗯……猫的大量数据。
- en: 'To get started, we will create a new project. We then have to grant our app
    internet access permission. This is done by adding the following code to your
    `AndroidManifest.xml` file right before the `Application` tag:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建一个新的项目。然后我们必须授予我们的应用程序互联网访问权限。这通过在 `AndroidManifest.xml` 文件中 `Application`
    标签之前添加以下代码来完成：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we need to set up our app to include Retrofit. Retrofit is a type-safe
    library provided by Square, which is built on top of the `OkHttp` HTTP client.
    Retrofit helps us generate **Uniform Resource Locators** (**URLs**), which are
    the addresses of the server endpoints we want to access. It also makes the decoding
    of JSON payloads easier by providing integration with several parsing libraries.
    Sending data to the server is also easier with Retrofit, as it helps with encoding
    the requests.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的应用程序以包含 Retrofit。Retrofit 是由 Square 提供的一个类型安全的库，它建立在 `OkHttp` HTTP
    客户端之上。Retrofit 通过提供与几个解析库的集成来帮助我们生成 **统一资源定位符**（**URL**），这是我们想要访问的服务器端点的地址。它还通过简化
    JSON 有效负载的解码使发送数据到服务器变得更容易。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Retrofit here [https://square.github.io/retrofit/](https://square.github.io/retrofit/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于 Retrofit 的信息 [https://square.github.io/retrofit/](https://square.github.io/retrofit/)。
- en: 'To add Retrofit to our project, we need to add the following code to the `dependencies`
    block of the `build.gradle` file of our app:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Retrofit添加到我们的项目中，我们需要将以下代码添加到我们应用`build.gradle`文件的`dependencies`块中：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the latest version here [https://github.com/square/retrofit](https://github.com/square/retrofit).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到最新版本[https://github.com/square/retrofit](https://github.com/square/retrofit)。
- en: With Retrofit included in our project, we can proceed to set it up.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中包含Retrofit之后，我们可以继续设置它。
- en: 'First, to access an HTTP(S) endpoint, we start by defining the contract with
    that endpoint. A contract to access the `https://api.thecatapi.com/v1/images/search`
    endpoint looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了访问一个HTTP(S)端点，我们首先定义与该端点的合约。访问`https://api.thecatapi.com/v1/images/search`端点的合约看起来是这样的：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are a few things to note here. First, you will notice that the contract
    is implemented as an interface. This is how you define contracts for Retrofit.
    Next, you will notice that the name of the interface implies that this interface
    can, eventually, cover all calls made to `TheCatAPIService`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些需要注意的事项。首先，你会注意到合约是以接口的形式实现的。这就是定义Retrofit合约的方式。接下来，你会注意到接口的名称暗示了这个接口最终可以覆盖对`TheCatAPIService`的所有调用。
- en: It is a bit unfortunate that Square chose `Service` as the conventional suffix
    for these contracts, as the term service has a different meaning in the Android
    world, as you will see in [*Chapter 8*](B19411_08.xhtml#_idTextAnchor471), *Services,
    WorkManager, and Notifications*. Nevertheless, this is the convention.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，Square将这些合约的传统后缀选为`Service`，因为在Android世界中，术语`service`有不同的含义，正如你在[*第8章*](B19411_08.xhtml#_idTextAnchor471)中将要看到的，*服务、WorkManager和通知*。尽管如此，这已经成为了一种惯例。
- en: To define our endpoint, we start by stating the method with which the call will
    be made using the appropriate annotation—in our case, `@GET`. The parameter passed
    to the annotation is the path of the endpoint to access. You’ll notice that `https://api.thecatapi.com/v1/`
    is stripped from that path.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的端点，我们首先使用适当的注解声明将要使用的调用方法——在我们的例子中，是`@GET`。传递给注解的参数是要访问的端点路径。你会注意到`https://api.thecatapi.com/v1/`已经被从该路径中移除。
- en: That is because this is the common address for all of the endpoints of `TheCatAPI`,
    and so it will be passed to our Retrofit instance at construction time instead.
    Next, we choose a meaningful name for our function—in this case, we'll call the
    image search endpoint, so `searchImages` seems appropriate. The parameters of
    the `searchImages` function define the values we can pass to the API when we make
    the calls.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这是`TheCatAPI`所有端点的通用地址，因此它将在构造时传递给我们的Retrofit实例。接下来，我们为我们的函数选择一个有意义的名称——在这种情况下，我们将调用图像搜索端点，所以`searchImages`似乎很合适。`searchImages`函数的参数定义了我们在调用API时可以传递的值。
- en: There are different ways in which we can transfer data to the API. `@Query`
    allows us to define values added to the query of our request URL (that’s the optional
    part of the URL that comes after the question mark). It takes a key-value pair
    (in our case, we have `limit` and `size`) and a data type. If the data type is
    not a string, the value of that type will be transformed into a string. Any value
    passed will be URL-encoded for us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种不同的方式可以将数据传输到API。`@Query`允许我们定义添加到请求URL查询中的值（这是URL中问号之后的可选部分）。它需要一个键值对（在我们的例子中，我们有`limit`和`size`）和一个数据类型。如果数据类型不是字符串，该类型的值将被转换为字符串。任何传递的值都将为我们进行URL编码。
- en: Another such way is using `@Path`. This annotation can be used to replace a
    token in our path wrapped in curly brackets with a provided value. The `@Header`,
    `@Headers`, and `@HeaderMap` annotations will allow us to add or remove HTTP headers
    from the request. `@Body` can be used to pass content in the body of the `POST`
    and `PUT` requests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是使用`@Path`。这个注解可以用来用提供的值替换我们路径中用花括号包裹的标记。`@Header`、`@Headers`和`@HeaderMap`注解将允许我们在请求中添加或删除HTTP头。`@Body`可以用来在`POST`和`PUT`请求的体中传递内容。
- en: Lastly, we have a return type. To keep things simple at this stage, we will
    accept the response as a string. We wrapped our string in a `Call` interface.
    `Call` is Retrofit’s mechanism for executing network requests synchronously (via
    `execute()`) or asynchronously (via `enqueue(Callback)`). When using coroutines,
    we can make the function a `suspend` function and omit the `Call` wrapper (see
    [*Chapter 14*](B19411_14.xhtml#_idTextAnchor751)*, Coroutines and Flow*, for more
    information on coroutines).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个返回类型。为了在这个阶段保持简单，我们将接受响应作为字符串。我们将我们的字符串包装在 `Call` 接口内。`Call` 是 Retrofit
    执行网络请求的机制，可以是同步的（通过 `execute()`）或异步的（通过 `enqueue(Callback)`）。当使用协程时，我们可以使函数成为一个
    `suspend` 函数，并省略 `Call` 包装器（有关协程的更多信息，请参见 [*第 14 章*](B19411_14.xhtml#_idTextAnchor751)，*协程和
    Flow*）。
- en: 'With our contract defined, we can get Retrofit to implement our service interface:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的合约定义之后，我们可以让 Retrofit 实现我们的服务接口：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we try to run our app with this code, our app will crash with an `IllegalArgumentException`.
    This is because Retrofit needs us to tell the app how to process the server response
    to a string. This processing is done with what Retrofit calls `ConverterFactory`
    instance to our `retrofit` instance, we need to add the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行带有此代码的应用程序，我们的应用程序将因 `IllegalArgumentException` 而崩溃。这是因为 Retrofit 需要我们告诉应用程序如何处理服务器响应字符串。这个过程是通过
    Retrofit 调用 `ConverterFactory` 实例到我们的 `retrofit` 实例来完成的，我们需要添加以下内容：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For our project to recognize `ScalarsConverterFactory`, we need to update our
    app’s `build.gradle` file by adding another dependency:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的项目识别 `ScalarsConverterFactory`，我们需要通过在应用程序的 `build.gradle` 文件中添加另一个依赖项来更新它：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we can obtain a `Call` instance by calling `val call = theCatApiService.searchImages(1,
    "full")`. With the instance obtained in this fashion, we can execute an async
    request by calling `call.enqueue(Callback)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过调用 `val call = theCatApiService.searchImages(1, "full")` 来获取一个 `Call`
    实例。通过这种方式获得的实例，我们可以通过调用 `call.enqueue(Callback)` 来执行异步请求。
- en: 'Our `Callback` implementation will have two methods: `onFailure(Call, Throwable)`
    and `onResponse(Call, Response)`. Note that we are not guaranteed to have a successful
    response if `onResponse` is called. `onResponse` is called whenever we successfully
    receive *any* response from the server, and no unexpected exception occurs.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Callback` 实现将有两个方法：`onFailure(Call, Throwable)` 和 `onResponse(Call, Response)`。请注意，如果调用
    `onResponse`，我们并不保证会有一个成功的响应。`onResponse` 在我们成功从服务器接收到 *任何* 响应且没有发生意外异常时被调用。
- en: So, to confirm that the response is successful, we should check the `response.isSuccessful`
    property. The `onFailure` function will be called in the case of a network error
    or an unexpected exception somewhere along the way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确认响应是成功的，我们应该检查 `response.isSuccessful` 属性。在发生网络错误或过程中某个地方出现意外异常的情况下，将调用
    `onFailure` 函数。
- en: So, where should we implement the Retrofit code? In clean architecture, data
    is provided by repositories. Repositories, in turn, have data sources. One such
    data source can be a network data source. This is where we will implement our
    network calls. Our ViewModels will then request data from repositories via use
    cases.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们应该在哪里实现 Retrofit 代码呢？在干净的架构中，数据由仓库提供。仓库反过来又拥有数据源。其中一个数据源可以是一个网络数据源。这就是我们将实现我们的网络调用的地方。然后，我们的
    ViewModels 将通过用例从仓库请求数据。
- en: In the case of **Model-View-ViewModel** (**MVVM**), the ViewModel is an abstraction
    of the view that exposes properties and commands.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **模型-视图-视图模型**（**MVVM**）的情况下，视图模型是视图的抽象，它公开属性和命令。
- en: For our implementation, we will simplify the process by instantiating Retrofit
    and the service in the Activity. This is not good practice. *Do not do this in
    a production app*. It does not scale well and is very difficult to test. Instead,
    adopt an architecture that decouples your views from your business logic and your
    data. See [*Chapter 15*](B19411_15.xhtml#_idTextAnchor789), *Architecture Patterns*,
    for some ideas.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们将通过在 Activity 中实例化 Retrofit 和服务来简化这个过程。这不是一个好的实践。*不要在生产应用中这样做*。它扩展性不好，并且很难测试。相反，采用一种将你的视图与你的业务逻辑和数据解耦的架构。参见
    [*第 15 章*](B19411_15.xhtml#_idTextAnchor789)，*架构模式*，以获取一些想法。
- en: Exercise 5.01 – reading data from an API
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01 – 从 API 读取数据
- en: 'In the following chapters, we will develop an app for an imaginary secret agency
    with a worldwide network of agents saving the world from countless dangers. The
    secret agency in question is quite unique: it operates secret cat agents.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将开发一个为一家虚构的秘密机构开发的应用程序，该机构在全球范围内拥有特工网络，拯救世界免受无数危险。这个秘密机构相当独特：它运营着秘密的猫特工。
- en: 'In this exercise, we will create an app that presents us with one random secret
    cat agent from The Cat API. Before you can present data from an API to your user,
    you first must fetch that data. Let’s start with that here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个应用，它从 The Cat API 中随机展示一个秘密猫特工。在你能够向用户展示 API 数据之前，你首先必须获取这些数据。让我们从这里开始：
- en: Create a new **Empty Activity** project (**File** | **New** | **New Project**
    | **Empty Activity**). Click **Next**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **空活动** 项目（**文件** | **新建** | **新建项目** | **空活动**）。点击 **下一步**。
- en: Name your application `Cat` `Agent Profile`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的应用程序命名为 `Cat Agent Profile`。
- en: Make sure your package name is `com.example.catagentprofile`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的包名是 `com.example.catagentprofile`。
- en: Set **Save location** to where you want to save your project.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **保存位置** 设置为你想要保存项目的地方。
- en: Leave everything else at its default values and click **Finish**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有内容保留为默认值并点击 **完成**。
- en: 'Make sure you are on the **Android** view in your **Project** pane:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你处于 **Android** 视图在你的 **项目** 窗格中：
- en: '![Figure 5.1 – The Android view in the Project pane](img/B19411_05_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 项目窗格中的 Android 视图](img/B19411_05_01.jpg)'
- en: Figure 5.1 – The Android view in the Project pane
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 项目窗格中的 Android 视图
- en: 'Open your `AndroidManifest.xml` file. Add internet permissions to your app
    like so:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `AndroidManifest.xml` 文件。向你的应用添加如下互联网权限：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To add Retrofit and the scalars converter to your app, open the `build.gradle`
    app module, (`Gradle Scripts` | `build.gradle (Module: app)`), and add the following
    lines anywhere inside the `dependencies` block:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '要将 Retrofit 和标量转换器添加到你的应用中，打开 `build.gradle` 应用模块（`Gradle 脚本` | `build.gradle
    (Module: app)`），并在 `dependencies` 块内添加以下行：'
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Your `dependencies` block should now look something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `dependencies` 块现在可能看起来像这样：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Between the time of writing and when you carry out this exercise, some dependencies
    may have changed. You should still only add the lines in bold from the preceding
    code block. These will add Retrofit and support for reading server responses as
    single strings.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文和执行此练习之间，一些依赖项可能已更改。你仍然只需添加前面代码块中加粗的行。这些行将添加 Retrofit 和读取服务器响应作为单个字符串的支持。
- en: Note
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: It is worth noting that Retrofit now requires, as a minimum, Android API 21
    or Java 8.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Retrofit 现在至少需要 Android API 21 或 Java 8。
- en: Click the **Sync Project with Gradle Files** button in Android Studio.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Android Studio 中的 **同步项目与 Gradle 文件** 按钮。
- en: Open your `activity_main.xml` file in the **Text** mode.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 **文本** 模式打开你的 `activity_main.xml` 文件。
- en: 'To be able to use your label to present the latest server response, you need
    to assign an ID to it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够使用你的标签来展示最新的服务器响应，你需要给它分配一个 ID：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the `com.example.catagentprofile`), then select **New** | **Package**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.catagentprofile` 中，然后选择 **新建** | **包**。
- en: Name your package `api`.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的包命名为 `api`。
- en: Now, right-click on the newly created package (`com.example.catagentprofile.api`),
    then select **New** | **Kotlin File/Class**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 **项目** 窗格中右键单击新创建的包（`com.example.catagentprofile.api`），然后选择 **新建** | **Kotlin
    文件/类**。
- en: Name your new file `TheCatApiService`. For **Kind**, choose **Interface**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的新文件命名为 `TheCatApiService`。对于 **类型**，选择 **接口**。
- en: 'Add the following to the `interface` block:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `interface` 块中：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This defines the image search endpoint. Make sure to import all the required
    Retrofit dependencies.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了图像搜索端点。请确保导入所有必需的 Retrofit 依赖项。
- en: Open your `MainActivity` file.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的 `MainActivity` 文件。
- en: 'At the top of the `MainActivity` class block, add the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 类块顶部添加以下内容：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will instantiate Retrofit and the API service. We use `lazy` to make sure
    the instances are only created when needed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将实例化 Retrofit 和 API 服务。我们使用 `lazy` 确保实例仅在需要时创建。
- en: 'Add `serverResponseView` as a field:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `serverResponseView` 作为字段：
- en: '[PRE14]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will look up the view with the `main_server_response` ID the first time
    `serverResponseView` is accessed and then keep a reference to it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在第一次访问 `serverResponseView` 时查找具有 `main_server_response` ID 的视图，并保留对该视图的引用。
- en: 'Now, add the `getCatImageResponse()` function after the `onCreate(Bundle?)`
    function:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `onCreate(Bundle?)` 函数之后添加 `getCatImageResponse()` 函数：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function will fire off the search request and handle the possible outcomes—a
    successful response, an error response, and any other thrown exception.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将触发搜索请求并处理可能的结果——成功响应、错误响应以及任何其他抛出的异常。
- en: 'Invoke a call to `getCatImageResponse()` in `onCreate()`. This will trigger
    the call as soon as the activity is created:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 中调用 `getCatImageResponse()`。这将触发调用，一旦活动创建完成：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add the missing imports.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加缺失的导入。
- en: 'Run your app by clicking the **Run ‘app’** button or pressing *Ctrl* + *R*.
    On the emulator, it should look like this:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**运行‘app’**按钮或按*Ctrl* + *R*来运行你的应用。在模拟器上，它应该看起来像这样：
- en: '![Figure 5.2 – The app presenting the server response JSON](img/B19411_05_02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – 应用展示服务器响应的JSON](img/B19411_05_02.jpg)'
- en: Figure 5.2 – The app presenting the server response JSON
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 应用展示服务器响应的JSON
- en: Because every time you run your app, a new call is made, and a random response
    is returned, your result will likely differ. However, whatever your result, if
    successful, it should be a JSON payload. Next, we will learn how to parse that
    JSON payload and extract the data we want from it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每次运行你的应用时，都会发起一个新的调用，并返回一个随机响应，所以你的结果可能会不同。然而，无论结果如何，如果成功，它应该是一个JSON负载。接下来，我们将学习如何解析这个JSON负载并从中提取我们想要的数据。
- en: Parsing a JSON response
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON响应
- en: Now that we have successfully retrieved a JSON response from an API, it is time
    to learn how to use the data we have obtained. To do so, we need to parse the
    JSON payload. This is because the payload is a plain string representing the data
    object, and we are interested in the specific properties of that object. If you
    look closely at *Figure 5**.2*, you may notice that the JSON contains breed information,
    an image URL, and some other bits of information. However, for our code to use
    that information, first, we must extract it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功从API中检索到了JSON响应，是时候学习如何使用我们获得的数据了。为此，我们需要解析JSON负载。这是因为负载是一个表示数据对象的普通字符串，而我们感兴趣的是该对象的具体属性。如果你仔细看*图5**.2*，你可能会注意到JSON包含品种信息、一个图片URL和一些其他信息。然而，为了我们的代码能够使用这些信息，首先，我们必须提取它们。
- en: As mentioned in the introduction, multiple libraries exist that will parse a
    JSON payload for us. The most popular ones are Google’s GSON (see [https://github.com/google/gson](https://github.com/google/gson))
    and, more recently, Square’s Moshi (see [https://github.com/square/moshi](https://github.com/square/moshi)).
    Moshi is very lightweight, which is why we have chosen to use it in this chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，存在多个库可以帮助我们解析JSON负载。最受欢迎的是Google的GSON（见[https://github.com/google/gson](https://github.com/google/gson)）和更近期的Square的Moshi（见[https://github.com/square/moshi](https://github.com/square/moshi)）。Moshi非常轻量级，这就是为什么我们选择在本章中使用它。
- en: What do JSON libraries do? Basically, they help us convert data classes into
    JSON strings (serialization) and vice versa (deserialization). This helps us communicate
    with servers that understand JSON strings while allowing us to use meaningful
    data structures in our code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: JSON库的作用是什么？基本上，它们帮助我们将数据类转换为JSON字符串（序列化）以及相反的过程（反序列化）。这有助于我们与理解JSON字符串的服务器进行通信，同时允许我们在代码中使用有意义的结构化数据。
- en: 'To use Moshi with Retrofit, we need to add the Moshi Retrofit converter to
    our project. This is done by adding the following line to the `dependencies` block
    of our app’s `build.gradle` file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Retrofit中使用Moshi，我们需要将Moshi Retrofit转换器添加到我们的项目中。这是通过将以下行添加到我们应用的`build.gradle`文件中的`dependencies`块来完成的：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since we will no longer the responses as strings, we can go ahead and remove
    the scalars Retrofit converter. Next, we need to create a data class to map the
    server JSON response to. One convention is to suffix the names of API response
    data classes with `Data`—so we’ll call our data class `ImageResultData`. Another
    common suffix is `Entity`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再将响应作为字符串处理，我们可以继续移除Retrofit的标量转换器。接下来，我们需要创建一个数据类来映射服务器JSON响应。一个约定是将API响应数据类的名称后缀为`Data`——所以我们将我们的数据类命名为`ImageResultData`。另一个常见的后缀是`Entity`。
- en: 'When we design our server response data classes, we need to take two factors
    into account: the structure of the JSON response and our data requirements. The
    first will affect our data types and field names, while the second will allow
    us to omit fields we do not currently need. JSON libraries ignore data in fields
    we have not defined in our data classes.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计服务器响应的数据类时，需要考虑两个因素：JSON响应的结构和我们的数据需求。第一个将影响我们的数据类型和字段名称，而第二个将允许我们省略当前不需要的字段。JSON库会忽略我们在数据类中未定义的字段中的数据。
- en: One more thing JSON libraries do for us is automatically map JSON data to fields
    if they happen to have the exact same name. While this is a nice feature, it carries
    risk. If we rely solely on it, our data classes (and the code accessing them)
    will be tightly coupled to the API naming.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JSON库为我们做的另一件事是自动将JSON数据映射到字段，如果它们恰好有相同的名称。虽然这是一个很好的特性，但它也带来了风险。如果我们完全依赖它，我们的数据类（以及访问它们的代码）将与API命名紧密耦合。
- en: 'Because not all APIs are designed well, you might end up with meaningless field
    names, such as `fn` or `last`, or inconsistent naming. Luckily, there is a solution
    to this problem. Moshi provides us with an `@Json` annotation. It can be used
    to map a JSON field name to a meaningful field name:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有 API 都设计得很好，你可能会遇到没有意义的字段名称，如 `fn` 或 `last`，或者不一致的命名。幸运的是，有一个解决方案可以解决这个问题。Moshi
    提供了一个 `@Json` 注解。它可以用来将 JSON 字段名称映射到一个有意义的字段名称：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `field:` prefix is used to ensure the generated Java field is annotated
    correctly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `field:` 前缀来确保生成的 Java 字段被正确注解。
- en: Some consider it better practice to include the annotation even when the API
    name is the same as the field name for the sake of consistency. We prefer the
    conciseness of direct conversion when the field name is clear enough. This approach
    can be challenged when obfuscating our code. If we do, we must either exclude
    our data classes or make sure to annotate all fields.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为，即使 API 名称与字段名称相同，为了保持一致性，最好还是包含该注解。我们更喜欢当字段名称足够清晰时直接转换的简洁性。当我们的代码被混淆时，这种方法可能会受到挑战。如果我们这样做，我们必须排除我们的数据类或者确保所有字段都被注解。
- en: While we are not always lucky enough to have properly documented APIs, when
    we do, it is best to consult the documentation when designing our model. Our model
    would be a data class into which the JSON data from all calls we make will be
    decoded. The documentation for the image search endpoint of The Cat API can be
    found at [https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/](https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们并不总是有幸拥有文档齐全的 API，但当我们确实有文档时，在设计我们的模型时最好查阅文档。我们的模型将是一个数据类，我们将在其中解码我们发出的所有调用的
    JSON 数据。The Cat API 的图像搜索端点的文档可以在 [https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/](https://protect-eu.mimecast.com/s/d7uqCWwlKf56Q17s6kKb5?domain=developers.thecatapi.com/)
    找到。
- en: You will often find documentation is or inaccurate. If this happens to be the
    case, the best thing you can do is contact the owners of the API and request that
    they update the documentation. You may have to resort to experimenting with an
    endpoint, unfortunately. This is risky because undocumented fields or structures
    are not guaranteed to remain the same, so when possible, try and get the documentation
    updated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常会发现文档是不准确或错误的。如果这种情况发生，最好的办法是联系 API 的所有者，并要求他们更新文档。不幸的是，你可能不得不求助于对端点的实验。这是有风险的，因为未记录的字段或结构不保证保持不变，所以当可能时，尽量让文档得到更新。
- en: 'Based on the response schema obtained from the preceding link, we can define
    our model as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 根据从先前的链接中获得的响应模式，我们可以定义我们的模型如下：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the response structure is that of a list of results. This means we
    need our responses mapped to `List<ImageResultData>`, not simply `ImageResultData`.
    Now, we need to update `TheCatApiService`. Instead of `Call<String>`, we can now
    have `Call<List<ImageResultData>>`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，响应结构是结果列表。这意味着我们需要将响应映射到 `List<ImageResultData>`，而不仅仅是 `ImageResultData`。现在，我们需要更新
    `TheCatApiService`。我们可以不再使用 `Call<String>`，而是现在可以使用 `Call<List<ImageResultData>>`。
- en: 'Next, we need to update the construction of our Retrofit instance. Instead
    of `ScalarsConverterFactory`, we will now have `MoshiConverterFactory`. Lastly,
    we need to update our callback since it should no longer handle string calls but
    `List<ImageResultData>` instead:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的 Retrofit 实例的构建。我们将不再使用 `ScalarsConverterFactory`，而是现在将使用 `MoshiConverterFactory`。最后，我们需要更新我们的回调，因为它不再应该处理字符串调用，而是应该处理
    `List<ImageResultData>`：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Exercise 5.02 – extracting the image URL from the API response
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02 – 从 API 响应中提取图像 URL
- en: 'So, we have a server response as a string. Now, we want to extract the image
    URL from that string and present only that URL on the screen:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个作为字符串的服务器响应。现在，我们想要从该字符串中提取图像 URL，并在屏幕上仅显示该 URL：
- en: 'Open the app’s `build.gradle` file and replace the scalars converter implementation
    with a Moshi converter one:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用的 `build.gradle` 文件，并将标量转换器的实现替换为 Moshi 转换器的一个：
- en: '[PRE21]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Click the **Sync Project with Gradle** **Files** button.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**同步项目与 Gradle 文件**按钮。
- en: Under your app package (`com.example.catagentprofile`), create a `model` package.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用包（`com.example.catagentprofile`）下创建一个 `model` 包。
- en: Within the `com.example.catagentprofile.model` package, create a new Kotlin
    file named `CatBreedData`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `com.example.catagentprofile.model` 包中，创建一个名为 `CatBreedData` 的新 Kotlin 文件。
- en: 'Populate the newly created file with the following:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的文件中填充以下内容：
- en: '[PRE22]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, create `ImageResultData` under the same package.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在相同的包下创建 `ImageResultData`。
- en: 'Set its contents to the following:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其内容如下：
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open the `TheCatApiService` file and update the `searchImages` return type:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`TheCatApiService`文件并更新`searchImages`的返回类型：
- en: '[PRE24]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Lastly, open `MainActivity`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，打开`MainActivity`。
- en: 'Update the Retrofit initialization block to use the Moshi converter to deserialize
    JSON:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Retrofit初始化块以使用Moshi转换器反序列化JSON：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Update the `getCatImageResponse()` function to handle the `List<ImageResultData>`
    requests and responses:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getCatImageResponse()`函数以处理`List<ImageResultData>`请求和响应：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, you need to check for a successful response and that there is at least
    one `ImageResultData` instance. You can then read the `imageUrl` property of that
    instance and present it to the user.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要检查是否有成功的响应，并且至少有一个`ImageResultData`实例。然后，您可以读取该实例的`imageUrl`属性并将其展示给用户。
- en: 'Run your app. It should now look something like the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。现在它应该看起来像以下这样：
- en: '![Figure 5.3 – The app presenting the parsed image URL](img/B19411_05_03.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – 应用展示解析后的图片URL](img/B19411_05_03.jpg)'
- en: Figure 5.3 – The app presenting the parsed image URL
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 应用展示解析后的图片URL
- en: Again, due to the random nature of the API responses, your URL will likely be
    different.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，由于API响应的随机性，您的URL可能不同。
- en: You have now successfully extracted a specific property from an API response.
    Next, we will learn how to load the image from the URL provided to us by the API.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已成功从API响应中提取了特定的属性。接下来，我们将学习如何从API提供的URL加载图片。
- en: Loading images from a remote URL
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从远程URL加载图片
- en: We just learned how to extract data from an API response. That data often includes
    URLs to images we want to present to the user. There is quite a bit of work involved
    in achieving that. First, you must fetch the image as a binary stream from the
    URL. Then, you need to transform that binary stream into an image (it could be
    a GIF, JPEG, or one of a few other image formats).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学习了如何从API响应中提取数据。这些数据通常包括我们想要展示给用户的图片的URL。要实现这一点，涉及的工作量相当大。首先，您必须从URL获取图片作为二进制流。然后，您需要将那个二进制流转换成图片（它可能是GIF、JPEG或其他几种图像格式之一）。
- en: Then, you need to convert it into a bitmap instance, potentially resizing it
    to use less memory. You may also want to apply other transformations to it at
    that point. Then, you need to set it to `ImageView`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将其转换为位图实例，可能需要调整大小以节省内存。您还可能想在此处应用其他转换。然后，您需要将其设置到`ImageView`。
- en: Sounds like a lot of work, doesn’t it? Well, luckily for us, there are a few
    libraries that do all of that (and more) for us. The most commonly used libraries
    are Square’s **Picasso** (see [https://square.github.io/picasso/](https://square.github.io/picasso/))
    and **Glide** by Bump Technologies (see [https://github.com/bumptech/glide](https://github.com/bumptech/glide)).
    Facebook’s **Fresco** (see [https://frescolib.org/](https://frescolib.org/)) is
    somewhat less popular. A library that’s gained traction recently is **Coil** (see
    [https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/)).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来像是一项繁重的工作，不是吗？幸运的是，对我们来说，有几个库可以为我们完成所有这些工作（甚至更多）。最常用的库是Square的**Picasso**（见[https://square.github.io/picasso/](https://square.github.io/picasso/))和Bump
    Technologies的**Glide**。Facebook的**Fresco**（见[https://frescolib.org/](https://frescolib.org/))相对不太受欢迎。最近获得关注的一个库是**Coil**（见[https://coil-kt.github.io/coil/](https://coil-kt.github.io/coil/))。
- en: We will proceed with Glide because it is consistently the fastest of the two
    popular options for loading images, whether from the internet or the cache. However,
    it’s worth noting that Picasso is more lightweight, so it is a trade-off, and
    both libraries are quite useful.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用Glide，因为它始终是两种流行的图像加载选项中最快的，无论是从互联网还是从缓存中加载。然而，值得注意的是，Picasso更轻量级，因此这是一个权衡，这两个库都非常有用。
- en: 'To include Glide in your project, add it to the `dependencies` block of your
    app’s `build.gradle` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Glide添加到您的项目中，将其添加到应用程序的`build.gradle`文件中的`dependencies`块：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In fact, because we might change our minds at a later point, this is a great
    opportunity to abstract away the concrete library to have a simpler interface
    of our own. So, let’s start by defining our `ImageLoader` interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，因为我们可能在以后改变主意，这是一个很好的机会将具体的库抽象出来，以拥有我们自己的更简单的接口。所以，让我们首先定义我们的`ImageLoader`接口：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a naïve implementation. In a production implementation, you might want
    to add arguments (or multiple functions) to support options such as different
    cropping strategies or loading states.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现。在生产实现中，您可能希望添加参数（或多个函数）以支持不同的裁剪策略或加载状态等选项。
- en: 'Our implementation of the interface will rely on Glide, so it will look something
    like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对接口的实现将依赖于 Glide，所以看起来可能像这样：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We prefix our class name with `Glide` to differentiate it from other potential
    implementations. Constructing `GlideImageLoader` with `context` allows us to implement
    the clean `loadImage(String, ImageView)` interface without having to worry about
    the context, which Glide requires for image loading.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类名前加上 `Glide` 以区分其他可能的实现。使用 `context` 构建出 `GlideImageLoader` 允许我们实现干净的 `loadImage(String,
    ImageView)` 接口，而无需担心上下文，这是 Glide 加载图像所必需的。
- en: In fact, Glide is smart about the Android context. That means we could have
    separate implementations for the `Activity` and `Fragment` scopes, and Glide would
    know when an image-loading request went beyond the relevant scope.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Glide 对 Android 上下文非常智能。这意味着我们可以为 `Activity` 和 `Fragment` 范围分别实现不同的实现，并且
    Glide 会知道当图像加载请求超出相关范围时。
- en: 'Since we haven’t yet added an `ImageView` to our layout, let’s do that now:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有将 `ImageView` 添加到布局中，让我们现在就做：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will add an `ImageView` with an ID of `main_profile_image` below our `TextView`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的 `TextView` 下方添加一个 ID 为 `main_profile_image` 的 `ImageView`。
- en: 'We can now create an instance of `GlideImageLoader` in `MainActivity`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在 `MainActivity` 中创建 `GlideImageLoader` 的实例：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In a production app, you would inject the dependency, rather than creating it
    inline.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产应用中，你会注入依赖项，而不是直接创建。
- en: 'Next, we tell our Glide loader to load the image and, once loaded, center-crop
    it inside the provided `ImageView`. This means the image will be scaled up or
    down to fully fill the `ImageView`, with any excess content cut off (cropped).
    Since we already obtained an image URL before, all we need to do is make the call:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们告诉我们的 Glide 加载器加载图像，并在加载完成后将其中心裁剪到提供的 `ImageView` 中。这意味着图像将被缩放或缩小以完全填充
    `ImageView`，任何多余的内容将被裁剪掉。由于我们之前已经获取了一个图像 URL，我们只需要进行调用：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have to ensure the result contains a string that is not empty or made of
    spaces (`isBlank()` in the preceding code block). Then, we can safely load the
    URL into `ImageView`. And we’re done. If we run our app now, we should see something
    like the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保结果包含一个非空或由空格组成的字符串（前一个代码块中的 `isBlank()`）。然后，我们可以安全地将 URL 加载到 `ImageView`
    中。完成。如果我们现在运行我们的应用，我们应该会看到以下截图：
- en: '![Figure 5.4 – Server response image URL with the actual image](img/B19411_05_04.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 服务器响应图像 URL 与实际图像](img/B19411_05_04.jpg)'
- en: Figure 5.4 – Server response image URL with the actual image
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 服务器响应图像 URL 与实际图像
- en: Remember that the API returns random results, so the actual image is likely
    to be different. If we’re lucky, we might even get an animated GIF, which we would
    then see animated.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 API 返回的是随机结果，所以实际图像可能不同。如果我们很幸运，甚至可能会得到一个动画 GIF，我们将会看到它动画播放。
- en: Exercise 5.03 – loading the image from the obtained URL
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.03 – 从获取的 URL 加载图像
- en: 'In the previous exercise, we extracted the image URL from the API response.
    Now, we will use that URL to fetch an image from the web and display it in our
    app:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们从 API 响应中提取了图像 URL。现在，我们将使用该 URL 从网络获取图像并在我们的应用中显示：
- en: 'Open the app’s `build.gradle` file and add the Glide dependency:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开应用的 `build.gradle` 文件并添加 Glide 依赖：
- en: '[PRE33]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Synchronize your project with the Gradle files.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目与 Gradle 文件同步。
- en: On the left `com.example.catagentprofile`) and select **New** | **Kotlin File/Class**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧 `com.example.catagentprofile`) 上右键单击并选择 **新建** | **Kotlin 文件/类**。
- en: Fill in `ImageLoader` in the **Name** field. For **Kind**, choose **Interface**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **名称** 字段中填写 `ImageLoader`。对于 **类型**，选择 **接口**。
- en: 'Open the newly created `ImageLoader.kt` file and update it like so:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新创建的 `ImageLoader.kt` 文件并更新如下：
- en: '[PRE34]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will be your interface for any image loader in the app.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是应用中任何图像加载器的接口。
- en: Right-click on the project package name again and select **New** | **Kotlin
    File/Class**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次右键单击项目包名并选择 **新建** | **Kotlin 文件/类**。
- en: Name the new file `GlideImageLoader` and select **Class** for **Kind**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为 `GlideImageLoader` 并选择 **类** 作为 **类型**。
- en: 'Update the newly created file:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新新创建的文件：
- en: '[PRE35]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Open `activity_main.xml` and update it like so:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并更新如下：
- en: '[PRE36]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will add an `ImageView` named `main_profile_image` below `TextView`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 `TextView` 下方添加一个名为 `main_profile_image` 的 `ImageView`。
- en: Open the `MainActivity.kt` file.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.kt` 文件。
- en: 'Add a field for your newly added `ImageView` at the top of your class:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加一个字段用于你新添加的 `ImageView`：
- en: '[PRE37]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define `ImageLoader` just above the `onCreate(Bundle?)` function:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate(Bundle?)` 函数上方定义 `ImageLoader`：
- en: '[PRE38]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Update your `getCatImageResponse()` function like so:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的 `getCatImageResponse()` 函数如下：
- en: '[PRE39]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, once you have a non-blank URL, it will be loaded into `profileImageView`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，一旦您有一个非空 URL，它将被加载到 `profileImageView`。
- en: 'Run the app:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序：
- en: '![Figure 5.5 – Exercise outcome showing a random image and its source URL](img/B19411_05_05.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 展示随机图像及其源 URL 的练习结果](img/B19411_05_05.jpg)'
- en: Figure 5.5 – Exercise outcome showing a random image and its source URL
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 展示随机图像及其源 URL 的练习结果
- en: The following are bonus steps.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些附加步骤。
- en: 'Update your layout like so:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的布局如下：
- en: '[PRE40]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will add an `Agent breed` label and tidy up the view layout. Now, your
    layout looks a bit more like a proper cat agent profile app.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加一个 `Agent breed` 标签并整理视图布局。现在，您的布局看起来更像是一个正规的猫代理配置文件应用程序。
- en: 'In `MainActivity.kt`, locate the following lines:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity.kt` 中定位以下行：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replace the preceding lines with the following to look up the new name field:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下内容以查找新的名称字段：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update `getCatImageResponse()` like so:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `getCatImageResponse()` 如下：
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This is done to load the first breed returned from the API into `agentNameView`,
    with a fallback to `Unknown`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了将 API 返回的第一个品种加载到 `agentNameView` 中，如果失败则显示 `Unknown`。
- en: 'At the time of writing, not many pictures in The Cat API have breed data. However,
    if you run your app enough times, you will end up seeing something like this:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本文时，The Cat API 中没有多少图片包含品种数据。然而，如果您运行应用程序足够多次，您最终会看到如下内容：
- en: '![Figure 5.6 – Showing the cat agent image and breed](img/B19411_05_06.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 展示猫代理图像和品种](img/B19411_05_06.jpg)'
- en: Figure 5.6 – Showing the cat agent image and breed
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 展示猫代理图像和品种
- en: In this chapter, we learned how to fetch data from a remote API. We then learned
    how to process that data and extract the information we needed from it. Lastly,
    we learned how to present an image on the screen when given an image URL.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何从远程 API 获取数据。然后我们学习了如何处理这些数据并从中提取所需的信息。最后，我们学习了如何在给定图像 URL 的情况下在屏幕上显示图像。
- en: In the following activity, we will apply our knowledge to develop an app that
    tells the user the current weather in New York, presenting the user with a relevant
    weather icon.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下活动中，我们将应用我们的知识来开发一个应用程序，该应用程序会告诉用户纽约当前的天气，并向用户提供相关的天气图标。
- en: Activity 5.01 – displaying the current weather
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第 5.01 部分 – 显示当前天气
- en: Let’s say we want to build an app that shows the current weather in New York.
    Furthermore, we also want to display an icon representing the current weather.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要构建一个显示纽约当前天气的应用程序。此外，我们还想显示代表当前天气的图标。
- en: This activity aims to create an app that polls an API endpoint for the current
    weather in JSON format, transforms that data into a local model, and uses that
    model to present the current weather. It also extracts the URL to an icon representing
    the current weather and fetches that icon to be displayed on the screen.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动旨在创建一个应用程序，该应用程序轮询 API 端点以获取当前天气的 JSON 格式，将数据转换为本地模型，并使用该模型来显示当前天气。它还提取表示当前天气的图标
    URL 并将其图标加载到屏幕上显示。
- en: We will use the free OpenWeatherMap API for the purpose of this activity. The
    documentation can be found at [https://openweathermap.org/api](https://openweathermap.org/api).
    To sign up for an API token, please go to [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up).
    You can find your keys and generate new ones as needed at [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动中，我们将使用免费的 OpenWeatherMap API。文档可以在 [https://openweathermap.org/api](https://openweathermap.org/api)
    找到。要注册 API 令牌，请访问 [https://home.openweathermap.org/users/sign_up](https://home.openweathermap.org/users/sign_up)。您可以在
    [https://home.openweathermap.org/api_keys](https://home.openweathermap.org/api_keys)
    找到您的密钥并按需生成新的密钥。
- en: 'The steps for this activity are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的步骤如下：
- en: Create a new app.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的应用程序。
- en: Grant internet permissions to the app in order to be able to make API and image
    requests.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授予应用程序互联网权限，以便能够进行 API 和图像请求。
- en: Add Retrofit, the Moshi converter, and Glide to the app.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Retrofit、Moshi 转换器和 Glide 添加到应用程序中。
- en: Update the app layout to support the presentation of the weather in a textual
    form (a short and long description) as well as a weather icon image.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序布局以支持以文本形式（简短和详细描述）以及天气图标图像的形式展示天气。
- en: Define the model. Create classes that will contain the server response.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义模型。创建包含服务器响应的类。
- en: Add the Retrofit service for the OpenWeatherMap API,[https://api.openweathermap.org/data/2.5/weather](https://api.openweathermap.org/data/2.5/weather).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Retrofit 服务以使用 OpenWeatherMap API，[https://api.openweathermap.org/data/2.5/weather](https://api.openweathermap.org/data/2.5/weather)。
- en: Create a Retrofit instance with a Moshi converter.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Moshi 转换器创建 Retrofit 实例。
- en: Call the API service.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 API 服务。
- en: Handle the successful server response.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理成功的服务器响应。
- en: Handle the different failure scenarios.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理不同的失败场景。
- en: 'The expected output is shown here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下所示：
- en: "![Figure 5.7 – The final we\uFEFF\uFEFFather app](img/B19411_05_07.jpg)"
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 最终的天气应用](img/B19411_05_07.jpg)'
- en: Figure 5.7 – The final weather app
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 最终的天气应用
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在 [https://packt.link/By7eE](https://packt.link/By7eE) 找到。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to fetch data from an API using Retrofit. We
    then learned how to handle JSON responses, as well as plain text responses, using
    Moshi. We also saw how different error scenarios could be handled.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Retrofit 从 API 获取数据。然后我们学习了如何使用 Moshi 处理 JSON 响应以及纯文本响应。我们还看到了如何处理不同的错误场景。
- en: We later learned how to load images from URLs using Glide and how to present
    them to the user via `ImageView`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们后来学习了如何使用 Glide 从 URL 加载图片，以及如何通过 `ImageView` 将它们展示给用户。
- en: There are quite a few popular libraries for fetching data from APIs and for
    loading images. We only covered some of the most popular ones. You might want
    to try out some of the other libraries to find out which ones fit your purposes
    best.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多流行的库用于从 API 获取数据以及加载图片。我们只介绍了一些最受欢迎的库。你可能想尝试其他一些库，以找出最适合你需求的库。
- en: In the next chapter, we will be introduced to `RecyclerView`, which is a powerful
    UI component that we can use to present our users with lists of items.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 `RecyclerView`，这是一个强大的 UI 组件，我们可以用它向用户展示项目列表。
