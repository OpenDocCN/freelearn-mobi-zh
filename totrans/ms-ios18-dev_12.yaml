- en: <st c="0">12</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">12</st>
- en: <st c="3">Being Smart with Apple Intelligence and ML</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">利用苹果智能和机器学习变得聪明</st>
- en: <st c="46">The launch of ChatGPT in November 2022 wasn’t the first appearance
    of an</st> **<st c="120">Artificial Intelligence</st>** <st c="143">(</st>**<st
    c="145">AI</st>**<st c="147">) tool, but it was the one that put the AI in</st>
    <st c="194">the spotlight.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46">2022年11月ChatGPT的发布并不是第一个出现的</st> **<st c="120">人工智能</st>** <st c="143">(</st>**<st
    c="145">AI</st>**<st c="147">) 工具，但它确实是将人工智能推到</st> <st c="194">聚光灯下</st> 的那个。
- en: <st c="208">Some may argue that Apple entered the AI world later than others.</st>
    <st c="275">Perhaps, but what’s certain is that iOS has machine-learning capabilities
    for both users</st> <st c="364">and developers.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="208">有些人可能会认为苹果比其他公司晚进入人工智能领域。</st> <st c="275">也许吧，但可以肯定的是，iOS为用户和开发者都提供了机器学习能力。</st>
- en: <st c="379">Machine learning opens up new capabilities in almost every area
    we can think of – from search, statistics, and insights to understanding images
    and sounds.</st> <st c="536">There are even apps that are based on AI and machine</st>
    <st c="589">learning capabilities.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="379">机器学习几乎在每个我们可以想到的领域都开辟了新的能力——从搜索、统计和洞察力到理解图像和声音。</st> <st c="536">甚至有一些基于人工智能和机器学习能力的应用程序。</st>
- en: <st c="611">Currently, most of these capabilities are server-based.</st> <st
    c="668">Still, the ongoing improvements in mobile phones’</st> **<st c="718">System
    On Chip</st>** <st c="732">(</st>**<st c="734">SoC</st>**<st c="737">) performance
    allow them to perform predictions on-device, which opens up</st> <st c="812">new
    opportunities.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="611">目前，这些功能大多是基于服务器的。</st> <st c="668">尽管如此，手机</st> **<st c="718">系统级芯片</st>**
    <st c="732">(</st>**<st c="734">SoC</st>**<st c="737">) 性能的持续改进使它们能够在设备上执行预测，这开辟了</st>
    <st c="812">新的机会。</st>
- en: <st c="830">In this chapter, we will do</st> <st c="859">the following:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="830">在本章中，我们将</st> <st c="859">完成以下内容：</st>
- en: <st c="873">Cover the basics of AI and machine learning, learn the different
    terms, how machine learning works, and what it means to train</st> <st c="1001">a
    model</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="873">涵盖人工智能和机器学习的基础知识，学习不同术语，了解机器学习的工作原理以及训练</st> <st c="1001">模型</st>
    的含义
- en: <st c="1008">Explore built-in machine learning frameworks such as</st> **<st
    c="1062">Natural Language Processing</st>** <st c="1089">(</st>**<st c="1091">NLP</st>**<st
    c="1094">), vision, and</st> <st c="1110">sound analysis</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1008">探索内置的机器学习框架，例如</st> **<st c="1062">自然语言处理</st>** <st c="1089">(</st>**<st
    c="1091">NLP</st>**<st c="1094">)、视觉和</st> <st c="1110">声音分析</st>
- en: <st c="1124">Add a semantic search to our Core</st> <st c="1159">Spotlight implementation</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1124">向我们的Core</st> <st c="1159">Spotlight实现</st> 添加语义搜索
- en: <st c="1183">Build and integrate a custom machine learning model using the Create</st>
    **<st c="1253">Machine Learning</st>** <st c="1269">(</st>**<st c="1271">ML</st>**<st
    c="1273">) application and the Core</st> <st c="1301">ML framework</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1183">使用Create</st> **<st c="1253">机器学习</st>** <st c="1269">(</st>**<st
    c="1271">ML</st>**<st c="1273">) 应用程序和Core</st> <st c="1301">ML框架</st> 构建和集成自定义机器学习模型
- en: <st c="1313">Machine learning is a vast topic, and we’ve got much to cover,
    so let’s jump right in to understand</st> <st c="1414">the basics.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1313">机器学习是一个广泛的主题，我们有很多内容要介绍，所以让我们直接进入主题，了解</st> <st c="1414">基础知识。</st>
- en: <st c="1425">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1425">技术要求</st>
- en: <st c="1448">You must download Xcode version 16.0 or above for this chapter
    from Apple’s</st> <st c="1525">App Store.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1448">您必须从苹果的</st> <st c="1525">App Store</st> <st c="1526">下载16.0或更高版本的Xcode，用于本章。</st>
- en: <st c="1535">You’ll also need to run the latest version of macOS (Ventura or
    above).</st> <st c="1608">Search for</st> `<st c="1619">Xcode</st>` <st c="1624">in
    the App Store and select and download the latest version.</st> <st c="1686">Launch
    Xcode and follow any additional installation instructions that your system may
    prompt you with.</st> <st c="1789">Once Xcode has fully launched, you’re ready</st>
    <st c="1833">to go.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1535">您还需要运行最新版本的macOS（Ventura或更高版本）。</st> <st c="1608">在App Store中搜索</st>
    `<st c="1619">Xcode</st>` <st c="1624">，选择并下载最新版本。</st> <st c="1686">启动Xcode，并遵循系统可能提示的任何附加安装说明。</st>
    <st c="1789">一旦Xcode完全启动，您就准备好</st> <st c="1833">开始了。</st>
- en: <st c="1839">This chapter includes many code examples, some of which can be
    found in the following GitHub</st> <st c="1933">repository:</st> [<st c="1945">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter12</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter12)<st
    c="2028">.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1839">本章包含许多代码示例，其中一些可以在以下GitHub存储库中找到：</st> <st c="1933">[https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter12](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter12)<st
    c="2028">。</st>
- en: <st c="2029">Note that some examples in this chapter need to be run on a device,
    not</st> <st c="2102">the simulator.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2029">请注意，本章中的一些示例需要在设备上运行，而不是在模拟器上。</st>
- en: <st c="2116">Going over the basics of AI and machine learning</st>
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2116">回顾人工智能和机器学习的基础知识</st>
- en: <st c="2165">Before we dive in, let’s acknowledge the complexity – AI and machine
    learning are two huge topics that are impossible to cover in one chapter or even</st>
    <st c="2316">one book.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2165">在我们深入之前，让我们承认其复杂性——人工智能和机器学习是两个巨大的主题，不可能在一章或甚至一本书中涵盖。</st>
- en: <st c="2325">However, it is recommended that we</st> <st c="2360">understand
    the basics if we want to implement some machine-learning</st> <st c="2429">capabilities
    in</st> <st c="2445">our projects.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2325">然而，如果我们想在项目中实现一些机器学习功能，建议我们先了解基础知识。</st>
- en: <st c="2458">So, let’s start with understanding the difference between machine
    learning</st> <st c="2534">and AI.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2458">因此，让我们从了解机器学习和人工智能之间的区别开始。</st>
- en: <st c="2541">Learning the differences between AI and machine learning</st>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2541">学习人工智能和机器学习之间的区别</st>
- en: <st c="2598">AI is considered a rising topic in computer</st> <st c="2642">science,
    and this trend has been accelerated</st> <st c="2687">since the launch</st> <st
    c="2705">of</st> **<st c="2708">ChatGPT</st>**<st c="2715">.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2598">人工智能被认为是计算机科学中的一个新兴话题，并且自**ChatGPT**发布以来，这一趋势得到了加速。</st>
- en: <st c="2716">Even though ML is not a new technology, many</st> <st c="2761">people
    still need clarification about the difference between ML and AI.</st> <st c="2834">It’s
    not that they are not related –they are.</st> <st c="2880">Still, as iOS professional
    developers, it is essential to have a clear overview of the differences now that
    Apple has integrated AI deeply into</st> <st c="3024">its system.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2716">尽管机器学习不是一项新技术，但许多人仍然需要澄清机器学习和人工智能之间的区别。</st> <st c="2761">这并不是说它们没有关系——它们是有关系的。</st>
    <st c="2834">尽管如此，鉴于苹果公司已经将人工智能深度集成到其系统中，作为iOS专业开发者，现在有一个清晰的概述这些区别是至关重要的。</st>
- en: <st c="3035">So, what is ML?</st> <st c="3052">ML technology focuses on developing
    algorithms and statistical models to help computers perform tasks such as prediction
    and classification.</st> <st c="3193">For example, a model can receive an image
    and reply whether it contains a cat, or a model can take some text and locate
    the verbs and</st> <st c="3327">the nouns.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3035">那么，什么是机器学习（ML）呢？</st> <st c="3052">机器学习技术专注于开发算法和统计模型，以帮助计算机执行预测和分类等任务。</st>
    <st c="3193">例如，一个模型可以接收一个图像并回复它是否包含猫，或者一个模型可以处理一些文本并定位动词和名词。</st>
- en: <st c="3337">The ML model is an algorithm that performs its predictions and
    classifications.</st> <st c="3418">In fact, a model can use several algorithms
    to perform its calculations.</st> <st c="3491">For example, a vision model can
    use neural networks to</st> <st c="3545">perform its image classification and
    a</st> **<st c="3585">YOLO</st>** <st c="3589">(</st>**<st c="3591">You Only Look
    Once</st>**<st c="3609">) algorithm to perform</st> <st c="3633">real-time object
    detection.</st> <st c="3661">Each algorithm has its strengths and weaknesses.</st>
    <st c="3710">For</st> <st c="3714">example, the decision tree algorithm is easy
    to interpret but is prone to overfitting, while</st> **<st c="3807">KNN</st>**
    <st c="3810">(</st>**<st c="3812">K-Nearest Neighbors</st>**<st c="3831">) is
    simple and intuitive but</st> <st c="3862">computationally intensive.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习模型是一个执行预测和分类的算法<st c="3337"></st><st c="3418"></st><st c="3491"></st><st
    c="3545"></st><st c="3585"></st><st c="3589"></st><st c="3591"></st><st c="3609"></st><st
    c="3633"></st><st c="3661"></st><st c="3710"></st><st c="3714"></st><st c="3807"></st><st
    c="3810"></st><st c="3812"></st><st c="3831"></st><st c="3862"></st>
- en: <st c="3888">Conversely, AI is an array of technologies and methods that create
    a system capable of performing tasks similar to what humans</st> <st c="4016">usually
    do.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，人工智能是一系列技术和方法，能够创建一个能够执行与人类通常所做任务相似的系统<st c="3888"></st><st c="4016"></st>
- en: <st c="4027">One great</st> <st c="4038">example is</st> **<st c="4049">LLM</st>**
    <st c="4052">(</st>**<st c="4054">Large Language Model</st>**<st c="4074">) services
    such as</st> **<st c="4094">ChatGPT</st>** <st c="4101">or</st> **<st c="4105">Gemini</st>**<st
    c="4111">. Another example is the autonomous car driving projects that involve
    many</st> <st c="4185">ML models, such as object detection</st> <st c="4222">and
    decision-making.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是**<st c="4049">LLM</st>**（**<st c="4054">大型语言模型</st>**）服务，如**<st c="4094">ChatGPT</st>**或**<st
    c="4105">Gemini</st>**。另一个例子是涉及许多机器学习模型的项目，如自动驾驶汽车，这些项目包括目标检测和决策<st c="4027"></st><st
    c="4038"></st><st c="4049"></st><st c="4052"></st><st c="4054"></st><st c="4094"></st><st
    c="4101"></st><st c="4105"></st><st c="4111"></st><st c="4185"></st><st c="4222"></st>
- en: <st c="4242">We now understand that the ML model is one building block in AI.</st>
    <st c="4308">Next, let’s dive into the ML model to understand how</st> <st c="4361">it
    works.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白，机器学习模型是人工智能的一个构建块<st c="4242"></st><st c="4308"></st><st c="4361"></st>
- en: <st c="4370">Delving into the ML model</st>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们讨论这个重要的主题<st c="4370"></st>
- en: <st c="4396">The</st> **<st c="4401">ML model</st>** <st c="4409">contains data
    to generate a prediction, classification, or decision.</st> <st c="4479">The ML
    models we want to store on a device are relatively small.</st> <st c="4544">However,
    models such as GPT can be hundreds</st> <st c="4588">of gigabytes.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具有决策树算法的模型包含一个树，其中叶子代表不同的决策或预测<st c="4396"></st><st c="4401"></st><st c="4409"></st><st
    c="4479"></st><st c="4544"></st><st c="4588"></st>
- en: <st c="4601">But what does</st> *<st c="4616">data</st>* <st c="4620">mean here?</st>
    <st c="4632">How is it</st> <st c="4642">structured?</st> <st c="4654">The answer
    to that question depends on a model’s algorithms.</st> <st c="4715">For example,
    if the model uses a linear regression algorithm, the data structure is a 2D array,
    where the rows represent samples and the columns represent features.</st> <st
    c="4880">A model with a</st> **<st c="4895">decision tree algorithm</st>** <st
    c="4918">contains a tree, where the leaves</st> <st c="4952">represent the different
    decisions</st> <st c="4987">or predictions.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里的*<st c="4616">数据</st>* <st c="4620">是什么意思呢？<st c="4632"></st><st c="4642"></st><st
    c="4654"></st><st c="4715"></st>
- en: <st c="5002">Going forward in this chapter, we will refer to building and creating
    a model’s data as training.</st> <st c="5101">Let’s discuss that</st> <st c="5120">important
    topic.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章接下来的内容中，我们将把构建和创建模型数据称为训练<st c="5002"></st><st c="5101"></st><st c="5120"></st>
- en: <st c="5136">Traini</st><st c="5143">ng the model</st>
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练模型<st c="5136"></st><st c="5143"></st>
- en: <st c="5156">Two distinct ML models can have the same algorithms and structures,
    but the data can differ because of the training</st> <st c="5273">process.</st>
    <st c="5282">Using the training process, we teach a model to make accurate predictions
    and decisions based on the input data.</st> <st c="5395">This process involves
    optimizing the model’s data (parameters) to accurately perform predictions on</st>
    <st c="5495">unseen data.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5156">两个不同的机器学习模型可以拥有相同的算法和结构，但由于训练过程的不同，数据可能不同。</st> <st c="5273">使用训练过程，我们教会模型根据输入数据做出准确的预测和决策。</st>
    <st c="5282">这个过程涉及优化模型的数据（参数），以便在未见过的数据上准确地进行预测。</st> <st c="5395">这个过程包括优化模型的数据（参数）以在未见过的数据上准确执行预测。</st>
- en: <st c="5507">There are several steps we need to do to train</st> <st c="5555">a
    model:</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5507">训练一个模型需要我们执行几个步骤：</st>
- en: '**<st c="5563">Data collection</st>**<st c="5579">: We need to prepare a relatively
    large dataset to train our model.</st> <st c="5648">We must also preprocess the
    data by handling missing values, cleaning unrelated data items, and</st> <st c="5744">normalizing
    values.</st>'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="5563">数据收集</st>**<st c="5579">：我们需要准备一个相对较大的数据集来训练我们的模型。</st> <st
    c="5648">我们还必须通过处理缺失值、清理无关数据项和归一化值来预处理数据。</st>'
- en: '**<st c="5763">Split the data collection</st>**<st c="5789">: Now that we have
    the dataset, we must divide it into training data, validation, and test sets.</st>
    <st c="5887">We use each of these sets in a different</st> <st c="5928">training
    stage.</st>'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="5763">分割数据集</st>**<st c="5789">：现在我们有了数据集，我们必须将其分为训练数据、验证集和测试集。</st>
    <st c="5887">我们在不同的训练阶段使用这些数据集。</st>'
- en: '**<st c="5943">Pick our ML algorithm</st>**<st c="5965">: Each algorithm aims
    to solve a different problem.</st> <st c="6018">For example, the logistic regression
    algorithm solves classification problems, and the linear regression algorithm
    solves</st> <st c="6140">regression problems.</st>'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="5943">选择我们的机器学习算法</st>**<st c="5965">：每种算法旨在解决不同的问题。</st> <st c="6018">例如，逻辑回归算法解决分类问题，线性回归算法解决回归问题。</st>'
- en: '**<st c="6160">Forward pass</st>**<st c="6173">: We pass the training data
    through the model to</st> <st c="6223">make predictions.</st>'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="6160">前向传播</st>**<st c="6173">：我们将训练数据通过模型来做出预测。</st>'
- en: '**<st c="6240">Validation</st>**<st c="6251">: We use validation datasets to
    assess the model’s performance and adjust the model based on</st> <st c="6345">the
    results.</st>'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="6240">验证</st>**<st c="6251">：我们使用验证数据集来评估模型的表现，并根据结果调整模型。</st>'
- en: '**<st c="6357">Testing</st>**<st c="6365">: We use the test data to evaluate
    our model’s performance in real-time use cases with unseen</st> <st c="6460">input
    data.</st>'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="6357">测试</st>**<st c="6365">：我们使用测试数据来评估我们的模型在实时使用案例中，使用未见过的输入数据时的性能。</st>'
- en: <st c="6471">That was a schematic overview of the training process.</st> <st
    c="6527">In practice, the process contains even more steps, such as calculating
    loss and optimizations.</st> <st c="6622">However, the goal is to give you a glimpse
    into training so that you can understand the following topics.</st> <st c="6728">And
    don’t worry – we will build and train an ML model</st> <st c="6782">together soon!</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6471">这是训练过程的概要图。</st> <st c="6527">在实践中，这个过程包含更多步骤，例如计算损失和优化。</st> <st
    c="6622">然而，目标是让你对训练过程有一个大致的了解，以便你能理解以下主题。</st> <st c="6728">别担心——我们很快就会一起构建和训练一个机器学习模型！</st>
- en: <st c="6796">Now that we know what an ML model is, let’s try to understand how
    it relates</st> <st c="6874">to iOS.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6796">既然我们已经了解了机器学习模型是什么，让我们尝试理解它如何与iOS相关。</st>
- en: <st c="6881">Apple intelligence and ML</st>
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="6881">苹果的智能和机器学习</st>
- en: <st c="6907">When ChatGPT gained popularity, many felt Apple had fallen behind
    in AI and ML.</st> <st c="6988">This book is not the place to discuss that</st>
    <st c="7030">question; suffice it to say that ML has since been</st> <st c="7081">an
    integral part of iOS for years.</st> <st c="7117">iOS uses ML to optimize our
    photos according to their content.</st> <st c="7180">Keyboard predictions involve
    ML models, and even the way iOS preserves a battery is based</st> <st c="7270">on
    ML.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6907">当ChatGPT变得流行时，许多人觉得苹果在人工智能和机器学习方面落后了。</st> <st c="6988">这本书不是讨论那个问题的场所；
    suffice it to say that ML has since been an integral part of iOS for years.</st>
    <st c="7030">iOS使用机器学习来根据其内容优化我们的照片。</st> <st c="7117">键盘预测涉及机器学习模型，iOS保存电池的方式也基于机器学习。</st>
- en: <st c="7276">All these features and capabilities are transparent to users and
    performed under the hood.</st> <st c="7368">However, iOS 18 brought AI into the
    spotlight with many features, such as an improved Siri, an image playground, and</st>
    <st c="7485">writing tools.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7276">所有这些特性和功能都对用户透明，并在幕后执行。</st> <st c="7368">然而，iOS 18 通过许多功能，如改进的
    Siri、图像游乐场和</st> <st c="7485">写作工具</st>，将 AI 推到了聚光灯下。
- en: <st c="7499">iOS 18 also provided some neat capabilities for us developers,
    but it especially brought the areas of ML and AI to our attention.</st> <st c="7630">For
    example, semantic search is one of the new capabilities available to</st> <st
    c="7702">developers using iOS</st> <st c="7724">ML features.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7499">iOS 18 也为我们开发者提供了一些实用的功能，但它特别将 ML 和 AI 的领域带到了我们的注意中。</st> <st c="7630">例如，语义搜索是
    iOS ML 功能开发者可用的新功能之一。</st>
- en: <st c="7736">Before we dive into</st> <st c="7757">Core ML and learn how to
    train our models, let’s start with the models that come with the iOS SDK, as there
    is a good chance that that is where we’ll find what we need quickly without training
    a</st> <st c="7952">new model.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7736">在我们深入研究</st> <st c="7757">Core ML 并学习如何训练我们的模型之前，让我们先从 iOS SDK
    中提供的模型开始，因为有很大机会我们可以在不训练</st> <st c="7952">新模型的情况下快速找到我们需要的。</st>
- en: <st c="7962">Exploring built-in ML frameworks</st>
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="7962">探索内置机器学习框架</st>
- en: <st c="7995">When we reviewed the</st> <st c="8016">basics of AI and ML, we
    saw what it means to train a model – it’s a long and complex process.</st> <st
    c="8111">This process requires us to prepare relatively big datasets, including
    the validation and test datasets.</st> <st c="8216">Even after that, we have an
    ML model we need to fine-tune and include in our app while trying to reduce</st>
    <st c="8320">its size.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7995">当我们回顾 AI 和 ML 的基础知识时，我们看到了训练模型意味着什么——这是一个漫长且复杂的过程。</st> <st c="8111">这个过程需要我们准备相对较大的数据集，包括验证集和测试集。</st>
    <st c="8216">即使那样，我们仍然需要微调我们的 ML 模型并将其包含在我们的应用程序中，同时试图减小其大小。</st>
- en: <st c="8329">However, don’t get me wrong.</st> <st c="8359">There are cases
    where training our ML model is essential, but before we start the training process,
    it’s important to be familiar with what</st> <st c="8499">iOS offers.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8329">但是，不要误解我。</st> <st c="8359">在某些情况下，训练我们的 ML 模型是必不可少的，但在我们开始训练过程之前，了解
    iOS 提供的内容是非常重要的。</st>
- en: <st c="8510">Working with ML frameworks in iOS isn’t new.</st> <st c="8556">These
    frameworks were introduced years ago, some even in iOS 10 (2016).</st> <st c="8628">However,
    few developers use them, perhaps because they believe they are complex</st> <st
    c="8708">to integrate.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8510">在 iOS 中与 ML 框架一起工作并不新鲜。</st> <st c="8556">这些框架几年前就已经被引入，其中一些甚至是在
    iOS 10（2016 年）中。</st> <st c="8628">然而，很少有开发者使用它们，可能是因为他们认为它们难以</st> <st c="8708">集成。</st>
- en: <st c="8721">We’ll start with one of the most practical frameworks in the</st>
    <st c="8782">ML toolset –</st> <st c="8796">NLP.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8721">我们将从 ML 工具集中最实用的框架之一——</st> <st c="8796">自然语言处理</st> <st c="8782">开始。</st>
- en: <st c="8800">Interpreting text using NLP</st>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8800">使用 NLP 解析文本</st>
- en: <st c="8828">Interpreting and understanding texts can</st> <st c="8870">provide
    significant value to many</st> <st c="8904">apps.</st> <st c="8910">For example,
    NLP can help us understand strings such as search phrases, text inputs, or extracting
    information from an</st> <st c="9029">imported text.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8828">解析和理解文本可以为许多</st> <st c="8904">应用程序</st> <st c="8870">提供显著的价值。</st>
    <st c="8910">例如，NLP 可以帮助我们理解诸如搜索短语、文本输入或从</st> <st c="9029">导入的文本中提取信息之类的字符串。
- en: <st c="9043">The iOS SDK has a built-in NLP framework</st> <st c="9085">called</st>
    `<st c="9092">NaturalLanguage</st>`<st c="9107">:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9043">iOS SDK 内置了一个名为</st> <st c="9092">NaturalLanguage</st> <st c="9107">的</st>
    <st c="9085">自然语言处理</st> <st c="9043">框架</st>
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="9132">The</st> `<st c="9137">NaturalLanguage</st>` <st c="9152">framework
    helps us interpret text efficiently on</st> <st c="9202">a device.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9132">`NaturalLanguage` <st c="9137">框架帮助我们高效地在</st> <st c="9202">设备上解析文本。</st>
- en: <st c="9211">We must first know how NLP works under the hood and its basic terms
    to understand how</st> <st c="9298">it works.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9211">为了理解其工作原理，我们首先必须了解 NLP 在幕后是如何工作的以及其基本术语。</st>
- en: <st c="9307">The NLP model works</st> <st c="9328">by finding relationships</st>
    <st c="9352">between different parts of texts.</st> <st c="9387">Even though this
    task is complex, it’s interesting to see how</st> <st c="9449">it works.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9307">NLP模型通过</st> <st c="9328">找到文本不同部分之间的关系</st> <st c="9352">来工作。</st>
    <st c="9387">尽管这个任务很复杂，但看到它是如何工作的很有趣。</st>
- en: <st c="9458">Understanding how NLP works</st>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="9458">理解NLP是如何工作的</st>
- en: <st c="9486">The NLP process involves text</st> <st c="9517">processing and
    several algorithms to extract the necessary information.</st> <st c="9589">There
    are three basic steps –</st> **<st c="9619">preprocessing</st>**<st c="9632">,</st>
    **<st c="9634">feature extraction</st>**<st c="9652">, and</st> **<st c="9658">modeling</st>**<st
    c="9666">. Let’s go over them one</st> <st c="9690">by one.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9486">NLP过程涉及文本处理和几个算法来提取必要的信息。<st c="9517">有三个基本步骤 –</st> **<st c="9619">预处理</st>**<st
    c="9632">，**<st c="9634">特征提取</st>**<st c="9652">，和</st> **<st c="9658">建模</st>**<st
    c="9666">。让我们逐一介绍。</st>
- en: <st c="9698">Preprocessing</st>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="9698">预处理</st>
- en: <st c="9712">In this step, the NLP model starts by</st> <st c="9751">cleaning
    the input, such as removing duplicates, splitting texts into words and sentences,
    converting text to lowercase, and performing stemming and lemmatization.</st>
    <st c="9915">Take the following text as</st> <st c="9942">an example:</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9712">在这个步骤中，NLP模型首先开始</st> <st c="9751">清理输入，例如删除重复项，将文本分割成单词和句子，将文本转换为小写，以及执行词干提取和词形还原。</st>
    <st c="9915">以下文本作为</st> <st c="9942">示例：</st>
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="9986">This will be preprocessed to someth</st><st c="10022">ing like</st>
    <st c="10032">the following:</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9986">这将预处理成以下类似的内容：</st><st c="10022">：</st><st c="10032">以下：</st>
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="10066">In this example, the NLP removed stop words (such as</st> `<st
    c="10120">is</st>`<st c="10122">) and lowercased the</st> <st c="10144">whole
    string.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10066">在这个例子中，NLP移除了停用词（例如</st> `<st c="10120">is</st>`<st c="10122">）并将整个字符串转换为小写。</st>
- en: <st c="10157">Feature extraction</st>
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="10157">特征提取</st>
- en: <st c="10176">After the string has been preprocessed, we transform it into a
    feature set that we can use with the ML algorithm.</st> <st c="10291">In most</st>
    <st c="10299">cases, this involves capturing different patterns and word frequencies.</st>
    <st c="10371">For example, the string from the previous step,</st> `<st c="10419">run
    fun love run</st>`<st c="10435">, can be transformed into</st> <st c="10461">the
    following:</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10176">在字符串预处理之后，我们将其转换成一个特征集，我们可以使用它与ML算法一起使用。</st> <st c="10291">在大多数</st>
    <st c="10299">情况下，这涉及到捕获不同的模式和单词频率。</st> <st c="10371">例如，上一步的字符串，<st c="10419">run
    fun love run</st>，可以转换成以下：</st>
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="10509">In this example, the NLP model takes the input string and analyzes
    the frequency of each word.</st> <st c="10605">This technique is called</st> **<st
    c="10630">Bag of Words</st>** <st c="10642">(</st>**<st c="10644">BoW</st>**<st
    c="10647">), and the model uses it to determine the importance of the different</st>
    <st c="10718">words in the string.</st> <st c="10739">Note there are many feature
    extraction techniques, and BoW is just an example.</st> <st c="10818">We can select
    the model now that we have the feature</st> <st c="10871">extraction data.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，NLP模型接收输入字符串并分析每个单词的频率。<st c="10605">这种技术被称为</st> **<st c="10630">词袋模型</st>**
    <st c="10642">(</st>**<st c="10644">BoW</st>**<st c="10647">)，模型使用它来确定字符串中不同单词的重要性。<st
    c="10739">请注意，有许多特征提取技术，BoW只是其中之一。</st> <st c="10818">现在我们已经有了特征提取数据，我们可以选择模型。</st>
- en: <st c="10887">Modeling</st>
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="10887">建模</st>
- en: <st c="10896">In the modeling step, we use string and</st> <st c="10937">feature
    extraction as input to the model algorithm.</st> <st c="10989">NLP uses several
    algorithms to analyze the string – logistic regression, naïve Bayes, and a neural
    network.</st> <st c="11097">The algorithm that the model selects depends on the
    task it needs</st> <st c="11163">to achieve.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10896">在建模步骤中，我们将字符串和</st> <st c="10937">特征提取作为模型算法的输入。</st> <st c="10989">NLP使用多个算法来分析字符串
    – 逻辑回归、朴素贝叶斯和神经网络。</st> <st c="11097">模型选择的算法取决于它需要完成的任务。</st>
- en: <st c="11174">For example, if the NLP framework needs to perform sentiment analysis,
    it would use a neural network-based model.</st> <st c="11289">Simple text processing
    tasks would use a rule-based</st> <st c="11341">system model.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11174">例如，如果NLP框架需要执行情感分析，它将使用基于神经网络的模型。</st> <st c="11289">简单的文本处理任务将使用基于规则的</st>
    `<st c="11341">系统模型。</st>
- en: <st c="11354">These three steps demonstrate how complex it is to interpret a
    simple text.</st> <st c="11431">Fortunately, the</st> `<st c="11448">NaturalLanguage</st>`
    <st c="11463">framework performs all of these steps</st> <st c="11502">for us.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11354">这三个步骤展示了理解简单文本的复杂性。</st> <st c="11431">幸运的是，</st> `<st c="11448">自然语言</st>`
    `<st c="11463">框架为我们执行了所有这些步骤。</st> <st c="11502">。</st>
- en: <st c="11509">Let’s see how to use the</st> `<st c="11535">NaturalLanguage</st>`
    <st c="11550">framework API.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11509">让我们看看如何使用</st> `<st c="11535">自然语言</st>` `<st c="11550">框架API。</st>
- en: <st c="11565">Using the NaturalLanguage API</st>
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="11565">使用自然语言API</st>
- en: <st c="11595">Finally, we are going to write some code!</st> <st c="11638">The</st>
    `<st c="11642">NaturalLanguage</st>` <st c="11657">framework has two primary uses
    – classification</st> <st c="11706">and word tagging.</st> <st c="11724">Let’s
    start</st> <st c="11736">with classification.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11595">最后，我们将编写一些代码！</st> <st c="11638">自然语言</st> `<st c="11642">框架有两个主要用途
    – 分类</st> <st c="11706">和词性标注。</st> <st c="11724">让我们从分类开始。</st>
- en: <st c="11756">Text classification</st>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="11756">文本分类</st>
- en: <st c="11776">Using</st> **<st c="11783">text classification</st>**<st c="11802">,
    we can analyze the</st> <st c="11822">text sentiment to determine whether it is
    positive</st> <st c="11874">or negative.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11776">使用</st> **<st c="11783">文本分类</st>** `<st c="11802">，我们可以分析文本情感以确定它是正面</st>
    `<st c="11822">还是负面。</st>`
- en: <st c="11886">For example, let’s take</st> <st c="11911">a look at the</st>
    <st c="11925">following text:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11886">例如，让我们看看以下文本：</st>
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="12001">To analyze the sentiment of this sentence using the</st> `<st
    c="12054">NaturalLanguage</st>` <st c="12069">framework, we’ll use the</st> `<st
    c="12095">NLTagger</st>` <st c="12103">class:</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12001">为了使用</st> `<st c="12054">自然语言</st>` `<st c="12069">框架分析这个句子的情感，我们将使用</st>
    `<st c="12095">NLTagger</st>` `<st c="12103">类：</st>
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`<st c="12483">NLTagger</st>` <st c="12492">is the primary class we use to
    process texts in NLP.</st> <st c="12546">When we initialize it, we pass the information
    we are interested in.</st> <st c="12615">In our example, we passed</st> `<st c="12641">sentimentScore</st>`
    <st c="12655">– a scheme that helps us determine the</st> <st c="12695">text sentiment.</st>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12483">NLTagger</st>` <st c="12492">是我们用于处理自然语言文本的主要类。</st> <st c="12546">当我们初始化它时，我们传递我们感兴趣的信息。</st>
    <st c="12615">在我们的例子中，我们传递了</st> `<st c="12641">sentimentScore</st>` <st c="12655">
    – 一种帮助我们确定</st> <st c="12695">文本情感的方案。</st>'
- en: <st c="12710">Our next step is to set the text input and call the tag function
    while passing relevant parameters, such as range, unit type, and scheme we want
    it</st> <st c="12859">to analyze.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12710">我们的下一步是设置文本输入并调用标记函数，同时传递相关参数，例如范围、单位类型和我们想要分析的方案。</st> <st c="12859">要分析。</st>
- en: <st c="12870">The tag function performs the text analysis and returns a score
    between -1 and 1, where a negative score indicates a negative sentiment and a
    positive score indicates a</st> <st c="13040">positive sentiment.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12870">标记函数执行文本分析并返回一个介于-1和1之间的分数，其中负分数表示负面情感，正分数表示</st> `<st c="13040">正面情感。</st>
- en: <st c="13059">If we run this code on</st> <st c="13082">our example sentence
    before the code example, we’ll get a score of 1.0 – an extremely</st> <st c="13169">positive
    text!</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13059">如果我们在这段代码示例之前运行这段代码</st> <st c="13082">我们的示例句子，我们将得到1.0的分数 – 一个极其</st>
    <st c="13169">积极的文本！</st>
- en: <st c="13183">Even though text classification is very easy to use, it is also
    very powerful.</st> <st c="13263">We can use this capability to analyze user feedback/reviews,
    chatbots, and surveys and even adapt an interface, based on the user’s sentiments</st>
    <st c="13406">and emotions.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13183">尽管文本分类非常容易使用，但它也非常强大。</st> <st c="13263">我们可以使用这种能力来分析用户反馈/评论、聊天机器人和调查，甚至根据用户的情感</st>
    `<st c="13406">和情绪调整界面。</st>
- en: <st c="13419">We mentioned that text classification is all about understanding
    the text sentiment.</st> <st c="13505">However, we can use NLP to analyze text
    using</st> <st c="13551">word tagging.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13419">我们提到文本分类完全是关于理解文本情感。</st> <st c="13505">然而，我们可以使用自然语言处理技术通过</st>
    `<st c="13551">词性标注</st>` `<st c="13567">来分析文本。</st>
- en: <st c="13564">Word tagging</st>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`<st c="13564">词性标注</st>`'
- en: '**<st c="13577">Word tagging</st>** <st c="13590">is the process of breaking
    a text into components and assigning tags to each phrase in the text, indicating
    its</st> <st c="13702">grammatical category.</st>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="13577">词性标注</st>** 是将文本分解成组件并为文本中的每个短语分配标签的过程，指示其 `<st c="13702">语法类别</st>`。'
- en: <st c="13724">Let’s take the</st> <st c="13739">example of the</st> <st c="13755">following
    text:</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下文本的例子：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="13810">If we try to break this sentence into grammatical categories,
    it will be something like</st> *<st c="13898">She</st>* <st c="13902">(pronoun),</st>
    *<st c="13914">enjoys</st>* <st c="13920">(verb),</st> *<st c="13929">reading</st>*
    <st c="13936">(verb),</st> *<st c="13945">books</st>* <st c="13950">(noun),</st>
    *<st c="13959">in</st>* <st c="13961">(preposition),</st> *<st c="13977">the</st>*
    <st c="13980">(determiner), and</st> *<st c="13999">library</st>* <st c="14006">(noun).</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将这个句子分解成语法类别，它将类似于 *<st c="13898">She</st>* (代词)，*<st c="13902">enjoys</st>*
    (动词)，*<st c="13914">reading</st>* (动词)，*<st c="13929">books</st>* (名词)，*<st c="13945">in</st>*
    (介词)，*<st c="13977">the</st>* (限定词)，以及 *<st c="13999">library</st>* (名词)。
- en: <st c="14014">The different parts of the</st> <st c="14041">text are called</st>
    **<st c="14058">tokens</st>**<st c="14064">, and their grammatical category is</st>
    <st c="14100">called</st> <st c="14107">a</st> **<st c="14109">tag</st>**<st c="14112">.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的不同部分被称为 **<st c="14058">标记</st>**，它们的语法类别被称为 **<st c="14109">标签</st>**。
- en: <st c="14113">The</st> `<st c="14118">NaturalLanguage</st>` <st c="14133">framework
    helps us perform tokenization and tag</st> <st c="14182">its tokens.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="14113">The</st>` `<st c="14118">NaturalLanguage</st>` `<st c="14133">框架帮助我们执行分词和标记</st>`
    `<st c="14182">其标记。</st>`'
- en: <st c="14193">Let’s look at the</st> <st c="14212">following code:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="14657">The preceding code example takes the same sentence as earlier,
    tokenizes it, and locates the first verb</st> <st c="14762">it finds.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码示例使用了之前相同的句子，对其进行分词，并定位到它找到的第一个动词。
- en: <st c="14771">We start by initializing</st> `<st c="14797">NLTagger</st>`<st
    c="14805">, similar to what we did in text classification.</st> <st c="14854">However,
    we do that this time by passing</st> `<st c="14895">lexicalClass</st>` <st c="14907">as</st>
    <st c="14911">its scheme.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化 `<st c="14797">NLTagger</st>`，类似于我们在文本分类中所做的。然而，这次我们通过传递 `<st c="14895">lexicalClass</st>`
    作为 `<st c="14911">其方案</st>` 来实现这一点。
- en: <st c="14922">Then, we provide the input</st> <st c="14949">text and omit punctuation
    and whitespaces.</st> <st c="14993">We do this because we want our text to be
    as clean as possible.</st> `<st c="15057">NLTagger</st>` <st c="15065">can catch
    extra whitespace characters and punctuation as</st> <st c="15123">additional tags.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提供输入 `<st c="14949">文本</st>` 并省略标点和空白。我们这样做是因为我们希望我们的文本尽可能干净。
- en: <st c="15139">After we clean our text, we call the</st> `<st c="15177">enumerateTags</st>`
    <st c="15190">function.</st> <st c="15201">This function iterates the words in
    the text within a given range and extracts the different tags.</st> <st c="15300">We
    compare the tag type inside the passed closure and store it in an</st> <st c="15369">instance
    variable.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们清理完文本后，我们调用 `<st c="15177">enumerateTags</st>` 函数。该函数遍历给定范围内的文本中的单词并提取不同的标签。我们比较传递的闭包内的标签类型并将其存储在一个
    `<st c="15369">实例变量</st>` 中。
- en: <st c="15387">In our example, we locate the first verb, which</st> <st c="15436">is</st>
    `<st c="15439">enjoys</st>`<st c="15445">.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们定位到第一个动词，它是 `<st c="15439">enjoys</st>`。
- en: <st c="15446">Although word tagging and text classification are</st> `<st c="15497">NLTagger</st>`<st
    c="15505">’s two primary use cases, they can also be used for additional cases,
    such as to identify a</st> <st c="15598">text’s language:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管词性标注和文本分类是 `<st c="15497">NLTagger</st>` 的两个主要用例，但它们也可以用于其他用例，例如用于识别文本的语言：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="15875">In the preceding example, the</st> `<st c="15906">NLTagger</st>`
    <st c="15914">receives input text and extracts its language.</st> <st c="15962">It
    can identify 50 different languages – impressive for an on-device</st> <st c="16031">NLP
    model!</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15875">在上一个示例中，</st> `<st c="15906">NLTagger</st>` <st c="15914">接收输入文本并提取其语言。</st>
    <st c="15962">它可以识别50种不同的语言——对于一个设备上的</st> <st c="16031">NLP模型来说非常令人印象深刻！</st>
- en: <st c="16041">We can use language identification</st> <st c="16076">to identify
    the user locale and offer to change an app’s preferred language, or we can send
    that information as analytics data to</st> <st c="16207">our servers.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16041">我们可以使用语言识别</st> <st c="16076">来识别用户区域设置，并建议更改应用程序的首选语言，或者我们可以将此信息作为分析数据发送到</st>
    <st c="16207">我们的服务器。</st>
- en: <st c="16219">Another great example of NLP is</st> **<st c="16252">word embedding</st>**<st
    c="16266">. This feature can help our application</st> <st c="16306">become smarter.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16219">自然语言处理（NLP）的另一个绝佳例子是</st> **<st c="16252">词嵌入</st>**<st c="16266">。此功能可以帮助我们的应用程序</st>
    <st c="16306">变得更智能。</st>
- en: <st c="16321">Each word in the dictionary is related to other</st> <st c="16369">words.</st>
    <st c="16377">For example,</st> *<st c="16390">house</st>* <st c="16395">is related
    to</st> *<st c="16410">building</st>* <st c="16418">and</st> *<st c="16423">apartment</st>*<st
    c="16432">, and</st> *<st c="16438">cat</st>* <st c="16441">is associated</st>
    <st c="16456">with</st> *<st c="16461">dog</st>*<st c="16464">.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16321">词典中的每个单词都与其他</st> <st c="16369">单词相关。</st> <st c="16377">例如，</st>
    *<st c="16390">house</st>* <st c="16395">与</st> *<st c="16410">building</st>*
    <st c="16418">和</st> *<st c="16423">apartment</st>*<st c="16432">相关，而</st> *<st
    c="16438">cat</st>* <st c="16441">与</st> *<st c="16456">dog</st>*<st c="16464">相关联。</st>
- en: <st c="16465">We can easily find related words, using a class</st> <st c="16514">called</st>
    `<st c="16521">NLEmbedding</st>`<st c="16532">:</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16465">我们可以轻松地使用名为</st> <st c="16514">NLEmbedding</st> <st c="16532">的类</st>
    <st c="16521">找到相关单词：</st>
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="16930">In the preceding example,</st> `<st c="16957">NLEmbedding</st>`
    <st c="16968">receives an input test, calculates its vector, and finds its closed
    neighbors.</st> <st c="17048">If you ask yourself why this is practical, think
    of a search engine that can find related content even if it isn’t exactly what
    the user</st> <st c="17185">searched for.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16930">在上一个示例中，</st> `<st c="16957">NLEmbedding</st>` <st c="16968">接收输入测试，计算其向量，并找到其邻近的邻居。</st>
    <st c="17048">如果你想知道这为什么实用，想想一个搜索引擎，即使内容与用户</st> <st c="17185">搜索的内容不完全一致，也能找到相关内容。</st>
- en: <st c="17198">In this section, we analyzed text using the</st> `<st c="17243">NaturalLanguage</st>`
    <st c="17258">framework.</st> <st c="17270">We’ve learned how NLP works, how to
    classify text, and extract additional information such as word tagging and even</st>
    <st c="17385">word embedding.</st> <st c="17402">However, iOS apps contain more
    than just text; they also include images.</st> <st c="17475">Can we analyze images</st>
    <st c="17497">as well?</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17198">在本节中，我们使用</st> `<st c="17243">NaturalLanguage</st>` <st c="17258">框架</st>
    <st c="17270">分析了文本。</st> <st c="17270">我们学习了NLP的工作原理，如何对文本进行分类，以及提取诸如词性标注甚至</st>
    <st c="17385">词嵌入</st> <st c="17402">等额外信息。</st> <st c="17475">然而，iOS应用程序不仅仅包含文本；它们还包括图像。</st>
    <st c="17497">我们能否也分析图像</st> <st c="17475">呢？</st>
- en: <st c="17505">Analyzing images using the Vision framework</st>
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17505">使用Vision框架分析图像</st>
- en: <st c="17549">Analyzing images is a fundamental</st> <st c="17584">topic in
    iOS apps.</st> <st c="17603">There are many use cases for analyzing images, such
    as detecting barcodes, scanning documents, or</st> <st c="17701">image editing.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17549">分析图像是iOS应用程序中的</st> <st c="17584">基本</st> <st c="17603">主题。</st>
    <st c="17603">分析图像有许多用例，例如检测条形码、扫描文档或</st> <st c="17701">图像编辑。</st>
- en: <st c="17715">To analyze images in iOS, we need to</st> <st c="17753">use Apple’s
    Vision framework.</st> <st c="17783">Introduced in 2017 with the release of iOS
    11, the Vision framework provides</st> <st c="17860">high-level functionality
    to perform various image</st> <st c="17910">analysis tasks.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17715">在iOS中分析图像，我们需要</st> <st c="17753">使用苹果的Vision框架。</st> <st c="17783">该框架于2017年随iOS
    11的发布而引入，提供了</st> <st c="17860">高级功能以执行各种图像</st> <st c="17910">分析任务。</st>
- en: <st c="17925">Understanding how image analysis works</st>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="17925">理解图像分析的工作原理</st>
- en: <st c="17964">In a way, image analysis works similarly to text analysis, working
    with different steps that clean and prepare</st> <st c="18076">data before inserting
    it into</st> <st c="18106">a model.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17964">从某种意义上说，图像分析的工作方式与文本分析类似，它通过不同的步骤在将数据插入</st> <st c="18076">模型之前对其进行清理和准备</st>
    <st c="18106">数据。</st>
- en: <st c="18114">The image analysis works with a</st> **<st c="18147">CNN</st>**
    <st c="18150">(</st>**<st c="18152">Convolutional Neural Network</st>**<st c="18180">),
    a neural network designed for</st> <st c="18214">visual data.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18114">图像分析使用一个</st> **<st c="18147">CNN</st>** <st c="18150">(</st>**<st
    c="18152">卷积神经网络</st>**<st c="18180">)，这是一种专为</st> <st c="18214">视觉数据</st> <st
    c="18226">设计的神经网络。</st>
- en: <st c="18226">Consider CNN as a series of filters that can help a model better
    understand an image.</st> <st c="18313">CNN will perform a similar process if
    the</st> `<st c="18355">NaturalLanguage</st>` <st c="18370">model preprocessed
    the text, removing whitespace and</st> <st c="18424">duplicate words.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18226">将CNN视为一系列过滤器，可以帮助模型更好地理解图像。</st> <st c="18313">如果NaturalLanguage模型预处理了文本，移除了空白和</st>
    <st c="18355">重复的单词</st> <st c="18370">，CNN将执行类似的过程。</st>
- en: <st c="18440">First, the CNN scans an image to detect similar patterns, such
    as lines, edges, and textures.</st> <st c="18535">It then filters out what it
    thinks are non-important features and shrinks the image to contain the most</st>
    <st c="18639">essential information.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，CNN扫描图像以检测相似的模式，例如线条、边缘和纹理。</st> <st c="18535">然后，它过滤掉它认为的非重要特征，并将图像缩小以包含最重要的信息。</st>
    <st c="18639">信息。</st>
- en: <st c="18661">Now that we have a smaller and cleaner image, the CNN tries to
    decide what the image is – for example, “</st>*<st c="18766">It’s</st>* *<st c="18772">a
    cat.</st>*<st c="18778">”</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18661">现在我们有了更小、更干净的图像，CNN试图判断图像是什么——例如，“</st>*<st c="18766">它是一只</st>*
    *<st c="18772">猫。</st>*<st c="18778">”</st>
- en: <st c="18780">Detecting patterns and edges, filtering them, and analyzing an
    image are complex techniques that require</st> <st c="18884">extensive training.</st>
    <st c="18905">Luckily, the Vision framework performs all the heavy lifting</st>
    <st c="18966">for us.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18780">检测模式、边缘、过滤它们以及分析图像是复杂的技术，需要</st> <st c="18884">大量的训练。</st> <st
    c="18905">幸运的是，Vision框架为我们完成了所有繁重的工作</st> <st c="18966">。</st>
- en: <st c="18973">Let’s see what it can do</st> <st c="18999">for us.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18973">让我们看看它能为</st> <st c="18999">我们做什么。</st>
- en: <st c="19006">Exploring the Vision Framework’s capabilities</st>
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="19006">探索Vision框架的功能</st>
- en: <st c="19052">Since starting iOS 18, the</st> **<st c="19080">Vision framework
    API</st>** <st c="19100">has become extremely simple yet even</st> <st c="19138">more
    powerful.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19052">自从iOS 18开始，**<st c="19080">Vision框架API</st>** <st c="19100">已经变得极其简单，但甚至更加强大。</st>
- en: <st c="19152">To understand how the</st> <st c="19174">Vision framework API
    works, we need to remember that it is based on two types – request</st> <st c="19263">and
    observation.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19152">为了理解Vision框架API的工作原理，我们需要记住它基于两种类型——请求</st> <st c="19174">和观察。</st>
- en: <st c="19279">To perform an image analysis, we first create a</st> **<st c="19328">request</st>**<st
    c="19335">. Then, we request the specific image and receive an</st> **<st c="19388">observation</st>**
    <st c="19399">containing the result (if we</st> <st c="19429">have any).</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19279">要进行图像分析，我们首先创建一个</st> **<st c="19328">请求</st>**<st c="19335">。然后，我们请求特定的图像并接收一个包含结果（如果我们</st>
    <st c="19429">有任何）的</st> **<st c="19388">观察</st>** <st c="19399">。</st>
- en: <st c="19439">Let’s take two popular use cases – detecting barcodes</st> <st
    c="19494">and faces.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19439">让我们看看两个流行的用例——检测条形码</st> <st c="19494">和面部。</st>
- en: <st c="19504">Detecting barcodes</st>
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="19504">检测条形码</st>
- en: <st c="19523">Look at the following code to</st> <st c="19553">see barcode detecting</st>
    <st c="19576">in action:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19523">查看以下代码以</st> <st c="19553">查看条形码检测</st> <st c="19576">的实际操作：</st>
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="19875">The preceding code block performs</st> <st c="19909">barcode detection
    using the Vision framework.</st> <st c="19956">First, we create</st> `<st c="19973">DetectBarcodesRequest</st>`<st
    c="19994">, which represents a request to scan barcodes in a given</st> <st c="20051">image
    URL.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19875">前面的代码块使用Vision框架执行条形码检测。</st> <st c="19909">首先，我们创建</st> `<st
    c="19973">DetectBarcodesRequest</st>`<st c="19994">，它表示在给定的</st> <st c="20051">图像URL中扫描条形码的请求。</st>
- en: <st c="20061">Then, we call the request’s</st> `<st c="20090">perform</st>`
    <st c="20097">function, which returns an array of observations in the case of</st>
    <st c="20162">several barcodes.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20061">然后，我们调用请求的</st> `<st c="20090">perform</st>` <st c="20097">函数，在存在多个条形码的情况下，它返回一个包含观察结果的数组</st>
    <st c="20162">。</st>
- en: <st c="20179">Next, we take the first observation payload and store it in a
    variable.</st> <st c="20252">That payload represents the</st> <st c="20280">barcode
    identifier.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20179">接下来，我们取出第一个观察有效负载并将其存储在一个变量中。</st> <st c="20252">该有效负载代表</st>
    <st c="20280">条形码标识符。</st>
- en: <st c="20299">Note that the scanning operation can be a heavy task, which is
    why it is an</st> <st c="20376">asynchronous function.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20299">请注意，扫描操作可能是一个繁重的任务，这就是为什么它是一个</st> <st c="20376">异步函数。</st>
- en: <st c="20398">Another interesting example of a Vision framework usage is detecting
    faces in an image – let’s see</st> <st c="20498">an example.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20398">Vision框架的一个有趣的应用示例是检测图像中的人脸——让我们看看</st> <st c="20498">一个示例。</st>
- en: <st c="20509">Detecting faces</st>
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="20509">人脸检测</st>
- en: <st c="20525">Detecting faces works similarly to</st> <st c="20561">detecting
    barcodes.</st> <st c="20581">Let’s see a</st> <st c="20593">code example:</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20525">人脸检测的工作原理与</st> <st c="20561">条形码检测</st> <st c="20581">类似。</st>
    <st c="20593">让我们看看一个</st> <st c="20593">代码示例：</st>
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="20881">The preceding code example looks almost identical to the previous
    barcode example.</st> <st c="20965">First, we create the request.</st> <st c="20995">However,
    this time, the request is from type</st> `<st c="21040">DetectFaceRectanglesRequest</st>`<st
    c="21067">. Next, we perform the detection operation on the given image URL and
    retrieve an array of observations.</st> <st c="21172">Each observation instance
    contains a rectangle of one</st> <st c="21225">of the faces in the image.</st>
    <st c="21253">If the image contains multiple faces, we’ll get one observation
    for</st> <st c="21321">each face.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20881">前面的代码示例几乎与之前的条形码示例相同。</st> <st c="20965">首先，我们创建请求。</st> <st c="20995">然而，这次，请求的类型是</st>
    `<st c="21040">DetectFaceRectanglesRequest</st>`<st c="21067">。接下来，我们在给定的图像URL上执行检测操作，并检索到一个观察数组。</st>
    <st c="21172">每个观察实例包含图像中一个</st> <st c="21225">人脸的矩形。</st> <st c="21253">如果图像包含多个面部，我们将为每个面部获得一个观察结果。</st>
- en: <st c="21331">Face detection and barcodes are two common examples of Vision
    framework use cases.</st> <st c="21415">However, the Vision framework is full
    of surprises and detection capabilities.</st> <st c="21494">Let’s see what else
    we can do</st> <st c="21524">with it.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21331">人脸检测和条形码是Vision框架用例的两个常见示例。</st> <st c="21415">然而，Vision框架充满了惊喜和检测能力。</st>
    <st c="21494">让我们看看我们还能用它做什么。</st>
- en: <st c="21532">Exploring more detection capabilities</st>
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="21532">探索更多检测能力</st>
- en: <st c="21570">As mentioned, the Vision framework is full of machine-learning
    models capable of detecting almost anything we want.</st> <st c="21687">Barcodes</st>
    <st c="21696">and faces are just the tip of</st> <st c="21726">the iceberg.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21570">正如提到的，Vision框架充满了能够检测我们想要的几乎所有东西的机器学习模型。</st> <st c="21687">条形码</st>
    <st c="21696">和人脸只是冰山一角。</st>
- en: <st c="21738">Here’s a list of</st> <st c="21756">additional detectors:</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21738">以下是一些</st> <st c="21756">额外的检测器：</st>
- en: '**<st c="21777">Image aesthetics analysis</st>**<st c="21803">: For analyzing
    an image from an</st> <st c="21837">aesthetic viewpoint</st>'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21777">图像美学分析</st>**<st c="21803">：从美学角度分析图像</st>'
- en: '**<st c="21856">Saliency analysis</st>**<st c="21874">: For finding the most
    important object in</st> <st c="21918">an image</st>'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21856">显著性分析</st>**<st c="21874">：用于找到图像中最重要的对象</st>'
- en: '**<st c="21926">Object tracking</st>**<st c="21942">: For tracking an object’s
    movement across a sequence</st> <st c="21997">of images</st>'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21926">对象跟踪</st>**<st c="21942">：用于跟踪对象在一系列</st> <st c="21997">图像中的运动</st>'
- en: '**<st c="22006">Body detection</st>**<st c="22021">: Similar to face detection,
    for locating arms, humans, eyes, a mouth, and a nose</st> <st c="22104">in images</st>'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22006">人体检测</st>**<st c="22021">：类似于人脸检测，用于在图像中定位手臂、人体、眼睛、嘴巴和鼻子</st>
    <st c="22104"></st>'
- en: '**<st c="22113">Body and hand pose</st>**<st c="22132">: For locating arms
    in an image as well as detecting</st> <st c="22186">their pose.</st>'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22113">人体和手势姿态</st>**<st c="22132">：用于在图像中定位手臂以及检测</st> <st c="22186">它们的姿态。</st>'
- en: '**<st c="22197">Text detection</st>**<st c="22212">: For detecting text in</st>
    <st c="22237">an image</st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22197">文本检测</st>**<st c="22212">：用于检测图像中的文本</st>'
- en: '**<st c="22245">Animal detection</st>**<st c="22262">: For detecting cats and
    dogs in an image as well as</st> <st c="22316">their pose</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22245">动物检测</st>**<st c="22262">：用于检测图像中的猫和狗以及</st> <st c="22316">它们的姿态</st>'
- en: '**<st c="22326">Background removal and object extraction</st>**<st c="22367">:
    For removing the background and extracting objects</st> <st c="22421">from images</st>'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22326">背景移除和对象提取</st>**<st c="22367">：用于从图像中移除背景和提取对象</st> <st c="22421">的</st>'
- en: <st c="22432">The list of the different request types looks impressive, which
    it is.</st> <st c="22504">Reviewing the requests reflects how powerful the Vision
    framework has become.</st> <st c="22582">We can see capabilities usually reserved
    for</st> <st c="22627">high-end image editing applications, such as background
    removal or object extraction, now available with just three lines</st> <st c="22749">of
    code.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22432">不同请求类型的列表看起来令人印象深刻，确实如此。</st> <st c="22504">审查这些请求反映了视觉框架变得多么强大。</st>
    <st c="22582">我们可以看到通常为</st> <st c="22627">高端图像编辑应用程序保留的功能，例如背景移除或对象提取，现在只需三行</st>
    <st c="22749">代码即可实现。</st>
- en: <st c="22757">This opens up new possibilities for unique features in our apps,
    such as working with a camera or prioritizing images based on</st> <st c="22885">their
    information.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22757">这为我们的应用程序中的独特功能开辟了新的可能性，例如与相机一起工作或根据</st> <st c="22885">它们的信息来优先处理图像。</st>
- en: <st c="22903">We’ve discussed analyzing text and images, which are considered
    the most common data sources we usually use.</st> <st c="23013">The text and image
    analysis techniques are different but straightforward</st> <st c="23086">to implement.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22903">我们已经讨论了分析文本和图像，这些被认为是我们在通常使用中最常见的数据源。</st> <st c="23013">文本和图像分析技术不同，但实现起来很简单。</st>
- en: <st c="23099">Now, let’s turn to a different type of source we can analyze –</st>
    <st c="23163">sound.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23099">现在，让我们转向我们可以分析的不同类型的源——</st> <st c="23163">声音。</st>
- en: <st c="23169">Classifying audio using the Sound Analysis framework</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23169">使用声音分析框架进行音频分类</st>
- en: <st c="23222">Working with audio is not a popular</st> <st c="23259">expertise
    for many developers.</st> <st c="23290">In fact, audio is considered to be a complex
    and unique</st> <st c="23346">world compared to what we developers are</st> <st
    c="23387">used to.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23222">对于许多开发者来说，处理音频不是一项流行的</st> <st c="23259">专业知识。</st> <st c="23290">事实上，与开发者习惯的相比，音频被认为是一个复杂且独特的</st>
    <st c="23346">世界。</st>
- en: <st c="23395">To mitigate this, the iOS SDK also includes an analysis framework
    that can classify audio using</st> <st c="23492">ML models.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23395">为了减轻这一点，iOS SDK 还包括一个分析框架，可以使用</st> <st c="23492">ML 模型对音频进行分类。</st>
- en: <st c="23502">Working with the</st> **<st c="23520">Sound Analysis framework</st>**
    <st c="23544">differs from the simplicity we are used to with the Vision framework.</st>
    <st c="23615">But don’t worry – it is still simple</st> <st c="23652">to use.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23502">与</st> **<st c="23520">声音分析框架</st>** <st c="23544">一起工作与我们习惯的视觉框架的简单性不同。</st>
    <st c="23615">但别担心——它仍然很容易使用。</st>
- en: <st c="23659">The Sound Analysis framework contains three</st> <st c="23704">different
    components:</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23659">声音分析框架包含三个</st> <st c="23704">不同的组件：</st>
- en: '**<st c="23725">SNAudioFileAnalyzer</st>**<st c="23745">: The main class that
    coordinates the</st> <st c="23784">analysis work</st>'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23725">SNAudioFileAnalyzer</st>**<st c="23745">：协调分析工作的主要类</st>'
- en: '**<st c="23797">SNClassifySoundRequest</st>**<st c="23820">: The sound</st>
    <st c="23833">detection request</st>'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23797">SNClassifySoundRequest</st>**<st c="23820">：声音</st> <st c="23833">检测请求</st>'
- en: '**<st c="23850">SNResultsObserving</st>**<st c="23869">: A protocol we need
    to implement to observe the results from</st> <st c="23932">the analyzer</st>'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="23850">SNResultsObserving</st>**<st c="23869">：我们需要实现的一个协议，用于观察分析器的</st>
    <st c="23932">结果</st>'
- en: <st c="23944">To see these three components in action, take a look at the</st>
    <st c="24005">following code:</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23944">要查看这三个组件的实际效果，请查看以下</st> <st c="24005">代码：</st>
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="24396">In this example, we first</st> <st c="24422">create the</st> `<st
    c="24434">SNAudioFileAnalyzer</st>` <st c="24453">instance and initialize it with
    a URL to the audio file.</st> <st c="24511">Then, we create a request for a classification
    sound request, passing</st> `<st c="24581">version1</st>` <st c="24589">as a</st>
    <st c="24595">parameter.</st> <st c="24606">The</st> `<st c="24610">version1</st>`
    <st c="24618">parameter specifies the pre-trained classification version of the
    model.</st> <st c="24692">At the time of writing, no additional versions</st>
    <st c="24739">are available.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24396">在这个例子中，我们首先</st> <st c="24422">创建</st> `<st c="24434">SNAudioFileAnalyzer</st>`
    <st c="24453">实例，并用音频文件的URL初始化它。</st> <st c="24511">然后，我们创建一个分类声音请求的请求，将</st>
    `<st c="24581">version1</st>` <st c="24589">作为一个</st> <st c="24595">参数。</st> <st
    c="24606">`<st c="24610">version1</st>` <st c="24618">参数指定了模型的预训练分类版本。</st> <st
    c="24692">在撰写本文时，没有其他版本可用。</st>
- en: <st c="24753">Then, we create the</st> `<st c="24774">resultsObserver</st>`
    <st c="24789">instance (which we’ll discuss briefly) and coordinate everything
    together, using the analyzer we</st> <st c="24887">created earlier.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24753">然后，我们创建</st> `<st c="24774">resultsObserver</st>` <st c="24789">实例（我们稍后会简要讨论）并协调一切，使用我们之前创建的分析器。</st>
- en: <st c="24903">How do we get the results?</st> <st c="24931">Unlike the Vision</st>
    <st c="24948">framework, receiving the results can be streamlined.</st> <st c="25002">The</st>
    `<st c="25006">ClassificationResultsObserver</st>` <st c="25035">is a custom class
    that conforms to</st> `<st c="25071">SNResultsObserving</st>`<st c="25089">. Let’s
    look at the</st> <st c="25109">class implementation:</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24903">我们如何获取结果？</st> <st c="24931">与视觉</st> <st c="24948">框架不同，接收结果可以简化。</st>
    <st c="25002">`<st c="25006">ClassificationResultsObserver</st>`</st> <st c="25035">是一个自定义类，它符合</st>
    `<st c="25071">SNResultsObserving</st>`<st c="25089">。让我们看看</st> <st c="25109">类的实现：</st>
- en: '[PRE13]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="25552">The</st> `<st c="25557">SNResultsObserving</st>` <st c="25575">protocol
    has three essential request methods –</st> `<st c="25623">didProduce</st>`<st
    c="25633">,</st> `<st c="25635">didFailWithError</st>`<st c="25651">,</st> <st
    c="25653">and</st> `<st c="25657">requestDidComplete</st>`<st c="25675">.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25552">该</st> `<st c="25557">SNResultsObserving</st>` <st c="25575">协议有三个基本请求方法
    –</st> `<st c="25623">didProduce</st>`<st c="25633">,</st> `<st c="25635">didFailWithError</st>`<st
    c="25651">,</st> <st c="25653">和</st> `<st c="25657">requestDidComplete</st>`<st
    c="25675">。</st>
- en: <st c="25676">Great!</st> <st c="25684">However, unfortunately, in this case,
    it seems like we need to go back in time and use the delegate pattern to</st>
    <st c="25795">observe results from the Sound</st> <st c="25826">Analysis framework.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25676">太好了！</st> <st c="25684">然而，不幸的是，在这种情况下，我们似乎需要回到过去，并使用代理模式来</st>
    <st c="25795">观察声音分析框架的结果。</st>
- en: <st c="25845">The result is a string describing the sound we passed to the analyzer.</st>
    <st c="25917">The code example in this book’s GitHub</st> <st c="25956">repository
    shows a sound file with a baby crying.</st> <st c="26006">In this case, the result
    would</st> <st c="26037">be</st> `<st c="26040">baby_crying</st>`<st c="26051">.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25845">结果是描述我们传递给分析器的声音的字符串。</st> <st c="25917">本书GitHub</st> <st c="25956">存储库中的代码示例显示了一个婴儿哭泣的声音文件。</st>
    <st c="26006">在这种情况下，结果将是</st> `<st c="26037">baby_crying</st>`<st c="26051">。</st>
- en: <st c="26052">Apple has yet to officially publish the number of sound classes
    that the Sound Analysis framework can recognize.</st> <st c="26166">However, in
    most cases, this should be enough for</st> <st c="26216">day-to-day usage.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果公司尚未正式公布声音分析框架可以识别的声音类别数量。<st c="26166">然而，在大多数情况下，这应该足以满足</st> <st c="26216">日常使用。</st>
- en: <st c="26233">The Sound Analysis framework can be great for monitoring apps,
    adding</st> **<st c="26304">SDH</st>** <st c="26307">(</st>**<st c="26309">subtitles
    for the deaf or hard of hearing</st>**<st c="26350">) to video captions, and</st>
    <st c="26376">analyzing videos.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 声音分析框架非常适合监控应用，添加**<st c="26304">SDH</st>** <st c="26307">(**<st c="26309">为听障人士或听力受损人士提供的字幕</st>**<st
    c="26350">)到视频字幕，以及</st> <st c="26376">分析视频。</st>
- en: <st c="26393">So far, we have discussed how to analyze</st> <st c="26435">different
    types of data – sound, images, and text.</st> <st c="26486">However, ML is valuable
    in other areas, such as</st> <st c="26534">app search.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26393">到目前为止，我们已经讨论了如何分析</st> <st c="26435">不同类型的数据 – 声音、图像和文本。</st>
    <st c="26486">然而，机器学习在其它领域也很有价值，例如</st> <st c="26534">应用搜索。</st>
- en: <st c="26545">Performing a semantic search with Core Spotlight</st>
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26545">使用Core Spotlight执行语义搜索</st>
- en: <st c="26594">When we discussed NLP in the</st> *<st c="26624">Interpreting
    text using NLP</st>* <st c="26651">section, we said that one of the most common
    NLP</st> <st c="26701">use cases is analyzing a search</st> <st c="26732">phrase
    to build intelligent</st> <st c="26761">search queries.</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26594">在我们讨论 NLP 的</st> *<st c="26624">使用 NLP 解释文本</st> *<st c="26651">部分时，我们说，最常见的
    NLP</st> <st c="26701">用例之一是分析搜索</st> <st c="26732">短语以构建智能</st> <st c="26761">搜索查询。</st>
- en: <st c="26776">Even though the</st> `<st c="26793">NaturalLanguage</st>` <st
    c="26808">Framework API is robust and straightforward, performing a semantic search
    is</st> <st c="26885">considered a</st> <st c="26899">complex task.</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26776">尽管</st> `<st c="26793">NaturalLanguage</st>` <st c="26808">框架API强大且直观，执行语义搜索</st>
    <st c="26885">被认为是一项</st> <st c="26899">复杂任务。</st>
- en: <st c="26912">Starting iOS 18, the Core Spotlight framework supports a semantic
    search.</st> <st c="26987">Before we dive into the details, let’s clarify the
    term</st> **<st c="27043">semantic search</st>**<st c="27058">.</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26912">从 iOS 18 开始，Core Spotlight 框架支持语义搜索。</st> <st c="26987">在我们深入细节之前，让我们明确一下</st>
    **<st c="27043">语义搜索</st>**<st c="27058">这个术语。</st>
- en: <st c="27059">Understanding what semantic search is</st>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="27059">理解语义搜索是什么</st>
- en: <st c="27097">Let’s think together about how</st> <st c="27128">search queries
    work in a standard app, and we’ll do that using</st> <st c="27192">an example.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27097">让我们一起来思考一下标准应用中搜索查询是如何工作的，我们将通过</st> <st c="27128">一个示例</st> <st
    c="27192">来进行。</st>
- en: <st c="27203">Imagine that we have a course catalog app where a user can search
    for a particular course, and let’s say we have the following list of courses in
    our local</st> <st c="27360">data store:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27203">想象一下，我们有一个课程目录应用，用户可以搜索特定的课程，假设我们在本地的</st> <st c="27360">数据存储</st>
    <st c="27360">中有以下课程列表：</st>
- en: <st c="27371">Management</st> <st c="27383">for employees</st>
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27371">为员工的管理</st>
- en: <st c="27396">Data science</st>
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27396">数据科学</st>
- en: <st c="27409">Digital marketing</st>
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27409">数字营销</st>
- en: <st c="27427">ML</st> <st c="27431">and AI</st>
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="27427">ML</st> <st c="27431">和 AI</st>
- en: <st c="27437">Our user wants to improve their leadership skills, so they search
    for a management course within this list</st> <st c="27545">of courses.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27437">我们的用户想要提高他们的领导技能，所以他们在这个课程列表</st> <st c="27545">中搜索管理课程。</st>
- en: <st c="27556">The search query’s basic form is to match a specific phrase.</st>
    <st c="27618">For example, if the user searches for</st> `<st c="27656">management</st>`<st
    c="27666">, we filter only courses containing</st> *<st c="27702">management</st>*<st
    c="27712">. We also need to ensure that the output query</st> <st c="27759">is
    case-insensitive.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27556">搜索查询的基本形式是匹配一个特定的短语。</st> <st c="27618">例如，如果用户搜索</st> `<st c="27656">管理</st>`<st
    c="27666">，我们只过滤包含</st> *<st c="27702">管理</st>*<st c="27712">的课程。我们还需要确保输出查询</st>
    <st c="27759">是不区分大小写的。</st>
- en: <st c="27779">However, what if the user searches for</st> `<st c="27819">manager</st>`<st
    c="27826">? In this case, our query returns no results, even though a typical
    user can search for</st> *<st c="27914">manager</st>* <st c="27921">if they want
    a course</st> <st c="27944">about management.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27779">然而，如果用户搜索</st> `<st c="27819">经理</st>`<st c="27826">呢？在这种情况下，我们的查询没有返回任何结果，尽管一个典型的用户如果想要搜索关于管理的课程，他们可以搜索</st>
    *<st c="27914">经理</st>* <st c="27921">。</st> <st c="27944">他们想要关于管理的课程。</st>
- en: <st c="27961">In this case, we can use the</st> `<st c="27991">NaturalLanguage</st>`
    <st c="28006">framework to try and perform lemmatization of the search phrase.</st>
    **<st c="28072">Lemmatization</st>** <st c="28085">is a technique that reduces
    words to their basic form.</st> <st c="28141">So, the basic</st> <st c="28155">form
    of</st> *<st c="28163">manager</st>* <st c="28170">is</st> *<st c="28174">manage</st>*<st
    c="28180">.</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27961">在这种情况下，我们可以使用</st> `<st c="27991">NaturalLanguage</st>` <st c="28006">框架来尝试对搜索短语进行词形还原。</st>
    **<st c="28072">词形还原</st>** <st c="28085">是一种将单词还原到其基本形式的技巧。</st> <st c="28141">因此，*<st
    c="28163">经理</st>* <st c="28170">的基本形式是</st> *<st c="28174">管理</st>*<st c="28180">。</st>
- en: <st c="28181">However, if we want to match the search phrase</st> *<st c="28229">manage</st>*<st
    c="28235">, we also need all our records with the word</st> *<st c="28280">management</st>*
    <st c="28290">to contain the word</st> *<st c="28311">manage</st>* <st c="28317">so
    that we can filter the results accordingly.</st> <st c="28365">It means we must
    maintain the basic form for each word in</st> <st c="28423">each record.</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28181">然而，如果我们想匹配搜索短语</st> *<st c="28229">管理</st>*<st c="28235">，我们还需要所有包含单词</st>
    *<st c="28280">管理</st>* <st c="28290">的记录都包含单词</st> *<st c="28311">管理</st>* <st
    c="28317">，这样我们才能相应地过滤结果。</st> <st c="28365">这意味着我们必须为每条记录中的每个单词保持基本形式。</st>
- en: <st c="28435">But things can get</st> <st c="28455">even more complex than that.</st>
    <st c="28484">What if the user searches for a management course using the phrase</st>
    *<st c="28551">leadership</st>*<st c="28561">? In this case, we will have to index
    our records with embedded words, as we learned in the</st> *<st c="28653">Word
    tagging</st>* <st c="28665">section of</st> <st c="28677">this chapter.</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28435">但事情可能会比这更复杂。</st> <st c="28455">假设用户使用短语</st> *<st c="28551">领导力</st>*<st
    c="28561">搜索管理课程？在这种情况下，我们将不得不像在本章的</st> *<st c="28653">单词标记</st> <st c="28665">部分</st>
    <st c="28677">中学到的那样，用嵌入的单词索引我们的记录。</st>
- en: <st c="28690">The conclusion is that basic search is easy.</st> <st c="28736">However,
    semantic search, which is much more effective, is also much</st> <st c="28805">more
    complex.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28690">结论是，基本搜索很简单。</st> <st c="28736">然而，语义搜索，虽然更有效，但也更复杂。</st>
- en: <st c="28818">As mentioned, semantic search is built on top of the</st> **<st
    c="28872">Core Spotlight framework</st>**<st c="28896">, starting with iOS 18\.</st>
    <st c="28920">The Core Spotlight</st> <st c="28938">framework is not new – it
    was introduced in 2015 as part of iOS 9 and helps developers index app content
    and make it searchable, using the Spotlight feature</st> <st c="29096">in iOS.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28818">如前所述，语义搜索建立在</st> **<st c="28872">Core Spotlight 框架</st>**<st
    c="28896">之上，从 iOS 18 开始。</st> <st c="28920">Core Spotlight 框架并非新事物——它于 2015 年作为
    iOS 9 的一部分被引入，帮助开发者索引应用程序内容并使其可搜索，使用 iOS 中的 Spotlight 功能</st> <st c="29096">进行搜索。</st>
- en: <st c="29103">This chapter does not cover using the Core Spotlight framework.</st>
    <st c="29168">However, we will briefly review the Core Spotlight principles to
    understand how to enable semantic search.</st> <st c="29275">Let’s begin.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29103">本章不涵盖使用 Core Spotlight 框架。</st> <st c="29168">然而，我们将简要回顾 Core
    Spotlight 原则，以了解如何启用语义搜索。</st> <st c="29275">让我们开始吧。</st>
- en: <st c="29287">Exploring the Core Spotlight framework</st>
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="29287">探索 Core Spotlight 框架</st>
- en: <st c="29326">The Spotlight framework</st> <st c="29350">indexes local data
    and retrieves it by</st> <st c="29390">performing queries.</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29326">Spotlight 框架</st> <st c="29350">通过执行查询来索引本地数据并检索它。</st>
- en: <st c="29409">The Core Spotlight framework has three primary parts – creating
    searchable items, indexing, and querying.</st> <st c="29516">Let’s go through
    the parts one</st> <st c="29547">by one.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29409">Core Spotlight 框架有三个主要部分——创建可搜索项、索引和查询。</st> <st c="29516">让我们逐一介绍这些部分。</st>
- en: <st c="29554">Creating searchable items</st>
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="29554">创建可搜索项</st>
- en: <st c="29580">Let’s say we have instances of a</st> <st c="29614">book structure
    in our local storage and want to implement Core Spotlight to allow users to search</st>
    <st c="29712">for books.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29580">假设我们在本地存储中有书籍结构的实例，并希望实现 Core Spotlight 以允许用户搜索</st> <st c="29712">书籍。</st>
- en: <st c="29722">First, we need to map all our</st> `<st c="29753">Book</st>` <st
    c="29757">instances</st> <st c="29768">to</st> `<st c="29771">CSSearchableItem</st>`<st
    c="29787">:</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29722">首先，我们需要将所有我们的</st> `<st c="29753">Book</st>` <st c="29757">实例</st>
    <st c="29768">映射到</st> `<st c="29771">CSSearchableItem</st>`<st c="29787">:</st>
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="30123">In the preceding code example, we</st> <st c="30157">took an array
    of</st> `<st c="30175">Book</st>` <st c="30179">and mapped it to an array of</st>
    `<st c="30209">CSSearchableItem</st>`<st c="30225">. We do that by creating a</st>
    `<st c="30252">CSSearchableItemAttributeSet</st>` <st c="30280">– an item that
    contains general information about the searchable item.</st> <st c="30352">Then,
    we initialize a new</st> `<st c="30378">CSSearchableItem</st>`<st c="30394">,
    passing our</st> `<st c="30408">CSSearchableItemAttributeSet</st>` <st c="30436">and
    providing a unique identifier that can help us retrieve the</st> `<st c="30501">Book</st>`
    <st c="30505">record</st> <st c="30513">when needed.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30123">在先前的代码示例中，我们</st> <st c="30157">取了一个包含</st> `<st c="30175">Book</st>`
    <st c="30179">的数组，并将其映射到一个包含</st> `<st c="30209">CSSearchableItem</st>`<st c="30225">的数组中。</st>
    <st c="30252">我们通过创建一个</st> `<st c="30252">CSSearchableItemAttributeSet</st>`
    <st c="30280">来完成这项工作——这是一个包含可搜索项一般信息的项。</st> <st c="30352">然后，我们初始化一个新的</st>
    `<st c="30378">CSSearchableItem</st>`<st c="30394">，传递我们的</st> `<st c="30408">CSSearchableItemAttributeSet</st>`
    <st c="30436">并提供一个唯一标识符，这有助于我们在需要时检索</st> `<st c="30501">Book</st>` <st c="30505">记录</st>
    <st c="30513">。</st>
- en: <st c="30525">Indexing</st>
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="30525">索引</st>
- en: <st c="30534">Now that we have an</st> <st c="30555">array of</st> `<st c="30564">CSSearchableItem</st>`<st
    c="30580">, we need to index the array items for the Core Spotlight framework.</st>
    <st c="30649">We do that by</st> <st c="30663">creating</st> `<st c="30672">CSSearchableIndex</st>`<st
    c="30689">:</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30534">现在我们有一个</st> <st c="30555">包含</st> `<st c="30564">CSSearchableItem</st>`<st
    c="30580">的数组，我们需要为Core Spotlight框架索引数组项。</st> <st c="30649">我们通过</st> <st c="30663">创建</st>
    `<st c="30672">CSSearchableIndex</st>`<st c="30689">来完成这项工作：</st>
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="30937">In the preceding example, we created a new</st> `<st c="30981">CSSearchableIndex</st>`
    <st c="30998">and called the</st> `<st c="31014">indexSearchableItems</st>` <st
    c="31034">function, with the array of</st> `<st c="31063">CSSearchableItem</st>`
    <st c="31079">that we made in the previous step.</st> <st c="31115">Note that</st>
    <st c="31124">this is an asynchronous operation and is considered to be</st> <st
    c="31183">quite intensive.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30937">在先前的示例中，我们创建了一个新的</st> `<st c="30981">CSSearchableIndex</st>`
    <st c="30998">并调用了</st> `<st c="31014">indexSearchableItems</st>` <st c="31034">函数，该函数使用我们在上一步中创建的包含</st>
    `<st c="31063">CSSearchableItem</st>` <st c="31079">的数组。</st> <st c="31115">请注意</st>
    <st c="31124">这是一个异步操作，并且被认为是非常密集的。</st>
- en: <st c="31199">Querying</st>
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="31199">查询</st>
- en: <st c="31208">Now that we have an index, we</st> <st c="31239">can perform a
    query to retrieve data based on a</st> <st c="31287">search phrase:</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31208">现在我们有了索引，我们可以</st> <st c="31239">执行一个查询来根据一个</st> <st c="31287">搜索短语</st>检索数据：</st>
- en: '[PRE16]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="31833">In the preceding example, we create a search context containing
    various query information.</st> <st c="31925">Based on the</st> <st c="31937">search
    context and the search phrase, we initialize an item of</st> `<st c="32001">CSUserQuery</st>`
    <st c="32012">and fetch the search results by calling its</st> `<st c="32057">responses</st>`
    <st c="32066">getter.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31833">在先前的示例中，我们创建了一个包含各种查询信息的搜索上下文。</st> <st c="31925">基于</st> <st
    c="31937">搜索上下文和搜索短语，我们初始化了一个</st> `<st c="32001">CSUserQuery</st>` <st c="32012">对象，并通过调用其</st>
    `<st c="32057">responses</st>` <st c="32066">获取器来获取搜索结果。</st>
- en: <st c="32074">The results are an array of</st> `<st c="32103">CSSearchableItem</st>`<st
    c="32119">, and we can retrieve the original item by using the unique identifier
    for</st> <st c="32194">each record.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32074">结果是包含</st> `<st c="32103">CSSearchableItem</st>`<st c="32119">的数组，我们可以通过使用每个记录的唯一标识符来检索原始项。</st>
- en: <st c="32206">Now that we know how to implement search using the Core Spotlight
    framework, let’s see how to implement a</st> <st c="32313">semantic search.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32206">现在我们知道了如何使用Core Spotlight框架实现搜索，让我们看看如何实现一个</st> `<st c="32313">语义搜索</st>`。</st>
- en: <st c="32329">Implementing semantic search</st>
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="32329">实现语义搜索</st>
- en: <st c="32358">Adding semantic search</st> <st c="32382">capabilities to an existing
    Core Spotlight search is simple.</st> <st c="32443">All we need to do is load
    the ML model once using the following</st> <st c="32507">static function:</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32358">将语义搜索功能添加到现有的Core Spotlight搜索中很简单。</st> <st c="32382">我们所需做的只是使用以下</st>
    <st c="32507">静态函数</st>加载ML模型一次：
- en: '[PRE17]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="32545">The</st> `<st c="32550">prepare</st>` <st c="32557">function prepares
    the Core Spotlight framework to load its ML models for</st> <st c="32631">semantic
    search.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32545">`<st c="32550">prepare</st>` <st c="32557">函数使Core Spotlight框架准备好加载其用于</st>
    <st c="32631">语义搜索</st>的ML模型。</st>
- en: <st c="32647">If the search index has a protection level due to privacy concerns,
    we also need to call the</st> `<st c="32741">prepreProtectionClasses</st>` <st
    c="32764">function:</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果搜索索引由于隐私问题具有保护级别，我们还需要调用<st c="32741">prepreProtectionClasses</st> <st c="32764">函数：</st>
- en: '[PRE18]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="32834">This function prepares the search for indexes marked with the</st>
    `<st c="32897">completeUnlessOpen</st>` <st c="32915">protection level.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能准备搜索标记为具有<st c="32897">completeUnlessOpen</st> <st c="32915">保护级别</st>的索引。
- en: <st c="32933">What are protection levels?</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是保护级别？
- en: <st c="32961">The term</st> **<st c="32971">protection level</st>** <st c="32987">refers
    to the</st> <st c="33002">accessibility level where users have specific resources,
    considering the device’s</st> <st c="33084">security conditions.</st> <st c="33105">There
    are three primary</st> <st c="33129">protection levels:</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**<st c="32971">保护级别</st>**指的是用户具有特定资源的可访问级别，考虑到设备的安全条件。<st c="33084">这里有三种主要</st>
    <st c="33129">保护级别：</st>
- en: '<st c="33147">-</st> `<st c="33150">NSFileProtectionNone</st>`<st c="33170">:
    The index is always accessible, even when the device</st> <st c="33226">is locked</st>'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33150">NSFileProtectionNone</st><st c="33170">：索引始终可访问，即使设备<st c="33226">锁定</st>时也是如此
- en: '<st c="33235">-</st> `<st c="33238">NSFileProtectionCompleteUntilFirstUserAuthentication</st>`<st
    c="33290">: Once the user is authenticated for the first time after a device restart,
    the index</st> <st c="33377">is accessible</st>'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33238">NSFileProtectionCompleteUntilFirstUserAuthentication</st><st c="33290">：设备重启后，用户首次认证成功，索引<st
    c="33377">可访问</st>
- en: '<st c="33390">-</st> `<st c="33393">NSFileProtectionComplete</st>`<st c="33417">:
    The index is accessible only when the device</st> <st c="33465">is unlocked</st>'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33393">NSFileProtectionComplete</st><st c="33417">：索引仅在设备<st c="33465">解锁</st>时才可访问
- en: <st c="33476">Remember that preparing the ML models costs time and memory, so
    it’s better to call the</st> `<st c="33565">prepare</st>` <st c="33572">function
    only immediately before the search</st> <st c="33617">user interface.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，准备 ML 模型需要时间和内存，所以最好在搜索用户界面立即之前调用<st c="33565">prepare</st> <st c="33572">函数。
- en: <st c="33632">We have discussed various</st> <st c="33659">built-in ML models,
    and we can see that they cover many use cases where we can use ML capabilities
    with our projects.</st> <st c="33777">However, there are cases where the iOS SDK
    doesn’t provide the exact ML solution we need.</st> <st c="33867">Luckily, we
    can integrate our models using the</st> <st c="33914">CoreML framework.</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了各种<st c="33659">内置 ML 模型，我们可以看到它们涵盖了我们可以使用 ML 功能的许多用例。<st c="33777">然而，有些情况下，iOS
    SDK 并没有提供我们需要的确切 ML 解决方案。</st> <st c="33867">幸运的是，我们可以使用</st> <st c="33914">CoreML
    框架</st>集成我们的模型。
- en: <st c="33931">Integrating custom models using CoreML</st>
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 CoreML 集成自定义模型
- en: <st c="33970">Generally, ML models are trained to perform a specific task –
    recognizing a sentence’s sentiment, detecting humans, or analyzing sounds are
    all examples of different tasks done using various models.</st> <st c="34170">This</st>
    <st c="34175">means that even though the potential of the existing models is enormous,
    we are still limited in what we</st> <st c="34280">can do.</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ML 模型是训练来执行特定任务的——识别句子的情感、检测人类或分析声音都是使用不同模型完成的不同任务的例子。<st c="34170">这意味着尽管现有模型潜力巨大，但我们仍然在能做什么方面受到限制。</st>
    <st c="34175">这意味着</st> <st c="34175">即使现有模型的潜力巨大，我们仍然在能做什么方面受到限制。
- en: <st c="34287">This is where the</st> **<st c="34306">CoreML framework</st>**
    <st c="34322">enters the</st> <st c="34334">picture.</st> <st c="34343">Using
    CoreML, we can integrate ML models that are not part</st> <st c="34402">of the
    iOS SDK, and we can even train our own models and add more</st> <st c="34468">intelligent
    capabilities.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**CoreML 框架**<st c="34306">进入场景的地方。</st> <st c="34322">使用 CoreML，我们可以集成 iOS
    SDK 之外的 ML 模型，我们甚至可以训练自己的模型并添加更多<st c="34468">智能能力。</st>
- en: <st c="34493">It’s best to explain how to do this by using an example, such
    as detecting</st> <st c="34569">spam messages.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过一个例子来说明如何做这件事，比如检测<st c="34569">垃圾邮件。</st>
- en: <st c="34583">Imaging we are developing a messaging app.</st> <st c="34627">One
    of the most popular messaging app features is the ability to detect spam to improve
    the user experience and</st> <st c="34739">increase retention.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34583">假设我们正在开发一个消息应用。</st> <st c="34627">最受欢迎的消息应用功能之一是检测垃圾邮件，以提高用户体验和</st>
    <st c="34739">增加用户留存率。</st>
- en: <st c="34758">We must create an ML model to classify messages as spam to implement
    a</st> <st c="34830">spam detector.</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34758">我们必须创建一个ML模型来将消息分类为垃圾邮件，以实现一个</st> <st c="34830">垃圾邮件检测器。</st>
- en: <st c="34844">To achieve this, we can use a desktop application called Create
    ML, which is part of the Xcode suite.</st> <st c="34947">Let’s begin by learning
    more about</st> <st c="34982">Create ML!</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34844">为了实现这一点，我们可以使用一个名为Create ML的桌面应用程序，它是Xcode套件的一部分。</st> <st c="34947">让我们先来了解一下</st>
    <st c="34982">Create ML！</st>
- en: <st c="34992">Getting to know the Create ML application</st>
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="34992">了解Create ML应用程序</st>
- en: '**<st c="35034">Create ML</st>** <st c="35044">was introduced in 2018 as</st>
    <st c="35071">part of Apple’s ongoing effort to make ML more accessible to developers.</st>
    <st c="35144">We can build, train, and deploy ML models in various areas using</st>
    <st c="35209">Create ML.</st>'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="35034">Create ML</st>** <st c="35044">于2018年作为</st> <st c="35071">苹果公司持续努力使机器学习对开发者更易获取的一部分而推出。</st>
    <st c="35144">我们可以使用Create ML在各个领域构建、训练和部署ML模型。</st>'
- en: <st c="35219">To open Create ML, follow</st> <st c="35246">these steps:</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35219">要打开Create ML，请按照</st> <st c="35246">以下步骤操作：</st>
- en: <st c="35258">Open Xcode.</st>
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35258">打开Xcode。</st>
- en: <st c="35270">Right-click on the Xcode icon on</st> <st c="35304">the dock.</st>
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35270">在Dock上的Xcode图标上</st> <st c="35304">右键单击。</st>
- en: <st c="35313">Select</st> **<st c="35321">Open Developer Tool</st>** <st c="35340">|</st>
    **<st c="35343">Create ML</st>**<st c="35352">.</st>
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="35313">选择</st> **<st c="35321">打开开发者工具</st>** <st c="35340">|</st> **<st
    c="35343">Create ML</st>**<st c="35352">。</st>
- en: <st c="35353">Another way to open</st> `<st c="35374">Create ML</st>` <st c="35383">is
    by searching for it in Spotlight on your Mac and</st> <st c="35436">selecting
    it.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35353">另一种打开</st> `<st c="35374">Create ML</st>` <st c="35383">的方法是在Mac的Spotlight中搜索它，并</st>
    <st c="35436">选择它。</st>
- en: <st c="35449">After opening it and clicking on the</st> **<st c="35487">New
    Document</st>** <st c="35499">button, we get the following screen (</st>*<st c="35537">Figure
    12</st>**<st c="35547">.1</st>*<st c="35549">):</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35449">打开它并点击</st> **<st c="35487">新建文档</st>** <st c="35499">按钮后，我们会看到以下屏幕（</st>*<st
    c="35537">图12.1</st>**<st c="35547">.1</st>*<st c="35549">）：</st>
- en: '![Figure 12.1: The Create ML template picker](img/B21795_12_1.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：创建ML模板选择器](img/B21795_12_1.jpg)'
- en: '<st c="36033">Figure 12.1: The Create ML template picker</st>'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36033">图12.1：创建ML模板选择器</st>
- en: '*<st c="36075">Figure 12</st>**<st c="36085">.1</st>* <st c="36087">shows the
    Create ML template picker screen.</st> <st c="36132">Each template represents
    a different configuration for our model, and each is designed to handle a different
    type of data.</st> <st c="36255">For example, the</st> **<st c="36272">Image Classification</st>**
    <st c="36292">template is designed to handle images.</st> <st c="36332">Since
    we want to classify</st> <st c="36358">text messages, we will pick the</st> **<st
    c="36390">Text Classification</st>** <st c="36409">template and click the</st>
    **<st c="36433">Next</st>** <st c="36437">button.</st>'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="36075">图12</st>**<st c="36085">.1</st>* <st c="36087">显示了Create ML模板选择器屏幕。</st>
    <st c="36132">每个模板代表我们模型的不同配置，每个都是为处理不同类型的数据而设计的。</st> <st c="36255">例如，</st>
    **<st c="36272">图像分类</st>** <st c="36292">模板是为处理图像而设计的。</st> <st c="36332">由于我们想要对</st>
    <st c="36358">文本消息进行分类，我们将选择</st> **<st c="36390">文本分类</st>** <st c="36409">模板并点击</st>
    **<st c="36433">下一步</st>** <st c="36437">按钮。</st>'
- en: <st c="36445">This will take us to the project details screen (</st>*<st c="36495">Figure
    12</st>**<st c="36505">.2</st>*<st c="36507">):</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36445">这将带我们进入项目详情屏幕（</st>*<st c="36495">图12.2</st>**<st c="36505">）：</st>
- en: '![Figure 12.2: The project details form](img/B21795_12_2.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：项目详情表](img/B21795_12_2.jpg)'
- en: '<st c="36940">Figure 12.2: The project details form</st>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36940">图12.2：项目详情表</st>
- en: <st c="36977">In the project details form, we will fill in some general information
    about our ML model, such as the name, author, license, and description, and then</st>
    <st c="37129">click</st> **<st c="37135">Next</st>**<st c="37139">.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36977">在项目详情表中，我们将填写一些关于我们的ML模型的一般信息，例如名称、作者、许可证和描述，然后</st> <st c="37129">点击</st>
    **<st c="37135">下一步</st>**<st c="37139">。</st>
- en: <st c="37140">Our next screen is the project window (</st>*<st c="37180">Figure
    12</st>**<st c="37190">.3</st>*<st c="37192">):</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37140">我们的下一个屏幕是项目窗口（</st>*<st c="37180">图12</st>**<st c="37190">.3</st>**<st
    c="37192">）：</st>
- en: '![Figure 12.3: The SpamClassifier project window](img/B21795_12_3.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：SpamClassifier项目窗口](img/B21795_12_3.jpg)'
- en: '<st c="37585">Figure 12.3: The SpamClassifier project window</st>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37585">图12.3：SpamClassifier项目窗口</st>
- en: <st c="37631">In</st> *<st c="37635">Figure 12</st>**<st c="37644">.3</st>*<st
    c="37646">, we can see the</st> `<st c="37663">SpamClassifier</st>` <st c="37677">project
    window.</st> <st c="37694">The project window is the main window</st> <st c="37732">where
    we will build our model.</st> <st c="37763">Let’s go over the different</st> <st
    c="37791">window components:</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37631">在</st> *<st c="37635">图12</st>**<st c="37644">.3</st>*<st c="37646">中，我们可以看到</st>
    `<st c="37663">SpamClassifier</st>` <st c="37677">项目窗口。</st> <st c="37694">项目窗口是我们构建模型的主要窗口。</st>
    <st c="37732">让我们回顾一下不同的</st> <st c="37791">窗口组件：</st>
- en: '**<st c="37809">Left pane</st>**<st c="37819">: The left pane lists the project’s
    different sources – the ML model and its data sources, used for training</st>
    <st c="37929">and testing</st>'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37809">左侧面板</st>**<st c="37819">：左侧面板列出了项目的不同来源 - 机器学习模型及其数据来源，用于训练和测试</st>'
- en: '**<st c="37940">Settings tab</st>**<st c="37953">: The</st> **<st c="37960">Settings</st>**
    <st c="37968">tab is where we define the different data sources for the various
    phases and general</st> <st c="38054">training parameters</st>'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37940">设置选项卡</st>**<st c="37953">：该</st> **<st c="37960">设置</st>**
    <st c="37968">选项卡是我们定义不同阶段和一般</st> <st c="38054">训练参数</st>'
- en: '**<st c="38073">Training tab</st>**<st c="38086">: The</st> **<st c="38093">Training</st>**
    <st c="38101">tab shows the progress of the</st> <st c="38132">training operation</st>'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38073">训练选项卡</st>**<st c="38086">：该</st> **<st c="38093">训练</st>**
    <st c="38101">选项卡显示了训练操作的进度</st>'
- en: '**<st c="38150">Evaluation tab</st>**<st c="38165">: The</st> **<st c="38172">Evaluation</st>**
    <st c="38182">tab shows the performance of our model in the</st> <st c="38229">different
    phases</st>'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38150">评估选项卡</st>**<st c="38165">：该</st> **<st c="38172">评估</st>**
    <st c="38182">选项卡显示了我们的模型在不同阶段</st> <st c="38229">的性能</st>'
- en: '**<st c="38245">Preview tab</st>**<st c="38257">: We can</st> *<st c="38267">play</st>*
    <st c="38271">with our ML model and experience it in the</st> **<st c="38315">Preview</st>**
    <st c="38322">tab</st>'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38245">预览选项卡</st>**<st c="38257">：我们可以在</st> *<st c="38267">预览</st>**
    <st c="38271">选项卡中* <st c="38271">与我们的机器学习模型互动并体验它</st>'
- en: '**<st c="38326">Output tab</st>**<st c="38337">: The</st> **<st c="38344">Output</st>**
    <st c="38350">tab is the place where we can deploy</st> <st c="38388">our model</st>'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="38326">输出选项卡</st>**<st c="38337">：该</st> **<st c="38344">输出</st>**
    <st c="38350">选项卡是我们部署</st> <st c="38388">我们的模型</st>'
- en: <st c="38397">The list of the components reflects the phases we must go through
    when we build</st> <st c="38478">our model.</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38397">组件列表反映了我们在构建</st> <st c="38478">我们的模型时必须经历的各个阶段。</st>
- en: <st c="38488">Now that we know what Create ML is, let’s start building</st>
    <st c="38546">our model.</st>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38488">现在我们知道了Create ML是什么，让我们开始构建</st> <st c="38546">我们的模型。</st>
- en: <st c="38556">Building our Spam Classifier model</st>
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="38556">构建我们的垃圾邮件分类器模型</st>
- en: <st c="38591">Our Spam Classifier</st> <st c="38612">model-building process
    is based on three</st> <st c="38653">data sources – training, validation, and
    testing data.</st> <st c="38708">These three data sources are something we covered
    earlier in this chapter in the</st> *<st c="38789">Training the</st>* *<st c="38802">model</st>*
    <st c="38807">section.</st>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38591">我们的垃圾邮件分类器</st> <st c="38612">模型构建过程基于三个</st> <st c="38653">数据来源
    - 训练数据、验证数据和测试数据。</st> <st c="38708">这三个数据来源是我们在本章前面*<st c="38789">训练</st>* *<st
    c="38802">模型</st>* <st c="38807">部分中提到的。</st>
- en: <st c="38816">First, let’s take a look at how we will prepare</st> <st c="38865">our
    data.</st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38816">首先，让我们看看我们将如何准备</st> <st c="38865">我们的数据。</st>
- en: <st c="38874">Preparing our data</st>
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="38874">准备我们的数据</st>
- en: <st c="38893">Since we are building a</st> <st c="38918">Spam Classifier model,
    we must prepare a dataset containing both spam and non-spam messages.</st> <st
    c="39011">The text classification template requires our dataset to be in the form
    of a CSV file with two columns –</st> `<st c="39116">text</st>` <st c="39120">and</st>
    `<st c="39125">label</st>`<st c="39130">. In our case, the</st> `<st c="39149">text</st>`
    <st c="39153">column represents the content of the SMS message, and the</st> `<st
    c="39212">label</st>` <st c="39217">column is the classification –</st> `<st c="39249">true</st>`
    <st c="39253">for a spam message and</st> `<st c="39277">false</st>` <st c="39282">for
    non-spam.</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38893">由于我们正在构建一个</st> <st c="38918">垃圾邮件分类器模型，我们必须准备一个包含垃圾邮件和非垃圾邮件的数据集。</st>
    <st c="39011">文本分类模板要求我们的数据集以CSV文件的形式存在，包含两列 –</st> `<st c="39116">文本</st>` <st
    c="39120">和</st> `<st c="39125">标签</st>`<st c="39130">。在我们的案例中，</st> `<st c="39149">文本</st>`
    <st c="39153">列代表短信的内容，而</st> `<st c="39212">标签</st>` <st c="39217">列是分类 –</st>
    `<st c="39249">true</st>` <st c="39253">表示垃圾邮件，而</st> `<st c="39277">false</st>`
    <st c="39282">表示非垃圾邮件。</st>
- en: <st c="39296">The ratio between the spam and the non-spam messages needs to
    reflect the real-world distribution.</st> <st c="39396">In our case, we have a
    dataset file with 300,000 records, where 10% of them are spam messages and 90%
    are</st> <st c="39502">non-spam messages.</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39296">垃圾邮件和非垃圾邮件之间的比例需要反映现实世界的分布。</st> <st c="39396">在我们的案例中，我们有一个包含300,000条记录的数据集文件，其中10%是垃圾邮件，90%是</st>
    <st c="39502">非垃圾邮件。</st>
- en: <st c="39520">To set the</st> **<st c="39532">training dataset</st>**<st c="39548">,
    we can drag the</st> <st c="39565">CSV file into the</st> **<st c="39584">Training
    Data</st>** <st c="39597">box (</st>*<st c="39603">Figure 12</st>**<st c="39613">.4</st>*<st
    c="39615">):</st>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39520">要设置</st> **<st c="39532">训练数据集</st>**<st c="39548">，我们可以将</st>
    <st c="39565">CSV文件拖放到</st> **<st c="39584">训练数据</st>** <st c="39597">框中（</st>*<st
    c="39603">图12</st>**<st c="39613">.4</st>*<st c="39615">）：</st>
- en: '![Figure 12.4: Training Data with 300,000 records](img/B21795_12_4.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：包含300,000条记录的训练数据](img/B21795_12_4.jpg)'
- en: '<st c="39986">Figure 12.4: Training Data with 300,000 records</st>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39986">图12.4：包含300,000条记录的训练数据</st>
- en: '*<st c="40033">Figure 12</st>**<st c="40043">.4</st>* <st c="40045">shows the</st>
    `<st c="40156">true</st>` <st c="40160">and</st> `<st c="40165">false</st>`<st
    c="40170">, as stated earlier.</st> <st c="40191">In addition, we also have a
    new</st> <st c="40223">data source in the left pane – the file we imported as
    the</st> <st c="40282">training dataset.</st>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="40033">图12</st>**<st c="40043">.4</st>* <st c="40045">显示了</st> `<st
    c="40156">真实</st>` <st c="40160">和</st> `<st c="40165">虚假</st>`<st c="40170">，如前所述。</st>
    <st c="40191">此外，我们还在左侧面板中有一个新的</st> <st c="40223">数据源 – 我们作为训练数据集导入的文件。</st>'
- en: <st c="40299">We can handle the</st> **<st c="40318">validation data</st>**
    <st c="40333">now that</st> <st c="40342">we have the training data.</st> <st
    c="40370">As a reminder, as part of the training process, we will use the validation
    data to tune the model.</st> <st c="40469">We can provide our own validation data,
    but Create ML allows us to split it from the training dataset we’ve</st> <st c="40577">just
    supplied.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40299">现在我们有了训练数据，我们可以处理</st> **<st c="40318">验证数据</st>** <st c="40333">了。</st>
    <st c="40342">提醒一下，作为训练过程的一部分，我们将使用验证数据来调整模型。</st> <st c="40370">我们可以提供自己的验证数据，但Create
    ML允许我们从我们刚刚提供的训练数据集中分割它。</st> <st c="40469">我们可以在评估步骤中稍后添加</st> <st c="40577">测试数据集</st>。
- en: <st c="40591">The third dataset is the</st> **<st c="40617">testing data</st>**<st
    c="40629">. We use the testing data to see how the model classifies unseen text.</st>
    <st c="40700">We can add the</st> <st c="40714">testing dataset later in the</st>
    <st c="40744">evaluation step.</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40591">第三个数据集是</st> **<st c="40617">测试数据</st>**<st c="40629">。我们使用测试数据来查看模型如何对未见过的文本进行分类。</st>
    <st c="40700">我们可以在评估步骤中稍后添加</st> <st c="40714">测试数据集</st>。
- en: <st c="40760">Apart from choosing the different datasets, we can also set the
    number of iterations our training will go through and the</st> <st c="40883">model
    algorithm.</st>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40760">除了选择不同的数据集，我们还可以设置训练将进行的迭代次数和</st> <st c="40883">模型算法</st>。
- en: <st c="40899">With each iteration, the training process can tune itself by reviewing
    the errors from the previous iteration and adjusting its parameters (like weights
    in a neural network).</st> <st c="41075">Our intuition may say that the more iterations
    we have, the more our model will be smarter.</st> <st c="41167">However, this
    is not so.</st> <st c="41192">First, at some point, having another iteration stops
    improving the model and only consumes computational resources.</st> <st c="41308">But
    the real problem is what we call overfitting.</st> **<st c="41358">Overfitting</st>**
    <st c="41369">is when an ML model learns the</st> <st c="41400">training data
    too well, including its noise.</st> <st c="41446">In this case, there will be
    issues with analyzing</st> <st c="41496">unseen data.</st>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代中，训练过程可以通过回顾前一次迭代的错误并调整其参数（如神经网络中的权重）来自我调整。我们的直觉可能会说，迭代次数越多，我们的模型就越聪明。然而，事实并非如此。首先，在某个点上，再进行迭代并不能提高模型，只会消耗计算资源。但真正的问题是所谓的过拟合。**过拟合**是指机器学习模型学习训练数据过于完美，包括其噪声。在这种情况下，分析未见数据将会有问题。
- en: <st c="41508">Another parameter is the model algorithm (</st>*<st c="41551">Figure
    12</st>**<st c="41561">.5</st>*<st c="41563">):</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个参数是模型算法（**图12.5**）：
- en: '![Figure 12.5: Choosing the model algorithm](img/B21795_12_5.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5：选择模型算法](img/B21795_12_5.jpg)'
- en: '<st c="41788">Figure 12.5: Choosing the model algorithm</st>'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**图12.5：选择模型算法**'
- en: '*<st c="41829">Figure 12</st>**<st c="41839">.5</st>* <st c="41841">shows the</st>
    <st c="41852">pop-up menu where we can choose the model learning algorithm from
    five different options.</st> <st c="41942">The algorithm overview is not in this
    chapter’s scope, but in short, different algorithms are suitable for different
    needs and consume other resources.</st> <st c="42094">For example, the</st> **<st
    c="42111">BERT</st>** <st c="42115">algorithm is ideal for semantic understanding,
    and</st> <st c="42166">the</st> **<st c="42171">Conditional Random Field</st>**
    <st c="42195">is great for</st> <st c="42209">sequence labeling.</st> <st c="42228">In
    our case, we will choose the</st> **<st c="42260">Maximum Entropy</st>** <st c="42275">algorithm,
    which is excellent</st> <st c="42306">for classification.</st>'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '***图12.5*** 显示了弹出菜单，我们可以从五个不同的选项中选择模型学习算法。算法概述不在本章的范围内，但简而言之，不同的算法适合不同的需求，并消耗其他资源。例如，**BERT**算法非常适合语义理解，而**条件随机字段**算法非常适合**序列标注**。在我们的案例中，我们将选择**最大熵**算法，它非常适合**分类**。'
- en: <st c="42325">Now that we have all our datasets ready, we can click the</st>
    **<st c="42384">Train</st>** <st c="42389">button in the top-left corner and start</st>
    <st c="42430">our training.</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有数据集，我们可以点击左上角的**训练**按钮并开始**训练**。
- en: <st c="42443">Performing the training</st>
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行训练**'
- en: <st c="42467">Now, we have arrived at the</st> <st c="42496">main dish – the
    training phase.</st> <st c="42528">In the training phase, the Create ML app goes
    over the training dataset using the algorithm we defined in the</st> *<st c="42638">Preparing
    our data</st>* <st c="42656">section.</st> <st c="42666">Let’s try to describe</st>
    <st c="42688">that process:</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了**主要环节——训练阶段**。在训练阶段，Create ML 应用程序会使用我们在**准备我们的数据**部分定义的算法遍历训练数据集。让我们尝试描述这个过程：
- en: <st c="42701">In each iteration, the model</st> *<st c="42731">verifies itself</st>*
    <st c="42746">using the validation dataset.</st> <st c="42777">Remember that the
    validation dataset can be distinct.</st> <st c="42831">However, by default, it
    is a subset of the</st> <st c="42874">training dataset.</st>
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次迭代中，模型使用验证数据集来**验证自身**。记住，验证数据集可以是不同的。然而，默认情况下，它是训练数据集的一个子集。
- en: <st c="42891">The</st> *<st c="42896">duration</st>* <st c="42904">of the training
    phase is derived from three major factors – the dataset size, the number of iterations,
    and the</st> <st c="43017">chosen algorithm.</st>
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="42891">训练</st> *<st c="42896">阶段的时间长度由三个主要因素决定</st> <st c="42904">——数据集大小、迭代次数和</st>
    <st c="43017">选择的算法。</st>
- en: <st c="43034">The model doesn’t have to perform the number of iterations we
    defined in the</st> **<st c="43112">Settings</st>** <st c="43120">tab.</st> <st
    c="43126">If the validation accuracy reaches a high level,</st> *<st c="43175">the
    training will stop earlier</st>* <st c="43205">to save resources and</st> <st
    c="43228">avoid overfitting.</st>
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="43034">模型不需要执行我们在</st> **<st c="43112">设置</st>** <st c="43120">选项卡中定义的迭代次数。</st>
    <st c="43126">如果验证准确率达到高水平，</st> *<st c="43175">训练将提前停止</st> * <st c="43205">以节省资源并</st>
    <st c="43228">避免过拟合。</st>
- en: <st c="43246">At the end of the training</st> <st c="43273">process, we’ll see
    the following graph (</st>*<st c="43314">Figure 12</st>**<st c="43324">.6</st>*<st
    c="43326">):</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43246">在训练</st> <st c="43273">过程结束时，我们将看到以下图表（</st>*<st c="43314">图12</st>**<st
    c="43324">.6</st>*<st c="43326">）：</st>
- en: '![Figure 12.6: The Training tab at the end of the training process](img/B21795_12_6.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6：训练过程结束时的训练选项卡](img/B21795_12_6.jpg)'
- en: '<st c="43660">Figure 12.6: The Training tab at the end of the training process</st>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43660">图12.6：训练过程结束时的训练选项卡</st>
- en: '*<st c="43724">Figure 12</st>**<st c="43734">.6</st>* <st c="43736">shows how
    well we did in our training phase.</st> <st c="43782">We can see that we have
    reached a high accuracy after only two iterations.</st> <st c="43857">In this
    case, it is because our training dataset is well-structured and reliable.</st>
    <st c="43939">However, that won’t always be the case, so we need patience in</st>
    <st c="44002">this step.</st>'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="43724">图12</st>**<st c="43734">.6</st>* <st c="43736">显示了我们在训练阶段的表现。</st>
    <st c="43782">我们可以看到，在仅经过两次迭代后，我们就达到了高准确率。</st> <st c="43857">在这种情况下，这是因为我们的训练数据集结构良好且可靠。</st>
    <st c="43939">然而，情况并不总是如此，因此我们需要在这个步骤中保持耐心。</st>'
- en: <st c="44012">Now that our model has been trained, we need to test it.</st>
    <st c="44070">To do that, we will use our test dataset as part of the evaluation
    step (</st>*<st c="44143">Figure 12</st>**<st c="44153">.7</st>*<st c="44155">):</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44012">现在我们的模型已经训练好了，我们需要对其进行测试。</st> <st c="44070">为此，我们将使用我们的测试数据集作为评估步骤的一部分（</st>*<st
    c="44143">图12</st>**<st c="44153">.7</st>*<st c="44155">）：</st>
- en: '![Figure 12.7: The model evaluation step](img/B21795_12_7.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7：模型评估步骤](img/B21795_12_7.jpg)'
- en: '<st c="44654">Figure 12.7: The model evaluation step</st>'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44654">图12.7：模型评估步骤</st>
- en: '*<st c="44692">Figure 12</st>**<st c="44702">.7</st>* <st c="44704">shows the
    evaluation step and the different datasets used to train and validate the model.</st>
    <st c="44796">We can also see that the testing data contains a dataset of 1,000
    items.</st> <st c="44869">The testing dataset</st> <st c="44889">structure is
    similar to the training and validation datasets.</st> <st c="44951">Tapping on
    the</st> **<st c="44966">Test</st>** <st c="44970">button runs the classification
    on all the 1,000 items in the dataset and measures their classification accuracy.</st>
    <st c="45084">Let’s see the test result (</st>*<st c="45111">Figure 12</st>**<st
    c="45121">.8</st>*<st c="45123">):</st>'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="44692">图12</st>**<st c="44702">.7</st>* <st c="44704">显示了评估步骤以及用于训练和验证模型的不同的数据集。</st>
    <st c="44796">我们还可以看到测试数据包含一个包含1,000个项目的数据集。</st> <st c="44869">测试数据集</st> <st
    c="44889">的结构与训练和验证数据集相似。</st> <st c="44951">点击</st> **<st c="44966">测试</st>**
    <st c="44970">按钮将在数据集中的所有1,000个项目上运行分类，并测量它们的分类准确率。</st> <st c="45084">让我们看看测试结果（</st>*<st
    c="45111">图12</st>**<st c="45121">.8</st>*<st c="45123">）：</st>'
- en: '![Figure 12.8: The evaluation results](img/B21795_12_8.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8：评估结果](img/B21795_12_8.jpg)'
- en: '<st c="45602">Figure 12.8: The evaluation results</st>'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45602">图12.8：评估结果</st>
- en: '*<st c="45637">Figure 12</st>**<st c="45647">.8</st>* <st c="45649">presents
    some</st> <st c="45663">terms that we need to be familiar with if we want to understand</st>
    <st c="45728">the report:</st>'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="45637">图12</st>**<st c="45647">.8</st>* <st c="45649">展示了我们需要熟悉的一些术语，以便理解这份报告：</st>'
- en: '`<st c="45825">true</st>` <st c="45829">or</st> `<st c="45833">false</st>`
    <st c="45838">(depending on the specific class) and that were correct.</st> <st
    c="45896">For example, 93% precision for the</st> `<st c="45931">false</st>` <st
    c="45936">class means that 93% of all the messages the model identifies as</st>
    `<st c="46002">false</st>` <st c="46007">were</st> <st c="46013">actually</st>
    `<st c="46022">false</st>`<st c="46027">.</st>'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="45825">true</st>` <st c="45829">或</st> `<st c="45833">false</st>` <st
    c="45838">(根据具体类别而定)并且是正确的。</st> <st c="45896">例如，对于</st> `<st c="45931">false</st>`
    <st c="45936">类别，93%的精确率意味着模型识别为</st> `<st c="46002">false</st>` <st c="46007">的所有消息实际上</st>
    <st c="46013">确实是</st> `<st c="46022">false</st>`<st c="46027">。</st>'
- en: '`<st c="46102">true</st>` <st c="46106">class means that the model correctly
    identified 93% of all actual</st> <st c="46173">spam messages.</st>'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="46102">true</st>` <st c="46106">类别意味着模型正确识别了所有实际</st> <st c="46173">垃圾邮件消息的93%。</st>'
- en: '**<st c="46187">F1 Score</st>**<st c="46196">: The F1 score is the balance
    between precision</st> <st c="46245">and recall.</st>'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="46187">F1分数</st>**<st c="46196">：F1分数是精确率和召回率的平衡。'
- en: <st c="46256">The</st> **<st c="46261">F1 Score</st>** <st c="46269">involves
    more than just measuring a model’s accuracy.</st> <st c="46324">It balances two
    important metrics –</st> **<st c="46360">precision</st>** <st c="46369">and</st>
    **<st c="46374">recall</st>** <st c="46380">– and reflects a better model performance
    measurement.</st> <st c="46436">In our case, a score of 0.96 is considered a very</st>
    <st c="46486">high performance.</st>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46256">**<st c="46261">F1分数</st>** <st c="46269">不仅涉及测量模型的准确性。</st> <st
    c="46324">它平衡了两个重要的指标——</st> **<st c="46360">精确率</st>** <st c="46369">和</st> **<st
    c="46374">召回率</st>** <st c="46380">——并且反映了更好的模型性能测量。</st> <st c="46436">在我们的案例中，0.96的分数被认为是非常</st>
    <st c="46486">高的性能。</st>
- en: <st c="46503">Our next tab is</st> **<st c="46520">Preview</st>**<st c="46527">,
    where we can play within a playground zone (</st>*<st c="46573">Figure 12</st>**<st
    c="46583">.9</st>*<st c="46585">):</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46503">我们的下一个选项卡是</st> **<st c="46520">预览</st>**<st c="46527">，在那里我们可以在游乐场区域内进行操作（</st>*<st
    c="46573">图12</st>**<st c="46583">.9</st>*<st c="46585">）：</st>
- en: '![Figure 12.9: The Preview tab](img/B21795_12_9.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图12.9：预览选项卡](img/B21795_12_9.jpg)'
- en: '<st c="46760">Figure 12.9: The Preview tab</st>'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46760">图12.9：预览选项卡</st>
- en: '*<st c="46788">Figure 12</st>**<st c="46798">.9</st>* <st c="46800">shows our
    model’s</st> **<st c="46819">Preview</st>** <st c="46826">tab, with an example
    message that says,</st> **<st c="46867">Call now to get an invite</st>**<st c="46892">.
    Our</st> <st c="46898">model identified this message as spam with a 92% confidence.</st>
    <st c="46959">Good job!</st>'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="46788">图12</st>**<st c="46798">.9</st>* <st c="46800">显示了我们的模型的</st>
    **<st c="46819">预览</st>** <st c="46826">选项卡，其中有一个示例消息说，</st> **<st c="46867">现在打电话获取邀请</st>**<st
    c="46892">。我们的</st> <st c="46898">模型以92%的置信度将该消息识别为垃圾邮件。</st> <st c="46959">干得好！</st>'
- en: <st c="46968">Now, let’s see how we can deploy</st> <st c="47002">our model.</st>
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46968">现在，让我们看看我们如何部署</st> <st c="47002">我们的模型。</st>
- en: <st c="47012">Deploying our model</st>
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="47012">部署我们的模型</st>
- en: <st c="47032">There’s no point in</st> <st c="47053">having a great training
    process if we can’t deploy it in Xcode.</st> <st c="47117">This is why we have
    the</st> **<st c="47141">Output</st>** <st c="47147">tab (</st>*<st c="47153">Figure
    12</st>**<st c="47163">.10</st>*<st c="47166">):</st>
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47032">如果我们不能在Xcode中部署它，那么拥有一个出色的训练过程是没有意义的。</st> <st c="47053">这就是为什么我们有</st>
    **<st c="47141">输出</st>** <st c="47147">选项卡（</st>*<st c="47153">图12</st>**<st
    c="47163">.10</st>*<st c="47166">）：</st>
- en: '![Figure 12.10: The Create ML Output tab](img/B21795_12_10.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10：创建ML输出选项卡](img/B21795_12_10.jpg)'
- en: '<st c="47903">Figure 12.10: The Create ML Output tab</st>'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47903">图12.10：创建ML输出选项卡</st>
- en: <st c="47941">The</st> **<st c="47946">Output</st>** <st c="47952">tab shows
    a summary of our model, including a new detail we haven’t seen until now – the</st>
    <st c="48042">model size.</st>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47941">**<st c="47946">输出</st>** <st c="47952">选项卡显示了我们的模型摘要，包括我们之前从未见过的细节——模型大小。</st>
    <st c="48042">模型大小。</st>
- en: <st c="48053">More importantly, the</st> `<st c="48229">mlmodel</st>` <st c="48236">extension.</st>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48053">更重要的是，</st> `<st c="48229">mlmodel</st>` <st c="48236">扩展。</st>
- en: <st c="48247">To use the</st> `<st c="48259">mlmodel</st>` <st c="48266">extension
    in our projects, we’ll need to use Core ML.</st> <st c="48321">That’s our</st>
    <st c="48332">next topic.</st>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48247">为了在我们的项目中使用</st> `<st c="48259">mlmodel</st>` <st c="48266">扩展，我们需要使用Core
    ML。</st> <st c="48321">这就是我们的</st> <st c="48332">下一个主题。</st>
- en: <st c="48343">Using our model with Core ML</st>
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48343">使用我们的模型与Core ML</st>
- en: <st c="48372">The</st> **<st c="48377">Core ML framework</st>**<st c="48394">’s
    goal is to allow us</st> <st c="48417">to integrate ML models into</st> <st c="48446">our
    projects.</st>
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="48372">The</st>` **`<st c="48377">Core ML framework</st>`** `<st c="48394">’s
    goal is to allow us</st>` `<st c="48417">to integrate ML models into</st>` `<st
    c="48446">our projects.</st>`'
- en: <st c="48459">Our first step is to add the</st> `<st c="48489">mlmodel</st>`
    <st c="48496">file that we saved from the Create ML application to Xcode.</st>
    <st c="48557">We can do that by dragging the file to the project navigator</st>
    <st c="48618">in Xcode.</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="48459">Our first step is to add the</st>` `<st c="48489">mlmodel</st>`
    `<st c="48496">file that we saved from the Create ML application to Xcode.</st>`
    `<st c="48557">We can do that by dragging the file to the project navigator</st>`
    `<st c="48618">in Xcode.</st>`'
- en: <st c="48627">The main class in the Core ML framework we will use is</st> `<st
    c="48683">MLModel</st>`<st c="48690">, which represents a ML model loaded into
    the system.</st> <st c="48744">To</st> <st c="48746">load our Spam Classifier
    model, we initialize the model in</st> <st c="48806">our code:</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="48627">The main class in the Core ML framework we will use is</st>`
    `<st c="48683">MLModel</st>` `<st c="48690">, which represents a ML model loaded
    into the system.</st>` `<st c="48744">To</st>` `<st c="48746">load our Spam Classifier
    model, we initialize the model in</st>` `<st c="48806">our code:</st>`'
- en: '[PRE19]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="49003">In the preceding code example, we created a new class, called</st>
    `<st c="49066">MessageClassifier</st>`<st c="49083">, which encapsulates our ML
    integration with the Spam</st> <st c="49137">Classifier model.</st>
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49003">In the preceding code example, we created a new class, called</st>`
    `<st c="49066">MessageClassifier</st>` `<st c="49083">, which encapsulates our
    ML integration with the Spam</st>` `<st c="49137">Classifier model.</st>`'
- en: <st c="49154">We then initiate the class, passing a new</st> `<st c="49197">MLModelConfiguration</st>`<st
    c="49217">. This contains different options, but we can pass an empty instance
    at</st> <st c="49289">this stage.</st>
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49154">We then initiate the class, passing a new</st>` `<st c="49197">MLModelConfiguration</st>`
    `<st c="49217">. This contains different options, but we can pass an empty instance
    at</st>` `<st c="49289">this stage.</st>`'
- en: <st c="49300">Our class also contains an</st> `<st c="49328">MLModel</st>` <st
    c="49335">instance.</st> <st c="49346">To initiate the model instance, we use
    the</st> `<st c="49389">SpamClassifier</st>` <st c="49403">class, passing</st>
    <st c="49419">our configuration.</st>
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49300">Our class also contains an</st>` `<st c="49328">MLModel</st>`
    `<st c="49335">instance.</st>` `<st c="49346">To initiate the model instance,
    we use the</st>` `<st c="49389">SpamClassifier</st>` `<st c="49403">class, passing</st>`
    `<st c="49419">our configuration.</st>`'
- en: <st c="49437">But wait – where did the</st> `<st c="49463">SpamClassifier</st>`
    <st c="49477">class</st> <st c="49484">come from?</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49437">But wait – where did the</st>` `<st c="49463">SpamClassifier</st>`
    `<st c="49477">class</st>` `<st c="49484">come from?</st>`'
- en: <st c="49494">When we added the Spam Classifier</st> `<st c="49529">mlmodel</st>`
    <st c="49536">file into our Xcode project, Core ML generated three interfaces
    – the</st> `<st c="49607">SpamClassifier</st>` <st c="49621">class,</st> `<st
    c="49629">SpamClassifierInput</st>`<st c="49648">,</st> <st c="49650">and</st>
    `<st c="49654">SpamClassifierOutput</st>`<st c="49674">.</st>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49494">When we added the Spam Classifier</st>` `<st c="49529">mlmodel</st>`
    `<st c="49536">file into our Xcode project, Core ML generated three interfaces
    – the` `<st c="49607">SpamClassifier</st>` `<st c="49621">class,</st>` `<st c="49629">SpamClassifierInput</st>`
    `<st c="49648">,</st>` `<st c="49650">and</st>` `<st c="49654">SpamClassifierOutput</st>`
    `<st c="49674">.</st>`'
- en: <st c="49675">Now that we have our model, let’s write a function that can predict
    whether a message</st> <st c="49762">is spam:</st>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="49675">Now that we have our model, let’s write a function that can
    predict whether a message</st>` `<st c="49762">is spam:</st>`'
- en: '[PRE20]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="50013">In the preceding example, we created a</st> `<st c="50053">prediction</st>`
    <st c="50063">function that receives a text message as input and</st> <st c="50114">returns</st>
    <st c="50123">a Boolean.</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="50013">In the preceding example, we created a</st>` `<st c="50053">prediction</st>`
    `<st c="50063">function that receives a text message as input and</st>` `<st c="50114">returns</st>`
    `<st c="50123">a Boolean.</st>`'
- en: <st c="50133">It starts by creating a</st> `<st c="50158">SpamClassifierInput</st>`
    <st c="50177">instance with the text input.</st> <st c="50208">Then, it generates
    a prediction result for this input by running the model’s</st> `<st c="50285">prediction()</st>`
    <st c="50297">function.</st> <st c="50308">We then get the value from the feature,
    called</st> `<st c="50355">label</st>`<st c="50360">, and compare it</st> <st
    c="50377">to</st> `<st c="50380">true</st>`<st c="50384">.</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="50133">It starts by creating a</st>` `<st c="50158">SpamClassifierInput</st>`
    `<st c="50177">instance with the text input.</st>` `<st c="50208">Then, it generates
    a prediction result for this input by running the model’s</st>` `<st c="50285">prediction()</st>`
    `<st c="50297">function.</st>` `<st c="50308">We then get the value from the feature,
    called</st>` `<st c="50355">label</st>` `<st c="50360">, and compare it</st>`
    `<st c="50377">to</st>` `<st c="50380">true</st>` `<st c="50384">.</st>`'
- en: <st c="50385">This code example demonstrates how to easily use a custom ML model
    in our</st> <st c="50460">Xcode projects.</st>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="50385">This code example demonstrates how to easily use a custom ML
    model in our</st>` `<st c="50460">Xcode projects.</st>`'
- en: <st c="50475">Now, let’s try to understand if using a custom ML in our Xcode
    is</st> <st c="50542">that simple.</st>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50475">现在，让我们尝试理解在我们的Xcode中使用自定义机器学习是否</st> <st c="50542">这么简单。</st>
- en: <st c="50554">Where to go from here</st>
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50554">接下来该往哪里去</st>
- en: <st c="50576">The Core ML part of this book is unique.</st> <st c="50618">In
    most cases, I have simplified complex topics to make them more accessible for
    developers.</st> <st c="50711">However, I think the Core ML topic</st> <st c="50746">is
    different.</st>
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50576">本书的Core ML部分是独特的。</st> <st c="50618">在大多数情况下，我已经简化了复杂的话题，使其对开发者更容易理解。</st>
    <st c="50711">然而，我认为Core ML主题</st> <st c="50746">是不同的。</st>
- en: <st c="50759">ML is a broad topic, beyond the scope of this chapter.</st> <st
    c="50815">Furthermore, it is a complex topic.</st> <st c="50851">Training is more
    than just delivering datasets.</st> <st c="50899">It is essential to understand
    the dataset mix between the different classes, pick the correct algorithm, and
    read the evaluation</st> <st c="51028">results carefully.</st>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50759">机器学习是一个广泛的话题，超出了本章的范围。</st> <st c="50815">此外，它是一个复杂的话题。</st> <st
    c="50851">训练不仅仅是提供数据集。</st> <st c="50899">理解不同类别之间的数据集混合，选择正确的算法，并仔细阅读评估</st>
    <st c="51028">结果至关重要。</st>
- en: <st c="51046">And remember that the model we created is a custom.</st> <st c="51099">This
    means that we don’t have any control over how its algorithm works and need to
    observe and fine-tune it</st> <st c="51207">over time.</st>
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51046">并且记住，我们创建的模型是自定义的。</st> <st c="51099">这意味着我们无法控制其算法的工作方式，需要随着时间的推移进行观察和微调</st>
    <st c="51207">它。</st>
- en: <st c="51217">In summary, ML is a complex topic, and if we want to enter this
    area, we need to approach it more in-depth than reading</st> <st c="51338">15
    pages.</st>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51217">总的来说，机器学习是一个复杂的话题，如果我们想进入这个领域，我们需要比阅读</st> <st c="51338">15页的内容更深入地了解。</st>
- en: <st c="51347">Summary</st>
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="51347">总结</st>
- en: <st c="51355">This was a long but fascinating chapter about one of the most
    exciting contemporary topics – ML</st> <st c="51452">and AI.</st>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51355">这是一章关于当代最激动人心的主题之一——机器学习（ML）和人工智能（AI）的漫长但引人入胜的章节。</st> <st c="51452">和人工智能。</st>
- en: <st c="51459">We reviewed the basics of AI and ML, understanding what it means
    to train an ML model.</st> <st c="51547">We explored the built-in ML models in
    the iOS SDK, including NLP, analyzing images using the Vision framework, and classifying
    audio with the Sound Analysis framework.</st> <st c="51715">We learned how to
    add semantic search capabilities to the Core Spotlight framework, and if that
    wasn’t enough, we also learned how to create and integrate custom ML models into</st>
    <st c="51892">our projects.</st>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51459">我们回顾了人工智能和机器学习的基础知识，了解了训练机器学习模型意味着什么。</st> <st c="51547">我们探索了iOS
    SDK中内置的机器学习模型，包括自然语言处理（NLP）、使用Vision框架分析图像，以及使用声音分析框架对音频进行分类。</st> <st c="51715">我们学习了如何向Core
    Spotlight框架添加语义搜索功能，而且如果还不够的话，我们还学习了如何创建和集成自定义机器学习模型到</st> <st c="51892">我们的项目中。</st>
- en: <st c="51905">Now, we can add some intelligence features to</st> <st c="51952">our
    apps!</st>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51905">现在，我们可以给我们的应用添加一些智能功能！</st> <st c="51952">我们的应用！</st>
- en: <st c="51961">Speaking of intelligence, our next chapter discusses how we can
    integrate Siri using App Intents.</st> <st c="52060">The ML phase is not over</st>
    <st c="52085">just yet!</st>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51961">说到智能，我们下一章将讨论如何使用App Intents集成Siri。</st> <st c="52060">机器学习阶段还没有结束</st>
    <st c="52085">呢！</st>
