- en: Chapter 4. Improving Code Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Achieving good code performance is an important and desirable task. Everyone
    would like to have applications that perform well. In this chapter we are going
    to cover these performance topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization checklist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value objects and reference objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift arrays and unsafe C arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first rule of optimization is—don''t optimize. You should always remember
    this phrase by Donald Knut:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Premature optimization is the root of all evil*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a very true and correct statement. You should start doing performance
    optimization only when you see a performance problem and you have found what is
    causing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of performance optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explicit performance optimization is a technique that is directed at a specific
    slow piece of code. This type of optimization requires significant code changes
    that could worsen code readability. You do explicit performance optimization by
    changing the algorithm to a more effective one. Using more memory for the cache
    could also increase performance.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit performance optimization is the technique of applying language-specific,
    in our case Swift-specific, features that lead to better performance. Implicit
    code performance doesn't require significant code changes. It doesn't have any
    negative impact on the code readability and sometimes makes it better. I call
    it implicit because you can apply it everywhere in the code and it becomes invisible
    to you after some time.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit performance optimization is a very popular and broad topic that is
    covered in many books about algorithms and data structures. Implicit on other
    hand is directly related to the Swift programming language and is a very interesting
    topic we are going to have a look at.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before doing any optimization and performance measurement, you should follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable the **Release** mode: The Swift compiler does a lot of code optimization
    and improves performance in the **Release** mode. To enable the **Release** mode
    go to **Product** | **Scheme** | **Edit Scheme** | **Run**, select the **Info**
    tab, and select **Release** in the **Build Configuration** setting.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Disable safety checks: Disabling safety checks could improve application performance;
    but as its name suggests, it affects safety and disabling is not 100-percent safe
    and should be applied carefully. An example of a safety check Swift does is checking
    array bounds before accessing the memory. If you disable safety checks Swift won''t
    do that.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Disabling safety checks is a **Swift Compiler – Code Generation** setting that
    is available in the target **Build Settings**. To disable safety checks select
    **Project** | **Build Settings**, then search for the **Disable Safety Checks**
    setting and set it to **Yes** for the **Release** mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enable the **Fast, Whole Module Optimization** level: By default, the Swift
    compiler does optimization only to one file at a time. It does it as though in
    sandbox environment for every file. The optimization of one file has no effect
    on the other files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Whole Module Optimization** enables optimization for all the source files
    in the module at once. All the source files are evaluated and optimized together.
    It is very useful because we often declare a type in one file and use it in another.
    One of the optimizations that **Whole Module Optimization** does is searching
    for declarations with the `internal` type that aren''t overridden anywhere and
    adding the `final` declaration optimization for them.'
  prefs: []
  type: TYPE_NORMAL
- en: To enable **Whole Module Optimization**, select **Optimization Level** for the
    Swift compiler in **Build Setting** and select the **Fast, Whole Module Optimization
    [-O -whole-module-optimization]** option for the **Release** mode.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling this setting increases build time. You should use it for release builds
    and performance testing. While developing and debugging, it would be better to
    disable this setting to speed up the compiling time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of Optimization Level settings available in Xcode
    with different purposes and options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple LLVM - Code Generation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swift Compiler – Code Generation**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you select the **Optimization Level** setting, you can see all the available
    options with a detailed description in the **Quick Help** section in the **Utilities**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimization checklist](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default in the **Release** mode Xcode uses these settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apple LLVM, GCC_OPTIMIZATION_LEVEL**: **Fastest, Smallest [-Os]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swift Compiler, SWIFT_OPTIMIZATION_LEVEL**: **Fastest [-O]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try enabling other optimization settings. For example using **Fastest,
    Aggressive Optimizations:[-Ofast]** could improve application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Swift code compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The LLVM first turns your source code into pseudocode. In the next step it gets
    optimized and compiled into Assembly code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform these code-processing steps manually from the command line
    by using `swiftc` in the Swift compiler. To see all available options for the
    Swift compiler, open `Terminal.app` and execute the `--help` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the available compilation modes and options. The ones we are looking
    for are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-emit-assembly`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-emit-ir`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-emit-silgen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-emit-sil`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These compilation modes allow you to apply different compilation steps to the
    Swift source file. As an example, we could emit `sourceFile.swift` into the canonical
    SIL representation and write the result to the `outputFile` with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will cover the compilation process in greater detail in [Chapter 8](part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0
    "Chapter 8. Discovering All the Underlying Swift Power"), *Discovering All the
    Underlying Swift Power*.
  prefs: []
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using constant has an impact on code readability. It makes code clearer and
    safer. Using constants instead of variables could also have performance benefits.
    When you use a constant you give the compiler a clear hint that this value won't
    be changed. The Swift compiler can apply inline optimization to use a value of
    that constant and not allocate memory for it.
  prefs: []
  type: TYPE_NORMAL
- en: In simple examples, the Swift compiler could do the same optimization for variables
    as well. Let's analyze the result for this simple example of iterating and calculating
    a sum. The performance is the same for variables and constants in this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we look at a more complex example, we will see that constants perform the
    same as, or even better than, variables. It might seem as if a version using variables
    should perform faster, because there is no need to allocate memory for new constants
    on every operation, but the Swift compiler is smart enough to perform intelligent
    optimization so that they behave the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So the general advice is: Prefer using constants. They make the code safer
    and clearer and also have a positive impact on performance. Variables in some
    situations could also improve code readability, as in the example earlier where
    we had to do some math calculations and changing the value in the variable actually
    made the code clearer.'
  prefs: []
  type: TYPE_NORMAL
- en: Constants are so much better than variables that Xcode shows a warning when
    it detects a variable that was never mutated and suggests you change it to a constant.
  prefs: []
  type: TYPE_NORMAL
- en: '![Constants and variables](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Method calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before discussing Swift method calls optimization, it would be very useful to
    have a look at different types of method call implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static**: Static method binding means that, when you call a method on the
    object, the compiler knows that you are calling exactly this method on exactly
    this class. C is an example of a language with static method binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic**: On other hand, dynamic has a weak binding between the method and
    the object. When you call a method on the object there is no guarantee that an
    object can handle this method call. Objective-C has a dynamic method binding.
    That''s why you can see the `object does not respond to selector` error in Objective-C.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective-C is a dynamic-type language and it has a dynamic runtime. Calling
    a method is called **message sending**. You send a message to the target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like a normal method call, but after compilation it would actually
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Objective-C uses dynamic method binding. It means that the message and the
    receiver are stored separately. When you send a `bark` message to the `dog` object,
    the dog class has to look up if it has a bark method and if it can handle it.
    This process is called dynamic method binding. The implementation would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Swift uses a static method binding. It uses a vtable—Virtual Method Table—for
    storing methods. Vtable is an array of function pointers. That means that a class
    has a list of its methods with the memory address of that method implementation.
    When you call a method in Swift, you are calling it on the specific type. The
    binding between the method and the object you are calling this method on is very
    strong and done at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look how the same code would behave in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Because Swift knows that you want to call a bark method on the `Dog` class,
    it doesn''t need to do any extra lookup for the method information. It will get
    the function address and call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift can do even more complex optimization to method calls. If the method
    is not overridden, it means that call to the `bark` method will always resolve
    to the same function call. The Swift compiler can skip the function lookup in
    the vtable and inline direct function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the mangled name of the `bark` method. We will learn more about this
    in [Chapter 8](part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0
    "Chapter 8. Discovering All the Underlying Swift Power"), *Discovering All the
    Underlying Swift Power*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_TFC12methodsCalls3Dog4barkfS0_FT_T_()` direct function call in the assembly
    code is translated into a simple command. Here is how the assembly pseudo code
    looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare the performance of Swift static method calls with the Objective-C
    dynamic method call to the see the performance difference. Let''s make a simple
    `Number` class with an `add` method that will add two numbers (a Swift solution):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For time measurement we are using our `measure` function from the previous
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result: `Average Time - 1.45391867654989`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the Objective-C solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result: `Average Time - 2.974986`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, even a very simple function call is twice as fast in Swift.
    Now you know the details of Swift method and functions call implementation, it's
    time to jump to more practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can make code reusable by making a function or a method in four different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Global functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static and final methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Global functions are the simplest ones. They cannot be overridden and changed.
    Global functions are stored as named pointers in memory. When you call a global
    function it is translated to the direct memory call without any lookup in the
    vtable. This should be the fastest way. The assembly code for calling a global
    function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Type methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type methods operate on the type and not instances of that type. Class methods
    are stored in the vtable for that class. The class method can be overridden by
    subclass. Because class methods can be overridden, the Swift compiler sometimes
    can''t optimize class method calls to a direct function call as for global functions.
    For a better understanding of why, let''s have a look at this simple example of
    an overridden class method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have made two simple classes: `Dog` and `BigDog`. The function `getDog`
    returns a `Dog.Type` class type, but it can also return `BigDog.Type`. The `dog`
    variable can be either a `Dog.Type` or a `BigDog.Type`. Because of that, the Swift
    compiler can''t do direct function calls inline. It has to do a lookup for the
    function pointer in the vtable and that is a very cheap operation. The pseudo
    assembly code for this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swift compiler can do direct function calls inline for overridden methods
    when you specify a type explicitly. In this example we call the `bark` method
    on the `Dog` class and the Swift compiler skips the vtable lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Static methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can declare a static type method in classes, structures and enumerations.
    In classes declaring a type method, using the `static` keyword is the same as
    using the `final class` keywords. Those two method declarations are equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Static methods can''t be overridden in the subclasses. Because they can''t
    be overridden they don''t need to be stored in the vtable. The implementation
    details of a static method are very similar to a global function. In the assembly
    code it will be translated to a direct function call, the same as for global functions.
    Let''s add a static function to our dog class and explore how it translates to
    the assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Both calls to the `speak` method in `Dog` and the `BigDog` class are translated
    to a one-line assembly instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Instance methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main difference between type methods and instance methods is that instance
    methods can operate with instance constants and variables. Instance methods can
    be overridden and they need to be stored in the vtable. Let''s add a name variable
    to our `Dog` class and a `changeName` instance method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `changeName` method will be translated to this assembly code. Get the method
    address from the vtable and call it with passing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Comparing function speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you know how functions and methods are implemented and how they work. Let''s
    compare the performance speed of those global function and the different method
    types. For the test we will use a simple `add` function. We will implement it
    as a global function, static, class type, and instance and override them in the
    subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For the measurement and code analysis, we use a simple loop where we call those
    different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All these methods perform in exactly the same way. Furthermore, their assembly
    code looks exactly the same, except the name of the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global function**: `add(10, y: 11)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static**: `NumOperation.addS(10, y: 11)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: `NumOperation.addC(10, y: 11)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subclass Static**: `BigNumOperation.addS(10, y: 11)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subclass overridden class**: `BigNumOperation.addC(10, y: 11)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The assembly pseudocode for those functions looks likes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `BigNumOperation` `addC` class function overrides the `NumOperation`
    `addC` function when you call it directly, there is no need for a vtable lookup.
  prefs: []
  type: TYPE_NORMAL
- en: The instance method call looks a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Subclass overridden instance**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The one difference is that they need to initialize a class and create an instance
    of the object. In our example this is not such an expensive operation because
    we do it outside the loop and it happens only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The loop with the calling instance method looks exactly the same so we will
    not list it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have seen there is almost no difference between global functions and
    static and class methods. Instance methods look a bit different but it doesn''t
    have a big impact on performance. Though this is true for simple use cases, there
    is a difference between them in more complex examples. Let''s have a look at this
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that, instead of specifying the `NumOperation` class
    type at compile time, we randomly return it at runtime. And because of this, the
    Swift compiler doesn't know which method should be called—`BigNumOperation.addC`
    or `NumOperation.addC`—at compile time. This small change has an impact on the
    generated assembly code and the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods usage summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Global functions are the simplest ones and provide the best performance. Having
    too many global functions makes code hard to read and follow.
  prefs: []
  type: TYPE_NORMAL
- en: Static type methods that can't be overridden have the same performance as global
    functions but they also provide a namespace (type `name`), so our code looks clearer
    and without any loss in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Class methods that can be overridden could lead to a performance loss and should
    be used when you need class inheritance. In other cases, static methods are preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods operate on the instance of the object. Use instance methods
    when you need to operate on the data of that instance.
  prefs: []
  type: TYPE_NORMAL
- en: Make methods final when you don't need to override them. This tells the compiler
    that optimization and performance could be increased because of that.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligent code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because Swift is a static and strongly typed language it can read, understand,
    and optimize code very well. Swift tries to remove the execution of all unnecessary
    code. For a better explanation let''s have a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an instance of the `Object` class and call a `nothing` method. The
    `nothing` method is empty and calling it does nothing. The Swift compiler understands
    that and removes those method calls. After this we have only one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The Swift compiler can also obviate the creation of objects that are never used.
    It reduces memory usage and unnecessary function calls, which also reduces CPU
    usage. In our example the `object` instance is not used after removing the `nothing`
    method call and the creation of `Object` can be dispensed with as well. This way,
    Swift removes all three lines of code and we end up with no code to execute at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C, can't do this optimization. Because it has a dynamic runtime, the
    `nothing` method implementation could be changed to do some work at runtime. That's
    why Objective-C can't remove empty method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'This optimization might not seem to amount to much but let''s have a look at
    another, slightly more complex example that uses more memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added some `Int` data to our `Object` class to increase memory usage.
    Now the `Object` instance uses at least 24 bytes (3 * `Int` size; `Int` uses four
    bytes in 64-bit architecture). Let''s also try to increases CPU usage by adding
    more instructions via a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integer literals can use underscores (`_`) to improve readability. 1_000_000_000
    is the same as 1000000000
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have three million instructions and we use 24 million bytes, about 24
    MB. This is quite a lot for the type of operation that actually doesn''t do anything.
    As you can see, we don''t use the result of the loop body. For the loop body Swift
    does the same optimization as in the previous example and we end up with an empty
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The empty loop can be skipped as well. As a result, we have saved 24 MB of memory
    usage and three million method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Dangerous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some functions and instructions that sometimes don't provide any value
    for the application but the Swift compiler can't skip them and they could have
    a very negative impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Console print
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Printing a statement to the console is usually used for debug purposes. The
    `print` and `debugPrint` instructions aren''t removed from the application in
    the Release mode. Let''s explore this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swift compiler treats `print` and `debugPrint` as a valid and important
    instruction that can''t be skipped. Even though this code does nothing, it can''t
    be optimized because Swift doesn''t remove the `print` statement. And as a result
    we have one million unnecessary instructions. The assembly code for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see even very simple code that uses the `print` statement can decrease
    application performance very dramatically. The loop with the 1_000_000 `print`
    statement takes five seconds and that's a lot. It's even worse if you run it in
    Xcode; it will take up to 50 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets even worse if you add a `print` instruction to the `nothing` method
    of an `Object` class from the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case, a loop where we create an instance of `Object` and call `nothing`
    can''t be eliminated because of the `print` instruction. Even though Swift can''t
    eliminate execution of that code completely it does the optimization by removing
    the creation instance of `Object` and calling the `nothing` method, and turns
    it into a simple loop operation. The compiled code after optimization will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this code is far from perfect and supplies a lot of instructions
    that actually don't give us any value. There is a way to improve this code so
    the Swift compiler would perform the optimal code optimisation.
  prefs: []
  type: TYPE_NORMAL
- en: Removing print logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To solve this performance problem we have to remove the `print` statements from
    the code before compiling it. There are a few ways to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Comment out
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first idea is to comment out all `print` statements in the code in the Release
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This would work but the next time you want to enable logs, you would need to
    uncomment that code. This is a very bad and painful practice. There is a better
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commented code is bad practice in general. You should be using a source code
    version control system, such as Git, instead. This way you can safely remove unnecessary
    code and find it in history if you need it someday.
  prefs: []
  type: TYPE_NORMAL
- en: Using build configurations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can enable `print` only in the **Debug** mode. To do this, we will use a
    build configuration to conditionally exclude some code. First we need to add a
    Swift compiler custom flag. To do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select a Project target— **Build Settings** – **Other Swift flags** setting
    in the **Swift Compiler – Custom Flags** section and add the **–D DEBUG** flag
    for the **Debug** mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using build configurations](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this you can use the `DEBUG` configuration flag to enable code only in
    the Debug mode. We will define our own `print` function that will generate print
    statement only in debug mode. In the Release mode, that function would be empty
    and the Swift compiler will successfully eliminate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Everywhere instead of `print` we will now use `D_print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also create a similar `D_debugPrint` function.
  prefs: []
  type: TYPE_NORMAL
- en: Swift is very smart and does a lot of optimization but we also have to make
    code clear for people to read and for the compiler to optimize.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a preprocessor adds complexity to the code. Use this wisely and only in
    those situations when normal `if` conditions won't work, like in our `D_print`
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Using nonoptimizable constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some types can't be optimized as well as others and using constants of that
    type can't prevent the code from being eliminated by the Swift compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swift compiler can eliminate this code. Let''s have a look at a more complex
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can''t be completely eliminated by the Swift compiler. By adding
    a very simple `String` constant, we have added much more complexity to the source-code.
    To understand why it happened we need to explore the assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'From the name of the `getInitializedObjCClass` we could make an assumption
    that this method does some Objective-C class type initialization. It might seem
    very strange because we haven''t used any Objective-C types in our code. We have
    added a simple empty string constant: `let a = ""`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The thing is that the Swift `String` provides seamless interoperability with
    the Objective-C `NSString` type. Because of this, when we use a Swift `String`
    it allocates some additional data to perform bridging to `NSString`. Here is how
    that metadata `objc_class__TtC4test11Optimizable` looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more types that can''t simply be eliminated by the Swift compiler
    when they are used with simple constants:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Class objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The interesting behavior happens if we try to use those types in a structure
    instead of a class. We see different behavior because Swift structures aren''t
    exposed for use in Objective-C. That''s why the Swift compiler can eliminate many
    of them: String, Array, Class, and Closures. Set and Dictionary aren''t eliminated
    even if they are used in the structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Moving those constant to the initializer doesn't solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to that issue is that you shouldn't use any constants that aren't
    used and don't provide any value for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Improving speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few techniques that can simply improve code performance. Let's jump
    directly to the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Final
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can make a function and property declaration with the `final` attribute.
    Adding the `final` attribute makes it nonoverridable. Subclasses can''t override
    that method or property. When you make a method nonoverridable there is no need
    to store it in the vtable and the call to that function can be performed directly
    without any function address lookup in the vtable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you have seen, the `final` method performs faster than nonfinal. Even so
    small an optimization can improve application performance. It not only improves
    performance but also makes the code more secure. This way you disable the method
    from being overridden and prevent unexpected and incorrect behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling the **Whole Module Optimization** setting achieves very similar optimization
    results but it''s better to mark a function and property declaration explicitly
    as `final`: This reduces compiler work and speeds up compilation time. The compilation
    time for big projects with **Whole Module Optimization** can take up to five minutes
    in Xcode 7 Beta 6.'
  prefs: []
  type: TYPE_NORMAL
- en: Inline functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have seen Swift can do optimization and make some function calls inline.
    This way there is no performance penalty for calling a function. You can manually
    enable or disable inline functions with the `@inline` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Even though you can manually control inline functions it's usually better to
    leave it to the Swift compiler to do that. Depending on different optimization
    settings, the Swift compiler applies a different inlining technique.
  prefs: []
  type: TYPE_NORMAL
- en: The use case for `@inline(__always)` is a very simple one-line function that
    you want always to be inlined.
  prefs: []
  type: TYPE_NORMAL
- en: Value objects and reference objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned the benefits of using immutable value objects.
    Value objects not only make code safer and clearer, they also make it faster.
    Value objects have better speed performance than reference objects and here is
    why. As an example of a value object, we will use structures in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value objects can be allocated on the stack memory instead of the heap memory.
    Reference objects need to be allocated on the heap memory because they can be
    shared between many owners. Because value objects have only one owner they can
    be safely allocated on the stack. Stack memory is way faster that heap memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second advantage is that value objects don''t need reference counting memory
    management. As they can have only one owner, there is no such thing as reference
    counting for value objects. With **ARC** (**Automatic Reference Counting**), we
    don''t need to think so much about memory management and it mostly looks transparent
    for us. Even though using reference-object and value-object code looks the same,
    ARC adds extra retain and release method calls for reference objects. Let''s look
    at a very simple example of a structure and class that represent a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example we will write exactly the same code using `NumberValue` and `NumberReference`
    and compare the generated assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The two lines of code for creating and using the `NumberValue` structure look
    very simple. In the assembly, it has three lines of code that do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `NumberValue` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign it to `x` variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save `x` number to the `xres` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see the code for creating the first number object and the second
    one looks exactly the same. Now let''s have a look the assembly code for the `NumberReference`
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see the first three lines look almost the same. It creates an instance
    of `NumberReference`, assigns it to the variable, gets the x number, and saves
    it to the `yres` variable. The code for creating second instance is more interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see it has three lines more than `NumberValue`. We have assigned
    a new instance to the `y` variable; the old `NumberReference` got out of a scope
    and needs to be released. Those three lines are related to the `_swift_release`
    function. If you further analyze the assembly code for working with reference
    objects, you will also discover another ARC function: `_swift_retain;`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you know the main performance difference between value types and reference
    types, let's see how they perform. For that, let's use the number type and perform
    some calculations in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The first loop with the `NumberValue` structure is completely eliminated by
    the Swift compiler at compile time. The calculating loop is turned into a simple
    integer result; 500500 in hexadecimal equals 0x7a314\. Here is the assembly pseudocode
    for the first loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see there no loop execution, the result is evaluated at the compile
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second loop using the `NumberReference` reference objects can''t be eliminated
    at compile time. The assembly pseudocode structure looks exactly the same as the
    source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As you see, using the value object gives a much bigger performance win. As
    an example, let''s measure the performance for that operation but increase the
    loop iterations to 1_00_000_000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not really a fair performance measurement because the variant with
    the value object actually doesn''t do any execution. To compare the actual execution
    speed let''s run this code in debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You shouldn't measure performance in the Debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The difference is still impressive; Value objects perform up to four times faster
  prefs: []
  type: TYPE_NORMAL
- en: Swift arrays and unsafe C arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everyone knows that C is a super-fast programming language and when you hit
    a performance problem people go to C for help. In Objective-C, it is very easy
    to use C functions and types; its name says it all—C with Objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift also has support for interacting with C types and pointers. Even though
    it''s available, it''s considered as a dangerous operation because you need to
    do memory management manually. You need to allocate and destroy memory. Those
    types are called **Unsafe** in Swift and start with the `Unsafe` prefix—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UnsafePointer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnsafeMutablePointer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnsafeBufferPointer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid using C pointers in Swift. It adds a lot of complexity to the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There are three main use scenarios for `UnsafePointers`:'
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a pointer to an existing variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating memory for the pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First let''s learn how to use pointers. When designing your API in Swift, you
    shouldn''t use `UnsafePointers`, but you can find a situation when you need to
    interact with the C API: a Core Foundation, for example. C pointers would be exposed
    to Swift as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const Int *` as `UnsafePointer<Int>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int *` as `UnsafeMutablePointer<Int>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you call a function in Swift with the `UnsafePointer` parameter, you can
    pass a variable of the same type as an in-out argument, by using the `&` sign
    or an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to pass `nil`, but in that case our function would have
    a null pointer as an argument and accessing its memory would crash the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using `UnsafeMutablePointer` is very similar. The main difference between `UnsafeMutablePointer`
    and `UnsafePointer` is that a mutable pointer can mutate the value of the variable
    it points to. When using arrays as an argument for a function with the `UnsafeMutablePointer`
    parameter, they also need to be passed as in-out parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Creating a pointer to an existing variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a pointer you can connect it to an existing variable with the
    `initialize` method. The `initialize` method would return a function that could
    be used to set a new value for that variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Allocating memory for the pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other way to work with pointers is to allocate a memory for them. The `alloc`
    method has one parameter: the number of objects it will allocate memory for. After
    allocating a memory for the pointer you can use it. Finally, you need to deallocate
    the memory used by the pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`UnsafeMutablePointer` has many useful methods that you can use, such as the
    `successor` and `predecessor` methods for moving pointers forward and backward,
    `subscript` for accessing random pointer indices, and many others.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about interacting with C pointers at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have learned how to work with C pointers in Swift let''s jump to our
    main goal: measuring how fast it would be to work with pointer arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Swift arrays with unsafe C arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For comparison, we will make an array of random numbers and sort them. The main
    goal is not to find the most efficient way to sort numbers in the array but to
    compare performance when working with C `UnsafePointers` and Swift array types.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s make a C-style variant with `UnsafeMutablePointer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is: `Average Time - 1.31680929350041`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make the same solution by using Swift arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is: `Average Time - 1.30709397329978`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Swift arrays have the same performance as when working with `UnsafePointers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see the code looks very similar. The initialization of arrays and
    sort algorithms looks exactly the same in both variants. It''s because both `Array`
    and `UnsafeMutablePointer` have a subscript method. The only difference is in
    the way we create arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `UnsafeMutablePointer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'For Swift array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In general, Swift Array provides more functionality and it's much easier to
    work with. As an example, Array has sort, filter and many other methods but `UnsafeMutablePointer`
    doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of working with pointers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To keep it short— Swift arrays are preferred, and here is why.
  prefs: []
  type: TYPE_NORMAL
- en: Working with pointers is an unsafe and dangerous operation. You need to manually
    allocate and release memory. Accessing memory with pointers is also very dangerous
    because you can access other memory that doesn't belong to you.
  prefs: []
  type: TYPE_NORMAL
- en: UnsafePointers and Swift arrays have the same performance characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned that Objective-C (with its dynamic runtime) in most cases performs
    more slowly than Swift. Interoperability between Swift and Objective-C is done
    so seamlessly that sometimes we can use Objective-C types and its runtime in the
    Swift code without knowing that.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use Objective-C types in Swift code, Swift is actually using the Objective-C
    runtime for method dispatch. Because of that, Swift can''t do the same optimization
    as for pure Swift types. Let''s have a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Let's read this code and make some assumptions about how the Swift compiler
    would optimize that code. The `NSObject` instance is never used in the loop body,
    so we could eliminate creating an object. After that we would have an empty loop
    that could also be eliminated. So we would remove all the code from execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what is happening in reality by looking at generated assembly pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As you can see no code gets eliminated. This is happening because Objective-C
    types use the dynamic runtime dispatch method, called message sending.
  prefs: []
  type: TYPE_NORMAL
- en: All the standard Frameworks such as Foundation and UIKit are written in Objective-C
    and all the types—such as NSDate, NSURL, UIView, and UITableView—use the Objective-C
    runtime. They don't perform as fast as Swift types but we get all those frameworks
    available for use in Swift and this is great.
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to remove the Objective-C dynamic runtime dispatch from the
    Objective-C types in Swift, so the only thing we can do is to learn how to use
    them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding exposing Swift to Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can't remove runtime behavior from Objective-C types but we can stop Swift
    types from using the Objective-C runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a Swift class inherits from an Objective-C class it also inherits its
    dynamic runtime behavior. This also makes it available for usage in Objective-C
    code. Because it inherits its dynamic behavior the Swift compiler can''t perform
    optimal optimization (as shown in the earlier example with `NSObject` inside a
    loop). Let''s make a simple class that inherits from Objective-C and explore its
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This code can't be eliminated and its assembly code looks very similar to that
    shown in the earlier example. We could improve that behavior very simply by removing
    the `NSObject` inheritance. We can do that in this example because we don't use
    any features from `NSObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In that case, the Swift compiler is able to perform optimal optimization and
    eliminates all the code from execution. It removes the creation of the MyObject
    inside the loop and eliminates the empty loop afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have seen, using Objective-C classes in Swift makes the Swift compiler
    less powerful. Inherit and use Objective-C classes only if it''s required in these
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Expose Swift types to Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to subclass from Objective-C class, such as UIView, UIViewController and
    so on. Subclass only when it's really required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one more dangerous attribute that adds Objective-C dynamic runtime
    behavior to your type: the `dynamic` keyword. When you make a member declaration
    with the `dynamic` modifier it adds the Objective-C runtime to the class. The
    access to that member will never be statically inlined and will be always dispatched
    dynamically by using the Objective-C Target-Action mechanism. Let''s examine this
    simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Even such a small example does quite a lot of work. Applying the `dynamic`
    keyword causes many issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic message sending with `_objc_msgSend`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type casting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we use the Objective-C dynamic dispatch method, we need to convert our
    "Name" Swift string type into NSString; when we get a result from that function
    call back into Swift code we need to do one more conversion from NSString back
    to Swift String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No optimization and function call inlining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because methods are always dispatched dynamically, the Swift compiler can't
    do inline optimization or eliminate empty methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of avoiding Objective-C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should avoid using Objective-C and its runtime behavior for achieving high
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid using the `dynamic` keyword at any price. You should almost
    never use it.
  prefs: []
  type: TYPE_NORMAL
- en: Inherit from a Objective-C class only when you need that class behavior, as
    for UIView. Use the `@objc` attribute only when you need to expose your type to
    Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered many topics related to Swift performance. First
    we need to understand what we need to improve and enable optimization settings
    to get the best performance.
  prefs: []
  type: TYPE_NORMAL
- en: Memory usage is very important for achieving high performance. First, we covered
    how using constants can have a positive impact on performance. The second and
    more important example reflects how using value types and structures reduces memory
    usage and also improves performance by using fast stack memory.
  prefs: []
  type: TYPE_NORMAL
- en: The third important topic we have covered is dispatching methods. We have analyzed
    and compared both Objective-C dynamic dispatch and Swift static dispatch. By looking
    at the assembly code we have seen how Swift actually performs method dispatch
    and how it can benefit performance.
  prefs: []
  type: TYPE_NORMAL
- en: We have also covered some dangerous operations that could decrease performance
    and that should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will learn more about different data structures: their
    differences and performance characteristics.'
  prefs: []
  type: TYPE_NORMAL
