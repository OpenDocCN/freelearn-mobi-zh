- en: Chapter 4. Improving Code Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 提高代码性能
- en: 'Achieving good code performance is an important and desirable task. Everyone
    would like to have applications that perform well. In this chapter we are going
    to cover these performance topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 实现良好的代码性能是一项重要且令人向往的任务。每个人都希望拥有性能良好的应用程序。在本章中，我们将讨论以下性能主题：
- en: Understanding performance optimization
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解性能优化
- en: Optimization checklist
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化清单
- en: Constants and variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量和变量
- en: Method calls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用
- en: Intelligent code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能代码
- en: Value objects and reference objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值对象和引用对象
- en: Swift arrays and unsafe C arrays
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 数组和不受保护的 C 数组
- en: Avoiding Objective-C
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用 Objective-C
- en: Understanding performance optimization
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解性能优化
- en: 'The first rule of optimization is—don''t optimize. You should always remember
    this phrase by Donald Knut:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 优化的第一规则是——不要优化。您应该始终记住唐纳德·诺伊曼（Donald Knut）的这句话：
- en: '*Premature optimization is the root of all evil*'
  id: totrans-12
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*过早优化是万恶之源*'
- en: This is a very true and correct statement. You should start doing performance
    optimization only when you see a performance problem and you have found what is
    causing it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常真实且正确的陈述。您应该在看到性能问题并找到导致问题的原因后才开始进行性能优化。
- en: 'There are two types of performance optimization:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的性能优化：
- en: Explicit
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式
- en: Implicit
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式
- en: Explicit
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式
- en: Explicit performance optimization is a technique that is directed at a specific
    slow piece of code. This type of optimization requires significant code changes
    that could worsen code readability. You do explicit performance optimization by
    changing the algorithm to a more effective one. Using more memory for the cache
    could also increase performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显式性能优化是一种针对特定慢速代码片段的技术。此类优化需要显著的代码更改，可能会降低代码的可读性。您可以通过将算法更改为更有效的一种来执行显式性能优化。使用更多内存作为缓存也可能提高性能。
- en: Implicit
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式
- en: Implicit performance optimization is the technique of applying language-specific,
    in our case Swift-specific, features that lead to better performance. Implicit
    code performance doesn't require significant code changes. It doesn't have any
    negative impact on the code readability and sometimes makes it better. I call
    it implicit because you can apply it everywhere in the code and it becomes invisible
    to you after some time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式性能优化是应用语言特定（在我们的例子中是 Swift 特定）功能以实现更好性能的技术。隐式代码性能不需要显著的代码更改。它不会对代码的可读性产生任何负面影响，有时甚至会使代码更好。我称之为隐式，因为您可以在代码的任何地方应用它，经过一段时间后，它对您来说就变得不可见了。
- en: Explicit performance optimization is a very popular and broad topic that is
    covered in many books about algorithms and data structures. Implicit on other
    hand is directly related to the Swift programming language and is a very interesting
    topic we are going to have a look at.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 显式性能优化是一个非常流行且广泛的话题，在许多关于算法和数据结构的书籍中都有涉及。另一方面，隐式与 Swift 编程语言直接相关，是一个非常有趣的话题，我们将对其进行探讨。
- en: Optimization checklist
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化清单
- en: 'Before doing any optimization and performance measurement, you should follow
    these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行任何优化和性能测量之前，您应遵循以下步骤：
- en: 'Enable the **Release** mode: The Swift compiler does a lot of code optimization
    and improves performance in the **Release** mode. To enable the **Release** mode
    go to **Product** | **Scheme** | **Edit Scheme** | **Run**, select the **Info**
    tab, and select **Release** in the **Build Configuration** setting.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**发布**模式：Swift 编译器在**发布**模式下进行大量的代码优化，并提高性能。要启用**发布**模式，请转到**产品** | **方案**
    | **编辑方案** | **运行**，选择**信息**选项卡，并在**构建配置**设置中选择**发布**。
- en: 'Disable safety checks: Disabling safety checks could improve application performance;
    but as its name suggests, it affects safety and disabling is not 100-percent safe
    and should be applied carefully. An example of a safety check Swift does is checking
    array bounds before accessing the memory. If you disable safety checks Swift won''t
    do that.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用安全检查：禁用安全检查可能会提高应用程序性能；但正如其名所示，它会影响安全性，禁用并不完全安全，应谨慎应用。Swift 执行的一个安全检查示例是在访问内存之前检查数组边界。如果您禁用安全检查，Swift
    不会执行此操作。
- en: Disabling safety checks is a **Swift Compiler – Code Generation** setting that
    is available in the target **Build Settings**. To disable safety checks select
    **Project** | **Build Settings**, then search for the **Disable Safety Checks**
    setting and set it to **Yes** for the **Release** mode.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '禁用安全检查是**Swift 编译器 - 代码生成**设置，可在目标**构建设置**中找到。要禁用安全检查，请选择**项目** | **构建设置**，然后搜索**禁用安全检查**设置，并将其设置为**发布**模式的**是**。 '
- en: 'Enable the **Fast, Whole Module Optimization** level: By default, the Swift
    compiler does optimization only to one file at a time. It does it as though in
    sandbox environment for every file. The optimization of one file has no effect
    on the other files.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**快速、整个模块优化**级别：默认情况下，Swift编译器一次只对单个文件进行优化。它就像为每个文件在沙盒环境中执行一样。一个文件的优化对其他文件没有影响。
- en: '**Whole Module Optimization** enables optimization for all the source files
    in the module at once. All the source files are evaluated and optimized together.
    It is very useful because we often declare a type in one file and use it in another.
    One of the optimizations that **Whole Module Optimization** does is searching
    for declarations with the `internal` type that aren''t overridden anywhere and
    adding the `final` declaration optimization for them.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**整个模块优化**一次对模块中的所有源文件进行优化。所有源文件一起评估和优化。这非常有用，因为我们经常在一个文件中声明一个类型并在另一个文件中使用它。**整个模块优化**所做的优化之一是搜索没有在任何地方覆盖的`internal`类型的声明，并为它们添加`final`声明优化。'
- en: To enable **Whole Module Optimization**, select **Optimization Level** for the
    Swift compiler in **Build Setting** and select the **Fast, Whole Module Optimization
    [-O -whole-module-optimization]** option for the **Release** mode.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用**整个模块优化**，请在**构建设置**中为Swift编译器选择**优化级别**，并为**发布**模式选择**快速、整个模块优化 [-O -whole-module-optimization**]选项。
- en: Enabling this setting increases build time. You should use it for release builds
    and performance testing. While developing and debugging, it would be better to
    disable this setting to speed up the compiling time.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此设置会增加构建时间。您应该用于发布构建和性能测试。在开发和调试时，最好禁用此设置以加快编译时间。
- en: 'There are two different types of Optimization Level settings available in Xcode
    with different purposes and options:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode中提供了两种不同类型的优化级别设置，具有不同的目的和选项：
- en: '**Apple LLVM - Code Generation**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apple LLVM – 代码生成**'
- en: '**Swift Compiler – Code Generation**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swift编译器 – 代码生成**'
- en: If you select the **Optimization Level** setting, you can see all the available
    options with a detailed description in the **Quick Help** section in the **Utilities**
    panel.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**优化级别**设置，您可以在**实用工具**面板的**快速帮助**部分看到所有可用选项的详细描述。
- en: '![Optimization checklist](img/00018.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![优化清单](img/00018.jpeg)'
- en: 'By default in the **Release** mode Xcode uses these settings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在**发布**模式下，Xcode使用以下设置：
- en: '**Apple LLVM, GCC_OPTIMIZATION_LEVEL**: **Fastest, Smallest [-Os]**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apple LLVM, GCC_OPTIMIZATION_LEVEL**: **最快、最小 [-Os**]'
- en: '**Swift Compiler, SWIFT_OPTIMIZATION_LEVEL**: **Fastest [-O]**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swift编译器，SWIFT_OPTIMIZATION_LEVEL**: **最快 [-O**]'
- en: You can try enabling other optimization settings. For example using **Fastest,
    Aggressive Optimizations:[-Ofast]** could improve application performance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试启用其他优化设置。例如，使用**最快、最激进的优化**[**-Ofast**]可以提高应用程序性能。
- en: Swift code compilation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift代码编译
- en: The LLVM first turns your source code into pseudocode. In the next step it gets
    optimized and compiled into Assembly code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM首先将您的源代码转换为伪代码。在下一步中，它被优化并编译成汇编代码。
- en: 'You can perform these code-processing steps manually from the command line
    by using `swiftc` in the Swift compiler. To see all available options for the
    Swift compiler, open `Terminal.app` and execute the `--help` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用Swift编译器中的`swiftc`在命令行手动执行这些代码处理步骤。要查看Swift编译器所有可用选项，请打开`Terminal.app`并执行`--help`命令：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will see the available compilation modes and options. The ones we are looking
    for are:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到可用的编译模式和选项。我们正在寻找的是：
- en: '`-emit-assembly`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-emit-assembly`'
- en: '`-emit-ir`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-emit-ir`'
- en: '`-emit-silgen`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-emit-silgen`'
- en: '`-emit-sil`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-emit-sil`'
- en: 'These compilation modes allow you to apply different compilation steps to the
    Swift source file. As an example, we could emit `sourceFile.swift` into the canonical
    SIL representation and write the result to the `outputFile` with this command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编译模式允许您将不同的编译步骤应用于Swift源文件。例如，我们可以使用此命令将`sourceFile.swift`输出到规范SIL表示形式，并将结果写入`outputFile`：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will cover the compilation process in greater detail in [Chapter 8](part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0
    "Chapter 8. Discovering All the Underlying Swift Power"), *Discovering All the
    Underlying Swift Power*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0 "第8章.
    发现所有底层的Swift力量")*发现所有底层的Swift力量*中更详细地介绍编译过程。
- en: Constants and variables
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量和变量
- en: Using constant has an impact on code readability. It makes code clearer and
    safer. Using constants instead of variables could also have performance benefits.
    When you use a constant you give the compiler a clear hint that this value won't
    be changed. The Swift compiler can apply inline optimization to use a value of
    that constant and not allocate memory for it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量会影响代码的可读性。它使代码更清晰、更安全。使用常量而不是变量也可能带来性能上的好处。当你使用常量时，你给编译器一个明确的提示，表明这个值不会改变。Swift
    编译器可以对常量的值进行内联优化，而不为其分配内存。
- en: In simple examples, the Swift compiler could do the same optimization for variables
    as well. Let's analyze the result for this simple example of iterating and calculating
    a sum. The performance is the same for variables and constants in this example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的例子中，Swift 编译器也可以对变量执行相同的优化。让我们分析这个简单示例的结果，迭代并计算总和。在这个例子中，变量和常量的性能相同。
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we look at a more complex example, we will see that constants perform the
    same as, or even better than, variables. It might seem as if a version using variables
    should perform faster, because there is no need to allocate memory for new constants
    on every operation, but the Swift compiler is smart enough to perform intelligent
    optimization so that they behave the same.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看一个更复杂的例子，我们会看到常量表现得和变量一样，甚至更好。可能看起来使用变量的版本应该运行得更快，因为不需要在每次操作时为新的常量分配内存，但
    Swift 编译器足够智能，能够执行智能优化，使它们表现得一样。
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So the general advice is: Prefer using constants. They make the code safer
    and clearer and also have a positive impact on performance. Variables in some
    situations could also improve code readability, as in the example earlier where
    we had to do some math calculations and changing the value in the variable actually
    made the code clearer.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般的建议是：优先使用常量。它们使代码更安全、更清晰，并且对性能也有积极的影响。在某些情况下，变量也可能提高代码的可读性，就像前面的例子中，我们不得不做一些数学计算，而改变变量的值实际上使代码更清晰。
- en: Constants are so much better than variables that Xcode shows a warning when
    it detects a variable that was never mutated and suggests you change it to a constant.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 常量比变量好得多，以至于当 Xcode 检测到一个从未被修改的变量时，它会显示警告，并建议你将其更改为常量。
- en: '![Constants and variables](img/00019.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![常量和变量](img/00019.jpeg)'
- en: Method calls
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法调用
- en: Before discussing Swift method calls optimization, it would be very useful to
    have a look at different types of method call implementation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 Swift 方法调用优化之前，查看不同类型的方法调用实现将非常有用。
- en: 'There are two main types of method call:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用主要有两种类型：
- en: '**Static**: Static method binding means that, when you call a method on the
    object, the compiler knows that you are calling exactly this method on exactly
    this class. C is an example of a language with static method binding.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：静态方法绑定意味着，当你对一个对象调用方法时，编译器知道你正在调用这个类上的确切方法。C 是一个具有静态方法绑定的语言的例子。'
- en: '**Dynamic**: On other hand, dynamic has a weak binding between the method and
    the object. When you call a method on the object there is no guarantee that an
    object can handle this method call. Objective-C has a dynamic method binding.
    That''s why you can see the `object does not respond to selector` error in Objective-C.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**：另一方面，动态方法与对象之间的绑定较弱。当你对一个对象调用方法时，没有保证对象能够处理这个方法调用。Objective-C 有动态方法绑定。这就是为什么你会在
    Objective-C 中看到“对象没有响应选择器”的错误。'
- en: Objective-C is a dynamic-type language and it has a dynamic runtime. Calling
    a method is called **message sending**. You send a message to the target.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 是一种动态类型语言，它有一个动态运行时。调用方法被称为**消息发送**。你向目标发送一个消息。
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This looks like a normal method call, but after compilation it would actually
    look like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一个正常的方法调用，但在编译后，它实际上会看起来像：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Objective-C uses dynamic method binding. It means that the message and the
    receiver are stored separately. When you send a `bark` message to the `dog` object,
    the dog class has to look up if it has a bark method and if it can handle it.
    This process is called dynamic method binding. The implementation would look like
    this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 使用动态方法绑定。这意味着消息和接收者被分别存储。当你向 `dog` 对象发送一个 `bark` 消息时，狗类必须查找它是否有
    `bark` 方法以及它是否能够处理这个方法。这个过程被称为动态方法绑定。实现方式可能如下所示：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Swift uses a static method binding. It uses a vtable—Virtual Method Table—for
    storing methods. Vtable is an array of function pointers. That means that a class
    has a list of its methods with the memory address of that method implementation.
    When you call a method in Swift, you are calling it on the specific type. The
    binding between the method and the object you are calling this method on is very
    strong and done at compile time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 使用静态方法绑定。它使用 vtable（虚拟方法表）来存储方法。vtable 是一个函数指针数组。这意味着一个类有一个其方法列表及其方法实现的内存地址。当你调用
    Swift 中的方法时，你是在调用特定类型的方法。方法与调用该方法的对象之间的绑定非常强，并且是在编译时完成的。
- en: 'Let''s have a look how the same code would behave in Swift:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看相同的代码在 Swift 中的表现：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because Swift knows that you want to call a bark method on the `Dog` class,
    it doesn''t need to do any extra lookup for the method information. It will get
    the function address and call it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Swift 知道你想要在 `Dog` 类上调用 bark 方法，所以它不需要为方法信息进行任何额外的查找。它将获取函数地址并调用它：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Swift can do even more complex optimization to method calls. If the method
    is not overridden, it means that call to the `bark` method will always resolve
    to the same function call. The Swift compiler can skip the function lookup in
    the vtable and inline direct function call:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 可以对方法调用进行更复杂的优化。如果方法没有被覆盖，这意味着对 `bark` 方法的调用将始终解析为相同的函数调用。Swift 编译器可以跳过
    vtable 中的函数查找并内联直接函数调用：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is the mangled name of the `bark` method. We will learn more about this
    in [Chapter 8](part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0
    "Chapter 8. Discovering All the Underlying Swift Power"), *Discovering All the
    Underlying Swift Power*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `bark` 方法的混淆名称。我们将在第 8 章[发现所有 Swift 的底层力量](part0068_split_000.html#20R681-f05765b7b5914043830034430c83d0a0
    "第 8 章。发现所有 Swift 的底层力量")中了解更多，*发现所有 Swift 的底层力量*。
- en: 'The `_TFC12methodsCalls3Dog4barkfS0_FT_T_()` direct function call in the assembly
    code is translated into a simple command. Here is how the assembly pseudo code
    looks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编代码中的 `_TFC12methodsCalls3Dog4barkfS0_FT_T_()` 直接函数调用被翻译成简单的命令。以下是汇编伪代码的示例：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s compare the performance of Swift static method calls with the Objective-C
    dynamic method call to the see the performance difference. Let''s make a simple
    `Number` class with an `add` method that will add two numbers (a Swift solution):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较 Swift 静态方法调用与 Objective-C 动态方法调用的性能差异。让我们创建一个简单的 `Number` 类，它有一个 `add`
    方法，用于将两个数字相加（Swift 解决方案）：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For time measurement we are using our `measure` function from the previous
    chapter:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于时间测量，我们使用上一章中的 `measure` 函数：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result: `Average Time - 1.45391867654989`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：`平均时间 - 1.45391867654989`。
- en: 'Let''s see the Objective-C solution:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Objective-C 的解决方案：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result: `Average Time - 2.974986`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：`平均时间 - 2.974986`。
- en: As you can see, even a very simple function call is twice as fast in Swift.
    Now you know the details of Swift method and functions call implementation, it's
    time to jump to more practical examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，即使在 Swift 中一个非常简单的函数调用也要快两倍。现在你已经了解了 Swift 方法和函数调用实现的细节，是时候转向更实际的例子了。
- en: Functions and methods
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和方法
- en: 'You can make code reusable by making a function or a method in four different
    ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下四种方式之一创建函数或方法来使代码可重用：
- en: Global functions
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局函数
- en: Type methods
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型方法
- en: Static and final methods
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态和最终方法
- en: Instance methods
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法
- en: Global functions
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局函数
- en: 'Global functions are the simplest ones. They cannot be overridden and changed.
    Global functions are stored as named pointers in memory. When you call a global
    function it is translated to the direct memory call without any lookup in the
    vtable. This should be the fastest way. The assembly code for calling a global
    function is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数是最简单的一种。它们不能被覆盖和更改。全局函数存储为内存中的命名指针。当你调用全局函数时，它会被翻译为直接内存调用，而不需要在 vtable 中进行查找。这应该是最快的方式。调用全局函数的汇编代码如下：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Type methods
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型方法
- en: 'Type methods operate on the type and not instances of that type. Class methods
    are stored in the vtable for that class. The class method can be overridden by
    subclass. Because class methods can be overridden, the Swift compiler sometimes
    can''t optimize class method calls to a direct function call as for global functions.
    For a better understanding of why, let''s have a look at this simple example of
    an overridden class method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类型方法操作的是类型本身，而不是该类型的实例。类方法存储在该类的 vtable 中。类方法可以被子类覆盖。因为类方法可以被覆盖，Swift 编译器有时无法像全局函数那样优化类方法调用为直接函数调用。为了更好地理解原因，让我们看看这个简单的覆盖类方法的例子：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We have made two simple classes: `Dog` and `BigDog`. The function `getDog`
    returns a `Dog.Type` class type, but it can also return `BigDog.Type`. The `dog`
    variable can be either a `Dog.Type` or a `BigDog.Type`. Because of that, the Swift
    compiler can''t do direct function calls inline. It has to do a lookup for the
    function pointer in the vtable and that is a very cheap operation. The pseudo
    assembly code for this would look like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个简单的类：`Dog` 和 `BigDog`。`getDog` 函数返回一个 `Dog.Type` 类类型，但它也可以返回 `BigDog.Type`。因此，`dog`
    变量可以是 `Dog.Type` 或 `BigDog.Type`。正因为如此，Swift 编译器不能直接在行内进行函数调用。它必须查找虚表中的函数指针，这是一个非常便宜的操作。这个伪汇编代码将看起来像这样：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Swift compiler can do direct function calls inline for overridden methods
    when you specify a type explicitly. In this example we call the `bark` method
    on the `Dog` class and the Swift compiler skips the vtable lookup:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你明确指定类型时，Swift 编译器可以对重写的方法进行行内直接函数调用。在这个例子中，我们调用 `Dog` 类上的 `bark` 方法，Swift
    编译器会跳过虚表查找：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Static methods
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'You can declare a static type method in classes, structures and enumerations.
    In classes declaring a type method, using the `static` keyword is the same as
    using the `final class` keywords. Those two method declarations are equivalents:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在类、结构和枚举中声明静态类型方法。在类中声明类型方法时，使用 `static` 关键字与使用 `final class` 关键字相同。这两个方法声明是等价的：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Static methods can''t be overridden in the subclasses. Because they can''t
    be overridden they don''t need to be stored in the vtable. The implementation
    details of a static method are very similar to a global function. In the assembly
    code it will be translated to a direct function call, the same as for global functions.
    Let''s add a static function to our dog class and explore how it translates to
    the assembly code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法不能在子类中被重写。因为它们不能被重写，所以不需要存储在虚表中。静态方法的实现细节与全局函数非常相似。在汇编代码中，它将被翻译为直接函数调用，与全局函数相同。让我们给我们的狗类添加一个静态函数，并探索它如何翻译成汇编代码：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Both calls to the `speak` method in `Dog` and the `BigDog` class are translated
    to a one-line assembly instruction.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog` 和 `BigDog` 类中 `speak` 方法的两次调用都被翻译成一条汇编指令。'
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Instance methods
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例方法
- en: 'The main difference between type methods and instance methods is that instance
    methods can operate with instance constants and variables. Instance methods can
    be overridden and they need to be stored in the vtable. Let''s add a name variable
    to our `Dog` class and a `changeName` instance method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类型方法和实例方法之间的主要区别在于实例方法可以操作实例常量和变量。实例方法可以被重写，并且需要存储在虚表中。让我们给我们的 `Dog` 类添加一个 `name`
    变量和一个 `changeName` 实例方法：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `changeName` method will be translated to this assembly code. Get the method
    address from the vtable and call it with passing parameters:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`changeName` 方法将被翻译成以下汇编代码。从虚表中获取方法地址，并传递参数来调用它：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Comparing function speed
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较函数速度
- en: 'Now you know how functions and methods are implemented and how they work. Let''s
    compare the performance speed of those global function and the different method
    types. For the test we will use a simple `add` function. We will implement it
    as a global function, static, class type, and instance and override them in the
    subclass:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了函数和方法是如何实现以及它们是如何工作的。让我们比较那些全局函数和不同方法类型的性能速度。对于测试，我们将使用一个简单的 `add` 函数。我们将将其实现为一个全局函数、静态、类类型和实例，并在子类中重写它们：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the measurement and code analysis, we use a simple loop where we call those
    different methods:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测量和代码分析，我们使用一个简单的循环来调用这些不同的方法：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Results:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果：
- en: 'All these methods perform in exactly the same way. Furthermore, their assembly
    code looks exactly the same, except the name of the function call:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法的表现方式完全相同。此外，它们的汇编代码看起来也完全一样，除了函数调用的名称：
- en: '**Global function**: `add(10, y: 11)`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局函数**：`add(10, y: 11)`'
- en: '**Static**: `NumOperation.addS(10, y: 11)`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：`NumOperation.addS(10, y: 11)`'
- en: '**Class**: `NumOperation.addC(10, y: 11)`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：`NumOperation.addC(10, y: 11)`'
- en: '**Subclass Static**: `BigNumOperation.addS(10, y: 11)`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子类静态**：`BigNumOperation.addS(10, y: 11)`'
- en: '**Subclass overridden class**: `BigNumOperation.addC(10, y: 11)`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子类重写类**：`BigNumOperation.addC(10, y: 11)`'
- en: 'The assembly pseudocode for those functions looks likes this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的汇编伪代码看起来是这样的：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even though the `BigNumOperation` `addC` class function overrides the `NumOperation`
    `addC` function when you call it directly, there is no need for a vtable lookup.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 即使直接调用 `BigNumOperation` 的 `addC` 类函数会重写 `NumOperation` 的 `addC` 函数，也不需要进行虚表查找。
- en: The instance method call looks a bit different.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法调用看起来略有不同。
- en: '**Instance**:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例**：'
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Subclass overridden instance**:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子类重写实例**：'
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The one difference is that they need to initialize a class and create an instance
    of the object. In our example this is not such an expensive operation because
    we do it outside the loop and it happens only once:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的不同之处在于它们需要初始化一个类并创建对象的实例。在我们的例子中，这并不是一个昂贵的操作，因为我们是在循环外部进行的，并且只发生一次：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The loop with the calling instance method looks exactly the same so we will
    not list it again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 调用实例方法的循环看起来完全一样，所以我们不再列出它。
- en: 'As you have seen there is almost no difference between global functions and
    static and class methods. Instance methods look a bit different but it doesn''t
    have a big impact on performance. Though this is true for simple use cases, there
    is a difference between them in more complex examples. Let''s have a look at this
    one:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，全局函数和静态及类方法之间几乎没有什么区别。实例方法看起来略有不同，但这不会对性能产生太大影响。尽管这在简单用例中是正确的，但在更复杂的例子中，它们之间还是有区别的。让我们看看这个例子：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only difference here is that, instead of specifying the `NumOperation` class
    type at compile time, we randomly return it at runtime. And because of this, the
    Swift compiler doesn't know which method should be called—`BigNumOperation.addC`
    or `NumOperation.addC`—at compile time. This small change has an impact on the
    generated assembly code and the performance.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是，我们不是在编译时指定 `NumOperation` 类类型，而是在运行时随机返回它。正因为如此，Swift 编译器在编译时不知道应该调用哪个方法——`BigNumOperation.addC`
    还是 `NumOperation.addC`。这个小小的改动对生成的汇编代码和性能有影响。
- en: Functions and methods usage summary
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数和方法使用总结
- en: Global functions are the simplest ones and provide the best performance. Having
    too many global functions makes code hard to read and follow.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 全局函数是最简单的，提供最佳性能。全局函数太多会使代码难以阅读和跟踪。
- en: Static type methods that can't be overridden have the same performance as global
    functions but they also provide a namespace (type `name`), so our code looks clearer
    and without any loss in performance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不能被重写的静态类型方法与全局函数具有相同的性能，但它们还提供了一个命名空间（类型 `name`），因此我们的代码看起来更清晰，且不会损失任何性能。
- en: Class methods that can be overridden could lead to a performance loss and should
    be used when you need class inheritance. In other cases, static methods are preferred.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 可以被重写的类方法可能会导致性能损失，应该在你需要类继承时使用。在其他情况下，静态方法更受欢迎。
- en: Instance methods operate on the instance of the object. Use instance methods
    when you need to operate on the data of that instance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法操作对象的实例。当你需要操作该实例的数据时，使用实例方法。
- en: Make methods final when you don't need to override them. This tells the compiler
    that optimization and performance could be increased because of that.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你不需要重写方法时，将方法设置为 `final`。这告诉编译器，由于这个原因，优化和性能可能会提高。
- en: Intelligent code
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能代码
- en: 'Because Swift is a static and strongly typed language it can read, understand,
    and optimize code very well. Swift tries to remove the execution of all unnecessary
    code. For a better explanation let''s have a look at a simple example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Swift 是一种静态和强类型语言，它可以很好地读取、理解和优化代码。Swift 尝试移除所有不必要的代码执行。为了更好地解释，让我们看看一个简单的例子：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We create an instance of the `Object` class and call a `nothing` method. The
    `nothing` method is empty and calling it does nothing. The Swift compiler understands
    that and removes those method calls. After this we have only one line of code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建 `Object` 类的实例并调用一个 `nothing` 方法。`nothing` 方法是空的，调用它没有任何作用。Swift 编译器理解这一点，并移除了这些方法调用。之后，我们只剩下一行代码：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The Swift compiler can also obviate the creation of objects that are never used.
    It reduces memory usage and unnecessary function calls, which also reduces CPU
    usage. In our example the `object` instance is not used after removing the `nothing`
    method call and the creation of `Object` can be dispensed with as well. This way,
    Swift removes all three lines of code and we end up with no code to execute at
    all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编译器还可以避免创建从未使用过的对象。它减少了内存使用和不必要的函数调用，这也有助于减少 CPU 使用。在我们的例子中，在移除 `nothing`
    方法调用和创建 `Object` 之后，`object` 实例不再被使用，因此可以省略 `Object` 的创建。这样，Swift 就移除了所有三行代码，最终我们没有代码要执行。
- en: Objective-C, can't do this optimization. Because it has a dynamic runtime, the
    `nothing` method implementation could be changed to do some work at runtime. That's
    why Objective-C can't remove empty method calls.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 无法进行此优化。因为它有动态运行时，`nothing` 方法的实现可以在运行时更改以执行一些工作。这就是为什么 Objective-C
    无法删除空方法调用。
- en: 'This optimization might not seem to amount to much but let''s have a look at
    another, slightly more complex example that uses more memory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优化可能看起来并不起眼，但让我们看看另一个稍微复杂一些的例子，它使用了更多的内存：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have added some `Int` data to our `Object` class to increase memory usage.
    Now the `Object` instance uses at least 24 bytes (3 * `Int` size; `Int` uses four
    bytes in 64-bit architecture). Let''s also try to increases CPU usage by adding
    more instructions via a loop:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向我们的 `Object` 类添加了一些 `Int` 数据来增加内存使用。现在 `Object` 实例至少使用 24 字节（3 倍的 `Int` 大小；在
    64 位架构中 `Int` 使用 4 字节）。让我们也通过添加更多指令来尝试增加 CPU 使用率，通过循环实现：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Integer literals can use underscores (`_`) to improve readability. 1_000_000_000
    is the same as 1000000000
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量可以使用下划线 (`_`) 来提高可读性。1_000_000_000 与 1000000000 相同
- en: 'Now we have three million instructions and we use 24 million bytes, about 24
    MB. This is quite a lot for the type of operation that actually doesn''t do anything.
    As you can see, we don''t use the result of the loop body. For the loop body Swift
    does the same optimization as in the previous example and we end up with an empty
    loop:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有三百万条指令，我们使用了 2400 万字节，大约 24 MB。这对于实际上什么也不做的操作类型来说相当多。如您所见，我们没有使用循环体的结果。对于循环体，Swift
    执行与上一个例子相同的优化，我们最终得到一个空的循环：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The empty loop can be skipped as well. As a result, we have saved 24 MB of memory
    usage and three million method calls.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 空循环也可以跳过。结果，我们节省了 24 MB 的内存使用和三百万次方法调用。
- en: Dangerous functions
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 危险的函数
- en: There are some functions and instructions that sometimes don't provide any value
    for the application but the Swift compiler can't skip them and they could have
    a very negative impact on performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数和指令有时对应用程序没有任何价值，但 Swift 编译器无法跳过它们，它们可能会对性能产生非常负面的影响。
- en: Console print
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台打印
- en: 'Printing a statement to the console is usually used for debug purposes. The
    `print` and `debugPrint` instructions aren''t removed from the application in
    the Release mode. Let''s explore this code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将语句打印到控制台通常用于调试目的。在发布模式下，`print` 和 `debugPrint` 指令不会被从应用程序中移除。让我们看看这段代码：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The Swift compiler treats `print` and `debugPrint` as a valid and important
    instruction that can''t be skipped. Even though this code does nothing, it can''t
    be optimized because Swift doesn''t remove the `print` statement. And as a result
    we have one million unnecessary instructions. The assembly code for this is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编译器将 `print` 和 `debugPrint` 视为有效且重要的指令，不能跳过。尽管这段代码实际上什么也不做，但它无法被优化，因为
    Swift 不移除 `print` 语句。因此，我们有一百万条不必要的指令。这个汇编代码如下：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see even very simple code that uses the `print` statement can decrease
    application performance very dramatically. The loop with the 1_000_000 `print`
    statement takes five seconds and that's a lot. It's even worse if you run it in
    Xcode; it will take up to 50 seconds.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使是非常简单的使用 `print` 语句的代码也可能非常大幅度地降低应用程序的性能。包含 1_000_000 个 `print` 语句的循环需要五秒钟，这已经很多了。如果在
    Xcode 中运行，它将需要长达 50 秒。
- en: 'It gets even worse if you add a `print` instruction to the `nothing` method
    of an `Object` class from the previous example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在前一个例子中的 `Object` 类的 `nothing` 方法中添加一个 `print` 指令，情况会更糟：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In that case, a loop where we create an instance of `Object` and call `nothing`
    can''t be eliminated because of the `print` instruction. Even though Swift can''t
    eliminate execution of that code completely it does the optimization by removing
    the creation instance of `Object` and calling the `nothing` method, and turns
    it into a simple loop operation. The compiled code after optimization will look
    like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于 `print` 指令，我们创建 `Object` 实例并调用 `nothing` 的循环无法消除。尽管 Swift 无法完全消除该代码的执行，但它通过移除创建实例和调用
    `nothing` 方法来进行优化，将其转换为简单的循环操作。优化后的编译代码将如下所示：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, this code is far from perfect and supplies a lot of instructions
    that actually don't give us any value. There is a way to improve this code so
    the Swift compiler would perform the optimal code optimisation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这段代码远非完美，提供了很多实际上对我们没有任何价值的指令。有一种方法可以改进这段代码，以便 Swift 编译器能够执行最优化的代码优化。
- en: Removing print logs
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除打印日志
- en: To solve this performance problem we have to remove the `print` statements from
    the code before compiling it. There are a few ways to do that.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个性能问题，我们必须在编译之前从代码中删除 `print` 语句。有几种方法可以做到这一点。
- en: Comment out
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注释掉
- en: The first idea is to comment out all `print` statements in the code in the Release
    mode.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法是在发布模式下的代码中注释掉所有的 `print` 语句。
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This would work but the next time you want to enable logs, you would need to
    uncomment that code. This is a very bad and painful practice. There is a better
    solution.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但下次你想启用日志时，你需要取消注释那段代码。这是一个非常糟糕且痛苦的做法。有一个更好的解决方案。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Commented code is bad practice in general. You should be using a source code
    version control system, such as Git, instead. This way you can safely remove unnecessary
    code and find it in history if you need it someday.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉的代码通常是不良实践。你应该使用源代码版本控制系统，如 Git，而不是这样做。这样，你可以安全地删除不必要的代码，并在需要时在历史记录中找到它。
- en: Using build configurations
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用构建配置
- en: 'We can enable `print` only in the **Debug** mode. To do this, we will use a
    build configuration to conditionally exclude some code. First we need to add a
    Swift compiler custom flag. To do that:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅在 **Debug** 模式下启用 `print`。为此，我们将使用构建配置来有条件地排除一些代码。首先，我们需要添加一个 Swift 编译器自定义标志。为此：
- en: 'Select a Project target— **Build Settings** – **Other Swift flags** setting
    in the **Swift Compiler – Custom Flags** section and add the **–D DEBUG** flag
    for the **Debug** mode:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 选择项目目标— **构建设置** – **其他 Swift 标志** 设置在 **Swift 编译器 – 自定义标志** 部分，并为 **Debug**
    模式添加 **–D DEBUG** 标志：
- en: '![Using build configurations](img/00020.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用构建配置](img/00020.jpeg)'
- en: 'After this you can use the `DEBUG` configuration flag to enable code only in
    the Debug mode. We will define our own `print` function that will generate print
    statement only in debug mode. In the Release mode, that function would be empty
    and the Swift compiler will successfully eliminate it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你可以使用 `DEBUG` 配置标志来仅启用调试模式下的代码。我们将定义自己的 `print` 函数，该函数仅在调试模式下生成打印语句。在发布模式下，该函数将为空，Swift
    编译器将成功将其删除：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everywhere instead of `print` we will now use `D_print`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何地方，我们都会使用 `D_print` 替代 `print`：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also create a similar `D_debugPrint` function.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个类似的 `D_debugPrint` 函数。
- en: Swift is very smart and does a lot of optimization but we also have to make
    code clear for people to read and for the compiler to optimize.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 非常智能，做了很多优化，但我们还必须使代码对人们阅读和编译器优化来说清晰易懂。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using a preprocessor adds complexity to the code. Use this wisely and only in
    those situations when normal `if` conditions won't work, like in our `D_print`
    example.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预处理器会增加代码的复杂性。明智地使用它，并且仅在正常 `if` 条件无法工作的情况下使用，就像我们的 `D_print` 示例中那样。
- en: Using nonoptimizable constants
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用不可优化的常量
- en: Some types can't be optimized as well as others and using constants of that
    type can't prevent the code from being eliminated by the Swift compiler.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类型不能像其他类型那样优化，使用该类型的常量不能防止 Swift 编译器删除代码。
- en: 'Let''s have a look at this simple example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的例子：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The Swift compiler can eliminate this code. Let''s have a look at a more complex
    example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编译器可以删除此代码。让我们看看一个更复杂的例子：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This code can''t be completely eliminated by the Swift compiler. By adding
    a very simple `String` constant, we have added much more complexity to the source-code.
    To understand why it happened we need to explore the assembly code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码不能完全被 Swift 编译器删除。通过添加一个非常简单的 `String` 常量，我们已经向源代码中添加了更多的复杂性。要理解为什么会发生这种情况，我们需要探索汇编代码：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'From the name of the `getInitializedObjCClass` we could make an assumption
    that this method does some Objective-C class type initialization. It might seem
    very strange because we haven''t used any Objective-C types in our code. We have
    added a simple empty string constant: `let a = ""`.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `getInitializedObjCClass` 的名字中，我们可以假设这个方法执行了一些 Objective-C 类类型的初始化。这可能会显得非常奇怪，因为我们没有在我们的代码中使用任何
    Objective-C 类型。我们添加了一个简单的空字符串常量：`let a = ""`。
- en: 'The thing is that the Swift `String` provides seamless interoperability with
    the Objective-C `NSString` type. Because of this, when we use a Swift `String`
    it allocates some additional data to perform bridging to `NSString`. Here is how
    that metadata `objc_class__TtC4test11Optimizable` looks:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是 Swift 的 `String` 提供了与 Objective-C 的 `NSString` 类型无缝互操作性。正因为如此，当我们使用 Swift
    的 `String` 时，它会分配一些额外的数据来执行到 `NSString` 的桥接。以下是这个元数据 `objc_class__TtC4test11Optimizable`
    的样子：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There are more types that can''t simply be eliminated by the Swift compiler
    when they are used with simple constants:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多类型，当与简单的常量一起使用时，Swift编译器无法简单地消除：
- en: String
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Array
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Custom Class objects
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义类对象
- en: Closures
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Set
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合
- en: Dictionary
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典
- en: '[PRE46]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The interesting behavior happens if we try to use those types in a structure
    instead of a class. We see different behavior because Swift structures aren''t
    exposed for use in Objective-C. That''s why the Swift compiler can eliminate many
    of them: String, Array, Class, and Closures. Set and Dictionary aren''t eliminated
    even if they are used in the structure.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在结构体而不是类中使用这些类型，会发生有趣的行为。我们观察到不同的行为，因为Swift结构体没有暴露给Objective-C使用。这就是为什么Swift编译器可以消除其中许多类型：String、Array、Class和Closures。即使它们在结构体中使用，Set和Dictionary也不会被消除。
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Moving those constant to the initializer doesn't solve the problem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些常量移动到初始化器并不能解决问题。
- en: The solution to that issue is that you shouldn't use any constants that aren't
    used and don't provide any value for the application.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是您不应该使用任何未使用且不提供任何价值的常量。
- en: Improving speed
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高速度
- en: There are a few techniques that can simply improve code performance. Let's jump
    directly to the first one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种技术可以简单地提高代码性能。让我们直接跳到第一种。
- en: Final
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终
- en: 'You can make a function and property declaration with the `final` attribute.
    Adding the `final` attribute makes it nonoverridable. Subclasses can''t override
    that method or property. When you make a method nonoverridable there is no need
    to store it in the vtable and the call to that function can be performed directly
    without any function address lookup in the vtable:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`final`属性来创建函数和属性声明。添加`final`属性使其不可覆盖。子类不能覆盖那个方法或属性。当您使方法不可覆盖时，没有必要将其存储在虚表中，可以直接调用该函数而无需在虚表中查找任何函数地址：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you have seen, the `final` method performs faster than nonfinal. Even so
    small an optimization can improve application performance. It not only improves
    performance but also makes the code more secure. This way you disable the method
    from being overridden and prevent unexpected and incorrect behavior.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`final`方法比非`final`方法运行得更快。即使这样的优化也能提高应用程序的性能。它不仅提高了性能，而且使代码更安全。这样，您禁用了方法被覆盖，并防止了意外和不正确的行为。
- en: 'Enabling the **Whole Module Optimization** setting achieves very similar optimization
    results but it''s better to mark a function and property declaration explicitly
    as `final`: This reduces compiler work and speeds up compilation time. The compilation
    time for big projects with **Whole Module Optimization** can take up to five minutes
    in Xcode 7 Beta 6.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 启用**整个模块优化**设置可以达到非常相似的优化结果，但最好将函数和属性声明明确标记为`final`：这可以减少编译器的工作量并加快编译时间。在Xcode
    7 Beta 6中，具有**整个模块优化**的大项目的编译时间可能长达五分钟。
- en: Inline functions
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联函数
- en: 'As you have seen Swift can do optimization and make some function calls inline.
    This way there is no performance penalty for calling a function. You can manually
    enable or disable inline functions with the `@inline` attribute:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Swift可以进行优化并使一些函数调用内联。这样调用函数就不会有任何性能损失。您可以使用`@inline`属性手动启用或禁用内联函数：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Even though you can manually control inline functions it's usually better to
    leave it to the Swift compiler to do that. Depending on different optimization
    settings, the Swift compiler applies a different inlining technique.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以手动控制内联函数，但通常最好将其留给Swift编译器来处理。根据不同的优化设置，Swift编译器会应用不同的内联技术。
- en: The use case for `@inline(__always)` is a very simple one-line function that
    you want always to be inlined.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`@inline(__always)`的使用场景非常简单，即您希望始终内联的一行函数。'
- en: Value objects and reference objects
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值对象和引用对象
- en: In the previous chapter, you learned the benefits of using immutable value objects.
    Value objects not only make code safer and clearer, they also make it faster.
    Value objects have better speed performance than reference objects and here is
    why. As an example of a value object, we will use structures in this chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了使用不可变值对象的好处。值对象不仅使代码更安全、更清晰，而且使代码运行更快。值对象的速度性能优于引用对象，原因如下。在本章中，我们将使用结构体作为值对象的示例。
- en: Memory allocation
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配
- en: Value objects can be allocated on the stack memory instead of the heap memory.
    Reference objects need to be allocated on the heap memory because they can be
    shared between many owners. Because value objects have only one owner they can
    be safely allocated on the stack. Stack memory is way faster that heap memory.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象可以在栈内存上分配，而不是在堆内存上。引用对象需要分配在堆内存上，因为它们可以被许多所有者共享。因为值对象只有一个所有者，所以它们可以安全地分配在栈上。栈内存比堆内存快得多。
- en: 'The second advantage is that value objects don''t need reference counting memory
    management. As they can have only one owner, there is no such thing as reference
    counting for value objects. With **ARC** (**Automatic Reference Counting**), we
    don''t need to think so much about memory management and it mostly looks transparent
    for us. Even though using reference-object and value-object code looks the same,
    ARC adds extra retain and release method calls for reference objects. Let''s look
    at a very simple example of a structure and class that represent a number:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个优点是值对象不需要引用计数内存管理。因为它们只有一个所有者，所以值对象没有引用计数。使用**ARC（自动引用计数**），我们不需要过多考虑内存管理，对我们来说它看起来大多是透明的。尽管使用引用对象和值对象的代码看起来相同，但ARC为引用对象添加了额外的保留和释放方法调用。让我们看看一个表示数字的结构和类的非常简单的例子：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As an example we will write exactly the same code using `NumberValue` and `NumberReference`
    and compare the generated assembly code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将使用`NumberValue`和`NumberReference`编写完全相同的代码，并比较生成的汇编代码：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The two lines of code for creating and using the `NumberValue` structure look
    very simple. In the assembly, it has three lines of code that do the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用`NumberValue`结构的三行代码看起来非常简单。在汇编中，它有三行代码执行以下操作：
- en: Create the `NumberValue` object
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`NumberValue`对象
- en: Assign it to `x` variables
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其分配给`x`变量
- en: Save `x` number to the `xres` variable
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`x`数字保存到`xres`变量中
- en: '[PRE52]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As you can see the code for creating the first number object and the second
    one looks exactly the same. Now let''s have a look the assembly code for the `NumberReference`
    objects:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建第一个数字对象和第二个对象的代码看起来完全相同。现在让我们看看`NumberReference`对象的汇编代码：
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see the first three lines look almost the same. It creates an instance
    of `NumberReference`, assigns it to the variable, gets the x number, and saves
    it to the `yres` variable. The code for creating second instance is more interesting:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前三条线看起来几乎相同。它创建了一个`NumberReference`实例，将其分配给变量，获取x数字，并将其保存到`yres`变量中。创建第二个实例的代码更有趣：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As you can see it has three lines more than `NumberValue`. We have assigned
    a new instance to the `y` variable; the old `NumberReference` got out of a scope
    and needs to be released. Those three lines are related to the `_swift_release`
    function. If you further analyze the assembly code for working with reference
    objects, you will also discover another ARC function: `_swift_retain;`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它比`NumberValue`多了三条线。我们将新的实例分配给了`y`变量；旧的`NumberReference`超出了作用域，需要释放。这三条线与`_swift_release`函数有关。如果您进一步分析处理引用对象的汇编代码，您还会发现另一个ARC函数：`_swift_retain;`。
- en: Now you know the main performance difference between value types and reference
    types, let's see how they perform. For that, let's use the number type and perform
    some calculations in the loop.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经知道了值类型和引用类型之间的主要性能差异，让我们看看它们的性能表现。为此，让我们使用数字类型并在循环中进行一些计算。
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Output:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first loop with the `NumberValue` structure is completely eliminated by
    the Swift compiler at compile time. The calculating loop is turned into a simple
    integer result; 500500 in hexadecimal equals 0x7a314\. Here is the assembly pseudocode
    for the first loop:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个使用`NumberValue`结构的循环在编译时被Swift编译器完全消除。计算循环被转换为一个简单的整数结果；十六进制的500500等于0x7a314。以下是第一个循环的汇编伪代码：
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see there no loop execution, the result is evaluated at the compile
    time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，没有循环执行，结果是在编译时评估的。
- en: 'The second loop using the `NumberReference` reference objects can''t be eliminated
    at compile time. The assembly pseudocode structure looks exactly the same as the
    source code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NumberReference`引用对象的第二个循环不能在编译时消除。汇编伪代码结构与源代码完全相同：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As you see, using the value object gives a much bigger performance win. As
    an example, let''s measure the performance for that operation but increase the
    loop iterations to 1_00_000_000:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用值对象带来了更大的性能提升。作为一个例子，让我们测量该操作的性能，但将循环迭代次数增加到1_00_000_000：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is not really a fair performance measurement because the variant with
    the value object actually doesn''t do any execution. To compare the actual execution
    speed let''s run this code in debug mode:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个公平的性能测量，因为具有值对象的变体实际上并没有执行任何操作。为了比较实际的执行速度，让我们以调试模式运行此代码：
- en: Tip
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You shouldn't measure performance in the Debug mode.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该在调试模式下测量性能。
- en: 'The results are:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The difference is still impressive; Value objects perform up to four times faster
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 差异仍然令人印象深刻；值对象的速度快至四倍
- en: Swift arrays and unsafe C arrays
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 数组和非安全 C 数组
- en: Everyone knows that C is a super-fast programming language and when you hit
    a performance problem people go to C for help. In Objective-C, it is very easy
    to use C functions and types; its name says it all—C with Objects.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道 C 是一种超级快的编程语言，当遇到性能问题时，人们会求助于 C。在 Objective-C 中，使用 C 函数和类型非常容易；其名称就说明了这一点——C
    with Objects。
- en: 'Swift also has support for interacting with C types and pointers. Even though
    it''s available, it''s considered as a dangerous operation because you need to
    do memory management manually. You need to allocate and destroy memory. Those
    types are called **Unsafe** in Swift and start with the `Unsafe` prefix—for example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还支持与 C 类型和指针交互。尽管它可用，但被认为是一种危险的操作，因为你需要手动进行内存管理。你需要分配和销毁内存。这些类型在 Swift
    中被称为 **Unsafe**，并以 `Unsafe` 前缀开头——例如：
- en: '`UnsafePointer`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnsafePointer`'
- en: '`UnsafeMutablePointer`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnsafeMutablePointer`'
- en: '`UnsafeBufferPointer`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnsafeBufferPointer`'
- en: Tip
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid using C pointers in Swift. It adds a lot of complexity to the code.
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 避免在 Swift 中使用 C 指针。它会给代码增加很多复杂性。
- en: 'There are three main use scenarios for `UnsafePointers`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnsafePointers` 有三个主要的使用场景：'
- en: Function parameters
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数
- en: Creating a pointer to an existing variable
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建指向现有变量的指针
- en: Allocating memory for the pointer
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为指针分配内存
- en: Function parameters
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'First let''s learn how to use pointers. When designing your API in Swift, you
    shouldn''t use `UnsafePointers`, but you can find a situation when you need to
    interact with the C API: a Core Foundation, for example. C pointers would be exposed
    to Swift as:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何使用指针。当你在 Swift 中设计 API 时，你不应该使用 `UnsafePointers`，但你可能会遇到需要与 C API
    交互的情况：例如 Core Foundation。C 指针将暴露给 Swift，如下所示：
- en: '`const Int *` as `UnsafePointer<Int>`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const Int *` 作为 `UnsafePointer<Int>`'
- en: '`Int *` as `UnsafeMutablePointer<Int>`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int *` 作为 `UnsafeMutablePointer<Int>`'
- en: 'When you call a function in Swift with the `UnsafePointer` parameter, you can
    pass a variable of the same type as an in-out argument, by using the `&` sign
    or an array:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Swift 中调用带有 `UnsafePointer` 参数的函数时，你可以通过使用 `&` 符号或数组将相同类型的变量作为输入输出参数传递：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It is also possible to pass `nil`, but in that case our function would have
    a null pointer as an argument and accessing its memory would crash the application:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能传递 `nil`，但那样的话，我们的函数将会有一个空指针作为参数，访问其内存会导致应用程序崩溃：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You will see the following on the screen:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在屏幕上看到以下内容：
- en: '[PRE63]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using `UnsafeMutablePointer` is very similar. The main difference between `UnsafeMutablePointer`
    and `UnsafePointer` is that a mutable pointer can mutate the value of the variable
    it points to. When using arrays as an argument for a function with the `UnsafeMutablePointer`
    parameter, they also need to be passed as in-out parameters.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UnsafeMutablePointer` 非常相似。`UnsafeMutablePointer` 和 `UnsafePointer` 之间的主要区别在于，可变指针可以修改其所指向变量的值。当使用数组作为具有
    `UnsafeMutablePointer` 参数的函数的参数时，它们也需要作为输入输出参数传递。
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Creating a pointer to an existing variable
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建指向现有变量的指针
- en: When you create a pointer you can connect it to an existing variable with the
    `initialize` method. The `initialize` method would return a function that could
    be used to set a new value for that variable.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建指针时，你可以使用 `initialize` 方法将其连接到现有变量。`initialize` 方法将返回一个函数，可以用来设置该变量的新值。
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Allocating memory for the pointer
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为指针分配内存
- en: 'The other way to work with pointers is to allocate a memory for them. The `alloc`
    method has one parameter: the number of objects it will allocate memory for. After
    allocating a memory for the pointer you can use it. Finally, you need to deallocate
    the memory used by the pointer.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针一起工作的另一种方式是为它们分配内存。`alloc` 方法有一个参数：它将为多少个对象分配内存。在为指针分配内存后，你可以使用它。最后，你需要释放指针使用的内存。
- en: '[PRE66]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`UnsafeMutablePointer` has many useful methods that you can use, such as the
    `successor` and `predecessor` methods for moving pointers forward and backward,
    `subscript` for accessing random pointer indices, and many others.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnsafeMutablePointer`有许多有用的方法可供使用，例如用于移动指针前后移动的`successor`和`predecessor`方法，用于访问随机指针索引的`subscript`，以及其他许多方法。'
- en: You can read more about interacting with C pointers at [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html)了解更多关于与C指针交互的信息。
- en: 'Now you have learned how to work with C pointers in Swift let''s jump to our
    main goal: measuring how fast it would be to work with pointer arrays.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经学会了如何在Swift中处理C指针，让我们跳到我们的主要目标：测量使用指针数组工作的速度。
- en: Comparing Swift arrays with unsafe C arrays
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较Swift数组和未安全C数组
- en: For comparison, we will make an array of random numbers and sort them. The main
    goal is not to find the most efficient way to sort numbers in the array but to
    compare performance when working with C `UnsafePointers` and Swift array types.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较，我们将创建一个随机数字数组并对它们进行排序。主要目标不是找到在数组中排序数字的最有效方法，而是比较使用C `UnsafePointers`和Swift数组类型时的性能。
- en: 'First let''s make a C-style variant with `UnsafeMutablePointer`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用`UnsafeMutablePointer`创建一个C样式的变体：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The result is: `Average Time - 1.31680929350041`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：`平均时间 - 1.31680929350041`。
- en: 'Now let''s make the same solution by using Swift arrays:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Swift数组来做出相同的解决方案：
- en: '[PRE68]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The result is: `Average Time - 1.30709397329978`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是：`平均时间 - 1.30709397329978`。
- en: The Swift arrays have the same performance as when working with `UnsafePointers`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Swift数组在处理`UnsafePointers`时的性能与之前相同。
- en: 'As you can see the code looks very similar. The initialization of arrays and
    sort algorithms looks exactly the same in both variants. It''s because both `Array`
    and `UnsafeMutablePointer` have a subscript method. The only difference is in
    the way we create arrays:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码看起来非常相似。数组的初始化和排序算法在两种变体中看起来完全相同。这是因为`Array`和`UnsafeMutablePointer`都有子脚本方法。唯一的区别在于我们创建数组的方式：
- en: 'For `UnsafeMutablePointer`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`UnsafeMutablePointer`：
- en: '[PRE69]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For Swift array:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Swift数组：
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In general, Swift Array provides more functionality and it's much easier to
    work with. As an example, Array has sort, filter and many other methods but `UnsafeMutablePointer`
    doesn't.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Swift数组提供了更多的功能，并且与它们一起工作要容易得多。例如，数组有排序、过滤和其他许多方法，但`UnsafeMutablePointer`没有。
- en: A summary of working with pointers
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指针操作总结
- en: To keep it short— Swift arrays are preferred, and here is why.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之——Swift数组更受欢迎，以下是原因。
- en: Working with pointers is an unsafe and dangerous operation. You need to manually
    allocate and release memory. Accessing memory with pointers is also very dangerous
    because you can access other memory that doesn't belong to you.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 与指针一起工作是一个不安全且危险的操作。你需要手动分配和释放内存。使用指针访问内存也非常危险，因为你可能会访问不属于你的其他内存。
- en: UnsafePointers and Swift arrays have the same performance characteristics.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnsafePointers`和Swift数组具有相同的性能特征。'
- en: Avoiding Objective-C
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用Objective-C
- en: You have learned that Objective-C (with its dynamic runtime) in most cases performs
    more slowly than Swift. Interoperability between Swift and Objective-C is done
    so seamlessly that sometimes we can use Objective-C types and its runtime in the
    Swift code without knowing that.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，在大多数情况下，Objective-C（及其动态运行时）比Swift运行得慢。Swift与Objective-C之间的互操作性做得非常无缝，有时我们可以在Swift代码中使用Objective-C类型及其运行时，而不知道这一点。
- en: 'When you use Objective-C types in Swift code, Swift is actually using the Objective-C
    runtime for method dispatch. Because of that, Swift can''t do the same optimization
    as for pure Swift types. Let''s have a look at a simple example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Swift代码中使用Objective-C类型时，Swift实际上使用Objective-C运行时进行方法调度。正因为如此，Swift不能对纯Swift类型进行相同的优化。让我们看看一个简单的例子：
- en: '[PRE71]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Let's read this code and make some assumptions about how the Swift compiler
    would optimize that code. The `NSObject` instance is never used in the loop body,
    so we could eliminate creating an object. After that we would have an empty loop
    that could also be eliminated. So we would remove all the code from execution.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们阅读这段代码，并对Swift编译器如何优化这段代码做出一些假设。`NSObject`实例在循环体中从未使用过，因此我们可以消除创建对象。之后，我们就会有一个空循环，也可以将其消除。因此，我们会从执行中移除所有代码。
- en: 'Let''s see what is happening in reality by looking at generated assembly pseudocode:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看生成的汇编伪代码来看看现实中发生了什么：
- en: '[PRE72]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see no code gets eliminated. This is happening because Objective-C
    types use the dynamic runtime dispatch method, called message sending.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有代码被消除。这是由于 Objective-C 类型使用动态运行时调度方法，称为消息发送。
- en: All the standard Frameworks such as Foundation and UIKit are written in Objective-C
    and all the types—such as NSDate, NSURL, UIView, and UITableView—use the Objective-C
    runtime. They don't perform as fast as Swift types but we get all those frameworks
    available for use in Swift and this is great.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准框架，如 Foundation 和 UIKit，都是用 Objective-C 编写的，所有类型，如 NSDate、NSURL、UIView 和
    UITableView，都使用 Objective-C 运行时。它们的性能不如 Swift 类型，但我们可以在 Swift 中使用所有这些框架，这是非常好的。
- en: There is no way to remove the Objective-C dynamic runtime dispatch from the
    Objective-C types in Swift, so the only thing we can do is to learn how to use
    them wisely.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中无法从 Objective-C 类型中移除 Objective-C 的动态运行时调度，所以我们唯一能做的就是学习如何明智地使用它们。
- en: Avoiding exposing Swift to Objective-C
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免暴露 Swift 到 Objective-C
- en: We can't remove runtime behavior from Objective-C types but we can stop Swift
    types from using the Objective-C runtime.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法从 Objective-C 类型中移除运行时行为，但我们可以阻止 Swift 类型使用 Objective-C 运行时。
- en: 'When a Swift class inherits from an Objective-C class it also inherits its
    dynamic runtime behavior. This also makes it available for usage in Objective-C
    code. Because it inherits its dynamic behavior the Swift compiler can''t perform
    optimal optimization (as shown in the earlier example with `NSObject` inside a
    loop). Let''s make a simple class that inherits from Objective-C and explore its
    behavior:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Swift 类继承自 Objective-C 类时，它也会继承其动态运行时行为。这也使其在 Objective-C 代码中使用变得可能。因为它继承了动态行为，所以
    Swift 编译器无法执行最优化的优化（如前面示例中 `NSObject` 在循环中的情况所示）。让我们创建一个继承自 Objective-C 的简单类，并探索其行为：
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This code can't be eliminated and its assembly code looks very similar to that
    shown in the earlier example. We could improve that behavior very simply by removing
    the `NSObject` inheritance. We can do that in this example because we don't use
    any features from `NSObject`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码无法被消除，其汇编代码看起来与前面示例中的非常相似。我们可以通过简单地移除 `NSObject` 继承来改进这种行为。我们可以在本例中这样做，因为我们没有使用
    `NSObject` 的任何功能。
- en: '[PRE74]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In that case, the Swift compiler is able to perform optimal optimization and
    eliminates all the code from execution. It removes the creation of the MyObject
    inside the loop and eliminates the empty loop afterwards.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Swift 编译器能够执行最优化的优化，并从执行中消除所有代码。它移除了循环中创建的 MyObject，并在之后消除了空循环。
- en: 'As you have seen, using Objective-C classes in Swift makes the Swift compiler
    less powerful. Inherit and use Objective-C classes only if it''s required in these
    cases:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，在 Swift 中使用 Objective-C 类会使 Swift 编译器变得不那么强大。只有在以下情况下才继承和使用 Objective-C
    类：
- en: Expose Swift types to Objective-C
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Swift 类型暴露给 Objective-C
- en: Need to subclass from Objective-C class, such as UIView, UIViewController and
    so on. Subclass only when it's really required
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要继承自 Objective-C 类，例如 UIView、UIViewController 等。只有在真正需要时才进行子类化
- en: Dynamic
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态
- en: 'There is one more dangerous attribute that adds Objective-C dynamic runtime
    behavior to your type: the `dynamic` keyword. When you make a member declaration
    with the `dynamic` modifier it adds the Objective-C runtime to the class. The
    access to that member will never be statically inlined and will be always dispatched
    dynamically by using the Objective-C Target-Action mechanism. Let''s examine this
    simple example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个更危险的属性会给你的类型添加 Objective-C 的动态运行时行为：`dynamic` 关键字。当你使用 `dynamic` 修饰符声明成员时，它会将
    Objective-C 运行时添加到类中。对该成员的访问永远不会被静态内联，而总是通过使用 Objective-C 的 Target-Action 机制动态调度。让我们来看一个简单的例子：
- en: '[PRE75]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Even such a small example does quite a lot of work. Applying the `dynamic`
    keyword causes many issues:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这样一个小的例子也做了很多工作。应用 `dynamic` 关键字会导致许多问题：
- en: Dynamic message sending with `_objc_msgSend`
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `_objc_msgSend` 进行动态消息发送
- en: Type casting
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Because we use the Objective-C dynamic dispatch method, we need to convert our
    "Name" Swift string type into NSString; when we get a result from that function
    call back into Swift code we need to do one more conversion from NSString back
    to Swift String
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们使用了 Objective-C 的动态调度方法，我们需要将我们的 "Name" Swift 字符串类型转换为 NSString；当我们从该函数调用中获取结果并返回到
    Swift 代码时，我们需要进行一次从 NSString 到 Swift String 的额外转换
- en: No optimization and function call inlining
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有优化和函数调用内联
- en: Because methods are always dispatched dynamically, the Swift compiler can't
    do inline optimization or eliminate empty methods
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于方法总是动态调度的，Swift 编译器无法进行内联优化或消除空方法。
- en: A summary of avoiding Objective-C
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 Objective-C 的总结
- en: You should avoid using Objective-C and its runtime behavior for achieving high
    performance.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该避免使用 Objective-C 及其运行时行为来实现高性能。
- en: You should avoid using the `dynamic` keyword at any price. You should almost
    never use it.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该不惜一切代价避免使用 `dynamic` 关键字。你几乎永远不应该使用它。
- en: Inherit from a Objective-C class only when you need that class behavior, as
    for UIView. Use the `@objc` attribute only when you need to expose your type to
    Objective-C.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在你需要那个类行为时才从 Objective-C 类继承，例如 UIView。只有在你需要将你的类型暴露给 Objective-C 时才使用 `@objc`
    属性。
- en: Summary
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered many topics related to Swift performance. First
    we need to understand what we need to improve and enable optimization settings
    to get the best performance.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了许多与 Swift 性能相关的话题。首先，我们需要了解我们需要改进什么，并启用优化设置以获得最佳性能。
- en: Memory usage is very important for achieving high performance. First, we covered
    how using constants can have a positive impact on performance. The second and
    more important example reflects how using value types and structures reduces memory
    usage and also improves performance by using fast stack memory.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 内存使用对于实现高性能非常重要。首先，我们讨论了使用常量如何对性能产生积极影响。第二个且更为重要的例子反映了使用值类型和结构体如何减少内存使用，并通过使用快速栈内存来提高性能。
- en: The third important topic we have covered is dispatching methods. We have analyzed
    and compared both Objective-C dynamic dispatch and Swift static dispatch. By looking
    at the assembly code we have seen how Swift actually performs method dispatch
    and how it can benefit performance.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的第三个重要主题是方法调度。我们分析了比较了 Objective-C 的动态调度和 Swift 的静态调度。通过查看汇编代码，我们看到了 Swift
    实际上是如何进行方法调度的，以及它是如何通过提高性能来受益的。
- en: We have also covered some dangerous operations that could decrease performance
    and that should be avoided.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了一些可能降低性能的危险操作，这些操作应该避免。
- en: 'In the next chapter, we will learn more about different data structures: their
    differences and performance characteristics.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习更多关于不同数据结构的知识：它们之间的差异和性能特征。
