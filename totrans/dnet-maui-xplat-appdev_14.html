<html><head></head><body>
<div id="sbo-rt-content"><div class="Basic-Text-Frame" id="_idContainer158">
<h1 class="chapterNumber">11</h1>
<h1 class="chapterTitle" id="_idParaDest-290">Developing Unit Tests</h1>
<p class="normal">Testing plays a crucial role in ensuring software quality in contemporary software development. Various types of testing are involved in the software development lifecycle, including unit testing, integration testing, and system testing. Unit testing is employed to examine software modules or components within an isolated environment and is typically carried out by developers. With a well-devised unit test strategy, programming issues can be detected at the earliest stage of the software development lifecycle, rendering unit testing the most efficient and cost-effective approach to guaranteeing software quality. </p>
<p class="normal">In .NET MAUI app development, we can utilize existing unit test frameworks or libraries present in the .NET ecosystem. By employing a test framework or library, we can expedite unit test development. An effective test framework is generally designed for seamless integration with a <strong class="keyWord">continuous integration</strong> (<strong class="keyWord">CI</strong>) and <strong class="keyWord">continuous deployment</strong> (<strong class="keyWord">CD</strong>) environment. In this chapter, we will demonstrate how to set up unit testing and execute unit test cases as part of the .NET MAUI app development lifecycle.</p>
<p class="normal">We will cover the following topics in this chapter:</p>
<ul>
<li class="bulletList">Unit testing in .NET</li>
<li class="bulletList">Mock .NET MAUI components</li>
<li class="bulletList">Razor component testing using bUnit</li>
</ul>
<h1 class="heading-1" id="_idParaDest-291">Technical requirements</h1>
<p class="normal">To test and debug the source code from this chapter, you need to have a .NET 8 environment set up. You can install .NET 8 by following the instructions provided at the Microsoft link below on Windows, macOS, or Linux: <a href="https://dotnet.microsoft.com/en-us/download/dotnet/8.0"><span class="url">https://dotnet.microsoft.com/en-us/download/dotnet/8.0</span></a>.</p>
<p class="normal">Unit tests can be executed from the command line using the <code class="inlineCode">dotnet</code> command, or via the Test Explorer in Visual Studio if you’re using Windows.</p>
<p class="normal">To set up Visual Studio 2022, please refer to the <em class="italic">Development environment setup</em> section in <em class="chapterRef">Chapter 1</em>, <em class="italic">Getting Started with .NET MAUI</em>, for the details.</p>
<p class="normal">The source code for this chapter is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/ae2e0ad9324ff4e05b1508090fe3cda77ad47ccf"><span class="url">https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition/tree/main/2nd/chapter11</span></a>.</p>
<p class="normal">To check out the source code of this chapter, we can use the below command:</p>
<pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>git <span class="hljs-con-built_in">clone</span> -b 2nd/chapter11 https://github.com/PacktPublishing/.NET-MAUI-Cross-Platform-Application-Development-Second-edition.git PassXYZ.Vault2
</code></pre>
<p class="normal">To find out more about the source code in this book, please refer to the section <em class="italic">Managing the source code in this book</em> in <em class="chapterRef">Chapter 2</em>, <em class="italic">Building Our First .NET MAUI App</em>.</p>
<h1 class="heading-1" id="_idParaDest-292">Unit testing in .NET</h1>
<p class="normal">To develop <a id="_idIndexMarker851"/>unit test cases, it is common to utilize a unit test framework to enhance efficiency. There are <a id="_idIndexMarker852"/>several unit test frameworks available in the .NET environment, which are as follows:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Microsoft Test Framework</strong> (<strong class="keyWord">MSTest</strong>) comes bundled with Visual Studio. The initial<a id="_idIndexMarker853"/> version<a id="_idIndexMarker854"/> of MSTest (V1) was not an open-source product, and it first appeared alongside the release of Visual Studio 2005. For more information about MSTest (V1), please refer to the book Microsoft Visual Studio 2005 Unleashed by Lars Powers and Mike Snell. Later, Microsoft made the MSTest (V2) open-source, hosting it on GitHub, with the first release becoming available around 2017.</li>
<li class="bulletList"><strong class="keyWord">NUnit</strong> is an <a id="_idIndexMarker855"/>open-source testing framework <a id="_idIndexMarker856"/>ported from JUnit. It was the inaugural unit test framework for .NET, with its earliest releases hosted on SourceForge in 2004. For more information on version 2.0, please refer to the release notes in the <em class="italic">Further reading</em> section. The latest releases have since been moved to GitHub.</li>
<li class="bulletList"><strong class="keyWord">xUnit</strong> is a <a id="_idIndexMarker857"/>modern and extensible framework <a id="_idIndexMarker858"/>developed by Jim Newkirk and Brad Wilson, the creators of NUnit. They made significant improvements to this new test framework compared to NUnit. To find out more about these enhancements, please refer to Jim’s blog, <em class="italic">Why Did we Build xUnit 1.0</em>? The first stable release of xUnit was available around 2015.</li>
</ul>
<p class="normal">All of these frameworks are quite popular and can be selected according to the project’s requirements. In this chapter, we will utilize xUnit to develop unit test cases, as it is a more recent framework that offers numerous enhancements compared to NUnit.</p>
<p class="normal">Regardless of the unit test framework you select, the process of developing unit tests is rather consistent. Even if you employ a different framework for your project, this chapter’s content remains applicable. Unit test cases are designed to run exclusively on cross-platform target frameworks instead of platform-specific ones. In this book, we utilize .NET 8.0; therefore, the target framework for unit testing is <code class="inlineCode">net8.0</code>, as opposed to <code class="inlineCode">net8.0-android</code> or <code class="inlineCode">net8.0-ios</code>.</p>
<p class="normal">In this chapter, we will first develop unit tests for the model layer, which is common to both XAML and Blazor. Subsequently, we will introduce unit test development for Blazor apps using bUnit. bUnit is a versatile testing library compatible with all three test frameworks: xUnit, NUnit, and MSTest.</p>
<h2 class="heading-2" id="_idParaDest-293">Setting up the unit test project</h2>
<p class="normal">To gain some <a id="_idIndexMarker859"/>practical experience, let’s create a unit test project. We can create a xUnit project using either Visual Studio or the .NET command line:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">To start with Visual Studio, we can add a new project to our current solution, as shown in <em class="italic">Figure 11.1</em>:</li>
</ol>
<figure class="mediaobject"><img alt="Figure 11.1 – Creating a xUnit project" height="499" src="../Images/B21554_11_01.png" width="759"/></figure>
<p class="packt_figref">Figure 11.1 – Creating an xUnit project using Visual Studio</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="2">To<a id="_idIndexMarker860"/> begin, type <code class="inlineCode">xunit</code> into the search box and select <strong class="screenText">xUnit Test Project</strong> for C#.</li>
<li class="numberedList">On the following screen, name the project <code class="inlineCode">PassXYZ.Vault.Tests</code> and click <strong class="screenText">Next</strong>.</li>
<li class="numberedList">Subsequently, set the framework to .NET 8.0 and click <strong class="screenText">Create</strong>.</li>
</ol>
<p class="normal">If you’re using Visual Studio Code, the first step is to install the .NET MAUI extension in your environment. Once the extension is installed, you can navigate through your project using Solution Explorer, akin to how you would in Visual Studio. Please be aware that the .NET MAUI extension is still in the preview stage as of March 2024.</p>
<p class="normal">To create an xUnit project, click the <strong class="screenText">+</strong> button located in the solution. This action will reveal a list of project templates, as demonstrated below:</p>
<figure class="mediaobject"><img alt="A screenshot of a computer  Description automatically generated" height="509" src="../Images/B21554_11_02.png" width="824"/></figure>
<p class="packt_figref">Figure 11.1a – Creating an xUnit project using Visual Studio Code</p>
<p class="normal">To create<a id="_idIndexMarker861"/> the project using a command line, we should first create the folder and then utilize a .NET command to establish the project, as demonstrated below:</p>
<pre class="programlisting con"><code class="hljs-con">mkdir PassXYZ.Vault.Tests
cd PassXYZ.Vault.Tests
dotnet new xunit
dotnet test
</code></pre>
<p class="normal">After creating the project, we can utilize the <code class="inlineCode">dotnet test</code> command to run the test cases. The default test case in the template will be executed, and we will proceed to add more test cases to this project. Our test targets incorporate components from both the <code class="inlineCode">PassXYZ.Vault</code> and <code class="inlineCode">PassXYZ.BlazorUI</code> projects, hence requiring us to include these two projects as reference projects. The target framework of <code class="inlineCode">PassXYZ.BlazorUI</code> is <code class="inlineCode">net8.0</code>, allowing us to add it directly. However, as the target frameworks of <code class="inlineCode">PassXYZ.Vault</code> are platform-specific, we must implement some modifications before incorporating them as references in <code class="inlineCode">PassXYZ.Vault.Tests</code>.</p>
<p class="normal">As we need to build the unit test against the target framework <code class="inlineCode">net8.0</code>, it is necessary to modify the <code class="inlineCode">PassXYZ.Vault.csproj</code> file to include <code class="inlineCode">net8.0</code> as one of the target frameworks:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">TargetFrameworks</span><span class="hljs-tag">&gt;</span><span class="code-highlight"><strong class="hljs-slc">net8.0</strong></span>;net8.0-android;net8.0-ios;net8.0-
  maccatalyst<span class="hljs-tag">&lt;/</span><span class="hljs-name">TargetFrameworks</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">When <a id="_idIndexMarker862"/>building the <code class="inlineCode">PassXYZ.Vault</code> project on supported platforms, we anticipate an executable, as it is an app. However, when building <code class="inlineCode">PassXYZ.Vault</code> for the <code class="inlineCode">net8.0</code> target framework, we aim to test it. <code class="inlineCode">PassXYZ.Vault</code> should be generated as a library so that the test framework can utilize it to run test cases. In this instance, we expect to build a file with a <code class="inlineCode">.dll</code> extension instead of <code class="inlineCode">.exe</code>, which necessitates the following modification:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">OutputType</span><span class="hljs-tag"> </span><span class="code-highlight"><strong class="hljs-attr-slc">Condition</strong><strong class="hljs-tag-slc">=</strong><strong class="hljs-string-slc">"'</strong><strong class="hljs-string-slc">$(TargetFramework)'!='net8.0'"</strong></span><span class="hljs-tag">&gt;</span>
  Exe<span class="hljs-tag">&lt;/</span><span class="hljs-name">OutputType</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">In the preceding build setup, a condition has been added to verify the target framework for the output type. If the target framework is not <code class="inlineCode">net8.0</code>, the build output will be generated as an executable. Conversely, if the target framework is set to <code class="inlineCode">net8.0</code>, a library will be generated.</p>
<p class="normal">After making these changes, we can add reference projects to <code class="inlineCode">PassXYZ.Vault.Tests</code> by either right-clicking on the solution node and selecting <strong class="screenText">Add </strong>-&gt;<strong class="screenText"> Project Reference</strong>, or by editing the project file for <code class="inlineCode">PassXYZ.Vault.Tests</code> to include these lines:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">ItemGroup</span><span class="hljs-tag">&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ProjectReference</span><span class="hljs-tag"> </span>
<span class="hljs-tag">    </span><span class="hljs-attr">Include</span><span class="hljs-tag">=</span><span class="hljs-string">"..\PassXYZ.BlazorUI\PassXYZ.BlazorUI.csproj"</span><span class="hljs-tag"> /&gt;</span>
  <span class="hljs-tag">&lt;</span><span class="hljs-name">ProjectReference</span><span class="hljs-tag"> </span>
<span class="hljs-tag">    </span><span class="hljs-attr">Include</span><span class="hljs-tag">=</span><span class="hljs-string">"..\PassXYZ.Vault\PassXYZ.Vault.csproj"</span><span class="hljs-tag"> /&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">ItemGroup</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">In order to test the MAUI project, it is also necessary to add the following configuration to the <code class="inlineCode">PassXYZ.Vault.Tests</code> project:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">UseMaui</span><span class="hljs-tag">&gt;</span>true<span class="hljs-tag">&lt;/</span><span class="hljs-name">UseMaui</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">We have now successfully set up the xUnit project. Next, let’s proceed to add our test cases.</p>
<h2 class="heading-2" id="_idParaDest-294">Developing test cases for the model</h2>
<p class="normal">We use <a id="_idIndexMarker863"/>xUnit as a unit testing tool for our app. It provides a comprehensive and efficient way to run tests sequentially in isolation from each other, supporting both desktop and mobile applications.</p>
<p class="normal">Two fundamental concepts in xUnit are <code class="inlineCode">Fact</code> and <code class="inlineCode">Theory</code>.</p>
<p class="normal"><code class="inlineCode">Fact</code> in xUnit refers to a parameterless test method that confirms the correctness of certain conditions in code. It states that something should always be true. A “fact” test always runs every time the test suite runs as they are supposed to be invariant conditions, regardless of the data state at the execution time.</p>
<p class="normal">On the other hand, <code class="inlineCode">Theory</code> allows parameterized tests to be conducted. It allows developers to run a single test method multiple times with different sets of data, reducing code redundancy while enhancing coverage. It is based on the idea that if the test method’s contract is true for a specific dataset, it should be true for all datasets.</p>
<p class="normal">We will begin by adding test cases to examine the model layer, as the test case setup for the model layer is identical in both the XAML and Blazor versions of our app.</p>
<p class="normal">In the model layer, the primary implementation resides within the <code class="inlineCode">PassXYZLib</code> library. For more information on the unit test cases at the model layer, please refer to the <code class="inlineCode">PassXYZLib</code> source code: <a href="https://github.com/shugaoye/PassXYZLib"><span class="url">https://github.com/shugaoye/PassXYZLib</span></a>.</p>
<p class="normal">In our app, <code class="inlineCode">IDataStore</code> is the interface used to export <code class="inlineCode">PassXYZLib</code>. Therefore, let’s incorporate test cases to test this interface, <code class="inlineCode">IDataStore</code>. To assess the <code class="inlineCode">IDataStore</code> interface, we can establish a new test class, <code class="inlineCode">DataStoreTest</code>, within the <code class="inlineCode">PassXYZ.Vault.Tests</code> project. We can add a new test case by testing “the addition of an item” as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataStoreTests</span>
{
  [<span class="hljs-meta">Fact</span>]                                                            <span class="hljs-comment">//(1)</span>
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Add_Item</span><span class="hljs-function">()</span>
  {
      <span class="hljs-comment">// Arrange                                          </span>          <span class="hljs-comment">//(2)</span>
      IDataStore&lt;Item&gt; datastore = <span class="hljs-keyword">new</span> MockDataStore();
      ItemSubType itemSubType = ItemSubType.Entry;
      <span class="hljs-comment">// Act                                              </span>          <span class="hljs-comment">//(3)</span>
      <span class="hljs-keyword">var</span> newItem = datastore.CreateNewItem(itemSubType);
      newItem.Name = <span class="hljs-string">$"</span><span class="hljs-subst">{itemSubType.ToString()}</span><span class="hljs-string">01"</span>;
      <span class="hljs-keyword">await</span> datastore.AddItemAsync(newItem);
      <span class="hljs-keyword">var</span> item = datastore.GetItem(newItem.Id);
      <span class="hljs-comment">// Assert                                           </span>          <span class="hljs-comment">//(4)</span>
      Assert.Equal(newItem.Id, item.Id);
  }
}
</code></pre>
<p class="normal">xUnit employs <a id="_idIndexMarker864"/>attributes to inform the framework about test case configurations. In this test case, we utilize the <code class="inlineCode">[Fact]</code> attribute <strong class="keyWord">(1)</strong> to designate this method as a test case. To define a test case, we can follow a common pattern – <code class="inlineCode">Arrange</code>, <code class="inlineCode">Act</code>, and <code class="inlineCode">Assert</code>:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Arrange</code> <strong class="keyWord">(2)</strong> – We will prepare all necessary setup for the test. To add an item, we need to initialize the <code class="inlineCode">IDataStore</code> interface first, and then we will define a variable to hold the item type.</li>
<li class="bulletList"><code class="inlineCode">Act</code> <strong class="keyWord">(3)</strong> – We execute the methods that we want to test, which are <code class="inlineCode">CreateNewItem</code> and <code class="inlineCode">AddItemAsync</code>.</li>
<li class="bulletList"><code class="inlineCode">Assert</code> <strong class="keyWord">(4)</strong> – We check the result that we expected. In our case, we try to retrieve the new item using <code class="inlineCode">item.Id</code>. After that, we check to ensure that the item ID retrieved is the same as what we expected.</li>
</ul>
<p class="normal">As you may have noticed, we tested the <code class="inlineCode">Entry</code> type in the previous test case. The <code class="inlineCode">Entry</code> type is only one of the item types – we have many. To test all of them, we need to create many test cases. xUnit supports another test case type, <code class="inlineCode">[Theory]</code>, which helps us to test different scenarios with one test case.</p>
<p class="normal">We can use the “delete an item” test case to demonstrate how to test different scenarios in one test case with the <code class="inlineCode">[Theory]</code> attribute. In this test case, we can delete an item in different item types in one test case:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataStoreTests</span>
{
  ...
  [<span class="hljs-meta">Theory</span>]                                                          <span class="hljs-comment">//(1)</span>
  [<span class="hljs-meta">InlineData(ItemSubType.Entry)</span>]                                   <span class="hljs-comment">//(2)</span>
  [<span class="hljs-meta">InlineData(ItemSubType.Group)</span>]
  [<span class="hljs-meta">InlineData(ItemSubType.Notes)</span>]
  [<span class="hljs-meta">InlineData(ItemSubType.PxEntry)</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Delete_Item</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType itemSubType</span><span class="hljs-function">)</span>
  {
      <span class="hljs-comment">// Arrange</span>
      IDataStore&lt;Item&gt; datastore = <span class="hljs-keyword">new</span> MockDataStore();
      <span class="hljs-keyword">var</span> newItem = datastore.CreateNewItem(itemSubType);           <span class="hljs-comment">//(3)</span>
      newItem.Name = <span class="hljs-string">$"</span><span class="hljs-subst">{itemSubType.ToString()}</span><span class="hljs-string">01"</span>;
      <span class="hljs-keyword">await</span> datastore.AddItemAsync(newItem);
      <span class="hljs-comment">// Act</span>
      <span class="hljs-built_in">bool</span> result = <span class="hljs-keyword">await</span>
        datastore.DeleteItemAsync(newItem.Id);                      <span class="hljs-comment">//(4)</span>
      Debug.WriteLine(<span class="hljs-string">$"Delete_Item: </span><span class="hljs-subst">{newItem.Name}</span><span class="hljs-string">"</span>);
      <span class="hljs-comment">// Assert</span>
      Assert.True(result);                                          <span class="hljs-comment">//(5)</span>
  }
  ...
}
</code></pre>
<p class="normal">When <a id="_idIndexMarker865"/>we create a test case using the <code class="inlineCode">[Theory]</code> attribute, <strong class="keyWord">(1)</strong>, we can pass different item types using the <code class="inlineCode">itemSubType</code> parameter. The value of the <code class="inlineCode">itemSubType</code> argument is defined using the <code class="inlineCode">[InlineData]</code> attribute, <strong class="keyWord">(2)</strong>.</p>
<p class="normal">To arrange test data, we create a new item using the <code class="inlineCode">itemSubType</code> argument, <strong class="keyWord">(3)</strong>. Then, we execute the <code class="inlineCode">DeleteItemAsync</code> method, <strong class="keyWord">(4)</strong>, which is the one that we want to test.</p>
<p class="normal">Finally, we check the return value, <strong class="keyWord">(5)</strong>. If the item is deleted successfully, the result is true. Otherwise, the result is false.</p>
<p class="normal">We have learned the process of creating a test case using the <code class="inlineCode">[Fact]</code> attribute, as well as how to address different scenarios with the <code class="inlineCode">[Theory]</code> attribute. In the next section, we will delve into further topics related to test case development.</p>
<h2 class="heading-2" id="_idParaDest-295">Sharing context between tests</h2>
<p class="normal">In our <a id="_idIndexMarker866"/>previous test cases, we created a new <code class="inlineCode">IDataStore</code> instance for each test. Is it possible to share one <code class="inlineCode">IDataStore</code> instance, instead of repeatedly creating the same instance for every test? By sharing the test setup among a <a id="_idIndexMarker867"/>group of test cases in xUnit, we can minimize duplication.</p>
<p class="normal">There are three methods for sharing setup and cleanup code between tests in xUnit:</p>
<ul>
<li class="bulletList"><strong class="keyWord">Constructor</strong> and <strong class="keyWord">Dispose</strong><code class="inlineCode">:</code> We can use a class constructor to share the setup and cleanup code without sharing instances.</li>
<li class="bulletList"><strong class="keyWord">Class Fixture</strong><code class="inlineCode">:</code> We can use a fixture to share object instances in a single class.</li>
<li class="bulletList"><strong class="keyWord">Collection Fixtures</strong><code class="inlineCode">:</code> We can use collection fixtures to share object instances in multiple test classes.</li>
</ul>
<h3 class="heading-3" id="_idParaDest-296">Sharing using a constructor</h3>
<p class="normal">To <a id="_idIndexMarker868"/>remove the duplicated setup code from the previous tests, we can move the creation of the <code class="inlineCode">IDataStore</code> instance to the constructor of the <code class="inlineCode">DataStoreTests</code> test class as follows:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataStoreTests</span>
{
  IDataStore&lt;Item&gt; datastore;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">DataStoreTests</span><span class="hljs-function">()</span>
  {
    datastore = <span class="hljs-keyword">new</span> MockDataStore();
    Debug.WriteLine(<span class="hljs-string">"</span><span class="hljs-string">DataStoreTests: Created"</span>);
  }
  ...
}
</code></pre>
<p class="normal">In this code, we added a private member variable, <code class="inlineCode">datastore</code>, and created an instance of <code class="inlineCode">IDataStore</code> in the constructor of <code class="inlineCode">DataStoreTests</code>. We also added a debug output so we can monitor the creation of the <code class="inlineCode">IDataStore</code> interface. Let us debug the execution of the <code class="inlineCode">DataStoreTests</code> class so we can see the debug output here:</p>
<pre class="programlisting con"><code class="hljs-con">DataStoreTests: Created
Delete_Item: Entry01
DataStoreTests: Created
Delete_Item: Group01
DataStoreTests: Created
Delete_Item: PxEntry01
DataStoreTests: Created
Delete_Item: Notes01
DataStoreTests: Created
Create_Item: PxEntry
DataStoreTests: Created
Create_Item: Group
DataStoreTests: Created
Create_Item: Entry
DataStoreTests: Created
Create_Item: Notes
DataStoreTests: Created
Add_Item: Done
</code></pre>
<p class="normal">We can see from the debug output that a <code class="inlineCode">DataStoreTests</code> class is created for each test case. There<a id="_idIndexMarker869"/> is no difference whether we create the instance of <code class="inlineCode">IDataStore</code> inside the test method or in the constructor. All the test cases are still isolated from each other. When we use the <code class="inlineCode">[Theory]</code> attribute to test different scenarios with one method, each of them looks like a separate test case at runtime. To understand this better, we can use the <code class="inlineCode">dotnet</code> command to list all the defined tests:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet test -t
  Determining projects to restore...
  All projects are up-to-date for restore.
Microsoft (R) Test Execution Command Line Tool Version 17.3.0
  (x64)
Copyright (c) Microsoft Corporation.  All rights reserved.
The following Tests are available:
    PassXYZ.Vault.Tests.DataStoreTests.Add_Item
    PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
      Entry)
    PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
      Group)
    PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
      Notes)
    PassXYZ.Vault.Tests.DataStoreTests.Delete_Item(itemSubType:
      PxEntry)
    PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
      Entry)
    PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
      Group)
    PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
      Notes)
   PassXYZ.Vault.Tests.DataStoreTests.Create_Item(itemSubType:
      PxEntry)
</code></pre>
<p class="normal">We can see that each parameter defined by the <code class="inlineCode">[InlineData]</code> attribute is shown as a separate test case. They are all isolated test cases at runtime.</p>
<p class="normal">After we list all the tests, we can selectively execute them using the <code class="inlineCode">dotnet</code> command.</p>
<p class="normal">If we want to run all the tests in the <code class="inlineCode">DataStoreTests</code> class, we can use this command:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet test --filter DataStoreTests
</code></pre>
<p class="normal">If we want to run <code class="inlineCode">Add_Item</code> tests only, we can use this command:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet test --filter DataStoreTests.Add_Item
</code></pre>
<p class="normal">As we can <a id="_idIndexMarker870"/>see from the debug output, even though we created an instance of <code class="inlineCode">IDataStore</code> in the constructor, the instance is re-created for each test. The instances created in the test class constructor won’t be shared across tests. Even though the effect is still the same, the code looks more concise.</p>
<p class="normal">However, in certain scenarios, we may want to share instances across multiple tests. To achieve this, we can utilize class fixtures. In the following section, we will examine these specific cases.</p>
<h3 class="heading-3" id="_idParaDest-297">Sharing using class fixtures</h3>
<p class="normal">When <a id="_idIndexMarker871"/>utilizing a tool across all test cases, it can be more efficient to share the setup among them rather than creating the same one each time. Let’s use a logging function as an example to illustrate this approach.</p>
<p class="normal">To generate a test report, we aim to create a test log that monitors the execution of unit tests. The <code class="inlineCode">Serilog</code> library is the one which can be used for this purpose. <code class="inlineCode">Serilog</code> enables us to log messages to different channels. In order to use <code class="inlineCode">Serilog</code>, we must first set it up and then clean it up after all the tests have been executed. In this scenario, we prefer to share a single instance of <code class="inlineCode">Serilog</code> between all the tests instead of creating one for each test. This setup allows us to produce a consolidated log file for all the tests rather than generating multiple log files for each individual test.</p>
<p class="normal">To incorporate <code class="inlineCode">Serilog</code>, we need to add the <code class="inlineCode">Serilog</code> package to the project. This can be accomplished by executing the following <code class="inlineCode">dotnet</code> commands in the project’s <code class="inlineCode">PassXYZ.Vault.Tests</code> folder:</p>
<pre class="programlisting con"><code class="hljs-con">dotnet add package Serilog
dotnet add package Serilog.Sinks.File
</code></pre>
<p class="normal">Having added the <code class="inlineCode">Serilog</code> libraries to the project, we can now create a class fixture, <code class="inlineCode">SerilogFixture</code>, for demonstration purposes:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerilogFixture</span> : <span class="hljs-title">IDisposable</span> {                         <span class="hljs-comment">//(1)</span>
  <span class="hljs-keyword">public</span> ILogger Logger { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">SerilogFixture</span><span class="hljs-function">()</span> {
    Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()                              <span class="hljs-comment">//(2)</span>
        .MinimumLevel.Debug()
        .WriteTo.File(<span class="hljs-string">@"logs\xunit_log.txt"</span>)
        .CreateLogger();
    Logger.Debug(<span class="hljs-string">"SerilogFixture: initialized"</span>);
  }
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Dispose</span><span class="hljs-function">()</span> {
    Logger.Debug(<span class="hljs-string">"SerilogFixture: closed"</span>);
    Log.CloseAndFlush();                                            <span class="hljs-comment">//(3)</span>
  }
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IDataStoreTests</span> : <span class="hljs-title">IClassFixture</span>&lt;<span class="hljs-title">SerilogFixture</span>&gt; {      <span class="hljs-comment">//(4)</span>
  IDataStore&lt;Item&gt; datastore;
  SerilogFixture serilogFixture;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">DataStoreTests</span><span class="hljs-function">(</span><span class="hljs-params">SerilogFixture fixture</span><span class="hljs-function">)</span> {                   <span class="hljs-comment">//(5)</span>
      serilogFixture = fixture;                                     <span class="hljs-comment">//(6)</span>
      datastore = <span class="hljs-keyword">new</span> MockDataStore();
      serilogFixture.Logger.Debug(<span class="hljs-string">"DataStoreTests: Created"</span>);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Add_Item</span><span class="hljs-function">() ...</span>
<span class="hljs-function">  ...</span>
<span class="hljs-function">}</span>
</code></pre>
<p class="normal">If we want to <a id="_idIndexMarker872"/>use class fixtures, we can create them using the following steps:</p>
<ul>
<li class="bulletList">We can create a new class as the fixture class and add the setup code to the constructor. Here, we created a fixture class, <code class="inlineCode">SerilogFixture</code>, <strong class="keyWord">(1)</strong>, and initialized the <code class="inlineCode">ILogger</code> interface, <strong class="keyWord">(2)</strong>, in the constructor.</li>
<li class="bulletList">Because we need to clean up the setup after the test case execution, we need to implement the <code class="inlineCode">IDisposable</code> interface for the fixture class and put the cleanup code in the <code class="inlineCode">Dispose</code> method. We implemented <code class="inlineCode">IDisposable</code> in <code class="inlineCode">SerilogFixture</code> and called the <code class="inlineCode">Serilog</code> function, <code class="inlineCode">Log.CloseAndFlush</code>, <strong class="keyWord">(3)</strong>, in the <code class="inlineCode">Dispose</code> method.</li>
<li class="bulletList">To use the fixture, the test case needs to implement the <code class="inlineCode">IClassFixture&lt;T&gt;</code> interface. We implemented this in the <code class="inlineCode">DataStoreTests</code> test class, <strong class="keyWord">(4)</strong>.</li>
<li class="bulletList">To access the fixture instance, we can add it as a constructor argument and it will be provided automatically. In the constructor of <code class="inlineCode">DataStoreTests</code>, <strong class="keyWord">(5)</strong>, we assign the argument to the private member variable, <code class="inlineCode">serilogFixture</code>, <strong class="keyWord">(6)</strong>. In test cases, we can access <code class="inlineCode">Serilog</code> using this variable.</li>
</ul>
<p class="normal">To verify <a id="_idIndexMarker873"/>this setup, we replaced all our debug output with <code class="inlineCode">Serilog</code> <code class="inlineCode">Debug</code>. After executing the tests in <code class="inlineCode">DataStoreTests</code>, we can see the log messages here in the <code class="inlineCode">xunit_log.txt</code> log file:</p>
<pre class="programlisting con"><code class="hljs-con">2022-08-28 10:25:39.273 +08:00 [DBG] SerilogFixture: initialized
2022-08-28 10:25:39.332 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.350 +08:00 [DBG] Delete_Item: Entry01
2022-08-28 10:25:39.355 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.355 +08:00 [DBG] Delete_Item: Group01
2022-08-28 10:25:39.356 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.357 +08:00 [DBG] Delete_Item: PxEntry01
2022-08-28 10:25:39.358 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.358 +08:00 [DBG] Delete_Item: Notes01
2022-08-28 10:25:39.359 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.359 +08:00 [DBG] Create_Item: PxEntry
2022-08-28 10:25:39.360 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.360 +08:00 [DBG] Create_Item: Group
2022-08-28 10:25:39.361 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.361 +08:00 [DBG] Create_Item: Entry
2022-08-28 10:25:39.362 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.362 +08:00 [DBG] Create_Item: Notes
2022-08-28 10:25:39.362 +08:00 [DBG] DataStoreTests: Created
2022-08-28 10:25:39.364 +08:00 [DBG] Add_Item: Done
2022-08-28 10:25:39.367 +08:00 [DBG] SerilogFixture: closed
</code></pre>
<p class="normal">As anticipated, the <code class="inlineCode">SerilogFixture</code> class is initialized only once, allowing its instance to be utilized in all tests within <code class="inlineCode">DataStoreTests</code>. This is in contrast to the <code class="inlineCode">IDataStore</code> interface, which is initialized for each individual test.</p>
<h3 class="heading-3" id="_idParaDest-298">Sharing using collection fixtures</h3>
<p class="normal">Utilizing <a id="_idIndexMarker874"/>class fixtures, as demonstrated in the previous section, allows us to share the test setup context within a single test class. However, there may be instances where we need to share the test setup across multiple test classes. In such cases, we can employ collection fixtures to achieve this.</p>
<p class="normal">In the case of <code class="inlineCode">Serilog</code>, we can utilize it across multiple test classes, allowing us to view all log messages in a single log file. To achieve a unified <code class="inlineCode">Serilog</code> setup for all test classes, we can implement collection fixtures in our project. By employing collection fixtures, we can create two new classes, <code class="inlineCode">SerilogFixture</code> and <code class="inlineCode">SerilogCollection</code>, within the <code class="inlineCode">PassXYZ.Vault.Tests</code> project, as demonstrated in <em class="italic">Listing 11.1</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Tests</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerilogFixture</span> : <span class="hljs-title">IDisposable</span> {
  <span class="hljs-keyword">public</span> ILogger Logger { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span>; }
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">SerilogFixture</span><span class="hljs-function">()</span> {
      Logger = <span class="hljs-keyword">new</span> LoggerConfiguration()
          .MinimumLevel.Debug()
          .WriteTo.File(<span class="hljs-string">@"logs\xunit_log.txt"</span>)
          .CreateLogger();
      Logger.Debug(<span class="hljs-string">"SerilogFixture: initialized"</span>);
  }
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Dispose</span><span class="hljs-function">()</span> {
      Logger.Debug(<span class="hljs-string">"SerilogFixture: closed"</span>);
      Log.CloseAndFlush();
  }
}
[<span class="hljs-meta">CollectionDefinition(</span><span class="hljs-string">"</span><span class="hljs-string">Serilog collection"</span><span class="hljs-meta">)</span>]                       <span class="hljs-comment">//(1)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SerilogCollection</span>:<span class="hljs-title">ICollectionFixture</span>&lt;<span class="hljs-title">SerilogFixture</span>&gt;
{
}                                                                  <span class="hljs-comment">//(2)</span>
</code></pre>
<p class="packt_figref">Listing 11.1: <code class="inlineCode">SerilogFixture.cs</code> (<a href="https://epa.ms/SerilogFixture11-1"><span class="url">https://epa.ms/SerilogFixture11-1</span></a>)</p>
<p class="normal">To <a id="_idIndexMarker875"/>implement collection fixtures, we can follow the steps outlined below:</p>
<ul>
<li class="bulletList">Create a new class file, <code class="inlineCode">SerilogFixture.cs</code>, that houses both the <code class="inlineCode">SerilogFixture</code> and <code class="inlineCode">SerilogCollection</code> classes.</li>
<li class="bulletList">Decorate the collection definition class, <code class="inlineCode">SerilogCollection</code>, with the <code class="inlineCode">[CollectionDefinition]</code> attribute <strong class="keyWord">(1)</strong> and assign it a unique name to help identify the test collection.</li>
<li class="bulletList">Ensure that the collection definition class, <code class="inlineCode">SerilogCollection</code>, implements the <code class="inlineCode">ICollectionFixture&lt;T&gt;</code> interface <strong class="keyWord">(2)</strong>.</li>
</ul>
<p class="normal">To utilize a collection fixture, we can implement the following modifications to our test classes:</p>
<ul>
<li class="bulletList">We can attach the <code class="inlineCode">[Collection]</code> attribute to all test classes that will be incorporated into the collection. We designate <code class="inlineCode">Serilog collection</code> as the name for the test collection definition within the attribute. In our case, as displayed in <em class="italic">Listing 11.2</em>, we append a <code class="inlineCode">[Collection("Serilog collection")]</code> attribute <strong class="keyWord">(1)</strong> to the <code class="inlineCode">DataStoreTests</code> class.</li>
<li class="bulletList">To access the fixture instance, we can follow the same approach as in the previous section with class fixtures by including it as a constructor argument. It will then be provided automatically. In the <code class="inlineCode">DataStoreTests</code> constructor, we assign a <code class="inlineCode">fixture</code> argument to the <code class="inlineCode">serilogFixture</code> variable <strong class="keyWord">(2)</strong>.</li>
<li class="bulletList">In order to <a id="_idIndexMarker876"/>save space, the full code is not provided in <em class="italic">Listing 11.2</em>. The absent parts are indicated with the “...” symbol. The <code class="inlineCode">Add_Item</code> test case was constructed using <code class="inlineCode">Fact</code> to examine the creation of an entry. The <code class="inlineCode">Create_Item</code> and <code class="inlineCode">Delete_Item</code> test cases both employ <code class="inlineCode">Theory</code>, enabling us to test a variety of items.</li>
</ul>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Tests</span>;
[<span class="hljs-meta">Collection(</span><span class="hljs-string">"Serilog collection"</span><span class="hljs-meta">)</span>]                                 <span class="hljs-comment">//(1)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DataStoreTests</span> {
  IDataStore&lt;Item&gt; datastore;
  SerilogFixture serilogFixture;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">DataStoreTests</span><span class="hljs-function">(</span><span class="hljs-params">SerilogFixture fixture</span><span class="hljs-function">)</span> {
    datastore = <span class="hljs-keyword">new</span> MockDataStore();
    serilogFixture = fixture;                                      <span class="hljs-comment">//(2)</span>
    serilogFixture.Logger.Debug(<span class="hljs-string">"DataStoreTests</span>
<span class="hljs-string">      initialized"</span>);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Add_Item</span><span class="hljs-function">()</span> {
    <span class="hljs-comment">// Arrange</span>
    ItemSubType itemSubType = ItemSubType.Entry;
    <span class="hljs-comment">// Act</span>
    <span class="hljs-keyword">var</span> newItem = datastore.CreateNewItem(itemSubType);
    newItem.Name = <span class="hljs-string">$"</span><span class="hljs-subst">{itemSubType.ToString()}</span><span class="hljs-string">01"</span>;
    <span class="hljs-keyword">await</span> datastore.AddItemAsync(newItem);
    <span class="hljs-keyword">var</span> item = datastore.GetItem(newItem.Id);
    <span class="hljs-comment">// Assert</span>
    Assert.Equal(newItem.Id, item.Id);
    serilogFixture.Logger.Debug(<span class="hljs-string">"Add_Item done"</span>);
  }
  [<span class="hljs-meta">Theory</span>]
  [<span class="hljs-meta">InlineData(ItemSubType.Entry)</span>]
  [<span class="hljs-meta">InlineData(ItemSubType.Group)</span>]
  [<span class="hljs-meta">InlineData(ItemSubType.Notes)</span>]
  [<span class="hljs-meta">InlineData(ItemSubType.PxEntry)</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Delete_Item</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType itemSubType</span><span class="hljs-function">)...</span>
<span class="hljs-function">  [Theory]</span>
<span class="hljs-function">  [</span><span class="hljs-title">InlineData</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType.Entry</span><span class="hljs-function">)]</span>
<span class="hljs-function">  [</span><span class="hljs-title">InlineData</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType.Group</span><span class="hljs-function">)]</span>
<span class="hljs-function">  [</span><span class="hljs-title">InlineData</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType.Notes</span><span class="hljs-function">)]</span>
<span class="hljs-function">  [</span><span class="hljs-title">InlineData</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType.PxEntry</span><span class="hljs-function">)]</span>
<span class="hljs-function">  </span><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Create_Item</span><span class="hljs-function">(</span><span class="hljs-params">ItemSubType itemSubType</span><span class="hljs-function">) ...</span>
<span class="hljs-function">}</span>
</code></pre>
<p class="packt_figref">Listing 11.2: <code class="inlineCode">DataStoreTests.cs</code> (<a href="https://epa.ms/DataStoreTests11-2"><span class="url">https://epa.ms/DataStoreTests11-2</span></a>)</p>
<p class="normal">Through<a id="_idIndexMarker877"/> these examples, we have demonstrated how to create unit tests in the model layer. The knowledge we have acquired thus far can also be applied to unit testing in other .NET applications.</p>
<p class="normal">Having concluded the introduction to the model layer unit testing, we will proceed to explore the Razor component unit testing using the bUnit library in the next part of this chapter.</p>
<h1 class="heading-1" id="_idParaDest-299">Mock .NET MAUI components</h1>
<p class="normal">In developing <a id="_idIndexMarker878"/>unit tests for .NET MAUI, we will present test case development for both XAML-based and Blazor-based apps. In both instances, we will incorporate the MVVM pattern in the design. The unit test cases at the model layer are identical for both; however, testing the view and the view model differs significantly. Developing unit test cases for the view and the view model in a XAML-based app can be quite complex. To test the view model, it is necessary to resolve the dependencies of XAML components. For instance, in the XAML version of our app, we need to invoke <code class="inlineCode">Shell</code> navigation methods within the view model, as demonstrated in the following code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">await</span> Shell.Current.GoToAsync(
  <span class="hljs-string">$"</span><span class="hljs-subst">{</span><span class="hljs-keyword">nameof</span><span class="hljs-subst">(ItemsPage)}</span><span class="hljs-string">?</span><span class="hljs-subst">{</span><span class="hljs-keyword">nameof</span><span class="hljs-subst">(ItemsViewModel.ItemId)}</span><span class="hljs-string">=</span><span class="hljs-subst">{item</span>
<span class="hljs-subst">  .Id}</span><span class="hljs-string">"</span>);
</code></pre>
<p class="normal">To address dependencies in <code class="inlineCode">Xamarin.Forms</code>, an open-source project, <code class="inlineCode">Xamarin.Forms.Mocks</code>, is available to help mock <code class="inlineCode">Xamarin.Forms</code> components. In the case of .NET MAUI XAML apps, we require a similar solution for developing unit test cases for the view model, but currently, an equivalent does not seem to exist. Furthermore, there is a native user interface test framework, <code class="inlineCode">Xamarin.UITest</code>, specifically for Android and iOS. However, it is not yet compatible with .NET MAUI. Additionally, since <code class="inlineCode">Xamarin.UITest</code> is not a cross-platform solution, it will not be discussed in this book.</p>
<p class="normal">To <a id="_idIndexMarker879"/>partially address the dependency issue related to the view model test in this book, we can reference the .NET MAUI source code directly. Found at <a href="https://github.com/dotnet/maui"><span class="url">https://github.com/dotnet/maui</span></a>, this source code includes the original unit test code containing mock .NET MAUI components.</p>
<p class="normal">I have incorporated some elements from the .NET MAUI source code into the unit test project <code class="inlineCode">PassXYZ.Vault.Tests</code>. To resolve the <code class="inlineCode">Shell</code> navigation issue in the view model, the following code from <code class="inlineCode">PassXYZ.Vault.Tests/maui/ShellTestBase.cs</code> is included:</p>
<ul>
<li class="bulletList">In the <code class="inlineCode">NewItemViewModel </code>tests, we can incorporate the <code class="inlineCode">ShellTestBase</code> class with the following namespace:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">using</span> Microsoft.Maui.Controls.Core.UnitTests;
</code></pre>
</li>
<li class="bulletList">After implementing the namespace above, a mock <code class="inlineCode">Shell</code> can be created using the following code:
        <pre class="programlisting code"><code class="hljs-code">TestShell shell = <span class="hljs-keyword">new</span> TestShell();
</code></pre>
</li>
<li class="bulletList">Once we have a mock <code class="inlineCode">Shell</code> instance, we can use this mock <code class="inlineCode">Shell</code> instance in the following test case:
        <pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">Fact</span>]
<span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">async</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">CancelNewItem</span><span class="hljs-function">()</span>  {
NewItemViewModel vm = <span class="hljs-keyword">new</span>(dataStore, logger);
<span class="hljs-keyword">await</span> shell.GoToAsync(<span class="hljs-string">"//About/Maui/"</span>);
vm.CancelCommand.Execute(<span class="hljs-literal">null</span>);
Assert.Equal(<span class="hljs-string">"//About/Maui/content"</span>, Shell.Current.CurrentState.Location.ToString());
}
</code></pre>
</li>
</ul>
<p class="normal">For a Blazor Hybrid app, we don’t have the above issue. We have access to a reliable testing library called bUnit, which can be utilized for testing Razor components. This allows us to develop unit test cases for the view, view model, and model layers for Blazor apps.</p>
<h1 class="heading-1" id="_idParaDest-300">Razor component testing using bUnit</h1>
<p class="normal">In .NET MAUI development, we <a id="_idIndexMarker880"/>cannot create unit test cases for all view and view model layers in XAML-based UI components; however, this is possible with Blazor. bUnit is an exceptional test library that can be employed for developing unit tests for Razor components. The bUnit library facilitates the creation of unit test cases for Razor components using xUnit, NUnit, or MSTest. Throughout the remainder of this chapter, we will utilize xUnit in conjunction with bUnit. The structure of unit test cases using bUnit bears similarity to the xUnit test cases we discussed in the previous section.</p>
<p class="normal">In the remainder of this chapter, we will focus on testing the following Razor components, which were created in the second part of this book:</p>
<ul>
<li class="bulletList">Razor components in the <code class="inlineCode">PassXYZ.BlazorUI</code> project</li>
<li class="bulletList">Razor components in the <code class="inlineCode">PassXYZ.Vault</code> project</li>
</ul>
<p class="normal">To test Razor components using bUnit, it is necessary to modify the project configuration of <code class="inlineCode">PassXYZ.Vault.Tests</code>.</p>
<h2 class="heading-2" id="_idParaDest-301">Changing the project configuration for bUnit</h2>
<p class="normal">To <a id="_idIndexMarker881"/>establish the test environment, we must add the bUnit and Moq packages, as well as updating the SDK type. The following modifications can be made to the xUnit <code class="inlineCode">PassXYZ.Vault.Tests</code> testing project:</p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1">Add bUnit to the project.
    <p class="normal">To incorporate the bUnit library into the project, first navigate to the project folder, then execute the following command from a console:</p>
<pre class="programlisting con"><code class="hljs-con">cd PassXYZ.Vault.Tests
dotnet add package bunit
</code></pre>
<p class="normal">Additionally, we need to include the Moq package, which is a mocking library that will be utilized during the test setup process.</p>
<pre class="programlisting con"><code class="hljs-con">dotnet add package Moq
</code></pre></li>
</ol>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="2">Change the project configuration.
    <p class="normal">To test the Razor components, we also need to change the project’s SDK to <code class="inlineCode">Microsoft.NET.Sdk.Razor</code>.</p>
<p class="normal">In the <code class="inlineCode">PassXYZ.Vault.Tests.csproj</code> project file, we need to replace the following line:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Project</span><span class="hljs-tag"> </span><span class="hljs-attr">Sdk</span><span class="hljs-tag">=</span><span class="hljs-string">"Microsoft.NET.Sdk"</span><span class="hljs-tag">&gt;</span>
</code></pre>
<p class="normal">with</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-tag">&lt;</span><span class="hljs-name">Project</span><span class="hljs-tag"> </span><span class="hljs-attr">Sdk</span><span class="hljs-tag">=</span><span class="hljs-string">"Microsoft.NET.Sdk.Razor"</span><span class="hljs-tag">&gt;</span>
</code></pre></li>
</ol>
<p class="normal">Once we<a id="_idIndexMarker882"/> have the project configuration ready, we can create a simple unit test case using bUnit to test our Razor components.</p>
<h2 class="heading-2" id="_idParaDest-302">Creating a bUnit test case</h2>
<p class="normal">In our <a id="_idIndexMarker883"/>PassXYZ.Vault app, there are two types of Razor components that can be tested. The shared Razor components <a id="_idIndexMarker884"/>are located in the <code class="inlineCode">PassXYZ.BlazorUI</code> project and serve as generic Razor components, which can be utilized across different projects. The second set of Razor components can be found in the <code class="inlineCode">Pages</code> folder of the <code class="inlineCode">PassXYZ.Vault</code> project. These components are specific to the <code class="inlineCode">PassXYZ.Vault</code> app and make use of shared components from the <code class="inlineCode">PassXYZ.BlazorUI</code> project.</p>
<p class="normal">To test the Razor components within the <code class="inlineCode">PassXYZ.BlazorUI</code> project, we can examine each component individually. These test cases are unit test cases. The Razor components located in the <code class="inlineCode">Pages</code> folder of the <code class="inlineCode">PassXYZ.Vault</code> project serve as UI pages. Since these pages utilize UI components from other packages, they possess more dependencies. Consequently, these test cases can be regarded as integration test cases.</p>
<p class="normal">To begin, let’s first create a test case for the <code class="inlineCode">ModalDialog</code> Razor component in the <code class="inlineCode">PassXYZ.BlazorUI</code> project. To test <code class="inlineCode">ModalDialog</code>, we can generate an xUnit test class called <code class="inlineCode">ModalDialogTests</code>, as illustrated in <em class="italic">Listing 11.3</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Tests</span> {
  [<span class="hljs-meta">Collection(</span><span class="hljs-string">"Serilog collection"</span><span class="hljs-meta">)</span>]
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ModalDialogTests</span> : <span class="hljs-title">TestContext</span> {                     <span class="hljs-comment">//(1)</span>
    SerilogFixture serilogFixture;
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ModalDialogTests</span><span class="hljs-function">(</span><span class="hljs-params">SerilogFixture serilogFixture</span><span class="hljs-function">)</span> {
      <span class="hljs-keyword">this</span>.serilogFixture = serilogFixture;
    }
    [<span class="hljs-meta">Fact</span>]
    <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">ModalDialogInitTest</span><span class="hljs-function">()</span> {
      <span class="hljs-built_in">string</span> title = <span class="hljs-string">"ModalDialog Test"</span>;                            <span class="hljs-comment">//(2)</span>
      <span class="hljs-keyword">var</span> cut = RenderComponent&lt;ModalDialog&gt;(                       <span class="hljs-comment">//(3)</span>
        parameters =&gt; parameters.Add(p =&gt; p.Title, title)           <span class="hljs-comment">//(4)</span>
        .Add(p =&gt; p.CloseButtonText, <span class="hljs-string">"Close"</span>)
        .Add(p =&gt; p.SaveButtonText, <span class="hljs-string">"Save"</span>));
      cut.Find(<span class="hljs-string">"h5"</span>).TextContent.MarkupMatches(title);              <span class="hljs-comment">//(5)</span>
      serilogFixture.Logger.Debug(<span class="hljs-string">"ModalDialogInitTest:</span>
<span class="hljs-string">        done"</span>);
    }
    ...
  }
}
</code></pre>
<p class="packt_figref">Listing 11.3: <code class="inlineCode">ModalDialogTests.cs</code> (<a href="https://epa.ms/ModalDialogTests11-3"><span class="url">https://epa.ms/ModalDialogTests11-3</span></a>)</p>
<p class="normal">As <a id="_idIndexMarker885"/>seen in the <code class="inlineCode">ModalDialogTests</code> unit test class, it bears a strong resemblance to the unit test class created for the <a id="_idIndexMarker886"/>model layer. We reuse the collection fixture established earlier and initialize it in the constructor. In the <code class="inlineCode">ModalDialogInitTest</code> test case, we continue to employ the <code class="inlineCode">Arrange</code>, <code class="inlineCode">Act</code>, and <code class="inlineCode">Assert</code> pattern for the implementation of the test case.</p>
<p class="normal">All bUnit test classes inherit from <code class="inlineCode">TestContext</code> <strong class="keyWord">(1)</strong>. During the <code class="inlineCode">Arrange</code> phase, we initialize a local <code class="inlineCode">title</code> variable, <strong class="keyWord">(2)</strong>, with a predefined string. In the <code class="inlineCode">Act</code> phase, we call a generic method, <code class="inlineCode">RenderComponent&lt;T&gt;</code>, <strong class="keyWord">(3)</strong>, and use the <code class="inlineCode">ModalDialog</code> type as the type parameter. We pass the <code class="inlineCode">title</code> variable, <strong class="keyWord">(4)</strong>, as the component parameter. The outcome of <code class="inlineCode">RenderComponent&lt;T&gt;</code> is stored in the <code class="inlineCode">cut</code> variable. In the <code class="inlineCode">Assert</code> phase, we confirm that the title text after rendering is consistent with the argument we pass, utilizing the bUnit method <code class="inlineCode">Find</code> <strong class="keyWord">(5)</strong>. The bUnit method <code class="inlineCode">Find</code> can be used to find any HTML tag. In <code class="inlineCode">ModalDialog</code>, the title is rendered as an <code class="inlineCode">&lt;h5&gt;</code> HTML tag.</p>
<p class="normal">In the <code class="inlineCode">ModalDialogInitTest</code> test case, we observe the structure of the bUnit tests. For bUnit tests, we first render the component being tested. The rendering outcome is stored in the <code class="inlineCode">cut</code> variable, <strong class="keyWord">(3)</strong> which is an instance of the <code class="inlineCode">IRenderedComponent</code> interface. To verify the result, we can refer to the properties or invoke the methods of the <code class="inlineCode">IRenderedComponent</code> instance.</p>
<p class="normal">When Razor components are rendered in the <code class="inlineCode">TestContext</code>, they exhibit the same lifecycle as any other Razor component. We can pass parameters to the components being tested, and they can generate output akin to their behavior in a browser.</p>
<p class="normal">In the preceding <a id="_idIndexMarker887"/>example, when rendering the <code class="inlineCode">ModalDialog</code> component, we can pass component parameters to it using the <code class="inlineCode">Add</code> method, which belongs to the parameter builder of the <code class="inlineCode">ComponentParameterCollectionBuilder&lt;TComponent&gt;</code> type.</p>
<p class="normal">Rendering<a id="_idIndexMarker888"/> simple components using C# code may not pose a problem. However, when passing multiple parameters to a component, using C# code can be inconvenient. By employing bUnit, we can develop test cases in Razor files, which significantly improves the experience of unit test development.</p>
<h2 class="heading-2" id="_idParaDest-303">Creating test cases in Razor files</h2>
<p class="normal">To<a id="_idIndexMarker889"/> create tests directly in Razor markup files, we can declare components using Razor markup, similar to how we utilize them within a Razor page. This approach eliminates the need to call Razor components in the C# code or pass parameters using function calls. For a Razor page, we can render Razor components using <strong class="keyWord">Razor templates</strong>.</p>
<p class="normal">We can illustrate the process of creating tests in Razor markup files by developing test cases for a more complex <code class="inlineCode">EditorDialog</code> component. We previously created the <code class="inlineCode">EditorDialog</code> component in <em class="chapterRef">Chapter 10</em>, <em class="italic">Implementing Razor Components</em>. In <em class="italic">Listing 11.4</em>, we will examine the unit tests for this component:</p>
<pre class="programlisting code"><code class="hljs-code">@inherits TestContext                                               <span class="hljs-comment">//(1)</span>
&lt;h3&gt;EditorDialogTests&lt;/h3&gt;
@code {
  <span class="hljs-built_in">bool</span> _isOnCloseClicked = <span class="hljs-literal">false</span>;
  <span class="hljs-built_in">string</span> _key = <span class="hljs-built_in">string</span>.Empty;
  <span class="hljs-built_in">string</span> _value = <span class="hljs-built_in">string</span>.Empty;
  <span class="hljs-built_in">string</span> updated_key = <span class="hljs-string">"key updated"</span>;
  <span class="hljs-built_in">string</span> updated_value = <span class="hljs-string">"value udpated"</span>;
  <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnSaveClicked</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> key, </span><span class="hljs-built_in">string</span><span class="hljs-params"> </span><span class="hljs-keyword">value</span><span class="hljs-function">)</span> {
    _key = key; _value = <span class="hljs-keyword">value</span>;
  }
  <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnCloseHandler</span><span class="hljs-function">()</span> {
    _isOnCloseClicked = <span class="hljs-literal">true</span>;
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">EditorDialog_Init_WithoutArgument</span><span class="hljs-function">() ...</span>
<span class="hljs-function">  [Fact]</span>
<span class="hljs-function">  </span><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Edit_OnClose_Clicked</span><span class="hljs-function">()</span> {
    <span class="hljs-keyword">var</span> cut = Render(@&lt;EditorDialog Key=<span class="hljs-string">"@_key"</span>
                                    Value=<span class="hljs-string">"@_value"</span> 
                                    OnSave=@OnSaveClicked
                                    OnClose=@OnCloseHandler&gt;
                     &lt;/EditorDialog&gt;);                              <span class="hljs-comment">//(2)</span>
    cut.Find(<span class="hljs-string">"button[class='btn btn-secondary']"</span>).Click();          <span class="hljs-comment">//(3)</span>
    Assert.True(_isOnCloseClicked);                                 <span class="hljs-comment">//(4)</span>
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Edit_With_KeyEditingEnabled</span><span class="hljs-function">()</span> {                       <span class="hljs-comment">//(5)</span>
     <span class="hljs-keyword">var</span> cut = Render(@&lt;EditorDialog Key=<span class="hljs-string">"@_key"</span>
                                     Value=<span class="hljs-string">"@_value"</span>
                                     IsKeyEditingEnable=<span class="hljs-string">"true"</span> 
                                     OnSave=@OnSaveClicked&gt;
                      &lt;/EditorDialog&gt;);
    cut.Find(<span class="hljs-string">"input"</span>).Change(updated_key);
    cut.Find(<span class="hljs-string">"textarea"</span>).Change(updated_value);
    cut.Find(<span class="hljs-string">"button[type=submit]"</span>).Click();
    Assert.Equal(_key, updated_key);
    Assert.Equal(_value, updated_value);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Edit_With_KeyEditingDisabled</span><span class="hljs-function">() ...</span>
<span class="hljs-function">}</span>
</code></pre>
<p class="packt_figref">Listing 11.4: <code class="inlineCode">EditorDialogTests.razor</code> (<a href="https://epa.ms/EditorDialogTests11-4"><span class="url">https://epa.ms/EditorDialogTests11-4</span></a>)</p>
<p class="normal">We<a id="_idIndexMarker890"/> can develop a new Razor component, called <code class="inlineCode">EditorDialogTests</code>, within the <code class="inlineCode">PassXYZ.Vault.Tests</code> project. As it serves as a bUnit test class, it is a child class of <code class="inlineCode">TestContext</code> <strong class="keyWord">(1)</strong>. Within this class, we generate test cases in a code block by utilizing <strong class="keyWord">Razor templates</strong>.</p>
<p class="normal">Let’s first examine the <code class="inlineCode">Edit_OnClose_Clicked</code> test case. In this scenario, we initially render the <code class="inlineCode">EditorDialog</code> component and then proceed to test the close button.</p>
<p class="normal">To render the <code class="inlineCode">EditorDialog</code> component, we invoke the <code class="inlineCode">Render</code> method <strong class="keyWord">(2)</strong> of <code class="inlineCode">TestContext</code>. Compared to the previous example, in this case, we can render the Razor markup directly rather than calling the C# function. The Razor markup utilized here is referred to as <strong class="keyWord">Razor templates</strong>. For more information about Razor templates, refer to the following Microsoft documentation: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1"><span class="url">https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-5.0#razor-templates-1</span></a>.</p>
<p class="normal"><code class="inlineCode">Razor templates</code> can be defined in the following format:</p>
<pre class="programlisting code"><code class="hljs-code">@<span class="hljs-attribute">&lt;{HTML tag}&gt;</span>…<span class="hljs-attribute">&lt;/{HTML tag}&gt;</span>
</code></pre>
<p class="normal">It consists of an <code class="inlineCode">@</code> symbol and a pair of open and closed HTML tags. Razor templates can be used in the code block of the Razor file. They cannot be used in a C# or C# code-behind file.</p>
<p class="normal">Employing<a id="_idIndexMarker891"/> this format, we can designate a snippet of Razor markup as the parameter for a C# function. This Razor markup snippet represents a Razor template, and its data type is either <code class="inlineCode">RenderFragment</code> or <code class="inlineCode">RenderFragment&lt;TValue&gt;</code>. In <em class="italic">Listing 11.4</em>, we use Razor templates to pass parameters to the <code class="inlineCode">EditorDialog</code>, as demonstrated in the subsequent code:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">var</span> cut = Render(@&lt;EditorDialog Key=<span class="hljs-string">"</span><span class="hljs-variable">@_key</span><span class="hljs-string">"</span>
Value=<span class="hljs-string">"</span><span class="hljs-variable">@_value</span><span class="hljs-string">"</span> OnSave=<span class="hljs-variable">@OnSaveClicked</span>
OnClose=<span class="hljs-variable">@OnCloseHandler</span>&gt;
                  &lt;/EditorDialog&gt;);
</code></pre>
<p class="normal">After <code class="inlineCode">EditorDialog</code> is rendered, we can find the close button and simulate the click action, <strong class="keyWord">(3)</strong>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">cut</span>.<span class="hljs-built_in">Find</span>(<span class="hljs-string">"button[class='btn btn-secondary']"</span>).Click();
</code></pre>
<p class="normal">In the <code class="inlineCode">OnCloseHandler</code> event handler, the <code class="inlineCode">_isOnCloseClicked</code> variable, <strong class="keyWord">(4)</strong>, is set to <code class="inlineCode">true</code> so that we can assert the result.</p>
<p class="normal">In the <code class="inlineCode">Edit_With_KeyEditingEnabled</code> test case, <strong class="keyWord">(5)</strong>, after the component is rendered, we can simulate user interactions to set the key and value fields in the component. After that, we can simulate clicking on the save button as we can see here:</p>
<pre class="programlisting code"><code class="hljs-code">    <span class="hljs-built_in">cut</span>.<span class="hljs-built_in">Find</span>(<span class="hljs-string">"input"</span>).Change(updated_key);
    <span class="hljs-built_in">cut</span>.<span class="hljs-built_in">Find</span>(<span class="hljs-string">"</span><span class="hljs-string">textarea"</span>).Change(updated_value);
    <span class="hljs-built_in">cut</span>.<span class="hljs-built_in">Find</span>(<span class="hljs-string">"button[type=submit]"</span>).Click();
</code></pre>
<p class="normal">Upon clicking the button, the event handler is triggered. Within the <code class="inlineCode">OnSaveClicked</code> event handler, we receive the modified key and value, enabling us to assert the result.</p>
<pre class="programlisting code"><code class="hljs-code">    <span class="hljs-built_in">Assert</span><span class="hljs-operator">.</span><span class="hljs-built_in">Equal</span><span class="h js-punctuation">(</span><span class="hljs-type">_key</span><span class="hljs-operator">,</span> <span class="hljs-type">updated_key</span><span class="h js-punctuation">)</span><span class="hljs-operator">;</span>
    <span class="hljs-built_in">Assert</span><span class="hljs-operator">.</span><span class="hljs-built_in">Equal</span><span class="h js-punctuation">(</span><span class="hljs-type">_value</span><span class="hljs-operator">,</span> <span class="hljs-type">updated_value</span><span class="h js-punctuation">)</span><span class="hljs-operator">;</span>
</code></pre>
<p class="normal">As evidenced by these two test cases, designing bUnit tests becomes more straightforward when creating tests within a Razor file. By utilizing Razor templates, we can render components and also simulate various user interactions, enabling us to test the components interactively.</p>
<p class="normal">Razor templates serve as an excellent tool for combining Razor markup and C# code, allowing<a id="_idIndexMarker892"/> us to benefit from the strengths of both approaches. However, there are certain limitations when using Razor templates. In the next section, we will explore how to overcome these constraints.</p>
<h2 class="heading-2" id="_idParaDest-304">Using the RenderFragment delegate</h2>
<p class="normal">Although<a id="_idIndexMarker893"/> Razor templates can help to simplify test setups, they have their limitations, especially in complex<a id="_idIndexMarker894"/> test case scenarios. With intricate test cases, Razor templates can become quite lengthy. If we intend to reuse the same Razor templates in another test case, we would need to copy them, potentially resulting in a significant amount of duplicated code. This is one of the main drawbacks of using Razor templates.</p>
<p class="normal">In this case, we can use a <code class="inlineCode">RenderFragment</code> delegate. As its name indicates, it is the delegate type of <code class="inlineCode">RenderFragment</code> or <code class="inlineCode">RenderFragment&lt;TValue&gt;</code>. The data type of Razor templates is <code class="inlineCode">RenderFragment</code> or <code class="inlineCode">RenderFragment&lt;TValue&gt;</code>. A <code class="inlineCode">RenderFragment</code> delegate is the delegate type for Razor templates.</p>
<p class="normal">You can find more information about the <code class="inlineCode">RenderFragment</code> delegate in the following Microsoft document: <a href="https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragments-in-code-2"><span class="url">https://learn.microsoft.com/en-us/aspnet/core/blazor/performance?view=aspnetcore-3.1#define-reusable-renderfragments-in-code-2</span></a>.</p>
<p class="normal">To demonstrate how to use the <code class="inlineCode">RenderFragment</code> delegate, let’s set up a more complex test for the <code class="inlineCode">EditorDialog</code> component. <code class="inlineCode">EditorDialog</code> can be used to edit either <code class="inlineCode">Item</code> or <code class="inlineCode">Field</code>. We can use an item-editing case to show how to use the <code class="inlineCode">RenderFragment</code> delegate.</p>
<p class="normal">We have the option to create a new test class, <code class="inlineCode">ItemEditTests</code>, within the <code class="inlineCode">PassXYZ.Vault.Tests</code> project. To differentiate the Razor markup and C# code, we can divide the <code class="inlineCode">ItemEditTests</code> test class into a Razor file (<code class="inlineCode">ItemEditTests.razor</code>) and a C# code-behind file (<code class="inlineCode">ItemEditTests.razor.cs</code>). The markup designated for testing can be declared in the Razor file, as demonstrated in <em class="italic">Listing 11.5</em>:</p>
<pre class="programlisting code"><code class="hljs-code">@inherits TestContext
@namespace PassXYZ.Vault.Tests
<span class="hljs-tag">&lt;</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>ItemEditTests<span class="hljs-tag">&lt;/</span><span class="hljs-name">h3</span><span class="hljs-tag">&gt;</span>
@code {
  private RenderFragment _editorDialog =&gt; __builder =&gt;
  {
    <span class="hljs-tag">&lt;</span><span class="hljs-name">CascadingValue</span><span class="hljs-tag"> </span><span class="hljs-attr">Value</span><span class="hljs-tag">=</span><span class="hljs-string">"@_dialogId"</span><span class="hljs-tag"> </span><span class="hljs-attr">Name</span><span class="hljs-tag">=</span><span class="hljs-string">"Id"</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;</span><span class="hljs-name">EditorDialog</span><span class="hljs-tag"> </span><span class="hljs-attr">IsKeyEditingEnable</span><span class="hljs-tag">=</span><span class="hljs-string">@isNewItem</span>
<span class="hljs-tag">    </span><span class="hljs-attr">OnSave</span><span class="hljs-tag">=</span><span class="hljs-string">@OnSaveClicked</span><span class="hljs-tag"> </span><span class="hljs-attr">Key</span><span class="hljs-tag">=</span><span class="hljs-string">@testItem.Name</span>
<span class="hljs-tag">    </span><span class="hljs-attr">Value</span><span class="hljs-tag">=</span><span class="hljs-string">@testItem.Notes</span><span class="hljs-tag">&gt;</span>
      @if (isNewItem) {
        <span class="hljs-tag">&lt;</span><span class="hljs-name">select</span><span class="hljs-tag"> </span><span class="hljs-attr">id</span><span class="hljs-tag">=</span><span class="hljs-string">"itemType"</span><span class="hljs-tag"> @</span><span class="hljs-attr">bind</span><span class="hljs-tag">=</span><span class="hljs-string">"testItem.ItemType"</span>
<span class="hljs-tag">          </span><span class="hljs-attr">class</span><span class="hljs-tag">=</span><span class="hljs-string">"form-select"</span><span class="hljs-tag"> </span><span class="hljs-attr">aria-label</span><span class="hljs-tag">=</span><span class="hljs-string">"Group"</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-name">option</span><span class="hljs-tag"> </span><span class="hljs-attr">selected</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">"Group"</span><span class="hljs-tag">&gt;</span>Group<span class="hljs-tag">&lt;/</span><span class="hljs-name">option</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-name">option</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">"Entry"</span><span class="hljs-tag">&gt;</span>Entry<span class="hljs-tag">&lt;/</span><span class="hljs-name">option</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-name">option</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">"PxEntry"</span><span class="hljs-tag">&gt;</span>PxEntry<span class="hljs-tag">&lt;/</span><span class="hljs-name">option</span><span class="hljs-tag">&gt;</span>
            <span class="hljs-tag">&lt;</span><span class="hljs-name">option</span><span class="hljs-tag"> </span><span class="hljs-attr">value</span><span class="hljs-tag">=</span><span class="hljs-string">"Notes"</span><span class="hljs-tag">&gt;</span>Notes<span class="hljs-tag">&lt;/</span><span class="hljs-name">option</span><span class="hljs-tag">&gt;</span>
        <span class="hljs-tag">&lt;/</span><span class="hljs-name">select</span><span class="hljs-tag">&gt;</span>
        }
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">EditorDialog</span><span class="hljs-tag">&gt;</span>
    <span class="hljs-tag">&lt;/</span><span class="hljs-name">CascadingValue</span><span class="hljs-tag">&gt;</span>
  };
}
</code></pre>
<p class="packt_figref">Listing 11.5: <code class="inlineCode">ItemEditTests.razor</code> (<a href="https://epa.ms/ItemEditTests11-5"><span class="url">https://epa.ms/ItemEditTests11-5</span></a>)</p>
<p class="normal">We <a id="_idIndexMarker895"/>define a <code class="inlineCode">RenderFragment</code> delegate, <code class="inlineCode">_editorDialog</code>, in the <code class="inlineCode">@code</code> block of <code class="inlineCode">ItemEditTests.razor</code>. The <code class="inlineCode">RenderFragment</code> delegate must accept a parameter called <code class="inlineCode">__builder</code> of the <code class="inlineCode">RenderTreeBuilder</code> type. In<a id="_idIndexMarker896"/> the markup code, we can access the variables defined in the test class.</p>
<p class="normal">Now let’s look at the usage of <code class="inlineCode">_editorDialog</code> in the C# code-behind file in <em class="italic">Listing 11.6</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Tests</span>;
[<span class="hljs-meta">Collection(</span><span class="hljs-string">"Serilog collection"</span><span class="hljs-meta">)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemEditTests</span> : <span class="hljs-title">TestContext</span> {
  <span class="hljs-keyword">readonly</span> SerilogFixture serilogFixture;
  <span class="hljs-built_in">bool</span> isNewItem { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; } = <span class="hljs-literal">false</span>;
  NewItem testItem { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
  <span class="hljs-built_in">string</span> _dialogId = <span class="hljs-string">"editItem"</span>;
  <span class="hljs-built_in">string</span> updated_key = <span class="hljs-string">"Updated item"</span>;
  <span class="hljs-built_in">string</span> updated_value = <span class="hljs-string">"This item is updated."</span>;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ItemEditTests</span><span class="hljs-function">(</span><span class="hljs-params">SerilogFixture fixture</span><span class="hljs-function">)</span> {
    testItem = <span class="hljs-keyword">new</span>() {
        Name = <span class="hljs-string">"New item"</span>,
        Notes = <span class="hljs-string">"This is a new item."</span>
    };
    serilogFixture = fixture;
  }
  <span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnSaveClicked</span><span class="hljs-function">(</span><span class="hljs-built_in">string</span><span class="hljs-params"> key, </span><span class="hljs-built_in">string</span><span class="hljs-params"> </span><span class="hljs-keyword">value</span><span class="hljs-function">)</span> {
    testItem.Name = key; testItem.Notes = <span class="hljs-keyword">value</span>;
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Edit_New_Item</span><span class="hljs-function">()</span> {
    isNewItem = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">var</span> cut = Render(_editorDialog);                                <span class="hljs-comment">//(1)</span>
    cut.Find(<span class="hljs-string">"#itemType"</span>).Change(<span class="hljs-string">"Entry"</span>);
    cut.Find(<span class="hljs-string">"input"</span>).Change(updated_key);
    cut.Find(<span class="hljs-string">"textarea"</span>).Change(updated_value);
    cut.Find(<span class="hljs-string">"button[type=submit]"</span>).Click();
    Assert.Equal(updated_key, testItem.Name);
    Assert.Equal(updated_value, testItem.Notes);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Edit_Existing_Item</span><span class="hljs-function">()</span> {
    isNewItem = <span class="hljs-literal">false</span>;                                              <span class="hljs-comment">//(3)</span>
    <span class="hljs-keyword">var</span> cut = Render(_editorDialog);                                <span class="hljs-comment">//(1)</span>
<span class="hljs-keyword">    var</span> ex = Assert.Throws&lt;ElementNotFoundException&gt;(() =&gt;
      cut.Find(<span class="hljs-string">"#itemType"</span>).Change(<span class="hljs-string">"</span><span class="hljs-string">Entry"</span>));                       <span class="hljs-comment">//(2)</span>
    Assert.Equal(<span class="hljs-string">"No elements were found that matches the</span>
<span class="hljs-string">      selector '#itemType'"</span>, ex.Message);                           <span class="hljs-comment">//(4)</span>
    cut.Find(<span class="hljs-string">"textarea"</span>).Change(updated_value);
    cut.Find(<span class="hljs-string">"button[type=submit]"</span>).Click();
    Assert.Equal(updated_value, testItem.Notes);
  }
}
</code></pre>
<p class="packt_figref">Listing 11.6: <code class="inlineCode">ItemEditTests.razor.cs</code> (<a href="https://epa.ms/ItemEditTests11-6"><span class="url">https://epa.ms/ItemEditTests11-6</span></a>)</p>
<p class="normal">Since <code class="inlineCode">_editorDialog</code> defines the <code class="inlineCode">Item</code> editing, we can develop multiple test cases for it. We can see <a id="_idIndexMarker897"/>that we render <code class="inlineCode">_editorDialog</code>, <strong class="keyWord">(1)</strong>, for multiple test cases, such as <code class="inlineCode">Edit_New_Item</code> and <code class="inlineCode">Edit_Existing_Item</code>. By employing the <code class="inlineCode">RenderFragment</code> delegate, our testing<a id="_idIndexMarker898"/> code appears more elegant and streamlined. Without taking this approach, we would need to replicate lengthy markup code in multiple locations. Directly using C# code may result in even more duplication of code.</p>
<p class="normal">In both test cases, we employ a similar process to test the <code class="inlineCode">EditorDialog</code> by setting values and then <a id="_idIndexMarker899"/>clicking the <code class="inlineCode">Save</code> button. In the markup code, we have a <code class="inlineCode">&lt;select&gt;</code> tag defined. We can change the option, <strong class="keyWord">(2)</strong>, of the <code class="inlineCode">&lt;select&gt;</code> tag within the test code. This <code class="inlineCode">&lt;select&gt;</code> tag is conditionally rendered based on the value of the <code class="inlineCode">isNewItem</code> variable. </p>
<p class="normal">In the <code class="inlineCode">Edit_Existing_Item</code> test, we can also examine the negative case when the <code class="inlineCode">isNewItem</code> variable,<strong class="keyWord">(3)</strong>, is set to <code class="inlineCode">false</code>. In this instance, an exception is raised since the <code class="inlineCode">&lt;select&gt;</code> tag is not rendered. We can observe that bUnit can also be utilized to test negative cases by verifying the content of the exception, <strong class="keyWord">(4)</strong>.</p>
<p class="normal">In the <a id="_idIndexMarker900"/>previous examples, we developed bUnit tests for the shared components in the <code class="inlineCode">PassXYZ.BlazorUI</code> project. As these shared components serve as reusable building blocks for a high-level UI, many of them declare numerous component parameters. Utilizing the <code class="inlineCode">RenderFragment</code> delegate or <strong class="keyWord">Razor templates</strong> can aid in simplifying the test setup process.</p>
<p class="normal">Upon examining the Razor pages within the <code class="inlineCode">Pages</code> folder of the <code class="inlineCode">PassXYZ.Vault</code> project, we find that <code class="inlineCode">Items</code>, <code class="inlineCode">ItemDetail</code>, and <code class="inlineCode">Login</code> also function as Razor components. However, they are not designed for reuse. These Razor pages feature defined route templates and lack an extensive range of component parameters. The component parameters present in these Razor pages serve routing purposes. When designing test cases for these Razor pages, it is advisable to implement tests in a C# class instead of Razor files.</p>
<h2 class="heading-2" id="_idParaDest-305">Testing Razor pages</h2>
<p class="normal">During <a id="_idIndexMarker901"/>the development testing of Razor pages, we will become familiar with some highly beneficial bUnit features. Since it is not possible to review all the tests of Razor pages in our app, we will use <code class="inlineCode">ItemDetail</code> as an example. <code class="inlineCode">ItemDetail</code> is a Razor page designed to display the contents of a password entry, and it has a defined route.</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@page</span> <span class="hljs-string">"/entry/{SelectedItemId}"</span>
</code></pre>
<p class="normal">When we want to display the <code class="inlineCode">ItemDetail</code> page, we need to pass the <code class="inlineCode">Id</code> info for an <code class="inlineCode">Item</code> instance to it, and this instance cannot be a group. The initialization of the <code class="inlineCode">ItemDetail</code> page is done in the <code class="inlineCode">OnParametersSet()</code> lifecycle method, as we can see here:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">protected</span><span class="hljs-function"> </span><span class="hljs-keyword">override</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">OnParametersSet</span><span class="hljs-function">()</span> {
  <span class="hljs-keyword">base</span>.OnParametersSet();
  <span class="hljs-keyword">if</span> (SelectedItemId != <span class="hljs-literal">null</span>) {
    selectedItem = DataStore.GetItem(SelectedItemId, <span class="hljs-literal">true</span>);
    <span class="hljs-keyword">if</span> (selectedItem == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(                        <span class="hljs-comment">//(2)</span>
  <span class="hljs-string">"ItemDetail: entry cannot be found with SelectedItemId"</span>);
    }
    <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (selectedItem.IsGroup) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(                      <span class="hljs-comment">//(3)</span>
   <span class="hljs-string">"ItemDetail: SelectedItemId should not be group here."</span>);
      }
      <span class="hljs-keyword">else</span> {                                                        <span class="hljs-comment">//(4)</span>
        fields.Clear();
        List&lt;Field&gt; tmpFields = selectedItem.GetFields();
        <span class="hljs-keyword">foreach</span> (Field field <span class="hljs-keyword">in</span> tmpFields) {
            fields.Add(field);
        }
        notes = selectedItem.GetNotesInHtml();
      }
    }
  }
  <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidOperationException(                            <span class="hljs-comment">//(1)</span>
      <span class="hljs-string">"ItemDetail: SelectedItemId is null"</span>);
  }
}
</code></pre>
<p class="normal">We<a id="_idIndexMarker902"/> will develop an <code class="inlineCode">ItemDetailTests</code> test class to cover all the execution paths in <code class="inlineCode">OnParametersSet()</code>. To cover all the execution paths, we can find the following test cases:</p>
<ul>
<li class="bulletList"><code class="inlineCode">Test case 1</code>: Initialize the <code class="inlineCode">ItemDetail</code> instance without a selected item <code class="inlineCode">Id</code>. We will get an <code class="inlineCode">InvalidOperationException</code> exception, <strong class="keyWord">(1)</strong>, in this case.</li>
<li class="bulletList"><code class="inlineCode">Test case 2</code>: Initialize the <code class="inlineCode">ItemDetail</code> instance with the wrong item <code class="inlineCode">Id</code>. In this case, we will get an <code class="inlineCode">InvalidOperationException</code> exception, <strong class="keyWord">(2)</strong>.</li>
<li class="bulletList"><code class="inlineCode">Test case 3</code>: Initialize the <code class="inlineCode">ItemDetail</code> instance with a valid item <code class="inlineCode">Id</code>, but the item type as a group. In this case, we will get an <code class="inlineCode">InvalidOperationException</code> exception, <strong class="keyWord">(3)</strong>.</li>
<li class="bulletList"><code class="inlineCode">Test case 4</code>: Initialize the <code class="inlineCode">ItemDetail</code> instance with a valid item <code class="inlineCode">Id</code> and the item type is an entry, <strong class="keyWord">(4)</strong>.</li>
</ul>
<p class="normal">We can implement these test cases in an <code class="inlineCode">ItemDetailTests</code> bUnit test class, as shown here in <em class="italic">Listing 11.7</em>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">namespace</span> <span class="hljs-title">PassXYZ.Vault.Tests</span>;
[<span class="hljs-meta">Collection(</span><span class="hljs-string">"Serilog collection"</span><span class="hljs-meta">)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ItemDetailTests</span> : <span class="hljs-title">TestContext</span> {
  SerilogFixture serilogFixture;
  Mock&lt;IDataStore&lt;Item&gt;&gt; dataStore;
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-title">ItemDetailTests</span><span class="hljs-function">(</span><span class="hljs-params">SerilogFixture fixture</span><span class="hljs-function">)</span> {
      serilogFixture = fixture;
      dataStore = <span class="hljs-keyword">new</span> Mock&lt;IDataStore&lt;Item&gt;&gt;();                    <span class="hljs-comment">//(1)</span>
      Services.AddSingleton&lt;IDataStore&lt;Item&gt;&gt;
        (dataStore.Object);                                        <span class="hljs-comment">//(2)</span>
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="code-highlight"><strong class="hljs-title-slc">Init_Empty_ItemDetail</strong></span><span class="hljs-function">()</span> {                            <span class="hljs-comment">//(3)</span>
      <span class="hljs-keyword">var</span> ex = Assert.Throws&lt;InvalidOperationException&gt;(
        () =&gt; RenderComponent&lt;ItemDetail&gt;());
      Assert.Equal(
        <span class="hljs-string">"ItemDetail: SelectedItemId is null"</span>, ex.Message);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="code-highlight"><strong class="hljs-title-slc">Load_ItemDetail_WithWrongId</strong></span><span class="hljs-function">()</span> {
    <span class="hljs-keyword">var</span> ex = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt;
      RenderComponent&lt;ItemDetail&gt;(parameters =&gt;
      parameters.Add(p =&gt; p.SelectedItemId, <span class="hljs-string">"Wrong Id"</span>)));
    Assert.Equal(<span class="hljs-string">"ItemDetail: entry cannot be found with</span>
<span class="hljs-string">        SelectedItemId"</span>, ex.Message);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="code-highlight"><strong class="hljs-title-slc">Load_ItemDetail_WithGroup</strong></span><span class="hljs-function">()</span> {
    Item testGroup = <span class="hljs-keyword">new</span> PwGroup(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) {
      Name = <span class="hljs-string">"Default Group"</span>,
      Notes = <span class="hljs-string">"This is a group in ItemDetailTests."</span>
    };
    dataStore.Setup(x =&gt; x.GetItem(It.IsAny&lt;<span class="hljs-built_in">string</span>&gt;(),
      It.IsAny&lt;<span class="hljs-built_in">bool</span>&gt;())).Returns(testGroup);
    <span class="hljs-keyword">var</span> ex = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt;
      RenderComponent&lt;ItemDetail&gt;(parameters =&gt;
     parameters.Add(p =&gt; p.SelectedItemId, testGroup.Id)));
    Assert.Equal(<span class="hljs-string">"ItemDetail: SelectedItemId should not be</span>
<span class="hljs-string">      group here."</span>, ex.Message);
  }
  [<span class="hljs-meta">Fact</span>]
  <span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="code-highlight"><strong class="hljs-title-slc">Load_ItemDetail_WithEmptyFieldList</strong></span><span class="hljs-function">()</span> {
    Item testEntry = <span class="hljs-keyword">new</span> PwEntry(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) {
      Name = <span class="hljs-string">"Default Entry"</span>,
      Notes = <span class="hljs-string">"This is an entry with empty field list."</span>
    };
    dataStore.Setup(x =&gt; x.GetItem(It.IsAny&lt;<span class="hljs-built_in">string</span>&gt;(),
        It.IsAny&lt;<span class="hljs-built_in">bool</span>&gt;())).Returns(testEntry);
    <span class="hljs-keyword">var</span> cut = RenderComponent&lt;ItemDetail&gt;(parameters =&gt;
      parameters.Add(p =&gt; p.SelectedItemId, testEntry.Id));
    cut.Find(<span class="hljs-string">"article"</span>).MarkupMatches(
      <span class="hljs-string">$"&lt;article&gt;&lt;p&gt;</span><span class="hljs-subst">{testEntry.Notes}</span><span class="hljs-string">&lt;/p&gt;&lt;/article&gt;"</span>);
  }
}
</code></pre>
<p class="packt_figref">Listing 11.7: <code class="inlineCode">ItemDetailTests.cs</code> (<a href="https://epa.ms/ItemDetailTests11-7"><span class="url">https://epa.ms/ItemDetailTests11-7</span></a>)</p>
<p class="normal">The<a id="_idIndexMarker903"/> first test case is implemented in <code class="inlineCode">Init_Empty_ItemDetail</code> <strong class="keyWord">(3)</strong>. During the test setup, we attempt to render the <code class="inlineCode">ItemDetail</code> component directly without providing a selected item <code class="inlineCode">Id</code>. We anticipate encountering an <code class="inlineCode">InvalidOperationException</code> exception as a result.</p>
<p class="normal">Before executing the test case, we must first address the <code class="inlineCode">IDataStore</code> dependency. <code class="inlineCode">ItemDetail</code> relies on the <code class="inlineCode">IDataStore&lt;Item&gt;</code> interface, and we can resolve this through dependency injection. In our app, this dependency is registered within the <code class="inlineCode">MauiProgram.cs</code> file.</p>
<p class="normal">With bUnit, dependency injection is supported using <code class="inlineCode">TestContext</code>. We can register the dependency using <code class="inlineCode">AddSingleton</code>, <strong class="keyWord">(2)</strong>. To isolate the test, we use the <code class="inlineCode">Moq</code> mocking framework, <strong class="keyWord">(1)</strong>, to replace the actual implementation of <code class="inlineCode">IDataStore</code>, so we can reduce the complexity of the test setup.</p>
<p class="normal">Using <code class="inlineCode">Moq</code>, we only need to fake the method or property that we need in our test setup. It can help to isolate our tests from their dependencies. To use the <code class="inlineCode">Moq</code> framework, we can create a <code class="inlineCode">Moq</code> object using the interface or class that we need as a type parameter. Later, we can define the behavior of the target interface or class when we use it. In the constructor, we create a <code class="inlineCode">Mock</code> object and register the <code class="inlineCode">IDataStore&lt;Item&gt;</code> interface using <code class="inlineCode">dataStore.Object</code>:</p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">dataStore</span> <span class="hljs-operator">=</span> new Mock&lt;IDataStore&lt;Item&gt;&gt;()<span class="hljs-comment">;</span>
Services.AddSingleton&lt;IDataStore&lt;Item&gt;&gt;(
  dataStore.Object)<span class="hljs-comment">;</span>
</code></pre>
<p class="normal">After we register <code class="inlineCode">IDataStore</code> in the constructor, we can execute the first test case again. This time, we can get the exception and verify the message is what we expect:</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">Fact</span>]
<span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Init_Empty_ItemDetail</span><span class="hljs-function">()</span> {
  <span class="hljs-keyword">var</span> ex = Assert.Throws&lt;InvalidOperationException&gt;(
    () =&gt; RenderComponent&lt;ItemDetail&gt;());
  Assert.Equal(<span class="hljs-string">"ItemDetail: SelectedItemId is null"</span>,
    ex.Message);
}
</code></pre>
<p class="normal">Next, let <a id="_idIndexMarker904"/>us look at the second test case. In the second test case, we pass an invalid <code class="inlineCode">Id</code> to <code class="inlineCode">ItemDetail</code> and try to render it:</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">Fact</span>]
<span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Load_ItemDetail_WithWrongId</span><span class="hljs-function">()</span> {
  <span class="hljs-keyword">var</span> ex = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt;
    RenderComponent&lt;ItemDetail&gt;(parameters =&gt;
    parameters.Add(p =&gt; p.SelectedItemId, <span class="hljs-string">"Wrong Id"</span>)));
    Assert.Equal(<span class="hljs-string">"ItemDetail: entry cannot be found with</span>
<span class="hljs-string">      SelectedItemId"</span>, ex.Message);
}
</code></pre>
<p class="normal">In this case, we also get an expected exception, and we can verify its content using <code class="inlineCode">Assert.Equal</code>.</p>
<p class="normal">In the third test case, we provide a valid <code class="inlineCode">Id</code> to <code class="inlineCode">ItemDetail</code>, but the item is of a group type. This is a scenario that may be challenging to reproduce during an integration or user acceptance test. However, in a unit test, it is relatively simple to verify, as demonstrated here:</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">Fact</span>]
<span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Load_ItemDetail_WithGroup</span><span class="hljs-function">()</span> {
  Item testGroup = <span class="hljs-keyword">new</span> PwGroup(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) {
    Name = <span class="hljs-string">"Default Group"</span>,
    Notes = <span class="hljs-string">"This is a group in ItemDetailTests."</span>
  };
  dataStore.Setup(x =&gt; x.GetItem(It.IsAny&lt;<span class="hljs-built_in">string</span>&gt;(),
    It.IsAny&lt;<span class="hljs-built_in">bool</span>&gt;())).Returns(testGroup);
  <span class="hljs-keyword">var</span> ex = Assert.Throws&lt;InvalidOperationException&gt;(() =&gt;
    RenderComponent&lt;ItemDetail&gt;(parameters =&gt;
    parameters.Add(p =&gt; p.SelectedItemId, testGroup.Id)));
    Assert.Equal(<span class="hljs-string">"ItemDetail: SelectedItemId should not be</span>
<span class="hljs-string">    group here."</span>, ex.Message);
  }
</code></pre>
<p class="normal">To test this, we need to create a group and assign it to a <code class="inlineCode">testGroup</code> variable. In this test case, we must call the <code class="inlineCode">GetItem</code> method of <code class="inlineCode">IDataStore</code>. Since we mocked <code class="inlineCode">IDataStore</code> in our setup, we also need to mock the <code class="inlineCode">GetItem</code> method here. The <code class="inlineCode">Moq</code> method returns <code class="inlineCode">testGroup</code> when called. Once the test setup is prepared, we can render <code class="inlineCode">ItemDetail</code> with <code class="inlineCode">testGroup.Id</code>. The expected outcome of this test is the exception that we anticipate.</p>
<p class="normal">In the final test case, we will pass a valid Item <code class="inlineCode">Id</code> and the item type is an entry:</p>
<pre class="programlisting code"><code class="hljs-code">[<span class="hljs-meta">Fact</span>]
<span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">void</span><span class="hljs-function"> </span><span class="hljs-title">Load_ItemDetail_WithEmptyFieldList</span><span class="hljs-function">()</span> {
  Item testEntry = <span class="hljs-keyword">new</span> PwEntry(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>) {
    Name = <span class="hljs-string">"Default Entry"</span>,
    Notes = <span class="hljs-string">"This is an entry with empty field list."</span>
  };
  dataStore.Setup(x =&gt; x.GetItem(It.IsAny&lt;<span class="hljs-built_in">string</span>&gt;(),
    It.IsAny&lt;<span class="hljs-built_in">bool</span>&gt;())).Returns(testEntry);
  <span class="hljs-keyword">var</span> cut = RenderComponent&lt;ItemDetail&gt;(parameters =&gt;
    parameters.Add(p =&gt; p.SelectedItemId, testEntry.Id));
  cut.Find(<span class="hljs-string">"article"</span>).MarkupMatches(
    <span class="hljs-string">$"&lt;article&gt;&lt;p&gt;</span><span class="hljs-subst">{testEntry.Notes}</span><span class="hljs-string">&lt;/p&gt;&lt;/article&gt;"</span>);
  Debug.WriteLine(<span class="hljs-string">$"</span><span class="hljs-subst">{cut.Markup}</span><span class="hljs-string">"</span>);
}
</code></pre>
<p class="normal">This<a id="_idIndexMarker905"/> test case is similar to the third test case, except we can create an entry and assign it to the <code class="inlineCode">testEntry</code> variable. After we render <code class="inlineCode">ItemDetail</code> with <code class="inlineCode">testEntry.Id</code>, we can verify that the <code class="inlineCode">&lt;article&gt;</code> rendered HTML tag is the one that we expect.</p>
<p class="normal">Thus far, we have explored testing Razor components using bUnit. It is evident that we can attain an impressively high level of test coverage with bUnit. This serves as one of the advantages of Blazor UI design.</p>
<p class="normal">We have now addressed all the topics related to unit test development with .NET MAUI in this chapter that we intended to explore.</p>
<h1 class="heading-1" id="_idParaDest-306">Summary</h1>
<p class="normal">In this chapter, we discussed unit test development for .NET MAUI apps. Although multiple test frameworks are available, we selected xUnit as our framework for this chapter. In the MVVM pattern, unit testing of the model layer is consistent with any other .NET application. We developed test cases for the <code class="inlineCode">IDataStore</code> interface to evaluate our model layer. For unit testing the view and view model, we concentrated on the Blazor Hybrid app utilizing the bUnit test library. By combining the xUnit framework and bUnit library, we can develop end-to-end unit tests for a Blazor Hybrid app. With bUnit, we addressed topics such as Razor templates, the <code class="inlineCode">RenderFragment</code> delegate, dependency injection, and the Moq framework.</p>
<p class="normal">With the understanding of unit testing acquired in this chapter, you should now be capable of developing your own unit tests. For more information on .NET unit test development, please refer to the <em class="italic">Further reading</em> section.</p>
<p class="normal">Unit testing can be integrated into a CI/CD pipeline. This setup allows unit tests to be executed automatically during the development process. We will explore this topic in greater detail in the upcoming chapter.</p>
<h1 class="heading-1" id="_idParaDest-307">Further reading</h1>
<ul>
<li class="bulletList"><em class="italic">Microsoft Visual Studio 2005 Unleashed</em> by Lars Powers and Mike Snell: <a href="https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194"><span class="url">https://www.amazon.com/Microsoft-Visual-Studio-2005-Unleashed/dp/0672328194</span></a></li>
<li class="bulletList">MSTest: <a href="https://github.com/microsoft/testfx"><span class="url">https://github.com/microsoft/testfx</span></a></li>
<li class="bulletList"><em class="italic">Strengthening Visual Studio Unit Tests</em> by John Robbins: <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests"><span class="url">https://learn.microsoft.com/en-us/archive/msdn-magazine/2006/march/bugslayer-strengthening-visual-studio-unit-tests</span></a></li>
<li class="bulletList"><em class="italic">NUnit Pocket Reference</em> by Bill Hamilton: <a href="https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396"><span class="url">https://www.amazon.com/NUnit-Pocket-Reference-Running-OReilly/dp/0596007396</span></a></li>
<li class="bulletList">NUnit Releases at SourceForge: <a href="https://sourceforge.net/projects/nunit/"><span class="url">https://sourceforge.net/projects/nunit/</span></a></li>
<li class="bulletList"><em class="italic">Why Did we Build xUnit 1.0: </em><a href="https://xunit.net/docs/why-did-we-build-xunit-1.0"><span class="url">https://xunit.net/docs/why-did-we-build-xunit-1.0</span></a></li>
<li class="bulletList">xUnit documentation: <a href="https://xunit.net/"><span class="url">https://xunit.net/</span></a></li>
<li class="bulletList">xUnit.NET 2.0 release note: <a href="https://xunit.net/releases/2.0"><span class="url">https://xunit.net/releases/2.0</span></a></li>
</ul>
<h1 class="heading-1">Learn more on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/cross-platform-app"><span class="url">https://packt.link/cross-platform-app</span></a></p>
<p class="normal"><img alt="" height="354" src="../Images/QR_Code166522361691420406.png" style="width:10em;" width="354"/></p>
</div>
</div></body></html>