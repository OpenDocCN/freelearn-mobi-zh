<html><head></head><body>
        

                            
                    <h1 class="header-title">Shaping Code with Kotlin Functional Programming Features</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will cover the following recipes:</p>
<ul>
<li>Working effectively with lambda expressions</li>
<li>Discovering basic scoping functions – <kbd>let</kbd>, <kbd>also</kbd>, and <kbd>apply</kbd></li>
<li>Initializing objects the clean way using the <kbd>run</kbd> scoping function</li>
<li>Working with higher-order functions</li>
<li>Functions currying</li>
<li>Function composition</li>
<li>Implementing the Either Monad design pattern</li>
<li>Approach to automatic function memoization</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Despite the fact that Kotlin is recognized implicitly as an object-oriented language, it is still open to other programming styles and paradigms. Thanks to Kotlin's built-in features, we are able to apply functional programming patterns to our code with ease. Having the possibility to return functions from other functions or to pass a function as a parameter allows us to benefit from a deferred computation. In addition, we are able to return functions, instead of already-computed values, on different layers in the code. This results in the lazy-evaluation feature.</p>
<p class="mce-root"/>
<p>Compared to Scala or other functional programming languages, Kotlin doesn't require us to use dedicated, functional style design patterns. It also lacks some of their out-of-the-box implementations. However, in return, it brings more flexibility to developers as far as software architecture and implementation details are concerned. The Kotlin language and standard library components provide full built-in support for basic functional programming concepts. And more sophisticated ones can always be implemented from scratch or reused from some of the available external libraries. The ones worth giving a try are the Kotlin Arrow (<a href="http://arrow-kt.io">http://arrow-kt.io</a>) and funKTionale (<a href="https://github.com/MarioAriasC/funKTionale">https://github.com/MarioAriasC/funKTionale</a>) projects. However, keep in mind the words of Robert C. Martin—<em>It is perfectly possible to write a program that is both object-oriented and functional. Not only is it possible, it is desirable. There is no "OO vs FP," the two are orthogonal and coexist nicely</em><q>.</q> It should be understood that functional programming is only one available tool. It should be used wisely and only where it is applicable.</p>
<p>This chapter focuses on explaining functional programming features supported by Kotlin internally. It gives you hands-on experience in solving real-life problems by using state-of-the-art functional programming concepts. By the end of the chapter, you should be familiar with the Kotlin language support for the functional programming approach and standard library components that can help implement it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working effectively with lambda expressions</h1>
                
            
            
                
<p>In this recipe, we are going to explore the concept of lambdas and closures. We are going to write part of an Android application code responsible for handling button-click actions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to implement this recipe's code, you need to create a new Android application project using Android Studio IDE. </p>
<p>Let's assume we have the following class, which is a sort of a controller of the application view layer:</p>
<pre class="mce-root">class RegistrationScreen : Activity() {<br/>    private val submitButton: Button by lazy { findViewById(R.id.submit_button) }  <br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<pre class="mce-root">        // hook function called once the screen is displayed<br/>    }<br/>}</pre>
<p>It contains a reference to the <kbd>submitButton: Button</kbd> instance. Inside the <kbd>onCreate()</kbd> function we are going to implement logic responsible for handling the button clicks. Once the button is clicked, we want to make it invisible.</p>
<p>In order to invoke some action when the button is clicked, we need to call the <kbd>View.setOnClickListener(listener: OnClickListener)</kbd> function on the <kbd>View</kbd> subclass. The <kbd>OnClickListener</kbd> is a functional interface defined as follows:</p>
<pre>public interface OnClickListener {<br/>    void onClick(View view);<br/>}</pre>
<p>Under the hood, the Android OS invokes the <kbd>onClick()</kbd> function when the user clicks the view.</p>
<p>There are two ways of implementing a functional interface in Kotlin:</p>
<ul>
<li>Defining an object that implements the interface:</li>
</ul>
<pre style="padding-left: 60px">val myInterfaceInstance = object: MyInterface {<br/>    override fun foo() {<br/>        // foo function body<br/>    }<br/>}</pre>
<ul>
<li>Treating the interface as a function and implementing it, for example, in the form of the lambda:</li>
</ul>
<pre style="padding-left: 60px">val myInterfaceAsFunction: () -&gt; Unit = { <br/>    // foo function body<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol start="1">
<li>Call the <kbd>setOnClickListener</kbd> function and pass an empty <kbd>OnClickListener</kbd> instance as a lambda expression:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">class RegistrationScreen : Activity() {<br/>    private val submitButton: Button by lazy { findViewById(R.id.submit_button) }  <br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        submitButton.setOnClickListener { view: View -&gt;<br/>            // do something on click<br/>        }<br/>    }<br/>}</pre>
<ol start="2">
<li>Modify the visibility of the <kbd>submitButton</kbd> instance inside the function body:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">class RegistrationScreen : Activity() {<br/>    private val submitButton: Button by lazy { findViewById(R.id.submit_button) }  <br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        submitButton.setOnClickListener {<br/>            submitButton.visibility = View.INVISIBLE<br/>        }<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Thanks to treating <kbd>OnClickListener</kbd> as a function, we were able to implement it in the clean and concise form of a lambda expression. The lambda's body will globally be invoked whenever the user clicks the button. In our case, once the button is clicked, it will be hidden away.</p>
<p>Lambda expressions are one of the most essential functional features of the language and are used extensively in the standard library components. They can be seen as an abbreviated form of a function or a functional interface implementation. Lambdas help to organize code correctly and reduce a lot of boilerplate code. The syntax of a lambda expression can be seen as a block of code placed between <kbd>{</kbd> <kbd>}</kbd> symbols. Lambda expressions can have function arguments defined explicitly, for example:</p>
<pre class="mce-root">val myFunction: (View) -&gt; Unit = { view -&gt;<br/>   view.visibility = View.INVISIBLE<br/>}</pre>
<p>For the sake of brevity, the explicit parameter can be omitted. However, we can still access it using <kbd>it</kbd> modifier:</p>
<pre class="mce-root">val myFunction: (View) -&gt; Unit = { <br/>   it.visibility = View.INVISIBLE<br/>}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>When working with lambdas, whenever we want to execute the code inside their body, we need to call the <kbd>invoke()</kbd> function on them or its equivalent, the <kbd>()</kbd> operator:</p>
<pre>val callback: () -&gt; Unit = { println("The job is done!") }<br/>callback.invoke()<br/>callback()</pre>
<p>The preceding code is going to print the text twice:</p>
<pre><strong>"The job is done!"</strong><br/><strong>"The job is done!"</strong></pre>
<p>There is also another clean way of passing functions as the parameters to other functions. We can do it using function references:</p>
<pre>fun hideView(view: View): Unit  {<br/>    view.visibility = View.INVISIBLE<br/>}<br/><br/>submitButton.setOnClickListener(::hideView)</pre>
<p>The function references approach can be particularly useful for reusing the function implementation across the codebase.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Discovering basic scoping functions – let, also, apply</h1>
                
            
            
                
<p>In this recipe, we are going to explore three useful extension functions from the standard library—<kbd>let</kbd>, <kbd>also</kbd>, and <kbd>apply</kbd>. They work great together with lambda expressions and help to write clean and safe code. We are going to practice their usage while applying them to implement a sequence of data-processing operations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's assume we can fetch the date using the following function:</p>
<pre class="mce-root">fun getPlayers(): List&lt;Player&gt;? </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Here, the <kbd>Player</kbd> class is defined like this:</p>
<pre>data class Player(val name: String, val bestScore: Int)</pre>
<p>We would like to perform the following sequence of operations to the <kbd>getPlayers()</kbd> function result:</p>
<ol>
<li>Print the original set of players in the list to the console</li>
<li>Sort the collection of the <kbd>Player</kbd> objects in descending order</li>
<li>Transform collection <kbd>Player</kbd> objects into the list of strings obtained from the <kbd>Player.name</kbd> property</li>
<li>Limit the collection to the first element and print it to the console</li>
</ol>
<p>In order to accomplish the task, first, we need to get familiar with the characteristics of the <kbd>let</kbd>, <kbd>also</kbd>, and <kbd>apply</kbd> functions. They are provided in the standard library as extension functions for a generic type. Let's explore the headers of the <kbd>let</kbd>, <kbd>also</kbd>, and <kbd>apply</kbd> functions:</p>
<pre>public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R<br/><br/>public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T<br/><br/>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T </pre>
<p>They look similar, however, there are some subtle differences in return types and in parameters. The following table compares the three functions:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td style="width: 10.4683%"><strong>Function</strong></td>
<td style="width: 26.8595%"><strong>Return type</strong></td>
<td style="width: 31.8182%"><strong>Argument in block argument</strong></td>
<td style="width: 29.2011%"><strong>Block argument definition</strong></td>
</tr>
<tr>
<td style="width: 10.4683%"><kbd>let</kbd></td>
<td style="width: 26.8595%"><kbd>R</kbd> (from block body)</td>
<td style="width: 31.8182%">Explicit it</td>
<td style="width: 29.2011%"><kbd>(T) -&gt; R</kbd></td>
</tr>
<tr>
<td style="width: 10.4683%"><kbd>also</kbd></td>
<td style="width: 26.8595%"><kbd>T</kbd> (this)</td>
<td style="width: 31.8182%">Explicit it</td>
<td style="width: 29.2011%"><kbd>(T) -&gt; Unit</kbd></td>
</tr>
<tr>
<td style="width: 10.4683%"><kbd>apply</kbd></td>
<td style="width: 26.8595%"><kbd>T</kbd> (this)</td>
<td style="width: 31.8182%">Implicit this</td>
<td style="width: 29.2011%"><kbd>T.() -&gt; Unit</kbd></td>
</tr>
</tbody>
</table>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Use the <kbd>let</kbd> function together with the safe operator to assure null safety:</li>
</ol>
<pre style="padding-left: 60px">getPlayers()?.let {}</pre>
<ol start="2">
<li>Inside the <kbd>let</kbd> function's lambda parameter block, use the <kbd>also()</kbd> function to print the original set of players in the list to the console:</li>
</ol>
<pre style="padding-left: 60px">getPlayers()?.let {<br/><strong>    it.also {<br/>        println("${it.size} players records fetched")</strong><br/><strong>        println(it)</strong><br/><strong>    }</strong><br/>}</pre>
<ol start="3">
<li>Use the <kbd>let()</kbd> function to perform sorting and mapping transformations:</li>
</ol>
<pre style="padding-left: 60px">getPlayers()?.let {<br/>    it.also {<br/>        println("${it.size} players records fetched")<br/>        println(it)<br/>    }<strong>.let {<br/>        it.sortedByDescending { it.bestScore }<br/>    }</strong></pre>
<ol start="4">
<li>Limit the collection of players to a single <kbd>Player</kbd> instance with the highest score using the <kbd>let()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">getPlayers()?.let {<br/>    it.also {<br/>        println("${it.size} players records fetched")<br/>        println(it)<br/>    }.let {<br/>        it.sortedByDescending { it.bestScore }<br/>    }<strong>.let {<br/>        it.first()</strong><br/><strong>    }</strong></pre>
<ol start="5">
<li>Print the name of the best player to the console:</li>
</ol>
<pre style="padding-left: 60px">getPlayers()?.let {<br/>    it.also {<br/>        println("${it.size} players records fetched")<br/>        println(it)<br/>    }.let {<br/>        it.sortedByDescending { it.bestScore }<br/>    }.let {<br/>        it.first()<br/>    }<strong>.apply {<br/>        val name = this.name<br/>        print("Best Player: $name")</strong><br/>    <strong>}</strong><br/>}</pre>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's test our implementation. For the sake of the test, we can assume that the <kbd>getPlayers()</kbd> function returns the following results:</p>
<pre><br/>fun getPlayers(): List&lt;Player&gt;? = listOf(<br/>        Player("Stefan Madej", 109),<br/>        Player("Adam Ondra", 323),<br/>        Player("Chris Charma", 239))</pre>
<p>The code we have implemented is going to print the following output to the console:</p>
<pre><strong>3 players records fetched</strong><br/><strong>[Player(name=Stefan Madej, bestScore=109), Player(name=Adam Ondra, bestScore=323), Player(name=Chris Charma, bestScore=239)]</strong><br/><strong>Best Player: Adam Ondra</strong></pre>
<p>Note that, in the case of the <kbd>apply()</kbd> function, we can omit <kbd>this</kbd> keyword while accessing class properties and functions inside the function lambda block:</p>
<pre>apply {<br/>    print("Best Player: $<strong>name</strong>")<br/>}</pre>
<p>It was just used in the example code for the sake of clarity.</p>
<p>The useful feature of the <kbd>let()</kbd> function is that it can be used to assure the null safety of the given object. In the following example inside the <kbd>let</kbd> scope, the <kbd>players</kbd> argument will always hold a not null value even if some background thread tries to modify the original value of the mutable <kbd>results</kbd> variable:</p>
<pre>var result: List&lt;Player&gt;? = getPlayers()<br/>result?.let { players: List&lt;Player&gt; -&gt;<br/>    ...<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to learn more about lambda expressions, check out the <em>Working effectively with lambda expressions </em>recipe</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Initializing objects the clean way using the run scoping function</h1>
                
            
            
                
<p>In this recipe, we are going to explore another useful extension function provided by the standard library, called <kbd>run()</kbd>. We are going to use it in order to create and set up an instance of the <kbd>java.util.Calendar</kbd> class. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>First, let's  explore the characteristics of the <kbd>run()</kbd> function defined in the standard library with the following function header:</p>
<pre>public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R</pre>
<p>It is declared as an extension function for a generic type. The <kbd>run</kbd> function provides implicit <kbd>this</kbd> parameter inside the <kbd>block</kbd> argument and returns the result of the <kbd>block</kbd> execution.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare an instance of the <kbd>Calendar.Builder</kbd> class and apply the <kbd>run()</kbd> function to it:</li>
</ol>
<pre style="padding-left: 60px">val calendar = Calendar.Builder().run {<br/>    build()<br/>}</pre>
<ol start="2">
<li>Add the desired properties to the builder:</li>
</ol>
<pre style="padding-left: 60px">val calendar = Calendar.Builder().run {<br/>    <strong>setCalendarType("iso8601")</strong><br/><strong>    setDate(2018, 1, 18)</strong><br/><strong>    setTimeZone(TimeZone.getTimeZone("GMT-8:00"))</strong><br/>    build()<br/>}</pre>
<ol start="3">
<li>Print the date from the calendar to the console:</li>
</ol>
<pre style="padding-left: 60px">val calendar = Calendar.Builder().run {<br/>    setCalendarType("iso8601")<br/>    setDate(2018, 1, 18)<br/>    setTimeZone(TimeZone.getTimeZone("GMT-8:00"))<br/>    build()<br/>}<br/><strong>print(calendar.time)</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>run</kbd> function is applied to the <kbd>Calendar.Builder</kbd> instance. Inside the lambda passed to the <kbd>run</kbd> function, we can access the <kbd>Calendar.Builder</kbd> properties and methods via <kbd>this</kbd> modifier. In other words, inside the <kbd>run</kbd> function block, we are accessing the scope of the <kbd>Calendar.Builder</kbd> instance. In the recipe code, we are omitting to invoke <kbd>Builder</kbd> methods with <kbd>this</kbd> keyword. We can call them directly because the <kbd>run</kbd> function allows accessing the <kbd>Builder</kbd> instance inside its scope by an implicit <kbd>this</kbd> modifier.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can also use the <kbd>run()</kbd> function together with the safe <kbd>?</kbd> operator to provide null safety of the object referenced by <kbd>this</kbd> keyword inside the <kbd>run()</kbd> function scope. You can see it in action in the following example of configuring the Android <kbd>WebView</kbd> class:</p>
<pre>webview.settings?.run {<br/>    this.javaScriptEnabled = true<br/>    this.domStorageEnabled = false<br/>}</pre>
<p>In the preceding piece of code, we are ensuring that the <kbd>settings</kbd> property is not null inside the <kbd>run</kbd> function scope and we can access it with <kbd>this</kbd> keyword.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The Kotlin standard library offers another similar extension function, called <kbd>apply()</kbd>, which is useful for the initialization of objects. The main difference is that it returns an original instance of the object it was called on. You can explore it in the<em> Implementing builders the smart way </em>recipe in <a href="6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml">Chapter 5</a>, <em>Tasteful Design Patterns Adopting Kotlin Concepts</em>.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with higher-order functions</h1>
                
            
            
                
<p>Kotlin is designed to provide first-class support for operating on functions. For example, we are able to easily pass functions as parameters to a function. We can also create a function that can return another function. This kind of a function is called a <em>higher-order function</em>. This powerful feature helps to write a functional style code easily. The possibility to return a function instead of a value makes along with the ability to pass a function instance to an other function as an argument, makes it possible to defer computations and to shape code cleanly. In this recipe, we are going to implement a helper function that is going to measure the execution time of other functions passed to it as an argument.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Implement the <kbd>measureTime</kbd> function:</p>
<pre>fun measureTime(block: () -&gt; Unit): Long {<br/>    val start = System.currentTimeMillis()<br/>    block()<br/>    val end = System.currentTimeMillis()<br/>    <br/>    return end - start<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>measureTime()</kbd> function takes an argument, called <kbd>block</kbd>, of the functional type. The <kbd>block</kbd> function parameter is invoked inside the <kbd>measureTime()</kbd> function using the <kbd>()</kbd> modifier. Finally, the difference between timestamps (before and after the block execution) is returned. </p>
<p>Let's analyze the following example showing the <kbd>measureTime()</kbd> function in action. We can consider having the following function responsible for computing the factorial of a given integer:</p>
<pre>fun factorial(n: Int): Long {<br/>    sleep(10)<br/>    return if (n == 1) n.toLong() else n * factorial(n - 1)<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>In order to measure the <kbd>factorial()</kbd> function execution time we can use the <kbd>measureTime()</kbd> function as follows:</p>
<pre>val duration = measureTime {<br/>    factorial(13)<br/>}<br/>print("$duration ms")</pre>
<p>As the result, we get the execution time printed to the console:</p>
<pre><strong>154 ms</strong></pre>
<p>Note that it is also possible to pass a function reference instead of a lambda instance as the parameter to the <kbd>measureTime()</kbd> function:</p>
<pre>fun foo() = sleep(1000)<br/>val duration = measureTime(::foo)<br/>print("$duration ms")</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Functions currying </h1>
                
            
            
                
<p>Currying is a common technique in functional programming. It allows transforming a given function that takes multiple arguments into a sequence of functions, each having a single argument. Each of the resulting functions handles one argument of the original (uncurried) function and returns another function. </p>
<p>In this recipe, we are going to implement an automatic currying mechanism that could be applied to any function taking three parameters.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To understand the concept of function currying, let's consider the following example of a function handling three parameters:</p>
<pre>fun foo(a: A, b: B, c: C): D </pre>
<p>Its curried form would look like this:</p>
<pre>fun carriedFoo(a: A): (B) -&gt; (C) -&gt; D </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>In other words, the curried form of the <kbd>foo</kbd> function would take a single argument of the <kbd>A</kbd> type and return another function of the following type: <kbd>(B) -&gt; (C) -&gt; D</kbd>. The returned function is responsible for handling the second argument of the original function and returns another function, which takes the third argument and returns a value of type <kbd>D</kbd>. </p>
<p>In the next section, we are going to implement the <kbd>curried()</kbd> extension function for the generic functional type declared as follows: <kbd>&lt;P1, P2, P3, R&gt; ((P1, P2, P3)</kbd>. The <kbd>curried()</kbd> function is going to return a chain of single-argument functions and will be applicable to any function which takes three arguments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a header of the <kbd>curried()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">fun &lt;P1, P2, P3, R&gt; ((P1, P2, P3) -&gt; R).curried(): (P1) -&gt; (P2) -&gt; (P3) -&gt; R </pre>
<ol start="2">
<li>Implement the <kbd>curried()</kbd> function body: </li>
</ol>
<pre style="padding-left: 60px">fun &lt;P1, P2, P3, R&gt; ((P1, P2, P3) -&gt; R).curried(): (P1) -&gt; (P2) -&gt; (P3) -&gt; R =<br/>        <strong>{ p1: P1 -&gt;<br/>            { p2: P2 -&gt;<br/>                { p3: P3 -&gt;<br/>                    this(p1, p2, p3)</strong><br/><strong>                }<br/>             }<br/>        }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Let's explore how to use the <kbd>curried()</kbd> function in action. In the following example we are going to call <kbd>curried()</kbd> on the following function instance which is responsible for computing a sum of three integers:</p>
<pre>fun sum(a: Int, b: Int, c: Int): Int = a + b + c</pre>
<p class="mce-root"/>
<p>In order to obtain a curried form of the <kbd>sum()</kbd> function, we have to invoke the <kbd>curried()</kbd> function on its reference:</p>
<pre>::sum.curried()</pre>
<p>Then we can invoke the curried sum function in the following way:</p>
<pre>val result: Int = ::sum.curried()<strong>(1)(2)(3)</strong></pre>
<p>In the end, the <kbd>result</kbd> variable is going to be assigned an integer value equal to <kbd>6</kbd>.</p>
<p>In order to invoke the <kbd>curried()</kbd> extension function, we access the <kbd>sum()</kbd> function reference using the <kbd>::</kbd> modifier. Then we invoke the next functions from the function sequence returned by the curried function one by one. </p>
<p>The preceding code could be written in an equivalent more verbose form with explicit types declarations:</p>
<pre>val sum3: (a: Int) -&gt; (b: Int) -&gt; (c: Int) -&gt; Int = ::sum.curried()<br/>val sum2: (b: Int) -&gt; (c: Int) -&gt; Int = sum3(1)<br/>val sum1: (c: Int) -&gt; Int = sum2(2)<br/>val result: Int = sum1(3)</pre>
<p>Under the hood, the currying mechanism implementation is just returning functions nested inside each other. Every time the specific function is invoked, it returns another function with the arity reduced by one. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There is a similar pattern called <em>partial application. </em>It is more flexible than currying as it doesn't limit the number of arguments handled by each of the functions. For example, given a <kbd>foo</kbd> function declared as follows:</p>
<pre>fun foo(a: A, b: B, c: C): D </pre>
<p>We could transform it into the following form:</p>
<pre>fun foo(a: A, c: C) -&gt; (B) -&gt; D</pre>
<p>Both currying and partial application are useful whenever we can't provide the full number of required arguments to the function in the current scope. We can apply only the available ones to the function and return the transformed function.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Function composition</h1>
                
            
            
                
<p>In the<em> Functions currying</em> recipe, we discovered a neat way of transforming a function to extract new functions from it. In this recipe, we are going to work on implementing the opposite transformation. It would be useful to have the option to merge a number of existing functions' declarations and define a new function from them. This is a common functional programming pattern called <em>functions composition</em>. Kotlin doesn't provide function composition mechanism out of the box. However, thanks to the extended built-in support for operations on functional types, we are able to implement a reusable mechanism for the composition manually.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to get familiar with function composition, let's study the following example. Let's say we have the following functions defined:</p>
<pre>fun length(word: String) = word.length<br/>fun isEven(x:Int): Boolean = x.rem(2) == 0</pre>
<p>The first one is responsible for returning the length of a given string. The second one checks whether a given integer is even. In order to define a new function based on those two functions, we can make nested function calls:</p>
<pre>fun isCharCountEven(word: String): Boolean = isEven(length(word))</pre>
<p>This works fine, however, it would be useful if we were able to operate on the function references instead. In order to make it more concise we'd like to be able to declare the <kbd>isCharCountEven()</kbd> function using the following syntax for the functions composition:</p>
<pre>val isCharCountEven: (word: String) -&gt; Boolean = ::length and ::isEven</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare an <kbd>infix</kbd> extension function for the single-argument function called <kbd>and()</kbd>:</li>
</ol>
<pre style="padding-left: 60px">infix fun &lt;P1, R, R2&gt; ((P1) -&gt; R).and(function: (R) -&gt; R2): (P1) -&gt; R2 = {<br/><br/>}</pre>
<p class="mce-root"/>
<ol start="2">
<li>Invoke the base function and the one passed as an argument of <kbd>and()</kbd> internally:</li>
</ol>
<pre style="padding-left: 60px">infix fun &lt;P1, R, R2&gt; ((P1) -&gt; R).and(function: (R) -&gt; R2): (P1) -&gt; R2 = {<br/>    function(this(it))<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In order to explore our function composition implementation, let's use the <kbd>and()</kbd> function to compose the <kbd>isCharCountEven()</kbd> function using the <kbd>length()</kbd> property and the <kbd>isEven()</kbd> function:</p>
<pre>fun length(word: String) = word.length<br/>fun isEven(x:Int): Boolean = x.rem(2) == 0<br/>val isCharCountEven: (word: String) -&gt; Boolean = ::length and ::isEven<br/>print(isCharCountEven("pneumonoultramicroscopicsilicovolcanoconiosis"))</pre>
<p>The preceding code is going to return the following output:</p>
<pre><strong>false</strong></pre>
<p>Under the hood, the <kbd>and()</kbd> extension function just invokes the given two functions one inside another. However, thanks to the infix notation we can perform the composition in the code while avoiding nested function calls. Moreover, the result of the <kbd>::length and ::isEven</kbd> call in the preceding example returns a new function instance which can be easily reused, just like a normal function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the Either Monad design pattern</h1>
                
            
            
                
<p>The concept of Monad is one of the fundamental functional programming design patterns. We can understand a Monad as an encapsulation for a data type that adds a specific functionality to it or provides custom handlers for different states of the encapsulated object. One of the most commonly used is a Maybe monad. The Maybe monad is supposed to provide information about the enclosed property presence. It can return an instance of the wrapped type whenever it's available or nothing when it's not. Java 8 introduced the <kbd>Optional&lt;T&gt;</kbd> class, which is implementing the Maybe concept. It's a great way to avoid operating on null values.</p>
<p class="mce-root"/>
<p>However, apart from having the information about the unavailable state, we would often like to be able to provide some additional information. For example, if the server returns an empty response, it would be useful to get an error code or a message instead of the <kbd>null</kbd> or an empty response string. This is a scenario for another type of Monad, usually called <kbd>Either</kbd>, which we are going to implement in this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare <kbd>Either</kbd> as a <kbd>sealed</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">sealed class Either&lt;out E, out V&gt;</pre>
<ol start="2">
<li>Add two subclasses of <kbd>Either</kbd>, representing Error and Value:</li>
</ol>
<pre style="padding-left: 60px">sealed class Either&lt;out L, out R&gt; {<br/>    data class Left&lt;out L&gt;(val left: L) : Either&lt;L, Nothing&gt;()<br/>    data class Right&lt;out R&gt;(val right: R) : Either&lt;Nothing, R&gt;()<br/>}</pre>
<ol start="3">
<li>Add factory functions for the convenient instantiating of <kbd>Either</kbd>:</li>
</ol>
<pre style="padding-left: 60px">sealed class Either&lt;out L, out R&gt; {<br/>    data class Left&lt;out L&gt;(val left: L) : Either&lt;L, Nothing&gt;()<br/>    data class Right&lt;out R&gt;(val right: R) : Either&lt;Nothing, R&gt;()<br/><br/>    companion object {<br/>        fun &lt;R&gt; right(value: R): Either&lt;Nothing, R&gt; = <br/>         Either.Right(value)<br/>        fun &lt;L&gt; left(value: L): Either&lt;L, Nothing&gt; = <br/>         Either.Left(value)<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In order to make use of the class <kbd>Either</kbd> and benefit from the <kbd>Either.right()</kbd> and <kbd>Either.left()</kbd> methods, we can implement a <kbd>getEither()</kbd> function that will try to perform some operation passed to it as a parameter. If the operation succeeds, it is going to return the <kbd>Either.Right</kbd> instance holding the result of the operation, otherwise, it is going to return <kbd>Either.Left</kbd>, holding a thrown exception instance:</p>
<pre>fun &lt;V&gt; getEither(action: () -&gt; V): Either&lt;Exception, V&gt; =<br/>        try { Either.right(action()) } catch (e: Exception) { Either.left(e) }</pre>
<p>By convention, we use the <kbd>Either.Right</kbd> type to provide a default value and <kbd>Either.Left</kbd> to handle any possible edge cases.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>One of the essential functional programming features the <kbd>Either</kbd> Monad can provide, is the ability to apply functions to its values. We can simply extend the <kbd>Either</kbd> class with the <kbd>fold()</kbd> function, which can take two functions as the parameters. The first function that should be applied to the <kbd>Either.Left</kbd> type and second, that should be applied to <kbd>Either.Right</kbd>:</p>
<pre>sealed class Either&lt;out L, out R&gt; {<br/>    data class Left&lt;out L&gt;(val left: L) : Either&lt;L, Nothing&gt;()<br/>    data class Right&lt;out R&gt;(val right: R) : Either&lt;Nothing, R&gt;()<br/><br/>    fun &lt;T&gt; fold(leftOp: (L) -&gt; T, rightOp: (R) -&gt; T): T = when (this) {<br/>        is Left -&gt; leftOp(this.left)<br/>        is Right -&gt; rightOp(this.right)<br/>    }<br/><br/>  //...<br/>}</pre>
<p>The <kbd>fold()</kbd> function is going to return a value from either the <kbd>leftOp</kbd> or <kbd>rightOp</kbd> function, whichever is used. We can illustrate the usage of the <kbd>fold()</kbd> function with a server-request parsing example.</p>
<p>Let's say we have the following types declared:</p>
<pre>data class Response(val json: JsonObject)<br/>data class ErrorResponse(val code: Int, val message: String)</pre>
<p>We also have a function responsible for delivering a backend response:</p>
<pre>fun someGetRequest(): Either&lt;ErrorResponse, Response&gt; = //..</pre>
<p>We can use the <kbd>fold()</kbd> function to handle the returned value in the right way:</p>
<pre>someGetRequest().fold({<br/>    showErrorInfo(it.message)<br/>}, {<br/>    parseAndDisplayResults(it.json)<br/>})</pre>
<p class="mce-root"/>
<p>We could also extend the <kbd>Either</kbd> class with other useful functions similar to the ones available in the standard library for data-processing operations—<kbd>map</kbd>, <kbd>filter</kbd>, and <kbd>exists</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Approach to automatic functions memoization </h1>
                
            
            
                
<p class="mce-root">Memoization is a technique used to optimize the program-execution speed by caching the results of expensive function calls and reusing their ready values when they are required again. Although memoization causes an obvious trade-off between memory usage and computation time, often it's crucial to provide the desired performance. Usually, we apply this pattern to computationally-expensive functions. It can help to optimize recursive functions that call themselves multiple times with the same parameters' values. Memoization can easily be added internally to function implementation. However, in this recipe, we are going to create a general-purpose, reusable memoization mechanism that could be applied to any function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a <kbd>Memoizer</kbd> class responsible for caching the results:</li>
</ol>
<pre style="padding-left: 60px">class Memoizer&lt;P, R&gt; private constructor() {<br/><br/>    private val map = ConcurrentHashMap&lt;P, R&gt;()<br/><br/>    private fun doMemoize(function: (P) -&gt; R):<br/>        (P) -&gt; R = { param: P -&gt;<br/>        map.computeIfAbsent(param) { param: P -&gt;<br/>                    function(param)<br/>                }<br/>            }<br/><br/>    companion object {<br/>        fun &lt;T, U&gt; memoize(function: (T) -&gt; U): (T) -&gt; U =<br/>                Memoizer&lt;T, U&gt;().doMemoize(function)<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>Provide a <kbd>memoized()</kbd> extension function for the <kbd>(P) -&gt; R</kbd> function type:</li>
</ol>
<pre style="padding-left: 60px">fun &lt;P, R&gt; ((P) -&gt; R).memoized(): (P) -&gt; R = Memoizer.memoize&lt;P, R&gt;(this)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>memoize()</kbd> function takes an instance of a one-argument function as its argument. The <kbd>Memoizer</kbd> class contains the <kbd>ConcurrentHashmap&lt;P, R&gt;</kbd> instance, which is used to cache the function's return values. The map stores functions passed to <kbd>memoize()</kbd> as arguments as the keys, and it puts their return values as its values. First, the <kbd>memoize()</kbd> function looks up the value for a specific param of the function passed as an argument. If the value is present in the map, it is returned. Otherwise, the function is executed and its result is both returned by <kbd>memoize()</kbd> and put into the map. This is achieved using the handy <kbd>inline fun &lt;K, V&gt; ConcurrentMap&lt;K, V&gt;.computeIfAbsent(key: K, defaultValue: () -&gt; V): V</kbd> extension function provided by the standard library.</p>
<p>Additionally, we provide an extension function <kbd>memoized()</kbd> for the <kbd>Function1</kbd> type that allows us to apply the <kbd>memoize()</kbd> function directly to the function references.</p>
<p>Under the hood functions in Kotlin are compiled to the <kbd>FunctionN</kbd> interface instances in the Java bytecode, where <kbd>N</kbd> corresponds to the number of function arguments. Thanks to that fact, we are able to declare an extension function for a function. For example, in order to add an extension function for the function taking two arguments, <kbd>(P, Q) -&gt; R</kbd>, we need to define an extension as <kbd>fun &lt;P, Q, R&gt; Function2&lt;P, Q, R&gt;.myExtension(): MyReturnType</kbd>.</p>
<p>Now, let's take a look at how we could benefit from the <kbd>memoized()</kbd> function in action. Let's consider a function that computes the factorial of an integer recursively:</p>
<pre>fun factorial(n: Int): Long = if (n == 1) n.toLong() else n * factorial(n - 1)</pre>
<p>We can apply the <kbd>memoized()</kbd> extension function to enable results-caching:</p>
<pre>val cachedFactorial = ::factorial.memoized()<br/>println(" Execution time: " + measureNanoTime { cachedFactorial(12) } + " ns")<br/>println(" Execution time: " + measureNanoTime { cachedFactorial(13) } + " ns")</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The preceding code gives the following output on a standard computer:</p>
<pre><strong>Execution time: 1547274 ns</strong><br/><strong>Execution time: 24690 ns</strong></pre>
<p>As you can see, even though the second computation requires a higher number of recursive calls of the <kbd>factorial()</kbd> function, it takes much less time than the first computation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<div><div><div><p>We could implement similar automatic memoization implementations for the other functions that take more than one argument. In order to declare an extension function for a function taking <em>N</em> arguments, we'd have to implement an extension function for the <kbd>FunctionN</kbd> type.</p>
</div>
</div>
</div>


            

            
        
    </body></html>