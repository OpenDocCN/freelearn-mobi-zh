- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Integrating SpriteKit into Your SwiftUI Projects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将SpriteKit集成到你的SwiftUI项目中
- en: In this chapter, we will dive deeper into the world of animation in SwiftUI
    and create some mini-projects, highlighting different animations that can be made
    using other techniques and the SpriteKit framework. Some of the animations will
    be simpler, some will be more complex, and some will be dynamic and interactive
    animations too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探索SwiftUI中的动画世界，并创建一些小型项目，突出展示可以使用其他技术和SpriteKit框架制作的动画。一些动画将比较简单，一些将更复杂，还有一些将是动态和交互式的动画。
- en: You will learn how to take advantage of the power of **SpriteKit** and **particle
    emitters**. SpriteKit is a game development framework that provides a convenient
    and efficient way to create 2D games for iOS and macOS platforms. Particle emitters,
    on the other hand, are powerful tools in the SpriteKit framework that allow you
    to create special effects such as fire, smoke, rain, wind, explosions, and more.
    These emitters will bring life to your apps, making them visually stunning and
    engaging for users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学会如何利用**SpriteKit**和**粒子发射器**的强大功能。SpriteKit是一个游戏开发框架，它为iOS和macOS平台提供了创建2D游戏的便捷和高效方式。另一方面，粒子发射器是SpriteKit框架中的强大工具，它允许你创建特殊效果，如火焰、烟雾、雨、风、爆炸等。这些发射器将为你的应用带来活力，使其在视觉上令人惊叹，并吸引用户。
- en: 'So, here are the topics we will cover in this final chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是我们在本章最后将要涵盖的主题：
- en: Animating pipe smoke
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画管道烟雾
- en: Animating coffee steam
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画咖啡蒸汽
- en: Animating rocket fire
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画火箭火焰
- en: Animating a blizzard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画暴风雪
- en: Animating rain
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画雨
- en: Animating a magic wand
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画魔法棒
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the completed projects and their code in the `Chapter 15` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上的`Chapter 15`文件夹中找到完成的项目及其代码：[https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Animating pipe smoke
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画管道烟雾
- en: In this project, we will create a smoke effect using SpriteKit’s **Smoke** template,
    and make it come out of an image of a pipe. This is a good first project, as it’s
    not too complicated and gets you familiar with creating the needed **SpriteKit
    Scene** (**SKS**) particle file and how to configure it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用SpriteKit的**Smoke**模板创建烟雾效果，并使其从管道图片中冒出。这是一个很好的入门项目，因为它并不复杂，让你熟悉创建所需的**SpriteKit场景**（**SKS**）粒子文件以及如何配置它。
- en: Let’s get started, first create a new SwiftUI project, and call it `Pipe Smoke`.
    We are going to need a couple of images for this project so you can grab them
    over at GitHub (`Chapter 15` | `Pipe Smoke`) and add them to the project’s Assets
    catalog. Now it’s time to create a SpriteKit particle file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，首先创建一个新的SwiftUI项目，并将其命名为`Pipe Smoke`。为了这个项目，我们需要几幅图片，你可以在GitHub上（`Chapter
    15` | `Pipe Smoke`）找到它们，并将它们添加到项目的Assets目录中。现在，是时候创建一个SpriteKit粒子文件了。
- en: Creating a SpriteKit particle file
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SpriteKit粒子文件
- en: Next, let’s create a new file; this will be a SpriteKit particle file. The **SpriteKit
    Scene** (**SKS**) **particle file** is a scene file that has information about
    the particle system it contains, such as the shape, size, and position of the
    particle emitter, as well as the type of particles that will be emitted, their
    behavior, and movements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个新的文件；这将是一个SpriteKit粒子文件。**SpriteKit场景**（**SKS**）**粒子文件**是一个包含粒子系统信息的场景文件，例如粒子发射器的形状、大小和位置，以及将要发射的粒子的类型、行为和运动。
- en: To create an SKS particle file, in Xcode, you simply need to go to **File**
    | **New** | **File** | **SpriteKit Particle File**, or press *Command + N* to
    bring up the template options, and scroll down until you come to a template called
    **SpriteKit Particle File**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个SKS粒子文件，在Xcode中，你只需转到**文件** | **新建** | **文件** | **SpriteKit粒子文件**，或者按*Command
    + N*来显示模板选项，然后向下滚动直到你看到一个名为**SpriteKit粒子文件**的模板。
- en: 'Now, we need to choose the type of template we want. There are several options
    and we’re going to explore them individually in separate projects, but the one
    we want now is **Smoke**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要选择我们想要的模板类型。有几个选项，我们将分别在不同的项目中探索它们，但现在我们想要的模板是**Smoke**：
- en: '![Figure 15.1: Particle template options ](img/B18674_15_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1：粒子模板选项](img/B18674_15_01.jpg)'
- en: 'Figure 15.1: Particle template options'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：粒子模板选项
- en: 'Once you click `Smoke`, choose a save location, and then click **Create**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击`Smoke`，选择一个保存位置，然后点击**创建**：
- en: '![Figure 15.2: Creating the Smoke.sks file ](img/B18674_15_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2：创建Smoke.sks文件](img/B18674_15_02.jpg)'
- en: 'Figure 15.2: Creating the Smoke.sks file'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：创建Smoke.sks文件
- en: Now, you will see a new particle file in your Xcode editor that has a smoke
    animation playing. That’s because we chose the **Smoke** template, so the particles
    are pre-configured to produce smoke. This smoke will need to be adjusted so it’s
    not as wide and thick. We want the effect to be thin and small enough that we
    can make it come out of a pipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在你的Xcode编辑器中看到一个新粒子文件，其中正在播放烟雾动画。这是因为我们选择了**烟雾**模板，所以粒子已经预先配置为产生烟雾。这种烟雾需要调整，使其不那么宽厚。我们希望效果足够薄小，可以从管道中冒出。
- en: 'To configure the smoke, go to the right side of Xcode and you’ll see four buttons;
    if you click on the fourth button, you open up the **Attributes** panel, which
    is where we can configure our particle file to create an infinite number of effects:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置烟雾，转到Xcode的右侧，你会看到四个按钮；如果你点击第四个按钮，就会打开**属性**面板，这是我们配置粒子文件以创建无限多种效果的地方：
- en: '![Figure 15.3: Xcode’s Attributes panel ](img/B18674_15_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3：Xcode的属性面板](img/B18674_15_03.jpg)'
- en: 'Figure 15.3: Xcode’s Attributes panel'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：Xcode的属性面板
- en: There are quite a few settings in this panel, and since we will be creating
    different particle files in this chapter, it’s a good idea to have an understanding
    of what each field does. So, I will explain each field in order for you to create
    this first project in the chapter, and you can use these definitions for reference
    as you continue working through the other projects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板中有相当多的设置，由于我们将在本章中创建不同的粒子文件，了解每个字段的作用是个好主意。因此，我将按顺序解释每个字段，以便你创建本章的第一个项目，并且你可以将这些定义作为你在继续处理其他项目时的参考。
- en: Name
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称
- en: The **Name** field is used to give a unique identifier to the particle emitter
    so that you can easily reference it within your code or in the editor. The field
    is a string value that you can set to anything you like, as long as it’s unique
    within the file. By giving your particle emitters descriptive names, they will
    act as a reminder of what they do and how they’re used in your project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称**字段用于为粒子发射器提供一个唯一的标识符，这样你就可以在你的代码或编辑器中轻松地引用它。该字段是一个字符串值，你可以将其设置为任何你喜欢的名称，只要它在文件中是唯一的即可。通过为你的粒子发射器赋予描述性的名称，它们将作为它们所执行的操作以及在你项目中如何使用的提醒。'
- en: Additionally, you can use the **Name** field to access the particle emitter
    and modify its properties programmatically in your code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用**名称**字段来访问粒子发射器，并在你的代码中以编程方式修改其属性。
- en: Background
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景
- en: The **Background** field lets you set the background color of the editor. Sometimes,
    it’s useful to adjust this color to help make the particles stand out more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**背景**字段允许你设置编辑器的背景颜色。有时，调整此颜色以帮助使粒子更加突出是有用的。'
- en: Texture
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理
- en: The **Texture** field is used to specify the image file that will be used as
    the particle texture. The particle texture is essentially the appearance of the
    particles, and you can use any image file you like to create a wide range of particle
    effects. For example, you could use a simple dot or circle image for a simple
    particle effect, or a more complex image with multiple shapes and colors for a
    more elaborate effect. When you specify a particle texture in the **Attributes**
    panel, it will be used for all of the particles in the particle emitter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**纹理**字段用于指定用作粒子纹理的图像文件。粒子纹理基本上是粒子的外观，你可以使用任何你喜欢的图像文件来创建各种粒子效果。例如，你可以使用简单的点或圆形图像来创建简单的粒子效果，或者使用具有多种形状和颜色的更复杂图像来创建更复杂的效果。当你指定粒子纹理在**属性**面板中时，它将用于粒子发射器中的所有粒子。'
- en: Emitter
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发射器
- en: '**Emitter** is the object that defines the characteristics of a particle, such
    as its initial position, speed, and lifetime.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**发射器**是定义粒子特性的对象，例如其初始位置、速度和寿命。'
- en: The **Emitter Birthrate** field specifies the number of particles that are emitted
    per second. It determines how quickly the particles will be generated by the emitter
    – a higher birthrate will result in more particles being emitted in a shorter
    amount of time, while a lower birthrate will result in fewer particles being emitted
    over a longer period of time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**发射器出生率**字段指定每秒发射的粒子数量。它决定了发射器生成粒子的速度——较高的出生率会在较短时间内发射更多粒子，而较低的出生率会在较长时间内发射较少粒子。'
- en: The **Emitter Maximum** field sets the maximum number of particles that can
    exist at one time in the particle system. If **Birthrate** is set to a high value
    and **Maximum** is set to a low value, the emitter will emit particles at the
    specified rate until the maximum limit is reached. Once the maximum number of
    particles has been reached, the emitter will stop emitting new particles until
    some of the existing particles have disappeared. This allows you to control the
    overall number of particles in your particle system and optimize performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**发射最大值**字段设置粒子系统中一次可以存在的最大粒子数。如果**出生率**设置为高值且**最大值**设置为低值，发射器将以指定的速率发射粒子，直到达到最大限制。一旦达到最大粒子数，发射器将停止发射新的粒子，直到一些现有的粒子消失。这允许您控制粒子系统中粒子的总数并优化性能。'
- en: Lifetime
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生命周期
- en: The **Lifetime** fields specify the amount of time that each particle in a particle
    system will be active before it disappears.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命周期**字段指定粒子系统中的每个粒子在消失之前将活跃的时间长度。'
- en: The **Lifetime Start** field specifies the length of time for which each particle
    will exist in the particle system. It determines how long each particle will stay
    visible in the scene before disappearing. A higher value will result in particles
    staying visible for a longer period of time, while a lower value will result in
    particles disappearing more quickly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命周期起始**字段指定每个粒子在粒子系统中存在的时间长度。它决定了每个粒子在场景中保持可见的时间长度，然后消失。较高的值将导致粒子保持可见的时间更长，而较低的值将导致粒子更快消失。'
- en: The **Lifetime Range** field sets the range of values that the **Lifetime**
    property can take. Instead of specifying a fixed value for the lifetime, you can
    specify a range of values, and the particle system will randomly choose a value
    from that range for each particle that is emitted. This allows you to add variation
    to your particle system, making it look more organic and natural. For example,
    if you set **Lifetime Start** to **1.0** and **Lifetime Range** to **0.5**, each
    particle’s lifetime will be a random value between 0.5 and 1.5 seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**生命周期范围**字段设置**生命周期**属性可以取的值范围。您可以为生命周期指定一个固定值，而不是指定一个值范围，粒子系统将为每个发射的粒子从这个范围中随机选择一个值。这允许您为粒子系统添加变化，使其看起来更加自然和有机。例如，如果您将**生命周期起始**设置为**1.0**，将**生命周期范围**设置为**0.5**，则每个粒子的生命周期将是介于0.5秒和1.5秒之间的随机值。'
- en: Position Range
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置范围
- en: The **Position Range** fields specify the range of values for the initial position
    of the particles in each dimension – **X**, **Y**, and **Z** – allowing you to
    create particle systems that emit particles from a random position within a defined
    area. The particle system will randomly choose a position from within the specified
    range for each particle that is emitted, which can help add variety and realism
    to your particle systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置范围**字段指定粒子在每个维度（**X**、**Y**和**Z**）中初始位置值的范围，允许您创建从定义区域内随机位置发射粒子的粒子系统。粒子系统将为每个发射的粒子从指定范围内随机选择一个位置，这有助于为粒子系统添加多样性和现实感。'
- en: Angle
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角度
- en: The **Angle** fields in an SKS particle file control the initial direction and
    spread of particles when they are emitted. **Angle Start** sets the starting direction
    of the particles, while **Angle Range** determines the range of possible directions;
    the system then randomly chooses an angle within the range for each particle emitted.
    **Angle Start** is measured in degrees, with 0 degrees pointing to the right,
    and **Angle Range** specifies the spread of angles in a counterclockwise direction,
    again measured in degrees.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在SKS粒子文件中的**角度**字段控制粒子在发射时的初始方向和扩散。**角度起始**设置粒子的起始方向，而**角度范围**确定可能的方向范围；系统随后为每个发射的粒子在这个范围内随机选择一个角度。**角度起始**以度为单位测量，0度指向右侧，**角度范围**指定逆时针方向的角度扩散，同样以度为单位。
- en: Speed
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度
- en: The **Speed** fields control the initial speed and variation of particles when
    emitted in an SKS particle file. **Speed Start** sets the starting speed, while
    **Speed Range** specifies the possible range of speeds; a random speed is then
    chosen within the specified range for each emitted particle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**速度**字段控制当在SKS粒子文件中发射粒子时的初始速度和变化。**速度起始**设置起始速度，而**速度范围**指定可能的速度范围；然后为每个发射的粒子在指定范围内选择一个随机速度。'
- en: Adjusting these fields allows you to create various particle effects, with a
    higher value resulting in faster particles and a lower value in slower particles.
    For example, setting **Speed Start** to **100** and **Speed Range** to **0** will
    emit particles at a constant speed, while setting **Speed Start** to **50** and
    **Speed Range** to **25** will create particles with varying speeds between 25
    and 75\. These values are generally understood to be points per second.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调整这些字段允许您创建各种粒子效果，值越高，粒子速度越快，值越低，粒子速度越慢。例如，将**Speed Start**设置为**100**，将**Speed
    Range**设置为**0**将发射以恒定速度运动的粒子，而将**Speed Start**设置为**50**，将**Speed Range**设置为**25**将创建速度在25到75之间的可变速度粒子。这些值通常被认为是每秒点数。
- en: Acceleration
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加速度
- en: The **Acceleration X** and **Acceleration Y** fields control the acceleration
    of the particles in the *x* and *y* directions respectively. For example, you
    could set **Acceleration X** to **0** and **Acceleration Y** to **-100** to create
    a particle system that is affected by gravity, causing the particles to fall downward.
    Alternatively, you could set **Acceleration X** to **50** and **Acceleration Y**
    to **0** to create a particle system that moves to the right at a constant rate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Acceleration X**和**Acceleration Y**字段分别控制粒子在*x*和*y*方向上的加速度。例如，您可以将**Acceleration
    X**设置为**0**，将**Acceleration Y**设置为**-100**，以创建受重力影响的粒子系统，使粒子向下坠落。或者，您可以将**Acceleration
    X**设置为**50**，将**Acceleration Y**设置为**0**，以创建以恒定速度向右移动的粒子系统。'
- en: The **Acceleration X** and **Acceleration Y** fields are specified in points
    per second squared; positive values will cause the particles to accelerate in
    the positive direction, while negative values will cause the particles to decelerate
    or accelerate in the opposite direction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Acceleration X**和**Acceleration Y**字段以每秒平方点为单位指定；正值将使粒子向正方向加速，而负值将使粒子减速或向相反方向加速。'
- en: Alpha
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Alpha
- en: '`.sks` file refers to the opacity or transparency of particles in a particle
    system. The alpha value controls how much of the particle is visible, with a higher
    value making the particle more visible and a lower value making the particle more
    transparent.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sks`文件指的是粒子系统中粒子的不透明度或透明度。alpha值控制粒子的可见程度，值越高，粒子越明显，值越低，粒子越透明。'
- en: The **Alpha Start** field specifies the starting alpha value for the particles,
    which can be used to control their initial transparency. The **Alpha Range** field
    specifies the range of possible alpha values that the particles can take, and
    when the particle emitter emits a particle, it will choose a random alpha value
    within the specified range. The **Alpha Speed** field specifies the rate at which
    the alpha value of the particles will change over time, and can be used to control
    the rate of fade-in or fade-out of the particles; a positive value for this field
    will cause the particles to fade in over time, while a negative value will cause
    the particles to fade out over time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Alpha Start**字段指定粒子的起始alpha值，可用于控制其初始透明度。**Alpha Range**字段指定粒子可能采取的alpha值的范围，当粒子发射器发射粒子时，它将在指定范围内选择一个随机的alpha值。**Alpha
    Speed**字段指定alpha值随时间变化的速率，可用于控制粒子的淡入或淡出速率；此字段的正值将使粒子随时间逐渐淡入，而负值将使粒子随时间逐渐淡出。'
- en: By adjusting the **Alpha Start**, **Alpha Range**, and **Alpha Speed** fields,
    you can control the transparency of the particles over their lifetime and create
    a wide range of particle effects. For example, you could set **Alpha Start** to
    **1** and **Alpha Range** to **0** to emit particles with a constant alpha value
    or set **Alpha Start** to **1**, **Alpha Range** to **0**, and **Alpha Speed**
    to **-0.5** to emit particles that fade out over time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整**Alpha Start**、**Alpha Range**和**Alpha Speed**字段，您可以控制粒子在其生命周期内的透明度，并创建各种粒子效果。例如，您可以将**Alpha
    Start**设置为**1**，将**Alpha Range**设置为**0**，以发射具有恒定alpha值的粒子，或者将**Alpha Start**设置为**1**，**Alpha
    Range**设置为**0**，将**Alpha Speed**设置为**-0.5**，以发射随时间逐渐消失的粒子。
- en: Scale
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放
- en: The **Scale** fields control the size of the particles over their lifetime.
    The **Scale Start** field specifies the starting size of the particles, which
    can be used to control their initial size. The **Scale Range** field specifies
    the range of possible sizes that the particles can take, and when the particle
    emitter emits a particle, it will choose a random size within the specified range.
    The **Scale Speed** field specifies the rate at which the size of the particles
    will change over time, and can be used to control the rate of growth or shrinkage
    of the particles; a positive value for this will cause the particles to grow over
    time, while a negative value will cause the particles to shrink over time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩放**字段控制粒子在其生命周期内的尺寸。**缩放起始**字段指定了粒子的起始尺寸，可以用来控制它们的初始大小。**缩放范围**字段指定了粒子可能采取的尺寸范围，当粒子发射器发射粒子时，它将在指定的范围内选择一个随机的大小。**缩放速度**字段指定了粒子尺寸随时间变化的速率，可以用来控制粒子生长或缩小的速率；此字段的正值将导致粒子随时间生长，而负值将导致粒子随时间缩小。'
- en: As an example of using **Scale**, you could set **Scale Start** to **1** and
    **Scale Range** to **0** to emit particles with a constant size or set **Scale
    Start** to **1**, **Scale Range** to **0.5**, and **Scale Speed** to **0.1** to
    emit particles that grow over time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用**缩放**的示例，你可以将**缩放起始**设置为**1**，**缩放范围**设置为**0**以发射具有恒定大小的粒子，或者将**缩放起始**设置为**1**，**缩放范围**设置为**0.5**，**缩放速度**设置为**0.1**以发射随时间生长的粒子。
- en: Rotation
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: The **Rotation Start** field specifies the starting rotation of the particles,
    which can be used to control their initial orientation. The **Rotation Range**
    field specifies the range of possible rotations that the particles can take, and
    when the particle emitter emits a particle, it will choose a random rotation within
    the specified range. The **Rotation Speed** field specifies the rate at which
    the rotation of the particles will change over time, and can be used to control
    the rate of rotation of the particles; a positive value will cause the particles
    to rotate clockwise, while a negative value will cause the particles to rotate
    counterclockwise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**旋转起始**字段指定了粒子的起始旋转，这可以用来控制它们的初始方向。**旋转范围**字段指定了粒子可能采取的旋转范围，当粒子发射器发射粒子时，它将在指定的范围内选择一个随机的旋转。**旋转速度**字段指定了粒子旋转随时间变化的速率，可以用来控制粒子旋转的速度；正值将使粒子顺时针旋转，而负值将使粒子逆时针旋转。'
- en: You could set **Rotation Start** to **0** and **Rotation Range** to **0** to
    emit particles with a constant orientation or set **Rotation Start** to **0**,
    **Rotation Range** to **180**, and **Rotation Speed** to **180** to emit particles
    that rotate rapidly over time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将**旋转起始**设置为**0**，**旋转范围**设置为**0**以发射具有恒定方向的粒子，或者将**旋转起始**设置为**0**，**旋转范围**设置为**180**，**旋转速度**设置为**180**以发射随时间快速旋转的粒子。
- en: Color Blend
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色混合
- en: The **Color Blend** fields control the color of the particles over their lifetime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色混合**字段控制粒子在其生命周期内的颜色。'
- en: The **Color Blend Factor** field specifies the amount of color blending that
    will be applied to the particles. When the particle emitter emits a particle,
    it will choose a random color blend factor within the specified range. The particle’s
    color will be blended with the color of the particle’s texture according to this
    blend factor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色混合因子**字段指定了将应用于粒子的颜色混合量。当粒子发射器发射粒子时，它将在指定的范围内选择一个随机的颜色混合因子。粒子的颜色将根据这个混合因子与粒子纹理的颜色混合。'
- en: The **Color Blend Factor Range** field specifies the range of possible color
    blend factors that the particles can take. A value of **0** will result in no
    color blending, while a value of **1** will result in full color blending.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色混合因子范围**字段指定了粒子可能采取的颜色混合因子的范围。值为**0**将导致没有颜色混合，而值为**1**将导致完全颜色混合。'
- en: The **Color Blend Factor Speed** field specifies the rate at which the color
    blend factor of the particles will change over time, and can be used to control
    the rate at which the particles’ color will change. A positive value for the **Color
    Blend Factor Speed** field will cause the color of the particles to change over
    time, while a negative value will cause the color of the particles to change in
    reverse.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色混合因子速度**字段指定了颜色混合因子随时间变化的速率，可以用来控制粒子颜色变化的速率。**颜色混合因子速度**字段的正值将导致粒子颜色随时间变化，而负值将导致粒子颜色反向变化。'
- en: Looking an example, you could set **Color Blend Factor** to **0**, **Color Blend
    Factor Range** to **0**, and **Color Blend Factor Speed** to **0** to emit particles
    with constant color, or set **Color Blend Factor** to **1**, **Color Blend Factor
    Range** to **1**, and **Color Blend Factor Speed** to **0.1** to emit particles
    that change color rapidly over time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个示例来看，您可以将**颜色混合因子**设置为**0**，**颜色混合因子范围**设置为**0**，以及**颜色混合因子速度**设置为**0**来发射具有恒定颜色的粒子，或者将**颜色混合因子**设置为**1**，**颜色混合因子范围**设置为**1**，以及**颜色混合因子速度**设置为**0.1**来发射随时间快速改变颜色的粒子。
- en: Color Ramp
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色渐变
- en: The **Color Ramp** field is used to specify a range of colors that particles
    can take on over their lifetime. The colors are defined using a ramp, which is
    a gradient that blends two or more colors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色渐变**字段用于指定粒子在其生命周期内可以采取的颜色范围。颜色是通过渐变定义的，渐变是两种或多种颜色的渐变。'
- en: '**Color Ramp** allows you to create particle effects with changing colors.
    By default, particles will be emitted with a single color, but by adjusting **Color
    Ramp**, you can set the particles to a fixed range of colors, change color over
    time, or randomize the color within a range. For example, you could set **Color
    Ramp** to shades of red and yellow to create a fire effect or shades of blue and
    white for a snow effect.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**颜色渐变**允许您创建具有变化颜色的粒子效果。默认情况下，粒子将以单色发射，但通过调整**颜色渐变**，您可以设置粒子为固定范围的多种颜色，随时间改变颜色，或随机化范围内的颜色。例如，您可以将**颜色渐变**设置为红色和黄色的阴影以创建火焰效果，或蓝色和白色的阴影以创建雪效果。'
- en: Additionally, **Color Ramp** can be used to create different blending modes,
    such as additive or subtractive blending. The blending mode determines how the
    colors of the particles are combined with the colors of the background or other
    particles in the scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**颜色渐变**还可以用于创建不同的混合模式，如加法混合或减法混合。混合模式决定了粒子的颜色如何与背景或场景中的其他粒子的颜色结合。
- en: Blend Mode
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合模式
- en: Blending is a process that combines the colors of the particles with the colors
    of the objects behind them on the screen. The **Blend Mode** field determines
    how the colors of the particles and the background will be combined.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 混合是一个过程，它将屏幕上粒子的颜色与它们后面的物体的颜色结合起来。**混合模式**字段决定了粒子的颜色和背景颜色如何结合。
- en: There are several blend modes available in SpriteKit, the choice of which depends
    on the desired visual effect for the particles. For example, the **Alpha** blend
    mode will blend the colors of the particles and the background by taking the alpha
    channel of the particle’s color into account. The **Add** blend mode will add
    the colors of the particles and the background together. The **Multiply** blend
    mode will multiply the colors of the particles and the background together.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit中提供了几种混合模式，选择哪种取决于对粒子所需视觉效果的期望。例如，**Alpha**混合模式会考虑粒子的颜色通道的透明度来混合粒子和背景的颜色。**加**混合模式会将粒子和背景的颜色相加。**乘**混合模式会将粒子和背景的颜色相乘。
- en: By adjusting the blend mode, you can control how the colors of the particles
    are blended with the colors of the objects behind them and create a wide range
    of particle effects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整混合模式，您可以控制粒子的颜色如何与它们后面的物体的颜色混合，并创建广泛的粒子效果。
- en: Field Mask
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 场域掩码
- en: '**Field Mask** takes an integer value that is used to specify a masking bit-field,
    and the bit-field defines which properties of the particle are affected by the
    mask. For example, if the bit-field includes the position bit, the mask will affect
    the position of the particles. If it includes the color bit, the mask will affect
    the color of the particles. By setting the value of **Field Mask**, you can control
    which properties of the particles are affected by the mask. This allows you to
    create complex and sophisticated particle effects.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**场域掩码**接受一个整数值，用于指定一个掩码位字段，位字段定义了粒子的哪些属性受掩码影响。例如，如果位字段包括位置位，掩码将影响粒子的位置。如果包括颜色位，掩码将影响粒子的颜色。通过设置**场域掩码**的值，您可以控制粒子的哪些属性受掩码影响。这允许您创建复杂和精细的粒子效果。'
- en: For example, you could set **Field Mask** to include the position bit, which
    would cause the mask to affect the position of the particles, and create particles
    that follow a specific path or shape. Otherwise, you could set **Field Mask**
    to include the color bit, which would cause the mask to affect the color of the
    particles, and create particles with a specific color scheme or pattern.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以将**字段掩码**设置为包含位置位，这将导致掩码影响粒子的位置，并创建出遵循特定路径或形状的粒子。否则，你可以将**字段掩码**设置为包含颜色位，这将导致掩码影响粒子的颜色，并创建出具有特定颜色方案或模式的粒子。
- en: Custom Shader
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义着色器
- en: The **Custom Shader** field allows you to specify a custom shader to be used
    to render the particles.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义着色器**字段允许你指定用于渲染粒子的自定义着色器。'
- en: A **shader** is a program that runs on the GPU and is used to define the appearance
    and behavior of the particles. By using a custom shader, you can create complex
    and sophisticated particle effects that would be difficult or impossible to achieve
    using the built-in properties of the particle emitter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**着色器**是一个在GPU上运行的程序，用于定义粒子的外观和行为。通过使用自定义着色器，你可以创建出复杂而精致的粒子效果，这些效果使用粒子发射器的内置属性难以实现或根本无法实现。'
- en: For example, you could use a custom shader to create particles that respond
    to changes in the environment, such as light or shadows, or create particles that
    change shape or appearance over time. To use one, you need to write the shader
    code in a language such as **OpenGL Shading Language** (**GLSL**) and then specify
    the shader code as the value of the **Custom Shader** field. Once you have specified
    the custom shader, SpriteKit will use it to render the particles, giving you complete
    control over the appearance and behavior of the particles. By combining custom
    shaders with other properties of the particle emitter, such as **Birthrate**,
    **Lifetime**, and **Position Range**, you can create a wide range of sophisticated
    and visually stunning particle effects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用自定义着色器来创建对环境变化（如光线或阴影）做出反应的粒子，或者创建随时间改变形状或外观的粒子。要使用它，你需要用类似于**OpenGL着色语言**（**GLSL**）的语言编写着色器代码，然后指定着色器代码作为**自定义着色器**字段的值。一旦指定了自定义着色器，SpriteKit就会使用它来渲染粒子，从而让你完全控制粒子的外观和行为。通过将自定义着色器与其他粒子发射器的属性（如**出生率**、**生命周期**和**位置范围**）结合使用，你可以创建出广泛而视觉上令人惊叹的粒子效果。
- en: Now, we have looked at all of the customization fields for the particle system.
    I know it can be a bit overwhelming, which is why I defined each field in the
    file so you can refer to it when you’re building your particle system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经查看了粒子系统的所有自定义字段。我知道这可能会有些令人不知所措，这就是为什么我在文件中定义了每个字段，以便你在构建粒子系统时可以参考。
- en: 'Let’s use the following values to alter the smoke so it is similar to the smoke
    that you would see coming from a pipe. I have worked out all the values; you just
    need to fill them in:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下值来改变烟雾，使其类似于从管道中看到的烟雾。我已经计算出所有值；你只需要填写它们：
- en: '![Figure 15.4: Attributes for the pipe smoke animation ](img/B18674_15_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4：管道烟雾动画属性](img/B18674_15_04.jpg)'
- en: 'Figure 15.4: Attributes for the pipe smoke animation'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：管道烟雾动画属性
- en: Make sure your file has those same values as well before proceeding, which will
    give you the correct smoke you need to come out of the pipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你的文件也有相同的值，这将为你提供从管道中出来的正确烟雾。
- en: Integrating the Smoke file into a SwiftUI View
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将烟雾文件集成到SwiftUI视图中
- en: Before we get started with this section, a little bit of explanation is needed
    as to what the SpriteKit framework is all about and how it works. As I mentioned
    at the beginning of this chapter, SpriteKit is a game development framework that
    provides a convenient and efficient way to create 2D games for iOS and macOS platforms.
    Using the SpriteKit framework, you can create different sprites for your animation
    or game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始本节之前，需要稍微解释一下SpriteKit框架是什么以及它是如何工作的。正如我在本章开头提到的，SpriteKit是一个游戏开发框架，它为iOS和macOS平台提供了创建2D游戏的一种方便且高效的方式。使用SpriteKit框架，你可以为你的动画或游戏创建不同的精灵。
- en: A sprite is represented by the `SKSpriteNode` class, which is a node that can
    display a textured image. A sprite can be thought of as a single frame of an animation
    and it can be moved, rotated, and scaled and have physics applied to it. A single
    sprite can also have multiple textures, allowing it to change appearance. In a
    game, sprites are used to represent characters, objects, and backgrounds.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵由 `SKSpriteNode` 类表示，这是一个可以显示纹理图像的节点。精灵可以被视为动画的单帧，它可以移动、旋转和缩放，并且可以应用物理属性。单个精灵也可以有多个纹理，允许它改变外观。在游戏中，精灵用于表示角色、对象和背景。
- en: You can create a sprite by initializing `SKSpriteNode` with an image or texture
    and then adding it to an `SKScene`. Once added to a scene, a sprite can be manipulated
    using various properties and methods, such as position, scale, and rotation, and
    you can also add actions, physics, and gestures to it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用图像或纹理初始化 `SKSpriteNode` 并将其添加到 `SKScene` 中来创建一个精灵。一旦添加到场景中，精灵就可以使用各种属性和方法进行操作，例如位置、缩放和旋转，你还可以向其添加动作、物理属性和手势。
- en: '`SKView` is a `UIView` subclass that is used to display and interact with SpriteKit
    scenes. It acts as the container for an `SKScene` and provides the necessary infrastructure
    for displaying and animating sprites. An `SKScene` is a container for all the
    sprites in a SpriteKit-based project. It is responsible for updating and rendering
    the sprites, and also provides a way to handle user interactions with the sprites.
    A scene can also contain other nodes such as labels and shapes in addition to
    sprites. Each scene can have its own set of sprites, physics, and interactions.
    You will become more familiar with sprites and nodes as we progress through the
    projects in this chapter.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKView` 是一个 `UIView` 子类，用于显示和交互 SpriteKit 场景。它作为 `SKScene` 的容器，并为显示和动画精灵提供必要的基础设施。`SKScene`
    是基于 SpriteKit 的项目中所有精灵的容器。它负责更新和渲染精灵，并提供处理用户与精灵交互的方式。场景还可以包含其他节点，如标签和形状，除了精灵之外。每个场景都可以有自己的精灵集、物理属性和交互。随着我们在这个章节的项目中不断前进，你将更加熟悉精灵和节点。'
- en: 'Let’s do some coding now. Go into `ContentView`, and we will create a smoke
    view struct in which we can use our `Smoke.sks` file. The first thing we need
    to do is import the SpriteKit framework so that we have access to the classes
    and methods. Add this line of code at the top of `ContentView`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在进行一些编码。进入 `ContentView`，我们将创建一个烟雾视图结构体，在其中我们可以使用我们的 `Smoke.sks` 文件。我们首先需要做的是导入
    SpriteKit 框架，以便我们可以访问类和方法。在 `ContentView` 的顶部添加以下代码行：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s create that `SmokeView` struct I mentioned by adding this under
    the `ContentView` struct:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我提到的那个 `SmokeView` 结构体，通过在 `ContentView` 结构体下添加以下内容：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s how the `SmokeView` struct works, line by line. Bear in mind that the
    SpriteKit framework uses methods and classes we have not used before, so the code
    may seem unfamiliar at first; as you work through the chapter though, you will
    understand it very quickly because it is Swift code after all, and is very readable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何逐行工作 `SmokeView` 结构体。请注意，SpriteKit 框架使用的是我们之前未使用过的方法和类，所以代码一开始可能看起来不熟悉；然而，随着你在这个章节中继续工作，你会很快理解它，因为毕竟它是
    Swift 代码，并且非常易于阅读：
- en: This code starts off by defining a struct named `SmokeView`, which is used to
    display the smoke effect that we configured in the `Smoke.sks` file. The struct
    conforms to the `UIViewRepresentable` protocol. This allows the struct to be used
    as a SwiftUI view.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码首先定义了一个名为 `SmokeView` 的结构体，该结构体用于显示我们在 `Smoke.sks` 文件中配置的烟雾效果。该结构体遵循 `UIViewRepresentable`
    协议。这使得结构体可以用作 SwiftUI 视图。
- en: Next, we add the `makeUIView` method, which is required by the `UIViewRepresentable`
    protocol. It creates and returns `SKView`, which is used to display the smoke
    effect.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们添加 `makeUIView` 方法，这是 `UIViewRepresentable` 协议所要求的。它创建并返回 `SKView`，用于显示烟雾效果。
- en: Then, we create an instance of `SKView` with a specified frame (size and position).
    This frame is used to determine the size of the smoke effect.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个具有指定框架（大小和位置）的 `SKView` 实例。这个框架用于确定烟雾效果的大小。
- en: We set the `backgroundColor` property of the `SKView` instance to `clear`. This
    means that the background of the view will be transparent and will not have a
    solid color background; this way, any underlying views or graphics can show through.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `SKView` 实例的 `backgroundColor` 属性设置为 `clear`。这意味着视图的背景将是透明的，并且不会有实色背景；这样，任何下层的视图或图形都可以显示出来。
- en: We create an instance of `SKScene` with a specified `size` property, which determines
    the size of the smoke effect, and a background `color` value of `clear` so that
    the background of the smoke effect will be transparent.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个具有指定`size`属性的`SKScene`实例，该属性确定烟雾效果的大小，以及背景`color`值为`clear`，这样烟雾效果的背景将是透明的。
- en: Next, we create an instance of `SKEmitterNode` using the particle system defined
    in the `Smoke.sks` file. The guard `let` statement is used to check whether the
    file was loaded correctly and if not, it returns an empty `SKView`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用在`Smoke.sks`文件中定义的粒子系统创建一个`SKEmitterNode`实例。使用`guard let`语句来检查文件是否正确加载，如果没有，则返回一个空的`SKView`。
- en: Then, we position the smoke effect in the center of the scene; set the blend
    mode to `SKBlendMode.screen`, which will make the smoke blend with the background;
    set the initial scale of the smoke particles, which will make the particles smaller
    and thinner; and set the range of the scale of the smoke particles.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将烟雾效果放置在场景的中心；将混合模式设置为`SKBlendMode.screen`，这将使烟雾与背景混合；设置烟雾粒子的初始缩放，这将使粒子更小、更细；并设置烟雾粒子缩放的范围。
- en: The `addChild` method is called on the `scene` instance, passing in the `smoke`
    node as an argument. This adds the particle emitter node as a child node to the
    scene, meaning it will be displayed in the scene.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`scene`实例上调用`addChild`方法，传入`smoke`节点作为参数。这将粒子发射器节点作为子节点添加到场景中，意味着它将在场景中显示。
- en: The `presentScene` method is called on the `view` instance, passing in the `scene`
    instance as an argument. This sets the scene as the currently displayed scene
    in the view.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`view`实例上调用`presentScene`方法，传入`scene`实例作为参数。这将设置场景为当前视图显示的场景。
- en: Then, the `return` keyword returns the `view` instance.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`return`关键字返回`view`实例。
- en: The `updateUIView` function is called when the view needs to be updated, such
    as when the view’s state changes. In this code, we leave it empty, as it is not
    needed in our example.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当视图需要更新时，会调用`updateUIView`函数，例如当视图的状态发生变化时。在这段代码中，我们将其留空，因为在我们这个例子中不需要它。
- en: To summarize, the code creates and returns an `SKView` instance that displays
    a SpriteKit particle emitter as a SwiftUI view. Now, we have a `SmokeView` ready
    to go and display the smoke.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段代码创建并返回一个`SKView`实例，该实例显示一个SpriteKit粒子发射器作为SwiftUI视图。现在，我们有一个准备好的`SmokeView`来显示烟雾。
- en: 'Let’s come into `ContentView` and add a background for the scene, and a smiley
    image that has a pipe in his mouth. Then, we will call the `SmokeView` we just
    created to put the smoke into the pipe. To do this, modify `ContentView` like
    so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入`ContentView`并为场景添加一个背景，以及一个嘴巴里有烟斗的笑脸图片。然后，我们将调用我们刚刚创建的`SmokeView`将烟雾放入烟斗中。为此，修改`ContentView`如下：
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we have done here is create a `ZStack` and put our image of the smiley,
    which is called `pipe`, into the scene. Then, we resized it with `width` and `height`
    values of `350` points and called our `SmokeView`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是创建一个`ZStack`，并将我们的笑脸图片（称为`pipe`）放入场景中。然后，我们使用`width`和`height`值为`350`点的值来调整其大小，并调用我们的`SmokeView`。
- en: Next, we positioned the smoke so that it is directly above the pipe and appears
    to come out of the pipe, achieved with the `offset` modifier. Finally, we add
    the background right onto the `ZStack`, and the project is finished.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将烟雾定位在管道正上方，使其看起来是从管道中冒出来的，这是通过`offset`修饰符实现的。最后，我们将背景直接添加到`ZStack`上，项目就完成了。
- en: 'If you run the project, you’ll see realistic pipe smoke coming out of the pipe:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行项目，你会看到从管道中冒出的逼真的烟雾：
- en: '![Figure 15.5: The pipe smoke animation ](img/B18674_15_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5：管道烟雾动画](img/B18674_15_05.jpg)'
- en: 'Figure 15.5: The pipe smoke animation'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：管道烟雾动画
- en: Now that you know how to create smoke and have a basic foundation of how to
    get the SpriteKit particle system operational in our SwiftUI project, let’s continue
    and solidify what you know and use the **Smoke** template once again, but vary
    the values to create a different effect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建烟雾，并且在我们SwiftUI项目中有了SpriteKit粒子系统的基本操作基础，让我们继续巩固你所知道的知识，并再次使用**Smoke**模板，但改变值以创建不同的效果。
- en: Animating coffee steam
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画咖啡蒸汽
- en: In this next project, we’ll modify the particle system file to create steam
    that we can use to create a steaming cup of coffee animation. Well also look at
    a technique where we can place the steam directly inside the coffee by overlapping
    images. To get started, create a new project and call it `Coffee`, and then we’ll
    move on to creating the SpriteKit particle file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个下一个项目中，我们将修改粒子系统文件以创建可以用于制作蒸汽咖啡动画的蒸汽。我们还将查看一种技术，可以通过重叠图像将蒸汽直接放置在咖啡中。要开始，创建一个新的项目并将其命名为
    `Coffee`，然后我们将继续创建 SpriteKit 粒子文件。
- en: Creating the Smoke SpriteKit particle file
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Smoke SpriteKit 粒子文件
- en: To create the file, like before, press *Command + N*, choose the **SpriteKit
    Particle File** template, and let’s pick **Smoke** from the particle template
    options again (yes, **Smoke** again, but we will make it look like steam this
    time).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件，就像之前一样，按 *Command + N*，选择 **SpriteKit 粒子文件** 模板，然后再次选择粒子模板选项中的 **Smoke**（是的，又是
    **Smoke**，但这次我们将使其看起来像蒸汽）。
- en: 'Now, we will modify the various properties to create our animation. Change
    all the properties in your SKS file to look like the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将修改各种属性以创建我们的动画。将你的 SKS 文件中的所有属性更改为以下图示：
- en: '![Figure 15.6: The attributes of the coffee steam animation ](img/B18674_15_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6：咖啡蒸汽动画的属性](img/B18674_15_06.jpg)'
- en: 'Figure 15.6: The attributes of the coffee steam animation'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：咖啡蒸汽动画的属性
- en: All of those properties have been explained in the previous project. If you’re
    unclear as to what each one does, revisit that section for a refresher.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性都在之前的项目中解释过了。如果你对每个属性的作用不清楚，请回顾那个部分以进行复习。
- en: Creating the Coffee Steam struct
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Coffee Steam 结构体
- en: 'Next, let’s go back into the `ContentView` file and we’ll start assembling
    the project. In the previous project, we learned how to use the `.sks` file inside
    the SwiftUI view, and we’re going to do almost the exact same thing here too.
    The first thing we did was create a separate struct and use the `UIViewRepresentable`
    protocol to use the `.sks` file within a SwiftUI view. So, in this project, underneath
    `ContentView`, add the following struct:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们回到 `ContentView` 文件，并开始组装项目。在之前的项目中，我们学习了如何在 SwiftUI 视图中使用 `.sks` 文件，我们在这里也将做几乎完全相同的事情。我们首先创建了一个单独的结构体，并使用
    `UIViewRepresentable` 协议在 SwiftUI 视图中使用 `.sks` 文件。因此，在这个项目中，在 `ContentView` 之下添加以下结构体：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I explained this code in the previous project, but I will go over it again
    to help solidify your understanding:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我在之前的项目中解释了这段代码，但我会再次讲解它，以帮助你巩固理解：
- en: The code starts off by defining a custom SwiftUI view named `CoffeeSteam`, which
    is used to display the steam effect that we configured in the `CoffeeSteam.sks`
    file. The struct conforms to the `UIViewRepresentable` protocol. This allows the
    struct to be used as a SwiftUI view.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码首先定义了一个名为 `CoffeeSteam` 的自定义 SwiftUI 视图，用于显示我们在 `CoffeeSteam.sks` 文件中配置的蒸汽效果。该结构体符合
    `UIViewRepresentable` 协议。这使得结构体可以用作 SwiftUI 视图。
- en: Next, we add the `makeUIView` method, which is required by the `UIViewRepresentable`
    protocol. It creates and returns an `SKView`, which is used to display the steam
    effect.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们添加 `makeUIView` 方法，这是 `UIViewRepresentable` 协议要求的。它创建并返回一个 `SKView`，用于显示蒸汽效果。
- en: We create an instance of `SKView` with a specified frame (size and position).
    This frame is used to determine the size of the steam effect.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个具有指定框架（大小和位置）的 `SKView` 实例。这个框架用于确定蒸汽效果的大小。
- en: We set the `backgroundColor` property of the `SKView` instance to `clear`. This
    means that the background of the view will be transparent and will not have a
    solid color background; this way, any underlying views or graphics can show through.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `SKView` 实例的 `backgroundColor` 属性设置为 `clear`。这意味着视图的背景将是透明的，并且不会有实色的背景；这样，任何下层的视图或图形都可以显示出来。
- en: Then, we create an instance of `SKScene` with a specified size, which is used
    to determine the size of the steam effect, and set the background color to `clear`;
    this way, the background of the steam effect will be transparent too.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个指定大小的 `SKScene` 实例，用于确定蒸汽效果的大小，并将背景颜色设置为 `clear`；这样，蒸汽效果的背景也将是透明的。
- en: Next, we create an instance of `SKEmitterNode` using the particle system defined
    in the `CoffeeSteam.sks` file. The guard `let` statement is used to check whether
    the file was loaded correctly and if not, it returns an empty `SKView`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用在 `CoffeeSteam.sks` 文件中定义的粒子系统创建一个 `SKEmitterNode` 实例。`guard let` 语句用于检查文件是否正确加载，如果没有，则返回一个空的
    `SKView`。
- en: Then, we position the steam in the center of the scene; set the blend mode of
    the steam to `SKBlendMode.screen`, which will help to make the steam blend in
    with the background; set the initial scale of the steam particles to help them
    resemble a steam effect; then, we set the range of the scale of the smoke particles.
    (Again, refer to the previous project where I defined each of these property fields
    in the SKS file).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将蒸汽定位在场景的中心；将蒸汽的混合模式设置为 `SKBlendMode.screen`，这将有助于使蒸汽与背景混合；设置蒸汽粒子的初始缩放以帮助它们看起来像蒸汽效果；然后，我们设置烟雾粒子的缩放范围。（再次参考之前的项目，我在
    SKS 文件中定义了每个这些属性字段）。
- en: The `addChild` method is called on the `scene` instance, passing in the `steam`
    node as an argument. This adds the particle emitter node as a child node to the
    scene, meaning it will be displayed in the scene.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `scene` 实例上调用 `addChild` 方法，传入 `steam` 节点作为参数。这会将粒子发射器节点作为子节点添加到场景中，意味着它将在场景中显示。
- en: The `presentScene` method is called on the `view` instance, passing in the `scene`
    instance as an argument. This sets the scene as the currently displayed scene
    in the view.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `view` 实例上调用 `presentScene` 方法，传入 `scene` 实例作为参数。这会将场景设置为当前视图显示的场景。
- en: Then, the `return` keyword returns the `view` instance.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`return` 关键字返回 `view` 实例。
- en: The `updateUIView` function is called when the view needs to be updated, such
    as when the view’s state changes. In this code, we leave it empty, as it is not
    needed in our example.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当视图需要更新时，会调用 `updateUIView` 函数，例如当视图的状态发生变化时。在这段代码中，我们将其留空，因为在我们这个例子中不需要它。
- en: So, all that code creates and returns an `SKView` instance that displays a SpriteKit
    particle emitter as a SwiftUI view. Noticed that I am setting some of the properties
    in code here? You have the option of setting the properties in the SKS file by
    adjusting the values there, or you can set them in code here; however, remember
    that when you set them in code, they override anything you set in the SKS file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有这些代码创建并返回一个显示 SpriteKit 粒子发射器作为 SwiftUI 视图的 `SKView` 实例。注意，我在这里设置了一些属性？你可以通过调整
    SKS 文件中的值来设置属性，或者你可以在这里通过代码设置它们；然而，记住当你通过代码设置时，它们会覆盖 SKS 文件中设置的任何内容。
- en: Filling out ContentView
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成 `ContentView`
- en: Now, we can just do a little work in `ContentView` and display the steaming
    cup of coffee. If you haven’t already done so, drop the assets into the Asset
    Catalog that you can find in the `Chapter 15` folder titled `Coffee Steam` on
    GitHub.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `ContentView` 中进行一些工作，并显示冒着热气的咖啡杯。如果你还没有这样做，请将资产拖放到 GitHub 上 `Chapter
    15` 文件夹中名为 `Coffee Steam` 的资产库中。
- en: 'Let’s modify `ContentView` to look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `ContentView` 以使其看起来如下：
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code declares a `ZStack` that will hold our views. Inside `ZStack`, we add
    a background image, resize it, and set the aspect ratio on it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了一个 `ZStack`，它将包含我们的视图。在 `ZStack` 内部，我们添加了一个背景图片，调整了其大小，并设置了其宽高比。
- en: Then, the code declares another `ZStack`, where we placed the first image titled
    `cup`, resizing it and setting its aspect ratio as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代码声明了另一个 `ZStack`，我们在其中放置了第一个名为 `cup` 的图片，调整了其大小并设置了其宽高比。
- en: Next, we called the `CoffeeSteam` struct and offset it a little bit so it’s
    centered in the middle of the cup.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用了 `CoffeeSteam` 结构体，并稍微偏移了一下，使其位于杯子的中心。
- en: And after that, we added the `cup 2` image. This second image is used to make
    the steam appear as though it’s coming out of the center of the cup. So, what
    we’re essentially doing is sandwiching the animating steam in between two coffee
    cup images, in which one of the cup images has a little cut out in it; when we
    place the steam in between these two, we can create a nice steaming effect that
    appears to be originating from inside the coffee cup.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们添加了 `cup 2` 图片。这个第二张图片用于使蒸汽看起来像是从杯子中心冒出来的。所以，我们实际上是在两个咖啡杯图片之间夹着动画蒸汽，其中一个杯子的图片上有一个小缺口；当我们在这两个图片之间放置蒸汽时，我们可以创建一个看起来像是从咖啡杯内部发出的蒸汽效果。
- en: Finally, I called the `offset` modifier on the `ZStack` to position everything
    on the *y*-axis.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我在 `ZStack` 上调用了 `offset` 修饰符，将所有内容定位在 *y* 轴上。
- en: Now, run the project and you will see the steaming effect that’s coming right
    off the surface of the coffee. Also notice how the back of the cup glistens with
    the steam as it rises, as it would do in a real cup of coffee.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行项目，你将看到蒸汽效果正从咖啡的表面冒出来。同时注意，当蒸汽上升时，杯子的背面会因蒸汽而闪闪发光，就像在真实的咖啡杯中一样。
- en: '![Figure 15.7: A cup of steaming coffee ](img/B18674_15_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.7：一杯冒着热气的咖啡](img/B18674_15_07.jpg)'
- en: 'Figure 15.7: A cup of steaming coffee'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：一杯冒着热气的咖啡
- en: 'Now, we have completed two projects using the **Smoke** particle template –
    creating pipe smoke and coffee steam – and we understand how to manipulate the
    particles in very different ways. Let’s continue and move on to the next project,
    where we’ll use a different particle system: fire.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经使用**Smoke**粒子模板完成了两个项目——创建管道烟雾和咖啡蒸汽——并且我们了解了如何以非常不同的方式操纵粒子。让我们继续前进，进入下一个项目，我们将使用不同的粒子系统：火焰。
- en: Animating rocket fire
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 火箭火焰动画
- en: The SpriteKit Fire particle template generates particles that are typically
    colored shades of orange, yellow, and red, which give the impression of glowing
    embers and flames. The particles may also have a slight degree of transparency
    to mimic the flickering and shifting quality of a real fire. In terms of behavior,
    the particles are designed to move upward with a certain amount of randomness,
    representing the movement of hot air and flames.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit火焰粒子模板生成的粒子通常是橙色、黄色和红色的阴影，给人一种发光的火星和火焰的印象。粒子也可能有一定的透明度，以模仿真实火焰的闪烁和移动特性。在行为方面，粒子被设计成以一定程度的随机性向上移动，代表热空气和火焰的移动。
- en: Rather than creating some simple flames, though, we’re going to animate a rocket!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会创建一些简单的火焰，而是要动画一个火箭！
- en: Press *Command + N*, then choose the `Rocket`. Xcode will go ahead and create
    the fire particles that you can see them running in the editor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Command + N*，然后选择`Rocket`。Xcode将创建你可以看到在编辑器中运行的火焰粒子。
- en: Now, let’s create the SwiftUI view that will bring this `.sks` file into our
    SwiftUI project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个SwiftUI视图，将这个`.sks`文件引入我们的SwiftUI项目中。
- en: Adding FireView
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加FireView
- en: 'To create the view, press *Command + N* and make a `SwiftUIView` file. Then,
    call it `FireView`. Then, import SpriteKit, and add the following code at the
    top of the file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建视图，按*Command + N*，创建一个`SwiftUIView`文件。然后，将其命名为`FireView`。然后，导入SpriteKit，并在文件顶部添加以下代码：
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I’m not going to go over this code because we have done this already, but you
    can refer back to the previous SpriteKit projects for all the explanations, and
    how we use the `UIViewRepresentable` protocol.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细讲解这段代码，因为我们已经做过类似的事情，但你可以参考之前的SpriteKit项目，那里有所有的解释以及我们如何使用`UIViewRepresentable`协议。
- en: If you run a code in the previews, you’ll see that it works great and the fire
    is the correct dimensions to fit under the rocket. However, notice that the fire
    is upside down. Let’s look at how we can fix this so it looks like a proper thrust
    to place underneath a rocket.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行预览中的代码，你会看到它运行得很好，火焰的尺寸正确，可以放在火箭下面。然而，请注意火焰是倒置的。让我们看看我们如何修复它，使其看起来像火箭下面的正确推力。
- en: Adding RocketView
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加RocketView
- en: 'Let’s now create one more view that we can use to put together the rocket and
    the fire, then rotate the fire around so it’s properly oriented under the rocket.
    Press *Command + N*, create a new SwiftUI View file, and call it `RocketView`.
    Then, add the following code inside the struct:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个额外的视图，我们可以用它来组合火箭和火焰，然后旋转火焰，使其在火箭下方正确对齐。按*Command + N*，创建一个新的SwiftUI视图文件，并将其命名为`RocketView`。然后，在结构体内部添加以下代码：
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we create a `rocketAndFire` offset variable that we can use to move both
    the rocket and the fire upward on the screen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`rocketAndFire`偏移变量，我们可以用它来在屏幕上向上移动火箭和火焰。
- en: Then, inside the `ZStack`, we take `FireView` and rotate it 180°, and offset
    it on the *y*-axis, which makes the fire extend further out from the rocket, which
    we will add shortly. Then, we animate the fire upward by changing the `y`-`offset`,
    and positioning the fire in the center of the screen on the *x*- and *y*-axes
    using the `UIScreen` property.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`ZStack`内部，我们将`FireView`旋转180°，并在*y*-轴上偏移，这使得火焰从火箭延伸出去，我们将很快添加它。然后，通过改变`y`-`offset`，我们向上动画火焰，并使用`UIScreen`属性在*x*-和*y*-轴上将火焰定位在屏幕中央。
- en: Then, we can add the `rocket` image, resize it, and animate it upward by offsetting
    the *y*-axis using the `rocketAndFire` variable. Next, we just need to position
    the rocket in the center of the screen using the `UIScreen` property.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加`rocket`图像，调整其大小，并通过使用`rocketAndFire`变量向上动画它。接下来，我们只需使用`UIScreen`属性将火箭定位在屏幕中央。
- en: Finally, we can add the animation to the closing brace of the `ZStack`, which
    will act on both `FireView` and the rocket image. Let’s give it a duration of
    `8` seconds, and make it repeat forever with no auto-reverse.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将动画添加到`ZStack`的闭合括号中，这将同时作用于`FireView`和火箭图像。让我们给它设置`8`秒的持续时间，并使其无限重复，没有自动反转。
- en: Now, we can launch the rocket in the `onAppear` method by changing the value
    of the `rocketAndFire` property. When the view appears, the rocket will lift off
    and continue off the top of the screen and come back up from the bottom and keep
    flying.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`onAppear`方法中通过更改`rocketAndFire`属性的值来发射火箭。当视图出现时，火箭将起飞并继续飞离屏幕顶部，然后从底部飞回来并继续飞行。
- en: All we have to do now is add the background!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在只需要添加背景！
- en: Putting things together inside ContentView
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ContentView内部组合元素
- en: 'Inside `ContentView`, we need very little code to get our rocket into space:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContentView`内部，我们只需要很少的代码就能让我们的火箭进入太空：
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And that’s it. Inside the `ZStack`, we added `RocketView()` to the scene, and
    then we added the background image right onto `ZStack`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。在`ZStack`内部，我们添加了`RocketView()`到场景中，然后我们直接在`ZStack`上添加了背景图像。
- en: 'Check it out in the previews and you’ll see that we now have a rocket flying
    in space:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览中查看，你会发现我们现在有一个在太空中飞行的火箭：
- en: '![Figure 15.8: Our rocket blasting off ](img/B18674_15_08.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8：我们的火箭起飞](img/B18674_15_08.jpg)'
- en: 'Figure 15.8: Our rocket blasting off'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：我们的火箭起飞
- en: By leveraging the power of particle systems, we were able to create a realistic
    and dynamic visual effect that brings our rocket to life. We explored the various
    parameters and properties of the emitter to fine-tune the look and feel of the
    thrust and learned how to integrate it with our SwiftUI view.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用粒子系统的力量，我们能够创建一个逼真且动态的视觉效果，使我们的火箭栩栩如生。我们探讨了发射器的各种参数和属性，以微调推力的外观和感觉，并学习了如何将其与我们的SwiftUI视图集成。
- en: Looking at another example, we’re going to return to another effect that we’ve
    already seen before – snow – but modify it so it creates a blizzard-like effect.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看另一个例子，我们将回到之前已经看到过的另一个效果——雪——但修改它，使其产生暴风雪般的效果。
- en: Animating a blizzard
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画暴风雪
- en: In this next project, we’re going to create a blizzard scene, and add a wind
    effect to make the snow blow from different directions. We will also use that
    wind to make the branches of a tree blow as well, by combining images and animating
    them. We created a snow scene in the breathing flower project in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082),
    but this time, we’re going to create this snow scene using a particle file, which
    gives us more options for making and controlling the snow.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，我们将创建一个暴风雪场景，并添加一个风效，使雪花从不同的方向飘落。我们还将使用这个风使树的树枝飘动，通过组合图像并对其动画化来实现。我们在[*第6章*](B18674_06.xhtml#_idTextAnchor082)的呼吸花朵项目中创建了一个雪景，但这次，我们将使用粒子文件来创建这个雪景，这为我们提供了更多制作和控制雪的选项。
- en: Let’s start by creating a new project and calling it `Snow`. Then, we will get
    right to work creating the SKS file that we need for the snow – this time, though,
    we’ll create two files.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个新的项目并命名为`Snow`开始。然后，我们将立即着手创建所需的SKS文件来制作雪——不过这次，我们将创建两个文件。
- en: Creating two Snow SpriteKit particle files
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建两个Snow SpriteKit粒子文件
- en: For this project, we will create two SpriteKit files – both will be from the
    **Snow** template, but we will use different values so the snow blows from different
    directions and at different velocities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们将创建两个SpriteKit文件——这两个文件都将来自**Snow**模板，但我们将使用不同的值，以便雪花从不同的方向和不同的速度飘落。
- en: 'To create the first file, press *Command + N*, choose the `Snow`. Now, let’s
    configure the particle properties so we can create a nice heavy snowfall. Use
    the same values from the following figure:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建第一个文件，按*Command + N*，选择`Snow`。现在，让我们配置粒子属性，以便我们可以创建一个漂亮的厚重雪景。使用以下图中的相同值：
- en: '![Figure 15.9: The attributes for the Snow file ](img/B18674_15_09.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9：Snow文件的属性](img/B18674_15_09.jpg)'
- en: 'Figure 15.9: The attributes for the Snow file'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：Snow文件的属性
- en: 'And that creates the desired snowfall we are going for. To help you in designing
    your unique snowfall, the following is a guide for making adjustments:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这就创造了我们想要的所需雪景。为了帮助您设计独特的雪景，以下是一个调整指南：
- en: '**Particle Lifetime**: Set the lifetime to a relatively long time so that the
    particles stay on the screen for a while'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子寿命**：将寿命设置得相对较长，这样粒子就可以在屏幕上停留一段时间'
- en: '**Particle Birthrate**: Increase the birthrate to generate more particles per
    second, which will create a denser snowfall effect'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子出生率**：增加出生率，每秒生成更多粒子，这将创建一个更密集的下雪效果'
- en: '**Particle Size**: Increase the size of the particles to make them appear larger
    and more prominent on the screen'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子大小**：增加粒子的大小，使它们在屏幕上看起来更大、更突出'
- en: '**Particle Speed**: Decrease the speed of the particles to make them fall slower
    and more gently'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子速度**：降低粒子的速度，使它们下落得更慢、更温柔'
- en: '**Particle Color**: Change the color of the particles to white or light blue
    to make them look more like snowflakes'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子颜色**：将粒子的颜色改为白色或浅蓝色，使其看起来更像雪花'
- en: '**Emitter Shape**: Change the emitter shape to a rectangle or a line to make
    the snowfall appear more natural'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射器形状**：将发射器形状改为矩形或线条，使下雪看起来更自然'
- en: '**Emitter Position**: Adjust the emitter’s position to start the snowfall from
    the top of the screen'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射器位置**：调整发射器的位置，从屏幕顶部开始下雪'
- en: If you look at that snow in the editor, you can see that it has a pretty heavy
    effect, just what we need for our scene. Now, let’s create the second file with
    different values for the snow; we’ll then combine both of these SKS files into
    one SwiftUI view that we can use to create a nice blizzard effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看编辑器中的雪，你可以看到它有一个相当强烈的效果，这正是我们场景所需要的。现在，让我们创建第二个文件，并为雪设置不同的值；然后，我们将这两个SKS文件合并成一个SwiftUI视图，我们可以使用它来创建一个漂亮的暴风雪效果。
- en: 'Follow the same steps to create a second file, but this time, call it `Blustery`.
    Now, let’s alter the attributes to the following values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照相同的步骤创建第二个文件，但这次将其命名为`Blustery`。现在，让我们将属性更改为以下值：
- en: '![Figure 15.10: The attributes for the Blustery file ](img/B18674_15_10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10：Blustery文件的属性](img/B18674_15_10.jpg)'
- en: 'Figure 15.10: The attributes for the Blustery file'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：Blustery文件的属性
- en: This new file has different **Birthrate**, **Angle**, and **Acceleration** values
    to make the snow blow from different directions, as well as lift the snow up a
    little bit as if being carried by the wind. When we combine the two SKS files
    together, which will create a nice blizzard effect.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新文件有不同的**出生率**、**角度**和**加速度**值，使雪从不同的方向吹来，并且稍微提升一些，就像被风吹起一样。当我们合并这两个SKS文件时，这将创建一个很好的暴风雪效果。
- en: So, let’s do that now; we’ll need to create a struct in which you can put these
    two files together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在就做吧；我们需要创建一个结构体，可以将这两个文件放在一起。
- en: Creating a view that combines the two SKS files
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个结合两个SKS文件视图
- en: Working inside the `ContentView` file, first, add the SpriteKit import. Then,
    create a new struct called `SnowView` after the `ContentView` struct. (You could
    create separate files and keep things neat in the project navigator, but I’m just
    going to put the rest of the code into the `ContentView` file for this project.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContentView`文件内部工作，首先，添加SpriteKit导入。然后，在`ContentView`结构之后创建一个新的结构体`SnowView`。（你可以在项目中创建单独的文件，并在项目导航器中保持整洁，但为了这个项目，我打算将剩余的代码放入`ContentView`文件中。）
- en: 'With `SnowView` created, add the following code within it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`SnowView`后，在它内部添加以下代码：
- en: '[PRE8]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code positions both nodes, the `snow` node and the `blustery` node, using
    the `position` property, and then sets the `particlePositionRange` property on
    both as well. `particlePositionRange` is the range of allowed random values for
    a particle’s position. Finally, as we’ve done with our other particle files, we
    add them to the scene using the `addChild` function and passing in the view that
    we want to add to the scene.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用`position`属性定位了两个节点，即`snow`节点和`blustery`节点，并在两个节点上设置了`particlePositionRange`属性。`particlePositionRange`是粒子位置允许的随机值范围。最后，就像我们在其他粒子文件中所做的那样，我们使用`addChild`函数将它们添加到场景中，并传入我们想要添加到场景中的视图。
- en: 'Now, we can call this struct in `ContentView` to check out the blizzard, and
    in fact, let’s also add a background snow scene too:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`ContentView`中调用这个结构来查看暴风雪，实际上，我们还可以添加一个背景雪景：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the previews and check out the blizzard effect:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行预览并查看暴风雪效果：
- en: '![Figure 15.11: Our blizzard scene ](img/B18674_15_11.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图15.11：我们的暴风雪场景](img/B18674_15_11.jpg)'
- en: 'Figure 15.11: Our blizzard scene'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：我们的暴风雪场景
- en: Now, let’s continue with the project and add another animation to it. For this
    one, we want to make the branches of the tree blow in the wind.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行项目，并添加另一个动画。对于这个，我们想要让树的树枝随风飘动。
- en: Animating the tree branches
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画树树枝
- en: To animate the tree branches, we’re going to wrap all the code up into several
    `ZStack`. Then, we will use one image of a snowy branch, replicate it many times
    with a `ForEach` loop, place the branch images over a portion of the tree, and
    put rotation animations on each of the axes of those images. We will also randomize
    the animation so that it doesn’t follow a set pattern.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使树枝动画，我们将所有代码包裹在几个 `ZStack` 中。然后，我们将使用一个雪树枝的图像，通过 `ForEach` 循环多次复制它，将树枝图像放置在树的某个部分上，并在这些图像的每个轴上添加旋转动画。我们还将随机化动画，使其不遵循固定模式。
- en: 'Let’s start by creating the struct that we need to hold these views:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个结构体来保存这些视图：
- en: '[PRE10]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let’s add the variables we need to keep track of the animations and set
    some initial values:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加我们需要跟踪动画的变量并设置一些初始值：
- en: '[PRE11]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code defines five state properties in a SwiftUI view.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在 SwiftUI 视图中定义了五个状态属性。
- en: The `anglesX`, `anglesY`, and `anglesZ` properties are arrays of `Double` values,
    each with a length of `25`. These arrays are used to store the rotation angles
    around the *x*-, *y*-, and *z*-axes, respectively. The `repeating:` parameter
    is used to initialize all the values in each array to 0.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`anglesX`、`anglesY` 和 `anglesZ` 属性是长度为 `25` 的 `Double` 值数组。这些数组分别用于存储围绕 *x*、*y*
    和 *z* 轴的旋转角度。`repeating:` 参数用于将每个数组中的所有值初始化为 0。'
- en: The `positions` property is an array of `CGPoint` values, also with a length
    of `25`. This array is used to store the positions of the views. The `repeating:`
    parameter is used to initialize all the values in the array to the zero point,
    `(``0, 0)`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`positions` 属性是一个包含 `CGPoint` 值的数组，长度为 `25`。这个数组用于存储视图的位置。`repeating:` 参数用于将数组中的所有值初始化为零点（`0,
    0`）。'
- en: The `durations` property is an array of `Double` values, again with a length
    of `25`. This array is used to store the durations of the animations associated
    with each view. The `repeating:` parameter is used to initialize all the values
    in the array to 0.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`durations` 属性是一个长度为 `25` 的 `Double` 值数组。这个数组用于存储与每个视图相关的动画持续时间。`repeating:`
    参数用于将数组中的所有值初始化为 0。'
- en: As we have seen, the `@State` property wrapper is used to make each of these
    arrays a mutable state property of the view. This means that whenever any of the
    arrays are modified, SwiftUI will automatically re-render the view to reflect
    the changes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`@State` 属性包装器用于使这些数组成为视图的可变状态属性。这意味着每当任何数组被修改时，SwiftUI 将自动重新渲染视图以反映这些更改。
- en: 'Next, let’s move into the `body` property and add a `ZStack` that contains
    the image we want to manipulate and reproduce, as well as the animation we’re
    going to put on it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们进入 `body` 属性并添加一个包含我们想要操作和复制的图像以及我们将要放在其上的动画的 `ZStack`：
- en: '[PRE12]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here’s what we’re doing in here. We start off with a `ZStack` so we can stack
    our views on top of each other. Next is a `ForEach` loop, which iterates over
    a range of integers from 0 to 7; the `index` parameter is used to access the current
    iteration value in the loop.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们要做的是。我们首先使用一个 `ZStack`，这样我们就可以将视图堆叠在一起。接下来是一个 `ForEach` 循环，它遍历从 0 到 7 的整数范围；`index`
    参数用于访问循环中的当前迭代值。
- en: 'Then, we add the branch image and the following modifiers:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加分支图像和以下修饰符：
- en: The `resizable` modifier resizes the image.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resizable` 修饰符调整图像的大小。'
- en: The `rotationEffect(_:)` modifier is used to rotate the image around the *x*-,
    *y*-, and *z*-axes. The angle of rotation is specified by the corresponding value
    in the `anglesX`, `anglesY`, and `anglesZ` arrays, respectively. The `anchor`
    parameter is used to specify the center of rotation. In this case, `.center` is
    used for both the `anglesY` and `anglesZ` rotations, so the image is rotated around
    its center point.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotationEffect(_:)` 修饰符用于围绕 *x*、*y* 和 *z* 轴旋转图像。旋转角度由 `anglesX`、`anglesY`
    和 `anglesZ` 数组中的相应值指定。`anchor` 参数用于指定旋转中心。在这种情况下，`.center` 用于 `anglesY` 和 `anglesZ`
    的旋转，因此图像围绕其中心点旋转。'
- en: The `position(_:)` modifier is used to position the image on the screen. The
    `positions` array stores the position for each image instance based on its index.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position(_:)` 修饰符用于在屏幕上定位图像。`positions` 数组根据索引存储每个图像实例的位置。'
- en: The `frame(width:height:)` modifier sets the size of the image.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame(width:height:)` 修饰符设置图像的大小。'
- en: The `animation(_:, value:)` modifier is used to animate the rotation of the
    image. The duration of the animation is based on the value stored in the `durations`
    array, while the `value` parameter specifies that the animation should be re-evaluated
    whenever the `anglesX` array changes.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation(_:, value:)`修饰符用于动画化图像的旋转。动画的持续时间基于存储在`durations`数组中的值，而`value`参数指定了每当`anglesX`数组发生变化时，动画应该重新评估。'
- en: The `onAppear` modifier is used to randomly generate new values for the `anglesX`,
    `anglesY`, `anglesZ` positions, and `durations` arrays whenever an image appears
    on the screen.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAppear`修饰符用于在屏幕上出现图像时随机生成`anglesX`、`anglesY`、`anglesZ`位置和`durations`数组的值。'
- en: Finally, the `offset` modifier applies an offset of `50` points on the *x*-axis
    and `200` points on the *y*-axis to the entire `ZStack`, which positions the tree
    branches in the middle-right portion of the tree.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`offset`修饰符在*x*轴上应用了`50`点的偏移量，在*y*轴上应用了`200`点的偏移量到整个`ZStack`，这样就将树枝定位在树的中间右侧部分。
- en: To summarize, what we’re doing is creating eight image views of snow-covered
    branches, each with a different rotation, position, duration, and animation. The
    views are stacked on top of each other within `ZStack` and have an offset applied
    to place them in the tree.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们所做的是创建八个覆盖着雪的树枝的图像视图，每个视图都有不同的旋转、位置、持续时间和动画。这些视图在`ZStack`中堆叠在一起，并应用偏移量以将它们放置在树上。
- en: 'Now, I’d like to replicate the `ZStack` several more times so we can cover
    the whole tree with snowy branches, rather than covering only a portion of the
    tree. So, we’ll make four more ZStacks but with slightly different values to make
    the wind-blowing effect seem more random and natural:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我想将`ZStack`复制几次，这样我们就可以用雪枝覆盖整个树，而不仅仅是树的一部分。所以，我们将再创建四个`ZStack`，但使用略有不同的值，以使风吹效果看起来更随机和自然：
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All of these `ZStack` do essentially the same thing, except that the code uses
    different values. For example, in the `ForEach` loop, we’re using a different
    range of values, and we’re also changing the random values for the *x*-, *y*-,
    and *z*-axes, as well as the `position` and `duration` values. Also, each `ZStack`
    has its own `onAppear` modifier, so it could randomly move its set of branches
    at a different pace and on a different axis.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些`ZStack`基本上都做同样的事情，只是代码使用了不同的值。例如，在`ForEach`循环中，我们使用了一个不同的值范围，我们还改变了*x*、*y*、*z*轴的随机值，以及`position`和`duration`值。此外，每个`ZStack`都有自己的`onAppear`修饰符，因此它可以以不同的速度和不同的轴随机移动其分支集。
- en: 'Now, let’s call this struct inside `ContentView`. We will call it just before
    the `SnowView` call; this way, the snow will appear on top of the tree images:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`ContentView`内部调用这个结构。我们将在调用`SnowView`之前调用它；这样，雪就会出现在树图像的上方：
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, run the code and check out the really cool animation of the tree branches
    blowing in the wind as the snow falls.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行代码并查看树枝在雪落下时随风摇曳的真正酷炫的动画。
- en: Play around with all the values that we’ve used in the various parameters and
    customize them to your liking. Maybe you want fewer branches for a thinner-looking
    tree, maybe you want the wind to blow much stronger, or maybe you want to animate
    all the trees in the background image... you can change all the settings to do
    just that.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 玩转我们在各种参数中使用的所有值，并根据自己的喜好进行定制。也许你想要更少的分支以使树看起来更细，也许你想要风刮得更强，或者也许你想要在背景图像中动画化所有树木...你可以更改所有设置来实现这一点。
- en: Let’s continue our exploration of some interesting animations. Up next, we will
    look at the rain particle system.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索一些有趣的动画。接下来，我们将查看雨粒子系统。
- en: Animating rain
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化雨
- en: In our next project, let’s make it rain. We’re going to create a realistic effect
    by creating rain from the **Rain** particle template and making it bounce off
    the ground as you would see in a rainstorm. We’ll also create a puddle that will
    subtly grow and shrink, appearing to react to the falling rain, and it will also
    look like water, as we will add some blending options to it to give it a transparent
    look for a spectacular effect that even shows some of the ground underneath it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个项目中，让我们来一场雨。我们将通过从**雨**粒子模板创建雨，并使其像暴风雨中那样弹跳在地面上来创建一个逼真的效果。我们还将创建一个水坑，它会微妙地生长和收缩，看起来像是对外部下落的雨做出反应，并且它看起来也会像水一样，因为我们将在上面添加一些混合选项，使其看起来半透明，以达到一种壮观的效果，甚至可以看到其下的地面。
- en: Creating the Rain SpriteKit particle file
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建雨的SpriteKit粒子文件
- en: 'Let’s get started. You know how to do this now – create an SKS file, choose
    `Rain` too. Now, configure the file to have the following attributes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。你现在知道如何做了——创建一个SKS文件，选择`Rain`。现在，配置文件以具有以下属性：
- en: '![Figure 15.12: The attributes of the rain animation ](img/B18674_15_12.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12：雨动画的属性](img/B18674_15_12.jpg)'
- en: 'Figure 15.12: The attributes of the rain animation'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：雨动画的属性
- en: Using the **Rain** particle template gives us rain right out of the box, but
    with some slight adjustments to the **Birthrate** and **Lifetime** options, we
    can alter how much of a rainstorm we want.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Rain**粒子模板可以直接获得雨效果，但通过调整**出生率**和**生命周期**选项，我们可以改变我们想要的雨量大小。
- en: Let’s now create another new file, this time, a SwiftUI file, which we will
    use to bring the rain effects into a SwiftUI view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另一个新文件，这次是一个SwiftUI文件，我们将使用它将雨效果引入SwiftUI视图。
- en: Creating the raindrops
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建雨滴
- en: To create the SwiftUI file, press *Command + N* and call this file `DropView`.
    The code we will add to this file will be responsible for creating the collision
    effect between a raindrop and the ground. We’ll also alter the opacity and the
    blur to really help it blend into the scene.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建SwiftUI文件，请按*Command + N*，并将此文件命名为`DropView`。我们将添加到该文件中的代码将负责创建雨滴与地面之间的碰撞效果。我们还将调整不透明度和模糊度，以真正帮助它融入场景。
- en: 'Let’s now add the following code inside the `DropView` struct:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`DropView`结构体内部添加以下代码：
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There’s a lot going on here, so let’s break it down line by line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容，让我们逐行分析。
- en: 'There are four `State` variables we need and each one has a specific task:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要四个`State`变量，每个变量都有特定的任务：
- en: The first variable is of the `CGFloat` type and gets an initial value of `0.1`.
    This variable is used to control the scale of the drops.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个变量是`CGFloat`类型，初始值为`0.1`。这个变量用于控制雨滴的缩放。
- en: The next two variables create arrays of `CGFloat` values, stored in the `xOffsets`
    and `yOffsets` state variables. The `map` method is used to generate random `CGFloat`
    values and the `CGFloat.random(in:)` method is used to generate a random `CGFloat`
    value within a given range. In short, these variables are used to set a random
    *x*- and *y*-coordinate position for each drop.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的两个变量创建`CGFloat`值的数组，存储在`xOffsets`和`yOffsets`状态变量中。使用`map`方法生成随机`CGFloat`值，并使用`CGFloat.random(in:)`方法在给定范围内生成一个随机的`CGFloat`值。简而言之，这些变量用于为每个雨滴设置随机的*x*-和*y*-坐标位置。
- en: The final variable is the `durations` variable, which randomizes the duration
    of the animation.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个变量是`durations`变量，它随机化动画的持续时间。
- en: Let’s take a closer look at the `map` method since it is being used by three
    of our properties. The `map` method is a higher-order function in Swift that transforms
    an array of values into a new array of different values. It takes a closure expression
    as an argument, which is executed for each element in the original array and returns
    a new value for that element. The resulting array is then the combination of all
    of these new values.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看`map`方法，因为它被我们的三个属性使用。`map`方法是Swift中的一个高阶函数，它将一个值数组转换为一个新的不同值的数组。它接受一个闭包表达式作为参数，该闭包表达式对原始数组中的每个元素执行，并为该元素返回一个新值。结果数组是所有这些新值的组合。
- en: 'In the code, the `map` method is being used to transform the range of integers
    between 0 and <300 into an array of `CGFloat` values, by using the `CGFloat.random(in:)`
    method to generate a random value for each element in the range. The closure expression
    passed to the `map` method takes a single argument, `_`, which is a placeholder
    for the current element of the range, and returns a new `CGFloat` value, generated
    by `CGFloat.random(in: -150...UIScreen.main.bounds.width)`. The `map` method combines
    all of these new values into a single array, which is then assigned to the `xOffsets`
    variable.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '在代码中，`map`方法被用来将0到<300之间的整数范围转换为`CGFloat`值的数组，通过使用`CGFloat.random(in:)`方法为范围内的每个元素生成一个随机值。传递给`map`方法的闭包表达式接受一个参数，`_`，它是范围当前元素的占位符，并返回一个由`CGFloat.random(in:
    -150...UIScreen.main.bounds.width)`生成的新的`CGFloat`值。`map`方法将这些新值组合成一个单一的数组，然后将其分配给`xOffsets`变量。'
- en: The `map` method is an important and versatile function in Swift, as it allows
    you to easily transform arrays and sequences of values into new arrays and sequences.
    Additionally, the `map` method is often used in combination with other functional
    programming techniques such as filter and reduce, to perform complex operations
    on arrays and sequences in a more efficient and maintainable way.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`map` 方法是 Swift 中一个重要且多功能的函数，因为它允许你轻松地将数组值和序列转换为新的数组和序列。此外，`map` 方法通常与过滤和归约等其他函数式编程技术结合使用，以更高效、更易于维护的方式在数组和序列上执行复杂操作。'
- en: Now, let’s move into the `body` property and look at what the code is doing
    there.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入 `body` 属性，看看代码在那里做了什么。
- en: We use a `ForEach` loop to iterate through a range from 0 and <150, and create
    a `Circle` view with each iteration – the circle will be the raindrop. Then, we
    set the `fill` color of the `Circle` view to `white`, the `width` and `height`
    values to `15`, and apply a `scaleEffect` with the value determined by the `dropScale`
    variable.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `ForEach` 循环遍历从 0 到 <150 的范围，并在每次迭代中创建一个 `Circle` 视图——这个圆圈将代表雨滴。然后，我们将
    `Circle` 视图的 `fill` 颜色设置为 `white`，`width` 和 `height` 值设置为 `15`，并应用由 `dropScale`
    变量确定的 `scaleEffect`。
- en: Next, we apply `rotation3DEffect` to the `Circle` view, with an angle of 80
    degrees on the *x*-axis; we want to rotate the drop so that it appears more like
    a raindrop colliding with the ground. Following that, we set its offset using
    the `xOffsets` and `yOffsets` variables with a value determined by the index.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `rotation3DEffect` 应用到 `Circle` 视图上，在 *x* 轴上有一个 80 度的角度；我们想要旋转雨滴，使其看起来更像雨滴撞击地面。之后，我们使用
    `xOffsets` 和 `yOffsets` 变量设置偏移量，其值由索引确定。
- en: We then add the animation, setting the duration to be determined by the `index`
    constant, and repeating the animation with `autoreverse` set to `true` to create
    the realistic collision of the raindrop with the ground.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加动画，将持续时间设置为由 `index` 常量确定，并将 `autoreverse` 设置为 `true` 以创建雨滴与地面的逼真碰撞效果。
- en: Finally, in the `onAppear` modifier, we give the `DropScale` variable a value
    of `0.8`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `onAppear` 修饰符中，我们将 `DropScale` 变量的值设置为 `0.8`。
- en: Running that in the previews will be a little difficult to see because of the
    white background, but let’s keep going and we’ll check out the results shortly.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于白色背景，运行预览可能会稍微困难一些，但让我们继续并稍后检查结果。
- en: Let’s now create a new view that will make a puddle of water that we can animate
    and add to the scene.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的视图，它将创建一个可以动画并添加到场景中的水坑。
- en: Creating the puddle
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建水坑
- en: 'Let’s now add a puddle to our scene, which we’ll do in a new SwiftUI View file
    called `PuddleView`. I’m going to add all the code for this view and then we’ll
    review how it works:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的场景中添加一个水坑，我们将在一个新的 SwiftUI 视图文件 `PuddleView` 中完成。我将添加这个视图的所有代码，然后我们将审查其工作原理：
- en: '[PRE16]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code defines a struct called `PuddleView` that has two properties, `scaleX`
    and `scaleY`, which are both `CGFloat` values. The `body` property of the struct
    is defined as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了一个名为 `PuddleView` 的结构体，它有两个属性，`scaleX` 和 `scaleY`，它们都是 `CGFloat` 类型的值。结构体的
    `body` 属性定义如下：
- en: A `ZStack` view is created, which arranges views on top of each other.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个 `ZStack` 视图，它将视图堆叠在一起。
- en: 'Inside `ZStack`, a `Capsule` view is created, which will be the shape of a
    puddle. The `Capsule` view is filled with a `LinearGradient` of colors and is
    then modified with several modifiers:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ZStack` 内部，创建了一个 `Capsule` 视图，它将是水坑的形状。`Capsule` 视图填充了颜色渐变，然后通过几个修饰符进行修改：
- en: The `opacity` modifier is set to `0.5`, making it partially transparent.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity` 修饰符设置为 `0.5`，使其部分透明。'
- en: The `blur` modifier is set with a radius of `5` pixels.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur` 修饰符设置为半径为 `5` 像素的模糊效果。'
- en: The `frame` modifier sets the `width` property to `600` pixels and `height`
    to `500` pixels.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame` 修饰符将 `width` 属性设置为 `600` 像素，`height` 设置为 `500` 像素。'
- en: The `scaleEffect` modifier is set with the *x* and *y* scale values set to `scaleX`
    and `scaleY`, respectively. The `anchor` parameter is set to `.center`, indicating
    that the scaling should be the center of the capsule.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleEffect` 修饰符设置为 *x* 和 *y* 缩放值分别对应 `scaleX` 和 `scaleY`。`anchor` 参数设置为 `.center`，表示缩放应以胶囊的中心为基准。'
- en: The `animation` modifier has a `scaleX` value, with an `easeInOut` timing function
    and a `duration` value of `8` seconds, and is set to repeat forever with `autoreverses`.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation` 修饰符具有 `scaleX` 值，使用 `easeInOut` 时间函数和 `duration` 值为 `8` 秒，并设置为无限重复，带有
    `autoreverses`。'
- en: 'Then,`.overlay()` is used to create a new `Capsule` view that is placed on
    top of the previous one. This new `Capsule` view is also modified with several
    modifiers:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，使用`.overlay()`创建一个新的`Capsule`视图，并将其放置在之前的视图之上。这个新的`Capsule`视图也通过几个修改器进行了修改：
- en: The `stroke` modifier adds a gray stroke with a line width of `5` pixels.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke`修改器添加了一个线宽为`5`像素的灰色描边。'
- en: The `opacity` modifier is set to `0.5`, making it partially transparent.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity`修改器设置为`0.5`，使其部分透明。'
- en: The `frame` modifier sets the `width` property to `350` pixels and `height`
    to `200` pixels.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame`修改器将`width`属性设置为`350`像素，`height`设置为`200`像素。'
- en: The `offset` modifier shifts the capsule slightly upward.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`offset`修改器将胶囊稍微向上移动。'
- en: The `scaleEffect` modifier sets the *x* and *y* scale values, with `scaleX`
    set to `+ 0.03` and `scaleY` to `+ 0.03`, respectively. The `anchor` parameter
    is set to `.center`, indicating that the scaling should be centered on the capsule.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleEffect`修改器设置了*x*和*y*的缩放值，其中`scaleX`设置为`+ 0.03`，`scaleY`也设置为`+ 0.03`。`anchor`参数设置为`.center`，表示缩放应该以胶囊为中心。'
- en: The `animation` modifier has a `scaleY` value, with an `easeInOut` timing function
    and a `duration` value of `8` seconds, and is set to repeat forever with `autoreverses`.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`animation`修改器有一个`scaleY`值，使用`easeInOut`时间函数和`duration`值为`8`秒，设置为无限重复，并带有`autoreverses`。'
- en: The `onAppear` modifier sets the initial value of `scaleX` and `scaleY` to `0.54`
    and `0.6`, respectively.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAppear`修改器将`scaleX`和`scaleY`的初始值分别设置为`0.54`和`0.6`。'
- en: The `rotation3DEffect` modifiers set an angle of `81` degrees on the *x*-axis.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation3DEffect`修改器在*x*轴上设置了一个`81`度的角度。'
- en: 'The `ZStack` view is then modified with `.offset(x: -50, y: 300)` and `.onAppear
    { scaleX = 0.55; scaleY = 0.6 }`. This shifts the group view 50 pixels to the
    left and 300 pixels downward. This code block is executed when the view appears
    and sets the initial values of `scaleX` and `scaleY` to `0.55` and `0.6`, respectively.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '然后使用`.offset(x: -50, y: 300)`和`.onAppear { scaleX = 0.55; scaleY = 0.6 }`修改`ZStack`视图。这使组视图向左移动50像素，向下移动300像素。此代码块在视图出现时执行，并将`scaleX`和`scaleY`的初始值分别设置为`0.55`和`0.6`。'
- en: In summary, this code creates a view that looks like a puddle of water by using
    a gradient fill that’s partially transparent and blurred, and with a ripple effect
    added. The ripple effect is created by applying a scale effect to the second capsule
    view and animating the `scaleX` and `scaleY` properties so that it appears to
    be moving. The ripple effect is also rotated on the *x*-axis to make it more interesting.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段代码通过使用部分透明且模糊的渐变填充以及添加波纹效果来创建一个看起来像水坑的视图。波纹效果是通过将缩放效果应用于第二个胶囊视图，并动画化`scaleX`和`scaleY`属性来实现的，使其看起来在移动。波纹效果也在*x*轴上旋转，使其更加有趣。
- en: Putting it all together
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'With `PuddleView` done, let’s just fill out `ContentView` and check out the
    animation. Add the following code to modify `ContentView`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成`PuddleView`后，让我们填写`ContentView`并查看动画。添加以下代码以修改`ContentView`：
- en: '[PRE17]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `ContentView`, we added an image of a street, resized and scaled it, then
    called `PuddleView`. In `PuddleView`, `blendMode` is set to `hardLight`. Play
    around with the blend mode options for different looks and effects, but I think
    the hard light gives the best water effect so far, creating a glass-like look
    that is perfect for making a puddle of water where you can see some of the ground
    underneath.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ContentView`中，我们添加了一张街道的图片，调整了大小和比例，然后调用了`PuddleView`。在`PuddleView`中，`blendMode`设置为`hardLight`。尝试不同的混合模式选项以获得不同的外观和效果，但我认为硬光效果迄今为止提供了最佳的水效果，创造出一种类似玻璃的外观，非常适合制作可以看到地面的一部分水坑。
- en: 'Next, I called `RainView` to add the rain, then `DropView` to add the collision
    effect of the raindrops hitting the ground, and then `Rainview` again just to
    add a little more rain to the mix. This is the result:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我调用了`RainView`来添加雨，然后调用`DropView`来添加雨滴撞击地面的碰撞效果，然后再次调用`Rainview`以添加更多雨。这是结果：
- en: '![Figure 15.13: The raindrops ](img/B18674_15_13.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图15.13：雨滴](img/B18674_15_13.jpg)'
- en: 'Figure 15.13: The raindrops'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：雨滴
- en: This creates a nice effect of raindrops colliding with the ground and even with
    the puddle.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个很好的效果，雨滴与地面甚至与水坑相撞。
- en: Let’s continue and take a look at the **Magic** particle template and we will
    see how we can use an image to make the particles.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，看看**魔法**粒子模板，我们将了解如何使用图像来制作粒子。
- en: Animating a magic wand
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画化魔法棒
- en: In this project, we’re going to use the **Magic** particle system, and we will
    display that magic from the tip of a wand. You will be able to move the wand around
    the screen with your finger, and as it moves, magic will emanate from its tip.
    We will also have a cemetery background including a gravestone, and when you tap
    on the gravestone, a skeleton will rise up from it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用**Magic**粒子系统，并将从魔杖尖端显示这种魔法。您将能够用手指在屏幕上移动魔杖，当它移动时，魔法将从其尖端散发出来。我们还将有一个包括墓碑的墓地背景，当您点击墓碑时，一个骷髅将从它升起。
- en: So, let’s get started with our spooky animation. Create a new project and call
    this one `Magic`. Next, add the resources for this project by dragging them from
    the `Chapter 15` | `Magic` folder on GitHub into the Asset Catalog. Then, we can
    make our particle file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始我们的神秘动画吧。创建一个新的项目，并将其命名为`Magic`。接下来，通过从GitHub上的`Chapter 15` | `Magic`文件夹中将资源拖动到资产库中，为该项目添加资源。然后，我们可以创建我们的粒子文件。
- en: Creating the magic SpriteKit particle file
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建魔法SpriteKit粒子文件
- en: 'As we’ve done before, create a new SpriteKit particle file, but select the
    `Magic`. Now, let’s do something a little different this time – using the **Texture**
    field in the **Attributes** panel, select the **star** image that you placed into
    the Asset Catalog. We’re going to make the particle system based on that image,
    so all the particles will be stars. Next, change the rest of the fields so the
    values look like the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，创建一个新的SpriteKit粒子文件，但选择`Magic`。现在，让我们这次做一些不同的事情——在**属性**面板中的**纹理**字段中，选择您放入资产库中的**星星**图像。我们将基于该图像创建粒子系统，因此所有粒子都将变成星星。接下来，更改其余字段，使其值看起来如下：
- en: '![Figure 15.14: The attributes of the magic animation ](img/B18674_15_14.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图15.14：魔法动画的属性](img/B18674_15_14.jpg)'
- en: 'Figure 15.14: The attributes of the magic animation'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：魔法动画的属性
- en: 'Notice the **Color Ramp** field. It has three colors selected. If you would
    like to select a color for the **Color Ramp** field, simply click anywhere along
    the color selector, and then a pop-up color box will come up allowing you to choose
    a color. I’ve chosen three colors here: red will be the center of the animation,
    green will surround it, and the third color is yellow, which will be the outer
    part of the magic animation.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注意**颜色渐变**字段。它选择了三种颜色。如果您想为**颜色渐变**字段选择颜色，只需在颜色选择器上点击任何位置，然后会出现一个弹出颜色框，允许您选择颜色。我在这里选择了三种颜色：红色将是动画的中心，绿色将围绕它，第三种颜色是黄色，它将是魔法动画的外部部分。
- en: 'Next, we want to make this `Magic.sks` file available as a SwiftUI view. So,
    let’s create a new Swift file, and call it `MagicView`. Then, add the following
    code to the file:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望将这个`Magic.sks`文件作为SwiftUI视图可用。所以，让我们创建一个新的Swift文件，并将其命名为`MagicView`。然后，将以下代码添加到文件中：
- en: '[PRE18]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve worked with this code in previous projects, so we’re familiar with it
    by now.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以前的项目中处理过这段代码，所以我们现在对它很熟悉。
- en: The code defines a struct called `MagicView`, which conforms to the `UIViewRepresentable`
    protocol in SwiftUI. The `makeUIView` function creates an instance of an `SKView`
    with a given frame size and sets its background color to `clear`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了一个名为`MagicView`的结构体，该结构体符合SwiftUI中的`UIViewRepresentable`协议。`makeUIView`函数创建了一个具有给定框架大小的`SKView`实例，并将其背景颜色设置为`clear`。
- en: It then creates an instance of `MagicScene`, specifying its size, setting its
    background color to `clear`, and scaling it to `aspectFill`. Finally, the created
    scene is presented on `SKView`, and the `SKView` instance is returned.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它创建了一个`MagicScene`实例，指定其大小，将其背景颜色设置为`clear`，并将其缩放为`aspectFill`。最后，创建的场景在`SKView`上显示，并返回`SKView`实例。
- en: The `updateUIView` function does not perform any actions for us, as we don’t
    need to update anything, but it is a required method for the `UIViewRepresentable`
    protocol.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateUIView`函数不会为我们执行任何操作，因为我们不需要更新任何内容，但它对于`UIViewRepresentable`协议是一个必需的方法。'
- en: 'Now, the code will give us an error because of this line: `let scene = MagicScene(size:
    CGSize(width: 900, height: 600))`. This is because we’re creating a scene and
    setting it to the `MagicScene` class, but we haven’t created a `MagicScene` class
    yet.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，代码将因为这一行而出错：`let scene = MagicScene(size: CGSize(width: 900, height: 600))`。这是因为我们创建了一个场景并将其设置为`MagicScene`类，但我们还没有创建一个`MagicScene`类。'
- en: 'So, let’s do that now. Let’s create the `MagicScene` class, which will contain
    the properties and functions we need to manipulate the magic coming from the wand,
    as well as making the skeleton rise up from the ground. Create a new Swift file
    and call this `Magic`. I’m going to place all of the code here and then I’ll explain
    how it works:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们现在就来做这件事。创建`MagicScene`类，它将包含我们需要的属性和函数来操纵魔杖发出的魔法，以及使骨骼从地面升起。创建一个新的Swift文件，并将其命名为`Magic`。我将在这里放置所有代码，然后解释它是如何工作的：
- en: '[PRE19]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Okay, let’s break down the code and see what it’s doing here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们分析一下代码，看看它在做什么。
- en: 'Inside the `MagicScene` class, there are two instance variables declared:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MagicScene`类内部，声明了两个实例变量：
- en: '`magic` is an instance of `SKEmitterNode`, which is a class from SpriteKit
    that represents an emitter that can create particles.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`magic`是`SKEmitterNode`的一个实例，它是SpriteKit中的一个类，代表可以创建粒子的发射器。'
- en: '`wand` is an instance of `SKSpriteNode`, which is a class from SpriteKit that
    represents a textured rectangle.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wand`是`SKSpriteNode`的一个实例，它是SpriteKit中的一个类，代表一个纹理矩形。'
- en: 'The `MagicScene` class overrides two methods from `SKScene`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`MagicScene`类覆盖了`SKScene`的两个方法：'
- en: The `touchesMoved(_:with:)` method is called when the user moves their finger
    across the screen. Inside this method, the position of the wand sprite is updated
    to follow the user’s touch location. If the touch location is in a specific area
    of the screen, a skeleton sprite is created and animated to move to a specific
    location on the screen, straight up. Then, a new `SKEmitterNode` instance is created
    and added as a child of the `MagicScene` instance. This emitter is positioned
    relative to the wand sprite and emits particles that we created in the `.sks`
    file, and simulates the magic. After a duration of 1.2 seconds, the emitter fades
    away and is removed from the scene.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户在屏幕上移动手指时，会调用`touchesMoved(_:with:)`方法。在这个方法内部，魔杖精灵的位置被更新以跟随用户的触摸位置。如果触摸位置在屏幕的特定区域，则会创建一个骨骼精灵并动画化移动到屏幕上的特定位置，垂直向上。然后，创建一个新的`SKEmitterNode`实例并将其添加为`MagicScene`实例的子节点。这个发射器相对于魔杖精灵定位并发射我们在`.sks`文件中创建的粒子，并模拟魔法效果。经过1.2秒的持续时间后，发射器逐渐消失并被从场景中移除。
- en: The `didMove(to:)` method is called once when the scene is first presented.
    Inside this method, a stone sprite is created and positioned on the screen. Then,
    an `SKEmitterNode` instance is created and added as a child of the `MagicScene`
    instance. This emitter will also simulate magic particles. Finally, a wand sprite
    is created and positioned on the screen.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当场景首次呈现时，会调用一次`didMove(to:)`方法。在这个方法内部，创建了一个石精灵并将其定位在屏幕上。然后，创建了一个`SKEmitterNode`实例并将其添加为`MagicScene`实例的子节点。这个发射器也将模拟魔法粒子。最后，创建了一个魔杖精灵并将其定位在屏幕上。
- en: 'That completes the code for the `magic.sks` file. Let’s continue and head into
    `ContentView` and add a little bit of code there so we can see the magic. All
    we need to do is add the graveyard background scene and call `MagicView`. To do
    this, change your `ContentView` to the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了`magic.sks`文件的代码。让我们继续前进，进入`ContentView`并添加一些代码，这样我们就能看到魔法效果。我们只需要添加墓地背景场景并调用`MagicView`。为此，将你的`ContentView`修改为以下内容：
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With that bit of code, the project is done. Run the animation and start making
    magic:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 用这段代码，项目就完成了。运行动画，开始施展魔法：
- en: '![Figure 15.15: The magic wand and graveyard scene ](img/B18674_15_15.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图15.15：魔杖和墓地场景](img/B18674_15_15.jpg)'
- en: 'Figure 15.15: The magic wand and graveyard scene'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：魔杖和墓地场景
- en: Move the wand around and see the magic coming out of its tip, then tap on the
    gravestone to wake the skeleton!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 移动魔杖，看看从其尖端冒出的魔法，然后点击墓碑唤醒骨骼！
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: With SpriteKit’s extensive support for physics and particle systems, combined
    with SwiftUI’s easy-to-use interface and modern design capabilities, you can create
    dynamic, engaging animations that bring your apps to life. As we have seen here,
    you can create smoke, rain, fire, snow, and magic, but there are even more particle
    systems to try and experiment with.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit对物理和粒子系统的广泛支持，结合SwiftUI易于使用的界面和现代设计能力，你可以创建动态、引人入胜的动画，让你的应用栩栩如生。正如我们在这里所看到的，你可以创建烟雾、雨、火、雪和魔法，但还有更多粒子系统可以尝试和实验。
- en: As always, alter each project to your liking, and add your own unique creativity
    and ideas. Add sound to various parts of each project if you want – for example,
    in the magic wand project, maybe when the wand is moving, play a wand sound effect.
    Enhance the animations by altering the values, changing the images, or building
    out more complex scenes using the tools you now have. Just have fun because the
    effects are only limited by your imagination.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，根据你的喜好调整每个项目，并加入你独特的创造力和想法。如果你想的话，可以为每个项目的各个部分添加声音——例如，在魔杖项目中，当魔杖移动时，可以播放魔杖音效。通过调整值、更改图像或使用你现在拥有的工具构建更复杂的场景来增强动画。只需享受乐趣，因为效果仅限于你的想象力。
- en: And with that, we have completed the final projects, and also the final chapter.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了最终项目，也完成了最后一章。
- en: Throughout the book, we delved into both implicit and explicit animations, exploring
    the differences between them and how to use them to achieve different effects.
    As we progressed through the book, we gradually introduced different modifiers
    and more challenging animation techniques, from basic bounces to more advanced
    moves. We also built two complete games that you can modify in many different
    ways.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们深入探讨了隐式和显式动画，研究了它们之间的区别以及如何使用它们来实现不同的效果。随着我们在书中的进展，我们逐渐介绍了不同的修饰符和更具挑战性的动画技术，从基本的弹跳到更高级的动作。我们还构建了两个完整的游戏，你可以以许多不同的方式对其进行修改。
- en: You now have the knowledge, skills, and a deeper understanding of SwiftUI animations
    to be able to implement a wide range of effects that will take your app to the
    next level and create engaging and dynamic user experiences.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了知识、技能，以及对SwiftUI动画的更深入理解，能够实现一系列效果，将你的应用提升到下一个层次，并创造引人入胜且动态的用户体验。
- en: Happy animating!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你动画愉快！
