- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating SpriteKit into Your SwiftUI Projects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive deeper into the world of animation in SwiftUI
    and create some mini-projects, highlighting different animations that can be made
    using other techniques and the SpriteKit framework. Some of the animations will
    be simpler, some will be more complex, and some will be dynamic and interactive
    animations too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: You will learn how to take advantage of the power of **SpriteKit** and **particle
    emitters**. SpriteKit is a game development framework that provides a convenient
    and efficient way to create 2D games for iOS and macOS platforms. Particle emitters,
    on the other hand, are powerful tools in the SpriteKit framework that allow you
    to create special effects such as fire, smoke, rain, wind, explosions, and more.
    These emitters will bring life to your apps, making them visually stunning and
    engaging for users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here are the topics we will cover in this final chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Animating pipe smoke
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating coffee steam
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating rocket fire
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a blizzard
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating rain
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a magic wand
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the completed projects and their code in the `Chapter 15` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Animating pipe smoke
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will create a smoke effect using SpriteKit’s **Smoke** template,
    and make it come out of an image of a pipe. This is a good first project, as it’s
    not too complicated and gets you familiar with creating the needed **SpriteKit
    Scene** (**SKS**) particle file and how to configure it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started, first create a new SwiftUI project, and call it `Pipe Smoke`.
    We are going to need a couple of images for this project so you can grab them
    over at GitHub (`Chapter 15` | `Pipe Smoke`) and add them to the project’s Assets
    catalog. Now it’s time to create a SpriteKit particle file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SpriteKit particle file
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, let’s create a new file; this will be a SpriteKit particle file. The **SpriteKit
    Scene** (**SKS**) **particle file** is a scene file that has information about
    the particle system it contains, such as the shape, size, and position of the
    particle emitter, as well as the type of particles that will be emitted, their
    behavior, and movements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: To create an SKS particle file, in Xcode, you simply need to go to **File**
    | **New** | **File** | **SpriteKit Particle File**, or press *Command + N* to
    bring up the template options, and scroll down until you come to a template called
    **SpriteKit Particle File**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to choose the type of template we want. There are several options
    and we’re going to explore them individually in separate projects, but the one
    we want now is **Smoke**:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: Particle template options ](img/B18674_15_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Particle template options'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click `Smoke`, choose a save location, and then click **Create**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: Creating the Smoke.sks file ](img/B18674_15_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Creating the Smoke.sks file'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will see a new particle file in your Xcode editor that has a smoke
    animation playing. That’s because we chose the **Smoke** template, so the particles
    are pre-configured to produce smoke. This smoke will need to be adjusted so it’s
    not as wide and thick. We want the effect to be thin and small enough that we
    can make it come out of a pipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the smoke, go to the right side of Xcode and you’ll see four buttons;
    if you click on the fourth button, you open up the **Attributes** panel, which
    is where we can configure our particle file to create an infinite number of effects:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: Xcode’s Attributes panel ](img/B18674_15_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Xcode’s Attributes panel'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few settings in this panel, and since we will be creating
    different particle files in this chapter, it’s a good idea to have an understanding
    of what each field does. So, I will explain each field in order for you to create
    this first project in the chapter, and you can use these definitions for reference
    as you continue working through the other projects.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Name
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Name** field is used to give a unique identifier to the particle emitter
    so that you can easily reference it within your code or in the editor. The field
    is a string value that you can set to anything you like, as long as it’s unique
    within the file. By giving your particle emitters descriptive names, they will
    act as a reminder of what they do and how they’re used in your project.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can use the **Name** field to access the particle emitter
    and modify its properties programmatically in your code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Background** field lets you set the background color of the editor. Sometimes,
    it’s useful to adjust this color to help make the particles stand out more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Texture
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Texture** field is used to specify the image file that will be used as
    the particle texture. The particle texture is essentially the appearance of the
    particles, and you can use any image file you like to create a wide range of particle
    effects. For example, you could use a simple dot or circle image for a simple
    particle effect, or a more complex image with multiple shapes and colors for a
    more elaborate effect. When you specify a particle texture in the **Attributes**
    panel, it will be used for all of the particles in the particle emitter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Emitter
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Emitter** is the object that defines the characteristics of a particle, such
    as its initial position, speed, and lifetime.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The **Emitter Birthrate** field specifies the number of particles that are emitted
    per second. It determines how quickly the particles will be generated by the emitter
    – a higher birthrate will result in more particles being emitted in a shorter
    amount of time, while a lower birthrate will result in fewer particles being emitted
    over a longer period of time.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The **Emitter Maximum** field sets the maximum number of particles that can
    exist at one time in the particle system. If **Birthrate** is set to a high value
    and **Maximum** is set to a low value, the emitter will emit particles at the
    specified rate until the maximum limit is reached. Once the maximum number of
    particles has been reached, the emitter will stop emitting new particles until
    some of the existing particles have disappeared. This allows you to control the
    overall number of particles in your particle system and optimize performance.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Lifetime
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Lifetime** fields specify the amount of time that each particle in a particle
    system will be active before it disappears.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The **Lifetime Start** field specifies the length of time for which each particle
    will exist in the particle system. It determines how long each particle will stay
    visible in the scene before disappearing. A higher value will result in particles
    staying visible for a longer period of time, while a lower value will result in
    particles disappearing more quickly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The **Lifetime Range** field sets the range of values that the **Lifetime**
    property can take. Instead of specifying a fixed value for the lifetime, you can
    specify a range of values, and the particle system will randomly choose a value
    from that range for each particle that is emitted. This allows you to add variation
    to your particle system, making it look more organic and natural. For example,
    if you set **Lifetime Start** to **1.0** and **Lifetime Range** to **0.5**, each
    particle’s lifetime will be a random value between 0.5 and 1.5 seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Position Range
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Position Range** fields specify the range of values for the initial position
    of the particles in each dimension – **X**, **Y**, and **Z** – allowing you to
    create particle systems that emit particles from a random position within a defined
    area. The particle system will randomly choose a position from within the specified
    range for each particle that is emitted, which can help add variety and realism
    to your particle systems.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Angle
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Angle** fields in an SKS particle file control the initial direction and
    spread of particles when they are emitted. **Angle Start** sets the starting direction
    of the particles, while **Angle Range** determines the range of possible directions;
    the system then randomly chooses an angle within the range for each particle emitted.
    **Angle Start** is measured in degrees, with 0 degrees pointing to the right,
    and **Angle Range** specifies the spread of angles in a counterclockwise direction,
    again measured in degrees.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Speed** fields control the initial speed and variation of particles when
    emitted in an SKS particle file. **Speed Start** sets the starting speed, while
    **Speed Range** specifies the possible range of speeds; a random speed is then
    chosen within the specified range for each emitted particle.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting these fields allows you to create various particle effects, with a
    higher value resulting in faster particles and a lower value in slower particles.
    For example, setting **Speed Start** to **100** and **Speed Range** to **0** will
    emit particles at a constant speed, while setting **Speed Start** to **50** and
    **Speed Range** to **25** will create particles with varying speeds between 25
    and 75\. These values are generally understood to be points per second.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Acceleration
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Acceleration X** and **Acceleration Y** fields control the acceleration
    of the particles in the *x* and *y* directions respectively. For example, you
    could set **Acceleration X** to **0** and **Acceleration Y** to **-100** to create
    a particle system that is affected by gravity, causing the particles to fall downward.
    Alternatively, you could set **Acceleration X** to **50** and **Acceleration Y**
    to **0** to create a particle system that moves to the right at a constant rate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The **Acceleration X** and **Acceleration Y** fields are specified in points
    per second squared; positive values will cause the particles to accelerate in
    the positive direction, while negative values will cause the particles to decelerate
    or accelerate in the opposite direction.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Alpha
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.sks` file refers to the opacity or transparency of particles in a particle
    system. The alpha value controls how much of the particle is visible, with a higher
    value making the particle more visible and a lower value making the particle more
    transparent.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The **Alpha Start** field specifies the starting alpha value for the particles,
    which can be used to control their initial transparency. The **Alpha Range** field
    specifies the range of possible alpha values that the particles can take, and
    when the particle emitter emits a particle, it will choose a random alpha value
    within the specified range. The **Alpha Speed** field specifies the rate at which
    the alpha value of the particles will change over time, and can be used to control
    the rate of fade-in or fade-out of the particles; a positive value for this field
    will cause the particles to fade in over time, while a negative value will cause
    the particles to fade out over time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: By adjusting the **Alpha Start**, **Alpha Range**, and **Alpha Speed** fields,
    you can control the transparency of the particles over their lifetime and create
    a wide range of particle effects. For example, you could set **Alpha Start** to
    **1** and **Alpha Range** to **0** to emit particles with a constant alpha value
    or set **Alpha Start** to **1**, **Alpha Range** to **0**, and **Alpha Speed**
    to **-0.5** to emit particles that fade out over time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Scale** fields control the size of the particles over their lifetime.
    The **Scale Start** field specifies the starting size of the particles, which
    can be used to control their initial size. The **Scale Range** field specifies
    the range of possible sizes that the particles can take, and when the particle
    emitter emits a particle, it will choose a random size within the specified range.
    The **Scale Speed** field specifies the rate at which the size of the particles
    will change over time, and can be used to control the rate of growth or shrinkage
    of the particles; a positive value for this will cause the particles to grow over
    time, while a negative value will cause the particles to shrink over time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: As an example of using **Scale**, you could set **Scale Start** to **1** and
    **Scale Range** to **0** to emit particles with a constant size or set **Scale
    Start** to **1**, **Scale Range** to **0.5**, and **Scale Speed** to **0.1** to
    emit particles that grow over time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Rotation
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Rotation Start** field specifies the starting rotation of the particles,
    which can be used to control their initial orientation. The **Rotation Range**
    field specifies the range of possible rotations that the particles can take, and
    when the particle emitter emits a particle, it will choose a random rotation within
    the specified range. The **Rotation Speed** field specifies the rate at which
    the rotation of the particles will change over time, and can be used to control
    the rate of rotation of the particles; a positive value will cause the particles
    to rotate clockwise, while a negative value will cause the particles to rotate
    counterclockwise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: You could set **Rotation Start** to **0** and **Rotation Range** to **0** to
    emit particles with a constant orientation or set **Rotation Start** to **0**,
    **Rotation Range** to **180**, and **Rotation Speed** to **180** to emit particles
    that rotate rapidly over time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Color Blend
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Color Blend** fields control the color of the particles over their lifetime.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The **Color Blend Factor** field specifies the amount of color blending that
    will be applied to the particles. When the particle emitter emits a particle,
    it will choose a random color blend factor within the specified range. The particle’s
    color will be blended with the color of the particle’s texture according to this
    blend factor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The **Color Blend Factor Range** field specifies the range of possible color
    blend factors that the particles can take. A value of **0** will result in no
    color blending, while a value of **1** will result in full color blending.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The **Color Blend Factor Speed** field specifies the rate at which the color
    blend factor of the particles will change over time, and can be used to control
    the rate at which the particles’ color will change. A positive value for the **Color
    Blend Factor Speed** field will cause the color of the particles to change over
    time, while a negative value will cause the color of the particles to change in
    reverse.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Looking an example, you could set **Color Blend Factor** to **0**, **Color Blend
    Factor Range** to **0**, and **Color Blend Factor Speed** to **0** to emit particles
    with constant color, or set **Color Blend Factor** to **1**, **Color Blend Factor
    Range** to **1**, and **Color Blend Factor Speed** to **0.1** to emit particles
    that change color rapidly over time.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Color Ramp
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Color Ramp** field is used to specify a range of colors that particles
    can take on over their lifetime. The colors are defined using a ramp, which is
    a gradient that blends two or more colors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**Color Ramp** allows you to create particle effects with changing colors.
    By default, particles will be emitted with a single color, but by adjusting **Color
    Ramp**, you can set the particles to a fixed range of colors, change color over
    time, or randomize the color within a range. For example, you could set **Color
    Ramp** to shades of red and yellow to create a fire effect or shades of blue and
    white for a snow effect.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, **Color Ramp** can be used to create different blending modes,
    such as additive or subtractive blending. The blending mode determines how the
    colors of the particles are combined with the colors of the background or other
    particles in the scene.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Blend Mode
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Blending is a process that combines the colors of the particles with the colors
    of the objects behind them on the screen. The **Blend Mode** field determines
    how the colors of the particles and the background will be combined.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: There are several blend modes available in SpriteKit, the choice of which depends
    on the desired visual effect for the particles. For example, the **Alpha** blend
    mode will blend the colors of the particles and the background by taking the alpha
    channel of the particle’s color into account. The **Add** blend mode will add
    the colors of the particles and the background together. The **Multiply** blend
    mode will multiply the colors of the particles and the background together.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: By adjusting the blend mode, you can control how the colors of the particles
    are blended with the colors of the objects behind them and create a wide range
    of particle effects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Field Mask
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Field Mask** takes an integer value that is used to specify a masking bit-field,
    and the bit-field defines which properties of the particle are affected by the
    mask. For example, if the bit-field includes the position bit, the mask will affect
    the position of the particles. If it includes the color bit, the mask will affect
    the color of the particles. By setting the value of **Field Mask**, you can control
    which properties of the particles are affected by the mask. This allows you to
    create complex and sophisticated particle effects.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could set **Field Mask** to include the position bit, which
    would cause the mask to affect the position of the particles, and create particles
    that follow a specific path or shape. Otherwise, you could set **Field Mask**
    to include the color bit, which would cause the mask to affect the color of the
    particles, and create particles with a specific color scheme or pattern.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Custom Shader
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Custom Shader** field allows you to specify a custom shader to be used
    to render the particles.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A **shader** is a program that runs on the GPU and is used to define the appearance
    and behavior of the particles. By using a custom shader, you can create complex
    and sophisticated particle effects that would be difficult or impossible to achieve
    using the built-in properties of the particle emitter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: For example, you could use a custom shader to create particles that respond
    to changes in the environment, such as light or shadows, or create particles that
    change shape or appearance over time. To use one, you need to write the shader
    code in a language such as **OpenGL Shading Language** (**GLSL**) and then specify
    the shader code as the value of the **Custom Shader** field. Once you have specified
    the custom shader, SpriteKit will use it to render the particles, giving you complete
    control over the appearance and behavior of the particles. By combining custom
    shaders with other properties of the particle emitter, such as **Birthrate**,
    **Lifetime**, and **Position Range**, you can create a wide range of sophisticated
    and visually stunning particle effects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have looked at all of the customization fields for the particle system.
    I know it can be a bit overwhelming, which is why I defined each field in the
    file so you can refer to it when you’re building your particle system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the following values to alter the smoke so it is similar to the smoke
    that you would see coming from a pipe. I have worked out all the values; you just
    need to fill them in:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: Attributes for the pipe smoke animation ](img/B18674_15_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: Attributes for the pipe smoke animation'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Make sure your file has those same values as well before proceeding, which will
    give you the correct smoke you need to come out of the pipe.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Smoke file into a SwiftUI View
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get started with this section, a little bit of explanation is needed
    as to what the SpriteKit framework is all about and how it works. As I mentioned
    at the beginning of this chapter, SpriteKit is a game development framework that
    provides a convenient and efficient way to create 2D games for iOS and macOS platforms.
    Using the SpriteKit framework, you can create different sprites for your animation
    or game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: A sprite is represented by the `SKSpriteNode` class, which is a node that can
    display a textured image. A sprite can be thought of as a single frame of an animation
    and it can be moved, rotated, and scaled and have physics applied to it. A single
    sprite can also have multiple textures, allowing it to change appearance. In a
    game, sprites are used to represent characters, objects, and backgrounds.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: You can create a sprite by initializing `SKSpriteNode` with an image or texture
    and then adding it to an `SKScene`. Once added to a scene, a sprite can be manipulated
    using various properties and methods, such as position, scale, and rotation, and
    you can also add actions, physics, and gestures to it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`SKView` is a `UIView` subclass that is used to display and interact with SpriteKit
    scenes. It acts as the container for an `SKScene` and provides the necessary infrastructure
    for displaying and animating sprites. An `SKScene` is a container for all the
    sprites in a SpriteKit-based project. It is responsible for updating and rendering
    the sprites, and also provides a way to handle user interactions with the sprites.
    A scene can also contain other nodes such as labels and shapes in addition to
    sprites. Each scene can have its own set of sprites, physics, and interactions.
    You will become more familiar with sprites and nodes as we progress through the
    projects in this chapter.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do some coding now. Go into `ContentView`, and we will create a smoke
    view struct in which we can use our `Smoke.sks` file. The first thing we need
    to do is import the SpriteKit framework so that we have access to the classes
    and methods. Add this line of code at the top of `ContentView`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let’s create that `SmokeView` struct I mentioned by adding this under
    the `ContentView` struct:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here’s how the `SmokeView` struct works, line by line. Bear in mind that the
    SpriteKit framework uses methods and classes we have not used before, so the code
    may seem unfamiliar at first; as you work through the chapter though, you will
    understand it very quickly because it is Swift code after all, and is very readable:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This code starts off by defining a struct named `SmokeView`, which is used to
    display the smoke effect that we configured in the `Smoke.sks` file. The struct
    conforms to the `UIViewRepresentable` protocol. This allows the struct to be used
    as a SwiftUI view.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we add the `makeUIView` method, which is required by the `UIViewRepresentable`
    protocol. It creates and returns `SKView`, which is used to display the smoke
    effect.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create an instance of `SKView` with a specified frame (size and position).
    This frame is used to determine the size of the smoke effect.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the `backgroundColor` property of the `SKView` instance to `clear`. This
    means that the background of the view will be transparent and will not have a
    solid color background; this way, any underlying views or graphics can show through.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an instance of `SKScene` with a specified `size` property, which determines
    the size of the smoke effect, and a background `color` value of `clear` so that
    the background of the smoke effect will be transparent.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create an instance of `SKEmitterNode` using the particle system defined
    in the `Smoke.sks` file. The guard `let` statement is used to check whether the
    file was loaded correctly and if not, it returns an empty `SKView`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we position the smoke effect in the center of the scene; set the blend
    mode to `SKBlendMode.screen`, which will make the smoke blend with the background;
    set the initial scale of the smoke particles, which will make the particles smaller
    and thinner; and set the range of the scale of the smoke particles.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addChild` method is called on the `scene` instance, passing in the `smoke`
    node as an argument. This adds the particle emitter node as a child node to the
    scene, meaning it will be displayed in the scene.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `presentScene` method is called on the `view` instance, passing in the `scene`
    instance as an argument. This sets the scene as the currently displayed scene
    in the view.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the `return` keyword returns the `view` instance.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updateUIView` function is called when the view needs to be updated, such
    as when the view’s state changes. In this code, we leave it empty, as it is not
    needed in our example.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, the code creates and returns an `SKView` instance that displays
    a SpriteKit particle emitter as a SwiftUI view. Now, we have a `SmokeView` ready
    to go and display the smoke.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s come into `ContentView` and add a background for the scene, and a smiley
    image that has a pipe in his mouth. Then, we will call the `SmokeView` we just
    created to put the smoke into the pipe. To do this, modify `ContentView` like
    so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What we have done here is create a `ZStack` and put our image of the smiley,
    which is called `pipe`, into the scene. Then, we resized it with `width` and `height`
    values of `350` points and called our `SmokeView`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Next, we positioned the smoke so that it is directly above the pipe and appears
    to come out of the pipe, achieved with the `offset` modifier. Finally, we add
    the background right onto the `ZStack`, and the project is finished.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the project, you’ll see realistic pipe smoke coming out of the pipe:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: The pipe smoke animation ](img/B18674_15_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.5: The pipe smoke animation'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to create smoke and have a basic foundation of how to
    get the SpriteKit particle system operational in our SwiftUI project, let’s continue
    and solidify what you know and use the **Smoke** template once again, but vary
    the values to create a different effect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Animating coffee steam
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next project, we’ll modify the particle system file to create steam
    that we can use to create a steaming cup of coffee animation. Well also look at
    a technique where we can place the steam directly inside the coffee by overlapping
    images. To get started, create a new project and call it `Coffee`, and then we’ll
    move on to creating the SpriteKit particle file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Smoke SpriteKit particle file
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the file, like before, press *Command + N*, choose the **SpriteKit
    Particle File** template, and let’s pick **Smoke** from the particle template
    options again (yes, **Smoke** again, but we will make it look like steam this
    time).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will modify the various properties to create our animation. Change
    all the properties in your SKS file to look like the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: The attributes of the coffee steam animation ](img/B18674_15_06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.6: The attributes of the coffee steam animation'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: All of those properties have been explained in the previous project. If you’re
    unclear as to what each one does, revisit that section for a refresher.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Coffee Steam struct
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s go back into the `ContentView` file and we’ll start assembling
    the project. In the previous project, we learned how to use the `.sks` file inside
    the SwiftUI view, and we’re going to do almost the exact same thing here too.
    The first thing we did was create a separate struct and use the `UIViewRepresentable`
    protocol to use the `.sks` file within a SwiftUI view. So, in this project, underneath
    `ContentView`, add the following struct:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'I explained this code in the previous project, but I will go over it again
    to help solidify your understanding:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The code starts off by defining a custom SwiftUI view named `CoffeeSteam`, which
    is used to display the steam effect that we configured in the `CoffeeSteam.sks`
    file. The struct conforms to the `UIViewRepresentable` protocol. This allows the
    struct to be used as a SwiftUI view.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we add the `makeUIView` method, which is required by the `UIViewRepresentable`
    protocol. It creates and returns an `SKView`, which is used to display the steam
    effect.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create an instance of `SKView` with a specified frame (size and position).
    This frame is used to determine the size of the steam effect.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set the `backgroundColor` property of the `SKView` instance to `clear`. This
    means that the background of the view will be transparent and will not have a
    solid color background; this way, any underlying views or graphics can show through.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create an instance of `SKScene` with a specified size, which is used
    to determine the size of the steam effect, and set the background color to `clear`;
    this way, the background of the steam effect will be transparent too.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we create an instance of `SKEmitterNode` using the particle system defined
    in the `CoffeeSteam.sks` file. The guard `let` statement is used to check whether
    the file was loaded correctly and if not, it returns an empty `SKView`.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we position the steam in the center of the scene; set the blend mode of
    the steam to `SKBlendMode.screen`, which will help to make the steam blend in
    with the background; set the initial scale of the steam particles to help them
    resemble a steam effect; then, we set the range of the scale of the smoke particles.
    (Again, refer to the previous project where I defined each of these property fields
    in the SKS file).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `addChild` method is called on the `scene` instance, passing in the `steam`
    node as an argument. This adds the particle emitter node as a child node to the
    scene, meaning it will be displayed in the scene.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `presentScene` method is called on the `view` instance, passing in the `scene`
    instance as an argument. This sets the scene as the currently displayed scene
    in the view.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, the `return` keyword returns the `view` instance.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `updateUIView` function is called when the view needs to be updated, such
    as when the view’s state changes. In this code, we leave it empty, as it is not
    needed in our example.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, all that code creates and returns an `SKView` instance that displays a SpriteKit
    particle emitter as a SwiftUI view. Noticed that I am setting some of the properties
    in code here? You have the option of setting the properties in the SKS file by
    adjusting the values there, or you can set them in code here; however, remember
    that when you set them in code, they override anything you set in the SKS file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Filling out ContentView
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can just do a little work in `ContentView` and display the steaming
    cup of coffee. If you haven’t already done so, drop the assets into the Asset
    Catalog that you can find in the `Chapter 15` folder titled `Coffee Steam` on
    GitHub.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s modify `ContentView` to look like the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code declares a `ZStack` that will hold our views. Inside `ZStack`, we add
    a background image, resize it, and set the aspect ratio on it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code declares another `ZStack`, where we placed the first image titled
    `cup`, resizing it and setting its aspect ratio as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Next, we called the `CoffeeSteam` struct and offset it a little bit so it’s
    centered in the middle of the cup.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: And after that, we added the `cup 2` image. This second image is used to make
    the steam appear as though it’s coming out of the center of the cup. So, what
    we’re essentially doing is sandwiching the animating steam in between two coffee
    cup images, in which one of the cup images has a little cut out in it; when we
    place the steam in between these two, we can create a nice steaming effect that
    appears to be originating from inside the coffee cup.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I called the `offset` modifier on the `ZStack` to position everything
    on the *y*-axis.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the project and you will see the steaming effect that’s coming right
    off the surface of the coffee. Also notice how the back of the cup glistens with
    the steam as it rises, as it would do in a real cup of coffee.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: A cup of steaming coffee ](img/B18674_15_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.7: A cup of steaming coffee'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have completed two projects using the **Smoke** particle template –
    creating pipe smoke and coffee steam – and we understand how to manipulate the
    particles in very different ways. Let’s continue and move on to the next project,
    where we’ll use a different particle system: fire.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Animating rocket fire
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SpriteKit Fire particle template generates particles that are typically
    colored shades of orange, yellow, and red, which give the impression of glowing
    embers and flames. The particles may also have a slight degree of transparency
    to mimic the flickering and shifting quality of a real fire. In terms of behavior,
    the particles are designed to move upward with a certain amount of randomness,
    representing the movement of hot air and flames.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating some simple flames, though, we’re going to animate a rocket!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Press *Command + N*, then choose the `Rocket`. Xcode will go ahead and create
    the fire particles that you can see them running in the editor.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create the SwiftUI view that will bring this `.sks` file into our
    SwiftUI project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Adding FireView
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the view, press *Command + N* and make a `SwiftUIView` file. Then,
    call it `FireView`. Then, import SpriteKit, and add the following code at the
    top of the file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I’m not going to go over this code because we have done this already, but you
    can refer back to the previous SpriteKit projects for all the explanations, and
    how we use the `UIViewRepresentable` protocol.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If you run a code in the previews, you’ll see that it works great and the fire
    is the correct dimensions to fit under the rocket. However, notice that the fire
    is upside down. Let’s look at how we can fix this so it looks like a proper thrust
    to place underneath a rocket.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Adding RocketView
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now create one more view that we can use to put together the rocket and
    the fire, then rotate the fire around so it’s properly oriented under the rocket.
    Press *Command + N*, create a new SwiftUI View file, and call it `RocketView`.
    Then, add the following code inside the struct:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we create a `rocketAndFire` offset variable that we can use to move both
    the rocket and the fire upward on the screen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Then, inside the `ZStack`, we take `FireView` and rotate it 180°, and offset
    it on the *y*-axis, which makes the fire extend further out from the rocket, which
    we will add shortly. Then, we animate the fire upward by changing the `y`-`offset`,
    and positioning the fire in the center of the screen on the *x*- and *y*-axes
    using the `UIScreen` property.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Then, we can add the `rocket` image, resize it, and animate it upward by offsetting
    the *y*-axis using the `rocketAndFire` variable. Next, we just need to position
    the rocket in the center of the screen using the `UIScreen` property.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can add the animation to the closing brace of the `ZStack`, which
    will act on both `FireView` and the rocket image. Let’s give it a duration of
    `8` seconds, and make it repeat forever with no auto-reverse.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can launch the rocket in the `onAppear` method by changing the value
    of the `rocketAndFire` property. When the view appears, the rocket will lift off
    and continue off the top of the screen and come back up from the bottom and keep
    flying.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: All we have to do now is add the background!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Putting things together inside ContentView
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside `ContentView`, we need very little code to get our rocket into space:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And that’s it. Inside the `ZStack`, we added `RocketView()` to the scene, and
    then we added the background image right onto `ZStack`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Check it out in the previews and you’ll see that we now have a rocket flying
    in space:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8: Our rocket blasting off ](img/B18674_15_08.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.8: Our rocket blasting off'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the power of particle systems, we were able to create a realistic
    and dynamic visual effect that brings our rocket to life. We explored the various
    parameters and properties of the emitter to fine-tune the look and feel of the
    thrust and learned how to integrate it with our SwiftUI view.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Looking at another example, we’re going to return to another effect that we’ve
    already seen before – snow – but modify it so it creates a blizzard-like effect.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Animating a blizzard
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next project, we’re going to create a blizzard scene, and add a wind
    effect to make the snow blow from different directions. We will also use that
    wind to make the branches of a tree blow as well, by combining images and animating
    them. We created a snow scene in the breathing flower project in [*Chapter 6*](B18674_06.xhtml#_idTextAnchor082),
    but this time, we’re going to create this snow scene using a particle file, which
    gives us more options for making and controlling the snow.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a new project and calling it `Snow`. Then, we will get
    right to work creating the SKS file that we need for the snow – this time, though,
    we’ll create two files.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Creating two Snow SpriteKit particle files
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this project, we will create two SpriteKit files – both will be from the
    **Snow** template, but we will use different values so the snow blows from different
    directions and at different velocities.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the first file, press *Command + N*, choose the `Snow`. Now, let’s
    configure the particle properties so we can create a nice heavy snowfall. Use
    the same values from the following figure:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9: The attributes for the Snow file ](img/B18674_15_09.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.9: The attributes for the Snow file'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'And that creates the desired snowfall we are going for. To help you in designing
    your unique snowfall, the following is a guide for making adjustments:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '**Particle Lifetime**: Set the lifetime to a relatively long time so that the
    particles stay on the screen for a while'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particle Birthrate**: Increase the birthrate to generate more particles per
    second, which will create a denser snowfall effect'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particle Size**: Increase the size of the particles to make them appear larger
    and more prominent on the screen'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particle Speed**: Decrease the speed of the particles to make them fall slower
    and more gently'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Particle Color**: Change the color of the particles to white or light blue
    to make them look more like snowflakes'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emitter Shape**: Change the emitter shape to a rectangle or a line to make
    the snowfall appear more natural'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emitter Position**: Adjust the emitter’s position to start the snowfall from
    the top of the screen'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at that snow in the editor, you can see that it has a pretty heavy
    effect, just what we need for our scene. Now, let’s create the second file with
    different values for the snow; we’ll then combine both of these SKS files into
    one SwiftUI view that we can use to create a nice blizzard effect.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the same steps to create a second file, but this time, call it `Blustery`.
    Now, let’s alter the attributes to the following values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: The attributes for the Blustery file ](img/B18674_15_10.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.10: The attributes for the Blustery file'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: This new file has different **Birthrate**, **Angle**, and **Acceleration** values
    to make the snow blow from different directions, as well as lift the snow up a
    little bit as if being carried by the wind. When we combine the two SKS files
    together, which will create a nice blizzard effect.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s do that now; we’ll need to create a struct in which you can put these
    two files together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Creating a view that combines the two SKS files
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working inside the `ContentView` file, first, add the SpriteKit import. Then,
    create a new struct called `SnowView` after the `ContentView` struct. (You could
    create separate files and keep things neat in the project navigator, but I’m just
    going to put the rest of the code into the `ContentView` file for this project.)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'With `SnowView` created, add the following code within it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code positions both nodes, the `snow` node and the `blustery` node, using
    the `position` property, and then sets the `particlePositionRange` property on
    both as well. `particlePositionRange` is the range of allowed random values for
    a particle’s position. Finally, as we’ve done with our other particle files, we
    add them to the scene using the `addChild` function and passing in the view that
    we want to add to the scene.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can call this struct in `ContentView` to check out the blizzard, and
    in fact, let’s also add a background snow scene too:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, run the previews and check out the blizzard effect:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: Our blizzard scene ](img/B18674_15_11.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: Our blizzard scene'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s continue with the project and add another animation to it. For this
    one, we want to make the branches of the tree blow in the wind.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Animating the tree branches
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To animate the tree branches, we’re going to wrap all the code up into several
    `ZStack`. Then, we will use one image of a snowy branch, replicate it many times
    with a `ForEach` loop, place the branch images over a portion of the tree, and
    put rotation animations on each of the axes of those images. We will also randomize
    the animation so that it doesn’t follow a set pattern.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating the struct that we need to hold these views:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, let’s add the variables we need to keep track of the animations and set
    some initial values:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code defines five state properties in a SwiftUI view.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The `anglesX`, `anglesY`, and `anglesZ` properties are arrays of `Double` values,
    each with a length of `25`. These arrays are used to store the rotation angles
    around the *x*-, *y*-, and *z*-axes, respectively. The `repeating:` parameter
    is used to initialize all the values in each array to 0.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The `positions` property is an array of `CGPoint` values, also with a length
    of `25`. This array is used to store the positions of the views. The `repeating:`
    parameter is used to initialize all the values in the array to the zero point,
    `(``0, 0)`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The `durations` property is an array of `Double` values, again with a length
    of `25`. This array is used to store the durations of the animations associated
    with each view. The `repeating:` parameter is used to initialize all the values
    in the array to 0.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the `@State` property wrapper is used to make each of these
    arrays a mutable state property of the view. This means that whenever any of the
    arrays are modified, SwiftUI will automatically re-render the view to reflect
    the changes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s move into the `body` property and add a `ZStack` that contains
    the image we want to manipulate and reproduce, as well as the animation we’re
    going to put on it:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here’s what we’re doing in here. We start off with a `ZStack` so we can stack
    our views on top of each other. Next is a `ForEach` loop, which iterates over
    a range of integers from 0 to 7; the `index` parameter is used to access the current
    iteration value in the loop.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we add the branch image and the following modifiers:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The `resizable` modifier resizes the image.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rotationEffect(_:)` modifier is used to rotate the image around the *x*-,
    *y*-, and *z*-axes. The angle of rotation is specified by the corresponding value
    in the `anglesX`, `anglesY`, and `anglesZ` arrays, respectively. The `anchor`
    parameter is used to specify the center of rotation. In this case, `.center` is
    used for both the `anglesY` and `anglesZ` rotations, so the image is rotated around
    its center point.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `position(_:)` modifier is used to position the image on the screen. The
    `positions` array stores the position for each image instance based on its index.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `frame(width:height:)` modifier sets the size of the image.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `animation(_:, value:)` modifier is used to animate the rotation of the
    image. The duration of the animation is based on the value stored in the `durations`
    array, while the `value` parameter specifies that the animation should be re-evaluated
    whenever the `anglesX` array changes.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onAppear` modifier is used to randomly generate new values for the `anglesX`,
    `anglesY`, `anglesZ` positions, and `durations` arrays whenever an image appears
    on the screen.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `offset` modifier applies an offset of `50` points on the *x*-axis
    and `200` points on the *y*-axis to the entire `ZStack`, which positions the tree
    branches in the middle-right portion of the tree.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To summarize, what we’re doing is creating eight image views of snow-covered
    branches, each with a different rotation, position, duration, and animation. The
    views are stacked on top of each other within `ZStack` and have an offset applied
    to place them in the tree.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I’d like to replicate the `ZStack` several more times so we can cover
    the whole tree with snowy branches, rather than covering only a portion of the
    tree. So, we’ll make four more ZStacks but with slightly different values to make
    the wind-blowing effect seem more random and natural:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All of these `ZStack` do essentially the same thing, except that the code uses
    different values. For example, in the `ForEach` loop, we’re using a different
    range of values, and we’re also changing the random values for the *x*-, *y*-,
    and *z*-axes, as well as the `position` and `duration` values. Also, each `ZStack`
    has its own `onAppear` modifier, so it could randomly move its set of branches
    at a different pace and on a different axis.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s call this struct inside `ContentView`. We will call it just before
    the `SnowView` call; this way, the snow will appear on top of the tree images:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, run the code and check out the really cool animation of the tree branches
    blowing in the wind as the snow falls.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Play around with all the values that we’ve used in the various parameters and
    customize them to your liking. Maybe you want fewer branches for a thinner-looking
    tree, maybe you want the wind to blow much stronger, or maybe you want to animate
    all the trees in the background image... you can change all the settings to do
    just that.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue our exploration of some interesting animations. Up next, we will
    look at the rain particle system.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Animating rain
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our next project, let’s make it rain. We’re going to create a realistic effect
    by creating rain from the **Rain** particle template and making it bounce off
    the ground as you would see in a rainstorm. We’ll also create a puddle that will
    subtly grow and shrink, appearing to react to the falling rain, and it will also
    look like water, as we will add some blending options to it to give it a transparent
    look for a spectacular effect that even shows some of the ground underneath it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Rain SpriteKit particle file
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s get started. You know how to do this now – create an SKS file, choose
    `Rain` too. Now, configure the file to have the following attributes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12: The attributes of the rain animation ](img/B18674_15_12.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.12: The attributes of the rain animation'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Using the **Rain** particle template gives us rain right out of the box, but
    with some slight adjustments to the **Birthrate** and **Lifetime** options, we
    can alter how much of a rainstorm we want.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create another new file, this time, a SwiftUI file, which we will
    use to bring the rain effects into a SwiftUI view.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Creating the raindrops
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the SwiftUI file, press *Command + N* and call this file `DropView`.
    The code we will add to this file will be responsible for creating the collision
    effect between a raindrop and the ground. We’ll also alter the opacity and the
    blur to really help it blend into the scene.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add the following code inside the `DropView` struct:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There’s a lot going on here, so let’s break it down line by line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four `State` variables we need and each one has a specific task:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The first variable is of the `CGFloat` type and gets an initial value of `0.1`.
    This variable is used to control the scale of the drops.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two variables create arrays of `CGFloat` values, stored in the `xOffsets`
    and `yOffsets` state variables. The `map` method is used to generate random `CGFloat`
    values and the `CGFloat.random(in:)` method is used to generate a random `CGFloat`
    value within a given range. In short, these variables are used to set a random
    *x*- and *y*-coordinate position for each drop.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final variable is the `durations` variable, which randomizes the duration
    of the animation.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look at the `map` method since it is being used by three
    of our properties. The `map` method is a higher-order function in Swift that transforms
    an array of values into a new array of different values. It takes a closure expression
    as an argument, which is executed for each element in the original array and returns
    a new value for that element. The resulting array is then the combination of all
    of these new values.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code, the `map` method is being used to transform the range of integers
    between 0 and <300 into an array of `CGFloat` values, by using the `CGFloat.random(in:)`
    method to generate a random value for each element in the range. The closure expression
    passed to the `map` method takes a single argument, `_`, which is a placeholder
    for the current element of the range, and returns a new `CGFloat` value, generated
    by `CGFloat.random(in: -150...UIScreen.main.bounds.width)`. The `map` method combines
    all of these new values into a single array, which is then assigned to the `xOffsets`
    variable.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The `map` method is an important and versatile function in Swift, as it allows
    you to easily transform arrays and sequences of values into new arrays and sequences.
    Additionally, the `map` method is often used in combination with other functional
    programming techniques such as filter and reduce, to perform complex operations
    on arrays and sequences in a more efficient and maintainable way.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move into the `body` property and look at what the code is doing
    there.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We use a `ForEach` loop to iterate through a range from 0 and <150, and create
    a `Circle` view with each iteration – the circle will be the raindrop. Then, we
    set the `fill` color of the `Circle` view to `white`, the `width` and `height`
    values to `15`, and apply a `scaleEffect` with the value determined by the `dropScale`
    variable.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Next, we apply `rotation3DEffect` to the `Circle` view, with an angle of 80
    degrees on the *x*-axis; we want to rotate the drop so that it appears more like
    a raindrop colliding with the ground. Following that, we set its offset using
    the `xOffsets` and `yOffsets` variables with a value determined by the index.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: We then add the animation, setting the duration to be determined by the `index`
    constant, and repeating the animation with `autoreverse` set to `true` to create
    the realistic collision of the raindrop with the ground.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `onAppear` modifier, we give the `DropScale` variable a value
    of `0.8`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Running that in the previews will be a little difficult to see because of the
    white background, but let’s keep going and we’ll check out the results shortly.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create a new view that will make a puddle of water that we can animate
    and add to the scene.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Creating the puddle
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s now add a puddle to our scene, which we’ll do in a new SwiftUI View file
    called `PuddleView`. I’m going to add all the code for this view and then we’ll
    review how it works:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code defines a struct called `PuddleView` that has two properties, `scaleX`
    and `scaleY`, which are both `CGFloat` values. The `body` property of the struct
    is defined as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: A `ZStack` view is created, which arranges views on top of each other.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside `ZStack`, a `Capsule` view is created, which will be the shape of a
    puddle. The `Capsule` view is filled with a `LinearGradient` of colors and is
    then modified with several modifiers:'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opacity` modifier is set to `0.5`, making it partially transparent.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `blur` modifier is set with a radius of `5` pixels.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `frame` modifier sets the `width` property to `600` pixels and `height`
    to `500` pixels.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scaleEffect` modifier is set with the *x* and *y* scale values set to `scaleX`
    and `scaleY`, respectively. The `anchor` parameter is set to `.center`, indicating
    that the scaling should be the center of the capsule.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `animation` modifier has a `scaleX` value, with an `easeInOut` timing function
    and a `duration` value of `8` seconds, and is set to repeat forever with `autoreverses`.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then,`.overlay()` is used to create a new `Capsule` view that is placed on
    top of the previous one. This new `Capsule` view is also modified with several
    modifiers:'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stroke` modifier adds a gray stroke with a line width of `5` pixels.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `opacity` modifier is set to `0.5`, making it partially transparent.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `frame` modifier sets the `width` property to `350` pixels and `height`
    to `200` pixels.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `offset` modifier shifts the capsule slightly upward.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scaleEffect` modifier sets the *x* and *y* scale values, with `scaleX`
    set to `+ 0.03` and `scaleY` to `+ 0.03`, respectively. The `anchor` parameter
    is set to `.center`, indicating that the scaling should be centered on the capsule.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `animation` modifier has a `scaleY` value, with an `easeInOut` timing function
    and a `duration` value of `8` seconds, and is set to repeat forever with `autoreverses`.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onAppear` modifier sets the initial value of `scaleX` and `scaleY` to `0.54`
    and `0.6`, respectively.
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `rotation3DEffect` modifiers set an angle of `81` degrees on the *x*-axis.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ZStack` view is then modified with `.offset(x: -50, y: 300)` and `.onAppear
    { scaleX = 0.55; scaleY = 0.6 }`. This shifts the group view 50 pixels to the
    left and 300 pixels downward. This code block is executed when the view appears
    and sets the initial values of `scaleX` and `scaleY` to `0.55` and `0.6`, respectively.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, this code creates a view that looks like a puddle of water by using
    a gradient fill that’s partially transparent and blurred, and with a ripple effect
    added. The ripple effect is created by applying a scale effect to the second capsule
    view and animating the `scaleX` and `scaleY` properties so that it appears to
    be moving. The ripple effect is also rotated on the *x*-axis to make it more interesting.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `PuddleView` done, let’s just fill out `ContentView` and check out the
    animation. Add the following code to modify `ContentView`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `ContentView`, we added an image of a street, resized and scaled it, then
    called `PuddleView`. In `PuddleView`, `blendMode` is set to `hardLight`. Play
    around with the blend mode options for different looks and effects, but I think
    the hard light gives the best water effect so far, creating a glass-like look
    that is perfect for making a puddle of water where you can see some of the ground
    underneath.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I called `RainView` to add the rain, then `DropView` to add the collision
    effect of the raindrops hitting the ground, and then `Rainview` again just to
    add a little more rain to the mix. This is the result:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13: The raindrops ](img/B18674_15_13.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.13: The raindrops'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: This creates a nice effect of raindrops colliding with the ground and even with
    the puddle.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue and take a look at the **Magic** particle template and we will
    see how we can use an image to make the particles.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Animating a magic wand
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we’re going to use the **Magic** particle system, and we will
    display that magic from the tip of a wand. You will be able to move the wand around
    the screen with your finger, and as it moves, magic will emanate from its tip.
    We will also have a cemetery background including a gravestone, and when you tap
    on the gravestone, a skeleton will rise up from it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get started with our spooky animation. Create a new project and call
    this one `Magic`. Next, add the resources for this project by dragging them from
    the `Chapter 15` | `Magic` folder on GitHub into the Asset Catalog. Then, we can
    make our particle file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Creating the magic SpriteKit particle file
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we’ve done before, create a new SpriteKit particle file, but select the
    `Magic`. Now, let’s do something a little different this time – using the **Texture**
    field in the **Attributes** panel, select the **star** image that you placed into
    the Asset Catalog. We’re going to make the particle system based on that image,
    so all the particles will be stars. Next, change the rest of the fields so the
    values look like the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14: The attributes of the magic animation ](img/B18674_15_14.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.14: The attributes of the magic animation'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the **Color Ramp** field. It has three colors selected. If you would
    like to select a color for the **Color Ramp** field, simply click anywhere along
    the color selector, and then a pop-up color box will come up allowing you to choose
    a color. I’ve chosen three colors here: red will be the center of the animation,
    green will surround it, and the third color is yellow, which will be the outer
    part of the magic animation.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to make this `Magic.sks` file available as a SwiftUI view. So,
    let’s create a new Swift file, and call it `MagicView`. Then, add the following
    code to the file:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ve worked with this code in previous projects, so we’re familiar with it
    by now.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The code defines a struct called `MagicView`, which conforms to the `UIViewRepresentable`
    protocol in SwiftUI. The `makeUIView` function creates an instance of an `SKView`
    with a given frame size and sets its background color to `clear`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: It then creates an instance of `MagicScene`, specifying its size, setting its
    background color to `clear`, and scaling it to `aspectFill`. Finally, the created
    scene is presented on `SKView`, and the `SKView` instance is returned.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The `updateUIView` function does not perform any actions for us, as we don’t
    need to update anything, but it is a required method for the `UIViewRepresentable`
    protocol.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the code will give us an error because of this line: `let scene = MagicScene(size:
    CGSize(width: 900, height: 600))`. This is because we’re creating a scene and
    setting it to the `MagicScene` class, but we haven’t created a `MagicScene` class
    yet.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s do that now. Let’s create the `MagicScene` class, which will contain
    the properties and functions we need to manipulate the magic coming from the wand,
    as well as making the skeleton rise up from the ground. Create a new Swift file
    and call this `Magic`. I’m going to place all of the code here and then I’ll explain
    how it works:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Okay, let’s break down the code and see what it’s doing here.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `MagicScene` class, there are two instance variables declared:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '`magic` is an instance of `SKEmitterNode`, which is a class from SpriteKit
    that represents an emitter that can create particles.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wand` is an instance of `SKSpriteNode`, which is a class from SpriteKit that
    represents a textured rectangle.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MagicScene` class overrides two methods from `SKScene`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The `touchesMoved(_:with:)` method is called when the user moves their finger
    across the screen. Inside this method, the position of the wand sprite is updated
    to follow the user’s touch location. If the touch location is in a specific area
    of the screen, a skeleton sprite is created and animated to move to a specific
    location on the screen, straight up. Then, a new `SKEmitterNode` instance is created
    and added as a child of the `MagicScene` instance. This emitter is positioned
    relative to the wand sprite and emits particles that we created in the `.sks`
    file, and simulates the magic. After a duration of 1.2 seconds, the emitter fades
    away and is removed from the scene.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `didMove(to:)` method is called once when the scene is first presented.
    Inside this method, a stone sprite is created and positioned on the screen. Then,
    an `SKEmitterNode` instance is created and added as a child of the `MagicScene`
    instance. This emitter will also simulate magic particles. Finally, a wand sprite
    is created and positioned on the screen.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That completes the code for the `magic.sks` file. Let’s continue and head into
    `ContentView` and add a little bit of code there so we can see the magic. All
    we need to do is add the graveyard background scene and call `MagicView`. To do
    this, change your `ContentView` to the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With that bit of code, the project is done. Run the animation and start making
    magic:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15: The magic wand and graveyard scene ](img/B18674_15_15.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.15: The magic wand and graveyard scene'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Move the wand around and see the magic coming out of its tip, then tap on the
    gravestone to wake the skeleton!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With SpriteKit’s extensive support for physics and particle systems, combined
    with SwiftUI’s easy-to-use interface and modern design capabilities, you can create
    dynamic, engaging animations that bring your apps to life. As we have seen here,
    you can create smoke, rain, fire, snow, and magic, but there are even more particle
    systems to try and experiment with.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: As always, alter each project to your liking, and add your own unique creativity
    and ideas. Add sound to various parts of each project if you want – for example,
    in the magic wand project, maybe when the wand is moving, play a wand sound effect.
    Enhance the animations by altering the values, changing the images, or building
    out more complex scenes using the tools you now have. Just have fun because the
    effects are only limited by your imagination.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 就像往常一样，根据你的喜好调整每个项目，并加入你独特的创造力和想法。如果你想的话，可以为每个项目的各个部分添加声音——例如，在魔杖项目中，当魔杖移动时，可以播放魔杖音效。通过调整值、更改图像或使用你现在拥有的工具构建更复杂的场景来增强动画。只需享受乐趣，因为效果仅限于你的想象力。
- en: And with that, we have completed the final projects, and also the final chapter.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了最终项目，也完成了最后一章。
- en: Throughout the book, we delved into both implicit and explicit animations, exploring
    the differences between them and how to use them to achieve different effects.
    As we progressed through the book, we gradually introduced different modifiers
    and more challenging animation techniques, from basic bounces to more advanced
    moves. We also built two complete games that you can modify in many different
    ways.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们深入探讨了隐式和显式动画，研究了它们之间的区别以及如何使用它们来实现不同的效果。随着我们在书中的进展，我们逐渐介绍了不同的修饰符和更具挑战性的动画技术，从基本的弹跳到更高级的动作。我们还构建了两个完整的游戏，你可以以许多不同的方式对其进行修改。
- en: You now have the knowledge, skills, and a deeper understanding of SwiftUI animations
    to be able to implement a wide range of effects that will take your app to the
    next level and create engaging and dynamic user experiences.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有了知识、技能，以及对SwiftUI动画的更深入理解，能够实现一系列效果，将你的应用提升到下一个层次，并创造引人入胜且动态的用户体验。
- en: Happy animating!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你动画愉快！
