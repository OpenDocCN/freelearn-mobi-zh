<html><head></head><body><div><div><div><h1 id="_idParaDest-168" class="chapter-number"><a id="_idTextAnchor198"/>14</h1>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor199"/>Continuous Integration and Continuous Deployment</h1>
			<p>After we complete the development and first deployment of our app, we must think of how to <a id="_idIndexMarker722"/>make the process smoother for consecutive deployments, and that’s where <strong class="bold">Continuous integration/Continuous delivery</strong> (<strong class="bold">CI/CD</strong>) comes in.</p>
			<p>In this chapter, we will learn how to use GitHub Actions to automate some of the manual tasks, such as deploying new builds to the Google Play Store. We will learn how to run tests on CI/CD pipelines and push builds to the Play Store using GitHub Actions.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>Setting up GitHub Actions</li>
				<li>Running lint checks and tests on GitHub Actions</li>
				<li>Deploying to Play Store using GitHub Actions</li>
			</ul>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor200"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need to have Android Studio Hedgehog or later (<a href="https://developer.android.com/studio">https://developer.android.com/studio</a>) downloaded.</p>
			<p>You can use the previous chapter’s code to follow the instructions in this chapter. You can find the code for this chapter at <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfourteen</a>.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor201"/>Setting up GitHub Actions</h1>
			<p>Before we <a id="_idIndexMarker723"/>can understand GitHub Actions, we need to understand what CI/CD is. This is a process that allows us to automate the building, testing, and deployment of our code to production. CI/CD not only automates these processes but also integrates them into a single coherent pipeline. This ensures that code changes are more reliable and stable when deployed. The definition should emphasize the role of CI/CD in facilitating frequent and reliable updates. This is an especially <a id="_idIndexMarker724"/>important process as it aims to improve the speed, efficiency, and reliability of how we deliver our software.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor202"/>Benefits of CI/CD</h2>
			<p>Let’s go <a id="_idIndexMarker725"/>through some of the benefits of CI/CD:</p>
			<ul>
				<li><strong class="bold">Fast release cycles</strong>: CI/CD allows us to release our software faster and more frequently. This is because we are automating the process of building, testing, and deploying our code.</li>
				<li><strong class="bold">Increased collaboration</strong>: Since a lot of the processes are automated, we can focus on the code and the features we are building. This allows us to collaborate more effectively with our team.</li>
				<li><strong class="bold">Less manual work</strong>: We are reducing the amount of manual work we do due to automation. This means we can focus on the code and the features we are building.</li>
				<li><strong class="bold">Improved quality</strong>: Automating the process allows us to test our code more frequently and more effectively. This means we can catch bugs and errors earlier in the process.</li>
			</ul>
			<p>Now we have learned about the benefits of CI/CD, let us look at how CI/CD works in detail.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor203"/>How CI/CD works</h2>
			<p>Let us <a id="_idIndexMarker726"/>go through how CI/CD works:</p>
			<ul>
				<li><strong class="bold">CI</strong>: This is the <a id="_idIndexMarker727"/>process of automating the building and testing of our code. This is done every time we push our code to our repository. This allows us to catch bugs and errors earlier in the process. In this step, once we push or commit code to our remote repository, which can be hosted in GitHub, Gitlab, Bitbucket, and so on, we run checks and tests against these changes to ensure they are functional and meet the code quality standards. If the <a id="_idIndexMarker728"/>tests pass, we can merge the code into the main branch. If the tests fail, we can fix the code and run the tests again.</li>
				<li><strong class="bold">CD</strong>: This is the process of automating the deployment of our code to production. This is done every time we push our code to our repository. This allows us <a id="_idIndexMarker729"/>to release our software faster and more frequently. This happens after the CI step. Once the changes are merged to the main or development branch, we can deploy the code to production or whichever environment it needs to be deployed to. This step aims at pushing minor changes to production more frequently. This allows us to release our software faster and more frequently.</li>
			</ul>
			<p>With this <a id="_idIndexMarker730"/>background, we can now look at GitHub Actions (<a href="https://docs.github.com/en/actions">https://docs.github.com/en/actions</a>). GitHub Actions is a CI/CD tool that allows us to automate the building, testing, and deployment of our code. It is built into GitHub and is free to use up to certain limits. It is also extremely easy to use and set up.</p>
			<p>In the next section, we are going to set up GitHub Actions for our project that is in this repository: <a href="https://github.com/PacktPublishing/Mastering-Kotlin-for-Android">https://github.com/PacktPublishing/Mastering-Kotlin-for-Android</a></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor204"/>Setting up GitHub Actions</h2>
			<p>To enable <a id="_idIndexMarker731"/>GitHub Actions in our project, follow these steps:</p>
			<ol>
				<li>Go to the <strong class="bold">Actions</strong> tab of our repository, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19779_14_01.jpg" alt="Figure 14.1 – GitHub Actions tab" width="690" height="156"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – GitHub Actions tab</p>
			<p class="list-inset">This step will bring us to the GitHub Actions landing page:</p>
			<div><div><img src="img/B19779_14_02.jpg" alt="Figure 14.2 – GitHub Actions landing page" width="1147" height="871"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – GitHub Actions landing page</p>
			<ol>
				<li value="2">As seen <a id="_idIndexMarker732"/>in the preceding image, we have some suggested actions that we can use in our repository. For now, we will set the actions by ourselves, so let us click on the <strong class="bold">set up a workflow yourself</strong> option. This brings us to the following page:</li>
			</ol>
			<div><div><img src="img/B19779_14_03.jpg" alt="Figure 14.3 – New GitHub Action" width="842" height="539"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – New GitHub Action</p>
			<p class="list-inset">As you can <a id="_idIndexMarker733"/>see in the preceding image, we have an editor for writing our workflow. Notice at the top we now have a new folder called <code>.github</code>. This is where we will store our workflow files. The editor saves the workflow file in the <code>.github/workflows</code> folder. By default, our workflow is named <code>main.yml</code>. On the right, we have templates that we can use to easily create our workflow.</p>
			<ol>
				<li value="3">For now, we are going to create our own workflow, so let us add the following code to our workflow:<pre class="source-code">
name: Push
on:
  push:
    branches: ["main" ]
  workflow_dispatch:
jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
        - run: echo "The job was automatically triggered by a ${{ github.event_name }} event."</pre><p class="list-inset">Let’s understand <a id="_idIndexMarker734"/>the different fields in the preceding workflow file:</p><ul><li><code>name</code>: This is the name of our workflow. This will be displayed on the GitHub Actions page.</li><li><code>on</code>: This is the event that will trigger our workflow. In our case, we are triggering our workflow when we push code to the main branch.</li><li><code>workflow_dispatch</code>: This is a manual trigger that we can use to trigger our workflow from the GitHub Actions page. This is useful when we want to trigger our workflow manually.</li><li><code>jobs</code>: This is the job that will be run when our workflow is triggered. In our case, we have a job called <code>build</code>. This job will run on the latest version of Ubuntu as specified by the <code>runs-on</code> field.</li><li><code>steps</code>: This field contains the steps that will be run in our job. In our case, we have a single step that will run a command. This command will print out the event that triggered our workflow. A step can contain a shell command or an action from GitHub Marketplace.</li></ul></li>				<li>Click on the <strong class="bold">Commit changes...</strong> button. This will commit our workflow file to our repository and trigger our workflow. We can see the workflow running in the <strong class="bold">Actions</strong> tab, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19779_14_04.jpg" alt="Figure 14.4 – First GitHub Action" width="836" height="173"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – First GitHub Action</p>
			<p class="list-inset">In the preceding image, we can see the commit that triggered the workflow and the workflow itself. We can also see the job that was run and the step that was run. We can <a id="_idIndexMarker735"/>also see the output of the step. Additionally, we can see the time it took to run the workflow. If we tap the action, we can see more details:</p>
			<div><div><img src="img/B19779_14_05.jpg" alt="Figure 14.5 – Github Action details" width="687" height="209"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Github Action details</p>
			<p class="list-inset">This shows the steps that were run and the time the job took to run. It also shows the total duration of the workflow.</p>
			<p class="list-inset">This was a simple workflow that just printed out the event that triggered the workflow. We can also do more complex things in our workflow.</p>
			<p>Let us see how we can set up Android-related actions in our workflow:</p>
			<ol>
				<li>Head to the newly created <code>.github/workflows</code> folder and edit the <code>main.yml</code> file.</li>
				<li>Let us add the following code to our workflow below the previous command we ran in <em class="italic">step 3 </em>of the previous section:<pre class="source-code">
- name: Checkout
  uses: actions/checkout@v3
- name: Set up JDK 17
  uses: actions/setup-java@v3
  with:
    java-version: '17'
    distribution: 'zulu'
    cache: gradle
- name: Grant execute permission for gradlew
  run: chmod +x gradlew
  working-directory: ./chapterfourteen
- name: Build with Gradle
  run: ./gradlew assembleDebug
  working-directory: ./chapterfourteen</pre><p class="list-inset">Let us <a id="_idIndexMarker736"/>understand the preceding code:</p><ul><li>We have created another step called <code>Checkout</code>. This step will <code>checkout</code> our code from our repository. This is done using the <code>checkout</code> action, which we specify using the <code>uses</code> field. This action is fetched from GitHub Marketplace.</li><li>We have <a id="_idIndexMarker737"/>created another step called <code>Set up JDK 17</code>. This step will set up JDK 17. <code>setup-java</code> action, which we specify using the <code>uses</code> field. We specify the version of Java we want to use using the <code>java-version</code> field. We specify the distribution of Java we want to use using the <code>distribution</code> field. We also specify that we want to cache Gradle using the <code>cache</code> field.</li><li>We have <a id="_idIndexMarker739"/>created another step called <code>Grant execute permission for gradlew</code>. This step will grant execute permission for gradlew. This is done using the <code>run</code> command. We specify the command we want to run using the <code>run</code> field. We also specify the working directory we want to run the command in using the <code>working-directory</code> field. In this case, we want to run the command in the <code>chapterfourteen</code> folder since we have a number of folders in our repository. Note that this step is platform-dependent since it is only necessary for Unix-based systems but might be redundant for Windows-based systems. Therefore, it may not be required in all CI/CD setups.</li><li>Lastly, we have created another step called <code>Build with Gradle</code>. This step will build our project using Gradle. <a id="_idTextAnchor205"/>Here, we run the <code>./gradlew assembleDebug</code> command. This command generates a debug Android APK for our project. We also specify the working directory in which we want to run the command.</li></ul><p class="list-inset">One thing to note is that <code>.yml</code> files are overly sensitive to indentation. So, we need to ensure that we indent our code correctly.</p></li>				<li>Commit to the changes and the action will automatically run. We can see the workflow results and, looking at the job build, we can see all the steps that were run, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19779_14_06.jpg" alt="Figure 14.6 – GitHub Action steps" width="759" height="320"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – GitHub Action steps</p>
			<p>We now know <a id="_idIndexMarker740"/>what GitHub Actions are, have created our first action, and have seen how we can run Android-specific workflows on GitHub Actions. In the next section, we will run lint checks and tests in our workflow.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor206"/>Running lint checks and tests on GitHub Actions</h1>
			<p>In <a href="B19779_11.xhtml#_idTextAnchor135"><em class="italic">Chapter 11</em></a>, we learned how to run lint checks on our project using shell commands on the terminal. We have <a id="_idIndexMarker741"/>also learned how to write tests for our code <a id="_idIndexMarker742"/>base. In this section, we are going to run the format, lint checks, and tests on our newly created actions and we will do all of this step by step:</p>
			<ol>
				<li>First, we will add the <code>ktlintCheck</code> step:<pre class="source-code">
- name: Run ktlintCheck
  run: ./gradlew<a id="_idTextAnchor207"/> ktlintCheck
  working-directory: ./chapterfourteen</pre><p class="list-inset">In this code, we have added a step called <code>Run ktlintCheck</code>. This step will run the <code>ktlintCheck</code> command, which will check whether our code is formatted correctly. This step fails if our code is not formatted correctly.</p></li>				<li>Next, we add the <code>detekt</code> step:<pre class="source-code">
- name: Run detekt
  run: ./gradlew detekt
  working-directory: ./chapterfourteen</pre><p class="list-inset">In this step, we run the <code>detekt</code> command, which will run the detekt checks on the code that we set up earlier in <a href="B19779_11.xhtml#_idTextAnchor135"><em class="italic">Chapter 11</em></a>. This step fails if our code does not pass the detekt checks.</p></li>				<li>Next, we add the test step:<pre class="source-code">
- name: Run unit tests
  run: ./gradlew testDebugUnitTest
  working-directory: ./chapterfourteen</pre><p class="list-inset">This step <a id="_idIndexMarker743"/>will run all the unit tests in our project. This step <a id="_idIndexMarker744"/>fails if any of the tests fail.</p></li>				<li>Lastly, we add the step to run our instrumented tests:<pre class="source-code">
- name: Run connected tests
  uses: ReactiveCircus/android-emulator-runner@v2
  with:
    working-directory: ./chapterfourteen
    api-level: 33
    target: google_apis
    arch: x86_64
    disable-animations: true
    script: ./gradlew connectedCheck</pre><p class="list-inset">This step uses the <code>android-emulator-runner</code> action to run our instrumented tests on an emulator. This action sets up an emulator to run our instrumented tests in the CI environment. In the action configuration, we set up the following:</p><ul><li><code>working-directory</code>: This is where our project is located.</li><li><code>api-level</code>: This is the API level of the platform system image for our emulator.</li><li><code>target</code>: This is the target for the system image of the emulator.</li><li><code>architecture</code>: We specify the architecture of the emulator we want to run our tests on.</li><li><code>disable-animations</code>: We disable animations in the emulator.</li><li>Lastly, we specify the command we want to run using the script field. In this case, we run the <code>connectedCheck</code> task, which will run our instrumented tests.</li></ul></li>				<li>After making <a id="_idIndexMarker745"/>the p<a id="_idTextAnchor208"/>receding changes, commit the changes <a id="_idIndexMarker746"/>and the action will run. We can see the results of the action in the <strong class="bold">Actions</strong> tab, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B19779_14_07.jpg" alt="Figure 14.7 – More Github Actions steps" width="981" height="490"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – More Github Actions steps</p>
			<p>We’ve expanded our workflow by incorporating additional steps to perform lint checks and tests. We can see the results of each step. We can also see the time it took to run each step. The <code>Run connected test</code> step takes the longest time to run. This is because it must set up the emulator and run the tests.</p>
			<p>We need to modify when the <code>main.yml</code> file runs. Currently, our workflow runs when we push code to the main branch. We are going to change this to also run <a id="_idIndexMarker747"/>when we create a pull request to the main branch. This is because <a id="_idIndexMarker748"/>we want to run our checks before we move our code to the main branch. To do this, we are going to add the <code>pull_request</code> event just above the <code>workflow_dispatch</code> event:</p>
			<pre class="source-code">
on:
  push:
    branches: ["main" ]
  pull_request:
  workflow_dispatch:</pre>			<p>After making <a id="_idTextAnchor209"/>this change, we can commit the changes and the action will run. Let us now create a pull request to test the changes. Ensure that you pull all the changes that we made in our browser locally before proceeding with the following steps:</p>
			<ol>
				<li>First, let us create a new branch called <code>test</code>.</li>
				<li>Open the terminal in Android Studio and run the following command:<pre class="source-code">
<code>test</code> and switches to the newly created branch.</p></li>				<li>Next, let us modify the app’s <code>versionName</code> and <code>versionCode</code> in our app-level <code>build.gradle.kts</code> file:<pre class="source-code">
versionCode = 2
versionName = "1.0<a id="_idTextAnchor210"/>.1"</pre></li>				<li>Tap <strong class="bold">Sync Now</strong> to sync these changes to our project.</li>
				<li>After making the <code>versionName</code> and <code>versionCode</code> changes, we can commit the changes and push them to our remote repository. We can do this by running the following command <a id="_idTextAnchor211"/>in the terminal:<pre class="source-code">
<strong class="bold">it add .</strong></pre><p class="list-inset">This command stages all the changes we have made.</p></li>				<li>Next, we run <a id="_idIndexMarker749"/>the following command:<pre class="source-code">
<strong class="bold">git commit -m "Update app version name and code"</strong></pre><p class="list-inset">This <a id="_idIndexMarker750"/>command commits the changes we have made.</p></li>				<li>Next, we run the following command:<pre class="source-code">
<strong class="bold">git push origin test</strong></pre><p class="list-inset">This command pushes the changes to our remote repository.</p></li>				<li>Next, head to our repository in a browser, open the <strong class="bold">Pull requests</strong> tab, and click on the <strong class="bold">New pull request</strong> button. This will open the following page:</li>
			</ol>
			<div><div><img src="img/B19779_14_08.jpg" alt="Figure 14.8 – Create a new pull request" width="1093" height="438"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – Create a new pull request</p>
			<p class="list-inset">On this page, we set the <code>base</code> branch and the <code>compare</code> branch. The <code>base</code> branch is the branch we want <a id="_idTextAnchor212"/>to merge our changes to. In our case, we want to merge our changes to the <code>main</code> branch. The <code>compare</code> branch is the branch that has recent changes. In our case, we want to merge changes from the <code>test</code> branch to the <code>main</code> branch. We can see the changes we have made as soon as we set the <code>compare</code> branch.</p>
			<ol>
				<li value="9">Finalize the <a id="_idIndexMarker751"/>pull request by clicking on the <strong class="bold">Create pull request</strong> button. After <a id="_idIndexMarker752"/>creating the pull request, we can review the pull request details:</li>
			</ol>
			<div><div><img src="img/B19779_14_09.jpg" alt="Figure 14.9 – Pull request checks" width="906" height="801"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Pull request checks</p>
			<p class="list-inset">As seen in the preceding image, the workflow checks have started running since we created a pull request and we specified that our workflow should run when we create a pull request. The <strong class="bold">Merge pull request</strong> button is disabled since the workflow is still running.</p>
			<p class="list-inset">Once the workflow is done running, we can merge the pull request. We can enforce even further rules per the checks but for now, we are good to go with the default <a id="_idIndexMarker753"/>behavior. Once the workflow completes and all <a id="_idIndexMarker754"/>checks pass, we should see the following:</p>
			<div><div><img src="img/B19779_14_10.jpg" alt="Figure 14.10 – Pull request checks complete" width="908" height="809"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Pull request checks complete</p>
			<p>We have now learned how to run lint checks and tests on GitHub Actions. In the next section, we are going to learn how to deploy our app to Google Play Store using GitHub Actions.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor213"/>Deploying to Play Store using GitHub Actions</h1>
			<p>In <a href="B19779_13.xhtml#_idTextAnchor175"><em class="italic">Chapter 13</em></a>, we learned how to deploy our app to Google Play Store using Google Play Console. However, in that chapter, we did it manually. In this chapter, we are going to learn <a id="_idIndexMarker755"/>how to deploy our app to Google Play Store using GitHub Actions. We are going to use the Google Play Publisher action to <a id="_idIndexMarker756"/>deploy our app to Google Play Store. This action is available in GitHub Marketplace.</p>
			<p>Before we can write our workflow, we need to do some setup. We need to create a service account on our Google Play Store account. We can do this by following these steps:</p>
			<ol>
				<li>Configure the service account in Google Cloud Platform by following these steps:<ol><li class="upper-roman">Navigate to <a href="https://cloud.google.com/gcp">https://cloud.google.com/gcp</a>.</li><li class="upper-roman">Navigate to <code>GOOGLE_SERVICES_JSON</code>. This is the name we will use in our workflow to access the JSON file.</li></ol></li>
				<li>Add a user to Google Play Console by following these steps:<ol><li class="upper-roman" value="8">Open <a href="https://play.google.com/console">https://play.google.com/console</a> and pick your developer account.</li><li class="upper-roman">Open <strong class="bold">Users </strong><strong class="bold">and permissions</strong>.</li><li class="upper-roman">Click on <strong class="bold">Invite new user</strong> and add the email of the service account created in step 1.</li><li class="upper-roman">Grant permissions to the app to which you want the service account to deploy in-app permissions.</li></ol><p class="list-inset">If you need more details on how to do this, you can check out the following link: <a href="https://developers.google.com/android/management/service-account">https://developers.google.com/android/management/service-account</a></p></li>
			</ol>
			<p>Like how we created the <code>GOOGLE_SERVICES_JSON</code> variable in our repository secrets, we need to add the details of our signing certificate to our variables so that we can use <a id="_idIndexMarker757"/>them on our CI/CD pipeline. The first step is to generate a <code>base64</code>-encoded version of our signing certificate. We can do <a id="_idIndexMarker758"/>this by running the following command in the terminal:</p>
			<pre class="console">
openssl base64 &lt; packt.jks | tr -d '\n' | tee packt.jks.base64.txt</pre>			<p>You should run this command in the directory where you saved your keystore file. You could change the name to match the filename of the keystore file if you named yours differently. This command will generate a <code>base64</code>-encoded version of our keystore file. We can then copy the contents of the file and add it to our repository secrets. We need to also add the following secrets to our repository:</p>
			<div><div><img src="img/B19779_14_11.jpg" alt="Figure 14.11 – Repository secrets" width="566" height="392"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.11 – Repository secrets</p>
			<p>The newly <a id="_idIndexMarker759"/>created secrets are explained as follows:</p>
			<ul>
				<li><code>KEYSTORE_PASSWORD</code>: This is the password of our keystore file</li>
				<li><code>KEY_ALIAS</code>: This is the alias of our keystore file</li>
				<li><code>KEY_PASSWORD</code>: This is the password of our keystore file alias</li>
			</ul>
			<p>All these <a id="_idIndexMarker760"/>details should be like the ones we used when we created our keystore file. Now, let us write our workflow. Before writing the workflow, ensure that you have completed the publishing of our app steps in <a href="B19779_13.xhtml#_idTextAnchor175"><em class="italic">Chapter 13</em></a>, since this is needed for this action to work. Let us head to the <code>.github/workflows</code> folder, create a new file called <code>deploy-to-playstore.yml</code>, and add the following code:</p>
			<pre class="source-code">
name: Deploy to Playstore
on:
  push:
    branches: [ "main"]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: set up JDK 17
        uses: actions/setup-java@v3
        with:
          distribution: 'zulu'
          java-version: '17'
  <a href="mailto:chkfung/android-version-actions@v1.1">    - name: Bump version</a>
<a href="mailto:chkfung/android-version-actions@v1.1">        use</a>s: chkfung/android-version-actions@v1.1
        with:
          gradlePath: chapterfourteen/build.gradle.kts
          versionCode: ${{github.run_number}}
          versionName: ${{ format('1.0.{0}', github.run_number ) }}
      - name: Assemble Release Bundle
        working-directory: chapterfourteen
        run: ./gradlew bundleRelease
      - name: De<a href="mailto:r0adkll/upload-google-play@v1.1.1">ploy to Internal Testing</a>
<a href="mailto:r0adkll/upload-google-play@v1.1.1">        </a>uses: r0adkll/upload-google-play@v1.1.1
        with:
          serviceAccountJsonPlainText: ${{ secrets.GOOGLE_SERVICES_JSON }}
          packageName: com.packt.chapterthirteen
          releaseFiles: chapterfourteen/build/outputs/bundle/release/app-release.aab
          track: internal
          whatsNewDirectory: whatsnew/
          status: completed</pre>			<p>The workflow <a id="_idIndexMarker761"/>is remarkably similar to the one we created earlier on in the <em class="italic">Setting up GitHub Actions</em> and <em class="italic">Running lint checks and tests in GitHub Actions</em> sections with only slight differences. We have a step that bumps the <code>versionName</code> and <code>versionCode</code> for us instead of us having to do this <a id="_idIndexMarker762"/>manually every time. Versioning serves as a structured identifier for different software iterations. Employing semantic versioning aids in communicating the impact of changes, distinguishing major backward-incompatible updates, minor backward-compatible feature additions, and patch-level bug fixes. It plays a crucial role in dependency management, facilitating compatibility between different components. Additionally, versioning supports rollbacks, hotfixes, and efficient testing, ensuring the stability of the application. Release notes and communication are streamlined, providing users and stakeholders with clear insights into each release. Ultimately, versioning contributes to a reliable and predictable user experience, fostering trust and transparency throughout the software development life cycle.</p>
			<p>We have <a id="_idIndexMarker763"/>another step that builds a signed <code>upload-google-play</code> action, which automates and makes the process easier. We do the configurations on this action, such as specifying our service account, the package name of our app on Play Store, the directory where our signed AAB will be found, and lastly, the track that we want to deploy to. Pushing the changes to the main branch will trigger the actions again and once the <code>deploy-to-playstore</code> workflow is complete, we should see a new internal testing release on our Play Store page, as shown in the following:</p>
			<div><div><img src="img/B19779_14_12.jpg" alt="Figure 14.12 – New internal testing release" width="527" height="152"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.12 – New internal testing release</p>
			<p>We have <a id="_idIndexMarker764"/>completed putting in place our CI/CD process. We <a id="_idIndexMarker765"/>only do this setup once and we can always use it to make deployments and automated testing easier, faster, and more reliable for us.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor214"/>Summary</h1>
			<p>In this chapter, we learned how to use GitHub Actions to automate some manual tasks, such as deploying new builds to the Play Store. Additionally, we learned how to run lint checks and tests on CI/CD pipelines and push builds to Google Play Store using GitHub Actions.</p>
			<p>In the next chapter, we will learn about techniques to improve our apps by adding analytics, using Firebase Crashlytics, and using cloud messaging to increase user engagement in our apps. Additionally, we will learn some tips and tricks for securing our apps.</p>
		</div>
	</div></div></body></html>