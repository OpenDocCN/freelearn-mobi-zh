<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Adding Game Logic"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Adding Game Logic</h1></div></div></div><p>
<span class="emphasis"><em>In the previous chapter, we learned about animating our objects on the screen using tweens; we also learned about sprite sheets, generated our very own sprite sheet with texture information, and animated it.</em></span>
</p><p>Let's take a quick look at what kind of topics we will tackle in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shooting cannonballs, which is pretty much a core mechanic of our game</li><li class="listitem" style="list-style-type: disc">Once a cannonball is displayed on the battlefield, it should be able to collide with the enemy ship</li><li class="listitem" style="list-style-type: disc">Destroying the enemy ship, if enough cannonballs hit the ship</li></ul></div><div class="section" title="Extending the asset manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Extending the asset manager</h1></div></div></div><p>In the previous chapter, we loaded our very first texture atlas and displayed each subtexture as frames in a movie clip. We did not use our asset manager for this as we hadn't implemented this functionality yet.</p><p>So, let's go ahead and allow our asset manager to deal with texture atlases.</p></div></div>
<div class="section" title="Time for action &#x2013; adding texture atlases to the asset manager"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Time for action – adding texture atlases to the asset manager</h1></div></div></div><p>We can <a id="id239" class="indexterm"/>extend our asset manager with the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open our game's project file, if it's not already open.</li><li class="listitem">Switch to the <code class="literal">TextureManager.h</code> file and declare the method <code class="literal">registerTextureAtlas</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(SPTextureAtlas *) registerTextureAtlas:(NSString *) filename;</pre></div></li><li class="listitem">Switch to the <code class="literal">TextureManager.m</code> file and implement the <code class="literal">registerTextureAtlas</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(SPTextureAtlas *) registerTextureAtlas:(NSString *) filename
{
    if ([_dict objectForKey:filename] == nil) {
    return (SPTextureAtlas *) [self registerAsset:filename withContent:[SPTextureAtlas atlasWithContentsOfFile:filename]];
  } else {
    return (SPTextureAtlas *) [self registerAsset:filename withContent:nil];
  }
}</pre></div></li><li class="listitem">Head over to the <code class="literal">Assets.h</code> file and add the static method <code class="literal">textureAtlas</code>:<div class="informalexample"><pre class="programlisting">+(SPTextureAtlas *) textureAtlas:(NSString*)filename;</pre></div></li><li class="listitem">In<a id="id240" class="indexterm"/> the <code class="literal">Assets.m</code> file, implement the following method by referring to its <code class="literal">TextureManager</code> instance:<div class="informalexample"><pre class="programlisting">+(SPTextureAtlas *) textureAtlas:(NSString*)filename
{
    return [textureAssets registerTextureAtlas:filename];
}</pre></div></li><li class="listitem">In the battlefield scene (<code class="literal">Battlefield.m</code>), navigate to where we are loading the texture atlas and getting the textures:<div class="informalexample"><pre class="programlisting">SPTextureAtlas *atlas = [SPTextureAtlas atlasWithContentsOfFile:@"ship_pirate_small_cannon.xml"];

NSArray *textures = [atlas texturesStartingWith:@"00"];</pre></div><p>Replace the preceding code with the following line of code:</p><div class="informalexample"><pre class="programlisting">NSArray *textures = [[Assets textureAtlas:@"ship_pirate_small_cannon.xml"] texturesStartingWith:@"00"];</pre></div></li><li class="listitem">Run the example. We will see the following constellation of ships on the screen:<div class="mediaobject"><img src="graphics/1509OS_06_01.jpg" alt="Time for action – adding texture atlases to the asset manager"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In step 1, we opened our Xcode template from where we left off in the previous chapter. In order to<a id="id241" class="indexterm"/> load texture atlases, we needed to switch to the texture manager, which we designated to load everything that is remotely connected to textures. In step 2, we declared the method we used in order to use texture atlases through the asset management system. To keep the method names consistent, we will name this method <code class="literal">registerTextureAtlas</code> to make it similar to <code class="literal">registerTexture</code>. The signature resembles that of <code class="literal">registerTexture</code>, but it returns an instance of <code class="literal">SPTextureAtlas</code> instead of <code class="literal">SPTexture</code>.</p><p>In the next step, we implemented the <code class="literal">registerTextureAtlas</code> method that loads the texture<a id="id242" class="indexterm"/> through the <code class="literal">filename</code> parameter, and we used the <code class="literal">SPTextureAtlas</code> factory method just like we did when we learned about texture atlases.</p><p>Once we finished extending the texture manager part, we needed to extend the <code class="literal">Assets</code> class, which we did in step 4 by adding the function head which we implemented in step 5. To keep the naming scheme consistent, we named this method <code class="literal">textureAtlas</code>. In this method, we just called the <code class="literal">registerTextureAtlas</code> method of our texture manager and returned the result.</p><p>We updated the lines in the battlefield to load the texture atlas for the movie clip through the asset management system. Instead of two lines—one for setting up the texture atlas instance and another for getting the needed textures out of the atlas—we now have only a single line that gets our texture atlas with the <code class="literal">textureAtlas</code> method from the last two steps and then gets the necessary textures for the movie clip.</p><p>When we ran the example in the last step, we had the exact result as we did at the end of the previous <a id="id243" class="indexterm"/>chapter, which is a good sign and an indication that the changes work as they should.</p></div></div>
<div class="section" title="Structuring our ships"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Structuring our ships</h1></div></div></div><p>So far, our ships are just instances of <code class="literal">SPImage</code> with tweens attached to them right inside our battlefield scene. In order to keep code duplication to a minimum, let's refactor the ship logic into its own class.</p></div>
<div class="section" title="Time for action &#x2013; creating a ship class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Time for action – creating a ship class</h1></div></div></div><p>To <a id="id244" class="indexterm"/>structure the code of our ship, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new group called <code class="literal">Entities</code>.</li><li class="listitem">Inside this group, add a new Objective-C class called <code class="literal">Ship</code>, which is derived from <code class="literal">SPSprite</code>.</li><li class="listitem">Open the <code class="literal">Ship.h</code> file. Add one instance variable for the ship image and another for the movie clip of the ship shooting cannonballs, as shown in the following code:<div class="informalexample"><pre class="programlisting">SPMovieClip *_shootingClip;
SPImage *_idleImage;</pre></div></li><li class="listitem">Declare an alternative initializer called <code class="literal">initWithContentsOfFile</code>, which takes an <code class="literal">NSString</code> as its parameter:<div class="informalexample"><pre class="programlisting">-(id)initWithContentsOfFile:(NSString *)filename;</pre></div></li><li class="listitem">Declare a method called <code class="literal">shoot</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(void) shoot;</pre></div></li><li class="listitem">Declare another method called <code class="literal">moveTo</code> that takes the <code class="literal">x</code> value as its first parameter and the <code class="literal">y</code> value as its second parameter, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(void) moveToX:(float) x andY:(float) y;</pre></div></li><li class="listitem">Declare a method called <code class="literal">stop</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(void) stop;</pre></div></li><li class="listitem">Define the default initializer for the <code class="literal">Ship</code> class with the following lines of code:<div class="informalexample"><pre class="programlisting">-(id) init
{
  if ((self = [super init])) {
    NSArray *textures = [[Assets textureAtlas:@"ship_pirate_small_cannon.xml"] texturesStartingWith:@"00"];
    
    _shootingClip = [SPMovieClip movieWithFrames:textures fps:20.0f];
    
    if (_idleImage == nil) {
      _idleImage = [[SPImage alloc] init];
    }
    
    [self addChild:_shootingClip];
    [self addChild:_idleImage];
  }

  return self;
} </pre></div></li><li class="listitem">Now, define<a id="id245" class="indexterm"/> the alternate initializer that takes <code class="literal">filename</code> as its parameter, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(id) initWithContentsOfFile:(NSString *)filename
{
  _idleImage = [[SPImage alloc] initWithTexture:[Assets texture:filename]];

  return [self init];
}</pre></div></li><li class="listitem">Implement the <code class="literal">shoot</code> method with the following lines:<div class="informalexample"><pre class="programlisting">-(void) shoot
{
  [_shootingClip play];
  [Sparrow.juggler addObject:_shootingClip];
}</pre></div></li><li class="listitem">The content of the <code class="literal">moveTo</code> method should look like the following code:<div class="informalexample"><pre class="programlisting">-(void) moveToX:(float)x andY:(float)y
{
  [self stop];

  float targetX = x - (self.width / 2);
  float targetY = y - (self.height / 2);

  float distanceX = fabsf(self.x - targetX);
  float distanceY = fabsf(self.y - targetY);

  float penalty = (distanceX + distanceY) / 80.0f;

  float shipInitial = 0.25f + penalty;

  float speedX = shipInitial + (distanceX / 
    Sparrow.stage.width) * penalty * penalty;
  float speedY = shipInitial + (distanceY / Sparrow.stage.height) * penalty * penalty;

  SPTween *tweenX = [SPTween tweenWithTarget:self time:speedX];
  SPTween *tweenY = [SPTween tweenWithTarget:self time:speedY];


  [tweenX animateProperty:@"x" targetValue:targetX];
  [tweenY animateProperty:@"y" targetValue:targetY];

  [Sparrow.juggler addObject:tweenX];
  [Sparrow.juggler addObject:tweenY];
}</pre></div></li><li class="listitem">Implement <a id="id246" class="indexterm"/>the <code class="literal">stop</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(void) stop
{
    [Sparrow.juggler removeObjectsWithTarget:self];
}</pre></div></li><li class="listitem">Switch to the <code class="literal">Battlefield.h</code> file and update the class so that the instance variable <code class="literal">_pirateShip</code> is from the type <code class="literal">Ship</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">#import "Scene.h"
<span class="strong"><strong>#import "Ship.h"</strong></span>

@interface Battlefield : Scene {
<span class="strong"><strong>    Ship</strong></span> *_pirateShip;
}</pre></div></li><li class="listitem">Now, switch to the <code class="literal">Battlefield.m</code> file.</li><li class="listitem">Update the <code class="literal">onBackgroundTouch</code> method in the scene, as shown in the following code:<div class="informalexample"><pre class="programlisting">SPTouch *touch = [[event touchesWithTarget:self] anyObject];

if (touch) {
  <span class="strong"><strong>[_pirateShip moveToX:touch.globalX andY:touch.globalY];</strong></span>
}</pre></div></li><li class="listitem">Next, update the <code class="literal">onShipStop</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];

if (touch) {
  <span class="strong"><strong>[_pirateShip stop];</strong></span>
}</pre></div></li><li class="listitem">Update the remaining references from <code class="literal">SPImage</code> to the <code class="literal">Ship</code> class and remove all occurrences of the cannon ship, as shown in the following code:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>_pirateShip = [[Ship alloc] initWithContentsOfFile:@"ship_pirate.png"];</strong></span>
_pirateShip.x = (Sparrow.stage.width - _pirateShip.width) / 2;
_pirateShip.y = (Sparrow.stage.height - _pirateShip.height) / 2;

<span class="strong"><strong>Ship *ship = [[Ship alloc] initWithContentsOfFile:@"ship.png"];</strong></span>
ship.x = 100;
ship.y = 100;</pre></div></li><li class="listitem">Run <a id="id247" class="indexterm"/>the example. We now see the pirate and enemy ships on the screen:<div class="mediaobject"><img src="graphics/1509OS_06_02.jpg" alt="Time for action – creating a ship class"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In game development, the term entity usually refers to an object on the screen which interacts with other objects. Let's take a 2D action side-scroller as an example: the enemy ships as well as the ship controlled by the player were entities. The bullets were entities too. A bullet, for example, interacted with the player ship as it spawned from it. The enemy ships interacted with the bullets; if a bullet hit an enemy ship, it needed to react by losing hit points or by being destroyed. The same applied to the player ship.</p><p>Entities also feature in more advanced game development techniques such as the entity-component pattern, where the interaction is described as components. These components are then attached to entities.</p><p>What we need to take away from our game is a clear separation between the different elements of the game. In step 1, we added a new group called <code class="literal">Entities</code>. In the next step, we defined our very first entity called <code class="literal">Ship</code>, which is a subclass of <code class="literal">SPSprite</code>. It was also possible to add a prefix before the class name, just like all Sparrow classes have the prefix <code class="literal">SP</code>. For our game, the prefix <code class="literal">PG</code> would make sense as it stands for PirateGame.</p><p>The ship<a id="id248" class="indexterm"/> had two instance variables, which we declared in step 3: one was the cannonball-shooting animation we previously saw in the battlefield scene and the second was the image of the ship itself.</p><p>In addition to the default initializer, we declared a second initializer in step 4. This method takes <code class="literal">filename</code> as a parameter. We didn't want to create a separate class for the pirate ship. We can use the same class for both types. We just needed a different <code class="literal">filename</code> parameter for either the enemy or the pirate ship.</p><p>Our ship class needed to have the following behaviors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shooting (step 5)</li><li class="listitem" style="list-style-type: disc">Moving the ship to a certain position (step 6)</li><li class="listitem" style="list-style-type: disc">Stopping the movement (step 7)</li></ul></div><p>Our <code class="literal">Ship.h</code> file now looks like the following code:</p><div class="informalexample"><pre class="programlisting">#import "SPSprite.h"

@interface Ship : SPSprite {
    SPMovieClip *_shootingClip;
    SPImage *_idleImage;
}

-(id)initWithContentsOfFile:(NSString *)filename;

-(void) shoot;

-(void) moveToX:(float) x andY:(float) y;
-(void) stop;

@end</pre></div><p>Once all methods and instance variables for the <code class="literal">Ship</code> class were declared, we went on to implement the methods. Before we did that, we defined the initializer in step 8: we initialized the movie clip—with the texture atlas from the shooting pirate ship—and the ship image itself. The only difference to what we know so far is that we are initializing the image if it hasn't been initialized yet.</p><p>In the second initializer that we implemented in step 9, we initialized the image with the filename we passed in and we called the default initializer. So, if the alternate initializer was called, we didn't overwrite the <code class="literal">_idleImage</code> instance variable with a fresh instance of <code class="literal">SPImage</code>.</p><p>The full <a id="id249" class="indexterm"/>piece of code of <code class="literal">Ship.m</code> up to this point is as follows:</p><div class="informalexample"><pre class="programlisting">#import "Ship.h"

#import "Assets.h"

@implementation Ship

-(id) init
{
    if ((self = [super init])) {
        NSArray *textures = [[Assets textureAtlas:@"ship_pirate_small_cannon.xml"] texturesStartingWith:@"00"];

        _shootingClip = [SPMovieClip movieWithFrames:textures fps:20.0f];

        if (_idleImage == nil) {
            _idleImage = [[SPImage alloc] init];
        }

        [self addChild:_shootingClip];
        [self addChild:_idleImage];
    }

    return self;
}

-(id) initWithContentsOfFile:(NSString *)filename
{
    _idleImage = [[SPImage alloc] initWithTexture:[Assets texture:filename]];

    return [self init];
}</pre></div><p>In the <a id="id250" class="indexterm"/>next steps, we implemented methods for the ship's actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Shooting</strong></span>: Plays the <code class="literal">_shooting</code> movie clip (step 10).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Moving</strong></span>: This is the moving logic of the ship we previously had in the <code class="literal">backgroundTouch</code> method in the battlefield scene. Instead of removing all tweens from the ship instance, we called the <code class="literal">stop</code> method from the <code class="literal">ship</code> instance (step 11).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stopping</strong></span>: Removes all tweens from the current instance (step 12).</li></ul></div><p>In its<a id="id251" class="indexterm"/> completeness, these methods look like the following piece of code:</p><div class="informalexample"><pre class="programlisting">-(void) shoot
{
    [_shootingClip play];
    [Sparrow.juggler addObject:_shootingClip];
}

-(void) moveToX:(float)x andY:(float)y
{
    [self stop];

    float targetX = x - (self.width / 2);
    float targetY = y - (self.height / 2);

    float distanceX = fabsf(self.x - targetX);
    float distanceY = fabsf(self.y - targetY);

    float penalty = (distanceX + distanceY) / 80.0f;

    float shipInitial = 0.25f + penalty;

    float speedX = shipInitial + (distanceX / Sparrow.stage.width) * penalty * penalty;
    float speedY = shipInitial + (distanceY / Sparrow.stage.height) * penalty * penalty;

    SPTween *tweenX = [SPTween tweenWithTarget:self time:speedX];
    SPTween *tweenY = [SPTween tweenWithTarget:self time:speedY];


    [tweenX animateProperty:@"x" targetValue:targetX];
    [tweenY animateProperty:@"y" targetValue:targetY];

    [Sparrow.juggler addObject:tweenX];
    [Sparrow.juggler addObject:tweenY];
}

-(void) stop
{
    [Sparrow.juggler removeObjectsWithTarget:self];
}

@end</pre></div><p>In the<a id="id252" class="indexterm"/> last steps, we updated the battlefield scene. First, we updated the header file. We needed to import the <code class="literal">Ship.h</code> file, and instead of being a pointer to <code class="literal">SPImage</code>, the <code class="literal">_pirateShip</code> instance variable was a pointer to the <code class="literal">Ship</code> class.</p><p>After this step, our <code class="literal">Battlefield.h</code> file had the following content:</p><div class="informalexample"><pre class="programlisting">#import "Scene.h"
#import "Ship.h"

@interface Battlefield : Scene {
    Ship* _pirateShip;
}

@end</pre></div><p>We updated the touch interactions in the battlefield scene:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onBackgroundTouch</code>: Since we moved the movement logic to the <code class="literal">Ship</code> class, we<a id="id253" class="indexterm"/> just needed to call the correct method, which was <code class="literal">moveTo</code>, and pass in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> coordinate of <code class="literal">touch</code> (step 15)</li><li class="listitem" style="list-style-type: disc"><code class="literal">onShipStop</code>: Similar<a id="id254" class="indexterm"/> to the <code class="literal">moveTo</code> method, we just needed to call the <code class="literal">stop</code> method of the ship itself (step 16)</li></ul></div><p>The touch events inside the <code class="literal">Battlefield.m</code> file should resemble the following piece of code:</p><div class="informalexample"><pre class="programlisting">#import "Battlefield.h"
#import "Assets.h"

@implementation Battlefield

-(void) onBackgroundTouch:(SPTouchEvent*) event
{
    SPTouch *touch = [[event touchesWithTarget:self] anyObject];

    if (touch) {
        [_pirateShip moveToX:touch.globalX andY:touch.globalY];
    }
}

-(void) onShipStop:(SPTouchEvent*) event
{
    SPTouch *touch = [[event touchesWithTarget:self andPhase:SPTouchPhaseBegan] anyObject];

    if (touch) {
        [_pirateShip stop];
    }
}</pre></div><p>In the <a id="id255" class="indexterm"/>next step, we updated the initializer for the ships. We didn't need the <code class="literal">cannonShip</code> movie clip anymore as this was an instance variable inside the <code class="literal">Ship</code> class.</p><p>Let's take a look at the initializer in the following code that binds these touch selectors and sets up the ship itself:</p><div class="informalexample"><pre class="programlisting">-(id) init
{
    if ((self = [super init])) {
        SPImage *background = [SPImage imageWithTexture:[Assets texture:@"water.png"]];
        background.x = (Sparrow.stage.width - background.width) / 2;
        background.y = (Sparrow.stage.height - background.height) / 2;

        _pirateShip = [[Ship alloc] initWithContentsOfFile:@"ship_pirate.png"];
        _pirateShip.x = (Sparrow.stage.width - _pirateShip.width) / 2;
        _pirateShip.y = (Sparrow.stage.height - _pirateShip.height) / 2;


        Ship *ship = [[Ship alloc] initWithContentsOfFile:@"ship.png"];
        ship.x = 100;
        ship.y = 100;

        SPTween *shipTween = [SPTween tweenWithTarget:ship time:4.0f transition:SP_TRANSITION_EASE_IN_OUT];
        [shipTween animateProperty:@"y" targetValue:250];
        shipTween.repeatCount = 5;
        shipTween.reverse = YES;
        shipTween.delay = 2.0f;

        [Sparrow.juggler addObject:shipTween];
        [background addEventListener:@selector(onBackgroundTouch:) atObject:self forType:SP_EVENT_TYPE_TOUCH];
        [_pirateShip addEventListener:@selector(onShipStop:) atObject:self forType:SP_EVENT_TYPE_TOUCH];
        [self addChild:background];
        [self addChild:ship];
        [self addChild:_pirateShip];
    }

    return self;
}

@end</pre></div><p>When we ran the example, we saw two ships on the screen; if we tapped anywhere, our pirate<a id="id256" class="indexterm"/> ship moved to that point, just like we expected it to. If we touched the ship during movement, it stopped.</p></div></div>
<div class="section" title="Extending the ship class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Extending the ship class</h1></div></div></div><p>Now<a id="id257" class="indexterm"/> that the base of our ship class is done, let's think of what we need for the ship class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Hit points</strong></span>: If a ship is hit, the hit points should reflect this state. The ship will start out with a given number of hit points, say 20 for example, and it will lose some each time it is hit. When it finally reaches zero hit points, it will be completely destroyed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Direction</strong></span>: This is the direction the ship is facing. Depending on the direction, the cannonballs will be fired from each side of the ship.</li></ul></div><p>We should abstain from using filenames where we don't necessarily need to, for example now, when initializing our ship instances.</p><p>Before we go ahead and get to the coding part of things, let's download the latest images from <a class="ulink" href="https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip">https://github.com/freezedev/pirategame-assets/releases/download/0.6/Graphics_06.zip</a>. These images include updated sprite sheets for both the pirate ship and a cannonball that we will use later.</p><p>Delete the <code class="literal">ship_small_cannon</code> files and copy the newer files to the project. This can be done easily, but Xcode doesn't always like replacing existing files.</p></div>
<div class="section" title="Time for action &#x2013; adding more functionality to the ship class"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec76"/>Time for action – adding more functionality to the ship class</h1></div></div></div><p>Let's extend the ship class using the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Ship.h</code> file.</li><li class="listitem">Add <code class="literal">enum</code> for the eight directions of the ship, as shown in the following code:<div class="informalexample"><pre class="programlisting">typedef NS_ENUM(NSInteger, ShipDirection) {
    DirectionNorth,
    DirectionSouth,
    DirectionWest,
    DirectionEast,
    DirectionNorthWest,
    DirectionNorthEast,
    DirectionSouthWest,
    DirectionSouthEast
};</pre></div></li><li class="listitem">Add another <code class="literal">enum</code> for the type of the ship, as shown in the following code:<div class="informalexample"><pre class="programlisting">typedef NS_ENUM(NSInteger, ShipType) {
    ShipPirate,
    ShipNormal
};</pre></div></li><li class="listitem">Change<a id="id258" class="indexterm"/> the <code class="literal">_shootingClip</code> instance variable to be a pointer to the <code class="literal">NSArray</code> class and remove the <code class="literal">_idleImage</code> instance variable, as shown in the following code:<div class="informalexample"><pre class="programlisting">NSArray *_shootingClip;</pre></div></li><li class="listitem">Add a property for the ship's <code class="literal">hitpoints</code>, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">@property int hitpoints;</pre></div></li><li class="listitem">Add another property for <code class="literal">type</code>, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">@property ShipType type;</pre></div></li><li class="listitem">The third property is the direction of the ship:<div class="informalexample"><pre class="programlisting">@property (nonatomic) ShipDirection direction;</pre></div><p>Because we will need to write custom getters and setters for this property as well, we will need an instance variable of the same name, prefixed with an underscore:</p><div class="informalexample"><pre class="programlisting">@interface Ship : SPSprite {
    NSArray *_shootingClip;
    <span class="strong"><strong>ShipDirection _direction;</strong></span>
}</pre></div></li><li class="listitem">Replace the <code class="literal">initWithContentsOfFile</code> method declaration with <code class="literal">initWithType</code>. This method takes <code class="literal">ShipType</code> as its parameter, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">-(id)initWithType:(ShipType)type;</pre></div></li><li class="listitem">Switch to the <code class="literal">Ship.m</code> file.</li><li class="listitem">Let's implement the <code class="literal">initWithType</code> method with the following lines of code:<div class="informalexample"><pre class="programlisting">-(id) initWithType:(ShipType)type
{
    if ((self = [super init])) {
        self.hitpoints = 100;
        self.type = type;

        SPTextureAtlas *atlas = (type == ShipPirate) ? [Assets textureAtlas:@"ship_pirate_small_cannon.xml"] : [Assets textureAtlas:@"ship_small_cannon.xml"] ;

        NSArray *texturesNorth = [atlas texturesStartingWith:@"n_00"];
        // ...

        float animationFPS = 12.0f;

        SPMovieClip *clipNorth = [SPMovieClip movieWithFrames:texturesNorth fps:animationFPS];
        // ...

        _shootingClip = [NSArray arrayWithObjects:clipNorth, clipSouth, clipWest, clipEast, clipNorthWest, clipNorthEast, clipSouthWest, clipSouthEast, nil];

        for (SPMovieClip* clip in _shootingClip) {
            clip.loop = NO;
            [self addChild:clip];
        }

        self.direction = DirectionSouthWest;
    }

    return self;
}</pre></div></li><li class="listitem">Remove<a id="id259" class="indexterm"/> the <code class="literal">initWithContentsOfFile</code> method and update the default initializer to use the <code class="literal">initWithType</code> method, as shown in the following code:<div class="informalexample"><pre class="programlisting">-(id) init
{
    return [self initWithType:ShipNormal];
}</pre></div></li><li class="listitem">Implement the custom getter for the <code class="literal">direction</code> property by simply returning the <code class="literal">_direction</code> instance variable.</li><li class="listitem">The setter for the <code class="literal">direction</code> property needs to have the following code:<div class="informalexample"><pre class="programlisting">_direction = direction;

for (SPMovieClip* clip in _shootingClip) {
  clip.visible = NO;
}

((SPMovieClip *) _shootingClip[_direction]).visible = YES;</pre></div></li><li class="listitem">Replace<a id="id260" class="indexterm"/> the content of the <code class="literal">shoot</code> method with the following lines:<div class="informalexample"><pre class="programlisting">for (SPMovieClip* clip in _shootingClip) {
  [Sparrow.juggler removeObjectsWithTarget:clip];
}

[_shootingClip[self.direction] play];
[Sparrow.juggler addObject:_shootingClip[self.direction]];

[_shootingClip[self.direction] addEventListenerForType:SP_EVENT_TYPE_COMPLETED block:^(SPEvent *event)
{
  [_shootingClip[self.direction] stop];
}];</pre></div></li><li class="listitem">Within the <code class="literal">moveTo</code> method, after the creation of the <code class="literal">tweenX</code> and <code class="literal">tweenY</code> objects, declare and define two variables that should detect which direction the ship will be rotated to, as shown in the following code:<div class="informalexample"><pre class="programlisting">int signX = 0;
int signY = 0;</pre></div></li><li class="listitem">Only update the values if a certain threshold has been broken, as shown in the following code:<div class="informalexample"><pre class="programlisting">if (distanceX &gt; 40) {
  signX = (self.x - targetX) / distanceX;
}

if (distanceY &gt; 40) {
  signY = (self.y - targetY) / distanceY;
}</pre></div></li><li class="listitem">Change <code class="literal">direction</code> to <code class="literal">DirectionEast</code> if <code class="literal">signX</code> has the value <code class="literal">1</code> and <code class="literal">signY</code> still has the value <code class="literal">0</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">if ((signX == 1) &amp;&amp; (signY == 0)) {
  self.direction = DirectionEast;
}</pre></div></li><li class="listitem">Repeat this for all the remaining directions.</li><li class="listitem">Switch to the <code class="literal">Battlefield.m</code> file.</li><li class="listitem">Update the initializers to the pirate and enemy ships. Only the pirate ship needs to have the <code class="literal">PirateShip</code> value from the <code class="literal">ShipType</code> type.</li><li class="listitem">Inside the <code class="literal">onShipStop</code> method, add the functionality to shoot when the pirate ship is tapped twice and stop if the ship is tapped once, as shown in the following code:<div class="informalexample"><pre class="programlisting">if (touch) {
  if (touch.tapCount == 1) {
    [_pirateShip stop];
  } else if (touch.tapCount == 2) {
    [_pirateShip shoot];
  }
}</pre></div></li><li class="listitem">Rename <code class="literal">onShipStop</code> and all its references to <code class="literal">onShipTap</code>.</li><li class="listitem">Run<a id="id261" class="indexterm"/> the example.</li></ol></div><p>We now see that the ship is moving in the direction where we touched the screen.</p><div class="mediaobject"><img src="graphics/1509OS_06_03.jpg" alt="Time for action – adding more functionality to the ship class"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>First, we opened the ship header file, and then we defined an <code class="literal">enum</code> for all the direction states. Objective-C provides a handy <code class="literal">NS_ENUM</code> macro which lets us do exactly that. As the first parameter, we need the type the <code class="literal">enum</code> will be represented as. The second parameter is the name <a id="id262" class="indexterm"/>of the <code class="literal">enum</code> type. This <code class="literal">enum</code> type has eight states: north, south, west, east, and a combination of these.</p><p>In step 3, we defined a second <code class="literal">enum</code> for the type of ship. It can either be a pirate ship or a normal enemy ship without black flags.</p><p>In step 4, we redefined the type of the <code class="literal">_shootingClip</code> instance. The reasoning behind this change is that we hold all movie clips in an array and can access a specific movie clip through the index.</p><p>In the <a id="id263" class="indexterm"/>next few steps, we added a few properties to the class, as listed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">hitpoints</code>: This indicates how many hit points the ship currently has (step 5)</li><li class="listitem" style="list-style-type: disc"><code class="literal">type</code>: This indicates the type of the ship (step 6)</li><li class="listitem" style="list-style-type: disc"><code class="literal">direction</code>: This indicates the direction the ship is facing (step 7)</li></ul></div><p>While it would have been fine to just add the filename to each initializer call when we created an instance of the ship class, it would get messy once we either changed all of these filenames or if we had more than just a few ships on the screen. This is why we replaced the <code class="literal">initWithContentsOfFile</code> method with the <code class="literal">initWithType</code> method.</p><p>Next, we implemented all of the methods we just declared. We started with the one we declared last. As this was our go-to initializer, we got through what was happening here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We set the <code class="literal">hitpoints</code> property to <code class="literal">100</code>. While <code class="literal">100</code> is more or less a random number, it is a good starting point to balance from as it's very easy to calculate with. For example, let's say we require four hits to destroy any ships; the damage potential of a cannonball is 25.</li><li class="listitem" style="list-style-type: disc">We set the <code class="literal">type</code> property to the value of the <code class="literal">type</code> parameter.</li><li class="listitem" style="list-style-type: disc">We set the texture atlas to either the pirate ship atlas or the other option, depending on the type. A ternary operation was just a fancy way of writing an <code class="literal">if</code> statement, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">if (type == ShipPirate) { ... } else { ... }</pre></div><p>The advantage of the ternary operation was that we could assign its result directly to a variable.</p></li><li class="listitem" style="list-style-type: disc">We got the textures for each direction. Within the texture atlas, every direction of the shooting animation was prefixed with the abbreviation of the direction: <code class="literal">n</code> for north, <code class="literal">nw</code> for northwest, and so on.</li><li class="listitem" style="list-style-type: disc">We then defined the speed for the animations. We set it to 12 frames per second as we didn't want the animation to be slower than usual. After all, operating the cannons is tough.</li><li class="listitem" style="list-style-type: disc">Just like we made an instance of <code class="literal">NSArray</code> for every direction, we needed to do the same for all the movie clips. We could also write this line as follows:<div class="informalexample"><pre class="programlisting">_shootingClip = @[clipNorth, clipSouth, clipWest, clipEast, clipNorthWest, clipNorthEast, clipSouthWest, clipSouthEast];</pre></div></li><li class="listitem" style="list-style-type: disc">We added all movie clips to the <code class="literal">_shootingClip</code> instance variable.</li><li class="listitem" style="list-style-type: disc">All the movie clips were added to the display tree by iterating over the <code class="literal">_shootingClip</code> instance variable. We also wanted the movie clips to play only once, which is why we set the <code class="literal">loop</code> property to <code class="literal">NO</code>.</li><li class="listitem" style="list-style-type: disc">The default direction of a ship was south-west.</li></ul></div><p>In step 11, we significantly simplified the default initializer by just calling the <code class="literal">initWithType</code> initializer with the <code class="literal">ShipNormal</code> type.</p><p>We started<a id="id264" class="indexterm"/> with creating the custom getters and setters for the <code class="literal">direction</code> property. We added the <code class="literal">nonatomic</code> keyword to the property definition. This was a performance optimization method to make the generated accessor faster, but non-thread safe. Since Sparrow should only be used single-threaded, it was safe to use <code class="literal">nonatomic</code> in our game. Internally, Objective-C had already defined the getters and setters as <code class="literal">propertyName</code> and <code class="literal">setPropertyName</code>, or in our case, <code class="literal">direction</code> and <code class="literal">setDirection</code>.</p><p>To use our own code, we just needed to overwrite these methods. The getter for the <code class="literal">direction</code> property was pretty simple as it just needed to return the <code class="literal">_direction</code> instance variable.</p><p>In our custom setter for the <code class="literal">direction</code> property, we needed to set the instance variable <code class="literal">_direction</code> to the value of the parameter first. Then, we iterated through all the movie clips and set its <code class="literal">visible</code> property to <code class="literal">NO</code>. We then showed the movie clip of the current direction. This was very similar to how we show scenes through the scene director.</p><p>In step 14, we updated the <code class="literal">shoot</code> method using the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We removed all animatable objects from the juggler which originate from any of the movie clips.</li><li class="listitem" style="list-style-type: disc">We played the movie clip from the current direction and added it to the juggler.</li><li class="listitem" style="list-style-type: disc">We added an event listener to the movie clip that fired when the movie clip animation was complete. Instead of a selector, we used a block. A block (also called a closure in non-Objective-C environments) is a function which has access to non-local variables. So, while we could define variables inside the block, we accessed the variables as if we were declaring a statement inside the <code class="literal">shoot</code> method. A block had a certain appeal to it as we didn't need to define a separate selector for just a few lines of code. There were few things we needed to be careful about when using blocks, but Xcode usually warned us about potential side effects.</li><li class="listitem" style="list-style-type: disc">Inside our block, we stopped the movie clip as it didn't reset itself. It was like rewinding a VHS tape.</li></ul></div><p>At this time, we updated the ship's direction when it moved. To achieve this, we defined two variables inside the <code class="literal">moveTo</code> method: <code class="literal">signX</code> and <code class="literal">signY</code>. Their default values were <code class="literal">0</code>.</p><p>The idea behind that was to map the direction from the values we got in our <code class="literal">moveTo</code> method to a value from the <code class="literal">ShipDirection</code> values. If <code class="literal">signY</code> was <code class="literal">1</code>, it would map to <code class="literal">DirectionNorth</code>; if <code class="literal">signX</code> was <code class="literal">-1</code>, it would map to <code class="literal">DirectionWest</code>; and if both had the values at the same time, they would map to <code class="literal">DirectionNorthWest</code>.</p><p>We had <a id="id265" class="indexterm"/>set the <code class="literal">signX</code> variables to the <span class="emphasis"><em>x</em></span> coordinate of the object minus the target <span class="emphasis"><em>x</em></span> coordinate and dividing that by <code class="literal">distanceX</code>. So, our values for <code class="literal">signX</code> were either <code class="literal">1</code> or <code class="literal">-1</code>. The same happened for the <code class="literal">signY</code> variable.</p><p>Now, if we moved the ship, we only got directions such as <code class="literal">DirectionNorthWest</code>, <code class="literal">DirectionNorthEast</code>, <code class="literal">DirectionSouthEast</code>, and <code class="literal">DirectionSouthWest</code>. It is pretty much impossible to tap the same pixel on a line twice. This was why we needed a threshold. We only set <code class="literal">signX</code> and <code class="literal">signY</code> to <code class="literal">1</code> or <code class="literal">-1</code>, respectively, if distance was more than 40 points. In this case, 40 was not a random number; a rectangle with 40 x 40 points is the average size of a tap, according to Apple.</p><p>In steps 17 and 18, we mapped the <code class="literal">signX</code> and <code class="literal">signY</code> variables to the <code class="literal">ShipDirection</code> values, and we set the <code class="literal">direction</code> property accordingly.</p><p>Within the battlefield scene, we needed to create our ship instances. For the enemy ship, we used the default initializer.</p><p>In step 21, we updated the <code class="literal">onShipStop</code> method. We utilized the <code class="literal">tapCount</code> property of the <code class="literal">touch</code> object to see how many times the object had been tapped. If the ship had been tapped once, it would stop its movement, and if it had been tapped twice, it would shoot.</p><p>Since the <code class="literal">onShipStop</code> method did not only stop the ship but also shot if tapped twice, it was a good call to rename this method to <code class="literal">onShipTap</code>.</p><p>When we ran the example, the ship changed its direction depending on where we tapped on the screen, and when we double-tapped the ship, we saw the cannon animation.</p></div></div>
<div class="section" title="Shooting cannonballs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec77"/>Shooting cannonballs</h1></div></div></div><p>When <a id="id266" class="indexterm"/>we double-tap our ship, the animation plays. However, there is one obvious thing missing, the cannonballs! Let's go ahead and add some cannonballs.</p></div>
<div class="section" title="Time for action &#x2013; allowing the ship to shoot cannonballs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec78"/>Time for action – allowing the ship to shoot cannonballs</h1></div></div></div><p>Let's <a id="id267" class="indexterm"/>allow the pirate ship to shoot cannonballs by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Ship.h</code> file.</li><li class="listitem">Add a read-only property called <code class="literal">isShooting</code>, which has an instance variable counterpart called <code class="literal">_isShooting</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">@property (readonly) BOOL isShooting;</pre></div></li><li class="listitem">Add a cannonball for the left-hand side and the right-hand side of the ship. Both of them are pointers to <code class="literal">SPImage</code>, as shown in the following code:<div class="informalexample"><pre class="programlisting">@property SPImage *cannonBallLeft;
@property SPImage *cannonBallRight;</pre></div></li><li class="listitem">Switch to the <code class="literal">Ship.m</code> file.</li><li class="listitem">Inside the <code class="literal">initWithType</code> method, set the <code class="literal">_isShooting</code> instance variable to <code class="literal">NO</code> at the top of the method.</li><li class="listitem">Inside the <code class="literal">initWithType</code> method, create both cannonballs with the <code class="literal">cannonball.png</code> image, set their <code class="literal">visible</code> property to <code class="literal">NO</code>, and add them to the display tree.</li><li class="listitem">Inside the <code class="literal">shoot</code> method, abort if <code class="literal">_isShooting</code> is set to <code class="literal">YES</code>, else set <code class="literal">_isShooting</code> to <code class="literal">YES</code>, as shown:<div class="informalexample"><pre class="programlisting">if (_isShooting) {
  return;
}

_isShooting = YES;</pre></div></li><li class="listitem">Set some default values for the animation speed and target position, as shown in the following code:<div class="informalexample"><pre class="programlisting">float shootingTime = 1.25f;
float innerBox = 25.0f;
float targetPos = 30.0f;</pre></div></li><li class="listitem">Add a reference to the movie clip with the current direction, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">SPMovieClip *currentClip = _shootingClip[self.direction];</pre></div></li><li class="listitem">Create a tween object for each cannonball and their respective <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> properties:<div class="informalexample"><pre class="programlisting">SPTween *tweenCbLeftX = [SPTween tweenWithTarget:self.cannonBallLeft time:shootingTime];
SPTween *tweenCbLeftY = [SPTween tweenWithTarget:self.cannonBallLeft time:shootingTime];
SPTween *tweenCbRightX = [SPTween tweenWithTarget:self.cannonBallRight time:shootingTime];
SPTween *tweenCbRightY = [SPTween tweenWithTarget:self.cannonBallRight time:shootingTime];</pre></div></li><li class="listitem">Set <a id="id268" class="indexterm"/>up the cannonballs and their tween properties for a direction pair, as shown in the following code:<div class="informalexample"><pre class="programlisting">switch (self.direction) {
  case DirectionNorth:
  case DirectionSouth:
    self.cannonBallLeft.x = (-self.cannonBallLeft.width / 2) + innerBox;
    self.cannonBallLeft.y = (currentClip.height - self.cannonBallLeft.height) / 2;
    
    self.cannonBallRight.x = (-self.cannonBallRight.width / 2) + currentClip.width - innerBox;
    self.cannonBallRight.y = (currentClip.height - self.cannonBallRight.height) / 2;
    
    [tweenCbLeftX animateProperty:@"x" targetValue:self.cannonBallLeft.x - targetPos];
    [tweenCbRightX animateProperty:@"x" targetValue:self.cannonBallRight.x + targetPos];
    
    break;

  default:
    break;
}</pre></div></li><li class="listitem">Set up the cannonballs for the <code class="literal">DirectionEast/DirectionWest</code> pair.</li><li class="listitem">Set both cannonballs to be visible on the screen and add all cannonball-related tweens to the main juggler.</li><li class="listitem">Remove all tweens that originate from the cannonballs just after the line where we removed all tweens originating from the movie clips.</li><li class="listitem">Once the movie clip is finished, set the <code class="literal">_isShooting</code> instance variable to <code class="literal">NO</code> and hide both cannonballs.</li><li class="listitem">Run the example. Our pirate ship can now shoot cannonballs, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1509OS_06_04.jpg" alt="Time for action – allowing the ship to shoot cannonballs"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We<a id="id269" class="indexterm"/> started this example in the header file of the <code class="literal">Ship</code> class, where we added a few new properties, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">isShooting</code>: This<a id="id270" class="indexterm"/> indicates if the ship is currently shooting (step 2)</li><li class="listitem" style="list-style-type: disc"><code class="literal">cannonBallLeft</code>: This<a id="id271" class="indexterm"/> indicates the cannonball shooting from the left-hand side of the ship (step 3)</li><li class="listitem" style="list-style-type: disc"><code class="literal">cannonBallRight</code>: This<a id="id272" class="indexterm"/> indicates the cannonball shooting from the right-hand side of the ship (step 3)</li></ul></div><p>In the next steps, we<a id="id273" class="indexterm"/> modified the <code class="literal">initWithType</code> method using the following steps:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We set <code class="literal">_isShooting</code> to a default value, which is <code class="literal">NO</code> (step 5)</li><li class="listitem" style="list-style-type: disc">We created the cannonball objects (step 6)</li><li class="listitem" style="list-style-type: disc">We hid both cannonballs (step 6)</li><li class="listitem" style="list-style-type: disc">We added the cannonballs to the display tree (step 6)</li></ul></div><p>Let's head into the <code class="literal">shoot</code> method and see what changed here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We only executed the method if the ship was not shooting to minimize potential side effects and prevent someone from tapping on the ship all the time (step 7).</li><li class="listitem" style="list-style-type: disc">We defined the variable <code class="literal">shootingTime</code> at the time the shooting took place. It is set to 1.2 seconds because this is the approximate length of the movie clip animation (step 8).</li><li class="listitem" style="list-style-type: disc">The variable <code class="literal">innerBox</code> was the distance from the edge of the ship image to the actual image itself (step 8).</li><li class="listitem" style="list-style-type: disc">The <a id="id274" class="indexterm"/>variable <code class="literal">targetPos</code> stored how far the cannonballs would fly (step 8).</li><li class="listitem" style="list-style-type: disc">For convenience, we defined the <code class="literal">currentClip</code> variable, so we didn't have to type <code class="literal">_shootingClip[self.direction]</code> each time we wanted to access the movie clip of the current direction (step 9).</li><li class="listitem" style="list-style-type: disc">We defined a tween for each coordinate and cannonball, so in total, we had four tweens at this point (step 10).</li><li class="listitem" style="list-style-type: disc">In steps 11 and 12, we set up the positions and the tweens for the cannonballs.</li><li class="listitem" style="list-style-type: disc">We needed to see the cannonballs on the screen, which is why we set them to be visible. To see the corresponding animation, we needed to add the tweens to the juggler (step 13).</li><li class="listitem" style="list-style-type: disc">We also removed all tweens originating from the cannonballs before we actually played the animation (step 14).</li><li class="listitem" style="list-style-type: disc">The last thing we needed to update in the <code class="literal">shoot</code> method was setting the <code class="literal">_isShooting</code> instance variable to <code class="literal">NO</code> once the animation was complete, and we hid both cannonballs in the same block (step 15).</li></ul></div><p>When we ran the example and double-tapped our pirate ship, the movie clip played and two huge cannonballs emerged from both sides of the ship.</p></div><div class="section" title="Have a go hero"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Have a go hero</h2></div></div></div><p>So far, the ship cannot shoot diagonally. Go ahead and implement this functionality on your own.</p></div></div>
<div class="section" title="Collision detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec79"/>Collision detection</h1></div></div></div><p>Before<a id="id275" class="indexterm"/> we implement collision detection, let's take a look at different types of collision detections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bounding box collision</strong></span>: We check the bounds<a id="id276" class="indexterm"/> of <a id="id277" class="indexterm"/>the entities (which<a id="id278" class="indexterm"/> is a rectangle). If these<a id="id279" class="indexterm"/> rectangles intersect, we have a collision.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bounding sphere collision</strong></span>: We calculate the distance between two entities. If the<a id="id280" class="indexterm"/> distance is smaller<a id="id281" class="indexterm"/> than the radius of both entities combined, these entities are colliding.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Pixel collision</strong></span>: We check if all the pixels of one entity intersect with the pixels <a id="id282" class="indexterm"/>of another entity. While this is definitely<a id="id283" class="indexterm"/> the most detailed and comprehensive collision check, it is also the most CPU-intensive one.</li></ul></div><p>Now that our pirate ship is actually shooting cannonballs, let's implement the functionality that can hit and sink the enemy ship. We use the bounding box collision because this is one of the easiest collision detection types to implement.</p></div>
<div class="section" title="Time for action &#x2013; letting cannonballs collide with ships"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec80"/>Time for action – letting cannonballs collide with ships</h1></div></div></div><p>To check if <a id="id284" class="indexterm"/>cannonballs collide against the enemy ship, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Ship.h</code> file.</li><li class="listitem">We need to add custom getters and setters to the <code class="literal">hitpoints</code> property, so let's make this property <code class="literal">nonatomic</code> and add an instance variable called <code class="literal">_hitpoints</code>.</li><li class="listitem">Declare the methods <code class="literal">abortShooting</code> and <code class="literal">hit</code>.</li><li class="listitem">Switch to the <code class="literal">Ship.m</code> file.</li><li class="listitem">The custom <code class="literal">hitpoints</code> getter just returns the instance variable <code class="literal">_hitpoints</code>.</li><li class="listitem">The custom setter for <code class="literal">hitpoints</code> contains the following code:<div class="informalexample"><pre class="programlisting">-(void) setHitpoints:(int)hitpoints
{
    _hitpoints = hitpoints;
    if (_hitpoints &lt;= 0) {
        self.visible = NO;
    }
}</pre></div></li><li class="listitem">The <code class="literal">abortShooting</code> method consists of the following lines:<div class="informalexample"><pre class="programlisting">-(void) abortShooting
{
    _isShooting = NO;
    
    [Sparrow.juggler removeObjectsWithTarget:self.cannonBallLeft];
    [Sparrow.juggler removeObjectsWithTarget:self.cannonBallRight];
    
    self.cannonBallLeft.visible = NO;
    self.cannonBallRight.visible = NO;
}</pre></div></li><li class="listitem">The <code class="literal">hit</code> method has the following content:<div class="informalexample"><pre class="programlisting">-(void) hit
{
    self.hitpoints = self.hitpoints - 25;
    
    for (SPMovieClip* clip in _shootingClip) {
        SPTween *tween = [SPTween tweenWithTarget:clip time:0.3f];
        tween.reverse = YES;
        tween.repeatCount = 2;
        
        [tween animateProperty:@"color" targetValue:SP_RED];
        [Sparrow.juggler addObject:tween];
    }
}</pre></div></li><li class="listitem">In the battlefield header file, we need to add an instance variable called <code class="literal">_enemyShip</code>, which is a pointer to the class <code class="literal">Ship</code>.</li><li class="listitem">Update the references from <code class="literal">ship</code> to <code class="literal">_enemyShip</code>.</li><li class="listitem">Add an<a id="id285" class="indexterm"/> event listener to the <code class="literal">SP_EVENT_TYPE_ENTER_FRAME</code> event, as shown in the following code:<div class="informalexample"><pre class="programlisting">[self addEventListener:@selector(onEnterFrame:) atObject:self forType:SP_EVENT_TYPE_ENTER_FRAME];</pre></div></li><li class="listitem">Implement the <code class="literal">onEnterFrame</code> method with the following lines of code:<div class="informalexample"><pre class="programlisting">-(void) onEnterFrame:(SPEvent *)event
{
  if (_pirateShip.isShooting) {
    SPRectangle *enemyShipBounds = [_enemyShip boundsInSpace:self];
    SPRectangle *ball1 = [_pirateShip.cannonBallLeft boundsInSpace:self];
    SPRectangle *ball2 = [_pirateShip.cannonBallRight boundsInSpace:self];
    
    if ([enemyShipBounds intersectsRectangle:ball1] || [enemyShipBounds intersectsRectangle:ball2]) {
      if (_pirateShip.cannonBallLeft.visible || _pirateShip.cannonBallRight.visible) {
        [_pirateShip abortShooting];
        [_enemyShip hit];
      }
    }
  }
}</pre></div></li><li class="listitem">Run the example. When the enemy ship is hit, it flashes red for a moment, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/1509OS_06_05.jpg" alt="Time for action – letting cannonballs collide with ships"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In step 2, we updated our <code class="literal">hitpoints</code> property so that we can add custom getters and setters. In the next step, we declared the methods <code class="literal">abortShooting</code> and <code class="literal">hit</code>. We needed the first method to cancel the current shooting animations and the second method to do something <a id="id286" class="indexterm"/>when a ship has been hit.</p><p>We defined the custom getter and setter in steps 5 and 6, respectively. For the getter, we just returned the instance variable <code class="literal">_hitpoints</code> that we declared in step 2. For the setter, we set this instance variable; but when <code class="literal">_hitpoints</code> equals or was below zero, we hid the ship.</p><p>The <code class="literal">abortShooting</code> method in step 7 set the <code class="literal">_isShooting</code> instance variable, removed all tweens from the cannonballs, and hid the cannonballs as well.</p><p>The <code class="literal">hit</code> method subtracted 25 points from <code class="literal">hitpoints</code> and added an animation that let the ship flash red for a very short amount of time to get some visual feedback if a ship had been hit.</p><p>In the next two steps, we refactored the enemy ship instance to be an instance variable, instead of being a local variable inside the initializer. We also updated all references to the enemy ship.</p><p>In step 11, we added an event listener. This event listener was called on each frame. In the next step, we implemented the collision between the enemy ship and the cannonballs from the pirate ship.</p><p>First, we needed to get the bounds from each of these objects relative to the current scene. We needed to see if any of the cannonballs intersected with the enemy ship. In order to make sure that the cannons were actually firing, we checked for the visibility of the cannonballs, and then we called the <code class="literal">hit</code> method from the enemy ship and the <code class="literal">abortShooting</code> method from the pirate ship. The latter was necessary, otherwise the check would happen again with a positive result, so much so that the enemy ship would be destroyed<a id="id287" class="indexterm"/> instantly and we wouldn't even get to see the red flashing ship.</p><p>When we ran the example, we needed to hit the enemy ship exactly four times for it to disappear. Each time the enemy ship was hit, it flashed red for a moment.</p></div></div>
<div class="section" title="Loading gameplay-relevant data"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec81"/>Loading gameplay-relevant data</h1></div></div></div><p>Let's reflect on what kind of gameplay-relevant data we have at this moment. They are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Hit points for each ship</li><li class="listitem" style="list-style-type: disc">The damage a cannonball inflicts</li><li class="listitem" style="list-style-type: disc">Positions for each ship in the battlefield</li></ul></div><p>We should put this data in a file and load it in the game.</p></div>
<div class="section" title="Time for action &#x2013; avoiding hardcoded values"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec82"/>Time for action – avoiding hardcoded values</h1></div></div></div><p>To <a id="id288" class="indexterm"/>separate and load our gameplay-relevant data, we need to follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new file called <code class="literal">gameplay.json</code> in the <code class="literal">Resources</code> folder with the following content:<div class="informalexample"><pre class="programlisting">{
    "hitpoints": 100,
    "damage": 25,
    "battlefield": {
        "enemy": {
            "x": 100,
            "y": 100
        },
        "pirate": {
            "x": 300,
            "y": 100
        }
    }
}</pre></div></li><li class="listitem">Open the <code class="literal">Ship.h</code> file.</li><li class="listitem">Add a <a id="id289" class="indexterm"/>property called <code class="literal">maxHitpoints</code>, as shown in the following line of code:<div class="informalexample"><pre class="programlisting">@property int maxHitpoints;</pre></div></li><li class="listitem">Inside the <code class="literal">Ship</code> initializer, replace the piece of code where we set <code class="literal">hitpoints</code> with the following lines of code:<div class="informalexample"><pre class="programlisting">self.maxHitpoints = [(NSNumber *) [Assets dictionaryFromJSON:@"gameplay.json"][@"hitpoints"] intValue];

self.hitpoints = self.maxHitpoints;</pre></div></li><li class="listitem">Inside the <code class="literal">hit</code> method, replace the hardcoded damage value to load from the <code class="literal">gameplay.json</code> file, as shown in the following code:<div class="informalexample"><pre class="programlisting">self.hitpoints = self.hitpoints - [(NSNumber *) [Assets dictionaryFromJSON:@"gameplay.json"][@"damage"] intValue];</pre></div></li><li class="listitem">Inside the <code class="literal">Battlefield.m</code> file, replace the hardcoded ship positions with those from the <code class="literal">gameplay.json</code> file, as shown in the following code:<div class="informalexample"><pre class="programlisting">NSDictionary *gameplayFile = [Assets dictionaryFromJSON:@"gameplay.json"];

_pirateShip = [[Ship alloc] initWithType:ShipPirate];
_pirateShip.x = [(NSNumber *) gameplayFile[@"battlefield"][@"pirate"][@"x"] floatValue];
_pirateShip.y = [(NSNumber *) gameplayFile[@"battlefield"][@"pirate"][@"y"] floatValue];

_enemyShip = [[Ship alloc] init];
_enemyShip.x = [(NSNumber *) gameplayFile[@"battlefield"][@"enemy"][@"x"] floatValue];
_enemyShip.y = [(NSNumber *) gameplayFile[@"battlefield"][@"enemy"][@"y"] floatValue];</pre></div></li><li class="listitem">Run the example.</li></ol></div><p>Instead of having hardcoded values in our code, we are now loading the values from a file. As a result, the ships are at different starting positions, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1509OS_06_06.jpg" alt="Time for action – avoiding hardcoded values"/></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>In <a id="id290" class="indexterm"/>step 1, we created the JSON file with values that we will load later on. The values we have so far are the hit points, damage, and of course, positions of the ships.</p><p>Inside the <code class="literal">Ship.h</code> file, we added a new property called <code class="literal">maxHitpoints</code>, which indicates the<a id="id291" class="indexterm"/> maximum health of any ship.</p><p>In step 4, we first set the <code class="literal">maxHitpoints</code> property with the <code class="literal">hitpoints</code> property from the <code class="literal">gameplay.json</code> file. Since a property is loaded from the <code class="literal">gameplay.json</code> file and it is from the type <code class="literal">id</code>, we need to cast it into a more familiar data type. We casted it into a pointer to <code class="literal">NSNumber</code> and then used its integer value through the <code class="literal">intValue</code> method.</p><p>In the next step, we did the same for the <code class="literal">damage</code> property.</p><p>In step 6, we switched to the battlefield scene and updated the positions for the ships to reflect the same from the <code class="literal">gameplay.json</code> file.</p><p>When we ran the example, our ships were at the position we defined in the <code class="literal">gameplay.json</code> file. Shooting and destroying an enemy worked as expected.</p></div><div class="section" title="Pop quiz"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Pop quiz</h2></div></div></div><p>Q1. How can event listeners be described?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Using blocks</li><li class="listitem">Using selectors</li><li class="listitem">Using selectors or blocks</li></ol></div><p>Q2. When is an event registered to <code class="literal">SP_TYPE_EVENT_ENTER_FRAME</code> called?</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Once in the first frame after it's added to the display tree</li><li class="listitem">Once every frame</li><li class="listitem">Never</li></ol></div><p>Q3. Detecting double taps is not possible with Sparrow.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">True</li><li class="listitem">False</li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec83"/>Summary</h1></div></div></div><p>In this chapter, we learned about adding the basic game logic elements to our game.</p><p>Specifically, we covered how to structure our code. We got a deeper knowledge of touches, event listeners, and collision detections.</p><p>Now that our pirate ship can actually shoot and hit things, let's add user-interface elements—which is the topic of the next chapter.</p></div></body></html>