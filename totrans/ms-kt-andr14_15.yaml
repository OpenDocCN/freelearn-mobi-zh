- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Android apps is a crucial aspect of the development process, ensuring
    that our application functions as intended and meets user expectations. It helps
    us identify and fix bugs before they reach production and ensure that our app
    is stable and performs well. This chapter will equip you with the skills to write
    tests for the different layers of our app that we’ve created so far.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to add tests for the different layers in
    our **MVVM** (**Model-View-ViewModel**) architecture. We will learn the importance
    of adding tests to our apps and how to add unit tests, integration tests, and
    instrumentation tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Importance of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the network and database layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our **ViewModels**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding UI tests to our composables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptertwelve).
  prefs: []
  type: TYPE_NORMAL
- en: Importance of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing tests is a crucial aspect of app development. It has the following
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps us to **identify and fix bugs** before they reach production. When
    we write tests for our code, we can see issues at an early stage and quickly fix
    them before they reach our users, which is normally very costly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ensures code quality**. When we write tests, we are forced to write code
    that can be tested. This means that we write code that is modular and loosely
    coupled. This makes our code base more maintainable and easier to work with. When
    we find a piece of code that is hard to test, it is a sign that the code is not
    well written and needs to be refactored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing tests results in **improved documentation and code understanding**.
    When we write tests, we are forced to think about how our code works and how it
    should be used. This makes it easier for other developers to understand our code.
    While tests can serve as a form of documentation, they should not replace proper
    code documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests help us to **refactor our code with confidence**. When we have tests in
    place, we can refactor our code and be sure that we have not broken the existing
    features in our app that were working well before the refactoring. This is because
    we can run our tests and see whether they pass or fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests help us **test regression**, especially adding new features or modifying
    existing ones. Tests ensure that the existing functionality still works as before,
    and nothing has been broken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just to mention a few. There are many more benefits of writing tests,
    and the best way to realize them is to start writing tests for your code. One
    important thing to note is that we can also add tests to our **Continuous Integration/Continuous
    Delivery** (**CI/CD**) pipelines to ensure that our tests run automatically when
    we push our code to our repositories. This also ensures that as we collaborate
    with other people on our projects, we can be sure that our code is always in a
    good state and we can always deploy our code to production with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, we have a concept called the **testing pyramid** that helps us
    to understand the several types of tests that we can write for our applications
    and how they relate to each other. The testing pyramid is divided into three layers,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Testing pyramid](img/B19779_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the preceding diagram, we have three layers of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit tests**: These tests sit at the bottom of the pyramid. These are tests
    that test a single unit of code in isolation. Unit tests are intended to test
    the smallest testable parts of an application – typically, methods and functions.
    They are the fastest to run and are the most reliable. They are also the easiest
    to write and maintain. Unit tests run on your local machine only. These tests
    are compiled to run locally on the **Java Virtual Machine** (**JVM**) to minimize
    execution time. For tests that depend on your own dependencies, we use mock objects
    to provide the external dependencies. **MockK** and **Mockito** are popular frameworks
    for mocking dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration tests**: These tests sit in the middle of the pyramid. They test
    how different units of code work together. They are slower to run than unit tests.
    They are also hard to write as they require multiple components and dependencies
    to work and maintain. **Roboletric** is a popular framework for writing integration
    tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI tests**: These tests sit at the top of the pyramid. They test how the
    different components of our app work together. They are the slowest to run since
    they run on a real device or emulator and are the least reliable. They are also
    the most expensive to write and maintain. There are several frameworks for writing
    UI tests, including **Espresso**, **UI Automator**, and **Appium**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing pyramid presents a way to distribute the tests that we write on
    our code base. The ideal distribution percentages are **70% for unit tests**,
    **20% for integration tests**, and **10% for UI tests**. Notice as we go up the
    pyramid that the number of tests reduces. This is because as we go up the pyramid,
    the tests become more expensive to write and maintain. This is why we should strive
    to write more unit tests than integration tests and more integration tests than
    UI tests.
  prefs: []
  type: TYPE_NORMAL
- en: Over the next few sections, we will write the tests for the different layers
    we have discussed. Let us start by testing our database and network layers in
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the network and database layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to write tests for our network and
    database layers step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the network layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test our network layer, we will write unit tests. However, since we are
    using Retrofit to make our network requests, we will use `MockWebServer` to mock
    our network requests. The `MockWebServer` is a library that allows us to mock
    our network requests. Let us start by setting up the test dependencies in our
    version catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **libs.version.toml** file and add the following versions in the versions
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are setting up the versions for `mockWebServer`, `coroutinesTest`, and `truth`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, in the libraries section, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are adding the dependencies for these libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will create a bundle so that it is easy to add all test dependencies
    at once. In the bundle section, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the **Sync Now** button at the top to add the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, let us head over to the app-level **build.gradle.kts** file and add
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add the test bundle to our test directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Sync Now** button to add the dependencies to our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we start writing our tests, we need to do several setup tasks. First,
    we need to create a JSON response for the request that our test will use:'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, right-click on the **app** directory, select **New**, and at the
    bottom of the pop-up dialog, select **Folder**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the options presented, select **Java Resources Folder**. This should create
    a new folder named **resources**, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – The resources folder](img/B19779_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – The resources folder
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this folder, let us create a new JSON file called **catsresponse.json**
    and add the following JSON:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our app uses the Cat as a Service API, which returns a list of cats per the
    filter you have applied. The API returns this list of cats in a JSON response,
    as shown previously. When testing, especially with mocked data, the structure
    and data types of the JSON response should match those of the real API to ensure
    our tests are correct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our response ready, we have to create a class that utilizes
    this response along with our test class in the **com.packt.chaptertwelve (test)**
    directory shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Test directory](img/B19779_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Test directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the **com.packt.chaptertwelve (test)** directory, let us create a new
    Kotlin file called **MockRequestDispatcher.kt** and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a breakdown of the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have created a class called **MockRequestDispatcher** that extends **Dispatcher**.
    This class will be used to mock our network requests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We override the **dispatch** function, which takes **RecordedRequest** and returns
    **MockResponse**. This function is called when a request is made to the server.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We check the path of the request, and if it matches the path of our request,
    we return **MockResponse** with a response code of **200** and a body of the **Json**
    response that we created earlier. For now, we have only mocked a successful response,
    but it’s important to handle all the different HTTP response codes and error cases
    to properly mimic real-world scenarios.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the path does not match, we throw **IllegalArgumentException**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we create a **getJson** function that takes a path and returns a **String**
    instance type. This function is used to read the **Json** response from the file
    that we created earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can add as many paths as we want to this class. Since our project only has
    one path, this is all we need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let us create our test class. Let us create a new Kotlin file called
    **CatsAPITest.kt** and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a breakdown of the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have created a class called **CatsAPITest**. This class will be used to test
    our network layer.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have created two variables: **mockWebServer** and **catsAPI**. The **mockWebServer**
    variable will be used to mock our network requests. The **catsAPI** variable will
    be used to make our network requests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have the **setup()** function, which is annotated with the **@Before** annotation.
    This means that this function will run before our tests run. In this function,
    we have done the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a **MockWebServer** instance and assigned it to the **mockWebServer**
    variable. We then set the dispatcher of **mockWebServer** to an instance of **MockRequestDispatcher**.
    This is the class that we created earlier. We then start **mockWebServer**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have created a Retrofit instance and added the **kotlinx-serialization-converter**
    factory. We then assign the **catsAPI** variable to an instance of **CatsAPI**.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have our test function, which is annotated with the **@Test** annotation.
    This means that this function will be run as a test. In this function, we do the
    following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We wrap the test in the **runTest()** function. This is because we want to test
    suspending functions. **runTest** is a coroutine test builder designed for testing
    coroutines. It is part of the **kotlinx-coroutines-test** library that we added
    earlier.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We make a network request to **mockWebServer** using the **catsAPI** instance
    that we created earlier. We then assert that the response is successful.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the **tearDown()** function, which is annotated with the **@After**
    annotation. This means that this function will run after our tests run. This function
    is used to shut down our **mockWebServer** instance.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Press the green *run* icon next to our test class to run our tests. We should
    see the following output in the **Run** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Test passing](img/B19779_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Test passing
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding figure, our test runs successfully. This means that
    our network layer is working as expected. We can now move on to testing our database
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the database layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are using `androidTest` directory shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Android test directory](img/B19779_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Android test directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a new file called `CatsDaoTest.kt` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created two variables: **database** and **catDao**. The **database**
    variable will be used to create an instance of our database. The **catDao** variable
    will be used to create an instance of our **CatDao** interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the **createDatabase()** function, which is annotated with the **@Before**
    annotation. This means that this function will run before our tests run. Inside
    the function, we create an instance of our database and assign it to the **database**
    variable. We are using the in-memory database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the **closeDatabase()** function, which is annotated with the **@After**
    annotation. This means that this function will run after our tests run. This function
    is used to close our database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this done, we can now start writing our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **CatsDaoTest** class, add the following test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we have created a `CatEntity` object with the details of a cat.
    We then inserted the details of the cat into the database. Lastly, we assert that
    the details of the cat are in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the green *run* icon next to our test class to run our tests. You
    should see the following output in the **Run** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Test to insert and read from the database](img/B19779_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Test to insert and read from the database
  prefs: []
  type: TYPE_NORMAL
- en: Our test runs successfully. This means that our database layer is working as
    expected. Let us add another test that tests adding a cat to the favorites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still inside the **CatsDaoTest** class, let us add the following test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we have created a `CatEntity` object with the details of a cat.
    We then insert the cat into the database. We then update the `CatEntity` object,
    passing `isFavorite` as `true`. Lastly, we assert that the cat is on the favorite
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click on the green *run* icon next to our test class to run our tests. You
    should see the following output in the **Run** window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Favoriting a cat test](img/B19779_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Favoriting a cat test
  prefs: []
  type: TYPE_NORMAL
- en: Our tests run successfully. This means that our functionality for adding cats
    to favorites is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to test our network and database layers. Next, let us test
    our ViewModel layer.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our ViewModels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `ViewModel` class fetches data from the repository and exposes it to the
    UI. To test our `ViewModel`, we will write unit tests. Let us start by setting
    up the test dependencies in our version catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the **libs.version.toml** file and add the following versions in the versions
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the libraries section, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the **test-mockk** dependency to the **test** bundle. Our updated **test**
    bundle should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on the **Sync Now** button at the top to add the dependencies. Adding
    **mockk** allows us to mock our dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now ready to create our test class. Create a new Kotlin file called
    **CatsViewModelTest.kt** inside the test directory and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a breakdown of the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We have created two variables: **petsRepository** and **petsViewModel**. The
    **petsRepository** variable will be used to mock our **PetsRepository** interface.
    We used **mockk<PetsRepository>** to provide a mock instance of **PetsRepository**.
    The **petsViewModel** variable will be used to create an instance of **PetsViewModel**.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the **setup()** function, which is annotated with the **@Before** annotation.
    This means that this function will run before our tests run. We set the main dispatcher
    to **Dispatchers.Unconfined**. This is because we are using coroutines in our
    ViewModel. We then assign the **petsViewModel** property to an instance of **PetsViewModel**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have the **tearDown()** function, which is annotated with the **@After**
    annotation. This means that this function will run after our tests run. This function
    is used to reset the main dispatcher.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this, we are ready to write our test. Below the `tearDown()` function,
    add the following test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test function, we have created a list of cats. We then mock the `getPets()`
    function of `PetsRepository` to return a flow of cats. It returns a flow of cats
    since our `getPets()` function in `PetsRepository` returns `Flow<List<Cat>>`;
    this way, we mock the correct behavior of this function. We then call the `getPets()`
    function of `PetsViewModel`. We then assert that the `getPets()` function of `PetsRepository`
    is called. Lastly, we assert that the list of cats that we created is the same
    as the list of cats that we get from `PetsViewModel`. Remember to remove the private
    marker in our `PetsViewModel` class in case you get an error when trying to access
    the `getPets()` function. Click on the green *run* icon next to our test class
    to run our tests. You should see the following output in the **Run** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – PetsViewModelTest](img/B19779_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – PetsViewModelTest
  prefs: []
  type: TYPE_NORMAL
- en: Our test runs successfully. This means that our `ViewModel` layer is working
    as expected. We can now move on to testing our UI layer. In the next section,
    we will learn how to write UI tests in Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Adding UI tests to our composables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing UI tests has been made easier for us. Jetpack Compose provides a set
    of testing APIs to find elements, verify their attributes, and perform actions
    on these elements. Jetpack Compose uses `PetListItem` composable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us head over to the `PetListItem.kt` file. We need to add a `testTags`
    modifier to our composable. This is because we are using tags to identify our
    composables. In the `PetListItem` composable, modify the composable contents to
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we have added the `testTag()` modifier to our components. With this,
    we are able to use the Finders APIs in Jetpack Compose to find our composables.
    Once we use the finders, we can perform actions and assert on our composables.
    Let us now create a new file in our `androidTest` directory called `PetListItemTest.kt`
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a breakdown of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a class called **PetListItemTest**. We will use this class to
    test our **PetListItem** composable. Inside this class, we have created a rule
    called **composeTestRule**. This rule will be used to create our composables.
    Through this rule, we can set Compose content or access our activity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have the **testPetListItem()** function, which is annotated with the **@Test**
    annotation. Several things are happening in this function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used the **with** scoping function to be able to use **composeTestRule**.
    We then set the content of our composable. In this case, it is the **PetListItem**
    composable that we want to test. We pass a **cat** object to our composable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the **onNodeWithTag()** function to find our composables. We then
    use the **assertExists()** function to assert that the composables exist. This
    will find our composables using the tags that we added earlier.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the **onNodeWithText()** function to find our composables. We then
    use the **assertIsDisplayed()** function to assert that the composables exist.
    We have also used the **onNodeWithContentDescription()** function to find our
    composables. These two functions help us find composables whose text or content
    description matches the text or content description that we pass to the function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, we are using the **performClick()** function to perform an action on
    our composables. In this case, we are performing a click action on our **PetListItemFavoriteIcon**
    composable.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on the green *run* icon next to our test class to run our tests. We should
    see the following output in the **Run** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Jetpack Compose UI tests](img/B19779_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Jetpack Compose UI tests
  prefs: []
  type: TYPE_NORMAL
- en: Our test runs successfully. Additionally, the test is also run on the device
    that we are working on. We are also able to see the components being displayed
    and actions being performed.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to write UI tests in Jetpack Compose. To learn more about testing
    in Jetpack Compose, check out the official documentation ([https://developer.android.com/jetpack/compose/testing](https://developer.android.com/jetpack/compose/testing)).
    With the knowledge that we have gained in this chapter, we can add more tests
    to the different layers of our app. You can try adding more tests to test your
    knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to add tests for the different layers in
    our MVVM architecture. We have learned about the importance of adding tests to
    our apps and how to add unit tests, integration tests, and instrumentation tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn step-by-step how to publish a new app in
    the Google Play Store. We will walk through how to create a signed app bundle
    and the things required for us to publish our first app to the Play Store. Additionally,
    we will learn about some of the Google Play Store policies and how to always stay
    compliant to avoid our apps from being removed or accounts from being banned.
  prefs: []
  type: TYPE_NORMAL
