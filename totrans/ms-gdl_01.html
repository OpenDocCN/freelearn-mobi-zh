<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Getting Started with Gradle"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Gradle</h1></div></div></div><p>Consider a typical IT company development center scenario. Different teams are working together on one enterprise project with many components. Teams are working on server-side technologies, frontend technologies, the messaging layer, mobile development and there may be a separate team responsible for Quality Assurance. Every team is working as per their schedule, developing their own component(s), unit testing and committing code, and this cycle is repeated in multiple iterations. So far, everybody is happy as they are able to meet the deadlines as per the software release dates. Then comes the integration phase, when teams have to build the complete project and deploy the software (which could be WAR, JAR, or any service) to the integration/staging environment. And then the nightmare starts.</p><p>Although every team has successfully followed many best practices of software engineering such as committing code on a daily basis, unit testing of code and verifying the working software on a developer's test environment, but in the integration or staging environment the situation has suddenly changed. The team is stuck with configuration and interoperation issues, localization issues, environmental issues, and so on.</p><p>This might be a very common scenario for any project and the situation will become worse if they are not using any automated solution for the build and deployment process. Hence the need for an automated process or we can call a <span class="strong"><strong>Build Automation System</strong></span> (<span class="strong"><strong>BAS</strong></span>), which automates the manual task of building the project seamlessly and delivers the software in a repeatable, reliable, and portable fashion. BAS <a id="id0" class="indexterm"/>doesn't claim that there will be absolutely no issues or errors, but with BAS, the software can be managed in a better way, minimizing the probability of repeating the same error again and again.</p><p>Gradle is one of the advanced build automation tools available in the market. In the next 10 chapters, we will explore how to mitigate these problems with Gradle and with other related technologies. However, before we start learning Gradle, we need to understand what a BAS is and why we need it.</p><div class="section" title="Understanding Build Automation System"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Understanding Build Automation System</h1></div></div></div><p>The most common processes in building any software include compiling the source files, packaging the compiled output to a compressed format (ZIP, JAR or any other format), and adding the required resource files and configuration files to the packaging. Along with this, it may also include some other activities such as running static code analysis on the source code to provide feedback on the design and coding patterns, and another important area is Quality Assurance, which involves unit testing, integration testing, regression testing, and so on.</p><p>A BAS is part of the <a id="id1" class="indexterm"/>software life cycle, which automates the build and deployment phases of the software. The first phase is building the software, which is the process of creating the binaries or executables. The second phase is the deployment phase, wherein we need to install the software at a particular location. This phase also includes various other activities such as unpacking the bundle, localization of the software, configuring the software as per the environment and setting the environment-specific properties required to execute the software. The next important step is functional testing to check the behavior of the software. Once everything is fine, it makes a happy and smiley ending for you.</p><p>So, as a developer, writing the code and test cases is just one of the major tasks in <span class="strong"><strong>Software Development Life Cycle</strong></span> (<span class="strong"><strong>SDLC</strong></span>). Build<a id="id2" class="indexterm"/> and deployment is also considered as another important phase in any software life cycle. If it is not managed properly, it could lead to major downtime and client dissatisfaction.</p><p>Build automation allows us to automate the manual steps in the build process. It also helps to eliminate the redundant tasks, mitigates the risks of manual intervention, keeps the history of the builds, and saves the cost and time spent in the manual process. The goal here is to create reproducible assets every time you run the build script, which will not be the case, if you manually execute the steps every time.</p><p>Many developers relate the build <a id="id3" class="indexterm"/>automation with <span class="strong"><strong>Continuous Integration</strong></span> (<span class="strong"><strong>CI</strong></span>). Do not get confused. The CI allows executing the build process, performing deployment activities, and many more activities. It helps to create a workflow for build and deployment automation. It also helps to schedule the builds and provides on-demand execution of builds. The schedule could be once in every hour, once in four hours, nightly builds or on every user commit. Some of the well known CI tools are Jenkins, TeamCity, Bamboo, Hudson, Cruise Control, and so on, which are totally different from Build tools, such as Ant, Maven, and Gradle.</p><div class="section" title="Need for BAS"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Need for BAS</h2></div></div></div><p>Imagine that all the preceding mentioned steps <a id="id4" class="indexterm"/>in building a software need to be done manually, and every developer has to perform steps on different machines. Now you can realize the amount of effort wasted in figuring out problems with build issues rather than focusing on the actual business requirements. That's one of the reasons why we need a BAS. Following are some of the major activities, which we automate for the build <a id="id5" class="indexterm"/>system:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Translating the source code into binaries</li><li class="listitem" style="list-style-type: disc">Packaging the binaries with configuration files to create deployable artifacts</li><li class="listitem" style="list-style-type: disc">Executing the test cases</li><li class="listitem" style="list-style-type: disc">Publishing the artifacts to a common repository</li><li class="listitem" style="list-style-type: disc">Deploying the artifacts to different environments (Development, QA, and Production)</li><li class="listitem" style="list-style-type: disc">Incremental builds</li><li class="listitem" style="list-style-type: disc">Status reports that summarize the current state of the build</li></ul></div><p>Another reason to have<a id="id6" class="indexterm"/> a BAS is to reduce the operational complexities. If a new member joins the team and he has to perform the manual build of the software, it could be a nightmare for him, if there is no automation. Rather than concentrating on the business requirement, most of his time will be wasted on how to compile it, how to run unit tests, how to execute integration tests, and so on.</p><p>Actually, what he needs to know is where to commit the source code, where to put the resources, and what commands to execute to perform the build process. The build process should automatically perform all the tasks of compiling, packaging, running tests, uploading asserts and so on.</p><p>The more automated the build and deployment process, the faster you will get the deliverables to the client. It also helps with business continuity. In case of any system crash or network failure, you can rebuild and deploy the software on back up infrastructure in much less time.</p><p>Some developers believe that project automation is a waste of time and why should they put in extra effort as their IDE performs this job. They can build the JAR, WAR, or any other deliverable unit with the help of IDE and deploy the same. Since they can build, and test it quickly, it works very well on their local system. The problem starts when integration happens. Thus, an automated system is required to avoid any manual intervention (unless it is the only option left), and to make builds portable, predictable and efficient.</p></div></div></div>
<div class="section" title="Gradle overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Gradle overview</h1></div></div></div><p>Before getting into the details of Gradle, we need to understand some of the terminologies related to the build system.</p><p>There are two types of build tools, namely <span class="strong"><strong>imperative build tools</strong></span> and <span class="strong"><strong>declarative build tools</strong></span>. An imperative build tool tells the <a id="id7" class="indexterm"/>system what to do and how to do it. In other words, it provides a set of action statements or commands, which the system executes in the same order and performs those actions. You<a id="id8" class="indexterm"/> can take Ant as an example of the<a id="id9" class="indexterm"/> imperative build system.</p><p>Whereas, a declarative build tool instructs the system, telling it what you would like to achieve, and system will figure out how to interpret it. With a declarative approach, the user only needs to determine the <span class="emphasis"><em>what</em></span>, not the <span class="emphasis"><em>how</em></span>. This is one of the key innovations Maven brought to the build world, after Ant achieved some popularity, where we don't need to write each and every step of an action, and end up creating a very large and verbose build script. With Maven we need to write some configuration parameters for the build and the build system itself decides how to interpret it. Internally, the declarative layer is based on a powerful imperative layer, which can be accessed directly as required. Ant and Maven are very good and reliable build systems. They are innovative in all the areas for which they were designed and built. Each of them has introduced key innovations into the build space.</p><p>Gradle combines the good parts of both tools and provides additional features and uses Groovy as a <span class="strong"><strong>Domain Specific Language</strong></span> (<span class="strong"><strong>DSL</strong></span>). It<a id="id10" class="indexterm"/> has power and flexibility of Ant tool with Maven features such as build life cycle and ease of use.</p><p>Gradle is a general purpose, declarative build tool. It is general purpose because it can be used to build pretty much anything you care to implement in the build script. It is declarative, since you don't want to see lots of code in the build file, which is not readable and less maintainable. So, while Gradle provides the idea of conventions and a simple and declarative build, it also makes the tool adaptable and developers the ability to extend. It also provides an easy way to customize the default behavior and different hooks to add any third-party features.</p><p>Primarily, Gradle is a<a id="id11" class="indexterm"/> JVM-language build tool, but it also supports C, C++, Android, and so on. You will find more information about this at <a class="ulink" href="https://docs.gradle.org/current/userguide/nativeBinaries.html">https://docs.gradle.org/current/userguide/nativeBinaries.html</a>.</p><p>It provides automation for the different phases required in a Java project, such as compile, package, execute test cases, and so on. It has grouped its similar automation tasks into plugins. When you import any plugin to a Gradle script file, they always come with a set of predefined tasks. To get started with Gradle, you need to have basic knowledge of Java. It uses Groovy as its scripting language, which is another JVM language. We will discuss Groovy in the next chapter. As the build script is written in Groovy, it tends to be much shorter, expressive, and clearer than those written in Ant or Maven. The amount of boilerplate code is much less in Gradle with use of Groovy DSL. It also leverages Maven conventions for familiarity, while making it easy to customize to the needs of your project. Developers can add new functionality or extend the existing features at any time. They can<a id="id12" class="indexterm"/> override the existing tasks or plugins to provide the new functionality.</p></div>
<div class="section" title="Installation and quick start"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Installation and quick start</h1></div></div></div><p>Gradle installation is<a id="id13" class="indexterm"/> quite simple. You can download the Gradle distribution from the Gradle home page at <a class="ulink" href="https://www.gradle.org/downloads">https://www.gradle.org/downloads</a>, which is available in different formats.</p><div class="section" title="Pre-requisites"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Pre-requisites</h2></div></div></div><p>Gradle requires a Java JDK or JRE to be installed, needing version 6 or higher (to check the Java version on your machine, use <code class="literal">java -version</code>). Some of the features might not work with JRE, so it is<a id="id14" class="indexterm"/> recommended to have JDK installed. Also, Gradle ships with its own Groovy library; therefore, Groovy does not need to be installed. Any existing Groovy installation is ignored by Gradle.</p><p>Gradle is available in three formats:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">gradle-[version]-all.zip</code>: This contains the <a id="id15" class="indexterm"/>source code, the binaries, and the documentation</li><li class="listitem" style="list-style-type: disc"><code class="literal">gradle-[version]-bin.zip</code>: This contains<a id="id16" class="indexterm"/> the binaries only</li><li class="listitem" style="list-style-type: disc"><code class="literal">gradle-[version]-src.zip</code>: This<a id="id17" class="indexterm"/> contains the source code only, in case you want to extend the Gradle features</li></ul></div><p>Alternatively, you can just download <code class="literal">gradle-[version]-bin.zip</code> file.</p><p>Once downloaded, you need to unpack the zip file and configure it as per your operating system.</p></div><div class="section" title="Gradle for Windows"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Gradle for Windows</h2></div></div></div><p>Following are<a id="id18" class="indexterm"/> the steps for installing Gradle on Windows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Unpack the <a id="id19" class="indexterm"/>Gradle distribution on the hard drive.</li><li class="listitem">Add Gradle's installed path (for example, <code class="literal">c:\gradle-2.4</code>) to the <code class="literal">GRADLE_HOME</code> variable. Note that this location should be the parent directory of the <code class="literal">bin</code> or the <code class="literal">lib</code> folder.</li><li class="listitem">Add the <code class="literal">GRADLE_HOME/bin</code> to the <code class="literal">PATH</code> variable.</li></ol></div><p>When you are ready to go ahead <a id="id20" class="indexterm"/>with Gradle, verify your installation by running the <code class="literal">gradle</code> command with the <code class="literal">--version</code> or <code class="literal">-v</code> command-line parameter.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; gradle –version</strong></span>

<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong>Gradle 2.4</strong></span>
<span class="strong"><strong>------------------------------------------------------------</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>Build time:   2015-05-05 08:09:24 UTC</strong></span>
<span class="strong"><strong>Build number: none</strong></span>
<span class="strong"><strong>Revision:     5c9c3bc20ca1c281ac7972643f1e2d190f2c943c</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>Groovy:       2.3.10</strong></span>
<span class="strong"><strong>Ant:          Apache Ant(TM) version 1.9.4 compiled on April 29 2014</strong></span>
<span class="strong"><strong>JVM:          1.7.0_79 (Oracle Corporation 24.79-b02)</strong></span>
<span class="strong"><strong>OS:           Windows 8.1 6.3 amd64</strong></span>
</pre></div></div><div class="section" title="Gradle for Mac/Linux"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Gradle for Mac/Linux</h2></div></div></div><p>Following are<a id="id21" class="indexterm"/> the steps to install Gradle on the Mac/Linux operating system.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Unpack the<a id="id22" class="indexterm"/> Gradle distribution.</li><li class="listitem">Add the following two lines in your initialization script (<code class="literal">~/.profile</code>).</li><li class="listitem">Export <code class="literal">GRADLE_HOME = &lt;Gradle_Installation_Dir&gt;</code></li><li class="listitem">Export <code class="literal">PATH=$PATH:$GRADLE_HOME/bin</code></li></ol></div><p>Reload the profile by executing <code class="literal">source ~/.profile</code> and execute the <code class="literal">gradle –version</code> command. You will be able to see a similar output as mentioned in the previous section.</p></div><div class="section" title="The Gradle JVM option"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The Gradle JVM option</h2></div></div></div><p>Gradle shares the<a id="id23" class="indexterm"/> same JVM options set by the environment variable <code class="literal">JAVA_OPTS</code>. If you don't want to use this setting and want to pass arguments specifically to the Gradle runtime, you can use the environment variable <code class="literal">GRADLE_OPTS</code>.</p><p>Suppose if <code class="literal">JAVA_OPTS=512MB</code> in your system and you want to increase the default maximum heap size to <code class="literal">1024MB</code> for Gradle application. You can set it like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GRADLE_OPTS="-Xmx1024m"</strong></span>
</pre></div><p>We can apply this setting in the project-specific build file. Alternatively, we can also apply this setting<a id="id24" class="indexterm"/> to all of the Gradle build by adding the variable to the Gradle startup script (this will be discussed later in this chapter).</p></div></div>
<div class="section" title="Our first script"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Our first script</h1></div></div></div><p>In the last section, we learned how to install Gradle. Now it's time create our very first Gradle script. This <a id="id25" class="indexterm"/>script will print <code class="literal">Hello Gradle- This is your first script</code> on the console. Just open a text editor, type in the following three lines, and save the file as <code class="literal">build.gradle</code>.</p><div class="informalexample"><pre class="programlisting">task helloGradle &lt;&lt; {
      println 'Hello Gradle- This is your first script'
}</pre></div><p>Then execute the <code class="literal">gradle helloGradle</code> command as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle helloGradle</strong></span>
<span class="strong"><strong>:helloGradle</strong></span>
<span class="strong"><strong>Hello Gradle- This is your first script</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong>Total time: 4.808 secs</strong></span>
</pre></div><p>So, what have we done here?</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have a created a Gradle build script file called <code class="literal">build.gradle</code>. This is the default name given to a build file. You can give any name to the build file. However, to execute the script, you must use the <code class="literal">-b</code> option with your filename with the <code class="literal">gradle</code> command. Otherwise,the build will fail with the <code class="literal">Task '%TASK_NAME%' not found in root project '%PROJECT_NAME'."gradle [-b &lt;file name&gt;] [task1 task2 ….. taskn]</code> error.</li><li class="listitem" style="list-style-type: disc">Try the <code class="literal">gradle -b &lt;buildfile_name&gt; helloGradle</code> command and you should get the same output.</li><li class="listitem" style="list-style-type: disc">With the gradle command, we have executed a task called <code class="literal">helloGradle</code>, which prints a line in the console. So, the parameter we passed to the gradle command is the task name. You can execute one to any number of tasks with the Gradle command and these tasks will be executed in the same order as they appear in the command line.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>There is a way to define the default task using the <code class="literal">defaultTasks</code> keyword, which will be executed by default, if user does not mention any specific task to execute on the build file. We'll discuss this more in <a class="link" href="ch03.html" title="Chapter 3. Managing Task">Chapter 3</a>, <span class="emphasis"><em>Managing Task</em></span>.</p></div></div></li></ul></div><p>The Gradle command initializes the script, reads all tasks mentioned on the command-line, and executes tasks. Moreover, if any task has multiple dependencies, then dependent tasks are executed in alphabetical order unless those tasks themselves<a id="id26" class="indexterm"/> enforce the order. You can find more about task ordering in <a class="link" href="ch03.html" title="Chapter 3. Managing Task">Chapter 3</a>, <span class="emphasis"><em>Managing Task</em></span>.</p><p>Remember that each Gradle build consists of three components: projects, tasks, and properties. Each build has at least one project and one or more tasks. The name of the project is the parent directory name in which the build file exists.</p></div>
<div class="section" title="Gradle command Line arguments"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Gradle command Line arguments</h1></div></div></div><p>Now that you have created the first working script, it is time to explore different command-line<a id="id27" class="indexterm"/> options supported by Gradle.</p><p>You have already seen the usage of <code class="literal">-b</code> option to specify a build script. We'll start with <code class="literal">--help</code> or <code class="literal">-h</code> or <code class="literal">-?</code> to list all the options available with the Gradle command line.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -h</strong></span>
<span class="strong"><strong>USAGE: gradle [option...] [task...]</strong></span>

<span class="strong"><strong>-?, -h, --help        Shows this help message.</strong></span>
<span class="strong"><strong>-a, --no-rebuild      Do not rebuild project dependencies.</strong></span>
<span class="strong"><strong>-b, --build-file      Specifies the build file.</strong></span>
<span class="strong"><strong>-c, --settings-file   Specifies the settings file.</strong></span>
<span class="strong"><strong>--configure-on-demand   Only relevant projects are configured in this build run. This means faster build for large multi-project builds. [incubating]</strong></span>
<span class="strong"><strong>--continue            Continues task execution after a task failure.</strong></span>
</pre></div><p>In the preceding output, <code class="literal">-h</code> or <code class="literal">--help</code> displays many more options. We have truncated the output.</p><p>You can execute the command on your systems and check all the options. Most of these are self-explanatory. We will discuss the usage of some of the most useful options in this section.</p><p>Now we'll add two more tasks, <code class="literal">failedTask</code> and <code class="literal">test</code> to the <code class="literal">build.gradle</code> script and save the file as <code class="literal">sample_build.gradle</code>. The task named <code class="literal">failedTask</code> is expected to always fail due to assertion failure and the <code class="literal">test</code> task is dependent on the previously created task <code class="literal">helloGradle</code>. A task can succeed (executing all statements in the task without any exception) or it can fail (due to any exception or error in any line of code mentioned in the task) thus stopping the execution of the script.</p><div class="informalexample"><pre class="programlisting">task failedTask &lt;&lt; {
      assert 1==2
}

task test(dependsOn: helloGradle ) &lt;&lt; {
      println 'Test case executed'
}</pre></div><p>On executing the <code class="literal">gradle -b sample_build.gradle failedTask test</code> command, we observe that the <code class="literal">test</code> task is never executed. As Gradle executes tasks sequentially as they appear on the command-line, if a task fails to execute, all the remaining tasks will be ignored.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -b sample_build.gradle failedTask test</strong></span>
<span class="strong"><strong>:failedTask FAILED</strong></span>
<span class="strong"><strong>FAILURE: Build failed with an exception.</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>BUILD FAILED</strong></span>

<span class="strong"><strong>Total time: 6.197 secs</strong></span>
</pre></div><p>By default, Gradle stops<a id="id28" class="indexterm"/> the build process if any task fails to execute. This feature helps to get a quick feedback on the build process. If you do not want to stop execution of the build irrespective of any task failure and you want to continue with other tasks, then it can be done by using the <code class="literal">--continue</code> command-line option. This feature could be useful when we want to build a multimodule project, where some of the modules might fail due to compilation error or test failure. With the <code class="literal">–continue</code> option, we will get a complete status of all the modules.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -b sample_build.gradle failedTask test --continue</strong></span>
<span class="strong"><strong>:failedTask FAILED</strong></span>
<span class="strong"><strong>:helloGradle</strong></span>
<span class="strong"><strong>Hello Gradle- This is your first script</strong></span>
<span class="strong"><strong>:test</strong></span>
<span class="strong"><strong>Test case executed</strong></span>

<span class="strong"><strong>FAILURE: Build failed with an exception.</strong></span>
</pre></div><p>As you can see in the preceding output, <code class="literal">failedTask</code> failed to execute. So the build is marked as <code class="literal">FAILURE</code>. However, this time the <code class="literal">test</code> task executed successfully. Also observe that the <code class="literal">helloGradle</code> task is executed before the <code class="literal">test</code> task. This is because we have defined the <code class="literal">test</code> task to be dependent on the <code class="literal">helloGradle</code> task. This is one of the ways you can create task dependencies. For now, don't get confused with task dependency. We will discuss the topic in detail in <a class="link" href="ch03.html" title="Chapter 3. Managing Task">Chapter 3</a>, <span class="emphasis"><em>Managing Task</em></span>.</p><p>Now, what happens if the <code class="literal">helloGradle</code> task fails? Just add a line <code class="literal">assert 1==2</code> into the <code class="literal">helloGradle</code> task. The assert statement forces the task to fail. When you look at the following output, you will find that the test tasks is not executed as the dependent task failed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -b sample_build.gradle failedTask test --continue</strong></span>
<span class="strong"><strong>:failedTask FAILED</strong></span>
<span class="strong"><strong>:helloGradle</strong></span>
<span class="strong"><strong>Hello Gradle- This is your first script</strong></span>
<span class="strong"><strong>:helloGradle FAILED</strong></span>

<span class="strong"><strong>FAILURE: Build completed with 2 failures.</strong></span>
</pre></div><p>In the preceding scenario, the test task is dependent on the <code class="literal">helloGradle</code> task. This means that, every time we execute the <code class="literal">test</code> task, the <code class="literal">helloGradle</code> task will be executed by default. In case you<a id="id29" class="indexterm"/> want to avoid the execution of the <code class="literal">helloGradle</code> task, you can use the <code class="literal">-x or --exclude-task</code> option.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -b sample_build.gradle failedTask --continue test -x helloGradle</strong></span>
<span class="strong"><strong>:failedTask FAILED</strong></span>
<span class="strong"><strong>:test</strong></span>
<span class="strong"><strong>Test case executed</strong></span>
</pre></div><p>Another useful option is <code class="literal">--dry-run</code> or <code class="literal">-m</code>, which runs the build but does not execute the tasks. It is useful if you want to know the task execution order or you want to validate the script.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle --dry-run -b sample_build.gradle failedTask test --continue</strong></span>
<span class="strong"><strong>:failedTask SKIPPED</strong></span>
<span class="strong"><strong>:helloGradle SKIPPED</strong></span>
<span class="strong"><strong>:test SKIPPED</strong></span>
<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
<span class="strong"><strong>Total time: 4.047 secs</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>
<code class="literal">--dry-run</code> executes all the statements which are not part of any tasks and are defined outside of a task block. To verify this, add a <code class="literal">println</code> statement anywhere outside a task block definition and observe the result.</p></div></div><p>So far, you must have noticed that each output displays extra information apart from the task output and error messages. Try the command-line option <code class="literal">-q</code> or <code class="literal">--quiet</code> to display only the task output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -q -b sample_build.gradle failedTask --continue test</strong></span>
<span class="strong"><strong>Hello Gradle- This is your first script</strong></span>
<span class="strong"><strong>Test case executed</strong></span>
</pre></div><p>The options <code class="literal">--debug</code> (<code class="literal">-d</code>), <code class="literal">--info</code> (<code class="literal">-i</code>), <code class="literal">--full-stacktrace</code> (<code class="literal">-S</code>), and <code class="literal">--stacktrace</code> (<code class="literal">-s</code>) display the output with different log levels and stack traces. <code class="literal">--debug</code> is the most detailed log level. <code class="literal">--full-stacktrace</code> and <code class="literal">--stacktrace</code> show stack traces if the build fails with an exception. Try the previously executed command with these command-line options and observe the output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -d -b sample_build.gradle failedTask --continue test</strong></span>
</pre></div><p>Now we will explore the <code class="literal">--daemon</code>, <code class="literal">--stop</code>, and <code class="literal">--no-daemon</code> options. On my machine, it took around 3.6 seconds to execute the preceding script. For this simple script, most of the execution time was spent in the initialization of Gradle. When we execute a Gradle command, a new Java Virtual Machine is started, then Gradle-specific classes and libraries are loaded, <a id="id30" class="indexterm"/>and finally the actual build steps are executed. Initialization and execution of Gradle can be improved using the <code class="literal">--daemon</code> option. This is very useful if you are working in a test-driven development where you need to execute unit tests frequently or you need to run a particular task repeatedly.</p><p>To start a daemon, you can use the <code class="literal">--daemon</code> option. The daemon process automatically expires after 3 hours of idle time. To check whether the daemon is running on the system, use the <code class="literal">ps</code> command in the UNIX environment, or the Process explorer in Windows systems. Once you have started the daemon process, again execute the same Gradle task. You will find an improvement in the execution time.</p><p>Alternatively, you can use the <code class="literal">gradle.properties</code> file to set the system property <code class="literal">org.gradle.daemon</code> to enable the daemon. In this scenario, you don't need to specify the <code class="literal">--daemon</code> option when executing the tasks. To try it out, create a file called <code class="literal">gradle.properties</code> in the same directory where you created the <code class="literal">sample_build.gradle</code> file and add this line <code class="literal">org.gradle.daemon=true</code>. Now, run the gradle command and check whether the daemon process is running. The <code class="literal">org.gradle.daemo</code> is a property that we have set to configure the Gradle build environment. We'll discuss more on properties and system variables in <a class="link" href="ch06.html" title="Chapter 6. Working with Gradle">Chapter 6</a>, <span class="emphasis"><em>Working with Gradle</em></span>.</p><p>To stop the daemon process, use the <code class="literal">gradle --stop</code> option. Sometimes, you may not want to execute Gradle tasks with the daemon process. Use the <code class="literal">--no-daemon</code> option with the task to ignore any running daemons.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle -b sample_build.gradle failedtask --continue test </strong></span>
<span class="strong"><strong>--daemon</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>$ ps -ef | grep gradle</strong></span>
<span class="strong"><strong>root   25395  2596 46 18:57 pts/1  00:00:04 </strong></span>
<span class="strong"><strong>/usr/local/java/jdk1.7.0_71/bin/java ….. </strong></span>
<span class="strong"><strong>org.gradle.launcher.daemon.bootstrap.GradleDaemon 2.4 </strong></span>
<span class="strong"><strong>/home/root/.gradle/daemon 10800000 93dc0fe2-4bc1-4429-a8e3-</strong></span>
<span class="strong"><strong>f10b8a7291eb -XX:MaxPermSize=256m -XX:+HeapDumpOnOutOfMemoryError -</strong></span>
<span class="strong"><strong>Xmx1024m -Dfile.encoding=UTF-8 -Duser.country=US -Duser.language=en -</strong></span>
<span class="strong"><strong>Duser.variant</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>$ gradle --stop</strong></span>
<span class="strong"><strong>Stopping daemon(s).</strong></span>
<span class="strong"><strong>Gradle daemon stopped.</strong></span>
</pre></div><p>Although the Gradle daemon is recommended for the development environment, it might get corrupted occasionally. When Gradle executes user build scripts from multiple sources (for example, in the Continuous Integration environment), it might exhaust the daemon process and may cause memory leakage if resources are not handled properly. Therefore, it is recommended not to enable the daemon for staging or continuous integration <a id="id31" class="indexterm"/>environment. Apart from the command-line, Gradle can be executed in the <span class="strong"><strong>Graphical User Interface</strong></span> (<span class="strong"><strong>GUI</strong></span>) as well. In the next section, we'll discuss the graphical user interface supported by Gradle. The other important command-line options such as <code class="literal">–D</code> or <code class="literal">--system-prop</code>, <code class="literal">-P</code> or <code class="literal">--project-prop</code> will be discussed in <a class="link" href="ch06.html" title="Chapter 6. Working with Gradle">Chapter 6</a>, <span class="emphasis"><em>Working with Gradle</em></span>, when we explore more on building Java applications with Gradle.</p></div>
<div class="section" title="The Gradle GUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>The Gradle GUI</h1></div></div></div><p>Apart from the<a id="id32" class="indexterm"/> command-line arguments and tools, Gradle provides a graphical user interface. It can be launched with the help of the following command-line option:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle --gui</strong></span>
</pre></div><p>It launches a<a id="id33" class="indexterm"/> <span class="strong"><strong>graphical user interface</strong></span> (<span class="strong"><strong>GUI</strong></span>), which can be used to execute Gradle tasks directly from the GUI.</p><div class="mediaobject"><img src="graphics/B02000_01_01.jpg" alt="The Gradle GUI"/><div class="caption"><p>Figure 1.1</p></div></div><p>It contains four tabs, which are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Task Tree</strong></span>: The directory, under which you executed this command, is considered as the parent project <a id="id34" class="indexterm"/>directory. If the <code class="literal">build.gradle</code> file is present under this directory, task tree will list out all the tasks available in the <code class="literal">build.gradle</code> file. If the <code class="literal">build.gradle</code> file is not in this directory, it will list out only the default tasks. You can execute any task by double-clicking on the task name.<p>
<span class="emphasis"><em>Figure 1.1</em></span> displays <code class="literal">failedTask</code>, <code class="literal">helloGradle</code> and <code class="literal">test</code> tasks that we developed earlier along with the default Gradle tasks.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Favorites</strong></span>: This works like your browser favorites, where you can save frequently used commands. Additionally, it provides an alias feature. In case you want to execute multiple<a id="id35" class="indexterm"/> tasks on the command line, you can add them here and give it a simple display name. For example, you can click on the plus sign and add the following tasks in the command-line textbox: <code class="literal">clean build</code>.<p>Add <code class="literal">init</code> in the display name area. You will see that <span class="strong"><strong>init</strong></span> appears in the <span class="strong"><strong>Favorites</strong></span> area. Next<a id="id36" class="indexterm"/> time, just click on <span class="strong"><strong>init</strong></span> to execute <code class="literal">clean build</code> tasks.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Command line</strong></span>: This works like the console. Here you can execute single or multiple inline <a id="id37" class="indexterm"/>commands. It will execute the command and will display the result in the lower window.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Setup</strong></span>: Even if you <a id="id38" class="indexterm"/>started the GUI from a specific project directory, you can change the directory using this tab. It allows you to change your current directory for executing commands. Along with that, it helps to change some general settings such as Log level, Stack Trace output, and so on. It also allows you to execute other Gradle versions through the custom Gradle Executor.</li></ul></div></div>
<div class="section" title="Start up script"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Start up script</h1></div></div></div><p>Consider this scenario, for each of your Gradle projects you have a dependency on a local in-house jar files. Additionally, you want to set some common environment variables for each of your Gradle projects (such as <code class="literal">GRADLE_OPTS</code>).</p><p>A simple solution is to <a id="id39" class="indexterm"/>add the jar file in the dependency closure. An alternate solution could be to create one common build file and include this common file in each of the build files.</p><p>The simplest solution Gradle provides for these kinds of problems by introducing the initialization script.</p><p>Initialization scripts are no special files, but a Gradle script with the <code class="literal">.gradle</code> extension. However, this will execute every time before any of your build files execute.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>There can be more than one initialization script.</p></div></div><p>Some of the uses<a id="id40" class="indexterm"/> of the initialization script are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Downloading some common jars for each of your projects</li><li class="listitem" style="list-style-type: disc">Performing common environment configuration related to system details and/or user details.</li><li class="listitem" style="list-style-type: disc">Registering listeners and loggers.</li></ul></div><p>So, how does Gradle find these initialization script(s)? There are multiple ways to define the initialization script which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All the files with <code class="literal">.gradle</code> extension under <code class="literal">&lt;USER_HOME&gt;/.gradle/init.d</code> directory are treated as initialization scripts. Gradle will execute all the <code class="literal">.gradle</code> files under this directory <a id="id41" class="indexterm"/>before the execution of any Gradle build script.</li><li class="listitem" style="list-style-type: disc">Files named <code class="literal">init.gradle</code> under <code class="literal">&lt;USER_HOME&gt;/.gradle/</code> are treated as an initialization script.</li><li class="listitem" style="list-style-type: disc">All the files <a id="id42" class="indexterm"/>with the <code class="literal">.gradle</code> extension under <code class="literal">&lt;GRADLE_HOME&gt;/init.d/</code> directory.</li><li class="listitem" style="list-style-type: disc">You can even specify any Gradle file as the initialization script with <code class="literal">-I &lt;file name&gt;</code> or <code class="literal">--init-script &lt;file name&gt;</code>.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Even if multiple files are found at the location mentioned earlier, Gradle will execute all the files as initialization script before executing any project build script.</p></div></div></li></ul></div><p>Following is a sample <code class="literal">init</code> script.</p><div class="informalexample"><pre class="programlisting">println "Hello from init script"
projectsLoaded {
  rootProject.allprojects {
    buildscript {
      repositories {
        maven {
          url "http://central.maven.org/maven2/"
        }
      }
      dependencies {
        classpath group: 'javax.mail', name: 'javax.mail-api', 
          version: '1.4.5'
      }
    }
  }
}</pre></div><p>Copy and paste the preceding code and save it as <code class="literal">init.gradle</code> file under any of the preceding mentioned paths. The <code class="literal">println</code> statement is intentionally added in this file to help you understand the execution cycle of the <code class="literal">init</code> script. Whenever you execute any Gradle script from a directory, you will see <code class="literal">Hello from init script</code>. Apart from printing <code class="literal">Hello from init script</code>, this script also downloads <code class="literal">javax.mail-api-1.4.5.jar</code> in the Gradle cache when the script is executed for the first time. It will not download this library again, unless there is a change in the file in the repository. If you don't understand what a cache is, don't worry. You will learn more about cache management in the later section of this chapter. Remember, sometimes defining too many configurations in the init script could be problematic. Specifically, debugging could be difficult because the projects are no longer self-contained.</p></div>
<div class="section" title="Build life cycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec15"/>Build life cycle</h1></div></div></div><p>Gradle build has a life cycle, which consists of three phases: initialization, configuration, and execution. Understanding the build life cycle and the execution phases is crucial for Gradle developers. Gradle build is primarily a collection of tasks and a user can<a id="id43" class="indexterm"/> define the dependency between the tasks. So, even if two tasks depend on the same task, for example, Task C and Task B both depend on Task A, Gradle makes sure that Task A will execute only once throughout the execution of the build script.</p><p>Before executing any task, Gradle <a id="id44" class="indexterm"/>prepares a <span class="strong"><strong>Directed Acyclic Graph</strong></span> (<span class="strong"><strong>DAG</strong></span>) of all tasks for the build. It is directed because a task directly depends on another task. It is acyclic because, if Task A depends on Task B and if you make Task B depend on Task A, it will result in an error, as there can't be cyclic dependency between two tasks. Before executing the build script, Gradle configures the task dependency graph.</p><p>Let's quickly discuss the three build phases.</p><div class="section" title="Initialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Initialization</h2></div></div></div><p>User can create a build script for a single project as well as for a Multi-project build. During the initialization phase, Gradle determines which projects<a id="id45" class="indexterm"/> are going to take part in the build process, and creates a Project instance for each of these projects.</p></div><div class="section" title="Configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Configuration</h2></div></div></div><p>This phase configures the project object. All the build scripts (in case the user is executing a multiproject build), which are part of the build process are <a id="id46" class="indexterm"/>executed without executing any task. This means whatever statements you have written outside of the task in the configuration block would be executed in the configuration phase. No tasks would be executed here; only the directed acyclic graph would be created for all tasks.</p></div><div class="section" title="Execution"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Execution</h2></div></div></div><p>In this phase, Gradle executes <a id="id47" class="indexterm"/>all tasks as per the order given in the command line. However, if any dependencies exist between tasks, those relationships will be honored first before the command-line ordering.</p></div></div>
<div class="section" title="Cache management"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec16"/>Cache management</h1></div></div></div><p>The main focus of any build tool is to not only automate the build and deployment processes, but also how to manage the cache effectively. No software works in isolation. Each software depends on some third-party libraries and/or in-house libraries.</p><p>Any good build tool <a id="id48" class="indexterm"/>should automatically take care of software dependencies. It should be able to download the dependencies automatically and maintain the versioning. When Ant was released, this feature was not available and developers need to manually download the dependencies and need to maintain their versioning on its own. Though it was later resolved by extending Ant with Ivy.</p><p>Gradle automatically downloads all dependencies given in the build file. It determines all the libraries needed for the project, downloads from the repositories, and stores them in its local cache. Next time when you run the build, it doesn't need to download those dependencies again (unless required) as it can reuse the libraries from the cache. It also downloads all the transitive dependencies.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>
<span class="strong"><strong>Downloading the example code</strong></span>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><div class="section" title="Cache location"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Cache location</h2></div></div></div><p>The first question arises regarding cache, in which location Gradle maintains its cache. Gradle uses <code class="literal">&lt;USER_HOME&gt;/.gradle/caches</code> as the default directory to store its local cache. It might contain more than one version directory if a developer has used multiple versions of Gradle to build the software. The actual cache is divided into two parts. All the jars that are downloaded from the<a id="id49" class="indexterm"/> repositories can be found under <code class="literal">modules-2/files-2.1</code>. Additionally, you will also find some binary files that will store the metadata about the downloaded binaries. If you look inside the <code class="literal">modules-2/files-2.1</code> directory, it has the path in the format <code class="literal">group/name/version/checksum</code>, which contains the actual binary. You can find out more about dependency management in detail in <a class="link" href="ch05.html" title="Chapter 5. Dependency Management">Chapter 5</a>, <span class="emphasis"><em>Dependency Management</em></span>.</p></div><div class="section" title="Change Cache location"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Change Cache location</h2></div></div></div><p>If you want to change<a id="id50" class="indexterm"/> the cache location to some other directory, other than default location, you need to set the following environment variables. You can set this variable in Windows as the environment variable and in the Unix/Linux in <code class="literal">.profile</code> file:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>GRADLE_USER_HOME=&lt;User defined location&gt;</strong></span>
</pre></div></div><div class="section" title="Cache features"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Cache features</h2></div></div></div><p>Now, let's discuss some <a id="id51" class="indexterm"/>of the important features of the Gradle cache.</p><div class="section" title="Reduce the traffic"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Reduce the traffic</h3></div></div></div><p>One of the main features of Gradle cache management is to reduce the network traffic. When you build the application for the first time, Gradle downloads all the dependencies into a cache, so that next time onwards it can directly fetch it from the cache.</p><p>In case multiple repositories are configured in the build script and a JAR is found in the first repository, then Gradle <a id="id52" class="indexterm"/>won't search other repositories for the same JAR file. In another situation, if the JAR was not found in the first repository but was fetched from the second repository, then Gradle will store metadata information about the first repository, so that next time onwards the first repository won't be searched for the missing JAR, to save time and network traffic.</p></div><div class="section" title="Dependency location"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec02"/>Dependency location</h3></div></div></div><p>Whenever Gradle downloads dependencies from the repositories, it also stores the repository location in its metadata. It helps to detect the changes in case the binaries are removed from the<a id="id53" class="indexterm"/> repositories or their structure is changed.</p></div><div class="section" title="Version integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec03"/>Version integration</h3></div></div></div><p>If a developer updates the Gradle version on his machine, and he has already downloaded libraries in an older <a id="id54" class="indexterm"/>cache, then it is reused. Gradle also provides tight integration with Maven's local repository. Gradle figures out whether an artifact has changed in the remote repository by comparing its checksum with the local cache. All those artifacts whose checksum matches are not downloaded. Apart from checksum, Gradle will consider an additional parameter to compare between the remote and local artifacts; Gradle uses the value of the HTTP header parameter <span class="emphasis"><em>content-length</em></span> or the last modified date.</p></div><div class="section" title="Switching off remote checking"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec04"/>Switching off remote checking</h3></div></div></div><p>With the <code class="literal">--offline</code> command-line option, a developer can ask Gradle to only look at the local cache, not in the<a id="id55" class="indexterm"/> remote cache. This could be useful if the user is working without any network connectivity. If Gradle can't find the JAR in the local cache, the build will fail.</p></div><div class="section" title="Version conflicts"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec05"/>Version conflicts</h3></div></div></div><p>If a developer has not<a id="id56" class="indexterm"/> mentioned any specific version of dependency and there are multiple versions available for the download, Gradle, by default, always downloads the latest version of the artifact.</p></div></div></div>
<div class="section" title="Gradle with IDE"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec17"/>Gradle with IDE</h1></div></div></div><p>So far, in this chapter, we have worked on creating some basic Gradle scripts. We will conclude this chapter by creating a Java application with Gradle. To create a Java application, we'll be using Eclipse IDE with the Gradle plugin.</p><p>With <span class="strong"><strong>Integrated Development Environment</strong></span> (<span class="strong"><strong>IDE</strong></span>), application development becomes much easier. In this <a id="id57" class="indexterm"/>section, we will explore how to install the Gradle plugin in Eclipse, create a simple Java application, explore Eclipse plugin tasks, and execute Gradle tasks from Eclipse.</p><p>Apart from Eclipse, another <a id="id58" class="indexterm"/>popular IDE is JetBrains IntelliJ IDEA. Gradle also supports IDEA plugin, which is very similar to the Eclipse plugin. However, in this book, we will focus only on the Eclipse plugin since it is freely available and is open source.</p><div class="section" title="Installing the Gradle plugin in Eclipse"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Installing the Gradle plugin in Eclipse</h2></div></div></div><p>The Eclipse Integration Gradle project from the spring source (<a class="ulink" href="https://github.com/spring-projects/eclipse-integration-gradle/">https://github.com/spring-projects/eclipse-integration-gradle/</a>) helps the developer to work with Gradle<a id="id59" class="indexterm"/> in Eclipse. This tool offers <a id="id60" class="indexterm"/>support for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with <a id="id61" class="indexterm"/>multiprojects</li><li class="listitem" style="list-style-type: disc">Using<code class="literal"> Gradle Import Wizard</code> to import Gradle projects into Eclipse</li><li class="listitem" style="list-style-type: disc">Using<code class="literal"> New Gradle Project Wizard</code> to create new Gradle projects</li><li class="listitem" style="list-style-type: disc">Using<code class="literal"> </code>Dependency Management to configure the classpath of the Eclipse project</li><li class="listitem" style="list-style-type: disc">Executing Gradle tasks using <code class="literal">Gradle Task UI</code></li><li class="listitem" style="list-style-type: disc">Integration with the Groovy Eclipse via DSLD (DSL Descriptors)</li></ul></div><p>Following are the steps to install this plugin in Eclipse (3.7.2 or higher) from the update site:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Launch Eclipse. Navigate to <span class="strong"><strong>Help</strong></span> | <span class="strong"><strong>Install New Software</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>Install New Software</strong></span> dialog, click on the <span class="strong"><strong>Add</strong></span> button to add a new site.</li><li class="listitem">Enter the <span class="strong"><strong>Location</strong></span> as <code class="literal">http://dist.springsource.com/release/TOOLS/gradle</code> and <span class="strong"><strong>Name</strong></span> as <code class="literal">Gradle</code>. You can enter any meaningful name you want.</li><li class="listitem">Click on <span class="strong"><strong>OK</strong></span> to add the repository.</li><li class="listitem">Select the newly created Gradle repository from the repository list.</li><li class="listitem">Check only the box next to <span class="strong"><strong>Extensions / Gradle Integration</strong></span> | <span class="strong"><strong>Gradle IDE</strong></span>. Click on <span class="strong"><strong>Next</strong></span> (Refer to <span class="emphasis"><em>Figure 1.2</em></span>).</li><li class="listitem">On the next screen, click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem">Accept the terms and conditions and click on <span class="strong"><strong>Finish</strong></span>. Eclipse should download and install <a id="id62" class="indexterm"/>Gradle IDE. Then restart <a id="id63" class="indexterm"/>Eclipse.<div class="mediaobject"><img src="graphics/B02000_01_02.jpg" alt="Installing the Gradle plugin in Eclipse"/><div class="caption"><p>Figure 1.2</p></div></div></li></ol></div></div><div class="section" title="Working with the Gradle project in IDE"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Working with the Gradle project in IDE</h2></div></div></div><p>We have successfully<a id="id64" class="indexterm"/> installed Gradle plugin. Now, we'll create a simple Gradle project and we'll look into few Eclipse-related important files, for <a id="id65" class="indexterm"/>example, <code class="literal">.project</code> and <code class="literal">.classpath</code>. Then we will build the project using the Gradle Task UI.</p><p>Following are the steps to create a Gradle project:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In Eclipse, navigate to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>Gradle</strong></span> | <span class="strong"><strong>Gradle Project</strong></span>.</li><li class="listitem">In the <span class="strong"><strong>New Gradle Project</strong></span> window, specify the project name as <span class="strong"><strong>FirstGradleProject</strong></span> and select the sample project as <span class="strong"><strong>Java Quickstart</strong></span>.</li><li class="listitem">Click on <span class="strong"><strong>Finish</strong></span> and wait for the build to be successful.</li></ol></div><p>You will find the following console output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>:cleanEclipseClasspath UP-TO-DATE</strong></span>
<span class="strong"><strong>:cleanEclipseJdt UP-TO-DATE</strong></span>
<span class="strong"><strong>:cleanEclipseProject UP-TO-DATE</strong></span>
<span class="strong"><strong>:cleanEclipse UP-TO-DATE</strong></span>
<span class="strong"><strong>:eclipseClasspath</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>:eclipseJdt</strong></span>
<span class="strong"><strong>:eclipseProject</strong></span>
<span class="strong"><strong>:eclipse</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>The output clearly shows <a id="id66" class="indexterm"/>what is going on here. Gradle initially executes a series of clean tasks (<code class="literal">cleanEclipseClasspath</code>, <code class="literal">cleanEclipse</code>, and so on.), then downloads some jar files from the Maven repository and finally executes a few more tasks (<code class="literal">eclipseJdt</code>, <code class="literal">eclipse</code>, and so on) to<a id="id67" class="indexterm"/> complete the build process.</p><p>The autogenerated <code class="literal">build.gradle</code> file has the following contents:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'eclipse'

sourceCompatibility = 1.5
version = '1.0'
jar {
  manifest {
    attributes 'Implementation-Title': 'Gradle Quickstart', 'Implementation-Version': version
  }
}

repositories {
  mavenCentral()
}

dependencies {
  compile group: 'commons-collections', name: 'commons-collections', version: '3.2'
  testCompile group: 'junit', name: 'junit', version: '4.+'
}

test {
  systemProperties 'property': 'value'
}

uploadArchives {
  repositories {
    flatDir {
      dirs 'repos'
    }
  }
}</pre></div><p>This <code class="literal">build</code> file is, quite different from what we created earlier in this chapter. The Java and Eclipse plugin declarations were added in the beginning. Project properties such as <code class="literal">sourceCompatibility</code> and<a id="id68" class="indexterm"/> version were added. The repository was declared as <code class="literal">mavenCentral()</code>. Dependencies, common-collections, and JUnit were configured on <code class="literal">compile</code> and <code class="literal">testCompile</code> respectively. We'll learn each and every component in the next chapters; now, let's concentrate on the other artifacts created by the Gradle project.</p><p>If you browse the <a id="id69" class="indexterm"/>source code (look for the <code class="literal">src</code> folder) of the project, you'll find that the application was prepopulated with some Java source code and JUnit test cases.</p><p>Apart from the source code and build file,a few other files, namely, <code class="literal">.project</code>, and <code class="literal">.classpath</code> and a folder, namely, <code class="literal">.settings</code>, were added to this Java project. These are the default files created by Eclipse. As the name suggests, the <code class="literal">.project</code> file contains the metadata information about the project such as name, description and build specification. The <code class="literal">.classpath</code> file describes the Java dependency, external library dependencies, and other project dependencies. <code class="literal">.settings/org.eclipse.jdt.core.prefs</code> stores information such as the Java compiler version, source, and the target Java version. All these three files were created during the build process when the <code class="literal">eclipse</code> task was executed.</p><p>So, we claimed that the Eclipse plugin was responsible for creating all of the Eclipse IDE-specific files. To confirm, first execute the <code class="literal">gradle cleanEclipse</code> command from the project of the base folder:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle cleanEclipse</strong></span>
<span class="strong"><strong>:cleanEclipseClasspath</strong></span>
<span class="strong"><strong>:cleanEclipseJdt</strong></span>
<span class="strong"><strong>:cleanEclipseProject</strong></span>
<span class="strong"><strong>:cleanEclipse</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>The <code class="literal">cleanEclipse</code> task executed three more dependent tasks: <code class="literal">cleanEclipseClasspath</code> (removes the <code class="literal">.classpath</code> file), <code class="literal">cleanEclipseJdt</code> (removes the <code class="literal">.settings/org.eclipse.jdt.core.prefs</code> file), and <code class="literal">cleanEclipseProject</code> (removes the <code class="literal">.project</code> file).</p><p>Check whether all the three files got deleted from the project, and, finally, execute the <code class="literal">gradle eclipse</code> command to recreate those files.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle eclipse</strong></span>
<span class="strong"><strong>:eclipseClasspath</strong></span>
<span class="strong"><strong>:eclipseJdt</strong></span>
<span class="strong"><strong>:eclipseProject</strong></span>
<span class="strong"><strong>:eclipse</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>
</pre></div><p>Now the question is if I have a Java project, how do I import that project in Eclipse IDE?</p><p>We have learned this already and you might have guessed it. It takes just three steps: add the Eclipse plugin into<a id="id70" class="indexterm"/> the build file (apply the <code class="literal">eclipse</code> plugin ), execute Eclipse task (<code class="literal">gradle eclipse</code>), and finally import project using <span class="strong"><strong>Eclipse File</strong></span> | <span class="strong"><strong>Import</strong></span>.</p><p>Alternatively, you can<a id="id71" class="indexterm"/> use Gradle IDE. From Eclipse, select the project by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>Import</strong></span> | <span class="strong"><strong>Gradle</strong></span> | <span class="strong"><strong>Gradle Project</strong></span>, and then perform <code class="literal">Build Model</code> and finish. Use of Gradle IDE helps to avoid all the manual steps mentioned earlier.</p><p>We'll conclude this section by exploring Gradle Task UI, which enables us to execute tasks. Gradle task execution is supported by the standard Eclipse launching framework. This means that before we execute any task, we must create a standard Eclipse launch configuration. To create the launch configuration, navigate to <span class="strong"><strong>Gradle project</strong></span> | <span class="strong"><strong>Run As</strong></span> | and click on <span class="strong"><strong>Gradle Build</strong></span>.</p><p>In the text area, enter the task names you want to execute, such as <code class="literal">clean build</code>. Then click on <span class="strong"><strong>Run</strong></span> to execute the tasks. The launch configuration will be saved as the project name by default. In <span class="emphasis"><em>Figure 1.3</em></span>, the configuration is saved as <span class="strong"><strong>FirstGradleProject</strong></span>, which is the project name.</p><div class="mediaobject"><img src="graphics/B02000_01_03.jpg" alt="Working with the Gradle project in IDE"/><div class="caption"><p>Figure 1.3</p></div></div><p>This launch configuration <a id="id72" class="indexterm"/>will be saved in Eclipse, so that it can be executed again. To launch the previously saved configuration, <span class="strong"><strong>FirstGradleProject</strong></span>, you need<a id="id73" class="indexterm"/> to navigate to <span class="strong"><strong>Run As</strong></span> | <span class="strong"><strong>Gradle Build</strong></span>. This will once again, execute the <code class="literal">clean build</code> command.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we briefly discussed what a Build Automation System is, why do we need it, and why Gradle is a popular Build Automation System. You also learned how to install Gradle and we created our first Gradle script. Then we discussed the command-line options, GUI support, cache management, and startup scripts. Finally, we concluded the chapter working with Eclipse IDE with the Gradle Plugin to develop a simple Java application.</p><p>All the build scripts developed in this chapter were written in Groovy, but we have not talked about it. So, in the next chapter, we will learn some basic concepts of the Groovy programming language. Next chapter is meant mainly for developers who already have some basic knowledge of Java and object-oriented programming concepts.</p></div></body></html>