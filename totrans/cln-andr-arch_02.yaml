- en: '*Chapter 1*: Getting Started with Clean Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll take you back and show you how a feature would have been
    implemented in the past while analyzing the potential issues and problems with
    that approach. Then, we'll look at some key design principles for software development
    and apply those principles to our legacy examples. After that, we'll cover the
    evolution of the Android platform and the various libraries and frameworks that
    have emerged. We'll also see how they can be integrated while adhering to various
    software design principles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: After that, we'll introduce clean architecture so that we know what our system
    needs to be improved and what questions we must ask, as developers, so that we
    can create a robust, scalable, maintainable, and testable application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of a legacy app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software design principles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the evolution of Android
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter clean architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know about the evolution of Android development,
    its architecture, and its design concepts, as well as the concept of clean architecture
    and how it can be used to build flexible, maintainable, and testable applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need Android Studio Arctic Fox 2020.3.1 Patch 3.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the hardware requirements for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 64-bit Microsoft® Windows® 8/10
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: x86_64 CPU architecture; 2nd generation Intel Core or newer, or an AMD CPU with
    support for a Windows Hypervisor
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of RAM or more
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,280 x 800 minimum screen resolution
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mac:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS® 10.14 (Mojave) or higher
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ARM-based chips, or 2nd generation Intel Core or newer with support for Hypervisor.Framework
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of RAM or more
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,280 x 800 minimum screen resolution
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any 64-bit Linux distribution that supports Gnome, KDE, or Unity DE; GNU C Library
    (glibc) 2.31 or later
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: x86_64 CPU architecture; 2nd generation Intel Core or newer, or AMD processor
    with support for AMD Virtualization (AMD-V) and SSSE3
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of RAM or more
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 GB of available disk space minimum (IDE + Android SDK + Android Emulator)
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 1,280 x 800 minimum screen resolution
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The architecture of a legacy app
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how Android applications used to be built in
    the past and what difficulties developers had with the approach taken.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Before we start analyzing an older application, we must distinguish the architecture
    and design of an application. To borrow from the construction industry, we can
    define architecture as a plan for the structure of a building; a design would
    be a plan to create each part of the building. Translating this into the world
    of software engineering, we can say that the architecture of an application or
    a system would be defining a plan that would incorporate the business and technical
    requirements, while software design deals with integrating all the components,
    modules, and frameworks into this plan. In an ideal world, you would want to recognize
    the architecture of an application in the same way you would recognize the architecture
    of your house.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the four main components of an Android application:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Activities**: These represent the entry points for interacting with the user.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: These represent the entry points for having an app run in the
    background for all kinds of reasons, such as large downloads or audio playback.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast Receivers**: These allow the system to interact with an application
    for a variety of reasons.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content Providers**: These represent a way for an application to manage application
    data.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and relying on these components created a challenge for developers because
    an app's architecture became dependent on the Android framework, mainly when it
    came to implementing unit tests. To understand why this is a problem, let's look
    at an example of what some older application code would look like. Let's suppose
    you have been asked to fetch some data from a backend service. The data would
    be served in the form of JSON through an HTTP connection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'It wasn''t uncommon to see a class such as `BaseRequest.java`, which would
    execute the request and depend on abstraction in the form of `JsonMapper.java`,
    to convert the data from a `String` into a **Plain Old Java Object** (**POJO**).
    The following code represents an example of how fetching the data might be implemented:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the `execute` method, we would use `HttpURLConnection` to connect to the
    backend service and retrieve the data. Then, we would read it into a `String`,
    which would then be converted into a `JSONObject` and then passed to `JsonMapper`
    to be converted into a POJO.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The `JsonMapper.java` interface would look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This interface represents the abstraction of converting a `JSONObject` into
    any POJO.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of generics allows us to apply this logic to any POJO. In our case,
    the POJO should look something like `ConcreteData.java`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ConcreteData` class will be responsible for holding the data we will receive
    from the backend service. In this case, we just have two `String` instance variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to create a concrete `JsonMapper.java` that will be responsible
    for converting a `JSONObject` into `ConcreteData`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `convert` method creates a new `ConcreteData` object, extracts the data
    from the `JSONObject` object, and populates the `field1` and `field2` values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must create a `ConcreteRequest.java` that will extend `BaseRequest`
    and use `ConcreteMapper`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class will inherit the `execute` method from `BaseRequest` and supply a
    new `ConcreteMapper` object so that we can convert the backend data into `ConcreteData`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can use this in our `Activity` to execute the request and update
    our `AsyncTask` class, which offers a set of methods for doing work on a separate
    thread and then processing the results on the main thread. However, we risk creating
    a context leak (if, for any reason, the `Activity` object is destroyed, then the
    garbage collector will not be able to collect the `Activity` object while `AsyncTask`
    is running since `Activity` has a dependency on `AsyncTask`) by using an inner
    `AsyncTask` class. To circumvent this, the recommended approach is to create a
    `WeakReference` for our `Activity`. This way, if the `Activity` object is destroyed
    either by the user or the system, its reference can be collected by the garbage
    collector.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code for our `MainActivity`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This class is responsible for loading the UI and starting `LoadConcreteDataTask`.
    The `update` method will then be called by `LoadConcreteDataTask` to show the
    data in the user interface.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '`LoadConcreteDataTask` must be an inner class of `MainActivity`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `LoadConcreteDataTask`, we take advantage of the `doInBackground` method,
    which is executed on a separate thread to load our data and then update our UI
    in the `onPostExecute` method. We also hold a `WeakReference` to `MainActivity`
    so that it can be safely garbage collected when destroyed. This also means that
    we will need to check if the reference still exists before updating the user interface.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram for the preceding code looks as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A class diagram for an older Android app'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.01_B18320.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – A class diagram for an older Android app
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see how the dependencies move from `MainActivity` toward the `ConcreteRequest`
    class, with one exception between `MainActivity` and `LoadConcreteDataTask`, where
    both classes depend on each other. This is a problem because the classes are then
    coupled together and making a change to one implies making a change to the other.
    Later in this chapter, we will look at some principles that can help us avoid
    such dependencies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea of what a legacy application looks like, let's see
    what issues we may encounter if we follow this path.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Legacy analysis
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will analyze some of the problems that legacy applications
    have.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ask ourselves the following questions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: What can we unit test?
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if, instead of showing the value of `field1` from `ConcreteData`,
    we need to show `field1+field2`?
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when the requirements for this particular screen change and data
    needs to be retrieved from another endpoint on top of this one?
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if we need to introduce caching or SQLite persistence?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if another activity needs this particular use case?
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s answer these questions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`androidTest` and `test` directories. Theoretically, we can write our unit
    tests so that they can run on the emulator, but that takes more time and instability.
    We can now execute these types of tests in the cloud using technologies such as
    Firebase Test Lab, but that would inevitably cost us money and it''s in our interest
    to avoid taking in such costs. Realistically, we are left with one option and
    that is to test as much as possible using local unit tests instead of instrumented
    ones. To solve this, we will need to separate the Android components we use from
    the Java components.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MainActivity` or add a method into the `ConcreteData` class that will return
    the concatenated result. But either of these will come with downsides. If we move
    the concatenation into `MainActivity`, we will put logic that can be unit tested
    into a class that is very hard and shouldn''t be unit tested. If we create a method
    to concatenate in `ConcreteData`, we risk giving responsibility to this class
    that it shouldn''t have since it''s related more to the UI than the actual representation
    of the JSON itself. What if, in the future, the networking aspect is developed
    by another team? You would need to rely on that particular team to create this
    update.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncTask` or execute both requests in the same `LoadConcreteData` class and
    then update the UI. If we create a separate `AsyncTask`, then we will need to
    make the activity responsible for managing the results and balance the two `AsyncTasks`,
    which again creates a problem concerning testing. If we execute the requests in
    the same `AsyncTask`, then the responsibility of `AsyncTask` increases, which
    we may want to avoid.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadConcreteDataTask`. Here, we run into the same issues that we did in the
    previous questions. If we used the request classes, we would end up being more
    responsible for dealing with HTTP connections than handling calls to the database.
    If we use `LoadConcreteDataTask`, we make the answer to the fifth question even
    harder.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoadConcreteDataTask` class. Now, let''s imagine that another activity with
    a completely different UI and a different interpretation of that data will rely
    on the same use case. One solution is to duplicate `LoadConcreteDataTask` into
    the new activity. This is not a great idea because a change in the requirements
    will make the developers change all the tasks. A better approach would be to create
    a new abstraction that will remove the dependency between `LoadConcreteDataTask`
    and `Activity`. This would allow us to reuse the same class for both activities.
    Let''s say that the activities would need different types of data for each interpretation.
    Here, we could follow the `JsonMapper` example and create an interface that would
    convert `ConcreteData` into a generic type, provide two implementations for each
    activity, and create the necessary POJOs to convert into.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another question that can be asked here is, "What amount of work would be necessary
    to export the business logic into another project?" This is an important question
    because it highlights how we should structure our code so that it can be reused
    by others without making it a pain for them to integrate. If we were to answer
    this, we must first ask, "Where's the business logic?" The answer would probably
    be `LoadConcreteDataTask`. Can we export that and publish it somewhere where other
    developers can get it?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no, because of its dependency on `MainActivity`. This question
    highlights an important aspect of defining an architecture, namely drawing the
    boundaries around your components. A component can be defined as the smallest
    piece of deliverable code. In our case, it would be the equivalent of a module.
    Now, let's say we were in a place where we could ship out our `LoadConcreteDataTask`.
    A follow-up question would be, "Would the data be hosted on the same service?"
    followed by, "Is it in the same JSON format?" Here, we would need to draw a boundary
    between `LoadConcreteDataTask` and `BaseRequest` and remove such dependencies
    on how the data is retrieved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The reason these questions were raised and answered is that all those scenarios
    have happened in the past and they will all likely happen in the life cycle of
    an application. We, as developers, tend to answer those questions in our code
    differently based either on time constraints, the rigor imposed on the team we
    work in, our ambition to deliver something fast by constantly challenging ourselves,
    and our experience or the team's experience. The fact that we had the option to
    make a less desirable solution or to be stuck in a situation where we had to pick
    between the frying pan or the fire represents a problem. Sometimes, it is good
    to take a step back from our daily routine, ask ourselves some of these questions,
    do mind experiments to see how our code may end up in those scenarios, and assess
    what would happen if that would happen now or 1 or 2 years from now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: A common scenario a lot of Android developers found themselves in was having
    a lack of businesses investing in testing because it would take too much time
    and there was a need to go to market. In many of these cases, the apps became
    harder to maintain over time, so more developers needed to be hired to keep the
    same productivity as a team compared to when they had fewer developers. When code
    is written with the notion that it needs to be unit tested, then the way we write
    that code becomes more rigorous and more maintainable. We start keeping track
    of how we create instances and separate the things we can test from the things
    we can't, we apply creational design patterns, and we also shorten the sizes of
    the methods in our classes, among other things.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We now have an idea of how applications used to be written in the past and the
    problems that were caused by the approaches that were taken, such as issues with
    the testability and maintainability of an application due to dependencies on the
    Android framework. Next, we will look at some design principles that will prove
    useful in how we write an application.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Software design principles
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will analyze a set of design principles that are adopted
    by developers worldwide to improve their systems and can also be applied to Android
    development. We will mainly focus on the principles defined by *Robert C Martin*
    (also known as Uncle Bob) for classes and components because they are well suited
    to Android development.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Based on the examples in the previous section, we understand that our code bases
    should be maintainable, understandable, and flexible. There is a set of software
    design principles that we can turn to for help when we develop classes or components.
    Think of a component as the minimum amount of code that can be released as part
    of a system. In Android, you can view them as individual modules. They don't necessarily
    need to be modules, but they can be organized as if they are.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are some of the most known design principles. The name is an acronym
    for a set of design principles that were collected by *Robert C Martin*. These
    principles are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open-closed principle
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at these principles in detail:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '`BaseRequest` class to change how the HTTP request is executed. Let''s assume
    that we now have two different AsyncTasks that will load the data. Both of these
    will be impacted by the change in the `BaseRequest` class. A solution would be
    to delegate the execution of the request to different classes for each particular
    use case. This would also allow developers to work on different features related
    to backend communication without changing the same source file.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open-Closed Principle**: This states that a class should be open for extension
    and closed for modification. Thinking back to our example, this principle would
    answer the question, "What would happen if an activity requires this particular
    use case?" The abstractions we discussed in how to answer that question would
    serve as a good example of implementing this principle.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bird` and a sub-class called `Duck`. If you are using references of `Bird`
    in your code and substitute those usages with `Duck`, then your code should remain
    unchanged. A famous example of a violation of this principle is having a `Rectangle`
    class with two members named `width` and `height` and a sub-class named `Square`.
    In reality, a square is a rectangle, but our modeling of a square wouldn''t be
    a rectangle because the rules in `Square` would mean that the width and height
    will always have to be the same. If you were to swap these two dependencies, then
    your code would break.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnClickListener`, `OnLongClickListener`, and `OnTouchListener`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle**: This states that we should depend on abstractions
    rather than concretions. The idea here is to depend as much as possible on abstract
    classes and interfaces. This can be very difficult to achieve considering that
    we rely on concretions a lot of the time. Here, we should identify parts of the
    code that are constantly developed and subject to change and introduce layers
    of abstractions between our code and these classes. A good way to protect against
    this is through dependency injection frameworks such as Dagger and Hilt, which
    generate factories to create volatile components.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID principles are used across the **object-oriented programming** (**OOP**)
    field to create applications that are flexible and able to incorporate new features
    and requirements. The principles that follow represent an expansion of SOLID.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Component cohesion principles
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can define cohesion by how well the classes in a component belong together
    or what classes belong in a certain component. In the past, components were assembled
    based on the context without any particular guiding principle. This would cause
    issues such as a change in the dependencies of a component triggering a change
    in the dependants of this component, without this having any relevance to the
    dependants.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'The three principles are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '**Reuse/Release Equivalence Principle** (**REP**): This states that we group
    classes in a component that can be released together. In Android development,
    this would translate to making sure that every module you create should be able
    to be published and used by other developers.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Closure Principle** (**CCP**): This states that components should
    have one reason to change. This principle is an application of the single responsibility
    principle for components.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Common Reuse Principle** (**CRP**): This states that a component should only
    have classes that should be used together. This represents the interface segregation
    principle for your component. In Android, this would mean that you should make
    sure that the users of your Android modules depend on all your classes in the
    module, not just some.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When these principles are incorporated, they end up conflicting with each other.
    REP and CCP tend to make components bigger, while CRP tends to make them smaller.
    The idea is to always match the current requirements of the application and find
    the middle ground between these principles. After that, you should constantly
    monitor how new requirements would affect this middle ground.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how SOLID can be applied to building a particular component
    through the component cohesion principles, let's learn how to manage a set of
    components.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Component coupling principles
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These principles deal with how to manage the relationships between our components
    in an Android application. In Android, this would be represented by how to manage
    the Gradle dependencies between different modules. The principles are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**Acyclic Dependencies Principle**: This states that we should avoid cyclic
    dependencies between components. Applying this to Android would mean that the
    dependencies that our modules have most not be cyclical (for example, module A
    depends on module B, which depends on module A). Fortunately, this rule is currently
    enforced by the build system, which doesn''t allow cyclical dependencies. A solution
    to this would be to create a new module in which we apply the dependency inversion
    principle and make one of the modules depend on the abstraction and create the
    implementation in the second module. If this is not possible, we can create a
    new module that can depend on both existing modules. An example of this can be
    seen in the following diagram:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Cyclic module dependency'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.02_B18320.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Cyclic module dependency
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable Dependencies Principle**: This states that less stable modules should
    depend on more stable modules. A component''s stability is defined as the ratio
    between outgoing dependencies (dependency on other components) and the total number
    of dependencies. The closer the number is to 0, the more stable a component becomes.
    This means that stable components should avoid having changes made because this
    will cause potential issues for the components that depend on the stable ones.
    One solution to avoid the dependencies between stable components and volatile
    components would be using abstract components. These are components that will
    contain nothing but abstractions.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stable Abstractions Principle**: This states that components that are likely
    to change should be more concrete and that stable components should be more abstract.
    This principle represents an application of the open-closed principle. We would
    want our high-level architecture decisions to be flexible enough to be changed
    without having to modify existing source code. We can achieve this using abstract
    classes. The abstractness of a component is defined as the ratio between the number
    of abstract classes and interfaces inside a component and the total number of
    classes in the component. The closer to 1 the value gets, the more abstract the
    component becomes. A component with 0 stability and 0 abstractness represents
    a **zone of pain** because it is very hard to change. A component with 1 stability
    and 1 abstractness is called a **zone of uselessness** because we have an independent
    component with no implementations. The aim is to get as many components as possible
    in either the 0 stability and 1 abstractness or 1 stability and 0 abstractness
    range.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, we have looked at some of the key design principles that should help
    us tackle problems that we face while developing an application. The SOLID principles
    show us how we should structure our code into classes, while the component cohesion
    principles and component coupling principles show us how we should structure our
    classes into separate modules, as well as how we should establish the relationships
    between those modules. In the next section, we will see how these principles lead
    to the evolution of the Android platform and what an application may look like
    now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the evolution of Android
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at key releases and changes that have been made
    to the Android framework and supporting libraries that have shaped the development
    of applications and how applications have evolved because of these changes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: We started by looking at an example of what the code in an older Android application
    looked like before looking at the design principles we should incorporate into
    our work. Now, let's see how the Android framework evolved and how some of our
    questions from the beginning have been answered. We will analyze some of the newer
    libraries, frameworks, and technologies that we can incorporate into an Android
    application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of fragments was meant to solve important issues developers
    were facing – that is, the activity code would become too big and hard to manage.
    They were released on Android Honeycomb, which was an Android release that only
    targeted tablets. The introduction of fragments was also meant to solve the issue
    of having different displays for activities in landscape versus activities in
    portrait. Fragments are meant to control portions of an activity's user interface.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Another improvement fragments brought was the ability to change and replace
    fragments at runtime. There was even a separate back stack for Fragments that
    the activity would be responsible for. This comes at a couple of costs: the life
    cycle of the fragment was even more complex than the life cycle of the activity,
    where you would have fragments that had their views destroyed but the fragments
    themselves weren''t. Another cost was the communication between two fragments.
    If you needed to update the user interface being handled by Fragment1 because
    of a change in Fragment2, you would need to communicate through the activity.
    This meant that every time a Fragment needed to be reused by a different activity,
    then the activity would be forced to adapt to this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Activity and fragment life cycle'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.03_B18320.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Activity and fragment life cycle
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we can see the difference between the lifecycle of
    activities and the lifecycle of fragments. We can observe how fragments have their
    own internal lifecycle for managing the views that they display between the `onCreateView`
    method and `onDestroyView` methods. This is often the reason why in many applications,
    you will see these methods used to load data and on the opposite site unsubscribing
    from any operations that might trigger a change in the user interface.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The Gradle build system
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initially, Android development used the Eclipse IDE and Ant as its build system.
    This came with certain limitations for applications. Things such as flavors were
    not available at the time. The release of Android Studio, along with the Gradle
    build system, provided new opportunities and features. This allows us to write
    extra scripts and easily integrate plugins and tools, such as performance monitoring
    of an application, Google Play services, Firebase Crashlytics, and more. This
    is often done through `".gradle"` files. These files are written in a language
    called Groovy. Another improvement that was added was the usage of the `".gradle.kts"`
    extensions, where we can provide the same configurations using the Kotlin language.
    The following code shows what the `build.gradle` file for a module looks like:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the `plugins` section, we can define external plugins that will provide certain
    methods and scripts that our project can use. Examples include annotation processing
    plugins, the `Parcelize` plugin, and Room plugins. In this case, the `com.android.application`
    plugin offers us the `android` configuration, which we can then use to specify
    the app version, what Android versions we want the app to be accessible from,
    various compilation options, and configurations for how the app should be built
    for the end user. In the `dependencies` section, we specify which external libraries
    we want to add to the project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite a few popular networking libraries have emerged, mainly in the open sourcing
    community. A large proportion of the applications in Google Play rely on HTTP
    communication and a large proportion of them use JSON data. With the addition
    of networking libraries, JSON serialization/deserialization to POJOs also became
    adopted. What this means for developers is that the communication with the backend
    is simplified – we no longer need to concern ourselves with how the actual communication
    is done; we only point to where we want the data from and provide the models that
    are required for this communication. The libraries will take care of the rest.
    Some of the most popular libraries include Volley and Retrofit. In terms of object
    serialization, we have libraries such as Moshi and GSON.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Humble objects
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because activities and fragments are difficult to unit test, the code inside
    them needed to be split into testable sections and untestable sections. Because
    of this necessity, two patterns emerged: **Model View Presenter** (**MVP**) and
    **Model View ViewModel** (**MVVM**). Sometimes, these patterns are referred to
    as architecture patterns. This shouldn''t be confused with the entire architecture
    of the app. The idea is to turn activities and fragments into humble objects with
    no logic, keep the references to the user interface objects, and shift the logic
    into the presenter and ViewModel, which we can write unit tests for. We will focus
    more on the particularities of each in [*Chapter 8*](B18320_08_ePub.xhtml#_idTextAnchor090)*,*
    *Implementing an MVVM Architecture*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Functional paradigms
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like objected-oriented languages have adopted paradigms from functional
    programming, so has the Android development world in the form of RxJava. Functional
    programming works on the premise that programs are built from composing functions
    rather than imperative statements such as the ones in Java. RxJava is a library
    that allows developers to implement event-driven applications. It offers observables
    (for emitting data) and subscribers (for subscribing to that data). What made
    this library appealing to developers was how it deals with threading. Let's assume
    you wanted an operation to be executed on a separate thread, and then you wanted
    to transform your data – all you need to do here is invoke the data you want,
    apply mapping functions, and then subscribe to get the final result. The added
    benefit is that you can chain different operations, have them processed, and get
    the result with all of the operations. All of this removes the need for creating
    and managing different AsyncTasks or threads.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin adoption
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RxJava introduced some aspects of functional programming. Its adoption and transition
    into Kotlin programming has added others. One of the most important is the concept
    of mutability. In Java, all variables are mutable unless they're declared otherwise
    through the `final` keyword. In Kotlin, all the variables must have their mutability
    declared. Why is this important? Because of multi-threading. If you had an application
    where multiple threads were executed at the same time and they all interacted
    with the same object, you would end up in a situation where you would either modify
    the same value at the same time or create deadlocks in which a thread would wait
    for another thread to release a resource, but the second thread would need access
    to a resource that the first thread is currently holding. This introduction helps
    developers aim for a greater degree of immutability, which would increase thread
    safety because immutable variables are thread-safe. Lambdas represent another
    great feature of Kotlin that allows boilerplate code to be reduced when you're
    dealing with callbacks. Other benefits of the adoption of Kotlin include that
    you can remove boilerplate code by introducing data classes, which represent POJOs,
    and introducing sealed classes, which allow developers to define enum-like structures
    that can carry data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dependency injection represents the decoupling of object invocation and object
    creation. Why is this important? Mainly because of testing. It''s easier to write
    unit tests for classes that have their dependencies injected rather than adding
    extra responsibilities, such as creating new instances for all of the dependencies
    in that class. Another benefit is in situations where we depend on abstractions.
    If we have a dependency on an abstraction, we can easily switch between different
    implementations, depending on different circumstances. Several libraries have
    emerged to tackle this issue: Dagger, Koin, and Hilt. Dagger is more of a general
    library that is not only Android applicable, but also applicable for other Java-based
    platforms. It aims to manage our dependencies using components and modules. Components
    are responsible for how the dependencies are managed, while modules are responsible
    for providing the appropriate dependencies. It relies on annotation processors,
    which generate the necessary code that will be responsible for managing our dependencies.
    Koin is what''s referred to as a service locator library. It keeps a collection
    of all the dependencies and when a particular dependency is required, it will
    look it up and provide it. Koin is an Android-specific library, and it provides
    support for injecting specific Android dependencies. Hilt is the newest of these
    libraries and it is built on top of Dagger. It removes the boilerplate code that
    was required for Dagger and provides support for Android dependencies as well.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Android architecture components
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is represented by a set of libraries that help developers make their apps
    scalable, testable, and maintainable. These libraries affect components that deal
    with activity and fragment life cycles, persisting data, background work, and
    UIs. Here, we have seen the introduction of concepts such as life cycle owners
    (such as activities and fragments), the Android ViewModel, and LiveData. These
    are meant to solve problems developers had with managing the state of a life cycle
    owner when it's destroyed and recreated by the system. It puts the logic that,
    in the past, was handled by the life cycle owners and delegated to the Android
    ViewModel. The combination of the Android ViewModel and LiveData has helped developers
    implement the MVVM pattern, which is also life cycle aware. This means that developers
    no longer have to concern themselves with stopping a background task when the
    life cycle owner is destroyed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过一系列帮助开发者使他们的应用可扩展、可测试和可维护的库来表示。这些库影响处理活动、片段生命周期、数据持久化、后台工作和 UI 的组件。在这里，我们看到了生命周期所有者（如活动和片段）的概念引入，Android
    ViewModel 和 LiveData。这些是为了解决开发者在使用系统销毁和重新创建生命周期所有者时管理生命周期所有者状态的问题。它将过去由生命周期所有者处理并委托给
    Android ViewModel 的逻辑放在了其中。Android ViewModel 和 LiveData 的组合帮助开发者实现了 MVVM 模式，这也是生命周期感知的。这意味着开发者不再需要在生命周期所有者被销毁时停止后台任务。
- en: 'The introduction of Room means that developers no longer have to deal with
    interacting with the SQLite framework, which caused a lot of boilerplate code
    to be written to define tables and various queries. Developers no longer need
    to deal with the SQLite interaction and the many dependencies that come with it;
    instead, they can focus on creating their own models and providing the abstractions
    for what needs to be queried, deleted, updated, and deleted; Room will take care
    of the actual implementations. DataStore does for SharedPreferences what Room
    does for SQLite. This is for when we want to store data in key-value pairs instead
    of using an entire table. DataStore provides two options for storing data: safely
    typed data and no type safety data.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Room 的引入意味着开发者不再需要与 SQLite 框架进行交互，这导致了大量样板代码的编写，用于定义表和各种查询。开发者不再需要处理 SQLite
    交互及其带来的众多依赖；相反，他们可以专注于创建自己的模型，并提供需要查询、删除、更新和删除的抽象；Room 将负责实际的实现。DataStore 对 SharedPreferences
    的作用类似于 Room 对 SQLite 的作用。这是在我们想要以键值对的形式存储数据而不是使用整个表时的情况。DataStore 提供了两种存储数据的方式：安全类型数据和无类型安全数据。
- en: With the addition of these new persistence libraries, the Repository pattern
    was adopted. The idea behind this pattern is to create a class that will interact
    with all the data sources we have in our application. As an example, let's imagine
    we have some data we will need to fetch from our backend that will then need to
    be stored locally in case we want the user to view it offline. Our repository
    would be responsible for fetching the data from the network class and then storing
    it using the persistence class. The repository would sit in between the local
    and remote classes and the classes that would want access to that data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这些新持久化库的添加，采用了 Repository 模式。这个模式背后的想法是创建一个将与我们应用中所有数据源进行交互的类。例如，让我们假设我们有一些数据需要从后端获取，然后可能需要存储在本地，以便用户可以离线查看。我们的仓库将负责从网络类获取数据，然后使用持久化类进行存储。仓库将位于本地和远程类以及希望访问这些数据的类之间。
- en: Regarding the UI, we now have access to view binding and data binding. Both
    of these deal with how activities and fragments deal with the views that are declared
    in our XML layout files. View binding generates references for each view we defined
    in our XML. This solves an issue that developers would have in the past where
    a view would be deleted from your XML file, but your application would still run
    because of another view with the same name in another file. This would cause crashes
    in the past because the `findViewById` function would return `null`. With view
    binding, we know at compile time what views we have in our hierarchy and what
    views we don't. Data binding allows us to bind our views to data sources. For
    example, we can bind a `TextView` in our XML file directly to a field in our source
    code. This approach tends to work well with the MVVM pattern, in which the ViewModel
    updates certain fields that are bound by views in our XML. This would update what
    the view would display without it interacting with the activity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines and flows
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coroutines came as a feature of the Kotlin language. The idea behind coroutines
    is to execute data asynchronously in a very simplified manner. We no longer have
    to create threads or AsyncTasks (which have been deprecated) and manage concurrency
    because it's managed under the hood. Other features include that it's not bound
    to a particular thread, and it can be suspended and resumed. Flows represent an
    extension of coroutines where we can have multiple emissions of data, such as
    RxJava, providing similar benefits.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This allows developers to build UIs directly in Kotlin without the use of XML
    files through composable functions. This removes the amount of code that needs
    to be written for building your UI. Compatibility with the other Android architecture
    component libraries is provided, allowing for easier integration into your application.
    The following is an example of what Compose looks like:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we can see a screen that contains an input field, some text
    that displays `Example Text`, and a button with the text `Button`. The layout
    of the screen is defined as a function annotated with the `@Compose` annotation.
    This content is then set in an activity through the `setContent` method, where
    a theme is provided. We will expand on how Jetpack Compose works later in this
    book.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at what our example code from the *The architecture of a legacy
    app* section will look like after we transition it through some of the aforementioned
    Android frameworks and updates. All our code will now be migrated to Kotlin. We
    will be using libraries such as Retrofit and Moshi for networking and JSON serialization
    and Hilt for dependency injection, as well as ViewModel, LiveData, and Compose
    for the UI layer. We will discuss how these libraries work in the following chapters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ConcreteData` class will look this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ConcreteData` class is now a Kotlin data class and will use the Moshi
    library for JSON conversion. Next, let''s see what our HTTP request will look
    like when we use something such as Retrofit to handle our HTTP communication:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because we use Retrofit and OkHttp, we only need to define the template for
    the endpoint we want to connect to and the data we want; the libraries will handle
    the rest. The `suspend` keyword will come in handy for Kotlin flows.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define a repository class that will be responsible for invoking
    this HTTP call on a separate thread:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`ConcreteDataRepository` will have a dependency on `ConcreteDataService`, which
    it will call to fetch the data. It will be responsible for retrieving the data
    on a separate thread by using Kotlin flows. The constructor will be annotated
    with the `@Inject` annotation because we are using Hilt, which will inject `ConcreteDataService`
    into `ConcreteDataRepository`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a `ViewModel` that will depend on the repository to load
    the appropriate data:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MainViewModel` will then use `ConcreteDataRepository` to retrieve the data,
    subscribe to the result, and post the result in `LiveData`, which `MainActivity`
    will subscribe to.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create `MainActivity`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`MainActivity` is now written using Jetpack Compose. It will trigger the data
    load when the screen is created and then subscribe to `LiveData` from `ViewModel`,
    which will update the text on the screen when the data is loaded.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using Hilt for dependency injection, we will need to define our
    external dependencies in a module, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, we must provide the `OkHttp` client, which is used to make the HTTP requests.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will need to provide the JSON serialization:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are using the Moshi library for JSON serialization, so we will have to provide
    a Factory that will be used by Retrofit for JSON conversion.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to provide a Retrofit object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Retrofit object will need a base URL that will act as the host for our backend
    service, `OkHttpClient`, and the JSON converter factory, which were provided earlier.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will need to provide the template we defined previously:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we will use Retrofit to create an instance of `ConcreteDataService` that
    will be injected into `ConcreteDataRepository` by Hilt.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to initialize Hilt in the `Application` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code represents a 10-year jump in time when it comes to Android development.
    Going back to the questions we asked for the initial example in the Legacy analysis
    section, we can see that we answered quite a few. If we want to introduce persistence
    into the application, we now have a repository that can manage that for us. We
    also have a lot of classes that can be individually unit tested because of the
    introduction of Hilt and because we have delimited separated from the Android
    framework dependencies. We have also introduced flows, which allow us to manipulate
    and handle the data in case we need to connect to multiple sources and handle
    multi-threading more easily. The introduction of Kotlin and Retrofit also allowed
    us to reduce the amount of code. If we were to make a diagram of this, it would
    look as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码代表了 Android 开发在时间上10年的跳跃。回到我们在遗留分析部分提出的初始示例问题，我们可以看到我们回答了很多。如果我们想在应用中引入持久性，我们现在有一个可以为我们管理这一点的仓库。我们还拥有许多可以单独进行单元测试的类，因为
    Hilt 的引入以及我们将 Android 框架依赖项分离开来。我们还引入了流程，这允许我们在需要连接到多个源并更轻松地处理多线程时操纵和处理数据。Kotlin
    和 Retrofit 的引入也使我们能够减少代码量。如果我们绘制这个图，它看起来会如下所示：
- en: '![Figure 1.4 – A class diagram for a newer Android application'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 一个较新 Android 应用的类图'
- en: '](img/Figure_1.04_B18320.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 一个较新 Android 应用的类图](img/Figure_1.04_B18320.jpg)'
- en: Figure 1.4 – A class diagram for a newer Android application
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 一个较新 Android 应用的类图
- en: Here, we can see that the dependencies between the classes go from one direction
    to the other, which is another positive. The introduction of Retrofit saved us
    a lot of hassle when dealing with HTTP requests. But an issue remains with regards
    to how `ConcreteData` is handled. We can see that it travels from `ConcreteDataService`
    into `MainActivity`. Imagine if we wanted to provide the data from a different
    URL with a different POJO representation. This means that all of the classes will
    have to be changed to accommodate for this. This violates the single responsibility
    principle because the `ConcreteData` class is used to serve multiple actors in
    our application. In the next section, we will try to seek a solution to this problem
    and address ways to properly structure our classes and components.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到类之间的依赖关系是从一个方向到另一个方向，这是另一个积极的方面。Retrofit 的引入在处理 HTTP 请求时为我们节省了很多麻烦。但是，关于如何处理
    `ConcreteData` 的问题仍然存在。我们可以看到它从 `ConcreteDataService` 流向 `MainActivity`。想象一下，如果我们想从不同的
    URL 提供数据，并且使用不同的 POJO 表示，这意味着所有类都必须进行更改以适应这一点。这违反了单一职责原则，因为 `ConcreteData` 类被用来服务于我们应用中的多个角色。在下一节中，我们将尝试寻求解决这个问题的方法，并讨论如何正确地构建我们的类和组件。
- en: With that, we have explored the evolution of the Android platform and tools,
    what an application may look like using the latest tools and libraries, and how
    this evolution solved many problems developers had in the past. However, we still
    haven't solved all of them. In the next section, we will talk about the concept
    of clean architecture and how we can use it to make our application flexible and
    more adaptable to changes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以上内容，我们已经探讨了 Android 平台和工具的演变，使用最新工具和库的应用可能的样子，以及这种演变如何解决了开发者过去遇到的一些问题。然而，我们仍未解决所有问题。在下一节中，我们将讨论清洁架构的概念以及我们如何利用它使我们的应用更加灵活，并能更好地适应变化。
- en: Enter clean architecture
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入清洁架构
- en: In this section, we will discuss the concept of clean architecture, the problems
    it solves, and how it can be applied to an Android application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论清洁架构的概念、它解决的问题以及如何将其应用于 Android 应用。
- en: Architecture can be viewed as the high-level solution that's required to build
    a system that can solve business and technical requirements. The goal should be
    to keep as many options on the table for as long as we can. From an Android development
    perspective, we've seen the platform grow a lot, and to balance the new changes
    that have been added to the platform with the addition of new features for our
    application and its maintenance, we will need to give our application a very good
    foundation so that it will adapt to changes. A common approach to architecture
    in Android development was the layered architecture, where apps would be split
    into three layers – the user interface, domain, and data layers. The problem here
    was that the domain layer depended on the data layer, so when the data layer changed,
    the domain layer needed to change too.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 架构可以看作是构建一个能够解决业务和技术需求的高层次解决方案。目标应该是尽可能长时间地保留尽可能多的选项。从Android开发的角度来看，我们已经看到平台发展壮大，为了平衡平台新增的功能和我们的应用程序及其维护的新变化，我们需要为我们的应用程序提供一个非常好的基础，以便它能够适应变化。Android开发中架构的常见方法是将应用程序分为三个层次——用户界面、领域和数据层。这里的问题是领域层依赖于数据层，因此当数据层发生变化时，领域层也需要进行相应的更改。
- en: 'Clean architecture represents an integration of multiple types of architecture
    that provide independence from frameworks, user interfaces, and databases, as
    well as being testable. The shape resembles that of an onion, where dependencies
    go toward the inner layers. These layers are as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构代表了多种架构的集成，这些架构提供了对框架、用户界面和数据库的独立性，同时也能进行测试。其形状类似于洋葱，其中依赖关系指向内层。这些层如下：
- en: '**Entity Layer**: This layer is the innermost layer and is represented by objects
    that hold data or business-critical functions.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体层**：这一层是最内层，由持有数据或业务关键功能的对象表示。'
- en: '**Use Case Layer**: This layer implements the business logic of the system.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例层**：这一层实现了系统的业务逻辑。'
- en: '**Interface Adapter Layer**: This layer is responsible for converting the data
    between the frameworks and drivers and the use case. This will hold components
    such as ViewModels and presenters, as well as various converters that are responsible
    for converting network and persistence-related data into entities.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口适配层**：这一层负责在框架和驱动程序与用例之间转换数据。这一层将包含诸如ViewModels和演示者等组件，以及各种转换器，这些转换器负责将网络和持久性相关的数据转换为实体。'
- en: '**Frameworks and Drivers Layer**: This layer is the outermost layer and is
    comprised of components such as activities, fragments, networking components,
    and persistence components.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和驱动层**：这一层是最外层，由活动、片段、网络组件和持久性组件等组成。'
- en: 'Let''s consider a scenario: you''ve recently been hired by a start-up company
    as their first Android engineer. You have been given a basic idea of what the
    app that you''ve been asked to develop should do, but there isn''t anything too
    concrete; the user interface has not been finalized, the teams working on the
    backend are new themselves, and there isn''t anything too concrete on their side
    either. What you do know is a set of use cases that specify what the app does:
    log into a system, load a list of tasks and add new tasks, delete tasks, and edit
    existing tasks. The product owner tells you that you should work on something
    while using mock data so that they can get a feel of the product and consult with
    the user interface and user experience teams to discuss improvements and modifications.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景：你最近被一家初创公司雇佣为他们的首位Android工程师。你已经得到了一个关于你被要求开发的应用程序应该做什么的基本想法，但并没有什么具体的内容；用户界面尚未确定，负责后端的团队本身也是新手，他们那边也没有什么具体的内容。你所知道的是一组用例，这些用例指定了应用程序的功能：登录系统、加载任务列表并添加新任务、删除任务和编辑现有任务。产品负责人告诉你，你应该使用模拟数据来工作，这样他们可以感受到产品的感觉，并与用户界面和用户体验团队讨论改进和修改。
- en: 'You are faced with a choice here: you can build the product that''s been requested
    by the product owner as fast as possible and then constantly refactor your code
    for each new integration and the change in requirements, or you can take a little
    bit more time and factor in the future changes that will come into your approach.
    If you were to take the first approach, then you would find yourself in a situation
    where many developers found themselves, which is to go back and change things
    properly. Let''s assume you chose the second approach. What would you need to
    do then? You can start decoupling your code into separate layers. You know that
    the UI will change, so you will need to keep it isolated so that when it is changed,
    the change will only be isolated to that particular section. Often, the UI is
    referred to as the presentation layer.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Next, you want to decouple the business logic. This is something specific to
    processing the data that your app will use. This is often done in the domain layer.
    Finally, you want to decouple how the data is loaded and stored. This will be
    the part where you deal with integrating libraries such as Room and Retrofit and
    it's often called the data layer. Because the requirements aren't definitive yet,
    you also want to decouple how you want to handle use cases so that if a use case
    changes, you can protect the others from that change. If you were to rotate the
    class diagram from *Figure 1.4*, you would see a layered approach to this example.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As we've mentioned previously, the fact that `ConcreteData` shows up in all
    the classes in our example is not a good idea. This is because, at the end of
    the day, the fact that we chose Retrofit and Moshi shouldn't impact the rest of
    the application. This is similar if it was the opposite way around and the activity
    or `ViewModel` would've done the same. At the end of the day, the way we choose
    to implement our UI or what networking library we should use represent details.
    Our domain layer shouldn't be impacted by any of these choices.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: What we are doing here is establishing boundaries between the components in
    our system so that a change in a component doesn't impact a change in another
    component. In Android, even if we use the latest libraries and frameworks, we
    should still make sure that our domain is still protected by changes in those
    frameworks. Going back to the start-up example, and assuming you've chosen to
    decouple your components and pick the appropriate boundaries, after many demos
    and iterations, your company decides to hire additional developers to work on
    new, separate features. If those developers follow the guidelines you've set up,
    they can work with a minimal level of overlap.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The recommendation from Android development documentation is to take advantage
    of modules. One of the arguments is that it improves build speed because when
    you work on a certain module, it won't rebuild the others when you build the application
    – it caches them instead. Splitting your application into multiple modules serves
    another purpose.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the start-up. Things are going great and people love your product,
    so your company decides to open your APIs for other businesses to integrate into
    their systems. Your company also wants to provide an Android library so that it's
    easier for businesses to access your APIs. You already have this logic integrated
    into your application; you just need to export it. What features do you want to
    export? All? None? Do they want to persist data locally? Do they want some of
    the UI or not? If your modules were split with proper boundaries, then you would
    be able to accommodate all of those features. What we want to do is have a system
    where we can easily plug things in and easily plug them out.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitioning our previous example to this approach, we would have something
    like this. The `ConcreteData` class and `ConcreteDataService` would remain the
    same:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will need to isolate the Retrofit library and create the interface
    adapter for it. But to do that, we will need to define our entity:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It looks like it's a duplicate of `ConcreteData`, but this is a case of fake
    duplication. In reality, as things evolve, the two classes may contain different
    data, so they will need to be separated.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'To isolate the Retrofit call, we need to invert the dependency of our repository.
    So, let''s create a new interface that will return `ConcreteEntity`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our implementation, we will invoke the Retrofit service interface:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have invoked `ConcreteDataService` and then converted the network model
    into an entity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our repository will change into the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ConcreteDataRepository` will depend on `ConcreteDataSource` to avoid the dependencies
    on the networking layer.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to build the use case to retrieve `ConcreteEntity`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`ConcreteDataUseCase` will depend on `ConcreteDataRepository` to retrieve the
    data and emit it using Kotlin flows.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `MainViewModel` will need to be changed to invoke the use case. To do
    so, it will use the `field1` object from `ConcreteEntity`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`MainViewModel` will now depend on `ConcreteDataUseCase` and retrieve `ConcreteEntity`,
    where it will extract `field1`. This will then be set in `LiveData`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`MainActivity` will be updated to use the `textData` object from `MainViewModel`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, `MainActivity` has been updated to use `LiveData`, which emits a
    `String` instead of a `ConcreteData` object.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the Hilt module will be updated as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we can see that `ConcreteDataUseCase` just invokes `ConcreteDataRepository`,
    which just invokes `ConcreteDataSource`. You may be wondering why this boilerplate
    is necessary. In this case, we have a bit of fake duplication. As the code grows,
    `ConcreteDataRepository` may connect to other data sources, and `ConcreteDataUseCase`
    may need to connect to multiple repositories to combine the data. The same can
    be said about `ConcreteData` and `ConcreteEntity`. Another benefit of this approach
    is the imposition of more rigor when it comes to development, and it creates consistency.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram and see how it compares to *Figure 1.4*:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Clean architecture'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.05_B18320.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Clean architecture
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the top row, we will see the use case and the entity. We can also
    see that the dependencies go from the classes at the bottom toward the classes
    at the top, similar to how the dependencies go from the outer layers toward the
    inner layers here. A difference you may have noticed is that our example doesn't
    mention the usage of modules. Later in this book, we will explore how to apply
    clean architecture to multiple modules and how to manage them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We are now back in the start-up, and you started working on the application,
    where you have defined a few entities and use cases and have put a simple UI in
    place. The product owner has asked you to deliver a demo with some mock data for
    tomorrow. What can you do? You can create a new implementation of your data source
    and plug in some mock objects that you can use to satisfy the conditions for the
    demo. You show the demo of the application and you receive some feedback about
    your UI. This means you can change your activities and fragments to render the
    data appropriately, and this won't impact any of the other components. What would
    happen if the use case were to change? In that situation, this would propagate
    into the rest of the other layers. This depends on the change, though, but this
    scenario is to be expected in this situation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored what an Android app used to look like and all the
    problems developers would face at the time. We've looked at some of the most important
    software design principles, such as SOLID, to get a better understanding of how
    to improve our code and how these principles helped the Android platform evolve.
    We also looked at the adoption of a new programming language that came with the
    introduction of new software paradigms, the addition of event-based libraries
    and frameworks, the introduction of architecture components to help developers
    write more testable applications, and a new way to build user interfaces. Finally,
    we introduced clean architecture, which helps us build maintainable, testable,
    and more independent applications. We looked at all of these changes through a
    small example, where we saw them transition from what they may have looked like
    in 2010 to what they may look like now.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into the libraries that are required
    for loading, storing, and managing data on Android. We will combine them to build
    an app using clean architecture.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨在Android上加载、存储和管理数据的库。我们将结合它们使用干净的架构来构建一个应用程序。
