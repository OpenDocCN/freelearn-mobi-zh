- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Persisting Data Locally and Doing Background Work
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地持久化数据和执行后台工作
- en: To provide better user experiences, we must ensure that apps don’t fetch data
    every time the user opens the app. At times, the user can be in areas that do
    not have internet access, and this can be very frustrating when the user can’t
    use your app in such situations. For such scenarios, we have to store data locally.
    We also have to store and update the data in an efficient way that doesn’t drain
    the device’s battery or block the user from doing other things on the app. In
    this chapter, we will be exploring how to do so for our apps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的用户体验，我们必须确保应用在用户每次打开应用时不要每次都获取数据。有时，用户可能处于没有互联网接入的地区，当用户在这种情况下无法使用您的应用时，这可能会非常令人沮丧。对于此类场景，我们必须本地存储数据。我们还必须以高效的方式存储和更新数据，这样不会耗尽设备的电池或阻止用户在应用上做其他事情。在本章中，我们将探讨如何为我们的应用做到这一点。
- en: In this chapter, we will learn how to save data to a local database, **Room**,
    which is part of the Jetpack libraries. We will be able to save items and read
    from the Room database. Additionally, we will learn how to do long-running operations
    using **WorkManager** and some of the best practices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何将数据保存到本地数据库 **Room** 中，这是 Jetpack 库的一部分。我们将能够保存条目并从 Room 数据库中读取。此外，我们还将学习如何使用
    **WorkManager** 执行长时间运行的操作以及一些最佳实践。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Saving and reading data from a local database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地数据库保存和读取数据
- en: Handling updates and migrations in the Room database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 Room 数据库中的更新和迁移
- en: Using WorkManager to schedule background tasks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 WorkManager 安排后台任务
- en: Testing your workers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的工作者
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本 ([https://developer.android.com/studio](https://developer.android.com/studio))。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在 [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chaptereight)
    找到本章的代码。
- en: Saving and reading data from a local database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从本地数据库保存和读取数据
- en: We are going to build up on the Pets app, which displays a list of cute cats.
    We will save our cute cats in a local database, Room, which is a part of the Android
    Jetpack libraries and provides a wrapper and abstraction layer over SQLite. We
    will also use the `ViewModel`. The Room database provides an abstraction layer
    over SQLite to allow fluent database access while harnessing the full power of
    SQLite. It also has inbuilt support for Kotlin coroutines and flows to allow for
    asynchronous database access. Room is also compile-time safe and hence any errors
    in SQL queries are caught at compile time. It allows us to do all this with concise
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于宠物应用进行构建，该应用显示可爱猫的列表。我们将把我们的可爱猫保存在本地数据库 Room 中，Room 是 Android Jetpack 库的一部分，它为
    SQLite 提供了一个包装和抽象层。我们还将使用 `ViewModel`。Room 数据库在 SQLite 上提供了一个抽象层，允许流畅的数据库访问，同时充分利用
    SQLite 的全部功能。它还内置了对 Kotlin 协程和流的支撑，以允许异步数据库访问。Room 还在编译时是安全的，因此 SQL 查询中的任何错误都会在编译时被捕获。它允许我们用简洁的代码完成所有这些。
- en: 'To use Room in our project, we need to add its dependency to our `libs.versions.toml`
    file. Let us start by defining the Room version in the `versions` section as the
    following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的项目中使用 Room，我们需要将其依赖项添加到我们的 `libs.versions.toml` 文件中。让我们首先在 `versions` 部分定义
    Room 版本，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let us add the dependencies in our `libraries` section:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的 `libraries` 部分添加依赖项：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sync the project for the changes to be added. Before we add these dependencies
    to the app level `build.gradle.kts` file, we need to set up an annotation processor
    for the room compiler. Room uses the `build.gradle.kts` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 同步项目以便添加更改。在我们将这些依赖项添加到应用级别的 `build.gradle.kts` 文件之前，我们需要为 Room 编译器设置一个注解处理器。Room
    使用 `build.gradle.kts` 文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have added the `build.gradle.kts` file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了 `build.gradle.kts` 文件：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This allows us to use KSP in our app module. To finalize setting up Room, now
    let us add the dependencies we declared earlier to the app level `build.gradle.kts`
    file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在我们的应用模块中使用KSP。为了最终设置Room，现在让我们将我们之前声明的依赖项添加到应用级别的`build.gradle.kts`文件中：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have added our Room dependencies and the Room KTX library with the `implementation`
    configuration and the Room compiler with the `ksp` configuration. We are now ready
    to start using Room in our project. Let us start by creating an entity class for
    our `Cat` object. This will be the data class that will be used to store our pets
    in the database. Inside the `data` package, create a new file called `CatEntity.kt`
    and add the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了我们的房间依赖和Room KTX库，使用`implementation`配置以及Room编译器使用`ksp`配置。我们现在可以开始在我们的项目中使用Room了。让我们先为我们的`Cat`对象创建一个实体类。这将是一个数据类，用于在数据库中存储我们的宠物。在`data`包内，创建一个名为`CatEntity.kt`的新文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This data class represents the Room table for our cats. The `@Entity` annotation
    is used to define the table for our cats. We have passed the `tableName` value
    to specify the name of our table. The `@PrimaryKey` annotation is used to define
    the `tags`, which is a list of strings. Room provides functionality to save non-primitive
    types using the `@TypeConverter` annotation. Let us create a new file named `PetsTypeConverters.kt`
    and add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据类代表了我们猫的Room表。`@Entity`注解用于定义我们的猫的表。我们传递了`tableName`值来指定我们的表名。`@PrimaryKey`注解用于定义`tags`，它是一个字符串列表。Room提供了使用`@TypeConverter`注解保存非原始类型的功能。让我们创建一个名为`PetsTypeConverters.kt`的新文件，并添加以下代码：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This class has two functions annotated with the `@TypeConverter` annotation.
    The first function converts a list of strings to a string. The second function
    converts a string to a list of strings. We have used the Kotlinx serialization
    library to convert the list of strings to a string and vice versa. This class
    will be referenced in our database class that we will create shortly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个函数被`@TypeConverter`注解标记。第一个函数将字符串列表转换为字符串。第二个函数将字符串转换为字符串列表。我们使用了Kotlinx序列化库将字符串列表转换为字符串，反之亦然。这个类将在我们即将创建的数据库类中引用。
- en: 'We are now ready to create our database. We need to create a `data` package,
    create a new file called `CatDao.kt` and add the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建我们的数据库。我们需要创建一个`data`包，创建一个名为`CatDao.kt`的新文件，并添加以下代码：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The interface is annotated with the `@Dao` annotation to tell Room that we will
    use this class as our DAO. We have defined two functions in our DAO. The `insert`
    function is used to insert a cat into our database. Notice that this is a `suspend`
    function. This is because we will be using coroutines to insert the cats into
    our database. Inserting items into the database needs to happen on a background
    thread since it is a resource-intensive operation. We also use the `@Insert` annotation
    with the `onConflict` parameter set to `OnConflictStrategy.REPLACE`. This tells
    Room to replace the cat if it already exists in the database. The `getCats` function
    is used to get all the cats from our database. It has the `@Query` annotation,
    which is used to define a query to get the cats from our database. We are using
    `Flow` to return the cats from our database. `Flow` is a stream of data that can
    be observed. This means that every time we update the database, the changes will
    be emitted to the view layers immediately without us doing any extra work. Cool,
    right?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接口被`@Dao`注解标记，以告诉Room我们将使用这个类作为我们的DAO。我们在DAO中定义了两个函数。`insert`函数用于将猫插入到我们的数据库中。请注意，这是一个`suspend`函数。这是因为我们将使用协程将猫插入到我们的数据库中。由于插入数据库是一个资源密集型操作，需要在后台线程上执行。我们还使用`@Insert`注解，并将`onConflict`参数设置为`OnConflictStrategy.REPLACE`。这告诉Room如果猫已经在数据库中存在，则替换它。`getCats`函数用于从我们的数据库中获取所有猫。它有一个`@Query`注解，用于定义一个查询以从我们的数据库中获取猫。我们使用`Flow`从数据库返回猫。`Flow`是一个可观察的数据流。这意味着每次我们更新数据库时，更改将立即发送到视图层，而无需我们做任何额外的工作。酷，对吧？
- en: 'We now need to create our database class. Inside the `data` package, create
    a new file called `CatDatabase.kt` and add the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建我们的数据库类。在`data`包内，创建一个名为`CatDatabase.kt`的新文件，并添加以下代码：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We have defined an abstract class that extends the `RoomDatabase` class. We
    passed the `entities` parameter to specify the entities or tables stored in our
    database. We have also passed the `version` parameter to specify the version of
    our database. We have used the `@TypeConverters` annotation to specify the type
    converters that we will be using in our database. We have also defined an abstract
    method that returns our `CatDao`. We need to provide an instance of the database
    to classes that need it. We will do this by using the dependency injection pattern
    we have been using in our project. Let us head over to the `di` package and in
    the `Module.kt` file, add the Room dependency just below the Retrofit dependency:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个继承自`RoomDatabase`类的抽象类。我们传递了`entities`参数来指定我们数据库中存储的实体或表。我们还传递了`version`参数来指定我们数据库的版本。我们使用了`@TypeConverters`注解来指定我们将在数据库中使用的类型转换器。我们还定义了一个返回我们的`CatDao`的抽象方法。我们需要为需要它的类提供一个数据库实例。我们将通过使用我们在项目中一直在使用的依赖注入模式来完成此操作。让我们转到`di`包，并在`Module.kt`文件中，在Retrofit依赖项下方添加Room依赖项：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we have created a single instance of our database. We have used the `databaseBuilder`
    method to create our database. We have passed the `androidContext()` method from
    Koin to get the context of our application. We have also passed `CatDatabase::class.java`
    to specify the class of our database. We have also passed the `name` of our database.
    We have then created a single instance of our `CatDao`. We are using the `get`
    method to get the instance of our database and then calling the `catDao` function
    to get our `CatDao`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了我们数据库的单个实例。我们使用了`databaseBuilder`方法来创建我们的数据库。我们传递了来自Koin的`androidContext()`方法以获取我们应用程序的上下文。我们还传递了`CatDatabase::class.java`来指定我们数据库的类。我们还传递了数据库的`name`。然后我们创建了一个`CatDao`的单个实例。我们使用`get`方法获取我们数据库的实例，然后调用`catDao`函数来获取我们的`CatDao`。
- en: 'Our database is now ready to be used in our repository. We are going to modify
    `PetRepository` and its implementation to be able to do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库名现已经准备好在我们的存储库中使用。我们将修改`PetRepository`及其实现，以便能够执行以下操作：
- en: Save items to our database
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目保存到我们的数据库
- en: Read items from our database
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从我们的数据库读取项目
- en: Change our `getPets()` function to return a `Flow` of pets
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的`getPets()`函数修改为返回一个宠物`Flow`
- en: 'The modified `PetRepository.kt` file should look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`PetRepository.kt`文件应如下所示：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have modified the `getPets` function to return a `Flow` of pets. Room does
    not allow database access on the main thread, therefore, our queries have to be
    asynchronous. Room provides support for observable queries that read data from
    our database every time data in our database changes and emits new values to reflect
    the changes. This is the reason we return a `Flow` instance type from the `getPets`
    function. We have also added the `fetchRemotePets` function to fetch the pets
    from the remote data source. Let us now modify `PetRepositoryImpl.kt` with a few
    changes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了`getPets`函数，使其返回一个宠物`Flow`。Room不允许在主线程上访问数据库，因此，我们的查询必须是异步的。Room提供了对可观察查询的支持，每次数据库中的数据发生变化时，它都会从我们的数据库中读取数据并发出新值以反映这些变化。这就是为什么我们从`getPets`函数返回`Flow`实例类型的原因。我们还添加了`fetchRemotePets`函数来从远程数据源获取宠物。现在让我们修改`PetRepositoryImpl.kt`文件，进行一些更改：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have made the following changes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行了以下更改：
- en: We have added the `catDao` property to the constructor of the class.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在类的构造函数中添加了`catDao`属性。
- en: We have modified the `getPets` function to return a `Flow` of pets. Additionally,
    we have added a `map` operator to map `CatEntity` to a `Cat` object. We have also
    added an `onEach` operator to check if the list of pets is empty. If it is empty,
    we call the `fetchRemotePets` function to fetch the pets from the remote data
    source. This provides an **offline first experience** to our users; that is, we
    first check if we have the data in our database and if we don’t, we fetch it from
    the remote data source.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经修改了`getPets`函数，使其返回一个宠物`Flow`。此外，我们还添加了一个`map`操作符，将`CatEntity`映射到`Cat`对象。我们还添加了一个`onEach`操作符来检查宠物列表是否为空。如果为空，我们将调用`fetchRemotePets`函数从远程数据源获取宠物。这为我们的用户提供了一个**离线优先体验**；也就是说，我们首先检查我们数据库中是否有数据，如果没有，我们就从远程数据源获取它。
- en: Lastly, we have modified the `fetchRemotePets` function that fetches the pets
    from the remote data source. When the response is successful, we map the response
    to a `CatEntity` instance type and insert it into our database.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们修改了从远程数据源获取宠物的 `fetchRemotePets` 函数。当响应成功时，我们将响应映射到 `CatEntity` 实例类型，并将其插入到我们的数据库中。
- en: 'We need to update the `PetsRepository` dependency in our `Module.kt` file to
    add the `CatDao` dependency:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `Module.kt` 文件中更新 `PetsRepository` 依赖项以添加 `CatDao` 依赖项：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our `PetsRepositoryImpl` class, we have been able to read and fetch data
    from the Room database. Next, we are going to modify the `getPets()` function
    in `PetsViewModel` to accommodate these new changes. Head over to the `PetsViewModel.kt`
    file and modify the `getPets()` function to look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `PetsRepositoryImpl` 类中，我们已经能够从 Room 数据库中读取和获取数据。接下来，我们将修改 `PetsViewModel`
    中的 `getPets()` 函数以适应这些新变化。前往 `PetsViewModel.kt` 文件并修改 `getPets()` 函数，使其看起来如下：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We have made a few minor changes. We have used the `asResult()` extension function
    to convert the `Flow` of pets to a `Flow` of `NetworkResult`. This is because
    we are now returning a `Flow` of pets from our repository. The rest of the code
    remains the same as before. We will get an error since we have not created the
    `asResult()` extension function. Let us create it in our `NetworkResult.kt` file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一些小的修改。我们使用了 `asResult()` 扩展函数将宠物的 `Flow` 转换为 `NetworkResult` 的 `Flow`。这是因为我们现在从我们的仓库返回宠物的
    `Flow`。其余的代码与之前相同。我们会得到一个错误，因为我们还没有创建 `asResult()` 扩展函数。让我们在我们的 `NetworkResult.kt`
    文件中创建它：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is an extension function on the `Flow` class. It maps a `Flow` of items
    to the `NetworkResult` class. We can now head back to our `PetsViewModel` class
    and add the extension function imports to resolve the error.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `Flow` 类的扩展函数。它将项目的 `Flow` 映射到 `NetworkResult` 类。现在我们可以回到我们的 `PetsViewModel`
    类，并添加扩展函数导入以解决错误。
- en: 'The last change we need to make is to provide the application context to our
    Koin instance in the `Application` class. Head over to the `ChapterEightApplication.kt`
    file and modify the `startKoin` block to the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一个更改是在 `Application` 类中向我们的 Koin 实例提供应用程序上下文。前往 `ChapterEightApplication.kt`
    文件并修改 `startKoin` 块如下：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have provided the application context to our Koin instance. Now, we can run
    the app. You should see the list of cute cats.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将应用程序上下文提供给我们的 Koin 实例。现在，我们可以运行应用程序。你应该能看到可爱猫咪的列表。
- en: '![Figure 8.1 – Cute cats](img/B19779_08_01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 可爱的猫咪](img/B19779_08_01.jpg)'
- en: Figure 8.1 – Cute cats
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 可爱的猫咪
- en: The app still works as before, but now we are reading items from the Room database.
    If you turn off your data and Wi-Fi, the app still shows the list of cute cats!
    Amazing, isn’t it? We have been able to make the app work offline. One of the
    benefits of having an architecture in place for our app is that we can change
    the different layers without necessarily affecting the other layers. We have been
    able to change the data source from the remote data source to the local data source
    without affecting the view layer. This is the power of having a good architecture
    in place.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仍然像以前一样工作，但现在我们从 Room 数据库中读取项目。如果你关闭数据和 Wi-Fi，应用程序仍然显示可爱猫咪的列表！令人惊讶，不是吗？我们已经能够使应用程序离线工作。拥有良好架构的应用程序的一个好处是，我们可以更改不同的层，而无需必然影响其他层。我们已经能够将数据源从远程数据源更改为本地数据源，而不会影响视图层。这就是拥有良好架构的力量。
- en: We know how to insert and read data from our Room database, but what about updating
    it? In the next section, we will learn how to update the data that is in our Room
    database. In the process, we will also learn how to migrate from one database
    version to the other using the Room **automated** **migration** feature.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何从 Room 数据库中插入和读取数据，但更新数据怎么办？在下一节中，我们将学习如何更新 Room 数据库中的数据。在这个过程中，我们还将学习如何使用
    Room 的**自动****迁移**功能从一个数据库版本迁移到另一个版本。
- en: Handling updates and migrations in the Room database
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Room 数据库的更新和迁移
- en: '`FavoritePetsScreen` doesn’t have any functionality yet. We are going to add
    the functionality to favorite pets and update this information in the Room database.
    To achieve this, we need to do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`FavoritePetsScreen` 目前没有任何功能。我们将添加收藏宠物的功能，并在 Room 数据库中更新此信息。为了实现这一点，我们需要做以下事情：'
- en: Set up a Room schema directory.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Room 模式目录。
- en: Add a new column to our `CatEntity` class to store the favorite status of the
    cat.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的 `CatEntity` 类中添加一个新列以存储猫咪的收藏状态。
- en: Add a new function to `CatDao` to update the favorite status of the cat.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 `CatDao` 添加一个新功能以更新猫的收藏状态。
- en: Update our UIs with a favorite icon and, once clicked, update the favorite status
    of the cat. This means the ViewModel and repository classes will also be updated
    in the process.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用收藏图标更新我们的 UI，一旦点击，就会更新猫的收藏状态。这意味着 ViewModel 和仓库类在过程中也会被更新。
- en: 'Let’s get started with the steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始以下步骤：
- en: 'Let us start by setting up the schema directory. In our app level `build.gradle.kts`
    file, add the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先设置模式目录。在我们的应用级别的 `build.gradle.kts` 文件中，添加以下代码：
- en: '[PRE16]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Do a Gradle sync and then build the project. This generates a `schema json`
    file with the name of the current database version as shown in the following figure:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 Gradle 同步然后构建项目。这将生成一个名为当前数据库版本的 `schema json` 文件，如下所示图所示：
- en: '![Figure 8.2 – Room schema directory](img/B19779_08_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Room 模式目录](img/B19779_08_02.jpg)'
- en: Figure 8.2 – Room schema directory
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Room 模式目录
- en: As shown in the preceding image, you have to switch to the `CatEntity` interface
    to store the favorite status of the cat.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，你必须切换到 `CatEntity` 接口来存储猫的收藏状态。
- en: 'We will add this field to the `CatEntity` and the `Cat` data classes. Head
    over to the `CatEntity.kt` file and add a new field called `isFavorite`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把这个字段添加到 `CatEntity` 和 `Cat` 数据类中。转到 `CatEntity.kt` 文件并添加一个名为 `isFavorite`
    的新字段：
- en: '[PRE17]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a Boolean whose default value is `false`. We have used the `@ColumnInfo`
    annotation to specify the default value of the column in our database, too. We
    will use this field to store the favorite status of the cat. Ensure you add the
    `val isFavorite: Boolean = false` field to the `Cat` data class, too. We now need
    to update our `CatDao` class to be able to update the favorite status of the cat.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '这是一个默认值为 `false` 的布尔值。我们也使用了 `@ColumnInfo` 注解来指定我们数据库中列的默认值。我们将使用这个字段来存储猫的收藏状态。确保你也在
    `Cat` 数据类中添加了 `val isFavorite: Boolean = false` 字段。我们现在需要更新我们的 `CatDao` 类以能够更新猫的收藏状态。'
- en: 'Let us head over to the `CatDao.kt` file and add the following functions:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `CatDao.kt` 文件并添加以下功能：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have two functions here. The first function will be used to update the favorite
    status of the cat. We have used the `@Update` annotation to tell Room that this
    function will be used to update the `CatEntity` class in our database. The second
    function will be used to get the favorite cats from our database. We have used
    the `@Query` annotation to define the query to get the favorite cats from our
    database. We have used `Flow` to return the favorite cats from our database. Now,
    we need to add a migration to our database to add the new column to our database.
    This ensures that we don’t lose any data when we update our database. `CatDatabase`
    to add `autoMigration` as follows:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有两个函数。第一个函数将用于更新猫的收藏状态。我们使用了 `@Update` 注解来告诉 Room 这个函数将用于更新我们数据库中的 `CatEntity`
    类。第二个函数将用于从我们的数据库中获取收藏的猫。我们使用了 `@Query` 注解来定义从我们的数据库中获取收藏猫的查询。我们使用了 `Flow` 来从我们的数据库中返回收藏的猫。现在，我们需要向我们的数据库添加一个迁移来添加新的列，这确保了在更新我们的数据库时不会丢失任何数据。向
    `CatDatabase` 添加 `autoMigration` 如下：
- en: '[PRE19]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have added the `autoMigrations` parameter to our database. We have passed
    a list of `AutoMigration` objects to the parameter. We have passed the `from`
    and `to` parameters to specify the version of our database. Ensure you add the
    imports for the `AutoMigration` class. Notice that we have also increased the
    `version` of our database. This is because we have added a new column to our database.
    Build the project to be able to generate the `schema json` file. You should see
    a new schema JSON file with the name of the new database version. Our schema directory
    should look like the following:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经向我们的数据库添加了 `autoMigrations` 参数。我们向参数传递了一个 `AutoMigration` 对象的列表。我们传递了 `from`
    和 `to` 参数来指定我们数据库的版本。确保你添加了 `AutoMigration` 类的导入。注意，我们还将我们数据库的 `version` 提高了。这是因为我们向数据库添加了一个新列。构建项目以生成
    `schema json` 文件。你应该会看到一个名为新数据库版本的新 schema JSON 文件。我们的模式目录应该看起来像以下这样：
- en: '![Figure 8.3 – Updated Room schema directory](img/B19779_08_03.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 更新的 Room 模式目录](img/B19779_08_03.jpg)'
- en: Figure 8.3 – Updated Room schema directory
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 更新的 Room 模式目录
- en: If we open the `2.json` file, we will notice that the new `isFavorite` column
    has been added to our table. That it’s for automated migration. We are now ready
    to update our repository to be able to update the favorite status of the cat.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 `2.json` 文件，我们会注意到新添加了 `isFavorite` 列到我们的表中。这是为了自动化迁移。我们现在可以更新我们的仓库以能够更新猫的喜欢状态。
- en: 'Let us head over to the `PetsRepository.kt` file and add the following functions:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `PetsRepository.kt` 文件，并添加以下函数：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `updatePet(cat: Cat)` and `getFavoritePets()` functions will be used to
    update the favorite status of the cat and get favorite cats.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePet(cat: Cat)` 和 `getFavoritePets()` 函数将用于更新猫的喜欢状态和获取喜欢的猫。'
- en: 'Let us add the implementation of the two functions in our `PetsRepositoryImpl.kt`
    class:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `PetsRepositoryImpl.kt` 类中添加这两个函数的实现：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is an explanation of the functions:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是这些函数的解释：
- en: In the `updatePet` function, we have used the update method of our `CatDao`
    interface to update the favorite status of the cat. We have also used `withContext`
    to ensure that the update runs on a background thread. We have created a new `CatEntity`
    class from the `Cat` object that we have passed to the function.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `updatePet` 函数中，我们使用了 `CatDao` 接口中的更新方法来更新猫的喜欢状态。我们还使用了 `withContext` 来确保更新在后台线程上运行。我们根据传递给函数的
    `Cat` 对象创建了一个新的 `CatEntity` 类。
- en: In the `getFavoritePets` function, we have used the `getFavoriteCats` function
    from our `CatDao` interface to get the favorite cats from our database. We have
    also mapped the list of `CatEntity` to a list of `Cat`. We then returned a `Flow`
    instance type of favorite cats.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `getFavoritePets` 函数中，我们使用了 `CatDao` 接口中的 `getFavoriteCats` 函数从我们的数据库中获取喜欢的猫。我们还把
    `CatEntity` 列表映射到了 `Cat` 列表中。然后我们返回了一个类型为 `Flow` 的喜欢的猫的实例。
- en: 'In the `PetsRepositoryImpl.kt` file, we need to update the `fetchRemotePets`
    and `getPets` functions to update the favorite status of the cat as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PetsRepositoryImpl.kt` 文件中，我们需要更新 `fetchRemotePets` 和 `getPets` 函数以更新猫的喜欢状态，如下所示：
- en: '[PRE22]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We add the `isFavorite` parameter to the `Cat` object when we are mapping the
    `CatEntity` class to a `Cat`. This will ensure that we have the favorite status
    of the cat when we are fetching the cats from the remote and local data sources.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们将 `CatEntity` 类映射到 `Cat` 对象时，我们添加了 `isFavorite` 参数。这将确保我们在从远程和本地数据源获取猫时，有猫的喜欢状态。
- en: 'Let us head over to the `PetsViewModel` class and add the following variables
    below the `petsUIState` variable:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `PetsViewModel` 类，并在 `petsUIState` 变量下方添加以下变量：
- en: '[PRE23]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have created a private `MutableStateFlow` of favorite cats and a public
    `StateFlow` of favorite cats. We will use the `_favoritePets` variable to update
    the favorite cats and the `favoritePets` variable to observe the favorite cats.
    This pattern is normally recommended to prevent exposing mutable states to the
    view layer.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个私有的 `MutableStateFlow` 喜欢的猫和一个公共的 `StateFlow` 喜欢的猫。我们将使用 `_favoritePets`
    变量来更新喜欢的猫，并使用 `favoritePets` 变量来观察喜欢的猫。这种模式通常建议用于防止将可变状态暴露给视图层。
- en: 'Next, let us add these two functions below the `getPets()` function in the
    `PetsViewModel`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `PetsViewModel` 中的 `getPets()` 函数下方添加这两个函数：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `updatePet` function will be called from the UI to update the favorite status
    of the cat. The `getFavoritePets` function will be called from the UI to fetch
    the favorite cats from our database. We collect the favorite cats from our database
    and update the `_favoritePets` variable. With these changes, we are now ready
    to make changes to our views to be able to favorite a cat and see a list of favorite
    pets.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`updatePet` 函数将从 UI 中调用以更新猫的喜欢状态。`getFavoritePets` 函数将从 UI 中调用以从我们的数据库中获取喜欢的猫。我们从数据库中收集喜欢的猫并更新
    `_favoritePets` 变量。有了这些更改，我们现在可以更改我们的视图，以便能够喜欢一只猫并查看喜欢的宠物列表。'
- en: 'We will start by adding our favorite icon to the `PetListItem` composable.
    Let us head over to the `PetList.kt` file and update the `PetListItem` composable
    to be the following:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先将我们的喜欢图标添加到 `PetListItem` 组合组件中。让我们转到 `PetList.kt` 文件，并更新 `PetListItem`
    组合组件如下：
- en: '[PRE25]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have added the `Icon` composable to the `PetListItem` composable. We have
    used the `Icons.Default.Favorite` icon if the cat is favorited and the `Icons.Default.FavoriteBorder`
    icon if the cat is not favorited. We have also used the `tint` parameter to change
    the color of the icon depending on the favorite status of the cat. `Icon` is now
    inside a `Row` together with `FlowRow`, which displays a list of tags. We have
    also added the `onFavoriteClicked` parameter to the `PetListItem` composable.
    We have used this parameter to update the favorite status of the cat.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在 `PetListItem` 组合器中添加了 `Icon` 组合器。如果猫被收藏，我们使用 `Icons.Default.Favorite` 图标，如果没有收藏，我们使用
    `Icons.Default.FavoriteBorder` 图标。我们还使用了 `tint` 参数来根据猫的收藏状态改变图标的颜色。`Icon` 现在在
    `Row` 中，与 `FlowRow` 一起显示标签列表。我们还向 `PetListItem` 组合器添加了 `onFavoriteClicked` 参数。我们使用此参数更新猫的收藏状态。
- en: 'Let us update the `PetList` composable to add a new callback parameter called
    `onFavoriteClicked` and pass the parameter to the `PetListItem` composable:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新 `PetList` 组合器，添加一个名为 `onFavoriteClicked` 的新回调参数，并将该参数传递给 `PetListItem`
    组合器：
- en: '[PRE26]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will add the `onFavoriteClicked` callback as a parameter to the `PetsScreenContent`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `onFavoriteClicked` 回调作为 `PetsScreenContent` 的参数：
- en: '[PRE27]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now pass the parameter to the `PetList` composable:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将参数传递给 `PetList` 组合器：
- en: '[PRE28]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let us update the `PetAndDetails` composable to add the `onFavoriteClicked`
    parameter:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新 `PetAndDetails` 组合器，添加 `onFavoriteClicked` 参数：
- en: '[PRE29]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can now pass the parameter to the `PetList` composable:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以将参数传递给 `PetList` 组合器：
- en: '[PRE30]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Back in the `PetsScreenContent.kt` file, we need to pass the `onFavoriteClicked`
    parameter to the `PetListAndDetails` composable:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `PetsScreenContent.kt` 文件，我们需要将 `onFavoriteClicked` 参数传递给 `PetListAndDetails`
    组合器：
- en: '[PRE31]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The final `PetScreenContent.kt` file with all the changes we have made so far
    should look like this:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们已做的所有更改的最终 `PetScreenContent.kt` 文件应该看起来像这样：
- en: '![Figure 8.4 – Updated PetscreenContent](img/B19779_08_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 更新的 PetscreenContent](img/B19779_08_04.jpg)'
- en: Figure 8.4 – Updated PetscreenContent
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 更新的 PetscreenContent
- en: 'Next, in the `PetsScreen` composable, which is in the `PetsScreen.kt` file,
    we need to add the `onFavoriteClicked` parameter to the `PetsScreenContent` composable:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `PetsScreen.kt` 文件中的 `PetsScreen` 组合器中，我们需要将 `onFavoriteClicked` 参数添加到
    `PetsScreenContent` 组合器中：
- en: '[PRE32]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We have passed the `onFavoriteClicked` callback to the `PetsScreenContent`
    composable. We have called the `updatePet` method of our `PetsViewModel` class
    with the updated cat object. Let us run the app; it now has a new favorite icon.
    If we click on the icon, the icon changes to a filled heart icon with a red color:'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经将 `onFavoriteClicked` 回调传递给了 `PetsScreenContent` 组合器。我们用更新后的猫对象调用了我们的 `PetsViewModel`
    类的 `updatePet` 方法。让我们运行应用；现在它有一个新的收藏图标。如果我们点击图标，图标会变成一个红色的实心心形图标：
- en: '![Figure 8.5 – Cute cats with favorite](img/B19779_08_05.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 憨态可爱好猫与收藏](img/B19779_08_05.jpg)'
- en: Figure 8.5 – Cute cats with favorite
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 憨态可爱好猫与收藏
- en: 'Lastly, we are going to update `FavoritePetsScreen` to display a list of favorite
    cats. Let us head over to the `FavoritePetsScreen.kt` file and update the `FavoritePetsScreen`
    composable to be the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将更新 `FavoritePetsScreen` 以显示收藏猫的列表。让我们转到 `FavoritePetsScreen.kt` 文件并更新
    `FavoritePetsScreen` 组合器，使其如下所示：
- en: '[PRE33]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is an explanation of the changes:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是更改的解释：
- en: We have added a new parameter, `onPetClicked` to the `FavoritePetsScreen` composable.
    We will use this parameter to navigate to the `PetDetailsScreen` composable.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向 `FavoritePetsScreen` 组合器添加了一个新参数 `onPetClicked`。我们将使用此参数导航到 `PetDetailsScreen`
    组合器。
- en: We have created a new instance of our `PetsViewModel` class using the `koinViewModel()`
    method.
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `koinViewModel()` 方法创建了我们 `PetsViewModel` 类的新实例。
- en: We have called the `getFavoritePets` function from our `PetsViewModel` class
    to get the favorite cats from our database. We used `LaunchedEffect` to call this
    method when the composable was first launched. This is to ensure that we do not
    call the function every time the composable recomposes.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从我们的 `PetsViewModel` 类中调用了 `getFavoritePets` 函数来获取我们数据库中的收藏猫。我们使用 `LaunchedEffect`
    在组合器首次启动时调用此方法。这是为了确保我们不会每次组合器重新组合时都调用该函数。
- en: We have a new variable called `pets`, which is a `StateFlow` of favorite cats.
    We have used the `collectAsStateWithLifecycle` method to collect the favorite
    cats from our database. This method is lifecycle aware and hence it will only
    collect the favorite cats when the composable is active.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个名为 `pets` 的新变量，它是一个收藏猫咪的 `StateFlow`。我们使用了 `collectAsStateWithLifecycle`
    方法从我们的数据库中收集收藏猫咪。此方法具有生命周期感知性，因此它只会在可组合项活跃时收集收藏猫咪。
- en: We have added a check to see if the list of favorite cats is empty. If it is
    empty, we display a message to the user. If it is not empty, we display a list
    of favorite cats.
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个检查，以查看收藏猫咪列表是否为空。如果为空，我们向用户显示一条消息。如果不为空，我们显示收藏猫咪的列表。
- en: 'We need to update the `AppNavigation.kt` file to pass the `onPetClicked` callback
    to the `FavoritePetsScreen` composable:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要更新 `AppNavigation.kt` 文件，将 `onPetClicked` 回调传递给 `FavoritePetsScreen` 可组合项：
- en: '[PRE34]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This logic is like what we had in the `PetsScreen` and it handles navigation
    to `PetDetailsScreen` when we are in `FavoritePetsScreen`. Build and run the app.
    Tap the favorite icon on the bottom bar and you should see a list of your favorite
    cute cats. If you tap the favorite icon, the cat is immediately removed from the
    list of favorite cats. This is because the list of favorite cats is a `Flow` and
    every time Room updates the data, they are immediately emitted to the view layer.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个逻辑类似于我们在 `PetsScreen` 中的逻辑，它处理在 `FavoritePetsScreen` 中导航到 `PetDetailsScreen`。构建并运行应用。点击底部栏上的收藏图标，你应该能看到你收藏的可爱猫咪列表。如果你点击收藏图标，猫咪会立即从收藏猫咪列表中移除。这是因为收藏猫咪列表是一个
    `Flow`，每次 Room 更新数据时，它们都会立即发射到视图层。
- en: '![Figure 8.6 – Favorite Pets Screen](img/B19779_08_06.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 收藏猫咪屏幕](img/B19779_08_06.jpg)'
- en: Figure 8.6 – Favorite Pets Screen
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 收藏猫咪屏幕
- en: We have been able to add the functionality to favorite cats and update this
    information in the Room database. We have also been able to handle updates and
    migrations in the Room database. In the next section, we will see how to use WorkManager
    to schedule background tasks. In this case, we will use WorkManager to fetch the
    cats from the remote data source and save them to our database. This improves
    our first offline experience since we will always have the latest data in our
    database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经能够添加收藏猫咪的功能，并在 Room 数据库中更新这些信息。我们还能处理 Room 数据库中的更新和迁移。在下一节中，我们将看到如何使用 WorkManager
    来安排后台任务。在这种情况下，我们将使用 WorkManager 从远程数据源获取猫咪并将其保存到我们的数据库中。这改善了我们的首次离线体验，因为我们将在数据库中始终拥有最新的数据。
- en: Using WorkManager to schedule background tasks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 WorkManager 来安排后台任务
- en: WorkManager is a Jetpack library that is best suited for performing long-running
    tasks in the background. It ensures that background tasks are completed even when
    your app restarts or the phone restarts. With WorkManager, you can either schedule
    one-time jobs or recurring jobs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: WorkManager 是一个适合在后台执行长时间运行任务的 Jetpack 库。它确保即使在您的应用重启或手机重启时，后台任务也能完成。使用 WorkManager，您可以安排一次性作业或重复性作业。
- en: 'We will start by adding the WorkManager dependency to our project. Follow these
    steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将 WorkManager 依赖项添加到我们的项目中。按照以下步骤操作：
- en: 'Let us head over to the `libs.versions.toml` file and define the work version
    in our `versions` section as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到 `libs.versions.toml` 文件，并在我们的 `versions` 部分如下定义工作版本：
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the libraries section, add the following dependencies:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库（libraries）部分，添加以下依赖项：
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we have two dependencies: the `work-runtime-ktx` dependency, which is
    the core dependency for WorkManager, and the `koin-androidx-workmanager` dependency,
    which is used to integrate WorkManager with Koin. Sync the project for the changes
    to be added.'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们有两个依赖项：`work-runtime-ktx` 依赖项，这是 WorkManager 的核心依赖项，以及 `koin-androidx-workmanager`
    依赖项，用于将 WorkManager 与 Koin 集成。同步项目以添加这些更改。
- en: 'Next, we need to add the dependencies to the app-level `build.gradle.kts` file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将依赖项添加到应用级别的 `build.gradle.kts` 文件中：
- en: '[PRE37]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Do a Gradle sync to add these dependencies to our project.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 Gradle 同步以将这些依赖项添加到我们的项目中。
- en: 'We are now ready to start using WorkManager in our project. We will use WorkManager
    to fetch the cats from the remote data source and save them to our database. We
    will use the `OneTimeWorkRequest` class to schedule a one-time job to fetch the
    cats from the remote data source and save them to our database. Let’s get started
    with the steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好开始在项目中使用 WorkManager。我们将使用 WorkManager 从远程数据源获取猫咪并将其保存到我们的数据库中。我们将使用
    `OneTimeWorkRequest` 类来安排一次性作业，从远程数据源获取猫咪并将其保存到数据库中。让我们开始以下步骤：
- en: 'Let us create a new package named `workers` and create a new file inside it
    called `PetsSyncWorker.kt` and add the following code:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `workers` 的新包，并在其中创建一个名为 `PetsSyncWorker.kt` 的新文件，并添加以下代码：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code block, we have created a class that implements the `CoroutineWorker`
    class. We implement this class when we want to perform a long-running task in
    the background. It uses coroutines to perform long-running tasks. We have passed
    the `appContext` and `workerParams` parameters to the constructor of the class.
    We have also passed the `petsRepository` parameter to the constructor of the class.
    We have overridden the `doWork` method, which is a `suspend` function that will
    be called when the work is scheduled. We have called `fetchRemotePets` from `PetsRepository`
    to fetch the cats from the remote data source and save them to our database. We
    are also returning `Result.success()` if the work is successful and `Result.failure()`
    if the work fails.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们创建了一个实现了 `CoroutineWorker` 类的类。当我们想在后台执行长时间运行的任务时，我们会实现这个类。它使用协程来执行长时间运行的任务。我们将
    `appContext` 和 `workerParams` 参数传递给了类的构造函数。我们还传递了 `petsRepository` 参数到类的构造函数。我们重写了
    `doWork` 方法，这是一个将在工作调度时被调用的 `suspend` 函数。我们从 `PetsRepository` 调用了 `fetchRemotePets`
    来从远程数据源获取猫并保存到我们的数据库中。如果工作成功，我们返回 `Result.success()`；如果工作失败，我们返回 `Result.failure()`。
- en: 'Next, let us create an instance of `PetsSyncWorker` in our `Module.kt` file:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的 `Module.kt` 文件中创建一个 `PetsSyncWorker` 的实例：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are using the `worker` Koin DSL to create an instance of `PetsSyncWorker`.
    This is from the Koin WorkManager library that we just added. We have passed the
    `appContext`, `workerParams`, and `petsRepository` parameters to the constructor
    of `PetsSyncWorker`.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用 `worker` Koin DSL 创建 `PetsSyncWorker` 的实例。这是从我们刚刚添加的 Koin WorkManager
    库中来的。我们将 `appContext`、`workerParams` 和 `petsRepository` 参数传递给了 `PetsSyncWorker`
    的构造函数。
- en: 'Next, let us add this function in our `MainActivity.kt` file:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在我们的 `MainActivity.kt` 文件中添加这个函数：
- en: '[PRE40]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we created a new `OneTimeWorkRequest` using `PetSyncWorker`.
    We have also set some constraints on our work request. We have set the network
    type to `NetworkType.CONNECTED` to ensure that the work request is only executed
    when the device is connected to the internet. We also have other network types,
    which are as follows:'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `PetSyncWorker` 创建了一个新的 `OneTimeWorkRequest`。我们还在我们的工作请求中设置了一些约束。我们将网络类型设置为
    `NetworkType.CONNECTED`，以确保只有在设备连接到互联网时才执行工作请求。我们还有其他网络类型，如下所示：
- en: '`NOT_REQUIRED`: For this type, a network is not required. This is useful for
    tasks that do not need any internet connection to work.'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT_REQUIRED`: 对于此类类型，不需要网络。这对于不需要任何互联网连接即可工作的任务很有用。'
- en: '`UNMETERED`: An unmetered network connection such as Wi-Fi is required for
    this type of network. This is suitable for tasks that involve large data transfers.'
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNMETERED`: 对于此类网络，需要一个非计费的网络连接，如 Wi-Fi。这适用于涉及大量数据传输的任务。'
- en: '`METERED`: A metered network connection is required for this type of network.
    Tasks that require a significant amount of data might be deferred when the device
    is on a metered connection to avoid unnecessary costs.'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`METERED`: 对于此类网络，需要一个计费网络连接。当设备处于计费连接时，可能需要大量数据的任务可能会被推迟，以避免不必要的费用。'
- en: '`NOT_ROAMING`: For this type of work, a non-roaming connection is required.
    This is relevant for tasks that might incur additional costs when executed when
    the device is roaming.'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT_ROAMING`: 对于此类工作，需要一个非漫游连接。当设备处于漫游状态时执行可能会产生额外费用的任务与此相关。'
- en: 'We have also set the `BatteryNotLow constraint` to `true` to ensure that the
    work request is only executed when the battery is not low. We then used `WorkManager.getInstance(applicationContext)`
    to get an instance of the WorkManager and then called the `enqueueUniqueWork`
    method to enqueue our work request. We have passed the name of our work request,
    `ExistingWorkPolicy`, and the work request to the `enqueueUniqueWork` method.
    `ExistingWorkPolicy` is used to specify what should happen if there is already
    a work request with the same name. We have used `ExistingWorkPolicy.KEEP` to ensure
    that the work request is not replaced if there is already a work request with
    the same name. The following are other available policies:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还设置了`BatteryNotLow constraint`为`true`，以确保只有在电池电量充足时才执行工作请求。然后我们使用`WorkManager.getInstance(applicationContext)`获取WorkManager的实例，然后调用`enqueueUniqueWork`方法来入队我们的工作请求。我们将工作请求的名称、`ExistingWorkPolicy`和工作请求传递给`enqueueUniqueWork`方法。`ExistingWorkPolicy`用于指定如果已存在具有相同名称的工作请求时应该发生什么。我们使用了`ExistingWorkPolicy.KEEP`以确保如果已存在具有相同名称的工作请求，则不会替换工作请求。以下是一些其他可用的策略：
- en: '`REPLACE`: This cancels existing work with the same unique name and enqueues
    the new work. This is suitable when we want only the latest version of the work
    to be executed, discarding previous instances.'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPLACE`：取消具有相同唯一名称的现有工作，并将新工作入队。这适用于我们只想执行最新版本的工作，丢弃先前实例的情况。'
- en: '`APPEND`: Enqueues the new work even if there is existing work with the same
    unique name. Both new and existing work will be executed independently. This is
    appropriate when we want multiple instances of the same work to coexist.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APPEND`：即使存在具有相同唯一名称的现有工作，也会将新工作入队。新工作和现有工作将独立执行。这适用于我们希望同一工作的多个实例共存的情况。'
- en: We are now ready to start our work request. We will start the work request in
    the `onCreate` method of `MainActivity`.
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在已准备好开始我们的工作请求。我们将在`MainActivity`的`onCreate`方法中启动工作请求。
- en: 'In the `MainActivity.kt` file, add the following code in the `onCreate` method:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.kt`文件中，在`onCreate`方法中添加以下代码：
- en: '[PRE41]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we are using Koin, we need to disable the default WorkManager initialization
    in our app manifest.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在使用Koin，我们需要在我们的应用程序清单中禁用默认的WorkManager初始化。
- en: 'Let us head over to the `AndroidManifest.xml` file and add the following code
    inside the application tag:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到`AndroidManifest.xml`文件，并在应用程序标签内添加以下代码：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding the preceding code prevents WorkManager from being initialized automatically.
    Not doing this causes an app to crash once you set up Koin initialization. The
    crash is caused by a conflict between Koin’s dependency injection and WorkManager’s
    default initialization. Lastly, we have also removed App Startup ([https://developer.android.com/topic/libraries/app-startup](https://developer.android.com/topic/libraries/app-startup)),
    which is used internally within WorkManager from WorkManager 2.6.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加前面的代码可以防止WorkManager自动初始化。如果不这样做，一旦设置了Koin初始化，应用程序就会崩溃。崩溃是由Koin的依赖注入和WorkManager的默认初始化之间的冲突引起的。最后，我们还从WorkManager
    2.6中移除了App Startup（[https://developer.android.com/topic/libraries/app-startup](https://developer.android.com/topic/libraries/app-startup)），这是WorkManager内部使用的。
- en: 'To set up a custom WorkManager instance, head over to the `ChapterEightApplication.kt`
    file and add the following code inside the `startKoin` block:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要设置自定义WorkManager实例，转到`ChapterEightApplication.kt`文件，并在`startKoin`块内添加以下代码：
- en: '[PRE43]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Build and run the app, and nothing changes. However, we have scheduled a background
    task to fetch the cats from the remote data source and save them to our database.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，没有任何变化。然而，我们已经安排了一个后台任务，从远程数据源获取猫并将其保存到我们的数据库中。
- en: '![Figure 8.7 – Cute cats](img/B19779_08_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 可爱的猫](img/B19779_08_07.jpg)'
- en: Figure 8.7 – Cute cats
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 可爱的猫
- en: We have created our `PetsSyncWorker` class and learned how to do work in the
    background. In the next section, we are going to write tests for our `PetsSyncWorker`
    class.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了我们的`PetsSyncWorker`类，并学习了如何在后台执行工作。在下一节中，我们将为我们的`PetsSyncWorker`类编写测试。
- en: Testing your workers
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的工作者
- en: 'Testing the code is very important. It ensures that our code works as expected
    and it also helps us to catch bugs early. We will be writing tests for our workers
    in this section. To test our workers, we first need to set up WorkManager testing
    dependencies with the following steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码非常重要。它确保我们的代码按预期工作，并帮助我们及早发现错误。在本节中，我们将为我们的工作者编写测试。要测试我们的工作者，我们首先需要按照以下步骤设置WorkManager测试依赖项：
- en: 'Let us head over to the `libs.versions.toml` file and add the following dependency
    to the `libraries` section:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到`libs.versions.toml`文件，并在`libraries`部分添加以下依赖项：
- en: '[PRE44]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Sync your project. This will add the `work-testing` artifact that helps in testing
    workers to our project.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同步您的项目。这将添加`work-testing`工件，帮助我们测试工作者到我们的项目中。
- en: 'Next, we need to add the dependency to our app level `build.gradle.kts` file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将依赖项添加到我们的应用级别的`build.gradle.kts`文件中：
- en: '[PRE45]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have used `androidTestImplementation` because we will be writing our tests
    in the `androidTest` folder. Do a Gradle sync to add the dependency to our project.
    We are now ready to start writing our tests.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了`androidTestImplementation`，因为我们将在`androidTest`文件夹中编写测试。执行Gradle同步操作以将依赖项添加到我们的项目中。我们现在可以开始编写测试了。
- en: 'Since our `PetsSyncWorker` class requires some dependencies, we will create
    a test rule that provides the Koin dependencies that we need. Let us head over
    to the `androidTest` folder, create a new file called `KoinTestRule.kt`, and add
    the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`PetsSyncWorker`类需要一些依赖项，我们将创建一个测试规则，提供我们需要的Koin依赖项。让我们转到`androidTest`文件夹，创建一个名为`KoinTestRule.kt`的新文件，并添加以下代码：
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`KoinTestRule` implements the `TestRule` interface. We have used this rule
    to provide the Koin dependencies that we need in our tests. We have used the `startKoin`
    method to provide the Koin dependencies that we need. We have used the `androidContext(ApplicationProvider.getApplicationContext())`
    method to get the application context. We have also used the `modules(appModules)`
    method to provide the Koin modules that we need. Now, we are ready to start writing
    our tests. Let us create a new file called `PetsSyncWorkerTest.kt` and add the
    following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`KoinTestRule`实现了`TestRule`接口。我们使用了这个规则来提供我们在测试中需要的Koin依赖项。我们使用了`startKoin`方法来提供我们需要的Koin依赖项。我们使用了`androidContext(ApplicationProvider.getApplicationContext())`方法来获取应用程序上下文。我们还使用了`modules(appModules)`方法来提供我们需要的Koin模块。现在，我们准备好开始编写测试了。让我们创建一个名为`PetsSyncWorkerTest.kt`的新文件，并添加以下代码：'
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We have created a test class called `PetsSyncWorkerTest`. We have annotated
    the class with the `@RunWith(AndroidJUnit4::class)` annotation. We have also created
    a `KoinTestRule` instance and annotated it with the `@get:Rule` annotation to
    provide the `KoinTestRule` to our test class. We have also created a `setup` function
    and annotated it with the `@Before` annotation. This function will be executed
    before each test. We are using the `WorkManagerTestInitHelper` class to initialize
    WorkManager for instrumentation tests. We are using the `SynchronousExecutor`
    class to ensure that the work is executed synchronously. This is to ensure that
    our tests are deterministic. We are now ready to start writing our tests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`PetsSyncWorkerTest`的测试类。我们使用`@RunWith(AndroidJUnit4::class)`注解了该类。我们还创建了一个`KoinTestRule`实例，并使用`@get:Rule`注解将其提供给我们的测试类。我们还创建了一个`setup`函数，并使用`@Before`注解。这个函数将在每个测试之前执行。我们使用`WorkManagerTestInitHelper`类来初始化WorkManager进行仪器测试。我们使用`SynchronousExecutor`类来确保工作同步执行。这是为了确保我们的测试是确定性的。我们现在准备好开始编写测试了。
- en: 'Follow these steps to create our test:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建我们的测试：
- en: 'We will start by creating a test function that will test the functionality
    of our worker. Add the following code to the `PetsSyncWorkerTest.kt` file below
    the `setup` function:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个测试函数来测试我们工作者的功能。在`setup`函数下方将以下代码添加到`PetsSyncWorkerTest.kt`文件中：
- en: '[PRE48]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is an empty function annotated with the `@``Test` annotation.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个用`@Test`注解标记的空函数。
- en: 'Create a work request as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤创建工作请求：
- en: '[PRE49]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding code, we have created a one-time request using our `PetsSyncWorker`
    class. We have also set the constraints to our work request. We have set the network
    type to `NetworkType.CONNECTED` to ensure that the work request is only executed
    when the device is connected to the internet. We have also set the `BatteryNotLow`
    constraint to `true` to ensure that the work request is only executed when the
    battery is not low.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`PetsSyncWorker`类创建了一个一次性请求。我们还设置了工作请求的约束条件。我们将网络类型设置为`NetworkType.CONNECTED`，以确保只有在设备连接到互联网时才执行工作请求。我们还设置了`BatteryNotLow`约束为`true`，以确保只有在电池电量充足时才执行工作请求。
- en: 'Next, set up the test drivers:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置测试驱动程序：
- en: '[PRE50]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we have set up the test drivers that help us simulate conditions needed
    for our tests. For example, it simulates that constraints are met.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们已经设置了测试驱动程序，帮助我们模拟测试所需的条件。例如，它模拟了约束条件得到满足的情况。
- en: 'Enqueue the work request:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作请求入队：
- en: '[PRE51]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have used the `enqueueUniqueWork` method to enqueue our work request. We
    have passed the name of our work request, `ExistingWorkPolicy`, and the work request
    to the `enqueueUniqueWork` method. We have used `ExistingWorkPolicy.KEEP` to ensure
    that the work request is not replaced if there is already a work request with
    the same name. We have also used the `result.get()` method to get the result of
    our work request.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了 `enqueueUniqueWork` 方法来入队我们的工作请求。我们将工作请求的名称、`ExistingWorkPolicy` 和工作请求传递给了
    `enqueueUniqueWork` 方法。我们使用了 `ExistingWorkPolicy.KEEP` 来确保如果已经存在具有相同名称的工作请求，则不会替换工作请求。我们还使用了
    `result.get()` 方法来获取工作请求的结果。
- en: 'Get the information about our work request using the `WorkInfo` class:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `WorkInfo` 类获取关于我们的工作请求的信息：
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We are getting `WorkInfo` for our work request. We have used the `getWorkInfoById`
    method to get `WorkInfo` for our work request. We are using the `result.get()`
    method to get the result of our work request.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在获取工作请求的 `WorkInfo`。我们使用了 `getWorkInfoById` 方法来获取工作请求的 `WorkInfo`。我们使用 `result.get()`
    方法来获取工作请求的结果。
- en: 'Next, let us get the worker state and assert that our work is enqueued:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们获取工作进程的状态并断言我们的工作是入队的：
- en: '[PRE53]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have used the `assertEquals` method to assert that our work is enqueued.
    We have used the `WorkInfo.State.ENQUEUED` to check if our work is enqueued.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了 `assertEquals` 方法来断言我们的工作是入队的。我们使用了 `WorkInfo.State.ENQUEUED` 来检查我们的工作是否入队。
- en: 'Next, let us simulate our constraints being met by using the `testDriver` instance
    that we created earlier:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用我们之前创建的 `testDriver` 实例来模拟我们的约束条件得到满足：
- en: '[PRE54]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We use `testDriver` to simulate that the constraints are met. We have used the
    `setAllConstraintsMet function` to simulate that the constraints are met. We have
    passed the `id` of our work request to the `setAllConstraintsMet` method. The
    work request `id` has an instance type of `Universally Unique` `Identifier (UUID)`.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `testDriver` 来模拟约束条件得到满足。我们使用了 `setAllConstraintsMet` 函数来模拟约束条件得到满足。我们将工作请求的
    `id` 传递给了 `setAllConstraintsMet` 方法。工作请求 `id` 具有通用唯一标识符（UUID）的实例类型。
- en: 'Lastly, let us get the output and state of our workers:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们获取我们的工作进程的输出和状态：
- en: '[PRE55]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This is the final step of our test. We have used the `getWorkInfoById` method
    to get the `WorkInfo` of our work request. We have used the `result.get()` method
    to get the result of our work request. We have used `WorkInfo.State.RUNNING` to
    check if our work is running. Our final test function should look like the following:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们的测试的最终步骤。我们使用了 `getWorkInfoById` 方法来获取工作请求的 `WorkInfo`。我们使用了 `result.get()`
    方法来获取工作请求的结果。我们使用了 `WorkInfo.State.RUNNING` 来检查我们的工作是否正在运行。我们的最终测试函数应该看起来像以下这样：
- en: '![Figure 8.8 – PetsSyncWorker test](img/B19779_08_08.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – PetsSyncWorker 测试](img/B19779_08_08.jpg)'
- en: Figure 8.8 – PetsSyncWorker test
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – PetsSyncWorker 测试
- en: 'Click the green run icon on the left of our test to run the test. The test
    runs and it’s all green! Our test passes, as seen in the following screenshot:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击我们测试左侧的绿色运行图标以运行测试。测试运行并且全部为绿色！我们的测试通过了，如下截图所示：
- en: '![Figure 8.9 – Test results](img/B19779_08_09.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 测试结果](img/B19779_08_09.jpg)'
- en: Figure 8.9 – Test results
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 测试结果
- en: Making all these tests work together is amazing work.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让所有这些测试协同工作是一项了不起的工作。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to save data to a local database, Room, which
    is part of the Jetpack libraries. We also saved items and read from the Room database.
    In the process, we also learned how to update items in the Room database and how
    to handle automated migrations in our database. Additionally, we learned how to
    do long-running operations using WorkManager, its best practices, and how to write
    tests for our workers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将数据保存到本地数据库 Room，它是 Jetpack 库的一部分。我们还保存了项目并从 Room 数据库中读取。在这个过程中，我们还学习了如何在
    Room 数据库中更新项目以及如何处理数据库中的自动迁移。此外，我们还学习了如何使用 WorkManager 进行长时间运行的操作，它的最佳实践以及如何为我们的工作进程编写测试。
- en: In the next chapter, we will learn about runtime permissions and how to request
    them in our app.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于运行时权限以及如何在我们的应用中请求它们。
