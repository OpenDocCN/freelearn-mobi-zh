["```kt\nV1_create_new_tables.sql\nV2_add_new_columns.sql\n```", "```kt\nCREATE TABLE HOUSEHOLD (\nid UUID primary key,\nname text not null\n);\n```", "```kt\nCREATE TABLE IF NOT EXISTS HOUSEHOLD (\nid UUID primary key,\nname text not null\n);\n```", "```kt\nALTER TABLE IF EXISTS HOUSEHOLD ADD COLUMN deleted boolean;\nUPDATE HOUSEHOLD SET deleted = false;\nALTER TABLE IF EXISTS HOUSEHOLD ALTER COLUMN IF EXISTS deleted SET NOT NULL;\nCOMMIT;\n```", "```kt\nINSERT INTO HOUSEHOLD (id, name, email) VALUES ('d0275532-1a0a-4787-a079-b1292ad4aadf', 'Whittington', 'info@ whittington'.com') ON DUPLICATE KEY UPDATE name = 'Whittington', email = 'info@ whittington'.com';\n```", "```kt\nclass HouseholdEventListener {\n    var lastProcessedTime: Instant? = null\n    @KafkaListener(\n        topics = [\"\\${household-v1-topic}\"],\n        clientIdPrefix = \"\\${client-id}\",\n        groupId = \"\\${group-id}\",\n        containerFactory = \"kafkaListenerContainerFactory\",\n        properties = [\"auto.offset.reset=earliest\"]\n    )\n    fun onMessage(\n        @Payload(required = false) event: HouseholdEvent?,\n        @Header(name = \"kafka_eventTime\", required = true) key: String,\n    ) {\n        if (lastProcessedTime != null && event?.time?.isBefore(lastProcessedTime) == true) {\n            log.warn { \"Skipping event with time ${event.time} because it is before the last processed time $lastProcessedTime\" }\n            return\n        }\n        // some processing logic here\n        lastProcessedTime = event?.time\n    }\n}\n```", "```kt\ndata class Household(\n    val version: Int,\n    val name: String,\n    val email: String,\n)\n```", "```kt\nfun main() {\n    val repo = HouseholdRepository()\n    val name = \"Whittington\"\n    val email1 = \"info@whittington.com\"\n    val email2a = \"query@whittington.com\"\n    val email2b = \"contact@whittington.com\"\n    val household1 = Household(0, name, email1)\n```", "```kt\n    repo.create(name) { household1 }\n    repo.update(name) { household1.copy(version = 1, email = email2a)}\n    repo.update(name) { household1.copy(version = 1, email = email2b)}\n    repo.get(name)?.also {\n        println(\"${it.version}, ${it.email}\")\n    }\n}\n```", "```kt\nclass HouseholdRepository {\n    private val values: ConcurrentMap<String, Household> = ConcurrentHashMap()\n```", "```kt\n    fun create(\n        key: String,\n        callback: () -> Household\n    ): Household {\n        val household = callback()\n        val result = values.putIfAbsent(key, household)\n        return result ?: household\n    }\n```", "```kt\n    fun update(\n        key: String,\n        callback: (Household) -> Household\n    ): Household? = values.computeIfPresent(key) { _, existing ->\n        callback(existing).let { updated ->\n            if (updated.version == existing.version + 1) {\n                updated\n            } else {\n                existing\n            }\n        }\n    }\n```", "```kt\n    fun get(key: String): Household? = values[key]\n}\n```", "```kt\n1, query@whittington.com\n```"]