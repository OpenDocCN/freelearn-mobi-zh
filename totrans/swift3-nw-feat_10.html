<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Exploring Swift on the Server"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Exploring Swift on the Server</h1></div></div></div><p>Unless you're making a really basic app, chances are that you will need some form of server backend to make your app really useful. Swift running on Linux is a big deal, especially with Linux's popularity for hosting and running servers. Swift 3 opens up possibilities for developers to create server-side applications using the same Swift that they use to create applications on iOS, macOS, tvOS, and watchOS. By the end of this chapter, you will have a server-side app written completely in Swift that can run seamlessly on a Linux box.</p><div class="section" title="IBM Swift Package catalog"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec52"/>IBM Swift Package catalog</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Discovering New Territories – Linux at Last!">Chapter 2</a>, <span class="emphasis"><em>Discovering New Territories</em></span> –<span class="emphasis"><em> Linux at Last!</em></span> we covered installing Swift toolchains and configuring environments for Linux. We wrote our first program in Swift and leveraged the Swift Package Manager to manage our dependencies. With the basics out of the way, I want to mention IBM's Swift Package Catalog.</p><p>The IBM Swift Package Catalog is a site that hosts links to Swift libraries and modules that you can use with the Swift Package Manager. IBM wants it to be a community resource for developers to find and share code for their projects. You can find the site listed at the following link <a class="ulink" href="https://developer.ibm.com/swift/the-ibm-swift-package-catalog">https://developer.ibm.com/swift/the-ibm-swift-package-catalog</a>. You should definitely keep this link handy, as it will be a site that you will use often. You can explore projects based on rank, popularity, or keywords.</p></div></div>
<div class="section" title="Introducing our server project"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Introducing our server project</h1></div></div></div><p>Let's go out with a bang! For this last chapter, we are going to create a small project to test developing a server app in Swift. We will use the IBM Swift Package Catalog to find a web server framework. I really like using Slack for team communication. If you haven't tried it, you should consider evaluating whether it could be a good tool for your team. One of the powerful features of Slack is the array of integration options you have to customize the experience for your team. Slack has opened many of its APIs to developers for customization and integration. Slack even provides an App Store for users to add third-party apps that their teams can use together. The catch, if there is one, is that your third-party app or integration has to be hosted on an outside server. We are going to create a Slack integration that you can later modify into a full Slack app of your own. Our Slack integration will be written entirely in Swift, and it could be hosted on a Linux virtual machine in the cloud with a provider such as Heroku, Digital Ocean, or Amazon Web Services.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note54"/>Note</h3><p>You can download the code for this project from <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> .</p></div></div><div class="section" title="Project description and dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec50"/>Project description and dependencies</h2></div></div></div><p>Our project needs a web server framework to work properly. We could write one from scratch, or we could see what third-party frameworks are available. Using the IBM Swift Package Catalog, I found several web application frameworks that are highly rated and are both actively developed and popular with developers. IBM's Kitura, Perfect by PerfectlySoft, and Vapor by Vapor are all viable candidates from which to choose. Each of these projects will feel familiar to you if you have ever dabbled with Node.js and Express, or with Ruby on Rails. While any of these frameworks would work for our project, I selected the Vapor project for our app because it was at the top of the list in the "essential" category at the time I was writing this chapter.</p><p>According to Vapor, their project is the most used web framework written for Swift. You can learn more about Vapor, including the Swift version it supports and links to the documentation, at <a class="ulink" href="https://swiftpkgs.ng.bluemix.net/package/vapor/vapor">https://swiftpkgs.ng.bluemix.net/package/vapor/vapor</a>.</p><p>Now that we have covered the libraries and frameworks that we will use, let me give you a description of the server application that we will be building together. Slack gives developers the option to create custom integrations for their own team or to make Slack apps that would be available to any team. We are going to create a custom integration for a single team. However, you could easily convert our customization into a full app for any team to discover.</p><p>We are going to build a storefront web application to sell widgets. As a user purchases a widget from us, we will process the order and send the order to our order-tracking channel in Slack. In the interest of keeping this application simple, we are going to take some shortcuts.</p></div><div class="section" title="Setting up our environment and project"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec51"/>Setting up our environment and project</h2></div></div></div><p>Since you learned how to install Swift in <a class="link" href="ch02.html" title="Chapter 2. Discovering New Territories – Linux at Last!">Chapter 2</a>, <span class="emphasis"><em>Discovering New Territories – Linux at Last!</em></span> we will skip over that step and move on to installing the Vapor framework. We are going to add Vapor's command line toolkit to gain access to shortcut commands and assistance for common tasks.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note55"/>Note</h3><p>You can find detailed links to documentation and examples on how to use Vapor at <a class="ulink" href="https://vapor.github.io/documentation/">https://vapor.github.io/documentation/</a>.</p></div></div><p>Here's how you do it:</p><p>To install the toolkit, run the following command in a terminal:</p><pre class="programlisting">
<span class="strong"><strong>curl -sL toolbox.vapor.sh | bash</strong></span>
</pre><p>You can verify that the command worked by running:</p><pre class="programlisting">
<span class="strong"><strong>vapor -help</strong></span>
</pre><p>Next, let's create a new Vapor project and name it <code class="literal">storefront</code>:</p><pre class="programlisting">
<span class="strong"><strong>vapor new storefront</strong></span>
</pre><p>Our newly created project will have the following file structure:</p><p>
</p><div class="mediaobject"><img alt="Setting up our environment and project" src="graphics/image_10_001.jpg"/></div><p>
</p><p>The file structure should be familiar to you, as it follows the structure required for the Swift Package Manager to work. Under the cover, vapor creates a new project with <span class="emphasis"><em>swift package init--type executable</em></span>. The Vapor script also adds the vapor framework as a dependency in <code class="literal">Package.swift</code>. Our <code class="literal">main.swift</code> is our entry point, since we created an executable program.</p><p>I'm going to develop my code on a Mac and then deploy it to a Linux VM in the cloud. For me, the benefit is that I can use Xcode and it's debugging tools for my local development. In fact, the Vapor framework supports this concept by offering a command in their toolkit to generate an Xcode project for development. Let's create an Xcode project that we can use for development of our <span class="emphasis"><em>storefront</em></span> app:</p><pre class="programlisting">vapor xcode &#13;
</pre><p>When Vapor creates a companion Xcode project, it first checks to see if you are missing any dependencies specified in the Package.swift file. Vapor will download any missing dependencies for you, prior to creating the Xcode Project. In addition, Vapor will create a scheme to use for running your app in Xcode. Finally, Vapor will show you which toolchain the Xcode project expects to be linked against:</p><pre class="programlisting">$vapor xcode &#13;
No Packages folder, fetch may take a while... &#13;
Fetching Dependencies [Done] &#13;
Generating Xcode Project [Done] &#13;
Select the `App` scheme to run. &#13;
Make sure Xcode &gt; Toolchains &gt; 3.0-GM-CANDIDATE is selected. &#13;
Open Xcode project? &#13;
y/n&gt;nz &#13;
</pre><p>Whenever you create new dependencies for your project, you have to rebuild the project so that the Swift Package Manager can download your new dependency before attempting to compile your code:</p><pre class="programlisting">
<span class="strong"><strong>vapor clean or vapor build --clean &#13;
</strong></span>
</pre><p>Let's take a quick look at <code class="literal">Package.swift</code> to see what the Vapor create command generated for us. We can configure the name of the app with something that better suits our project. The current default name is <code class="literal">VaporApp</code>, but we could change this to <code class="literal">Storefront</code>. You should also notice that the vapor framework is added for us as a dependency.</p><pre class="programlisting">import PackageDescription &#13;
 &#13;
let package = Package( &#13;
    name: "VaporApp", &#13;
    dependencies: [ &#13;
        .Package(url: "https://github.com/vapor/vapor.git", majorVersion: 0, minor: 18) &#13;
], &#13;
    exclude: [ &#13;
        "Config", &#13;
        "Database", &#13;
        "Localization", &#13;
        "Public", &#13;
        "Resources", &#13;
        "Tests", &#13;
    ] &#13;
) &#13;
</pre><p>When you use the Vapor CLI to create a new project, Vapor adds example code with documentation to project. Open <code class="literal">main.swift</code> and glance over the included routes and comments. Delete everything in this file, and we will be build our app from scratch.</p><div class="section" title="The Vapor framework"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec17"/>The Vapor framework</h3></div></div></div><p>In Vapor terminology, a Droplet is a service container that acts as a gateway to Vapor's service offerings. Use a Droplet to register routes and add middleware to start your server. To get things started, we need to import Vapor and create an instance of a Droplet.</p><pre class="programlisting">import Vapor &#13;
 &#13;
let drop = Droplet() &#13;
</pre><p>We can also customize the behavior of our Droplet instance via properties. You can read more about options in Vapor's documentation.</p></div><div class="section" title="Routing"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec18"/>Routing</h3></div></div></div><p>Now that we have a Droplet instance, we need to talk about routing. Routing is an essential function for every web framework. When an incoming request is received, we need to have a way to appropriately filter and handle each request. Vapor gives you multiple options for addressing your routing concerns. We are going to create two routes for our application: one to serve our shop page, and the other to respond to <span class="emphasis"><em>post</em></span> requests when a user purchases an item on our page.</p><p>A basic route in Vapor is composed of a method, path, and closure. Two of our routes fall into this category. Vapor routing supports the standard RESTful HTTP methods (get, post, put, patch, delete, and options). We register routes by calling the corresponding method on our Droplet instance, passing in our route path and returning a closure we define.</p><pre class="programlisting">drop.get("/") { request in &#13;
    return try drop.view.make("shop.html") &#13;
} &#13;
 &#13;
drop.post("purchase") { request in &#13;
 &#13;
// more stuff happening here but omitted &#13;
 &#13;
var response = try Response(status: .ok, json: json) &#13;
    return response &#13;
} &#13;
</pre><p>Our first route handles all <span class="emphasis"><em>get</em></span> requests for the root directory of our website. When this route is requested, we return the <code class="literal">shop.html</code> view. Our second route handles <span class="emphasis"><em>post</em></span> requests for the <code class="literal">/purchase</code> route. Once we finish carrying out work, we return a response to the requester with a status and JSON payload.</p><p>Vapor also supports nested routes and parameters. Creating a nested route is as easy as replacing the forward slashes in the URL with commas when registering your route.</p><pre class="programlisting">// Nested route &#13;
drop.get("products", "vehicles", "trucks") { request in &#13;
    return "You requested /products/vehicles/trucks" &#13;
} &#13;
</pre><p>Vapor handles parameters by making them type safe. Many web frameworks default to using strings for route parameters and types, which can be error prone. Using Swift's closures allows for a safer way to access route parameters. In the following example, we define the route to accept an <span class="emphasis"><em>Int</em></span> parameter. Our route matches <span class="emphasis"><em>artboard/:id</em></span> where our <span class="emphasis"><em>:id</em></span> parameter must be an Integer value.</p><pre class="programlisting">// Type Safe parameters &#13;
drop.get("artboard", Int.self) { request, productId in &#13;
    return "You requested Artboard #\(productId)" &#13;
} &#13;
</pre><p>We could have also written this without using route parameters and then access our parameters on the request object.</p><pre class="programlisting">drop.get("artboard", ":id") { request in &#13;
    guard let productId = request.parameters["id"]?.int else { &#13;
        throw Abort.badRequest &#13;
    } &#13;
     &#13;
    return "You requested Artboard #\(productId)" &#13;
} &#13;
</pre></div><div class="section" title="Creating views"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec19"/>Creating views</h3></div></div></div><p>When you want to send HTML from your application, you create views. You can create a view from an HTML document or you can build your views using renderers like Mustache. By default, views are stored in the <span class="emphasis"><em>Resources/Views </em></span>directory. Going back to the first route registered for our root directory, we used a view to return an HTML document (<code class="literal">shop.html</code>). You create an instance of a view by calling the <code class="literal">view.make</code> method on your Droplet instance.</p><pre class="programlisting">drop.get("/") { request in &#13;
    return try drop.view.make("shop.html") &#13;
} &#13;
</pre><p>More complex documents, such as mustache templates, need more information to process and create a view. This additional information is passed to the <span class="emphasis"><em>view.make</em></span> method as the second argument.</p><pre class="programlisting">drop.get("shop_template") { request in &#13;
    return try drop.view.make("shop.template", [ &#13;
        "countdown": "2 days left", &#13;
        "shopper_count": "1,000" &#13;
        ]) &#13;
} &#13;
</pre></div><div class="section" title="Public resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec20"/>Public resources</h3></div></div></div><p>For the most part, we want all of our server code and files protected from snooping eyes and web crawlers. Vapor handles that for us. When we need to provide resources that are reachable from our views, we use the <code class="literal">Public</code> folder created at the root of our application. We will store our images, scripts, and styles nested under the <code class="literal">Public</code> folder.</p></div><div class="section" title="Defining our shop view"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec21"/>Defining our shop view</h3></div></div></div><p>When we serve the root level document on our application, we return a <code class="literal">shop.html</code> view. Our simple page displays a welcome message and details of three products.</p><p>
</p><div class="mediaobject"><img alt="Defining our shop view" src="graphics/image_10_002.jpg"/></div><p>
</p><p>When a user clicks the buy now button, we execute a jQuery Ajax post command to communicate with our server. We send the product ID of the product we want to purchase to our <code class="literal">"/purchase"</code> route.</p><p>On the server, when we receive a request that matches this route, we extract the product ID and search for a matching product in our local store. Of course, in a production app, we would use a database to house our products and even populate our store listings. In situations where we can't find a valid product ID on our request object or where we can't find a matching product for a supplied product ID, we throw an error that is sent back to the client.</p><p>Finally, we create a JSON payload that contains some of our product details and return it to the client with a successful status code.</p><pre class="programlisting">drop.post("purchase") { request in &#13;
    drop.log.info("purchase request made") &#13;
    guard let product_id = request.data["product_id"]?.int else { &#13;
        throw Abort.badRequest &#13;
    } &#13;
     &#13;
    guard let product = products.filter({ (prod) -&gt; Bool in &#13;
        return prod.id == product_id &#13;
    }).first else{ &#13;
        throw Abort.badRequest &#13;
    } &#13;
    &#13;
 &#13;
    let json = try JSON(node: [ &#13;
        "Product" : "\(product.name)", &#13;
        "price" : "\(product.price)", &#13;
        ]) &#13;
 &#13;
// more work happening and omitted  &#13;
 &#13;
    var response = try Response(status: .ok, json: json) &#13;
     &#13;
    return response &#13;
} &#13;
</pre><p>When our client receives the post response, we display an alert dialog that thanks the user for their purchase. We also display the returned JSON data in a console.</p></div><div class="section" title="Slack integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec22"/>Slack integration</h3></div></div></div><p>Now that we covered the basics of our web app, let's make it a bit more interesting by integrating with Slack. Using Slack's APIs, we can extend Slack to make our workflow better. In our case, we want to notify our operations team of new orders so that they can immediately start processing them. We are going to take advantage of incoming webhooks to send messages into Slack from our Swift server. While this webhook will only be for our team, you can read the documentation <a class="ulink" href="https://api.slack.com/">https://api.slack.com/</a> and easily convert our custom integration into a Slack app that any team could incorporate into their workflows.</p></div><div class="section" title="Making a custom integration"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec23"/>Making a custom integration</h3></div></div></div><p>Since our custom integration will only work with a single Slack team, you will need to create an account and team on Slack if you don't already have one. Once you do that, you can navigate to the build section of the Slack app directory located at :</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Click on the <span class="strong"><strong>Make a Custom Integration</strong></span> button.<p>
</p><div class="mediaobject"><img alt="Making a custom integration" src="graphics/image_10_003.jpg"/></div><p>
</p></li><li class="listitem">Select the <span class="strong"><strong>Incoming WebHooks</strong></span> link next.<p>
</p><div class="mediaobject"><img alt="Making a custom integration" src="graphics/image_10_004.jpg"/></div><p>
</p></li></ol></div><p>Choose a channel to post your messages to or create a new channel. I chose to send my messages to my orders channel. After picking your channel, press the "<span class="strong"><strong>Add Incoming WebHooks integration</strong></span>" button.</p><p>
</p><div class="mediaobject"><img alt="Making a custom integration" src="graphics/image_10_005.jpg"/></div><p>
</p><p>On this view, you can see instructions for setting things up as well as the fields you can customize for your use case. You can provide an optional descriptive label for this integration along with a user name. The default name is <code class="literal">incoming-webhook</code>, but I changed mine to <code class="literal">OrderUp</code>. I also added an emoji to serve as my icon for the messages I add to this channel. Once you have previewed your settings, you just need to click on the <span class="strong"><strong>Save Settings</strong></span> button to make your changes go live.</p></div><div class="section" title="Updating our server to post to Slack"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec24"/>Updating our server to post to Slack</h3></div></div></div><p>Before we close this view, we need to copy the Webhook URL to use from our external service. You can click on the <span class="strong"><strong>Copy URL</strong></span> button, and it will be added to your clipboard. Let's head back to Swift and open <code class="literal">main.swift</code>. Update your purchase route to create a JSON payload for Slack to send our post request to Slack's servers:</p><pre class="programlisting"> &#13;
drop.post("purchase") { request in &#13;
 // omitted code above &#13;
 &#13;
    let slack_payload = try JSON(node: [ "attachments": &#13;
        try JSON(node: [ &#13;
            try JSON(node: [ &#13;
                "fallback": "New purchase Request", &#13;
                "pretext": "New purchase Request", &#13;
                "color": "#D00000", &#13;
                "fields": try JSON(node: [ &#13;
                    try JSON(node: [ &#13;
                        "title" : "Product: \(product.name)", &#13;
                        "value" : "Price: \(product.price)", &#13;
                        "short" : "false" &#13;
                        ]) &#13;
                    ]) &#13;
                ]) &#13;
            ]) &#13;
        ]) &#13;
     &#13;
     _ = try drop.client.post("https://hooks.slack.com/services/&lt;your hook id&gt;", headers: [:], query: [:], body: slack_payload) &#13;
 &#13;
    var response = try Response(status: .ok, json: json) &#13;
     &#13;
    return response &#13;
} &#13;
</pre><p>Our formatted message payload sends a general message, which will show up in your Slack notifications on desktop and mobile (<code class="literal">"New purchase Request"</code>). We also use the attachment syntax to provide details on the product order. We pass the product name and price.</p><p>Now, when you make a purchase on the website, you will also get a real-time message sent to the orders channel in Slack for your team.</p><p>
</p><div class="mediaobject"><img alt="Updating our server to post to Slack" src="graphics/image_10_007.jpg"/></div><p>
</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Summary</h1></div></div></div><p>In this chapter, we explored Swift on the server. We developed a web application that runs entirely in Swift. Our application also communicates with Slack to post messages. We used the Vapor web framework to create a Swift web server, and you learned how to call Slack webhooks from Swift. While our example was fairly simple, it is easy to see how we could expand it to a larger and more complex application leveraging the power of Swift.</p><p>This brings us to the end of the book. We've covered a lot of material and learned the new features of Swift 3. We discussed Apple's motivation and objectives for the evolution of Swift. I have shown you where to find documentation on the language and how to get involved with the future direction of Swift. We explored Swift on Linux and some of the possibilities this creates for server-side Swift applications. Swift 3 adds new language features that improve many of the libraries that you will use everyday in your coding projects.</p><p>It's my hope that this book will prove to be a reference for you as dive into developing for Swift 3. While we have examined many of the features of the language, it isn't feasible to cover every single change to the language. While this book provides a good base for understanding the changes for Swift 3, you will need to apply what you've learned in your code. In addition, you should refer to Apple's documentation, and the Swift community to stay on top of the latest developments to the language. The best developers never rely on their current knowledge. They actively seek to learn more and more. If you want to master Swift 3, you will have to use all of the resources at your disposal to build on the base we created together. I know you can do it, and I wish you the best of luck in your journey.</p></div></body></html>