["```java\n       class Renderer{\n       std::vector <Scene*> scenes; // Scene List   \n\n    public:\n    void initializeScenes();     // Initialize Engine\n    void resize( int w, int h );// resize screen\n    void render();             // Render the Scenes\n    void addScene(Scene* scene);// Add new scene\n       bool removeScene( Scene* scene); // Remove the scene\n    };\n    ```", "```java\n    // When renderer initializes it initiates each Scene\n    void Renderer::initializeScenes(){ \n         for( int i=0; i<scenes.size();  i++ )\n                scenes.at(i)->initializeScene();\n    }\n\n    // Resize all the scenes to adapt new window size\n    void Renderer::resize( int w, int h ){\n      for( int i=0; i<scenes.size();  i++ )\n        scenes.at(i)->resize(w, h); \n    }\n\n    // Add a new Scene into the rendering engine\n    void Renderer::addScene( Scene* scene){\n      if(!scene) return;\n\n      for( int i=0; i<scenes.size();  i++ ){\n          if(scenes.at(i) == scene ){\n              return; // If already added return;\n          }\n      }\n\n      scenes.push_back( scene );\n      scene->setRenderer(this);\n    }\n\n    // No longer need a scene, then remove it\n    bool Renderer::removeScene(Scene* scene){\n      for( int i=0; i<scenes.size();  i++ ){\n    if(scenes.at(i) == scene){\n    scenes.erase(scenes.begin()+i); \n    return true; \n    }\n      }\n      return false;\n    }\n\n    // Render Each Scene\n    void Renderer::render(){ \n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n\n        for( int i=0; i<scenes.size();  i++ )\n            scenes.at(i)->render();\n    }\n    ```", "```java\n    class Light {\n      private:\n        int lightID;\n      public:\n        Material material;\n        glm::vec4 position;\n        GLfloat constantAttenuation, linearAttenuation,\n                quadraticAttenuation;\n        Light() {}\n        Light(Material mt, glm::vec4 p, GLfloat ca = 1.0,\n                   GLfloat la = 0.2, GLfloat qa = 0.05) {\n            material                = mt;\n            position               = p;\n            constantAttenuation    = ca;\n            linearAttenuation      = la;\n            quadraticAttenuation   = qa;\n            enabled                = false;\n        }\n    };\n    ```", "```java\n    class Material{\n    public:\n       glm::vec4 ambient, diffuse, specular;\n       GLfloat shines;\n       std::string name;\n    MaterialType typeOfMaterial;\n       Material(glm::vec4  ambient, glm::vec4 diffuse,\n     glm::vec4 specular, GLfloat shiness);\n       Material(const Material & p);\n    Material & operator = (const Material & p);\n    Material(MaterialType type = MaterialNone);\n    };\n    ```", "```java\n    typedef enum {\n        MaterialNone,\n        MaterialGold,\n        MaterialCopper,\n    } MaterialType;\n\n    // Copper Material\n    const vec4 CopperAmbient(0.19f, 0.07f, 0.022f, 1.0f);\n    const vec4 CopperDiffuse(0.70f, 0.27f, 0.082f, 1.0f);\n    const vec4 CopperSpecular(0.2f, 0.13f, 0.086f, 1.0f);\n    const GLfloat   CopperShiness = 2.8f;\n\n    // Gold Material\n    const vec4 GoldAmbient(0.24f, 0.19f, 0.07f, 1.0f);\n    const vec4 GoldDiffuse(0.75f, 0.60f, 0.22f, 1.0f);\n    const vec4 GoldSpecular(0.62f,0.55f, 0.36f, 1.0f);\n    const GLfloat   GoldShiness=51.2f;\n    ```", "```java\n    class Scene{\n    public:\n    Scene(string name=\"\",Renderer* parentObj = NULL);  virtual ~Scene(void);       // Destructor\n       void initializeScene();      // Initialize Scene\n       inline ProgramManager* SceneProgramManager(){\n     return &ProgramManagerObj; }\n        inline Transform*  SceneTransform() {\n     return &TransformObj;  }\n        void render();              // Render the Models\n        void initializeModels();    // Initialize Models\n        void clearModels();         // Remove models\n        void addModel( Model* );   // Add into model list\n        void addLight( Light* );   // Add lights\n        Renderer* getRenderer();    // Get scene's renderer\n        void setUpProjection();      // Set projection\n        std::vector<Light*>& getLights(){ return lights; }\n\n    private:\n        ProgramManager   ProgramManagerObj;\n        Transform      TransformObj;\n        vector<Model*> models; // Model's List\n        vector<Light*> lights; // Light's List\n        Renderer* renderManager;  // Scene's Renderer\n        Model* currentModel;   // Current Model in use\n    };\n    ```", "```java\n    void Scene::addModel(Model* model){\n        if(!model) { return; }\n    models.push_back( model );\n    model->setSceneHandler(this);\n    }\n\n    void Scene::addLight( Light* lightObj){\n        for(int i =0; i<lights.size(); i++){\n            if(lights.at(i) == lightObj) return;\n        }\n        lights.push_back(lightObj);\n    }\n    ```", "```java\n    class Model {\n    public:\n       Model(Scene* SceneHandler, Model* model,\n            ModelType type, string objectName=\"\");  \n\n       // Define setter and getter function for Scene\n       // and material class. \n\n    // Reuse the older Model class existing methods\n\n    protected:\n       Scene*  SceneHandler; \n    Material materialObj;\n    };\n    ```", "```java\n    class ObjLoader : public Model{\n    public:\n        // Constructor for ObjLoader\n        ObjLoader( Scene* parent, Model* model, MeshType\n     mesh, ModelType type);\n        void ApplyLight();   // Apply scenes light\n        void ApplyMaterial();// Object's material\n\n        // Rest of the function are same, for more info please\n        // refer to SG1_withSceneLightMaterial recipe.\n    };\n    ```", "```java\n    void ObjLoader::Render(){\n        glUseProgram(program->ProgramID);\n        ApplyMaterial();\n        ApplyLight();\n\n        // Apply Transformation.\n     // Bind with Vertex Array Object for OBJ\n\n        // Draw Geometry\n        glDrawArrays(GL_TRIANGLES, 0, IndexCount );\n        glBindVertexArray(0);\n    }\n    ```", "```java\n    Renderer* engine   = NULL; \n    ObjLoader* Suzzane = NULL; \n    Scene* scene1      = NULL;\n\n    bool GraphicsInit(){\n      // Create a new Renderer instance \n       engine = new Renderer(); \n\n    // Add a new scene named \"Mesh Scene\" to engine\n       scene1 = new Scene(\"MeshScene\", engine);\n\n       // Create a new light and set into the scene\n       scene1->addLight(new Light(Material(MaterialWhite)\n     ,glm::vec4(0.0, 0.0, 10.0, 1.0)));\n\n       // Create Suzzane,added into the scene1.\n       Suzzane = new ObjLoader(scene1,NULL,SUZZANE,None);\n    Suzzane->SetMaterial(Material(MaterialCopper));\n\n       // Add Suzzane into Scene \n    scene1->addModel( Suzzane); \n\n    // Initialize engine \n    engine->initializeScenes(); \n    }\n    ```", "```java\n    bool GraphicsRender(){\n        static int i=0;   static clock_t start = clock();\n     // Switch material each second\n        if(clock()-start > CLOCKS_PER_SEC){\n            start = clock(); \n            (i %=6)++; //Plus one to avoid None type\n\n           // Assign a new material   \n            Suzzane->SetMaterial(Material(MaterialType(i)));\n        }\n       engine->render();\n    }\n    ```", "```java\n         mat4 transformation; mat4 transformationLocal; vec3 center;\n    ```", "```java\n       // Many line skipped, refer to source for CTOR/DTOR\n       void Model::Rotate(float angle,float x,float y,float z){\n      transformation = translate( transformation, center);\n      transformation=rotate(transformation,angle,vec3(x,y,z));\n      transformation = translate( transformation, -center);\n    }\n\n    void Model::Translate(float x, float y, float z ){\n     transformation = translate(transformation,vec3(x,y,z));\n    }\n\n    void Model::Scale(float x, float y, float z ){    \n     transformation = scale(transformation,vec3(x,y,z)); }\n\n    void Model::RotateLocal(float ang,float x,float y,float z){\n    transformationLocal = rotate(transformationLocal, ang,\n                               vec3( x, y, z ) ); }\n\n    void Model::TranslateLocal(float x, float y, float z ){\n        transformationLocal = translate\n    (transformationLocal, vec3( x, y, z ));\n    }\n    void Model::ScaleLocal(float x, float y, float z ){\n              transformationLocal=scale(transformationLocal,vec3(x,y,z));\n    }\n    void Model::SetCenter(vec3 cntrPoint){center=cntrPoint;}\n    vec3 Model::GetCenter(){ return center; }\n    ```", "```java\n    ObjLoader::Render(){\n      // USE PROGRAM, APPLY MATERIAL AND LIGHT\n         // APPLY RELATIVE TRANSFORMATION\n          TransformObj->TransformPushMatrix();\n          *TransformObj->TransformGetModelMatrix() =\n    *TransformObj->TransformGetModelMatrix()\n    *transformation;\n\n          // APPLY LOCAL TRANSFORMATION\n          TransformObj->TransformPushMatrix();\n          *TransformObj->TransformGetModelMatrix() =\n    *TransformObj->TransformGetModelMatrix()\n    *transformationLocal;\n                // RENDER GEOMETRY, REUSE CODE\n                // POP LOCAL TRANSFORMATION\n          TransformObj->TransformPopMatrix(); // Local Level\n\n          Model::Render();\n       // POP RELATIVE TRANSFORMATION\n          TransformObj->TransformPopMatrix();\n       }\n    ```", "```java\n    // GLOBAL VARIABLES\n    //  Renderer* graphicsEngine;  ObjLoader* Suzzane;\n    //  ObjLoader* Torus; Scene* scene1;\n\n      graphicsEngine = new Renderer();\n      scene1         = new Scene(\"MeshScene\", graphicsEngine);\n      Suzzane        = new ObjLoader(scene1, NULL, SUZZANE, None);\n      Torus          = new ObjLoader(scene1, NULL, TORUS, None);\n\n    // Set Light and Material\n      scene1->addLight(new Light(Material(MaterialWhite),\n      glm::vec4(0.0, 0.0, 10.0, 1.0)));\n      Suzzane->SetMaterial(Material(MaterialCopper));\n      Torus->SetMaterial(Material(MaterialGold));\n      Torus->Scale(0.40, 0.40, 0.4);\n\n      scene1->addModel( Suzzane ); //Add Suzzane to scene\n      scene1->addModel( Torus );   //Add Torus to scene\n\n    // Set position in the 3D space.\n      Suzzane->SetCenter(glm::vec3 (-3.0, 0.0, 0.0));\n      Suzzane->Translate(3.0, 0.0, 0.0);\n\n      graphicsEngine->initializeScenes(); //Init Scene\n    ```", "```java\n    bool GraphicsRender() {\n        Suzzane->Rotate(1.0, 0.0, 1.0, 0.0);     // Relative\n        Suzzane->RotateLocal(6.0, 0.0, 1.0, 0.0);// Local\n        graphicsEngine->render();    return true;\n    ```", "```java\n    class Object{\n    public:\n        Object(string name=\"\", Object* parentObj=NULL);\n        virtual ~Object(){}\n        void SetName(string mdlName){ name = mdlName;}\n        string GetName() { return name; }\n\n        void SetChild(Object* child = 0);\n        void RemoveFromParentChildList();\n        Object*  GetParent() { return parent; }\n        vector<Object*>* GetChildren(){ return &childList; }\n\n        void SetVisible(bool flag,bool applyToChildren=false);\n        bool GetVisible(){ return isVisible; }\n\n    protected:\n        string name;          // Model's name\n        Object* parent;      // Model's parent\n        vector<Object*> childList; // Model's child list\n     bool isVisible;      // Is Model Visible\n    };\n    ```", "```java\n    Object::Object(std::string objectName, Object* parentObj){\n        parent = NULL;          name = objectName;\n        SetParent(parentObj);   return;\n    }\n\n    void Object::RemoveParent()\n    { RemoveFromParentChildList(); parent = NULL; }\n\n    void Object::SetChild(Object* child){\n        for(int i =0; i<childList.size(); i++){ \n    if(child == childList.at(i)) { return; } \n     }\n        child->parent = this;\n        childList.push_back(child);\n    }\n\n    void Object::RemoveFromParentChildList(){\n       for(int i=0; parent&&i<parent->childList.size(); i++){\n            if(this == parent->childList.at(i))\n                 { parent->childList.erase\n    (parent->childList.begin()+i); return; }\n       }\n    }\n    ```", "```java\n    void Model::SetVisible(bool flag, bool applyToChildren){\n        isVisible = flag;\n        if(applyToChildren){\n          for(int i =0; i<childList.size(); i++)\n            dynamic_cast<Model*>(childList.at(i))->\n    SetVisible( flag, applyToChildren );}\n    }\n    ```", "```java\n    ObjLoader::Render(){\n      // REUSE CODE, APPLY RELATIVE TRANSFORMATION\n    if(isVisible){\n          // APPLY LOCAL TRANSFORMATION\n    // RENDER GEOMETRY, REUSE CODE   \n       // POP LOCAL TRANSFORMATION\n    }\n       // POP RELATIVE TRANSFORMATION\n       }\n    ```", "```java\n    void Model::Render(){\n        for(int i =0; i<childList.size(); i++)\n            dynamic_cast<Model*>(childList.at(i))->Render();\n    }\n    ```", "```java\n    Renderer* graphicsEngine; Scene* scene1;\n    ObjLoader *Sphere, *BaseSphere, *Cube[2];\n\n    bool GraphicsInit(){\n        graphicsEngine = new Renderer();\n        scene1 = new Scene(\"MeshScene\", graphicsEngine);\n        scene1->addLight(new Light(Material(MaterialWhite)\n    ,vec4(0.0,0.0,10.0,1.0)));\n        BaseSphere =  new ObjLoader   (scene1,NULL,SPHERE,None);\n        BaseSphere->SetMaterial(Material(MaterialGold));\n        BaseSphere->ScaleLocal(1.5,1.5,1.5);\n        int j = 0;\n        for(int i=-1; i<2; i+=2){\n          Cube[j] = new ObjLoader(scene1,BaseSphere,CUBE,None);\n          Cube[j]->SetMaterial(Material(MaterialCopper));\n          Cube[j]->Translate(10.0*i, 0.0, 0.0);\n          for(int i=-1; i<2; i+=2){\n            Sphere=new ObjLoader(scene1,Cube[j],SPHERE,None);\n            Sphere->SetMaterial(Material(MaterialSilver));\n            Sphere->Translate(0.0, -5.0*i, 0.0);\n          } j++;\n        }\n        scene1->addModel( BaseSphere);\n        graphicsEngine->initializeScenes();\n    }\n\n    bool GraphicsRender(){\n        BaseSphere->Rotate(1.0, 0.0, 1.0, 0.0);\n        Cube[0]->Rotate(-1.0, 1.0, 0.0, 0.0);\n        Cube[1]->Rotate( 1.0, 1.0, 0.0, 0.0);\n        graphicsEngine->render();\n    }\n    ```", "```java\nclass DummyModel : public Model{\npublic:\n   DummyModel(Scene* SceneHandler, Model* model, ModelType type,\n           string objectName = \"\");  // Constructor\n   virtual ~DummyModel(){}      // Destructor\n      void Render();           // Render the dummy model.\n};\n\nDummyModel::DummyModel(Scene*  parentScene, Model* model, ModelType type,std::string objectName):Model(parentScene, model, type, objectName){}          // DummyModel CTOR.\n\nvoid DummyModel::Render(){\n   SceneHandler->SceneTransform()->TransformPushMatrix();\n   ApplyModelsParentsTransformation();//Parent Transformation\n       Model::Render(); // Base renderer process the childs\n   SceneHandler->SceneTransform()->TransformPopMatrix();\n}\n```", "```java\nRenderer*    graphicsEngine;   Scene* scene1;\nObjLoader    *Base,   *Stand, *MotorShaft, *CubePlane;\nObjLoader    *Sphere,  *Torus, *Suzzane;\n\nbool GraphicsInit(){\n    graphicsEngine = new Renderer();\n    scene1 = new Scene(\"MeshScene\", graphicsEngine);\n    scene1->addLight(new Light(\n            Material(MaterialWhite),vec4(0.0, 0.0, 10.0, 1.0)));\n\n    Base =  new ObjLoader(scene1, Sphere, CUBE);// Base\n    Base->SetMaterial(Material(MaterialSilver));\n    Base->SetName(std::string(\"Base\"));\n    Base->ScaleLocal(1.5, 0.25, 1.5);\n\n    Stand = new ObjLoader(scene1,Base,SEMI_HOLLOW_CYLINDER);// Stand\n    Stand->SetMaterial(Material(MaterialSilver));\n    Stand->SetName(std::string(\"Stand\"));\n    Stand->Translate(0.0, 4.0, 0.0);\n    Stand->ScaleLocal(0.5, 4.0, 0.5);\n\n    MotorShaft = new ObjLoader(scene1,Stand,CUBE); // MotorShaft\n    MotorShaft->SetMaterial(Material(MaterialSilver));\n    MotorShaft->SetName(std::string(\"MotorShaft\"));\n    MotorShaft->Translate(0.0, 4.0, 1.0);\n    MotorShaft->ScaleLocal(0.5, 0.5, 2.0);\n\n    Sphere = new ObjLoader(scene1,MotorShaft,SPHERE);// MotorEngine\n    Sphere->SetMaterial(Material(MaterialGold));\n    Sphere->Translate(0.0, 0.0, 2.0);\n    Sphere->SetName(std::string(\"Sphere\"));\n\n    for(int i=0; i<360; i+=360/18){ // 20 Fan Blades\n        CubePlane =  new ObjLoader   ( scene1, Sphere, CUBE);\n        CubePlane->SetMaterial(Material(MaterialCopper));\n        CubePlane->SetName(std::string(\"FanBlade\"));\n        CubePlane->Translate(0.0, 2.0, 0.0);\n        CubePlane->SetCenter(glm::vec3(0.0, -2.0, 0.0));\n        CubePlane->ScaleLocal(0.20, 2.0, 0.20);\n        CubePlane->Rotate(i, 0.0, 0.0, 1.0);\n    }\n\n    scene1->addModel( Base);\n    graphicsEngine->initializeScenes(); return true;\n}\n\nbool GraphicsRender(){\n    Sphere->Rotate(3.0, 0.0, 0.0, 1.0);\n    Base->Rotate(1.0, 0.0, 1.0, 0.0);\n        graphicsEngine->render(); return true;\n}\n```", "```java\n    class Event {\n     public:\n       Event(){          // Define CTOR };\n       virtual ~Event(){ // Define DTOR };\n    };\n    class GestureEvent : public Event {\n      public:\n       GestureEvent():Event(){  // Define CTOR }\n       virtual ~GestureEvent(){ // Define DTOR }\n       virtual void TouchEventDown(float x, float y) = 0;\n       virtual void TouchEventMove(float x, float y) = 0;    \n       virtual void TouchEventRelease(float x, float y) = 0;\n    };\n    ```", "```java\n    class Renderer: public Object, public GestureEvent\n    class Scene    : public Object, public GestureEvent\n    class Model    : public Object, public GestureEvent\n    ```", "```java\n    void Renderer::TouchEventDown(float x, float y){\n        for( int i=0; i<scenes.size();  i++ )\n            { scenes.at(i)->TouchEventDown(x, y); } }\n    // Similarly, implement TouchEventMove &\n    // TouchEventRelease like TouchEventDown.\n    ```", "```java\n    void Scene::TouchEventDown(float x, float y){\n        for( int i=0; i<models.size(); i++ ){\n          models.at(i)->TouchEventDown(x, y); }\n    }\n    //Similarly, defineTouchEventMove & TouchEventRelease\n    ```", "```java\n    void Model::TouchEventDown(float x, float y){\n        for(int i =0; i<childList.size(); i++){\n          dynamic_cast<Model*>\n           (childList.at(i))->TouchEventDown(x, y);}\n    }\n    //Similarly, define TouchEventMove & TouchEventRelease\n    ```", "```java\n    class Ray{\n     public:\n       vec3 dest, dir; // Destination and Direction\n       Ray(){ dest = vec3(); dir = vec3(); }\n       Ray(vec3 de, vec3 di){ dest = de; dir = di; }\n       Ray(const Ray & r){ dest=r.dest; dir=r.dir; }\n       Ray & operator=(const Ray&r)\n    {dest=r.dest; dir=r.dir; return *this; }\n    };\n    ```", "```java\n    bool ObjLoader::IntersectWithRay(Ray ray0,vec3& intersect){\n        vec4 p0, p1, p2;\n        // COMPUTE EACH TRIANGLE AND CHECK INTERSECTION\n        for(uint i=0; i<objMeshModel->vertices.size(); i+=3){\n         p0=vec4(objMeshModel->vertices.at(i).position,1);\n         p1=vec4(objMeshModel->vertices.at(i+1).position,1);\n         p2=vec4(objMeshModel->vertices.at(i+2).position,1);\n         mat4 mat = *TransformObj->TransformGetModelMatrix();\n\n         p0 = mat*GetEyeCoordinatesFromRoot() * p0;\n         p1 = mat*GetEyeCoordinatesFromRoot() * p1;\n         p2 = mat*GetEyeCoordinatesFromRoot() * p2;\n\n         if (intersectLineTriangle(ray0.destination,\n         ray0.dir, vec3(p0.x,p0.y,p0.z),\n         vec3(p1.x,p1.y,p1.z), vec3(p2.x,p2.y,p2.z),\n         intersect))\n         { return true; }\n        }\n        return false;\n    }\n    ```", "```java\n    void ObjLoader::TouchEventDown( float x, float y ){\n       GLint vp[4] = { 0, 0, 0, 0 }; //Store's viewport\n       glGetIntegerv( GL_VIEWPORT, vp );\n       vec4 viewport(vp[0], vp[1],vp[2], vp[3]);\n       vec3 win(x, vp[3]-y, 0.0);\n       vec3 nearPoint = glm::unProject(win, *TransformObj->\n       TransformGetModelViewMatrix(), *TransformObj-> TransformGetProjectionMatrix(), viewport);\n       win.z = 1.0; // On the far plane.\n       vec3 farPoint = glm::unProject(win,\n    *TransformObj->TransformGetModelViewMatrix(), *TransformObj->TransformGetProjectionMatrix(), viewport);\n        Ray ray0(nearPoint, farPoint-nearPoint);\n        glm::vec3 intersectionPoint;\n        if(IntersectWithRay( ray0, intersectionPoint)){\n          printf(\"Intersect with %s\", GetName().c_str());\n            isPicked = !isPicked;\n         }\n\n        Model::TouchEventDown(x,y); //Propagate to children\n    }\n    ```", "```java\nvoid glm::unproject(vec3 const& win, mat4 const& modelView,\nmat4 const& proj, vec4 const& viewport);\n```", "```java\nScreen Coordinates => Viewport => Projection => ModelView => World coordinates\n```", "```java\n    class Button : public Model{\n    public:\n        Button(Scene* parent,Model* model,ModelType type,vec3*\n     vertices,vec2* textureCoordinates,char* texture);\n        virtual ~Button();      // Destructor for Button class\n        void InitModel();    // Initialize our Button class\n        void Render();       // Render the Button class\n    private:\n     char MVP, TEX; Image* image;  char* textureImage;\n        vec3 vertices[4]; vec2 texCoordinates[4];  \n    };\n    ```", "```java\n    void Button::Render(){\n        glBindBuffer(GL_ARRAY_BUFFER, 0);\n        glUseProgram(program->ProgramID);\n\n        glDisable(GL_CULL_FACE); // Disable culling\n        glEnable(GL_BLEND);      // Enable blending\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n\n        glActiveTexture (GL_TEXTURE0);\n        glUniform1i(TEX, 0);\n        if (image)\n      {glBindTexture(GL_TEXTURE_2D,image->getTextureID());}\n\n        TransformObj->TransformPushMatrix(); //Parent Level\n        ApplyModelsParentsTransformation();\n\n        if(isVisible){\n            TransformObj->TransformPushMatrix(); // Local Level\n            ApplyModelsLocalTransformation();\n\n            glEnableVertexAttribArray(VERTEX_POSITION);\n            glEnableVertexAttribArray(TEX_COORD);\n            glVertexAttribPointer(TEX_COORD, 2, GL_FLOAT,\n    GL_FALSE, 0, &texCoordinates[0]);\n            glVertexAttribPointer(VERTEX_POSITION, 3, GL_FLOAT,\n                    GL_FALSE, 0, &vertices[0]);\n            glUniformMatrix4fv( MVP, 1, GL_FALSE,TransformObj->\n    TransformGetModelViewProjectionMatrix());\n            glDrawArrays(GL_TRIANGLE_STRIP, 0, 4); // Draw\n            TransformObj->TransformPopMatrix();//Local Level\n        }\n\n        Model::Render();\n        TransformObj->TransformPopMatrix(); //Parent Level\n    }\n    ```", "```java\n    void Scene::setUpProjection(){\n      TransformObj.TransformSetMatrixMode(PROJECTION_MATRIX );\n      TransformObj.TransformLoadIdentity();\n      int viewport_matrix[4];\n      glGetIntegerv( GL_VIEWPORT, viewport_matrix );\n      TransformObj.TransformOrtho( 0, viewport_matrix[2],\n     viewport_matrix[3], 0 , -1, 1);\n      TransformObj.TransformSetMatrixMode( VIEW_MATRIX );\n      TransformObj.TransformLoadIdentity();\n      TransformObj.TransformSetMatrixMode( MODEL_MATRIX );\n      TransformObj.TransformLoadIdentity(); return;    \n    }\n    ```", "```java\n    Renderer* graphicsEngine; \n    Scene* scene2;\n    Button* buttonUp, *buttonDown, *buttonLeft,\n    Button* buttonRight, *buttonForward, *buttonBackward;\n\n    bool GraphicsInit(){\n       graphicsEngine = new Renderer();    \n    vec2 texCoords[4]={ \n    vec2(0.0, 0.0),\n    vec2(1.0,0.0), \n    vec2(0.0, 1.0), \n    vec2(1.0,1.0) \n    };\n\n    vec3 vertices[4]={ \n    vec3(0.0,0.0,0.0), \n    vec3(400.0,0.,0.),\n                              vec3(0.0,400.0,0.0),\n    vec3(400.0,400.0,0.0)\n    };\n\n        scene2      = new Scene(\"ButtonScene\");    \n        buttonUp     = new Button(scene2, NULL, None,\n    NULL, texCoords, \"dir_up.png\");\n        buttonUp->SetName(std::string(\"Direction Up\"));\n        buttonUp->Translate(50.0, 100, 0.0);\n        buttonUp->Scale(2.0, 2.0, 2.0);\n\n        // MAKE THE buttonUp AS PARENT OF OTHER BUTTONS\n        buttonBackward = new Button(scene2, buttonUp,\n    None, NULL, texCoords, \"dir_down.png\");\n        buttonBackward->SetName(string(\"Direction Backward\"));\n        buttonBackward->Translate(250.0, 0.0, 0.0);\n        buttonBackward->SetCenter(vec3(16, 16, 0));\n        buttonBackward->Rotate(-135.0, 0.0, 0.0, 1.0);\n        // SIMILARLY DEFINE OTHER BUTTONS. . . . .\n     // buttonDown, buttonLeft, buttonRight, buttonForward\n\n        scene2->addModel(buttonUp); // ADD TO THE SCENE\n        graphicsEngine->addScene(scene2);\n        graphicsEngine->initializeScenes(); return true;\n    }\n    ```", "```java\nclass Button : public Model, public GestureEvent\n    {//Multiple code skipped};\nvoid Button::TouchEventDown(float x, float y){\n    GLint viewport_matrix[4]   = { 0, 0, 0, 0 };\n    glGetIntegerv( GL_VIEWPORT, viewport_matrix );\n    glm::vec4 viewport(viewport_matrix[0],viewport_matrix[1],\n                       viewport_matrix[2],viewport_matrix[3]);\n    glm::vec3 win(x, viewport_matrix[3]-y, 0.0);\n    mat4 matMV  = *TransformObj->TransformGetModelMatrix();\n    mat4 matMVP = *TransformObj->TransformGetModelMatrix();\n    glm::vec3 nearPoint = unProject(win, mat, matMVP, viewport);\n    win.z = 1.0;\n    glm::vec3 farPoint = unProject(win, matMV,matMVP, viewport);\n    Ray ray0(nearPoint, farPoint-nearPoint);\n\n    glm::vec3 intersectionPoint;\n    if(IntersectWithRay( ray0, intersectionPoint)){\n        printf(\"Intersect with %s\", this->GetName().c_str());\n        isPicked = !isPicked; clicked = true; return;\n    }\n    Model::TouchEventDown(x,y);\n}\n\nvoid Button::TouchEventRelease( float x, float y ){\n    clicked = false; isPicked = false;\n    Model::TouchEventRelease(x,y);\n}\n```", "```java\nbool Button::IntersectWithRay(Ray ray0, vec3& intersectionPoint){\n    // CHECK INTERSECTION WITH FIRST TRIANGLE\n    mat4 = *TransformObj->TransformGetModelMatrix();\n    p0 = mat * GetEyeCoordinatesFromRoot() * vec4(vertices[0], 1.0);\n    p1 = mat * GetEyeCoordinatesFromRoot() * vec4(vertices[1], 1.0);\n    p2 = mat * GetEyeCoordinatesFromRoot() * vec4(vertices[2], 1.0);\n    if ( intersectLineTriangle(ray0.destination, ray0.direction,\n         vec3(p0.x,p0.y,p0.z), vec3(p1.x,p1.y,p1.z),\n         vec3(p2.x,p2.y,p2.z), intersectionPoint)){\n        return true;\n    }\n\n    // CHECK INTERSECTION WITH SECOND TRIANGLE\n    p0 = mat * GetEyeCoordinatesFromRoot() * vec4(vertices[1], 1.0);;\n    p1 = mat * GetEyeCoordinatesFromRoot() * vec4(vertices[3], 1.0);;\n    p2 = mat * GetEyeCoordinatesFromRoot() * vec4(vertices[2], 1.0);;\n    if ( intersectLineTriangle(ray0.destination, ray0.direction,\n          vec3(p0.x,p0.y,p0.z), vec3(p1.x,p1.y,p1.z),\n          vec3(p2.x,p2.y,p2.z), intersectionPoint)){\n       return true;\n    }\n    return false;\n}\n```", "```java\n       struct ViewPort{ int x, y, width, height; };\n       struct CameraViewParams{ float left, right, bottom, top,\n       front, back; float fov, nearPlane, farPlane; };\n\n       class Camera : public Object{\n       vec3 Forward, Up, Right, Position, Target;\n       CameraType type; // Type of cameras\n\n       protected:\n       int viewport_matrix[4]; ViewPort viewPortParam;\n       CameraViewParams cameraViewParameters;\n\n       public:\n       Camera(string name, Scene* parent = NULL,\n       CameraType camType = perspective);\n\n       void Viewport (int x, int y, int width, int height);\n       virtual void Render ();\n       void Rotate(vec3 orientation, float angle);\n       void MoveForwards( GLfloat Distance );\n       // Similarly,define MoveBackwards, StrafeRightSide etc.\n\n       void SetLeft(float val) {cameraViewParameters.left=val;}\n       // Similarly,define SetRight, SetBottom, SetTop Etc.\n\n       float GetLeft(){ return cameraViewParameters.left; }\n       //Similarly, define GetRight, GetBottom, GetTop etc Etc.\n       vec3 PositionCamera(){return Position + Forward;}\n    };\n    ```", "```java\n    #define DEGREE_TO_RADIAN   M_PI / 180.0f\n    #define RADIAN_TO_DEGREE   180.0f / M_PI\n    #define COS(Angle) (float)cos(Angle*DEGREE_TO_RADIAN)\n    #define SIN(Angle) (float)sin(Angle*DEGREE_TO_RADIAN)\n\n    void Camera::Rotate(vec3 orientation, float angle){\n      if(orientation.x == 1.0){ //Rotate along X axis\n       Forward=normalize(Forward*COS(angle)+Up*SIN(angle));\n       Up     = -cross( Forward, Right ); }\n\n      if(orientation.y == 1.0){ //Rotate along Y axis\n        Forward=normalize(Forward*COS(angle)-Right*SIN(angle));\n        Right  = cross( Forward, Up ); }\n\n      if(orientation.z == 1.0){ //Rotate along Z axis\n       Left = normalize(Right*COS(angle)+Up*SIN(angle));\n       Up   = -cross(Forward, Right); }\n    }\n    ```", "```java\n    void Camera::MoveForwards(GLfloat d){   \n      Position += Forward*d;\n    }\n\n    void Camera::StrafeRightSide(GLfloat d){\n      Position += Left*d;\n    }\n\n    void Camera::StrafeUpside(GLfloat d){\n      Position += Up*d;\n    }\n\n    void Camera::MoveBackwards(GLfloat d){\n      MoveForwards( -d );\n    }\n\n    void Camera::StrafeLeftSide(GLfloat d){\n      StrafeRightSide(-d);\n    }\n\n    void Camera::StrafeDownside(GLfloat d){\n      StrafeUpside(-d); \n    }\n    ```", "```java\n    void Camera::Render(){\n      Scene* scene = dynamic_cast<Scene*>(this->GetParent());\n      Transform* TransformObj = scene->SceneTransform();\n      glViewport( viewPortParam.x, viewPortParam.y,\n      viewPortParam.width, viewPortParam.height );\n      TransformObj->TransformSetMatrixMode(PROJECTION_MATRIX);\n      TransformObj->TransformLoadIdentity();\n\n      if ( type == perspective ){\n         // Multiple code line skipped\n         // Apply perspective view:TransformPerspective\n      }else{\n         // Multiple code line skipped\n         // Apply Orthographic view: TransformOrtho\n      }\n    }\n\n    TransformObj->TransformSetMatrixMode(VIEW_MATRIX);\n    TransformObj->TransformLoadIdentity();\n    vec3 viewPoint = Position + Forward;\n    TransformObj->TransformLookAt(&Position,&viewPoint,&Up);\n\n    TransformObj->TransformSetMatrixMode(MODEL_MATRIX);\n    TransformObj->TransformLoadIdentity();\n    }\n    ```", "```java\n    Camera *camera1, *camera2;\n    bool GraphicsInit(){\n        graphicsEngine = new Renderer();\n        scene1   = new Scene(\"MeshScene\", graphicsEngine);\n        camera1 = new Camera(\"Camera1\", NULL);\n        scene1->addCamera(camera1);\n        // Multiple code lines skipped\n        graphicsEngine->initializeScenes();\n\n        scene2   = new Scene(\"ButtonScene\");\n        camera2 = new CameraHUD(\"Camera2\", scene2);\n        // Multiple code line skipped\n        graphicsEngine->addScene(scene2);\n        graphicsEngine->initializeScenes();}\n\n    bool GraphicsResize(int width, int height){\n       graphicsEngine->resize(width, height);\n       camera1->Viewport(0, 0, width, height);\n       camera2->Viewport(0, 0, width, height);}\n    ```", "```java\nclass CameraHUD : public Camera{\npublic:\n    CameraHUD(std::string name, Scene* parent = NULL);\n    void Render();\n    virtual ~CameraHUD();\n};\n\n   // Code skipped, see sample for CTOR and DTOR definition.\n   void CameraHUD::Render(){ // Render HUD VIEW\n    Scene* scene = dynamic_cast<Scene*>(this->GetParent());\n    glViewport( viewPortParam.x, viewPortParam.y,\n           viewPortParam.width, viewPortParam.height );\n\n    Transform*  TransformObj = scene->SceneTransform();\n    TransformObj->TransformSetMatrixMode(PROJECTION_MATRIX);\n    TransformObj->TransformLoadIdentity();\n\n    glGetIntegerv( GL_VIEWPORT, viewport_matrix );\n    TransformObj->TransformOrtho( viewport_matrix[0],\n       viewport_matrix[2], viewport_matrix[3],\n        viewport_matrix[1] , -1, 1);\n    // Code skipped, Load Model/View Matrix with Identity matrix.\n\n}\n```", "```java\n    void Camera::SetClearColor(glm::vec4 color){\n        clearColor = color;\n    }\n    ```", "```java\n    void Camera::Render(){\n       // Setup Viewport Info\n       glViewport( viewPortParam.x, viewPortParam.y,\n       viewPortParam.width, viewPortParam.height );\n       // Apply scissoring\n       glScissor ( viewPortParam.x, viewPortParam.y,\n       viewPortParam.width, viewPortParam.height );\n\n       glClearColor( clearColor.x, clearColor.y,\n       clearColor.z, clearColor.w );\n       glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n\n       // Reuse code for Setting up Projection/Model/View\n    }\n    ```", "```java\n    Camera *camera1, *camera2, *camera3, *camera4;\n    bool GraphicsInit(){\n        graphicsEngine = new Renderer();\n        scene1  = new Scene(\"MeshScene\", graphicsEngine);\n        camera1 = new Camera(\"Camera1\", scene1);\n        camera2 = new Camera(\"Camera2\", scene1);\n        camera3 = new Camera(\"Camera3\", scene1);\n        camera4 = new Camera(\"Camera4\", scene1);\n        // Multiple code line skipped\n    }\n    ```", "```java\n    bool GraphicsResize( int width, int height ){\n       graphicsEngine->resize(width, height);\n       // Third Quadrant\n       camera1->Viewport(0, 0, width/2, height/2);\n       camera1->SetClearColor(glm::vec4(0.0, 0.0, 0.0, 1.0));\n       // Second Quadrant\n       camera2->Viewport(0, height/2, width/2, height/2);\n       camera2->SetClearColor(glm::vec4(1.0, 1.0, 1.0, 1.0));\n       // Fourth Quadrant\n       camera3->Viewport(width/2, 0, width/2, height/2);\n       camera3->SetClearColor(glm::vec4(1.0, 0.0, 1.0, 1.0));\n       // First Quadrant\n       camera4->Viewport(width/2,height/2,width/2,height/2);\n       camera4->SetClearColor(glm::vec4(1.0, 1.0, 0.0, 1.0));}\n    ```", "```java\nglViewport( viewPortParam.x, viewPortParam.y,\n          viewPortParam.width, viewPortParam.height );\nglScissor ( viewPortParam.x, viewPortParam.y,\n         viewPortParam.width, viewPortParam.height );\nglClearColor( clearColor.x, clearColor.y,\n         clearColor.z, clearColor.w );\nglClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);\n```", "```java\nvoid glScissor(GLint x, GLint y, GLsizei width, GLsizei height);\n```"]