<html><head></head><body>
		<div><h1 id="_idParaDest-66"><em class="italic"><a id="_idTextAnchor134"/>Chapter 4</em>: The App We Are Going to Build</h1>
			<p>In the previous chapters, you learned how to write unit tests and saw an easy example of <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>). When starting TDD, writing unit tests is easy for most people. The hard part is transferring knowledge from writing tests to driving development. What can be assumed? What should be done before we write the first test? What should be tested to end up with a complete app?</p>
			<p>As a developer, you are used to thinking in terms of code. When you see a feature on the requirement list for an app, your brain already starts to lay out the code for this feature. For recurring problems in iOS development (such as building table views), you most probably have already developed your own best practices.</p>
			<p>In TDD, you should not think about the code while working on the test. The tests have to describe what the unit under test should do and not how it should do it. It should be possible to change the implementation without breaking the tests. Thinking like this is the hard part of TDD. You'll need practice before this becomes natural.</p>
			<p>To practice this development approach, we will develop a simple to-do list app in the remainder of this book. It is, on purpose, a boring and easy app. We want to concentrate on the TDD workflow, not complex implementations. An interesting app would distract from what is important in this bookâ€”how to perform TDD.</p>
			<p>This chapter introduces the app we are going to build and shows the views that the finished app will have. </p>
			<p>These are the main topics of this chapter:</p>
			<ul>
				<li>A list of to-do items</li>
				<li>A view for the details of a to-do item</li>
				<li>A view to add to-do items</li>
				<li>The structure of the app</li>
				<li>Getting started in Xcode</li>
			</ul>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor135"/>Technical requirements</h1>
			<p>All the code in this chapter is uploaded (in complete form) here:</p>
			<p><a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter04">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter04</a></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor136"/>A list of to-do items</h1>
			<p>When starting the app (the one we are going to build), the user<a id="_idIndexMarker085"/> sees a list of to-do items on the screen of their iOS device. The items in the list consist of a title, an optional location, and the due date. New items can be added to the list by using an add (<strong class="bold">+</strong>) button, which is shown in the navigation bar of the view. The task list view will look like this:</p>
			<div><div><img src="img/Figure_4.01_B18127.jpg" alt="Figure 4.1 â€“ A list of to-do items&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.1 â€“ A list of to-do items</p>
			<p>As a user, I have the<a id="_idIndexMarker086"/> following requirements:</p>
			<ul>
				<li>I want to see a list of to-do items when I open the app.</li>
				<li>I want to add to-do items to the list.</li>
			</ul>
			<p>In a to-do list app, the user will obviously need to be able to check off items when they are finished. The checked items are shown below the unchecked items, and it is possible to uncheck them again. The app uses the <strong class="bold">Delete</strong> button in the UI of the table view to check and uncheck items. Checked items will be put at the end of the list in a section with the <strong class="bold">Done</strong> header. The UI for the to-do item list will look like this:</p>
			<div><div><img src="img/Figure_4.02_B18127.jpg" alt="Figure 4.2 â€“ To-do items can be checked as Done&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2 â€“ To-do items can be checked as Done</p>
			<p>As a user, I have the following<a id="_idIndexMarker087"/> requirements:</p>
			<ul>
				<li>I want to check a to-do item to mark it as finished.</li>
				<li>I want to see all the checked items following the unchecked items.</li>
				<li>I want to uncheck a to-do item.</li>
				<li>I want to delete all the to-do items.</li>
			</ul>
			<p>When the user taps an entry, the details of this entry are shown in the task detail view.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor137"/>A view for the details of a to-do item</h1>
			<p>The task detail view<a id="_idIndexMarker088"/> shows all the information that's stored for a to-do item. The information consists of a title, due date, location (name and address), and a description. If an address is given, a map with an address is shown. The detail view also allows checking off the item as done. The <strong class="bold">Details</strong> view looks like this:</p>
			<div><div><img src="img/Figure_4.03_B18127.jpg" alt="Figure 4.3 â€“ The view for the details of a to-do item&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3 â€“ The view for the details of a to-do item</p>
			<p>As a user, I have the following requirements:</p>
			<ul>
				<li>I have tapped a to-do item in the list and I want to see its details.</li>
				<li>I want to check a to-do item from its details view.</li>
			</ul>
			<p>You need to be able to add to-do items<a id="_idIndexMarker089"/> to the list. The next section shows what this input view will look like.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor138"/>A view to add to-do items</h1>
			<p>When the user selects the add (<strong class="bold">+</strong>) button in the list view, the task input view is shown. The user can add information<a id="_idIndexMarker090"/> for the task. Only the title is required. The <strong class="bold">Save</strong> button can only be selected when a title is given. It is not possible to add a task that is already on the list. The <strong class="bold">Cancel</strong> button dismisses the view. The task input view will look like this:</p>
			<div><div><img src="img/Figure_4.04_B18127.jpg" alt="Figure 4.4 â€“ The view to add a to-do item to the list&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4 â€“ The view to add a to-do item to the list</p>
			<p>As a user, I have the following<a id="_idIndexMarker091"/> requirements:</p>
			<ul>
				<li>Given that I tapped the add (<strong class="bold">+</strong>) button in the item list, I want to see a form to put in the details (title, optional date, optional location name, optional address, and optional description) of a to-do item.</li>
				<li>I want to add a to-do item to the list of to-do items by tapping on the <strong class="bold">Save</strong> button.</li>
			</ul>
			<p>We will not implement the editing and deletion of tasks, but when you have worked through this book completely, it will be easy for you to add this feature yourself by writing the tests first.</p>
			<p>Keep in mind that we will not test the look and design of the app. Unit tests cannot figure out whether an app looks like it was intended. Unit tests can test features, and these are independent of their presentation. In principle, it would be possible to write unit tests for the position and color of UI elements, but such things are very likely to change a lot in the early stages of development. We do not want to have failing tests only because a button has moved 10 points.</p>
			<p>However, we will test whether the UI elements are present in the view. If your user cannot see the information for the tasks or if it is not possible to add all the information of a task, then the app<a id="_idIndexMarker092"/> does not meet the requirements. </p>
			<p>In the next section, we will discuss the structure of the app we are going to build.</p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor139"/>The structure of the app</h1>
			<p>Before we start to implement the different views of our to-do app, we need to think about the structure<a id="_idIndexMarker093"/> of our app. The app is quite simple on purpose to help keep the focus on the main topic of this book: building an app using TDD.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor140"/>The table view controller, the delegate, and the data source</h2>
			<p>In iOS apps, data is often<a id="_idIndexMarker094"/> presented using<a id="_idIndexMarker095"/> a table view. Table views are highly<a id="_idIndexMarker096"/> optimized for performance; they are easy<a id="_idIndexMarker097"/> to use and implement. We will use<a id="_idIndexMarker098"/> a table view for the<a id="_idIndexMarker099"/> list of to-do items.</p>
			<p>A table view is usually represented by <code>UITableViewController</code>, which is also the data source and delegate for the table view. This often leads to a massive table view controller, because it is doing too much: presenting the view, navigating to other view controllers, and managing the presentation of the data in the table view.</p>
			<p>To reduce the responsibility of the table view controller a bit, we will use the coordinator pattern. This way, a coordinator is responsible for navigating between different views of the app. As our app is quite simple, we will only need one coordinator for the whole app.</p>
			<p>The communication<a id="_idIndexMarker100"/> between the table view <a id="_idIndexMarker101"/>controller and the coordinator class<a id="_idIndexMarker102"/> will be defined using a protocol. Protocols define<a id="_idIndexMarker103"/> what the interface of a class<a id="_idIndexMarker104"/> looks like. This has a great benefit: if we need<a id="_idIndexMarker105"/> to replace an implementation with a better version (maybe because you have learned how to implement the feature in a better way), we only need to develop<a id="_idIndexMarker106"/> against the clear <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>). The inner workings of other classes do not matter.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor141"/>Table view cells</h2>
			<p>As you can see in the preceding<a id="_idIndexMarker107"/> screenshots, the to-do list items have a title and, optionally, they can have<a id="_idIndexMarker108"/> a due date and a location name. The table view cells should only show the set data. We will accomplish this by implementing our own custom table view cell.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor142"/>The model</h2>
			<p>The model of the app consists<a id="_idIndexMarker109"/> of the to-do item, the location, and an item manager, which allows the addition and removal of items and is also responsible for managing the items. Therefore, the controller will ask the item manager for items to present. The item manager will also be responsible for storing the items on disk.</p>
			<p>Beginners often tend to manage the model objects within the controller. Then, the controller has a reference to a collection of items, and the addition and removal of items are directly done by the controller. This is not recommended because if we decide to change the storage of items (for example, using core data), their addition and removal would have to be changed within the controller. It is difficult to keep an overview of such a class as it does many different unrelated things; for this reason, it can be a source of bugs.</p>
			<p>It's much easier to have a clear interface between the controller and the model objects because if we need to change how the model objects are managed, the controller can stay the same. We could even replace the complete model layer if we just keep the interface the same. Later in the book, we will see that<a id="_idIndexMarker110"/> this decoupling also helps to make testing easier.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor143"/>Other views</h2>
			<p>The app will have two<a id="_idIndexMarker111"/> more views: a task detail<a id="_idIndexMarker112"/> view and a task input view.</p>
			<p>When the user<a id="_idIndexMarker113"/> taps a to-do item in the list, the details of the item are presented in the task detail view controller. From the <strong class="bold">Details</strong> screen, the user will be able to check an item.</p>
			<p>New to-do items will be added to the list through an input view. This view will be implemented using SwiftUI.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor144"/>The development strategy</h2>
			<p>In this book, we will build the app<a id="_idIndexMarker114"/> from the inside out. We will start with the model and then build the controllers and networking. At the end of the book, we will put everything together.</p>
			<p>Usually, you would rather build apps feature-by-feature when doing TDD, but by separating based on layers instead of features, it is easier to follow and keep an overview of what is happening. When you later need to refresh your memory, the relevant information you need is easier to find.</p>
			<p>In the next section, we are going to set up the app in Xcode and tweak some Xcode behaviors.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor145"/>Getting started in Xcode</h1>
			<p>Now, let's start our journey by creating a project<a id="_idIndexMarker115"/> that we will implement using TDD. Proceed as follows:</p>
			<ol>
				<li>Open Xcode and create a new iOS project using the <strong class="bold">App</strong> template. </li>
				<li>In the <code>ToDo</code> as the product name, select the <code>Storyboard</code> interface and <code>Swift</code> as the language, and check the box next to <strong class="bold">Include Tests</strong>. Let the <strong class="bold">Use Core Data</strong> box stay unchecked.</li>
			</ol>
			<p>Xcode creates a small iOS project with three targets: one for the implementation code, one for the unit, and one for the UI tests. The template contains code that presents a single view on the screen.</p>
			<ol>
				<li value="3">To take a look at how the app target and test target fit together, select the project in the project<a id="_idIndexMarker116"/> navigator and then select the <code>ToDoTests</code> target. In the <strong class="bold">General</strong> tab, you'll find a setting for the <strong class="bold">Host Application</strong> that the test target should be able to test. It looks like this:</li>
			</ol>
			<div><div><img src="img/Figure_4.05_B18127.jpg" alt="Figure 4.5 â€“ General settings for the test target&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5 â€“ General settings for the test target</p>
			<p>Xcode has already set up the test target correctly to allow the testing of the implementations that we will write to the app target.</p>
			<ol>
				<li value="4">Unfortunately, Xcode also created a test target for UI tests. UI tests are too slow for TDD. To keep the feedback from the test running fast, we need to disable the UI tests for the main scheme. Click the scheme in the <strong class="bold">Build</strong> information bar at the top of the Xcode window and select the <strong class="bold">Test</strong> stage. Next, uncheck the box next to the UI test target. The process is illustrated in the<a id="_idIndexMarker117"/> following screenshot:</li>
			</ol>
			<div><div><img src="img/Figure_4.06_B18127.jpg" alt="Figure 4.6 â€“ Disabling the UI tests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6 â€“ Disabling the UI tests</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor146"/>Setting up useful Xcode behaviors for testing</h2>
			<p>Xcode has a feature called <strong class="bold">Behaviors</strong>. With the use of behaviors<a id="_idIndexMarker118"/> and tabs, Xcode can show useful information depending on its state.</p>
			<p>Open the <strong class="bold">Behaviors</strong> window by navigating to <strong class="bold">Xcode</strong> | <strong class="bold">Behaviors</strong> | <strong class="bold">Edit Behaviors</strong>. On the left-hand side are the different stages for which you can add behaviors (<strong class="bold">Build</strong>, <strong class="bold">Testing</strong>, <strong class="bold">Running</strong>, and so on). These behaviors are useful when doing TDD.</p>
			<p>The behaviors shown here are those that I find useful. Play around with the settings to find the ones most useful for you. Overall, I recommend using behaviors because I think they speed up development.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor147"/>Useful build behaviors</h2>
			<p>When the building starts, Xcode compiles<a id="_idIndexMarker119"/> the files and links them together. To see what<a id="_idIndexMarker120"/> is going on, you can activate the <strong class="bold">Build</strong> log when the building starts. It is recommended that you open the <strong class="bold">Build</strong> log in a new tab because this allows you to switch back<a id="_idIndexMarker121"/> to the code editor when no error occurs<a id="_idIndexMarker122"/> during the build:</p>
			<ol>
				<li value="1"> Select the <strong class="bold">Starts</strong> stage and check <strong class="bold">Show</strong> for <strong class="bold">window tab</strong>. </li>
				<li>Put the name <code>Log</code> into the <strong class="bold">named</strong> field or use an emoji.</li>
				<li> Check <strong class="bold">Show</strong> for <strong class="bold">navigator</strong> and <strong class="bold">Issues</strong>.</li>
				<li>At the bottom of the window, check <strong class="bold">Navigate to</strong> and select <strong class="bold">current log</strong>. After you have made these changes, the settings window will look like this:</li>
			</ol>
			<div><div><img src="img/Figure_4.07_B18127.jpg" alt="Figure 4.7 â€“ Behavior to show the build log when building starts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7 â€“ Behavior to show the build log when building starts</p>
			<ol>
				<li value="5">Build and run to see what the behavior looks like.</li>
			</ol>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor148"/>Testing behaviors</h2>
			<p>I have a window<a id="_idIndexMarker123"/> tab for coding. The name of this tab is ðŸ¤“. Usually, in this tab, the test is open on the left-hand side, and in the <strong class="bold">Assistant Editor</strong> is the code to be tested (or in the case of TDD, the code to be written). It looks like this:</p>
			<div><div><img src="img/Figure_4.08_B18127.jpg" alt="Figure 4.8 â€“ The &lt;?AID d83e?&gt;&lt;?AID dd13?&gt; tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8 â€“ The ðŸ¤“ tab</p>
			<p>When the test starts, we want<a id="_idIndexMarker124"/> to see the code editor again. So, we add a behavior to show the ðŸ¤“ tab. In addition to this, we want to see the <strong class="bold">Test</strong> navigator and debugger with the console view.</p>
			<p>When the test succeeds, Xcode should show a bezel to notify us that all tests have passed. Navigate to the <strong class="bold">Testing</strong> | <strong class="bold">Succeeds</strong> stage and check the <strong class="bold">Notify using system notification</strong> setting. In addition to this, it should hide the navigator and the debugger, because we want to concentrate on refactoring or writing the next test.</p>
			<p>In case the testing fails (which happens a lot in TDD), Xcode should show a notification again. I like to hide the debugger because usually, it is not the best place to figure out what is going on in the case of a failing test. In most cases in TDD, we already know what the problem is.</p>
			<p>You can even make your Mac speak announcements. Check <strong class="bold">Speak announcements using</strong> and select the voice you like but be careful not to annoy your co-workers. You might need their help<a id="_idIndexMarker125"/> in the future.</p>
			<p>Now, the project and Xcode are set up, and we can start our TDD journey.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor149"/>Summary</h1>
			<p>In this chapter, we took a look at the app that we are going to build throughout the course of this book. We took a look at how the screens of the app will look when we are finished with it. We created a project that we will use later on and learned about Xcode behaviors.</p>
			<p>In the next chapter, we will develop the data model of the app using TDD. We will use structs for the model wherever we can because models are best represented in Swift by value types.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor150"/>Exercises</h1>
			<ol>
				<li value="1">Replicate the mock-up screens using a storyboard in Xcode.</li>
				<li>Change the behaviors such that you can figure out if a test failed or if all tests passed without looking at the screen.</li>
			</ol>
		</div>
	</body></html>