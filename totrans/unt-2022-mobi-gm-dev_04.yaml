- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Resolution-Independent UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working on mobile devices, one of the things that you’ll need to spend
    a fair bit of time on is the **user interface**(**UI**). Unlike when developing
    projects for a PC, where you only need to care about a single resolution or aspect
    ratio, there are many different devices out there with different resolutions and
    aspect ratios when building for mobile. For instance, we have phones that can
    fit in one of our pockets, and also tablets, which are huge. Not only that but
    mobile games can also be played horizontally or vertically. Some new phones even
    allow you to fold them to either increase or decrease the screen size dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: A **graphical user interface**(**GUI**) is the way that players interact with
    games. You’ve actually used a GUI in all of the previous chapters (the Unity Editor)
    and also when interacting with your operating system. Without a GUI of some sort,
    the only way you’d be able to interact with a computer is with a **command-line
    interface** (**CLI**) – that is, Command Prompt in Windows and Terminal for Linux
    and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: When working on GUIs, we want them to contain only information that is important
    to the player at any given time while also being simple and intuitive. There are
    people whose main job is programming and/or designing UIs, and there are college
    degrees in the subject as well. So, while we won’t talk about everything to do
    with using GUIs, I do want to touch on the aspects that should be quite helpful
    when working on your own projects in the future.
  prefs: []
  type: TYPE_NORMAL
- en: When building for mobile, it’s very important that you design your UI to be
    resolution-independent – that is, to ensure that the UI will scale and adjust
    itself to fit any screen size that is given to it. As a game developer, you will
    be able to target a large number of devices if your game is resolution-independent
    or responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be split into a number of topics. The chapter is a simple
    step-by-step process from beginning to end. The following is the outline of our
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a title screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding UI elements to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding on-screen controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system** **requirements** section.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a title screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, before we start adding UI elements to our game, let’s first set up some
    groundwork and foundational knowledge by creating something that we will need
    anyway – a title screen:'
  prefs: []
  type: TYPE_NORMAL
- en: To start, we’ll go ahead and create a new scene for us to work with by going
    to **File** | **New Scene**. There will be a window that pops up asking which
    template should be used. In this case, we will select **Basic (Built-in)** and
    then click on the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Creating a Basic scene](img/Figure_4.01_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Creating a Basic scene
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with a UI, we will often want to see a visual representation of
    what will be drawn on the screen, so we will want to make use of 2D mode to have
    a better representation of what our UI will look like in the final version of
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, go to the **Scene** view tab – you’ll see the control bar menu
    with a **2D** button on it underneath that. Click on it, and you should see the
    camera automatically move into something that looks similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Selecting 2D mode](img/Figure_4.02_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Selecting 2D mode
  prefs: []
  type: TYPE_NORMAL
- en: The `Gizmos` are gone due to the fact that the only option is to look perpendicularly
    at the *XY* plane (the *x* axis pointing to the right and the *y* axis pointing
    upward) and that our camera has changed to an orthographic view.
  prefs: []
  type: TYPE_NORMAL
- en: We have to create a **Text** object with the name of our game. Go to the menu
    and select **GameObject** | **UI** | **Text – Text** **Mesh Pro**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is your first time using **TextMeshPro**, there may be a **TMP Importer**
    window that pops up. If so, click on the **Import TMP** **Essentials** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – TMP Importer window](img/Figure_4.03_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – TMP Importer window
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that while this book uses **TextMesh Pro** for drawing text, the following
    steps from the scripting portion also work with the legacy Unity UI system and
    **Text** objects, and all the concepts in this chapter work the same with both
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see three new objects, in the **Hierarchy** view, **Canvas**, **Text
    (TMP)**, and **EventSystem**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Canvas**: This is the area where all of the UI elements will reside, and
    if you try to create a UI element without one already existing, Unity will create
    one for you like it just did here. From the **Scene** view tab, it will draw a
    white rectangle around itself to show you how large it is and will resize itself
    depending on how large the **Game** view is:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Zooming out to display the Canvas](img/Figure_4.04_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Zooming out to display the Canvas
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you double-click on an object in the **Hierarchy** window, the camera will
    automatically move and zoom so you can see the object within the **Scene** window.
    The GameObject contains a **Canvas** component, which allows you to dictate how
    the image will be rendered (and a **Canvas Scaler** component to make your art
    scale, depending on the resolution of the device the game is running on and the
    **Graphic Raycaster** component, which determines whether any objects on the **Canvas**
    have been hit. We will dive into the **Canvas Scaler** component later on in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the **Canvas** object, check out [http://docs.unity3d.com/Manual/UICanvas.html](http://docs.unity3d.com/Manual/UICanvas.html).
    In particular, the discussion on the render modes is quite useful in understanding
    the ways that UI elements can be rendered onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '**Text (TMP)**: This object is our actual text object, which has all of the
    properties that allow us to position the object anywhere on the **Canvas** object
    and change the text, color, size, and so on that will be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more info on TextMesh Pro, check out [https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0/manual/index.html](https://docs.unity3d.com/Packages/com.unity.textmeshpro@3.0/manual/index.html)**.**
  prefs: []
  type: TYPE_NORMAL
- en: '**EventSystem**: This object allows users to send events to objects in our
    game based on various input types, whether keyboard presses, touch events, or
    gamepads. There are properties in this object that allow you to specify how you’d
    like your users to interact with your UI, and if you try to create a UI element
    without one existing, Unity will create one for you as it did here. If you want
    to have any kind of interactive material in your level using Unity’s UI system,
    such as buttons, sliders, and so on, you must have an object with the **EventSystem**
    component attached within the level or the events will not trigger.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the **EventSystem** object, check out [http://docs.unity3d.com/Manual/EventSystem.html](http://docs.unity3d.com/Manual/EventSystem.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, you may or may not see where our textbox was created. If you aren’t
    able to see it, you can go to the **Hierarchy** window and then double-click on
    the **Text (TMP)** object. If all went well, we should have something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Zooming in to the Text (TMP) object](img/Figure_4.05_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Zooming in to the Text (TMP) object
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we will do is make it easier to tell what this object is. So,
    with that in mind, scroll all the way up on the `Title Text`. To make it a bit
    easier to see, with the object selected, go to the **Inspector** tab and scroll
    down to the **TextMeshPro – Text (UI)** component, and then change the **Vertex
    Color** property to **black**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can tell whether the object is going to be visible in the game by seeing
    whether it is within the white box created for **Canvas**. One thing to note is
    that instead of the default **Transform** component that all of the game objects
    we’ve seen so far used, our **Text** object has a **Rect Transform** component
    in the same place.
  prefs: []
  type: TYPE_NORMAL
- en: The Rect Transform component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Rect` `Transform` is different from the regular `Transform` in that while
    the Transform component represents a single point or the center of an object,
    Rect Transform represents a rectangle, in which the UI element will reside. If
    an object with a Rect Transform has a parent, which also has a Rect Transform,
    then the child will specify how the object should be positioned relative to its
    parent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on positioning objects and information on **Rect Transform**,
    check out [http://docs.unity3d.com/Manual/UIBasicLayout.html](http://docs.unity3d.com/Manual/UIBasicLayout.html)**.**
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better idea of what the properties of the `0`, which will center our
    object around the object’s anchors; you can then double-click on the object in
    the **Hierarchy** tab to center the camera at its new position and can zoom in/out
    using the mouse wheel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Title Text centered on the Canvas](img/Figure_4.06_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Title Text centered on the Canvas
  prefs: []
  type: TYPE_NORMAL
- en: Our object’s anchors are visible from the **Scene** tab via four small rectangles,
    creating an X shape in the center of our **Scene** tab, if you have the **Title
    Text** object selected (double-click on it to center the object on the screen).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, note that the white box that is displayed here for
    the **Canvas** may look different on your screen based on the aspect ratio you’ve
    set from the **Game** tab view (mine is set to **Free Aspect**, so it scales based
    on that to fill the space). If you go to the **Game** tab, you can select them
    from the drop-down menu on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll take a look at the two main elements present that work differently
    in the **Rect Transform** component: anchors and pivots.'
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Found inside the `0`, the UI element would stick to the left edge of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties above the anchors are your position relative to the anchor that
    has been set. This can be quite useful when it comes to things such as supporting
    multiple resolutions without scaling the art assets created. In our case, we will
    want to have our title position itself relative to the top of the camera. Let’s
    look at the steps to take when working with anchors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Anchor Presets** menu in the upper-left corner of the **Rect
    Transform** component (the box to the left of the **Pos X** and **Width** values).
    From there, it shows some of the most common anchor positions used in games for
    easy selection. In our case, we will want to pick the top-center option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Selecting the top-center option on the Anchor Presets menu](img/Figure_4.07_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Selecting the top-center option on the Anchor Presets menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that after selecting it, the `-290`). This is saying that our object is
    positioned `0`, the object would be centered along the *y* **axis**’s anchor,
    which would place the object with half of it off the screen, which is not good,
    as you can see in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Changing Pos Y to 0](img/Figure_4.08_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Changing Pos Y to 0
  prefs: []
  type: TYPE_NORMAL
- en: I placed the tab to make it easier to see the issue; you can do this by dragging
    and dropping the tab to the edge of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: To reset any layout changes, you may go to the **Layout** menu in the top-right
    part of the screen and select **Default**.
  prefs: []
  type: TYPE_NORMAL
- en: If we changed our object’s value to `-25` (subtracting half its value), it would
    be positioned correctly. However, hardcoding this value will be an issue if we
    decide we want to change the value later on, as we will have to remember to adjust
    this again. It would be a lot nicer if we had something to make at `0` the edge
    of the map relative to our height, and, thankfully, we have the property to fix
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change the `1` and then change `0` if you changed it previously and it
    doesn’t change automatically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Adjusting Pivot and Pos Y values](img/Figure_4.09_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Adjusting Pivot and Pos Y values
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the text is now hugging the top due to the pivot setting being
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: Pivots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`0`, `0.5`, and `1`, and note the differences in how things are rotated.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is possible to set the **Pivot**, **Position**, and **Anchors settings**
    of an object via the **Anchors Preset** menu I mentioned previously if you hold
    down the *Alt* **+** *Shift*keys while clicking on the object. This way, all of
    the steps we discussed will happen all at once, but it’s a good idea to get a
    foundation of what everything means before jumping straight into using shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of how to work within the m space, let’s
    start finalizing our **Title** **Text** object.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting and resizing the title text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our object positioned correctly, let’s give some visual flair
    to our title text using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Endless Roller` and set the `40`. Note that now the text shows up
    in two lines and is not within the confines of the size that we defined in the
    **Rect** **Transform** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Settings used for the TextMeshPro - Text (UI) component](img/Figure_4.10_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Settings used for the TextMeshPro - Text (UI) component
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, scroll up to `300``50`. We will also want it to be offset
    from the top of the world, so let’s change `-30` to give it a little offset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 4.11 –\uFEFF Offsetting the title text](img/Figure_4.11_B18868.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Offsetting the title text
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this looks great for this resolution; however, if we were to play the
    game at a larger resolution, it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Current state of the title screen](img/Figure_4.12_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Current state of the title screen
  prefs: []
  type: TYPE_NORMAL
- en: Having a UI that doesn’t scale can be good if you’re trying to have a (component
    to adjust how the screen will change based on the resolution we give it.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Canvas** object from the **Hierarchy** component, and then from
    the **Inspector** window, go to the **Canvas Scaler** component. From there, change
    **UI Scale Mode** to **Scale with** **Screen Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key property here is **Reference Resolution**. This is the resolution that
    we want to base our menu on—if the resolution is made bigger, it will scale up;
    if it’s made smaller, it will scale down. You will likely have a resolution in
    mind based on your mockups or an image file you’ve made; however, for reference,
    the following are some of the most common screen resolutions at the time of writing
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some sample Apple device resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device Name** | **Resolution** |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 12 Pro Max/13 Pro Max | 2778 x 1284 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 12/12 Pro/13 Pro | 2532 x 1170 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 12/13 | 2532 x 1170 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 12 mini/13 mini | 2340 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 11 Pro Max | 2688 x 1242 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 11 Pro | 2436 x 1125 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 11 | 1792 x 828 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 14 Pro Max | 2796 x 1290 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 14 Pro | 2556 x 1179 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 14 | 2532 x 1170 (Same as 12/13) |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 14 Plus | 2778 x 1284 (Same as Phone 12 Pro Max/13 Pro Max) |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone SE (2020) | 1334 x 750 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone XS Max | 1242 x 2688 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone XS | 1125 x 2436 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone XR | 828 x 1792 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone X | 2436 x 1125 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 7 Plus/8 Plus | 1080 x 1920 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 7/8 | 750 x 1334 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 6S Plus | 1080 x 1920 |'
  prefs: []
  type: TYPE_TB
- en: '| iPhone 6S | 750 x 1334 |'
  prefs: []
  type: TYPE_TB
- en: '| iPad Pro (1st-5th gen 12.9”) | 2048 x 2732 |'
  prefs: []
  type: TYPE_TB
- en: '| iPad 9th gen | 2160 x 1620 |'
  prefs: []
  type: TYPE_TB
- en: '| iPad Air 4th gen | 2388 x 1668 |'
  prefs: []
  type: TYPE_TB
- en: '| iPad Mini (6th gen) | 2266 x 1488 |'
  prefs: []
  type: TYPE_TB
- en: 'Here are some sample Android device resolutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Device Name** | **Resolution** |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S22 Ultra | 3080 x 1440 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S22 | 2340 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy Z Fold3 | 2208 x 1768 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S20 Ultra/S21 Ultra | 3200 x 1440 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S20/S21 | 2400 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Note 10+ | 2280 x1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 5 XL | 2960 x 1440 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 5 | 2340 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 4 XL | 1440 x 2960 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 4 | 2280 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S10/S10+ | 3040 x 1440 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 3 XL | 2960 x 1440 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 3/3a XL | 2160 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 3a | 2220 x 1080 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S8/S8+ | 2960 x 1440 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel 2 XL | 2560 x 1312 |'
  prefs: []
  type: TYPE_TB
- en: '| Nexus 6P | 1440 x 2560 |'
  prefs: []
  type: TYPE_TB
- en: '| Nexus 5X | 1080 x 1920 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel/Pixel 2 | 1080 x 1920 |'
  prefs: []
  type: TYPE_TB
- en: '| Google Pixel XL/Pixel 2 XL | 1440 x 2560 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy Note 5 | 1440 x 2560 |'
  prefs: []
  type: TYPE_TB
- en: '| LG G5 | 1440 x 2560 |'
  prefs: []
  type: TYPE_TB
- en: '| One Plus 3 | 1080 x 1920 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S7 | 1440 x 2560 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy S7 Edge | 1440 x 2560 |'
  prefs: []
  type: TYPE_TB
- en: '| Nexus 7 (2013) | 1200 x 1920 |'
  prefs: []
  type: TYPE_TB
- en: '| Nexus 9 | 1536 x 2048 |'
  prefs: []
  type: TYPE_TB
- en: '| Samsung Galaxy Tab 10 | 800 x 1280 |'
  prefs: []
  type: TYPE_TB
- en: '| Chromebook Pixel | 2560 x 1700 |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To see a list of popular cell phone screen resolutions, check out [http://screensiz.es/phone](http://screensiz.es/phone)
    or [https://www.ios-resolution.com/](https://www.ios-resolution.com/).
  prefs: []
  type: TYPE_NORMAL
- en: I am using a Google Pixel 3a XL, which has a resolution of 2160 x 1080, and
    an iPhone 13 Pro Max, which has a 2778 x 1284 resolution, so I think that would
    be a good place to start. However, if you are creating art assets, it’s a good
    idea to create the UI at the largest resolution you plan on supporting and then
    build for other resolutions from there.
  prefs: []
  type: TYPE_NORMAL
- en: Unity has some of the most common resolutions built in, which can be seen/changed
    from the dropdown in the window view mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 4. In the `1920 x 1080` if it isn’t there already.
  prefs: []
  type: TYPE_NORMAL
- en: 5. Next, under **Match**, move it all the way over to **Height**. This will
    ensure that when the height of our screen changes, that’s when we will modify
    the scale of our UI.
  prefs: []
  type: TYPE_NORMAL
- en: '6. Next, let’s make the text a bit larger. Select the `1000` and `200`, and
    then change the `130`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.13 – Adjusting the \uFEFFtitle text to be large](img/Figure_4.13_B18868.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Adjusting the title text to be large
  prefs: []
  type: TYPE_NORMAL
- en: '7. Now, if we play the game with a higher resolution, it will display our title
    nicely, scaling up to fit the larger size that we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Scaling the title screen](img/Figure_4.14_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Scaling the title screen
  prefs: []
  type: TYPE_NORMAL
- en: '8. Go to the **Game** view control bar and pick a smaller resolution, such
    as **800x480 Landscape (800x480)**, and you’ll note that the text will scale down
    to fit nicely as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Title screen at a smaller resolution](img/Figure_4.15_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Title screen at a smaller resolution
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Canvas Scaler** component will adjust the size of the
    text depending on the resolution of the device. Next, we will see how we can quickly
    test different resolutions as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the **Canvas Scaler** component, check out [https://docs.unity3d.com/Manual/script-CanvasScaler.html](https://docs.unity3d.com/Manual/script-CanvasScaler.html).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting different aspect ratios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned previously, in the **Game** view, if we go to the control bar
    and select the first option, there is a drop-down menu where we can pick different
    resolutions to test our game, so we can find potential issues before exporting
    it to our devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Different resolution options](img/Figure_4.16_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Different resolution options
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of resolutions built in for us by default, but we can also
    make our own using the **+** button at the bottom. I suggest that you make two
    new selections for your phone for landscape mode and for portrait mode at the
    resolutions you are trying to reach if they’re not included by default (in my
    case, 1920 x 1080, 1080 x 1920, 2778 x 1284, and 1284 x 2778):'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, at this point, we can see that in a landscape ratio, it works fairly well,
    but let’s try a portrait one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Current Portrait view](img/Figure_4.17_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Current Portrait view
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! Currently, the text is overflowing past the bounds of the screen. Looks
    like will have to fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `200`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, go to the `0.25` and `0.75`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Setting the Anchors values](img/Figure_4.18_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Setting the Anchors values
  prefs: []
  type: TYPE_NORMAL
- en: Note that the and values. They have now been replaced with the and properties,
    which are currently set to `-338` and `-338`. This means that the area being taken
    up by this is `-338` units away from our anchor at 25%, and `-338` units away
    from our max anchor at 75%. We want the screen to resize to be at those anchors,
    so we will change both the and values to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save our Scene as a new file inside the `Scenes` folder called `MainMenu`,
    and then play the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – The title text automatically adjusts to fit the screen](img/Figure_4.19_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – The title text automatically adjusts to fit the screen
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, the text now fits a lot nicer. You’ll
    also note that no matter what resolution we are using, this text takes up an amount
    of room that’s fitting for the game’s title. Now that we have the text displaying
    correctly, let’s add the ability to move from the main menu into the game properly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike our title, for things that we want our players to touch, it’s a good
    idea to make the buttons the same size in each device, as our fingers are the
    same size, no matter what device we are using. To show a possible solution for
    this, we will create a new Canvas using a different scaling technique:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the game if it is currently running. We will first rename our current `Canvas
    - Scale w/Screen`. This way, we can easily tell whether we are using the correct
    Canvas for this or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have that one ready, we can create our new one. Go to the top menu
    bar and then select `Canvas - Scale Physical`. Then, under the **Canvas Scaler**
    component, change **UI Scale Mode** to **Constant** **Physical Size**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Creating a Physical Canvas](img/Figure_4.20_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – Creating a Physical Canvas
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, Unity will attempt to scale the size of this Canvas so that
    each element has the same physical size, regardless of the resolution. Since we’re
    going for buttons that we intend to press with our fingers, this makes a lot of
    sense.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with this Canvas (**Canvas - Scale Physical**) selected in the **Hierarchy**
    view, go to the menu and select **GameObject** | **UI** | **Button - TextMeshPro**
    to create a new button inside this Canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also do this by right-clicking on the `Canvas - Scale Physical`object
    from the **Hierarchy** window and selecting **UI | Button -** **TextMeshPro**.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you will see a new child object to called child also:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.21 – Showing off the Te\uFEFFxt (TMP) object](img/Figure_4.21_B18868.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Showing off the Text (TMP) object
  prefs: []
  type: TYPE_NORMAL
- en: The next question is, what size should our buttons be? Google suggests in their
    Material guidelines for Android that at least 48 x 48 for short), whereas, at
    their (**WWDC**), Apple recommended at least 44 x 44 dp. Either way, that comes
    somewhere around 8mm x 8mm, or 0.3 inches x 0.3 inches.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To read the material guidelines, check out [https://material.io/design/layout/spacing-methods.html#touch-click-targets](https://material.io/design/layout/spacing-methods.html#touch-click-targets).
    Or for Material 3’s guidelines, check out [https://m3.material.io/components/buttons/specs#85e63496-f905-4978-ae35-69ab83b70536](https://m3.material.io/components/buttons/specs#85e63496-f905-4978-ae35-69ab83b70536)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to look at the game right now and check out some of the different
    resolution options, you may be a bit scared due to the size of the button, depending
    on the resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Small button](img/Figure_4.22_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Small button
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s because our button size is assuming that the (value to to see something
    closer to what we’ll use on our device when we play there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Game at a 16:9 aspect ratio](img/Figure_4.23_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Game at a 16:9 aspect ratio
  prefs: []
  type: TYPE_NORMAL
- en: Stop the game if it is currently running. Afterward, from the `Play`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in finding out what the DPI for your devi[c](http://dpi.lv/)e
    is, check out [http://dpi.lv/](http://dpi.lv/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s make some adjustments to the **Button** object itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Play Button` at the top of the **Inspector** window to make it clear
    what the object is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to the `0` to center the button in the middle of the screen. Afterward,
    the size of the button is quite large, so let’s change the `75``35`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Adjusting the button’s size](img/Figure_4.24_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – Adjusting the button’s size
  prefs: []
  type: TYPE_NORMAL
- en: We now have a button, but it doesn’t actually do anything yet. Let’s fix that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a script to contain the functionality that we want. From the `Scripts``MainMenuBehaviour`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your IDE has opened, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `LoadLevel` function will load a level based on the name that we provide
    to it making use of Unity’s Scene Manager, which we added using a statement at
    the top of our code so that we would have access to that namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script and go back to the Unity editor. To call Unity’s UI events from
    the editor, we will need to have a game object with the `MainMenuBehaviour` component
    attached to it to call this function. We could use one of the currently existing
    objects, but we’ll just create a new object, making it easier to be found in the
    future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that in mind, create an empty game object (`Main Menu` and then add the
    `MainMenuBehaviour` script to it. Then, drag and drop it to the top of the **Hierarchy**
    tab to make it easier to access in the future and reset its position for the sake
    of neatness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Creating the Main Menu object](img/Figure_4.25_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – Creating the Main Menu object
  prefs: []
  type: TYPE_NORMAL
- en: Select your **Play Button** object from **Hierarchy**, go to the **Inspector**
    tab, and scroll down to the **Button** component from there. Then, in the **On
    Click ()** section, click on the **+** icon to add something for our button to
    do.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, drag and drop the **Main Menu** object from the **Hierarchy** tab into
    the area that currently says **None (Object)**, which is added to the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the dropdown that currently says `Gameplay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Adding functionality to the button](img/Figure_4.26_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – Adding functionality to the button
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your scene by going to **File | Save**. Lastly, open **Build Settings**
    as we did before by going to **File** | **Build Settings** and add our **MainMenu
    scene** to the list at index **0** by selecting **Add Open Scenes** and then dragging
    the **MainMenu** level to the top, so that the main menu level will be the scene
    that starts off when we start the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Starting the game with the main menu](img/Figure_4.27_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 – Starting the game with the main menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Save your project and Scene, then click on the **Play** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Current state of the main menu](img/Figure_4.28_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Current state of the main menu
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our main menu is working well, and we can get into the game
    without any issues by clicking on the **Play** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Current state of the gameplay scene](img/Figure_4.29_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – Current state of the gameplay scene
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a foundational knowledge of the UI system and we have our
    title screen, we will move on to building something else that most games will
    need: a pause menu.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a pause menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When playing games, especially mobile games, there may come a time when you
    need to stop playing them at any moment. Having a pause menu will allow our players
    the convenience of deciding when they want to stop the game in its current state
    and resume it at a time that is convenient for them. This will also allow us to
    dive into some additional concepts in using Unity’s UI system, so with that in
    mind, let’s start building one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Assets/Scenes` folder, and double-clicking on **Gameplay**, saving
    the **MainMenu** level if you didn’t do so already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Opening the Gameplay scene](img/Figure_4.30_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 – Opening the Gameplay scene
  prefs: []
  type: TYPE_NORMAL
- en: Before we worry about how we are going to open our pause menu, let’s go ahead
    and create the pause menu that we’ll be opening first.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we’ll do is dim our screen when we enter the pause menu. An
    easy way to do that is to have an image scale to cover our entire screen, which
    is what the **Panel** object does by default. We can create it by selecting **Game
    Object** | **UI** | **Panel**. Note that this creates a **Canvas** object and
    an **EventSystem** object in addition to the **Panel** object, as one doesn’t
    exist in this scene already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename the `Pause` `Menu`. Then, with the object selected from the`178`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Setting the Panel’s color](img/Figure_4.31_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 – Setting the Panel’s color
  prefs: []
  type: TYPE_NORMAL
- en: The component works in a similar manner to for 2D games, with information on
    an image to draw and the color to use for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to the **Game** window to get a better look at what the **Panel** object
    is doing to the screen. The current image has a thin border, which I’m not a fan
    of, in this case. You may keep it if you’d like, but I’m going to remove it and
    change the **Source Image** value to **None (Sprite)** by selecting the current
    one and pressing the *Delete* key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Creating the backdrop](img/Figure_4.32_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 – Creating the backdrop
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this, we will need to populate the menu with content. In this
    case, we will have a object saying that the game is paused, and some buttons allowing
    the player to resume, restart, or return to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create another panel to hold our pause menu contents. We want this panel
    to be a child of our **Pause Menu** object, so we can do this easily by going
    to the **Hierarchy** window, right-clicking on **Pause Menu**, and selecting **UI**
    | **Panel**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Creating a child via the Hierarchy window](img/Figure_4.33_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.33 – Creating a child via the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: Now, for this panel, I don’t want it to take up the entire screen, so I will
    use another component to modify its size based on the resolution we receive. In
    this case, I will use an **Aspect Ratio** **Fitter** component.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Aspect`. From there, select **Aspect Ratio Fitter** and then press the
    *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterward, go to our newly added component and change the value to `Fit In Parent`
    to ensure that the panel will always fit within our screen and set to `0.5`. This
    means that the panel will be twice as high as it is wide (width over height, which
    means ½ or `0.5`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you go to the **Game** window and switch aspect ratios, you’ll note that
    the menu will stay in a similar shape.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the **Aspect Ratio Fitter** component, check out [https://docs.unity3d.com/Manual/script-AspectRatioFitter.html](https://docs.unity3d.com/Manual/script-AspectRatioFitter.html).
  prefs: []
  type: TYPE_NORMAL
- en: This is good, but I don’t want to have the panel stuck directly to the edge
    of our screen, so we will make this object invisible by clicking on the checkmark
    by the **Image** component. This will disable the component and stop the component’s
    functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, right-click on the `Pause Menu Contents` and then change the `10`to give
    us a border around the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will use physical buttons like last time, so let’s move to the **Canvas**
    object, and under the **Canvas Scaler** component, change **UI Scale Mode** to
    **Constant** **Physical Size**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.34 – Pause Menu Contents setup](img/Figure_4.34_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.34 – Pause Menu Contents setup
  prefs: []
  type: TYPE_NORMAL
- en: 'We could place everything manually as we did previously, but in this case,
    we may want to use another feature that Unity’s UI system has: layout groups.'
  prefs: []
  type: TYPE_NORMAL
- en: will resize the children of an object so that a component will automatically
    fit the area of the parent. There are several different layout groups, including
    grid-based, horizontal, and vertical layout groups. In our case, the menu will
    probably be vertical.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Unity’s way of automatically creating layouts, check
    out [https://docs.unity3d.com/Manual/UIAutoLayout.html](https://docs.unity3d.com/Manual/UIAutoLayout.html).
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Vertical Layout Group` and select **Vertical Layout Group** by pressing
    the *Enter* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s create some children to fit into our menu. From the **Hierarchy** window,
    right-click on the **Pause Menu Contents** object and select **UI** | **Button
    -** **TextMeshPro**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This creates a button, but you’ll note that it looks pretty much like a normal
    button. Let’s open up its child `Resume`. Then, we’ll check the `0`. To keep all
    of the button text on one line, we can also change the `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Afterward, select the **Pause Menu Contents** object, and under the **Inspector**
    window, go to the **Vertical Layout Group (Script)** component and change the
    **Child Alignment** value to **Middle Center**. Then, change the **Child Control
    Size** value to have **Width** toggled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, in the `5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will add five pixels of padding in each direction within all of the children
    of the layout group.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Adding padding](img/Figure_4.35_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.35 – Adding padding
  prefs: []
  type: TYPE_NORMAL
- en: Now, duplicate this button twice and change the text to `Restart``Main Menu`.
    Then, to make it easy to tell the difference between them, let’s change the objects’
    names to `Resume Button`, `Restart Button`, and `Main` `Menu Button`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, right-click on the `Paused``0``30`. Note how the order in which the children
    are placed in the hierarchy changes the order in which they are displayed. With
    that in mind, drag the **Text** object to the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.36 – Pause Menu setup](img/Figure_4.36_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.36 – Pause Menu setup
  prefs: []
  type: TYPE_NORMAL
- en: This looks nice, but there’s also a lot of spacing here. So, if we’d like, we
    can instead condense the contents of our menu to just fit what we have there.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we can go to **Hierarchy** and select the **Pause Menu Contents**
    object and then add a **Content Size Fitter** component. Once it is added, we
    will change **Vertical Fit** to **Preferred Size**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Effect of the preferred size option](img/Figure_4.37_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.37 – Effect of the preferred size option
  prefs: []
  type: TYPE_NORMAL
- en: 'This will scrunch all the buttons together, so we can change the `5` and add
    some space between the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Current view of the pause menu](img/Figure_4.38_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.38 – Current view of the pause menu
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the buttons themselves, let’s actually make them do something.
    In the `Scripts` folder and create a new C# script called `PauseScreenBehaviour`**,**
    and double-click on it to open up the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once it’s opened, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this script, we will first use a `static` variable, which is called `paused`.
    When we declare a `static` variable, we ensure that there will only ever be one
    of those variables inside this class, which all instances will share. One of the
    advantages of this is that we can access the property in other scripts using the
    class name followed by a period and then the attribute’s name (in this case, `PauseScreenBehaviour.paused`).
    We will use this concept later on when we want to open the menu through code.
  prefs: []
  type: TYPE_NORMAL
- en: We then have two public functions, which we will call via the UI elements. First,
    we have a `Restart` function, which will use Unity’s Scene Manager to return us
    to the currently loaded level, effectively restarting the game. It is important
    to note that `static` variables do not reset when restarting in Unity, so that’s
    why I set `paused` to `false` in the `Start` function to ensure that when we come
    to the level, it is unpaused.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a `SetPauseMenu` function, which will turn the pause menu on
    or off based on the value of `isPaused`. It also sets the `Time.timeScale` property,
    where `0` means that nothing will happen and `1` means normal time. This property
    will modify the `Time.deltaTime`variable, effectively canceling out movement that
    we have as long as we use it.
  prefs: []
  type: TYPE_NORMAL
- en: Save your script and dive back into Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we’ll create a new empty game object by going to `Pause Screen Handler`
    and then attach the **Pause Screen Behaviour (Script)** component to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, assign the **Pause Menu** variable to the **Pause Menu** game object
    in the **Hierarchy** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Assigning the Pause Menu property](img/Figure_4.39_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.39 – Assigning the Pause Menu property
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the script, we can now change the buttons to actually do something.
    Go to the **Inspector** window with the **Resume Button** object selected, go
    to the **Button** component’s **On Click ()** section, and click on the **+**
    button to add an action to occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop the `false` due to not being checked, so this should work for
    us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Calling the SetPauseMenu function from the Resume button](img/Figure_4.40_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.40 – Calling the SetPauseMenu function from the Resume button
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, do the same for the `Restart`function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, do the same for the `LoadLevel` and put the name of our main menu level
    in the string place (`MainMenu`, in my case).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `PauseScreenHandler` script already contains `LoadLevel``MainMenuBehaviour`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save our game and go ahead and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.41 – The current state of the game](img/Figure_4.41_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding screenshot, if we start the game, the menu appears
    correctly—we can click the **Main Menu** button to get to the main menu, and **Resume**
    continues the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have some issues: once the menu is gone, there is no way
    to get it back; the game should start unpaused, and the game should actually pause.
    Let’s tackle these issues next.'
  prefs: []
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get the game to pause correctly, we will tweak some scripts we’ve written
    previously using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `PlayerBehaviour` script and add the code highlighted in bold to the
    `FixedUpdate` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The added code makes it so that if the game is paused, we will not do anything
    within the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then also need to add the same script to the top of the `Update` function
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save your script and return to the Unity editor. Now, the game, by default,
    should be unpaused, so let’s go ahead and select the **Pause Menu** object in
    the **Hierarchy** view and then click on the active button in the **Inspector**
    view to disable it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.42 – Disabling the pause menu](img/Figure_4.42_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.42 – Disabling the pause menu
  prefs: []
  type: TYPE_NORMAL
- en: Save your scene and then go ahead and play the game. While playing, hit the
    *Esc* key and you should see the pause menu appear and the game is paused! We
    can also use **Resume** or hit *Esc* again to resume the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.43 – The current state of the game](img/Figure_4.43_B18868.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.43 – The current state of the game
  prefs: []
  type: TYPE_NORMAL
- en: This is great, but it will only work if our player has a keyboard or controller
    attached to it. In the next chapter, we will see how we can have a button that
    players can click to turn on the menu. In addition, we may want to be able to
    move the player using some visual on-screen UI menu. That’s what we will tackle
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that, we’ve got a good foundation to build on when creating UI elements
    for a mobile game. We first covered how to create a title screen, making use of
    buttons and **Text** objects. We then covered how to use panels, buttons, text,
    and layout groups to make your menus adapt to the size of your elements. We also
    touched on how layout groups can arrange our objects to fit in a pleasing manner.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue our exploration of UIs for games by seeing
    how we can add a pause screen button and an on-screen joystick, and adapting our
    GUIs for notch devices.
  prefs: []
  type: TYPE_NORMAL
