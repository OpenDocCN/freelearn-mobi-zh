<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Behavioral Patterns – Visitor, Interpreter, and Memento</h1></div></div></div><p>In this chapter, we will complete our discovery trip of the 23 Gang of Four patterns. Now, let's have a look at the three last design patterns of the behavioral patterns category. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The visitor pattern</li><li class="listitem" style="list-style-type: disc">The interpreter pattern</li><li class="listitem" style="list-style-type: disc">The memento pattern</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec37"/>The visitor pattern</h1></div></div></div><p>In this <a class="indexterm" id="id384"/>section, we <a class="indexterm" id="id385"/>will talk about the visitor pattern, which allows us to separate data and their associated treatments.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec138"/>Roles</h2></div></div></div><p>The <a class="indexterm" id="id386"/>visitor pattern allows us to externalize and centralize the actions that must be executed on object; these objects cannot have any links between them.</p><p>These actions will not be implemented in the class of the objects but in external classes.</p><p>So, this allows us to add any action in an external class, even a concrete visitor that implements <a class="indexterm" id="id387"/>
<strong>IVisitor</strong>.</p><p>This pattern can be used when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We need to add functionalities to a group of classes without weighing down these classes</li><li class="listitem" style="list-style-type: disc">A group of classes have a fixed structure and we need to add some functionalities to them without modifying their interface</li></ul></div><p>The visitor<a class="indexterm" id="id388"/> pattern must be applied and used when you need to perform operations on objects of a collection that do not share a common base class or conform to a common protocol.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec139"/>Design</h2></div></div></div><p>The <a class="indexterm" id="id389"/>following diagram shows us how objects and treatments are separated. Treatments are implemented in the <code class="literal">ConcreteVisitor</code> classes. The objects are implemented in the <code class="literal">ConcreteElement</code> classes, as shown in the following figure:</p><div><img alt="Design" src="img/4852_08_01.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec140"/>Participants</h2></div></div></div><p>The following<a class="indexterm" id="id390"/> are the visitor pattern participants:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Visitor</code>: This<a class="indexterm" id="id391"/> interface introduces the signature of the methods that realize a functionality in a group of classes. There is one method per class that receives an instance of this class as an argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteVisitors</code>: This <a class="indexterm" id="id392"/>implements methods that realize the functionality that correspond to the classes. This functionality is distributed in different elements.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Element</code>: This <a class="indexterm" id="id393"/>is an abstract class of the concrete elements class. It introduces the <code class="literal">accept(visitor)</code> method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ConcreteElements</code>: This<a class="indexterm" id="id394"/> implements the <code class="literal">accept()</code> method, which consists of calling the visitor through the method that corresponds to the class.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec141"/>Collaboration</h2></div></div></div><p>A<a class="indexterm" id="id395"/> client that uses a visitor needs to create an instance of a visitor in the class of its choice and then pass it as an argument to the accept method of a group of elements.</p><p>The element then calls the the visitor method that corresponds to its class. A reference to itself is sent back to the visitor that allows it to access its internal structure.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec142"/>Illustration</h2></div></div></div><p>We are a car <a class="indexterm" id="id396"/>seller having three brands: DS, Renault, and Citroen, and each of them has a price.</p><p>We want to be able to modify the price without modifying our car concrete classes. For this, we will introduce our visitor pattern.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec143"/>Implementation</h2></div></div></div><p>For this<a class="indexterm" id="id397"/> last chapter, we will use Playground. Now, open the <code class="literal">VisitorPattern.playground</code> file and let's have a look at how this works.</p><p>Here, we will use a technique called <strong>Double Dispatch</strong><a class="indexterm" id="id398"/> that will allow us to perform the appropriate actions depending on the type of the object . This technique also help us to avoid making some type casting to perform the appropriated operation. (see the following URL to get more information: <a class="ulink" href="https://en.wikipedia.org/wiki/Double_dispatch if you need more informations about this technique">https://en.wikipedia.org/wiki/Double_dispatch if you need more informations about this technique</a>)</p><p>First, we define our visitor protocol. The visitor has three visit methods having a <code class="literal">ConcreteElement</code> as an argument to accept each car type, as shown:</p><div><pre class="programlisting"> protocol CarVisitor {
  func visit(car: DSCar)
  func visit(car: RenaultCar)
  func visit(car: CitroenCar)
}</pre></div><p>Then, we define our <code class="literal">Car</code> protocol. A car can accept a concrete <code class="literal">CarVisitor</code> object:</p><div><pre class="programlisting">protocol Car {
  func accept(visitor: CarVisitor)
}</pre></div><p>We can easily <a class="indexterm" id="id399"/>implement our three concrete cars. Each of them has a default price and also the <code class="literal">accept</code> method having a concrete <code class="literal">Visitor</code> object as an argument:</p><div><pre class="programlisting">class DSCar: Car {
  var price = 29000.0
  func accept(visitor: CarVisitor) { visitor.visit(self) }
}
class RenaultCar: Car {
  var price = 17000.0
  func accept(visitor: CarVisitor) { visitor.visit(self) }
}
class CitroenCar: Car {
  var price = 19000.0
  func accept(visitor: CarVisitor) { visitor.visit(self) }
}</pre></div><div><div><h3 class="title"><a id="note22"/>Note</h3><p>The <code class="literal">accept</code> method defined by the <code class="literal">Car</code> protocol and implemented by the classes is the key to the double dispatch technique. By sending <code class="literal">self</code> as argument to the <code class="literal">visitor.visit</code> method, where visitor is our concrete visitor implementation of <code class="literal">CarVisitor</code>, Swift will choose the version of the <code class="literal">visit</code> method with the most specific type.</p></div></div><p>Lastly, we must implement our concrete visitor, our visitor is in charge of modifying the price of the <code class="literal">Element</code> class. The <code class="literal">Element</code> class modification depends on the type of object passed in the argument.</p><p>The DS car will see its price modified by 20 percent and the price of Renault and Citroen cars modified by 10 percent:</p><div><pre class="programlisting">class PriceVisitor: CarVisitor {
  var price = 0.0
  func visit(car: DSCar)  { price = car.price * 0.8  }
  func visit(car: RenaultCar) { price = car.price * 0.9 }
  func visit(car: CitroenCar)  { price = car.price * 0.9 }
}</pre></div><p>The client will be simulated with the following code. We will first instantiate our three car objects and add them in a <code class="literal">Car</code> array. Then we will define a new variable <code class="literal">price</code>, which is an array containing our three new prices.</p><p>For this, we will <a class="indexterm" id="id400"/>use the <code class="literal">map</code> function that is an extension of the array type. It allows us to execute a treatment on each element of the array. Here we can (for each element) instantiate a <code class="literal">PriceVisitor</code> object and pass it in the <code class="literal">accept</code> method of the current <code class="literal">car</code> object.</p><p>Then we return the new <code class="literal">visitor.price</code>, which is the new price of the current car object.</p><p>Like I said in the <em>Roles</em> section of this pattern, the visitor pattern is used when an array manages a heterogeneous collection of objects that does not share a common base class or conforms to a common protocol. By applying the pattern, all three <code class="literal">Cars</code> classes can share and conform to the same protocol and allow us to manage the following array:</p><div><pre class="programlisting">let cars: [Car] = [DSCar(), RenaultCar(), CitroenCar()]</pre></div><p>Then, we can calculate new prices by applying the appropriate visitor calculation:</p><div><pre class="programlisting">let prices = cars.map { (car: Car) -&gt; Double in
  let visitor = PriceVisitor()
  car.accept(visitor)
  return visitor.price
}</pre></div><p>To show the result, check the right part of the following screenshot. <strong>23200</strong>, <strong>15300</strong> and <strong>17100</strong> are the new prices of our cars:</p><div><img alt="Implementation" src="img/4852_08_02.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec38"/>The interpreter pattern</h1></div></div></div><p>The <a class="indexterm" id="id401"/>interpreter pattern is not really used, but it can be really useful. Usually, this<a class="indexterm" id="id402"/> pattern is described in terms of formal grammar but the area where it can be applied, can be extended.</p><p>You can refer to the following for more information: Lecture de chiffre Romain (<a class="ulink" href="http://www.oodesign.com/interpreter-pattern.html">http://www.oodesign.com/interpreter-pattern.html</a>) and <a class="ulink" href="https://en.wikipedia.org/wiki/Roman_numerals">https://en.wikipedia.org/wiki/Roman_numerals</a>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec144"/>Roles</h2></div></div></div><p>The interpreter pattern <a class="indexterm" id="id403"/>defines an object representation of a language grammar in order to evaluate some expression written in this language by interpreting them.</p><p>This pattern can be used to interpret some expressions that are represented as a hierarchical tree. It may be applied when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Grammar of expression is simple</li><li class="listitem" style="list-style-type: disc">Evaluation doesn't need to be quick</li></ul></div><p>Some examples where this pattern can be used are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In rule engines</li><li class="listitem" style="list-style-type: disc">To add some functionality to the composite pattern</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec145"/>Design</h2></div></div></div><p>The <a class="indexterm" id="id404"/>implementation of this pattern is seen in the use of the composite pattern applied to represent a grammar (refer to the <em>The composite pattern</em> in <a class="link" href="ch03.html" title="Chapter 3. Structural Patterns – Composite and Flyweight">Chapter 3</a>, <em>Structural Patterns – Composite and Flyweight</em>). The difference is that the interpreter pattern defines the behavior while the composite defines only the structure.</p><p>The UML class diagram of the pattern is as follows:</p><div><img alt="Design" src="img/4852_08_03.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec146"/>Participants</h2></div></div></div><p>Participants to this<a class="indexterm" id="id405"/> pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AbstractExpression</code>: This <a class="indexterm" id="id406"/>defines the <code class="literal">interpret()</code> method that is common to all the nodes in the abstract syntax tree.</li><li class="listitem" style="list-style-type: disc"><code class="literal">TerminalExpression</code>: This<a class="indexterm" id="id407"/> implements the interpret method associated with terminal symbols of the grammar. Each terminal symbol of the grammar requires a concrete class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">NonTerminalExpression</code>: This<a class="indexterm" id="id408"/> implements the interpret method and can also contain other <code class="literal">AbstractExpression</code> instances.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Context</code>: This <a class="indexterm" id="id409"/>contains information that is global to the interpreter. For example, the actual values of variables.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Client</code>: This <a class="indexterm" id="id410"/>builds an abstract syntax tree that is assembled from instances of <code class="literal">NonTerminalExpression</code> and <code class="literal">TerminalExpression</code>. It will be our demo usage of the pattern.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec147"/>Collaboration</h2></div></div></div><p>The client<a class="indexterm" id="id411"/> builds the abstract syntax tree, initializes the context of the interpreter, and then invokes the interpret method.</p><p>The interpret method at the <code class="literal">TerminalExpression</code> and <code class="literal">NonTerminalExpression</code> node uses the context to store and access the state of the interpreter.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec148"/>Illustration</h2></div></div></div><p>We <a class="indexterm" id="id412"/>want to create a roman number converter; you know the ones that interpret that XIV means 14 in decimals. The main purpose of our example is to write a roman number and our converter will tell us the decimal value.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec149"/>Implementation</h2></div></div></div><p>Open <a class="indexterm" id="id413"/>the <code class="literal">InterpreterPattern.xcodeproj</code> file and see how we have implemented the pattern.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>For this pattern, all the code has been added to the <code class="literal">main.swift</code> class so that it can be easily exported into Playground if you want to see the live execution of the code.</p></div></div><p>Before starting to understand the code, have a look at the following link to understand how roman numbers work and how they are written.</p><p>You can see some rules about the roman numerals and also a roman numeral chart at <a class="ulink" href="http://4thgradecrocs.weebly.com/roman-numerals.html">http://4thgradecrocs.weebly.com/roman-numerals.html</a> and how the roman system works can be seen at <a class="ulink" href="https://en.wikipedia.org/wiki/Roman_numerals">https://en.wikipedia.org/wiki/Roman_numerals</a>.</p><p>For the pattern, we will use one string extension that lets us do a substring easily just by passing the number of characters we want to ignore in the argument:</p><div><pre class="programlisting">extension String {
  func subStringFrom(pos: Int) -&gt; String {
    var substr = ""
    let start = self.startIndex.advancedBy(pos)
    let end = self.endIndex
    let range = start..&lt;end
    substr = self[range]
    return substr
  }
}</pre></div><p>The expression to be interpreted is a string that is put in the context:</p><div><pre class="programlisting">class Context {
  var input: String!
  var output: Int = 0
  
  init(input: String){
    self.input = input
  }
}</pre></div><p>This class will <a class="indexterm" id="id414"/>help us to work while we apply the pattern; it consists of the remaining unparsed roman numeral strings and also the result of the numerals that are already parsed.</p><p>The context is passed to one of four sub-interpreters based on the type of interpreting (thousand, hundred, ten, and one). In this example, only <code class="literal">TerminalExpressions</code> are used.</p><p>Next, we will define our <code class="literal">AbstractExpression</code> class. This class must implement the <code class="literal">interpret()</code> method and define the methods that will be overridden in the subclasses:</p><div><pre class="programlisting">class Expression {
  func interpret(context: Context) {
    if context.input.characters.count == 0 {
      return
    }
    
    if context.input.hasPrefix(nine()){
      context.output = context.output + (9 * multiplier())
      context.input = context.input.subStringFrom(2)
    } else  if context.input.hasPrefix(four()){
      context.output = context.output + (4 * multiplier())
      context.input = context.input.subStringFrom(2)
    } else  if context.input.hasPrefix(five()){
      context.output = context.output + (5 * multiplier())
      context.input = context.input.subStringFrom(1)
    }
    
    while context.input.hasPrefix(one()) {
      context.output = context.output + (1 * multiplier())
      context.input = context.input.subStringFrom(1)
    }
  }
  
  func one() -&gt; String {
    fatalError("this method must be implemented in a subclass")
  }
  
  func four() -&gt; String {
      fatalError("this method must be implemented in a subclass")
  }
  
  func five() -&gt; String {
      fatalError("this method must be implemented in a subclass")
  }
  func nine() -&gt; String {
      fatalError("this method must be implemented in a subclass")
  }
  func multiplier() -&gt; Int {
      fatalError("this method must be implemented in a subclass")
  }
}</pre></div><p>The <code class="literal">Expression</code> class <a class="indexterm" id="id415"/>consists of the <code class="literal">interpret</code> method, which receives the context. Based on the current object, it uses specific values for thousand, hundred, ten, one, and also a specific multiplier.</p><p>The <code class="literal">one()</code>, <code class="literal">four()</code>, <code class="literal">five()</code>, <code class="literal">nine()</code>, and <code class="literal">multiplier()</code> methods of the <code class="literal">Expression</code> class are abstract. They will be implemented in our Concrete <code class="literal">TerminalExpressions</code> class</p><p>We can now implement our four <code class="literal">TerminalExpression</code> classes. Each of them override the <code class="literal">one()</code>, <code class="literal">four()</code>, <code class="literal">five()</code>, <code class="literal">nine()</code> and the <code class="literal">multiplier()</code> methods. These methods will then be interpreted depending on if we are in a thousand, hundred, ten or one expressions. Indeed, these classes are used to define each specific expression. Usually, these classes implement the <code class="literal">interpret</code> method, but here it is already defined in the base expression class and each of the <code class="literal">TerminalExpression</code> class defines its behavior by implementing the abstract methods: <code class="literal">one()</code>, <code class="literal">four()</code>, <code class="literal">five()</code>, <code class="literal">nine()</code>, and <code class="literal">multiplier()</code>. This is a template method (refer to the <em>The template method</em> section in <a class="link" href="ch05.html" title="Chapter 5. Behavioral Patterns – Strategy, State, and Template Method">Chapter 5</a>, <em>Behavioral Patterns – Strategy, State, and Template Method</em>):</p><div><pre class="programlisting">class ThousandExpression: Expression {
  override func one() -&gt; String {
    return "M"
  }
  override func four() -&gt; String {
    return " "
  }
  override func five() -&gt; String {
    return " "
  }
  override func nine() -&gt; String {
    return " "
  }
  override func multiplier() -&gt; Int {
    return 1000
  }
}

class HundredExpression: Expression {
  override func one() -&gt; String {
    return "C"
  }
  override func four() -&gt; String {
    return "CD"
  }
  override func five() -&gt; String {
    return "D"
  }
  override func nine() -&gt; String {
    return "CM"
  }
  override func multiplier() -&gt; Int {
    return 100
  }
}

class TenExpression: Expression {
  override func one() -&gt; String {
    return "X"
  }
  override func four() -&gt; String {
    return "XL"
  }
  override func five() -&gt; String {
    return "L"
  }
  override func nine() -&gt; String {
    return "XC"
  }
  override func multiplier() -&gt; Int {
    return 10
  }
}

class OneExpression: Expression {
  override func one() -&gt; String {
    return "I"
  }
  override func four() -&gt; String {
    return "IV"
  }
  override func five() -&gt; String {
    return "V"
  }
  override func nine() -&gt; String {
    return "IX"
  }
  override func multiplier() -&gt; Int {
    return 1
  }
}</pre></div><p>The pattern is now<a class="indexterm" id="id416"/> written; we only have to test it. Before writing our test code, we will create a helper <code class="literal">RomanToDecimalConverter()</code> class having a <code class="literal">calculate()</code> method that returns the result of the conversion:</p><div><pre class="programlisting">class RomanToDecimalConverter {
  var tree = [ThousandExpression(), HundredExpression(), TenExpression(),OneExpression()]

  func calculate(romanString: String) -&gt; Int {
    let context = Context(input: romanString)
    for t in tree {
      t.interpret(context)
    }
    return context.output
  }
}</pre></div><p>This class is responsible to build the syntax tree representing our specific value; the roman number, in the language defined by the grammar.</p><p>Note that we can only add our terminal expressions to the array in a specific order: from thousand to one expression, as we will parse the roman string from left to right.</p><p>We call the interpret method after the syntax tree is build. We return the <code class="literal">context.output</code> value once all expressions of the pattern are executed, which corresponds to the decimal result.</p><p>We will add a new method to our <code class="literal">RomanToDecimalConverter</code> before writing our test code. This will validate that the roman number that we are trying to convert is correct: otherwise, a message will be displayed informing us that our number is not a roman number. The added code is highlighted in the following:</p><div><pre class="programlisting">
<strong>enum FormatError: ErrorType {</strong>
<strong>  case RomanNumberFormatError</strong>
<strong>}</strong>

//Helper
class RomanToDecimalConverter {
<strong>  static let pattern = "^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$"</strong>
<strong>  let validation = NSPredicate(format: "SELF MATCHES %@", pattern)</strong>
  
  var tree = [ThousandExpression(), HundredExpression(), TenExpression(),OneExpression()]
  
<strong>  func calculate(romanString: String) throws -&gt; Int {</strong>
<strong>    guard validate(romanString) else {</strong>
<strong>      throw FormatError.RomanNumberFormatError</strong>
<strong>    }</strong>
    
    let context = Context(input: romanString)
    for t in tree {
      t.interpret(context)
    }
    return context.output
  }
<strong>  </strong>
<strong>  func validate(romanString: String) -&gt; Bool {</strong>
<strong>    return validation.evaluateWithObject(romanString)</strong>
<strong>  }</strong>
}</pre></div><p>We first<a class="indexterm" id="id417"/> define a new <code class="literal">enum</code> function that we call <code class="literal">FormatError</code> of type <code class="literal">ErrorType</code>. We will use this to throw an exception when the format of the roman number is incorrect.</p><p>Then we have a static string <code class="literal">pattern</code> in the <code class="literal">RomanToDecimalConverter</code> class that contains our regular expression and also an instance constant called <code class="literal">validation</code> that will handle the validation process through an <code class="literal">NSPredicate</code> object. The purpose of this object is to define the logical conditions needed to constrain a search either for a fetch or for an in-memory filtering.</p><p>In the <code class="literal">calculate</code> method, we had a <code class="literal">guard</code> statement that executed the <code class="literal">validate</code> function, if the <code class="literal">validate</code> function returns <code class="literal">false</code> (meaning the number is incorrect), a <code class="literal">FormatError.RomanNumberFormatError</code> exception is raised; otherwise, we will continue the operation and calculate the decimal value using the pattern. Note the addition of the <code class="literal">throws</code> keyword just before the return type of the method. It means that this method can throw errors.</p><p>The <code class="literal">validate()</code> method calls the <code class="literal">evaluateWithObject</code> method of the <code class="literal">NSPredicate</code> instance by passing the<a class="indexterm" id="id418"/> roman number in an argument. This method returns <code class="literal">true</code> if the format is correct, otherwise it will return <code class="literal">false</code>.</p><div><div><h3 class="title"><a id="note24"/>Note</h3><p>The regex expression used in this code comes from the following URL and is very well explained at: <a class="ulink" href="http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression">http://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression</a>
</p><p>For more information about NSPredicate, you can refer to this site: <a class="ulink" href="https://realm.io/news/nspredicate-cheatsheet/">https://realm.io/news/nspredicate-cheatsheet/</a>
</p></div></div><p>Now we can write our test code like the following:</p><div><pre class="programlisting">let romanNumberToTest = ["XIV", "MCCMXXVIII","MCMXXVIII"]
var converter = RomanToDecimalConverter()
for roman in romanNumberToTest {
  var decimal = try? converter.calculate(roman)
  guard (decimal != nil) else {
    print("\(roman) is not a correct roman number")
    continue
  }
  print(decimal!)
}</pre></div><p>We initialize an array with some roman numbers and then initialize our <code class="literal">RomanToDecimalConverter</code> converter object and loop over all elements to make the calculations.</p><p>We are using the following statement:</p><div><pre class="programlisting">var decimal = try? converter.calculate(roman)</pre></div><p>The decimal will return <code class="literal">nil</code> if an exception is raised. So, the next three lines help us to print an appropriate message when a roman number doesn't have the  correct format.</p><p>With the three values of our array and after building and running the project, you'll obtain the following result:</p><div><img alt="Implementation" src="img/4852_08_04.jpg"/></div><p>The preceding result given by the program inform us that  <strong>MCCMXXVIII</strong> has a wrong roman number format and the two others numbers are well converted with the 14 decimal value for the first roman number and 1928 for the second roman number.</p><p>You can try running <a class="indexterm" id="id419"/>the code using the roman numeral chart given at the beginning of this section.</p><p>You can see that this pattern is really interesting. You have already seen that the composite and template method patterns have also been used to build and implement our interpreter pattern with our use case.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec39"/>The memento pattern</h1></div></div></div><p>The <a class="indexterm" id="id420"/>memento pattern <a class="indexterm" id="id421"/>will be the last pattern that we will discover together. You will see that this pattern is really interesting to work with and has many uses.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec150"/>Roles</h2></div></div></div><p>The role of the <a class="indexterm" id="id422"/>memento pattern is to capture an object's internal state and save it externally so that it can be restored later without breaking the encapsulation of this object.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec151"/>Design</h2></div></div></div><p>The <a class="indexterm" id="id423"/>generic UML class diagram is defined as the following:</p><div><img alt="Design" src="img/4852_08_05.jpg"/></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec152"/>Participants</h2></div></div></div><p>The following are the<a class="indexterm" id="id424"/> participants of the memento pattern:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Memento</code>: This is <a class="indexterm" id="id425"/>the class for the objects that saved the internal states of origin objects (or part of this state), such as the introduction of the fact that the saving of a state can be made independent of the object itself. The memento has two interfaces:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A complete interface for <code class="literal">Originator</code> objects that permit access to everything that needs to be saved or restored</li><li class="listitem" style="list-style-type: disc">A narrow interface to the caretaker that can keep and pass on the memento references, but no more</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Originator</code>: This<a class="indexterm" id="id426"/> is the object class that creates memento to save their internal states and that they can restore from memento.</li><li class="listitem" style="list-style-type: disc"><code class="literal">caretaker</code>: This is <a class="indexterm" id="id427"/>responsible to manage the list of mementos and doesn't provide access to the internal state of the origin objects. This is also the class that the client code needs to access.</li><li class="listitem" style="list-style-type: disc"><code class="literal">CreateMemento</code>: This <a class="indexterm" id="id428"/>method is used to save the state of the originator. It creates a <code class="literal">Memento</code> object by saving the state variable into the <code class="literal">Memento</code> object and returns it. This is used to record the state of <code class="literal">Originator</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SetMemento</code>: This <a class="indexterm" id="id429"/>class stores the historical information of the <code class="literal">Originator</code> objects. The information is stored in its state variable.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec153"/>Collaboration</h2></div></div></div><p>An<a class="indexterm" id="id430"/> instance of <code class="literal">Caretaker</code> asks for a memento of the <code class="literal">originator</code> object by calling the <code class="literal">createMemento</code> method and saves it. In case of cancellation and going back to the saved state in the memento, you can send it to the <code class="literal">originator</code> object using the <code class="literal">setMemento</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec154"/>Illustration</h2></div></div></div><p>You have <a class="indexterm" id="id431"/>developed a platform game where each time your hero passes a level, a checkpoint is stored. This allows the player to reload from any level that he has already crossed.</p><p>The data that needs to be stored when saving the checkpoint are the level numbers, the current weapon, and the number of points.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec155"/>Implementation</h2></div></div></div><p>To <a class="indexterm" id="id432"/>simplify our code, we will use an OS X command line project, where we will write all our code in the <code class="literal">main.swift</code> file.</p><p>Open the <code class="literal">MementoPattern.xcodeproj</code> file in Xcode and let's see how we have organized our code.</p><p>Firstly, we define our <code class="literal">GameState</code> structure: data that needs to be saved are <code class="literal">level</code>, <code class="literal">weapon</code>, and <code class="literal">points</code>:</p><div><pre class="programlisting">struct GameState {
  var level: Int
  var weapon: String
  var points: Int
}</pre></div><p>Then we <a class="indexterm" id="id433"/>define our <code class="literal">Originator</code> with the <code class="literal">createMemento</code> and <code class="literal">setMemento</code> methods:</p><div><pre class="programlisting">protocol Originator {
  func createMemento() -&gt; GameMemento  func setMemento(memento: GameMemento)
}</pre></div><p>Then we implement our <code class="literal">GameState Memento</code>: it contains all the information that <code class="literal">CheckPoint</code> needs to restore the state.</p><p>First, we define three variables that will help us to store states:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">entries</code> is a list of <code class="literal">GameState</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">nextId</code> contains the next index of the <code class="literal">entries</code> array</li><li class="listitem" style="list-style-type: disc"><code class="literal">totalPoints</code> is a variable that has the total points of each entry</li></ul></div><p>We have a constructor where we can pass a <code class="literal">CheckPoint</code> object as an argument. States of the checkpoint are assigned to the memento internal variables.</p><p>The <code class="literal">apply()</code> method receives a checkpoint object in the argument. Then, we assign the current memento values to the checkpoint properties in order to restore the checkpoint state:</p><div><pre class="programlisting">struct GameMemento {
  private let entries: [Int: GameState]
  private let nextId: Int
  private let totalPoints: Int

  init(checkPoint: CheckPoint){
    self.entries = checkPoint.entries
    self.nextId = checkPoint.nextId
    self.totalPoints = checkPoint.totalPoints
  }

  func apply(checkPoint: CheckPoint) {
    print("Restoring a game state to a checkpoint...")
    checkPoint.nextId = nextId
    checkPoint.totalPoints = totalPoints
    checkPoint.entries = entries
  }
}</pre></div><p>We can now <a class="indexterm" id="id434"/>save and restore a memento. The next thing to be done is to create our originator: the <code class="literal">CheckPoint</code> object. While playing the game, an entry will be added to the checkpoint entries list.</p><p>Just like in the <code class="literal">Memento</code> object, we will define three variables. The difference being that we initialize them in this object:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Entries</code>: This is an array that will contain all entries.</li><li class="listitem" style="list-style-type: disc"><code class="literal">totalPoints</code>: This is an integer initialized to <code class="literal">0</code> and it will contain the total of each level points.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nextId</code>: This is an integer that starts from <code class="literal">0</code>. It contains the value of the next index in the <code class="literal">entries</code> array.</li></ul></div><p>We have four methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">addGameStateEntry</code>: This method is used to add a new entry to our entries list. This will be called by the client every time a level of our game is complete.</li><li class="listitem" style="list-style-type: disc"><code class="literal">createMemento</code>: This method creates and return a memento object. The checkpoint itself is sent as an argument of the method.</li><li class="listitem" style="list-style-type: disc"><code class="literal">setMemento</code>: This method allows us to restore a <code class="literal">Memento</code> object.</li><li class="listitem" style="list-style-type: disc"><code class="literal">printCheckPoint</code>: This method is here to easily see what the current state of the <code class="literal">CheckPoint</code> object is.</li></ul></div><p>The <code class="literal">CheckPoint</code> class<a class="indexterm" id="id435"/> has the following implementation:</p><div><pre class="programlisting">class CheckPoint: Originator {
  private var entries: [Int: GameState] = [:]
  private var totalPoints: Int  = 0
  private var nextId: Int = 0
  
  func addGameStateEntry(level: Int, weapon: String, points: Int) {
    let entry = GameState(level: level, weapon: weapon, points: points)
    entries[nextId++] = entry
    totalPoints += points
  }
  
  func createMemento() -&gt; GameMemento {
    return GameMemento(checkPoint: self)
  }
  
  func setMemento(memento: GameMemento) {
       memento.apply(self)
  }
  
  func printCheckPoint() {
    print("Printing checkPoint....")
    entries.sort {$0.0 &lt; $1.0 }
.map {
        print("Level: \($0.1.level)   Weapon: \($0.1.weapon)   Points: \($0.1.points) ")
    }
    print("Total Points: \(totalPoints)\n")
  }
}</pre></div><p>You have <a class="indexterm" id="id436"/>probably seen the following statement:</p><div><pre class="programlisting">    entries.sort {$0.0 &lt; $1.0 }
.map {
        print("Level: \($0.1.level)   Weapon: \($0.1.weapon)   Points: \($0.1.points) ")
    }</pre></div><p>This is how we can easily sort our array by index value. Then we can use the <code class="literal">map</code> function, only to be able to execute the print statement on each entry of the array.</p><p>You can see more information about closures to the following URL at: <a class="ulink" href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html">https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html</a>
</p><p>Our pattern is now in place, let's have a look at how to use it:</p><div><pre class="programlisting">let checkPoint = CheckPoint()
checkPoint.addGameStateEntry(0, weapon: "gun", points: 1200)
checkPoint.addGameStateEntry(1, weapon: "tommy gun", points: 2250)
checkPoint.printCheckPoint()

let memento = checkPoint.createMemento()
checkPoint.addGameStateEntry(2, weapon: "bazooka", points: 2400)
checkPoint.addGameStateEntry(4, weapon: "knife", points: 3000)
checkPoint.printCheckPoint()

checkPoint.setMemento(memento)
checkPoint.printCheckPoint()</pre></div><p>After initializing a checkpoint object, we add two entries to the checkpoint.</p><p>After calling the <code class="literal">printCheckPoint</code> method of the <code class="literal">checkpoint</code> object: we obtain the following result:</p><div><pre class="programlisting">Printing checkPoint....
Level: 0   Weapon: gun   Points: 1200 
Level: 1   Weapon: tommy gun   Points: 2250 
Total Points: 3450</pre></div><p>The <code class="literal">printCheckPoint</code> method <a class="indexterm" id="id437"/>iterates over all the entries of the checkpoint object and displays the state of each one and the total points of the entries.</p><p>At this moment, we have still not created a <code class="literal">Memento</code> object, so we cannot restore a previous state.</p><p>To create a memento, we only have to call the <code class="literal">createMemento</code> method of the <code class="literal">Originator</code> object (in our case the <code class="literal">checkPoint</code> object):</p><div><pre class="programlisting">
<strong>let memento = checkPoint.createMemento()</strong>
</pre></div><p>This method returns a memento object that we assign to our memento constant, so that we can restore when needed.</p><p>We continue the game and pass two others levels successfully and print the current checkpoint state once more:</p><div><pre class="programlisting">checkPoint.addGameStateEntry(2, weapon: "bazooka", points: 2400)
checkPoint.addGameStateEntry(4, weapon: "knife", points: 3000)
checkPoint.printCheckPoint()</pre></div><p>The result is as follows:</p><div><pre class="programlisting">Printing checkPoint....
Level: 0   Weapon: gun   Points: 1200 
Level: 1   Weapon: tommy gun   Points: 2250 
Level: 2   Weapon: bazooka   Points: 2400 
Level: 4   Weapon: knife   Points: 3000 
Total Points: 8850</pre></div><p>The <code class="literal">CheckPoint</code> now contains four entries in its array.</p><p>We want to restore our checkpoint state to the last saved state. To proceed, we only need to call the <code class="literal">setMemento()</code>method of the checkpoint object with the memento object we previously have created and make a call to the <code class="literal">printCheckPoint</code> method to display the result, as shown:</p><div><pre class="programlisting">checkPoint.setMemento(memento)
checkPoint.printCheckPoint()</pre></div><p>The result of the <code class="literal">printCheckPoint</code> call is the following:</p><div><pre class="programlisting">Restoring a game state to a checkpoint...
Printing checkPoint....
Level: 0   Weapon: gun   Points: 1200 
Level: 1   Weapon: tommy gun   Points: 2250 
Total Points: 3450</pre></div><p>We can see that the checkpoint object has been restored to its previous state.</p><p>With this simple<a class="indexterm" id="id438"/> example, you should now have a good pattern to use and easily manage cancellation and restoration of an object.</p><p>The memento pattern is a pattern that is extensively used in scientific computing to save the state of long-running computations. As seen here, it may be used to save the state of play over a matter of hours or days. In the graphics toolkit, it may be used to preserve the state of a display while the objects are being moved around.</p><div><div><h3 class="title"><a id="note25"/>Note</h3><p>Use this pattern when:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An object's state must be saved to be restored later</li><li class="listitem" style="list-style-type: disc">It's undesirable to expose the state directly</li></ul></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec40"/>Comparing the three patterns</h1></div></div></div><p>Though they<a class="indexterm" id="id439"/> seem dissimilar, there are several ways in which we can compare these three patterns:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Reusability</strong>: All three patterns aim to relieve the developer of implementing a common code repeatedly. Indeed, once the visitor has been implemented, they can be reused with different types of objects without any changes. To facilitate the reuse, you must limit the number of states the visitor needs to be aware of. The interpreter pattern is designed to parse an input where the structure is data driven. The <code class="literal">Caretaker</code> and memento classes of the <code class="literal">Memento</code> pattern are independent of the data, only the originator should be changed.</li><li class="listitem" style="list-style-type: disc"><strong>Working with structure</strong>: These patterns are intended to work with structures. Visitor and interpreter require the developer to write traversing codes whereas the memento pattern moves the structure as a whole, relying on the serialization to do the traversing.</li><li class="listitem" style="list-style-type: disc"><strong>Objects as argument</strong>: In the memento and visitor patterns, objects are passed around as a part of their structure, while in the interpreter pattern it relies on a context that is basically the evolving state of the input that is being interpreted to output.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec41"/>Summary</h1></div></div></div><p>This chapter concludes the discovery of the eight behavioral patterns, as described by the gang of four. Moreover, this chapter concludes the book.</p><p>I wanted the book to be really easy to follow without adding complexity in the sample provided. This book is intended to be a reference for anyone who wants to implement design patterns with Swift.</p><p>There are some points that we have not covered, such as multi-concurrency access, Swift 2 special coding with closure, and so on. I think that these points don't occur in a learning book. The main purpose of the book is to easily find the appropriate pattern when needed and have an easy illustration to follow.</p><p>Well, you now have all the necessary information to structure your code in a scalable way. This will help you to structure your code properly, increase the performance of your code, and reduce maintenance costs.</p><p>I really thank you to have followed the book. Now, it's up to you to put this knowledge into practice.</p></div></body></html>