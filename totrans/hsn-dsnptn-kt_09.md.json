["```kt\nfun activeActor(out: SendChannel<String>) = actor<Int> {\n    for (i in this) {\n        out.send(i.toString().reversed())\n    }\n    out.close()\n}\n```", "```kt\nval channel = Channel<String>()\nval actor = activeActor(channel)\n\nval j1 = launch {\n    for (i in 42..53) {\n        actor.send(i)\n    }\n    actor.close()\n}\n```", "```kt\nval j2 = launch {\n    for (i in channel) {\n        println(i)\n    }\n}\n\nj1.join()\nj2.join()\n```", "```kt\nval deferred = CompletableDeferred<String>()\n\nlaunch {\n    delay(100)\n    if (Random().nextBoolean()) {\n        deferred.complete(\"OK\")\n    }\n    else {\n        deferred.completeExceptionally(RuntimeException())\n    }\n}\n\nprintln(deferred.await())\n```", "```kt\ndeferred.cancel()\n```", "```kt\ndata class FavoriteCharacter(val name: String, val catchphrase: String, val repeats: Int)\n```", "```kt\nval latch = CountDownLatch(3)\n\nvar name: String? = null\nlaunch {\n    delay(Random().nextInt(100))\n    println(\"Got name\")\n    name = \"Inigo Montoya\"\n    latch.countDown()\n}\n\nvar catchphrase = \"\"\nlaunch {\n    delay(Random().nextInt(100))\n    println(\"Got catchphrase\")\n    catchphrase = \"Hello. My name is Inigo Montoya. You killed my father. Prepare to die.\"\n    latch.countDown()\n}\n\nvar repeats = 0\nlaunch {\n    delay(Random().nextInt(100))\n    println(\"Got repeats\")\n    repeats = 6\n    latch.countDown()\n}\n\nlatch.await()\n\nprintln(\"${name} says: ${catchphrase.repeat(repeats)}\")\n```", "```kt\nGot name\nGot catchphrase\nGot repeats\n```", "```kt\nInigo Montoya says: Hello. My name is Inigo Montoya. ...\n```", "```kt\nprivate fun getName(latch: CountDownLatch) = launch {\n    ...\n    latch.countDown()\n}\n```", "```kt\nprivate fun getName() = async {\n    delay(Random().nextInt(100))\n    println(\"Got name\")\n    \"Inigo Montoya\"\n}\n\nprivate fun getCatchphrase() = async {\n    delay(Random().nextInt(100))\n    println(\"Got catchphrase\")\n    \"Hello. My name is Inigo Montoya. You killed my father. Prepare to die.\"\n}\n\nprivate fun getRepeats() = async {\n    delay(Random().nextInt(100))\n    println(\"Got repeats\")\n    6\n}\n```", "```kt\nprivate fun getCatchphrase(): Deferred<String> {\n    return async {\n        ...\n    }\n}\n```", "```kt\nval name = getName()\nval catchphrase = getCatchphrase()\nval repeats = getRepeats()\n\nprintln(\"${name.await()} says: ${catchphrase.await().repeat(repeats.await())}\")\n```", "```kt\nval character = FavoriteCharacter(getName().await(), getCatchphrase().await(), getRepeats().await())\n\n// Will happen only when everything is ready\nwith(character) {\n    println(\"$name says: ${catchphrase.repeat(repeats)}\")    \n}\n```", "```kt\nval (name, catchphrase, repeats) = character\nprintln(\"$name says: ${catchphrase.repeat(repeats)}\")\n```", "```kt\nobject Michael {\n    fun getFavoriteCharacter() = async {\n        // Doesn't like to think much\n        delay(Random().nextInt(10))\n        FavoriteCharacter(\"Terminator\", \"Hasta la vista, baby\", 1)\n    }\n}\n\nobject Jake {\n    fun getFavoriteCharacter() = async {\n        // Rather thoughtful barista\n        delay(Random().nextInt(100) + 10)\n        FavoriteCharacter(\"Don Vito Corleone\", \"I'm going to make him an offer he can't refuse\", 1)\n    }\n}\n\nobject Me {\n    fun getFavoriteCharacter() = async {\n        // I already prepared the answer!\n        FavoriteCharacter(\"Inigo Montoya\", \"Hello, my name is...\", 6)\n    }\n}\n```", "```kt\nval favoriteCharacters = listOf(Me.getFavoriteCharacter().await(),\n        Michael.getFavoriteCharacter().await(),\n        Jake.getFavoriteCharacter().await())\n\nprintln(favoriteCharacters)\n```", "```kt\n// Same as launch {}\nlaunch(CommonPool) {\n...\n}\n\n// Same as async {}\nval result = async(CommonPool) {\n...\n}\n```", "```kt\nval r1 = async(CommonPool) {\n    for (i in 1..1000) {\n        println(Thread.currentThread().name)\n        yield()\n    }\n}\n\nr1.await()\n```", "```kt\nForkJoinPool.commonPool-worker-2\nForkJoinPool.commonPool-worker-3\n...\nForkJoinPool.commonPool-worker-3\nForkJoinPool.commonPool-worker-1\n```", "```kt\nval r1 = async(Unconfined) {\n    ...\n}\n```", "```kt\nmain\nmain\n...\n```", "```kt\nval r1 = async {\n    for (i in 1..1000) {\n        val parentThread = Thread.currentThread().name\n        launch(coroutineContext) {\n            println(Thread.currentThread().name == parentThread)\n        }\n        yield()\n    }\n}\n```", "```kt\nval r1 = async(Unconfined) {\n    for (i in 1..1000) {\n        println(Thread.currentThread().name)\n        delay(1)\n    }\n}\n\nr1.await()\n```", "```kt\nmain\nkotlinx.coroutines.DefaultExecutor\n...\n```", "```kt\nval pool = newFixedThreadPoolContext(2, \"My Own Pool\")\nval r1 = async(pool) {\n    for (i in 1..1000) {\n        println(Thread.currentThread().name)\n        yield()\n    }\n}\n\nr1.await()\npool.close()\n```", "```kt\n...\nMy Own Pool-2\nMy Own Pool-1\nMy Own Pool-2\nMy Own Pool-2\n...\n```", "```kt\nrepositories {\n    ...\n    jcenter()\n}\n\ndependencies {\n    ...\n    compile \"org.jetbrains.kotlinx:kotlinx.dom:0.0.10\"\n}\n```", "```kt\nfun producePages() = produce {\n    fun getPages(): List<String> {\n        // This should actually fetch something\n        return listOf(\"<html><body><H1>Cool stuff</H1></body></html>\",\n                \"<html><body><H1>Event more stuff</H1></body></html>\").shuffled()\n    }\n    while (this.isActive) {\n        val pages = getPages()\n        for (p in pages) {\n            send(p)\n        }\n        delay(TimeUnit.SECONDS.toMillis(5))\n    }\n}\n\n```", "```kt\nfun produceDom(pages: ReceiveChannel<String>) = produce {\n\n    fun parseDom(page: String): Document {\n         return kotlinx.dom.parseXml(*page.toSource()*)\n    }\n\n    for (p in pages) {\n        send(parseDom(p))\n    }\n}\n```", "```kt\nprivate fun String.toSource(): InputSource {\n    return InputSource(StringReader(this))\n}\n```", "```kt\nfun produceTitles(parsedPages: ReceiveChannel<Document>) = produce {\n    fun getTitles(dom: Document): List<String> {\n        val h1 = dom.getElementsByTagName(\"H1\")\n        return h1.asElementList().map {\n            it.textContent\n        }\n    }\n\n    for (page in parsedPages) {\n        for (t in getTitles(page)) {\n            send(t)\n        }\n    }\n}\n```", "```kt\nval pagesProducer = producePages()\n\nval domProducer = produceDom(pagesProducer)\n\nval titleProducer = produceTitles(domProducer)\n\nrunBlocking {\n    titleProducer.consumeEach {\n        println(it)\n    }\n}\n```", "```kt\npagesProducer |> domProducer |> titleProducer |> output\n```", "```kt\nprivate fun ReceiveChannel<Document>.titles(): ReceiveChannel<String> {\n    val channel = this\n    fun getTitles(dom: Document): List<String> {\n        val h1 = dom.getElementsByTagName(\"H1\")\n        return h1.asElementList().map {\n            it.textContent\n        }\n    }\n\n    return produce {\n        for (page in channel) {\n            for (t in getTitles(page)) {\n                send(t)\n            }\n        }\n    }\n}\n\nprivate fun ReceiveChannel<String>.dom(): ReceiveChannel<Document> {\n    val channel = this\n    return produce() {\n        for (p in channel) {\n            send(kotlinx.dom.parseXml(p.toSource()))\n        }\n    }\n}\n```", "```kt\nrunBlocking {\n    producePages().dom().titles().consumeEach {\n        println(it)\n    }\n}\n```", "```kt\nprivate fun producePages() = produce {\n    for (i in 1..10_000) {\n        for (c in 'a'..'z') {\n            send(i to \"page$c\")\n        }\n    }\n}\n```", "```kt\n\nprivate fun consumePages(channel: ReceiveChannel<Pair<Int, String>>) = async {\n    for (p in channel) {\n        println(p)\n    }\n}\n```", "```kt\nval producer = producePages()\n\nval consumers = List(10) {\n    consumePages(producer)\n}\n\nrunBlocking {\n    consumers.forEach {\n        it.await()\n    }\n}\n```", "```kt\nprivate fun techBunch(collector: Channel<String>) = launch {\n    repeat(10) {\n        delay(Random().nextInt(1000))\n        collector.send(\"Tech Bunch\")\n    }\n}\n\nprivate fun theFerge(collector: Channel<String>) = launch {\n    repeat(10) {\n        delay(Random().nextInt(1000))\n        collector.send(\"The Ferge\")\n    }\n}\n```", "```kt\nval collector = Channel<String>()\n\ntechBunch(collector)\ntheFerge(collector)\n\nrunBlocking {\n    collector.consumeEachIndexed {\n        println(\"${it.index} Got news from ${it.value}\")\n    }\n}\n\n```", "```kt\nval numbers = List(10_000_000) {\n    Random().nextInt()\n}\n```", "```kt\nfun divide(input: ReceiveChannel<List<Int>>, \n           output: SendChannel<Int>) = async {\n    var max = 0\n    for (list in input) {\n        for (i in list) {\n            if (i > max) {\n                max = i\n                output.send(max)\n            }\n        }\n    }\n}\n```", "```kt\nfun collector() = actor<Int> {\n    var max = 0\n    for (i in this) {\n        max = Math.max(max, i)\n    }\n    println(max)\n}\n```", "```kt\nval input = Channel<List<Int>>()\nval output = collector()\nval dividers = List(10) {\n    divide(input, output)\n}\n\nlaunch {\n    for (c in numbers.chunked(1000)) {\n        input.send(c)\n    }\n    input.close()\n}\n\ndividers.forEach {\n    it.await()\n}\n\noutput.close()\n```", "```kt\nval channel = Channel<Int>()\n\nval j = launch {\n    for (i in 1..10) {\n        channel.send(i)\n        println(\"Sent $i\")\n```", "```kt\n    }\n}\n\nj.join()\n```", "```kt\nval channel = Channel<Int>(5)\n```", "```kt\nSent 1\nSent 2\nSent 3\nSent 4\nSent 5\n```", "```kt\nval actor = actor<Int>(capacity = 5) {\n    ...\n}\n\nval producer = produce<Int>(capacity = 10) {\n    ...        \n}\n\n```", "```kt\nfun producer(name: String, repeats: Int) = produce {\n    repeat(repeats) {\n        delay(1)\n        send(name)\n    }\n}\n```", "```kt\nval repeats = 10_000\nval p1 = producer(\"A\", repeats)\nval p2 = producer(\"B\", repeats)\nval p3 = producer(\"C\", repeats)\n\nval results = ConcurrentHashMap<String, Int>()\nrepeat(repeats) {\n    val result = select<String> {\n        p1.onReceive { it }\n        p2.onReceive { it }\n        p3.onReceive { it }\n    }\n\n    results.compute(result) { k, v ->\n        if (v == null) {\n            1\n        }\n        else {\n            v + 1\n        }\n    }\n}\n\nprintln(results)\n```", "```kt\n{A=8235, B=1620, C=145}\n{A=7850, B=2062, C=88}\n{A=7878, B=2002, C=120}\n{A=8260, B=1648, C=92}\n{A=7927, B=2011, C=62}\n```", "```kt\n...\nval result = selectUnbiased<String> {\n    p1.onReceive { it }\n    p2.onReceive { it }\n    p3.onReceive { it }\n}\n...\n```", "```kt\n{A=3336, B=3327, C=3337}\n{A=3330, B=3332, C=3338}\n{A=3334, B=3333, C=3333}\n{A=3334, B=3336, C=3330}\n{A=3332, B=3335, C=3333}\n```", "```kt\nvar counter = 0\n\nval jobs = List(10) {\n    launch {\n        repeat(1000) {\n            counter++\n            yield()\n        }\n    }\n}\n\nrunBlocking {\n    jobs.forEach {\n        it.join()\n    }\n    println(counter)\n}\n```", "```kt\nvar counter = 0\nval mutex = Mutex()\n\nval jobs = List(10) {\n    launch {\n        repeat(1000) {\n            mutex.lock()\n            counter++\n            mutex.unlock()\n            yield()\n        }\n    }\n}\n```", "```kt\nrepeat(1000) {\n    try {\n        mutex.lock()\n        counter++                     \n   }\n finally {\n        mutex.unlock()                    \n    }\n\n    yield()\n}\n```", "```kt\n...\nrepeat(1000) {\n    mutex.withLock {\n        counter++\n    }\n    yield()\n}\n...\n```", "```kt\nval p1 = produce {\n    repeat(10) {\n        send(\"A\")\n    }\n}\n\nval p2 = produce {\n    repeat(5) {\n        send(\"B\")\n    }\n}\n\nrunBlocking { \n    repeat(15) {\n        val result = selectUnbiased<String> {\n            p1.onReceive {\n                it\n            }\n            p2.onReceive {\n                it\n            }\n        }\n\n        println(result)\n    }\n}\n```", "```kt\nrepeat(15) {\n    val result = selectUnbiased<String> {\n        p1.onReceiveOrNull {\n            // Can throw my own exception\n            it ?: throw RuntimeException()\n        }\n        p2.onReceiveOrNull {\n            // Or supply default value\n            it ?: \"p2 closed\"\n        }\n    }\n\n    println(result)\n}\n```", "```kt\nvar count = 0\nwhile (count < 15) {\n    val result = selectUnbiased<String?> {\n        p1.onReceiveOrNull {\n            it\n        }\n        p2.onReceiveOrNull {\n            it\n        }\n    }\n\n    if (result != null) {\n        println(result)\n        count++\n    }\n}\n```", "```kt\nval batman = actor<String> {\n    for (c in this) {\n        println(\"Batman is beating some sense into $c\")\n        delay(100)\n    }\n}\n\nval robin = actor<String> {\n    for (c in this) {\n        println(\"Robin is beating some sense into $c\")\n        delay(250)\n    }\n}\n```", "```kt\nval j = launch {\n    for (c in listOf(\"Jocker\", \"Bane\", \"Penguin\", \"Riddler\", \"Killer Croc\")) {\n        val result = select<Pair<String, String>> {\n            batman.onSend(c) {\n                Pair(\"Batman\", c)\n            }\n            robin.onSend(c) {\n                Pair(\"Robin\", c)\n            }\n        }\n        delay(90)\n        println(result)\n    }\n}\n```", "```kt\nBatman is beating some sense into Jocker\n(Batman, Jocker)\nRobin is beating some sense into Bane\n(Robin, Bane)\nBatman is beating some sense into Penguin\n(Batman, Penguin)\nBatman is beating some sense into Riddler\n(Batman, Riddler)\nRobin is beating some sense into Killer Croc\n(Robin, Killer Croc)\n```", "```kt\nval elements = 10\nval deferredChannel = Channel<Deferred<Int>>(elements)\n\nlaunch(CommonPool) {\n    repeat(elements) { i ->\n        println(\"$i sent\")\n        deferredChannel.send(async {\n            delay(if (i == 0) 1000 else 10)\n            i\n        })\n    }\n}\n\n```", "```kt\nval time = measureTimeMillis {\n    repeat(elements) {\n        val result = select<Int> {\n            deferredChannel.onReceive {\n                select {\n                    it.onAwait { it }\n                }\n            }\n        }\n        println(result)\n    }\n}\n\nprintln(\"Took ${time}ms\")\n```", "```kt\nTook 1010ms\n```", "```kt\nval stop = async {\n    delay(600)\n    true\n}\n\n```", "```kt\nval channel = Channel<Deferred<Int>>(10)\n\nrepeat(10) {i ->\n    channel.send(async {\n        delay(i * 100)\n        i\n    })\n}\n```", "```kt\nrunBlocking {\n    for (i in 1..10) {\n        select<Unit> {\n            stop.onAwait {\n                channel.close()\n            }\n            channel.onReceive {\n                println(it.await())\n            }\n        }\n    }\n}\n```"]