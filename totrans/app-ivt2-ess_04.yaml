- en: Chapter 4. Fling App – Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, you learned to use the MIT App Inventor Designer and Blocks Editor
    by creating your first fully functional mobile app! In this chapter, we will show
    you how you can take the basic Fling app and build it out by adding more complex
    features. We will demonstrate how to enable:'
  prefs: []
  type: TYPE_NORMAL
- en: A scoring mechanism that will display when the ball touches the top edge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code, so the ball can only be flung from the lower half of the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The increasing levels of difficulty by increasing ball speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also begin debugging. Debugging is a standard practice in app development
    and should be viewed as part of the process, not as something negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time you add new components to your app, we encourage you to share your
    app with others to get feedback. Not only will the feedback give you ideas about
    the design, but it will also help you learn what users want from an app game.
    Such information will prove invaluable once you begin designing apps from scratch.
    This chapter will not only help you discover new ways to enhance a game app, it
    will also trigger new paths of creativity! By the end of this chapter, your Fling
    app will resemble the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fling App – Part 2](img/00109.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Adding a scoring feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since most game apps include some sort of scoring feature, we will add this
    code to our Fling app. The score will display in the same label that will also
    display the **Game Over** text.
  prefs: []
  type: TYPE_NORMAL
- en: Coding scoring blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We left off in the last chapter with the ball bouncing off all the edges except
    the bottom edge. Now, we want to program the app to increase the score by one
    point every time the ball reaches the top edge. We will use another **if**/**then**
    block and add it into the **else** portion of the existing **if/then/else** block
    within the **when** **Ball1.EdgeReached** event, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Can you guess what block will fit in the **if** opening? If the ball hits the
    top edge, then the app will increase the score by **1**. In [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, you learned that the bottom edge is represented by **-1** (and the
    top edge is represented by 1). Since we've already created an if/then scenario
    for the ball hitting the bottom edge, we can copy this set of blocks and adjust
    it for the ball hitting the top edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the blue block from the existing **if** block (note that by copying the
    blue block, you will also automatically copy the embedded orange **get edge**
    block and the blue **-1** math block). Snap these pasted blocks into the new **if**
    block and change **-1** to **1**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have coded: if the top edge is reached, then what will happen? We want the
    app to record a point. To code the score feature, we will first create a **global
    variable**. A global variable is a value that can be used by any block, whereas
    a **local variable** is one that can only be used by the specific block for which
    it was intended. Go to the **Variables** block drawer and select the orange, **initialize
    global name to** block.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00112.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **name** and change the text to **score**. Next, in the **Math** drawer,
    select the **0** blue Math block. Connect it to the **initialize global score
    to** block. Your blocks will now look like the following screenshot. Note that
    this **initialize global name** block does not fit into any other block; it stands
    alone with the attached Math **0** block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By setting the global variable equal to **0**, essentially, we have established
    the initial score to be set to `0`. Now, we can program the app to add **1** to
    this score. Go back into the **Variables** block drawer and select the **set to**
    block. Click on the little arrow in the middle of the block and select **global
    score** from the drop-down menu (this is now available for us to select because
    we created the global variable). Insert the block into the empty **then** slot,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will insert a Math block into the **set global score to** block because,
    every time the top edge is reached, we will want to get the current score (in
    this case, **0**) and add **1** to it. Therefore, we will need the blue Math addition
    block, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first blank will be filled with an orange **get global score** block, in
    the second block after the plus sign, there will be a number block filled with
    **1**, as shown in the following screenshot. There are two ways to find the get
    global score block. One is in the Variables drawer. Click on the get to block
    and then click on the downward arrow to select global score from the drop down
    menu. Or, you can hover (not click) over the initialize global score block and
    both a set and get global score block will appear. Select the get global score
    block. The reason we are using the get global score block and not the 0 block
    is because we want to add 1 to the most recent score. At the beginning of the
    game, the score is 0, but as soon as the ball hits the top edge, the new global
    score will be 0+1, then 1+1 (and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding scoring blocks](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So now, we have created the code to update the score each time the top edge
    is reached. But we haven't yet created the code to display the score. Let's do
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the score label
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at the blocks in the first **then** section in the following screenshot
    and notice the name change of our Score Label. Since the Score Label will be displaying
    both the score and the level, we decided to make that clear in our label name.
    In the Designer, we renamed the Label from Score to Score_Level_Label. This change
    updates in the Blocks Editor as well. The block name initially was, set Score.Text
    to is now, set Score_Level_Label.Text to. The blocks drawer is also updated. We
    show you this edit in the middle of development because sometimes, no matter how
    well thought out your app is, you may discover ways to improve it as you begin
    coding. Changing the Label name is not necessarily integral to the functioning
    of our app, but it helps us to be more clear in our design
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the Label will now display both the score and the level, we need to code
    that. Copy the green **set Score_Level_Label.Text to** block, from the if/then/else
    block. Since it will also copy the pink **"Game Over"** text block, you can merely
    delete this block as we won''t need it. Instead, go into the pink **Text** blocks
    and choose the **join** block, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need this block to set the Label text to display pieces of information:
    the score and the level. If you think about it, we can''t just display two numbers
    because the user won''t know what they mean. We have to display: the word **Score**
    and the actual score (whatever number it is) and the word "Level" and the actual
    level (whatever number that is). To begin, we will just add two things, the word
    Score and the actual score. You probably can guess that the first block to attach
    to the join block is another blank **Text** block will. Type the word **Score:**
    with a space after the colon (so there will be a space between the word and the
    score number). The second block is the orange **get global score** block.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Increasing difficulty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you stop and think about our app as it stands, it would be very easy to cheat!
    A user could just keep the ball very near the top edge and fling it a short distance
    to amass tons of points! If you'd like to make it harder for the user to score
    points, we will show you one way to increase the difficulty. If, on the other
    hand, you are making this app for a young user and want it to be easy for them
    to score points, then you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the game's dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the game stands, the ball is moving downward and whenever your finger touches
    it, it will get flung in another direction (to be exact, 360 degrees minus the
    direction it was heading). We can program the app so the ball only responds to
    a fling when it is below the middle of the screen. Can you guess how we might
    program this? If you guessed using an **if**/**then** block, you're on the right
    track! If the ball is below the middle of the screen, then it can be flung.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our blocks look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the game''s dynamic](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We want to tell the app to first check and see whether the ball is below the
    middle of the screen. We've coded something similar if you recall when we used
    the **Screen1.Width** block. Since we won't know the screen size of every user,
    we cannot just input a specific number and divide it by 2\. But we can get the
    user's screen size with the **Screen1.Height** block and divide this by 2\. In
    [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc "Chapter 3. Navigating
    the App Inventor Platform"), *Navigating the App Inventor Platform*, you also
    learned that **x** is used to represent the width and **y** is used to represent
    the height. The values of **x** and **y** start with `0`, `0` in the top left
    corner of the screen. So, we will use the **y** variable, which represents the
    height. We know that **y** gets bigger from top to bottom. Thus, we want to enable
    the ball to be flung if **y** is bigger than the screen size divided by `2`. For
    example, suppose that the height of the screen is `100` (with the value of `0`
    at the top and the value of `100` at the bottom). If the ball is at *y = 51*,
    it will be just below the halfway mark. Thus, it will be enabled to be flung.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin coding this scenario temporarily, remove **set Ball1.Heading** and
    its accompanying blocks from the when Ball1.Flung event block. Add an **if**/**then**
    block and a **greater than Math** block (select the equals Math block and then
    chose the greater than symbol from the drop down menu by clicking on the downward
    arrow in the center of the block) to the **if** opening, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the game''s dynamic](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, hover over (don''t click on) the light orange box with the variable **y**
    in the **when Ball1.Flung** event block. This will produce a pop-up window. Select
    the top choice, **get y**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the game''s dynamic](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Insert the **get y** block into the first opening before the greater than sign.
    Remember we won't be adding a number into the second opening, but rather an equation
    of the screen height divided by 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the game''s dynamic](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the second opening, insert another **Math** block—this time, a division **Math**
    block because we want the **y** to be greater than the screen height divided by
    **2**. Get the **Screen1.Height** block from the **Screen1** block drawer and
    the **number** block from the **Math** drawer, and change the value to **2**.
    Insert the **Screen1.Height** block into the first opening of the **Math** division
    block and insert the number 2 block into the opening after the division sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reinsert the set **Ball1.Heading** blocks you removed earlier into the **then**
    opening of the **if**/**then** block, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the game''s dynamic](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, our app checks to see *if* the ball's **y** height value is below the halfway
    point on the screen. If it is, *then* the ball will be flung in a direction indicated
    by our formula, **360 - Ball1.Heading**. If it is not, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer games typically have multiple levels where the difficulty of playing
    the game progressively increases. This is what makes a game fun, challenging,
    and even somewhat addictive. We want to incorporate levels in our game as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One simple way to make the game play harder and harder is to increase the speed
    of the ball as the player continues to score points. You can create whatever tiers
    you like, but for the purpose of this tutorial, we will create a simple tier system:
    whenever a player scores 5 points, the player has completed a level. Again, to
    keep it simple, we will not pause game play (as is common in most computer games)
    when a level is completed. The player will automatically move on to the next level,
    which will also increase the speed of the ball.'
  prefs: []
  type: TYPE_NORMAL
- en: To figure out whether a level change is needed or not, we will code the app
    to constantly check the value of score. Each time the score is incremented, the
    app will check to see whether it is a multiple of 5 (for example, *score = 5,
    10, 15, 20, and so on*). If the score is indeed a multiple of 5, it will mean
    that the player has scored another 5 points and a level change should occur. To
    change the level, we will simply increase the speed a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained earlier in this chapter, the event, **Ball1.EdgeReached**, contains
    the code that increments the score: the **set global score to** block. Whenever
    the score increases, the label will update to display the new score (the previous
    score plus 1). As you can see in the blocks shown in the following screenshot,
    the block immediately after the score-increment block is the **set Score_Level_Label.text
    to** block to update the score displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add an **if**/**then** block right after the **set Score_Level_Label.text**
    block. Do you remember where to find the **if**/**then** block?
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating levels](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s think about the condition that we want to insert in the empty socket
    next to **if**. We want to check and see whether the score is a multiple of 5
    (if it is a multiple of 5, then the remainder will be 0). In order to do so, we
    need to complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the current value of the score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Divide its value by 5 and calculate the remainder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See whether the remainder is equal to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To achieve these three subtasks, we will first get the **get global score**
    block just like we did when we used this block to increment the score. This block
    can be select from the **Variables** blocks or can be copied from your current
    set of blocks. This completes task 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will get the remainder of the block from under the **Math** blocks.
    This step is not as obvious. When you go to the Math blocks, you will not see
    any remainder block. Instead, select the **modulo of** block, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating levels](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the downward-facing triangle to the right of **modulo of** and select
    **remainder of** from the drop-down list. Modulo, remainder, and quotient are
    different mathematical operations related to division. Hence, they all belong
    to the same block. Place the **get global score** block within the first slot
    of the **remainder of** block. Since we want to calculate the remainder of the
    score when divided by 5, place number **5** in the second slot of the **remainder
    of** block (that is, insert a Math number block and change the value from 0 to
    5). This completes step 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to check whether this remainder is equal to 0\. If it is equal
    to 0, then it is time to increase the level (speed). If it is not, the level (speed)
    will remain the same. To check for the equality of numbers, we will need an **equal
    to** block from the **Math** blocks. Plug the **remainder of** block (and its
    accompanying **get global score / 5** blocks) that we created in step 2 into the
    left side of the **equal to** block and the number **0** into the right side.
    The following screenshot shows the completed steps plugged to the **if** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating levels](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Blocks placed within the **then** part of an **if**/**then** statement are executed
    only when the condition plugged to the **if** statement is true. In this case,
    when the score is a multiple of 5 (that is, the whole remainder equals 0 and the
    if block evaluates to be true), we would want to increase the speed. We need two
    blocks from the Ball1 drawer. The first block, **Ball1.Speed**, gives us the current
    value of **Ball1**'s speed property. The second one, **set Ball1.Speed**, lets
    us change the speed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating levels](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we want to increase the speed relative to the current speed, we will
    use both these blocks by:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Ball1.Speed** to get the current speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increasing the **Ball1.Speed** value by a small amount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the result to set the new speed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To complete these steps, drag an **add** block from the **Math** blocks and
    attach it to the **set Ball1.Speed** block. Insert the **Ball1.Speed** block into
    the opening on the left-hand side of the plus sign and a **number** Math block
    set to 2 (the small amount that we are increasing the speed by) in the opening
    on the right-hand side of the plus sign. This completes tasks 1, 2, and 3\. Finally,
    we will place the block within the **then** block, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating levels](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To summarize, whenever the user scores a point, the new score will be calculated.
    Then, the app will check to see whether the new score is a multiple of 5 or not.
    If it is indeed a multiple of 5, the app will increase the speed by a little bit
    to make the game harder. If the score is not a multiple of 5, nothing will change;
    the speed will remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: We have completed coding the leveling part of our app! Can you think of what
    is still missing? We need to display the new level in the label!
  prefs: []
  type: TYPE_NORMAL
- en: Updating the score label to display the level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our game, we have a label that displays the score or the words **"Game Over"**.
    Now that we have implemented levels as well, we also want to display the level
    within that label.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, we used the **join** block to join two
    pieces of information and display it in the label—the word **Score:** (there is
    a blank space after the colon) and the value of the score. Now that we want to
    display the level, we will add three more pieces of information to this **join**
    block. There is another blank space after the score (value), followed by the word
    **"Level: "** (there is also a blank space after the colon here), and finally
    the value of level.'
  prefs: []
  type: TYPE_NORMAL
- en: To make room for these three new pieces of information, we need to add strings
    to the existing **join** block. Click on the blue square in the top left corner
    of the **join** block. This will open a pop-up window. Inside this popup, drag
    the **string** block from the top left corner into the **join** block on the right-hand
    side. Do this three times. Each time you add another **string**, you will see
    a new space appear in the **join** block below the **get global score** block.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label to display the level](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you have done this correctly, there will be three empty slots, as shown in
    the following screenshot. Now, click anywhere outside the popup to close the pop-up
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label to display the level](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we are ready to plug in the three new pieces of information related to
    the levels. Plug in a blank text box in the first open slot (the blank text block
    is the first block in **Text** block's drawer). Even though it seems like this
    contains a blank space, we must make one. Click inside the blank text and press
    your keyboard's spacebar to create a space. In the next empty slot, plug in another
    blank text block, and click and type in the word **Level:** with a space after
    the colon.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have correctly guessed, the last piece of text we will plug into
    the **join** block is the level value. You might be wondering where this level
    value is going to come from. We will actually calculate this from the current
    score value.
  prefs: []
  type: TYPE_NORMAL
- en: When we implemented the levels, we assumed that an increase in score by 5 will
    trigger a level change. Hence, scores 0 to 4 correspond to level 0, scores 5 to
    9 correspond to level 1, scores 10 to 14 correspond to level 2, and so on. We
    can use some math to calculate the level from the score. As you might have guessed,
    the math that we are going to use here is the quotient operation. More specifically,
    we will divide the score by 5 and use the quotient part to determine our levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the quotient block, go back to **Math** Blocks drawer and drag a **modulo**
    block. Then, click on the downward pointing triangle to change it to **quotient**.
    Copy a **get global score** block and plug it into the first open socket of the
    **quotient** block. Insert a Math **number** block into the second opening and
    change it to `5`. The completed blocks are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label to display the level](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is an ideal time to reconnect your mobile device to your Fling app. Your
    Label will now display both the score and the level, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the score label to display the level](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Updating the Reset button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Don''t think that we have forgotten about our bug! Have you figured out what
    the bug is?" In the last chapter, we programmed the Reset button to move the ball
    to the top of the screen (y=2) and to a random x value. But, before the Play button
    starts the ball moving, it also moves the ball to a random x location. And the
    problem is, it isn''t the same location that the Reset button previously set.
    So the ball moves once upon Reset and again on Play. We can fix this problem!"
    START A NEW PARAGRAPH Start it with "In addition to fixing the bug, we have some
    other updates to the Reset and Play buttons. Now that we have added scoring and
    leveling to our game, we need to edit the Reset button. There are several tasks
    related to resetting the game. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Stopping the ball's motion and resetting the position of the ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resetting the score variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the label used to display the score.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another point to note is that we can't assume that the only reason a user presses
    Reset is because the ball hit the bottom edge and the game ended. We also have
    to think of the scenario of the user pressing the Reset button to stop the game.
  prefs: []
  type: TYPE_NORMAL
- en: To reset the position of the ball, we will reuse the **Ball1.MoveTo** block
    that we already coded in [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, when we created the **Play_Button.Click** event. When the user presses
    **Play** button, the ball will move to a random **x** coordinate between the value
    of **1** and the screen width.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Reset button](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You may also recall in [Chapter 3](part0020_split_000.html#J2B81-9c0b907946184095a315b26c8a9b12bc
    "Chapter 3. Navigating the App Inventor Platform"), *Navigating the App Inventor
    Platform*, that we programmed the **Reset** button to move the ball to a random
    integer between **1** and the screen width, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Reset button](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As the app is currently programmed, the Reset button moves the ball to a random
    *x* position at the top of the screen and the Play button also moves the ball
    to a random *x* position at the top of the screen, but these two random positions
    are not the same. Imagine a scenario in which the ball hits the bottom edge and
    ends the game. A user presses Reset to move the ball back up to the top of the
    screen. It goes to a random *x* location. Then, when the user presses Play, the
    ball is again reset to a new random *x* location before it starts moving downward.
  prefs: []
  type: TYPE_NORMAL
- en: We first programmed the Play button to position the ball at the top of the screen,
    because the first time the game is played, the user wouldn't press the Reset button,
    but rather the Play button. However, after the game is played once, the user would
    press Reset and thus the Play button would no longer need to reposition the ball,
    since the Reset button will perform this function.
  prefs: []
  type: TYPE_NORMAL
- en: We want the Play button to let the ball start moving from the same location
    that the Reset button previously randomly selected. To do this, we need to program
    our app so that the Play button gets the ball's x location from the **Reset**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this Reset_Button and Play_Button communication happen, we will first
    create a variable called **randomX**. This variable will initially be set to **0**.
    Initializing a variable to some value (even if that value is not used later on)
    is important. Select the **initialize global name to** block from the **Variables**
    blocks drawer. Change the name to **randomX**. Select a number **Math** block
    and attach it, as shown in the following screenshot (note that this set of blocks
    stands on its own; it does not fit into the other event blocks):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Reset button](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After initializing the global variable, randomX, we can now use it for both
    our Reset and Play buttons. If you recall, when we programmed the Play_Button.Click
    event, we enabled the ball to start moving. We set the value of the set Ball1.Enabled
    block to true, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Reset button](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, for the **Reset** button, we want to disable the ball. And we do this by
    making the value **false**.
  prefs: []
  type: TYPE_NORMAL
- en: First, copy and paste the **set Ball1.Enabled** block; it will also copy and
    paste the attached **true** block. Simply click on the arrow to the right of the
    word **true** and you will be able to select **false**. This block disables the
    ball's movement. This was one of our goals, since the user will expect the game
    to stop when the Reset button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, select the **set global randomX** block from the **Variables** block (it
    will be available as a choice in the blocks drawer, since we initialized the global
    variable, **randomX**). We will generate a random integer for the x coordinate
    and store it in this **randomX** variable. You know how to do this because we
    have already created the blocks to move the ball to a random x integer. Copy and
    paste the **random integer from to** blocks and add them to the **set global randomX
    to** block, as shown in the following screenshot. Once we set the global randomX
    variable to a random integer, we will use this variable in the **Call Ball1.MoveTo**
    block. The following screenshot shows how to generate a random number, store it
    in the variable (set **global randomX**), and then use this variable (get **global
    randomX**). This completes *Task 1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Reset button](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Tasks 2* and *Task 3* are relatively easy. Since the Reset button also resets
    the score to equal zero, we will also set the score variable to zero. To do this,
    we will copy and paste the **set global score** block from the **Ball1.EdgeReached**
    event and modify the right-hand side to simply be a Math number block of the value
    0\. For *Task 3*, we will simply copy and paste the **Score_Level_Label.Text**
    block that we created previously in this chapter. This block always updates the
    label using the latest value of the score and the level. Since we are resetting
    the score to **0** right before we execute this block, this block will correctly
    reset the label to show **0** for the score and the level. (Note: blocks execute
    from top to bottom.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Reset button](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Updating the Play button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we built the Play button, the blocks resembled the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Play button](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: But now, we want to redo the Play button blocks because we no longer want the
    Play button to set the ball's x random location. Instead, we want the Play button
    to get the location of the ball from the Reset button. This way, when the Play
    button is pressed, the ball will just begin moving from where it already is, having
    just been reset to the top of the screen by the Reset button between the very
    first time a user plays the game, the Play button will set the random location
    of the ball using the blocks we already programmed. Then the first time (and ensuing
    times) that the Reset button is pressed and sets the location of the ball at the
    top of the screen, we want the ball to start moving from that location when the
    Play button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it might be obvious that we will use an **if**/**then**/**else**
    event block. The reasoning, however, is a little counter-intuitive. The only time
    the Play button determines the ball's x location is the very first time that the
    user plays the app. This is when the global variable, randomX, has the value of
    0\. Instead of saying if the global randomX is equal to 0, then do something,
    we are going to say if the **global randomX** is not equal to 0, then do something.
    We are going to program the blocks this way because there is only one time this
    won't happen. Every other time the app checks this information, the global randomX
    will indeed be a value between 1 and the screen width (as we coded in the Reset
    button). If the **global randomX** *is not equal to* 0, *then* move the ball to
    the global randomX location set by the Reset button. Otherwise (else), we will
    move the ball to a random integer between 1 and the screen width (this code will
    only occur once—the first time the user plays the Fling app).
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating the Play button](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We hope you found this chapter to be challenging yet rewarding. You have learned
    how to take a simple app and make it more intermediate by adding more complex
    features and code. Each feature, scoring, fling capability, and level requires
    a lot of thought on how each would work and interact with each other. As you experienced,
    enabling scoring and leveling mechanisms required us to alter code in a variety
    of block locations. Similarly, we had to reexamine how our buttons functioned
    and reprogram the buttons. You will discover that this is a typical process in
    coding. Changing or adding one thing requires reevaluating how other things would
    work and interact. Also, this chapter demonstrates how much thought needs to go
    into planning an app. Earlier in this chapter we decided to update our Label from
    Score to Score_Level_label to reflect that it would be displaying the Score, Level
    and Game Over. If you don't take sufficient time to map out your app design on
    paper initially, then you will most likely end up having to do more re-working
    than you may have anticipated. Most programming efforts require coders to do some
    troubleshooting along the way, so don't be discouraged if you find that your app
    building includes many rewrites. But, you can avoid grand overhauls by really
    thinking through each aspect of your app's features ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will begin working on an intermediate app, an event
    app to plan events, parties, or meetings.
  prefs: []
  type: TYPE_NORMAL
