# 第二章. 强制访问控制和 SELinux

在第一章《Linux 访问控制》中，我们介绍了基于权限的访问控制系统的不足之处。在这些系统中，对象的所有者对其权限标志拥有完全控制权，并且在以`root`身份或具有某些能力执行时可以展示出更大的能力（例如，`chown`的能力）。在本章中，我们将：

+   检查 MAC 的基本原理

+   介绍一些 SELinux 的行业驱动因素

+   讨论标签、用户、角色和类型

+   探索实现具体策略以允许和约束对象交互

理想的 MAC 系统保持提供对内核资源（如文件）的明确访问控制属性，无论对象的所有者是谁。例如，在 MAC 系统中，对象的所有者可能无法完全控制其权限。在 Linux 中，MAC 框架与当前的 DAC 控制正交工作。这意味着 MAC 控制不会干扰 DAC 控制。换句话说，为了避免 MAC 和 DAC 系统之间可能发生的冲突，内核在检查 MAC 权限之前使用 DAC 权限验证访问。如果 DAC 权限导致权限违规，则不会检查 MAC 权限。内核仅在 DAC 权限通过时才对 MAC 权限提供者进行访问验证。任何级别的失败都将导致返回`EACCESS`错误。如果 DAC 和 MAC 权限都通过，则内核资源（例如，文件描述符）将返回到用户空间。

在 Linux 中，一个名为**Linux 安全模块**（**LSM**）的框架在 Linux 2.6.x 系列内核中进行了合并。这个框架允许你通过将 LSM 钩子绑定到安全提供者来在构建时选择启用强制访问控制系统。**安全增强型 Linux**（**SELinux**）是内核中第一个使用此 MAC 安全框架的消费者，并且是实现强制访问控制系统的一种实现。SELinux 在多种 Linux 系统中提供，例如**红帽企业 Linux**（**RHEL**）以及随后的 Fedora。最近，它已经开始与 Android 一起提供。对于那些希望审查它的人来说，SELinux 的源代码可以在 Linux 源代码树中的`kernel/security/selinux`下找到。

# 回归基本原理

SELinux 是美国政府和犹他大学的**FLUX 高级安全内核**（**FLASK**）设计的重新实现。SELinux 和 FLASK 架构提供了一个中央策略文件，在确定访问控制决策结果时使用。这个中央策略是白名单形式。这意味着所有访问控制规则都必须由策略文件明确定义。这个策略文件被抽象化，并由一个名为安全服务器的软件组件提供。当 Linux 内核需要做出访问控制决策并且 SELinux 被启用时，内核通过 LSM 钩子与安全服务器交互。

在运行系统中，进程是获得 CPU 时间以执行任务的活跃实体。用户只是调用这些进程来代表他们完成工作。这是一个重要的概念。当我们编写这本书时，我们相信运行在我们机器上的带有我们凭据的字处理器不会打开我们的 SSH 密钥并将它们嵌入到文档元数据中。目前，进程控制着计算资源，而不是用户。进程是运行实体，是进程向内核发出系统调用以获取资源，而不是物理人类。考虑到这一点，SELinux 系统中的第一个行为者是进程，通常被称为**主体**。它是访问文件的主体。它是安全服务器将用于做出访问决策的主体。

因此，主体利用内核资源。这类内核资源是**目标**的一个例子。主体在目标上执行操作。自然地，人们会问：“主体执行什么操作？”这些被称为访问向量，通常与执行的系统调用的名称相关。例如，主体可以在目标上执行`open`操作。需要注意的是，目标也可以是进程。例如，如果系统调用是`ptrace`，主体可能是调试器之类的，而目标是希望调试的进程。主体通常是进程，但目标可以是进程、套接字、文件或其他。

# 标签

SELinux 通过标签提供描述与目标和主体相关的策略的语义。标签是与对象关联的元数据，它维护了主体和目标访问信息。与该对象关联的数据是一个字符串。回到调试器示例，`gdb`进程可能有一个主体标签字符串为`debugger`，而目标可能有一个标签为`debugee`。然后在安全策略中，可以使用一些语义来表示具有主体标签`debugger`的进程允许调试具有目标标签`debugee`的应用程序。

幸运的是，也许不幸的是，SELinux 并不使用如此简单的标签。实际上，标签由四个由冒号分隔的字段组成：用户、角色、类型和级别。这种额外的复杂性提供了非常灵活的控制选项。

## 用户

标签中第一个字段用于标识用户。用户字段被用作**基于用户的访问控制**（**UBAC**）设计的一部分。然而，这通常与人类用户的概念不相关，而是与 DAC 中的用户概念相关。SELinux 用户通常定义一组传统用户。一个常见的例子是将所有普通用户标识为 SELinux 用户`user_u`。也许为系统进程保留一个单独的用户，例如`system_u`。在桌面 SELinux 社区中，字符串的用户部分通常以`_u`后缀。

## 角色

标签中的第二个字段是角色。角色被用作**基于角色的访问控制**（**RBAC**）设计的一部分。角色被用来为用户提供额外的粒度。例如，假设我们有一个用户字段，`sysadm_u`，为管理员保留。管理员可能执行不同的任务，并且根据任务的不同，`sysadm_u`中用户的角色（以及因此的权限）可能会改变。例如，当管理员需要挂载和卸载文件系统时，角色字段可能会变为`mount_admin_r`。当管理员设置`iptables`规则时，角色可能会变为`net_admin_r`。角色允许在执行的任务范围内隔离权限。

## 类型

类型是冒号分隔标签的第三个字段。类型字段在 SELinux 访问控制模型的**类型强制**（**TE**）部分进行评估。TE 是驱动 SELinux 安全能力的最主要组件，并且正是在这一点上，策略开始发挥作用。

SELinux 基于一个白名单系统，默认情况下一切都被拒绝，并且需要策略的明确批准才能发生交互。这种批准最初是通过策略确定的，通过一个允许规则引用了主体和目标的类型。SELinux 类型也可以分配属性。属性允许你为许多类型赋予一组共同的规则。属性可以帮助最小化类型的数量，并且可以类似于继承模型的方式使用。

# 访问向量

数据通过系统调用和可能的用户定义访问方法被进程访问。用户定义的访问方法通常通过用户空间对象管理器进行控制。这些访问路径，也称为向量，构成了一组可以应用于对象的操作。例如，如果一个进程打开一个文件，向文件中写入一些数据，然后读取它，所执行的访问向量将是`open`、`read`和`write`。如果一个进程调试另一个进程，访问向量将是`ptrace`。

# 多级安全

SELinux 还支持**多级安全**（**MLS**）模型，该模型向**贝尔-拉帕卢拉**（**BLP**）模型致敬，但也可以使用其他模型。BLP 模型是为了正式化国防部的安全政策而创建的。例如，一个拥有机密清级的个人不应该能够阅读绝密材料。然而，假设这个人有一个最终需要保护在绝密级别的绝妙想法；那么这些数据就可以被“升级”为绝密。这被称为“不向上读取或向下写入”。

SELinux 对这个字段的实现有子字段。第一个字段是敏感性，它始终存在。在先前的例子中，相关的敏感性包括机密和绝密。第二个子字段是类别，可能不存在。这些字段在政府分类的背景下也有意义。数据本身可能被分类，因此虽然敏感性相同，例如绝密，但数据应仅向同一分类或类别内的人员传播。敏感性通过支配关键字以分层方式定义。在典型的策略中，`s0`是最低敏感性，而`n > 0`的`sN`是最高。因此，`s1`比`s0`有更高的敏感性。类别是集合。与级别相关的控制，该级别由敏感性和可能存在的类别组成，遵循集合理论概念，如支配和相等。在 MLS 安全中，所有交互默认允许，与类型强制不同。敏感性和类别都可以有范围，类别可以枚举。因此，一个标签可能有一些敏感性，以及不同数量的类别。

# 汇总

SELinux 标签非常灵活，有时也相当复杂。通常从关注类型强制的一个虚构例子开始是有益的。随后，随着对更精细粒度需求的显现，我们可以添加额外的字段。方便的是，你可以将这个模型投影到日常生活中，为材料提供一些可触摸的感觉。丹·沃尔什，一位杰出的 SELinux 人物，发布了一篇使用宠物作为类比的文章。让我们继续这个前提，但我们在进行中会做一些修改，并定义我们自己的例子。最好从简单的类型强制开始，因为它最容易理解。

### 注意

您可以阅读丹·沃尔什（Dan Walsh）介绍宠物类比的原博文章，链接为[`opensource.com/business/13/11/selinux-policy-guide`](http://opensource.com/business/13/11/selinux-policy-guide)。

假设我们拥有一只猫和一只狗。我们不希望猫吃狗粮。我们不希望狗吃猫粮。在这个时候，我们已经确定了两个主题，一只猫和一只狗，以及两个目标，猫粮和狗粮。我们还确定了一个访问向量，即吃。我们可以使用允许规则来实施我们的策略。可能的规则可能看起来像这样：

```kt
allow cat cat_chow:food eat;
allow dog dog_chow:food eat;

```

让我们用这个例子开始，并定义一个基本的语法来表示我们想要实施的访问控制。第一个令牌是`allow`，表示我们希望允许主体和目标之间的交互。狗被分配类型`dog`，猫被分配类型`cat`。猫食被分配类型`cat_chow`，狗食被分配类型`dog_chow`。在这个情况下，访问向量是`eat`。使用这个基本的语法，它也是有效的 SELinux 语法，我们限制动物只能食用它们应该吃的食物。注意类型后面的`:food`注释。这是目标对象的类字段。例如，也可能有`dog_chow` `treat`和`cat_chow`类，这可以表明我们希望以与允许访问非奖励食物不同的方式允许访问奖励。

假设我们再得到两只狗，我们的场景现在有三只狗。狗的大小不同：小、中、大。我们想要确保这些新来的狗不会吃其他狗的食物。我们可以为每只狗创建一个新的类型，并防止狗吃其他狗的食物。它可能看起来像这样：

```kt
allow cat cat_chow:food eat;
allow dog_small dog_small_chow:food eat;
allow dog_medium dog_medium_chow:food eat;
allow dog_large dog_large chow:food eat;

```

这将有效；然而，类型的总数将难以管理，如果我们允许大型狗吃小型犬种的食物，这个数量还会继续增长。我们可以做的是使用 MLS 支持为每个目标或狗食盆分配一个敏感度。让我们假设以下：

+   猫的食盆具有敏感度，`tiny`

+   小型狗的食盆具有敏感度，`small`

+   中型狗的食盆具有敏感度，`medium`

+   大型狗的食盆具有敏感度，`large`

我们还需要确保受试者被正确地标记了敏感度：

+   猫应该具有敏感度，`tiny`

+   小型狗应该具有敏感度，`small`

+   中型狗应该具有敏感度，`medium`

+   大型狗应该具有敏感度，`large`

在这一点上，我们需要引入额外的语法来允许交互，因为默认情况下，MLS 允许所有操作，TE 拒绝所有操作。我们将使用`mlsconstrain`来限制系统内的交互。规则可能看起来像这样：

```kt
mlsconstrain food eat (l1 eq l2);

```

这个限制只允许受试者食用具有相同敏感度级别的食物。SELinux 定义了关键字`l1`和`l2`。`l1`关键字是目标级别的，`l2`是源级别的。因为规则是白名单的一部分，这也防止了受试者食用不具有等效敏感度级别的食物。

现在，假设我们得到了另一只大型狗。现在我们有两只大型品种狗。然而，它们有不同的饮食，需要访问不同的食物。我们可以添加一个新的类型或修改现有的类型，但这会有导致我们使用敏感性来防止访问的相同限制。我们可以添加另一个敏感性，但这可能会因为存在 `large1` 和 `large2` 敏感性而变得混乱。在这个时候，类别可以让我们在控制上更加细致。假设我们添加一个表示品种的类别。我们的标签中的 MLS 部分看起来可能像这样：

```kt
large:golden_retriever
large:black_lab

```

这些可以用来防止黑拉布拉多狗吃金毛寻回犬的食物。现在假设你遇到了另一只狗，一只圣伯纳德狗。让我们说这只新的伯纳德可以吃任何大型狗的食物，但其他大型狗不能吃他的食物。我们可以标记食物碗和狗。

| 狗品种 | 主题标签 | 目标标签 |
| --- | --- | --- |
| 金毛寻回犬 | `Dog:large:golden_retriver` | `dog_chow:large:golden_retriver` |
| 黑拉布拉多 | `Dog:large:black_lab` | `dog_chow:large:black_lab` |
| 圣伯纳德 | `Dog:large:saint_bernard, black_lab, golden_retriever` | `dog_chow:large:saint_bernard` |
| 猫 | `Cat:tiny` | `cat_chow:tiny` |

现有的 `mlsconstraint` 需要修改。如果圣伯纳德狗的食物吃完了，它去了黑拉布拉多狗的盘子，圣伯纳德狗将无法从那里进食，因为级别不相等（`Dog:large:saint_bernard, black_lab, golden_retriever` 与 `dog_chow:large:black_lab` 不相同）。记住，级别是集合，因此我们需要引入某种概念，即如果主题集合支配目标集合，那么这种交互应该被允许。

这可以通过 `dom` 关键字来实现：

```kt
mlsconstrain food eat (l1 dom l2);

```

主导关键字 `dom` 与相等性不同，表示 `l1` 是 `l2` 的超集。换句话说，与目标 `l2` 相关的级别是可能与主题 `l1` 相关的更大集合中的级别。在这个阶段，我们能够将所有食物分开并按需使用。

在得到所有这些狗之后，你意识到是时候喂它们了，所以你拿了一袋狗粮，并把它放在每个碗里。然而，在你能够向碗中添加狗粮之前，我们需要一些允许规则和标签来允许你这样做。记住，SELinux 是基于白名单的系统，一切都必须明确允许。

我们将用 `human` 标签标记人类，并定义一些规则。哦，对了...别忘了喂猫：

```kt
allow human dog_chow:food put;
allow human cat_chow:food put;

```

我们还需要用所有敏感性和类别来标记 `human`，但当我们需要向系统中添加额外的狗、品种和品种尺寸时，这会变得繁琐。如果类型是 `human`，我们可以绕过这个约束。采用这种方法，我们始终相信 `human` 会将正确的食物放入适当的碗中：

```kt
mlsconstrain food eat (l1 dom l2);
mlsconstrain food put (t1 == human);

```

注意 MLS 约束中访问向量中`put`的增加。哇！现在人类可以喂他不断增长的动物群了。

所以你的生日到了，你收到了一个自动喂食器作为礼物。你给食物分配器贴上标签，`dispenser`，并修改 MLS 约束：

```kt
mlsconstrain food eat (l1 dom l2);
mlsconstrain food put (t1 == human or t1 == dispenser);

```

再次，我们看到有必要减少类型数量并组织起来，以防止重复行。这正是属性很有用的地方。我们可以通过首先定义属性来给我们的`human`和`dispenser`类型分配属性：

```kt
attribute feeder;

```

然后我们可以将其添加到类型中：

```kt
typeattribute human, feeder;
typeattribute dispenser, feeder;

```

这也可以在类型声明时完成：

```kt
type human, feeder;
type dispenser, feeder;

```

在这一点上，我们可以修改 MLS 语句，使其看起来像这样：

```kt
mlsconstrain food eat (l1 dom l2);
mlsconstrain food put (t1 == feeder);

```

现在假设你雇佣了一个家政服务。你想要确保任何由家政服务派来的人都能喂你的宠物。为了这个目的，让我们也让你的家庭成员来喂它们。这将是一个用户能力的良好用例。我们将定义以下用户：`adults_u`、`kids_u`和`maid_u`。然后我们需要添加一个约束语句来允许这些用户进行交互：

```kt
mlsconstrain food put (u1 == adults_u or u1 == maid_u);

```

这将防止孩子们喂狗，但允许女仆和成年人喂它们。现在假设你雇佣了一个园丁。你可以创建另一个用户`gardener_u`，或者你可以将用户合并成几个类别并使用角色。假设我们将`gardener_u`和`maid_u`合并为`staff_u`。园丁没有必要喂狗，因此我们可以使用基于角色的转换在职责之间移动员工。例如，假设员工可以执行多个服务，也就是说，同一个人可能既可能园艺也可能打扫。在这种情况下，他们可能承担`gardener_r`或`maid_r`的角色。我们可以使用 SELinux 的角色能力来满足这一需求：

```kt
mlsconstrain food put (u1 == adults_u or (u1 == staff_u and r1 == animal_care_r);

```

员工只能在`animal_care_r`角色下喂狗。如何进入和退出该角色实际上是唯一缺少的组件。你需要有一个明确定义的系统，以便员工可以进入动物护理角色并过渡出来。在 SELinux 中，这些过渡要么通过动态角色转换自动发生，要么通过源代码修改。我们假设任何人类实体（园丁、成年人、孩子）都从`human_r`角色开始。

动态角色转换与两部分规则一起工作，第一部分允许通过允许规则进行转换：

```kt
allow human_r animal_care_r;

```

角色转换语句如下：

```kt
role_transition human_r dog_chow animal_care_r;
role_transition human_r cat_chow animal_care_r;

```

这将是一个将`dog_chow`和`cat_chow`类型归入新属性`animal_chow`的好案例，并重写前面的角色转换：

```kt
typeattribute dog_chow, animal_chow;
typeattribute cat_chow, animal_chow;
role_transition human_r animal_chow animal_care_r;

```

通过这些角色转换，你只能从 `human_r` 角色转换到 `animal_care_r` 角色。

# 复杂性和最佳实践

正如你现在可以理解的那样，SELinux 是复杂的，可以被视为一种通用的“元编程策略语言”。你实际上是在编程，确定在像 Linux 这样非常复杂的操作系统（其中交互本身通常也很复杂）中允许发生哪些交互。就像一种编程语言一样，你可以用不同的风格和方法做事，从而得到不同的结果。也许在程序中使用 `switch()` 会使其更清晰、更容易理解，而不是使用 `else-if` 块，尽管从功能上讲，你最终会得到相同的结果。SELinux 也是如此；你通常可以使用强制机制的一部分来完成事情，而这部分事情更适合使用另一种机制来完成。在后面的章节中，我们将介绍对目标和主题进行标记的过程，这是系统更困难的部分之一。

当有人编写程序时，他们通常会有一套要求，即软件应该执行的操作。这些是软件的要求。在 SELinux 中，你应该做同样的事情。你应该收集安全要求并了解你希望保护自己免受其侵害的威胁模型。一个设计良好的 SELinux 策略将满足这些目标。一个优秀的设计将以易于扩展的方式实现这些目标。

# 摘要

在本章中，我们介绍了 SELinux 的主要工作部分，包括类型强制、多级和多类别安全以及用户和角色。此外，我们还看到了如何将这些技术应用于将越来越复杂的访问策略应用于具体示例。在下一章中，我们将跳出内核，了解 Android 在其非常独特的用户空间中是如何工作的。
