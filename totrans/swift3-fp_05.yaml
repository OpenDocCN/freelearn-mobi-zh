- en: Chapter 5. Generics and Associated Type Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics enable us to write flexible reusable functions, methods, and types
    that can work with any type. This chapter explains how to define and use generics
    and introduces the problems that can be solved with generics in the Swift programming
    language with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions and methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic type constraints and where clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associated type protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subclassing generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are generics and what kind of problems do they solve?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift is a type-safe language. Whenever we work with types, we need to specify
    them. For instance, a function can have specific parameters and return types.
    We cannot pass any type but the ones that are specified. What if we need a function
    that can handle more than one type?
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know that Swift provides `Any` and `AnyObject` but it is not a good
    practice to use them unless we have to. Using `Any` and `AnyObject` will make
    our code fragile as we will not be able to catch type mismatching during compile
    time. Generics are the solution to our requirement. Let''s examine an example
    first. The following function simply swaps two values (`a` and `b`). The values
    `a` and `b` are of the `Int` type. We have to pass only `Int` values to this function
    to be able to compile the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Type safety is supposed to be a good thing but it makes our code less generic
    in this case. What if we want to swap two `Strings`? Should we duplicate this
    function with a new one?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The bodies of these two functions are identical. The only difference relies
    on the function signature, more specifically, parameter types. Some may think
    it is a good idea to change these parameters'' type to `Any` or `AnyObject`. Remembering
    that `AnyObject` can represent an instance of any class type and `Any` can represent
    an instance of any type, excluding function types, let''s assume that we change
    the types to `Any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our API user can go ahead and send any types as parameters. They may not match.
    The compiler is not going to complain. Let''s examine the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our function is called by `String` and `Int` parameters. Our function swaps
    two values so the returned `a` becomes `Int` and `b` becomes `String`. This will
    make our code easily breakable and very hard to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not want to be that flexible. We do not want to use `Any` and `AnyObject`
    but we still need some level of flexibility. Generics are the solution to our
    problem. We can make this function generic and robust using generics. Let''s examine
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we replaced `Any` with `T`. It could be anything that is not
    defined already in our code or not a part of SDK. We put this type inside `<>`
    after the function name and before its parameters. Then we use this type in the
    parameter or return type. This way, we tell the compiler that our function accepts
    a generic type. Any type can be passed to this function but both parameters and
    return types have to be of the same type. So, our API user is not going to be
    able to pass `String` and `Int` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will complain about the type mismatch. This way, our code is type-safe
    and flexible so that we can use it for different types without worrying about
    type mismatching problems.
  prefs: []
  type: TYPE_NORMAL
- en: Generics are great tools in functional programming because with them, we are
    able to develop powerful, multipurpose, and generic functions. Let's examine a
    functional example of generics usage.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html "Chapter 2. Functions and Closures") , *Functions and
    Closures*, we had an example such as the following one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we need to develop a function that adds two `Int` values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to develop a function to calculate the square of an `Int` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we need to add two squared values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What if we needed to develop functions to multiply, subtract, or divide two
    squared values?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer was using higher-order functions to write a flexible function, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This higher-order function takes two other functions as parameters and uses
    them. We can call it for different scenarios such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using higher-order functions made them flexible and more generic but still
    not that generic. These functions work only with `Int` values. Using generics,
    we can make them work with any numerical type. Let''s make our calculate function
    even more generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `calculate` function accepts two values of the same type (`T`) and two functions.
    The `funcA` function accepts two values of the `T` type and returns a value of
    the `T` type. The `funcB` function accepts one value of the `T` type and returns
    a value of the same `T` type.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `calculate` function with any type now. For instance, we can
    pass any numeric number and the function will calculate it for that specific type.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things to notice here. First of all, the same techniques can
    be applied to methods, and secondly, we cannot define `typealiases` with generic
    types directly in pre-Swift 3.0\. Swift 3.0 introduces generic `typealiases` such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is great that our function works with any type, but what if our API user
    tries to use the `calculate` function on types that cannot be used in arithmetic
    calculations?
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate this problem, we can use type constraints. Using type constraints,
    we will be able to enforce the usage of a certain type. Type constraints specify
    that a type parameter must inherit from a specific class or conform to a particular
    protocol or protocol composition. Collections are examples of type constraints
    that we are already familiar with in the Swift programming language. Collections
    are generics in Swift, so we can have arrays of `Int`, `Double`, `String`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Objective-C, where we could have different types in a collection, in
    Swift we need to have the same type that complies to the type constraint. For
    instance, the keys of a `dictionary` must conform to the `Hashable` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify type constraints with either of the following two syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<T: Class>` or `<T: Protocol>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `calculate` example and define a numerical type constraint.
    There are different protocols such as `Hashable` and `Equatable`. However, none
    of these protocols are going to solve our problem. The easiest solution would
    be defining our protocol and extending the types that we want to use by conforming
    to our protocol. This is a generic approach that can be used to solve similar
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a protocol for numeric types with related basic math operators. We
    will require the types that we want to use to conform to our protocol. So we extend
    them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to define the type constraint in our function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we have a function that accepts only numerical types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it with a non-numeric type to ensure its correctness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This code example does not compile because of our type constraint, which can
    be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type constraints](img/B05092_05_01_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Where clauses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `where` clauses can be used to define more complex type constraints, for
    instance, to conform to more than one protocol with some constraints.
  prefs: []
  type: TYPE_NORMAL
- en: We can specify additional requirements on type parameters and their associated
    types by including a `where` clause after the generic parameter list. A `where`
    clause consists of the `where` keyword, followed by a comma-separated list of
    one or more requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can express the constraints that a generic type `T` inherits
    from a `C` class and conforms to a `V` protocol as `<T where T: C, T: V>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can constrain the associated types of type parameters to conform to protocols.
    Let''s consider the following generic parameter clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, it specifies that `Seq` conforms to the `SequenceType` protocol and the
    associated `Seq.Generator.Element` type conforms to the `Equatable` protocol.
    This constraint ensures that each element of the sequence is `Equatable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify that two types should be identical using the `==` operator.
    Let''s consider the following generic parameter clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, it expresses the constraints that `Seq1` and `Seq2` conform to the `SequenceType`
    protocol and the elements of both sequences must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Any type argument substituted for a type parameter must meet all the constraints
    and requirements placed on the type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We can overload a generic function or initializer by providing different constraints,
    requirements, or both on the type parameters in the generic parameter clause.
    When we call an overloaded generic function or initializer, the compiler uses
    these constraints to resolve which overloaded function or initializer to invoke.
  prefs: []
  type: TYPE_NORMAL
- en: Generic data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to generic functions, Swift empowers us to define our own generic
    types and data structures. In [Chapter 4](ch04.html "Chapter 4. Enumerations and
    Pattern Matching") , *Enumerations and Pattern Matching*, we developed a simple
    tree with enumeration. Let''s make it generic so that it can take different types
    as its leaf and node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With generics, our tree, which could accept only `Int` as a leaf, became a generic
    tree that can accept any type.
  prefs: []
  type: TYPE_NORMAL
- en: Using generics, it is possible to develop simple and generic types or data structures
    such as graphs, linked lists, stacks, and queues.
  prefs: []
  type: TYPE_NORMAL
- en: Let's examine a queue data structure example by making a `struct` generic. Queue
    is a well-known data structure in computer science that provides a mean to store
    items in the **First In First Out** (**FIFO**) order. A generic queue will be
    able to store any type in the FIFO order. The following example is not a complete
    implementation of a queue but it gives an idea about how generics can help develop
    generic data structures. Also, it is not a functional data structure as it has
    mutable variables and functions. In Chapter 8, *Functional Data Structures*, we
    will explore the functional data structure in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Associated type protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we were able to make functions, methods, and types generic. Can we make
    protocols generic too? The answer is no, we cannot, but protocols support a similar
    feature named associated types. Associated types give placeholder names or aliases
    to types that are used as part of the protocol. The actual type to use for an
    associated type is not specified until the protocol is adopted. Associated types
    are specified with the `associatedtype` keyword. Let''s examine an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This protocol defines an `append` function that takes any item of the `ItemType`
    type. This protocol does not specify how the items in the container should be
    stored or what type they should be. The protocol only specifies an `append` function
    that any type must provide in order to be considered a `Container`.
  prefs: []
  type: TYPE_NORMAL
- en: Any type that conforms to the `Container` protocol should be able to specify
    the type of values that it stores. Specifically, it must ensure that only items
    of the right type are added to the container.
  prefs: []
  type: TYPE_NORMAL
- en: To define these requirements, the `Container` protocol requires a placeholder
    to refer to the type of elements that a container will contain, without knowing
    what that type is for a specific container. The `Container` protocol needs to
    specify that any value passed to the `append` method must have the same type as
    the container's element type.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, the `Container` protocol declares an associated type called
    `ItemType`, written as `associatedtype ItemType`.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol does not define what `ItemType` is an `associatedtype` for, and
    this information is left for any conforming type to provide. Nonetheless, `ItemType`
    `associatedtype` provides you with a way to refer to the type of the items in
    a `Container` and define a type to use with `append`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we will conform to a protocol with an associated
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a new `struct` that conforms to the `Container` protocol and
    takes `Int` as `ItemType`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, it is possible to extend a generic type. For instance, we can extend
    our `Queue` example `struct` and add new behaviors to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As seen in this example, we were able to use the generic `Element` type in the
    extension.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing generic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, it is possible to subclass a generic class. Suppose that we have
    a generic `Container` class. There are two different ways to subclass it. In our
    first example, `GenericContainer` subclasses the `Container` class and stays as
    a generic class. In our second example, `SpecificContainer` subclasses `Container`
    and becomes a `Container` of `Int`, therefore, it is not generic anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood how to define and use generics. We also understood
    what type of problems generics solve. Then we explored type constraints, generic
    data structures, and associated type protocols with examples. Generics are great
    tools that, when accustomed to, make our code more flexible, useful, and robust,
    so we will use them a lot in the rest of our book.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will be introduced to some category theory concepts
    such as functors, applicative functors, and monads. We will also explore higher-order
    functions such as map, filter, and reduce.
  prefs: []
  type: TYPE_NORMAL
