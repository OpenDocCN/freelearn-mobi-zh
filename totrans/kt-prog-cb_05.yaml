- en: Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with interfaces in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement complicated interfaces with multiple overridden methods in
    Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend a class in Kotlin (Inheritance and Extension functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with Generics in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement polymorphism in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting class hierarchies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Object-Oriented Programming**, also known as **OOP**, is a programming paradigm
    based on objects. In this programming paradigm, objects contain data in the form
    of fields and code in the form of methods, which can be used to modify the data
    of the same object. In some object-oriented languages, objects are instances of
    classes (for example, Java and Kotlin). In object-oriented programming, our code
    is made up of objects that interact with each other. In this chapter, we will
    learn about some key components of OOPs, such as interfaces, classes, class hierarchies,
    and Generics.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with interfaces in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Interfaces** in OOP are like the *contract*. They define the behavior or
    rules. The classes that implement them need to do so in order to conform to the
    behavior defined by interfaces. However, that''s not it. Interfaces in Kotlin
    provide much more. Prior to Java 8, we couldn''t have the implementation of methods
    in the interfaces, but in Kotlin, we can have that too! In this recipe, we will
    see how to deal with interfaces in Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using IntelliJ IDEA for writing and executing code. You are free to
    use any IDE where you can run the Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have just discussed, interfaces in Kotlin can have the implementation
    of methods; let''s follow these mentioned steps to check that out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an interface named `DemoInterface`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining a method with implementation in the interface is just like you would
    do inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see a class that has implemented the preceding interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can call the method like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A key benefit to this new type of interface is that you can have the behavior
    of multiple interfaces since it allows method implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, using multiple interfaces, we have the
    behavior of two entities. Yes, this may sound like multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have two types of interfaces, and both have the methods with the
    same name, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you try to implement both interfaces to a class, the compiler will
    throw an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason is intuitive, as it brings ambiguity of which method to call. Hence,
    Kotlin will require you to implement that method and call the desired method inside
    it, something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will simply call the `foo` method, as earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces in Kotlin can have the implementation of methods, but can't have
    states. This means you can't declare a property in the interface and store the
    state in it. Either the class implementing it needs to override it, or you need
    to implement its accessor also.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can''t have `val a=23` in an interface, though you can have
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, simply define it in the interface and override it in the implementing class,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will look at interfaces delegation in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A delegation pattern, an object ( [https://en.wikipedia.org/wiki/Object_(computer_science)](https://en.wikipedia.org/wiki/Object_(computer_science)))
    handles a request by delegating to a second object. Let''s take a look at the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we are delegating the call to the `foo` method, to
    the object that has implemented the interface A. While the preceding code is perfectly
    fine, Kotlin allows us to use the function directly. Look at this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `InterfaceImplementation` class is implementing `A` but
    is delegating the implementation to the objects that it is receiving as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that Kotlin supports the implementation of methods in interfaces, you might
    be thinking what's the difference between an `interface` and `abstract` methods.
  prefs: []
  type: TYPE_NORMAL
- en: In interfaces, you can only define the property, which needs to be overridden
    by implementing class. However, in an abstract class, you can have an implementation
    that works with the state so that it cannot be overridden in the derived classes.
    In an abstract class, you can define some states and methods that will be the
    same in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Another key difference is that you can have final members in an abstract class,
    but not in interfaces. Also, interfaces don't support `protected` and `internal` modifiers.
    It only supports `private`.
  prefs: []
  type: TYPE_NORMAL
- en: How to implement complicated interfaces with multiple overridden methods in
    Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SOLID **is a mnemonic acronym that is used to define the five basic **object-oriented
    design** principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open-Closed Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov Substitution Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface Segregation Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Inversion Principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Interface Segregation Principle**(**ISP**) states that if an interface
    becomes too long, it is better to split it into smaller pieces (interfaces) so
    that the client doesn't need to implement the ones in which they are not interested.
    In this recipe, we will understand what and why this is important.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using Android Studio 3.0\. Ensure that you have its latest version.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see an example where ISP can help us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple example of a "fat" interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the problem of a big interface is that we are forced to implement
    the methods even if we don't have anything to do it in there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A simple solution is to break that interface into smaller interfaces, like
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that now we have divided the one big interface into smaller ones, which
    can be implemented independently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kotlin also has a powerful feature that allows you to write full implementation
    of methods in the interfaces itself. Let''s take a look at the following code
    to understand it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we implemented the whole method in the interface, and we were
    able to call it from the class that implemented that interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This feature can also be used to follow the ISP principle, as we can put a commonly
    used method in the interfaces itself; as a result, we will not need to implement
    it every time we implement that interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to extend a class in Kotlin (Inheritance and Extension functions)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to extend a class (Inheritance) and how to
    extend the functionality of a class using Kotlin's Extension functions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inheritance** is probably the first concept you learn in object-oriented
    programming. It is a mechanism where a new class is derived from an existing class.
    Via this, the classes may inherit or acquire the properties and methods of other
    classes. **Extension functions**, on the other hand, let us skip creating wrapper
    for functionality and enable us to add extra functions to the classes. Let''s
    see both of them now.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will be dealing with Android code, it is recommended that you use Android
    Studio as IDE. The source code can be found in the 1-recycler-view-in-kotlin branch of
    the [https://gitlab.com/aanandshekharroy/kotlin-cookbook](https://gitlab.com/aanandshekharroy/kotlin-cookbook)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A class derived from another class is called a subclass, whereas the class
    from which a subclass is derived is called a superclass. In this example, we will
    create a superclass A and a subclass B. To extend class B, we need to use `:` in
    the class declaration, and then add the superclass name with its primary constructor.
    Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A key thing to remember is that classes in Kotlin are *closed* for extension
    by default, so we need to open them by adding the *open* keyword before the class
    declaration. So our superclass A looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can extend our class B, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose our class A has a primary constructor that takes in a `String`
    variable, such as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we wish to extend B with A, there are two ways to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize A in B''s primary constructor. In this approach, we will initialize
    A by passing arguments from B''s primary constructor. Consider this example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If B, or any class, doesn''t have a primary constructor, then each secondary
    class of the extending class needs to initialize the superclass using the `super`
    keyword. Consider the given example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We generally extend a class to import the functionalities from a superclass
    and sometimes, we might also like to override them to have our own implementation.
    Similar to classes, methods are also closed by default, and we need to "open"
    them with the open modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also mark a method "final" to prevent any other subclass from overriding
    it. Take this example into consideration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you extend your class with an abstract class, you need to implement all
    the methods defined as abstract in the abstract class. Note that you don''t need
    to mark them open in order for them to be overridden by the extending class. Making
    them abstract does the job itself, as shown in this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Extension functions** are useful, as they allow us to extend the functionality
    of a class without actually touching it. For example, if you''ve used Glide or
    Picasso library for placing an image inside the `Imageview`, you must be familiar
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make this look much better using an extension function. Let''s call
    the `loadImage(imageUrl)` function on `imageView`. If you do it, you will see
    an error—Unresolved reference- loadImage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3ed60f9-8df2-4d3b-a1d5-b7bdd7467c4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will also see two suggestions, one of which is Create extension function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b442b29a-96fb-4153-9db2-6ba84378122f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on Create extension function, you''ll be provided with some choices,
    as in the this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3066a626-c699-4ad2-b9c5-cdc6f9c24305.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on ImageView, because we want to create an extension function on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you click on it, an extension function is created in the same file, which
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can place our Glide/Picasso code for image loading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So, even if the `loadImage` function was not present in the `ImageView` class,
    we were able to extend it and use it as if this function was part of `ImageView`,
    and we didn't even have to touch the `ImageView` class. The extension function
    extended the functionality of `ImageView` externally.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prefix to the extension function (the name that comes before the dot) is
    called **receiver** **type**, that is, the type being extended. This receiver
    object is accessed inside the function using the `this` keyword. The extension
    functions are resolved statically; it's like calling a static method. Since this
    is a static method, it's not needed to be defined under the class, but since it's
    a static method, it's hard to test. For example, Mockito (a testing framework)
    cannot test static methods, so to produce great code quality, use extension function
    only if that function doesn't require any testing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens when you create an extension function with a name similar to that
    of a member function? For example, in the following code, what will happen if
    we call `c.foo()`?:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So a member function will win if an extension function with the same name is
    called.
  prefs: []
  type: TYPE_NORMAL
- en: How to work with Generics in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic methods and classes help us use the same method or class for various
    types. This improves code reusability. In this recipe, we will understand Generics
    and how to use it in Kotlin. Generics in Kotlin is quite similar to Generics in
    Java, but there are additional special keywords in Kotlin that make Generics in
    Kotlin more intuitive. Let's dive in.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    a Kotlin compiler installed along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s follow these steps to understand how Generics works in Kotlin,
    with the help of some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a generic class that we can instantiate using any type of
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also restrict what types are allowed in our generic class like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use the preceding class with a type that is not a `Number`, for
    example, a `String`, we get the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try an example of a generic method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic types in Java are invariant, which means `List<String>` is not a subtype
    of `List<Object>`. Java has this so that we are not able to add, say, a `Float`
    to a `List` that contains `String` and has the type as `Object`. In Kotlin, we
    have a better solution where we use the wildcard argument as  `? extends E`, which
    denotes that the method accepts a subtype of E or collection of E and not just
    E itself. This gives us the power to read from a collection of E but not write
    to it, as we do not know what items are accepted. This makes Kotlin covariant.
  prefs: []
  type: TYPE_NORMAL
- en: How to implement polymorphism in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** is the ability of an object to take many forms, depending
    on the situation. Kotlin supports two types of polymorphism: **compile-time polymorphism**
    and **run-time polymorphism**. In this recipe, we will try both. Let''s get started.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for the purpose, for which you need
    a Kotlin compiler installed along with JDK. I am using IntelliJ IDE to compile
    and run my Kotlin code for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn how to use polymorphism in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with compile-time polymorphism. In **compile-time polymorphism**,
    the name functions, that is, the signature remains the same but parameters or
    return type is different. At compile time, the compiler then resolves which functions
    we are trying to call based on the type of parameters and more. Check out this
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s talk about run-time polymorphism. In **run-time polymorphism**,
    the compiler resolves a call to overridden/overloaded methods at runtime. We can
    achieve run-time polymorphism using method overriding. Let''s try an example where
    we extend a superclass and override one of its member methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, the compiler resolves, at run-time, which method to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting class hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to restrict the class hierarchies in Kotlin.
    Before we move ahead, let's understand why this is a cause worth spending our
    time on.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll be using Android Studio to run the code described in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are sure that a value or a class can have only a limited set of types
    or number of subclasses, that''s when we try to restrict class hierarchy. Yes,
    this might sound like an enum class but, actually, it''s much more than that.
    Enum constant exists only as a single instance, whereas a subclass of a sealed
    class can have multiple instances that can contain state. Let''s look at an example
    in the mentioned steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a **sealed** class named `ToastOperation`. Under the same source
    file, we will define a `ShowMessageToast` subclass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we''ll define a `ShowErrorToast` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noted, I have defined an **object** rather than a full class
    declaration, because the `ShowErrorToast` **object** doesn't have any state. Also,
    by doing so, we have removed *is* from the *when* block, since there is just one
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can use it in a `when` statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The key benefit is that we don't need to implement the `else` block, which acted
    as the default block when the other statements didn't fit the bill.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: According to documentation, a `sealed` class can have subclasses, but all of
    them must be declared in the same file as the sealed class itself. However, the
    subclasses of subclasses need not be defined in the same file. It is abstract
    by itself, and you cannot instantiate objects from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our structure of `sealed` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've kept all the subclasses under the same source file in
    which we have defined the **sealed** class.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we were sure that we can only have two types of toasts:
    an error toast and a toast with a custom message. So we created a **sealed** class
    `ToastOperation` and created two subclasses of `ToastOperation`. Note that if
    we aren''t sure of types of subclasses, we will not use a **sealed** class, in
    that case, an **enum** class might be better suited.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using Kotlin versions prior to 1.1, you''ll need to implement the subclasses
    inside the sealed class, much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can use the preceding way in the new version of Kotlin as well.
  prefs: []
  type: TYPE_NORMAL
