<html><head></head><body>
		<div><h1 id="_idParaDest-116" class="chapter-number"><a id="_idTextAnchor196" class="calibre6 pcalibre pcalibre1"/>6</h1>
			<h1 id="_idParaDest-117" class="calibre5"><a id="_idTextAnchor197" class="calibre6 pcalibre pcalibre1"/>Managing Your Code</h1>
			<p class="calibre3">In <a href="B18653_05.xhtml#_idTextAnchor163" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 5</em></a>, we covered the essential aspects of the Swift language. In this chapter, we will cover more topics related to iOS development, such as UIKit and various frameworks.</p>
			<p class="calibre3">Preparing for iOS interviews is mostly around Swift, UIKit, and coding. It is obvious why – these are the bread and butter of iOS development. But being an iOS developer is much more than that.</p>
			<p class="calibre3">In my experience, developers who know how to plan their tasks, solve/test complex bugs, and document their work are true professionals, regardless of their code quality. I think that this is what separates a good developer from a true pro-iOS developer.</p>
			<p class="calibre3">In a good and effective hiring process, these skills are tested as part of the manager interview or the home assessment stage, and we should be ready for them. Unlike most other topics, the <em class="italic">principles</em> for good quality work are vital to remember here.</p>
			<p class="calibre3">This chapter will cover the following four main topics in managing our project:</p>
			<ul class="calibre10">
				<li class="calibre11">We will ensure that we have the capability to <em class="italic">plan</em> our projects and features and gain knowledge on how to develop a technical document.</li>
				<li class="calibre11">We will cover <em class="italic">testing</em>, not only unit testing but also integration and performance tests. We will also learn what it means to write testable code.</li>
				<li class="calibre11">We will go over <em class="italic">debug</em> techniques for different types of issues.</li>
				<li class="calibre11">We will answer some questions about <em class="italic">documentation</em> – how to comment correctly and handle documentation as part of a bigger team.</li>
			</ul>
			<p class="calibre3">Let’s start with the essential part of this chapter, in my opinion: planning.</p>
			<h1 id="_idParaDest-118" class="calibre5"><a id="_idTextAnchor198" class="calibre6 pcalibre pcalibre1"/>Planning</h1>
			<p class="calibre3">Planning and<a id="_idIndexMarker350" class="calibre6 pcalibre pcalibre1"/> design are both critical aspects of being a developer, certainly a senior one. Many think of “planning” as a way to estimate delivery dates, but the delivery date is really only a tiny part of the story.</p>
			<p class="calibre3">The real story behind planning is going down to the details. In my perspective, planning is equal to learning. When we plan, we perform research about our task, trying to understand the following:</p>
			<ul class="calibre10">
				<li class="calibre11">Can we <em class="italic">understand the product requirements</em> and translate them into tasks?</li>
				<li class="calibre11">What are our <em class="italic">dependencies</em> with other teams/developers?</li>
				<li class="calibre11">What things do we need to<a id="_idIndexMarker351" class="calibre6 pcalibre pcalibre1"/> perform <em class="italic">additional research</em>? Do we need a <strong class="bold">Proof of </strong><strong class="bold">Concept</strong> (<strong class="bold">POC</strong>)?</li>
				<li class="calibre11">What tasks will be complicated, and what tasks will be simple?</li>
				<li class="calibre11">Are we handling <em class="italic">edge cases</em>? Can we define them?</li>
			</ul>
			<p class="calibre3">When we plan, we consider different aspects and challenges we may encounter. Therefore, “planning” is much more than estimation; it is really a learning session.</p>
			<p class="calibre3">Being a professional means learning our task before we start it. From my experience, not all interviews emphasize that point. In many hiring processes, planning is not even a part of the interview.</p>
			<p class="calibre3">I advise bringing it up <a id="_idIndexMarker352" class="calibre6 pcalibre pcalibre1"/>even if we are not explicitly asked for it. We are interested in leading the conversation with our interviewer to the places where we want to show our strengths.</p>
			<h2 id="_idParaDest-119" class="calibre7"><a id="_idTextAnchor199" class="calibre6 pcalibre pcalibre1"/>“How do you create a project timeline and plan for the iOS app’s development process<a id="_idTextAnchor200" class="calibre6 pcalibre pcalibre1"/>?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Similar to <a id="_idIndexMarker353" class="calibre6 pcalibre pcalibre1"/>many questions <a id="_idIndexMarker354" class="calibre6 pcalibre pcalibre1"/>we’ll find in this book, this one also doesn’t have a clear right or wrong answer. But the interviewer doesn’t care about the answer’s details. Their main goal is to assess our experience, organization skills, and our development process point of view.</p>
			<p class="calibre3">In <a href="B18653_02.xhtml#_idTextAnchor041" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 2</em></a>, we talked about “soft skills.” Planning and time management are indeed essential soft skills our interviewer wants to see. An iOS developer who understands how to plan, challenges and dependencies, manage time, and prioritize tasks is a great addition to the t<a id="_idTextAnchor201" class="calibre6 pcalibre pcalibre1"/>eam.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Regardless of the details we are required to provide, there are three points we need to ensure to highlight in our answer:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Demonstrate our experience</strong>: Providing examples, approaches, and lessons learned is a great way to show we understand and have handled challenges in the past.</li>
				<li class="calibre11"><strong class="bold">Show we understand the development process</strong>: Task management, estimation, resources, and priority are all good examples of tools that can help us to provide a good plan.</li>
				<li class="calibre11"><strong class="bold">Show we can collaborate</strong>: Working on a development project involves heavy collaboration. We need to highlight the fact that we are not working alone. Collaboration means task ownership, collaborative tech design, reviews, dependencies, and working with designers, QA teams, product managers, and backend developers.</li>
			</ul>
			<p class="calibre3">Why are these steps <a id="_idIndexMarker355" class="calibre6 pcalibre pcalibre1"/>crucial to <a id="_idIndexMarker356" class="calibre6 pcalibre pcalibre1"/>highlight? Because, in most cases, we are joining an existing team and project. Understanding what a good and healthy process looks like is essential.</p>
			<p class="calibre3">Now let’s dive into a standard framework for a project planning process:</p>
			<ol class="calibre15">
				<li class="calibre11">Understand<a id="_idIndexMarker357" class="calibre6 pcalibre pcalibre1"/> the <em class="italic">project’s requirements</em>, purpose, and audience.</li>
				<li class="calibre11"><em class="italic">Break the project down</em> into small, manageable tasks: design, coding, and testing.</li>
				<li class="calibre11">Provide a development <em class="italic">estimation for each task</em> and a result: a timeline.</li>
				<li class="calibre11">Assign <em class="italic">resources</em> between the different team members.</li>
				<li class="calibre11"><em class="italic">Monitor</em> progress to ensure we are on time.</li>
				<li class="calibre11"><em class="italic">Testing</em> and <a id="_idIndexMarker358" class="calibre6 pcalibre pcalibre1"/>deployment.</li>
			</ol>
			<p class="calibre3">We need to look at this question as a chance to bring our point of view and experience to the table <a id="_idIndexMarker359" class="calibre6 pcalibre pcalibre1"/>while taking a<a id="_idIndexMarker360" class="calibre6 pcalibre pcalibre1"/> standard process and breaking it down into the three key points I mentioned.</p>
			<h2 id="_idParaDest-120" class="calibre7"><a id="_idTextAnchor202" class="calibre6 pcalibre pcalibre1"/>“How do you estimate development time for a task?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Time estimation<a id="_idIndexMarker361" class="calibre6 pcalibre pcalibre1"/> is one of the most challenging tasks for developers, and how we approach task estimation shows our experience.</p>
			<p class="calibre3">Development time estimation is both a soft and hard skill.</p>
			<p class="calibre3">On the one hand, it requires a broad technical knowledge of the development challenges and risks, breaking them into smaller tasks and managing them.</p>
			<p class="calibre3">On the other hand, we need good communication skills to work with other teammates, excellent time management skills, and the ability to analyze dependencies that can affect our schedule.</p>
			<p class="calibre3">After all, we chose to develop professional iOS applications, and that’s a complex job to do…</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The answer is similar to the previous answer about the project timeline. The difference is that in task estimation, it is simpler to get into the small details and understand the risks.</p>
			<p class="calibre3">Let’s go over the list of the stages we need to go through:</p>
			<ol class="calibre15">
				<li class="calibre11">Understand the <em class="italic">requirements</em>.</li>
				<li class="calibre11"><em class="italic">Break</em> them down into small sub-tasks.</li>
				<li class="calibre11"><em class="italic">Assess the complexity</em> of each sub-task, and consider any potential risks and challenges. If needed, research such risks or even create a POC to understand.</li>
				<li class="calibre11"><em class="italic">Consider dependencies</em> to make sure we are not blocked from moving forward with our development process.</li>
				<li class="calibre11">Add more time for <em class="italic">reviewing and refining</em> the results.</li>
			</ol>
			<p class="calibre3">I think that point number three is perhaps the most important. When a development task doesn’t meet its estimation goals, it is primarily because of risks we didn’t consider. It is hard to go <a id="_idIndexMarker362" class="calibre6 pcalibre pcalibre1"/>wrong when setting up a standard <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) screen, but the unknown issues are what make our task overdue.</p>
			<h2 id="_idParaDest-121" class="calibre7"><a id="_idTextAnchor203" class="calibre6 pcalibre pcalibre1"/>“How do you create a technical design document for an iOS task?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">This is a<a id="_idIndexMarker363" class="calibre6 pcalibre pcalibre1"/> question that continues<a id="_idIndexMarker364" class="calibre6 pcalibre pcalibre1"/> from the previous two. We started with project planning and task time estimation, and now we are trying to understand how to design a single development task.</p>
			<p class="calibre3">Technical document creation encapsulates our expertise in approaching a technical task. Even if we don’t usually write technical documents, the process of designing a feature from a technical point of view is crucial for developers.</p>
			<p class="calibre3">Put aside the suggested answer – try to go over technical documents you’ve used in the past and retrieve what the process that led to this output was. Bringing your own experience to the table is the best answer because it will be easier to explain.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">A technical document contains the following topics: introduction, requirements, architecture, flows, data model, testing, and deployment.</p>
			<p class="calibre3">These are the following steps to create it:</p>
			<ol class="calibre15">
				<li class="calibre11"><strong class="bold">Plan and research</strong>: Collect information about the project, including requirements and constraints.</li>
				<li class="calibre11"><strong class="bold">Outline the document</strong>: Write the sections and sub-sections to ensure we are not missing any important topic.</li>
				<li class="calibre11"><strong class="bold">Describe the requirements</strong>: Specify requirements in detail.</li>
				<li class="calibre11"><strong class="bold">Discuss the system architecture</strong>: Describe the system architecture in detail. Write down the different layers involved in the feature.</li>
				<li class="calibre11"><strong class="bold">Define the data model</strong>: Describe the entities and the different API calls.</li>
				<li class="calibre11"><strong class="bold">Specify the user interface</strong>: Include screens, UI components, and navigation flows.</li>
				<li class="calibre11"><strong class="bold">Outline the testing strategy</strong>: Include types of testing, tools, and goals.</li>
				<li class="calibre11"><strong class="bold">Discuss the deployment process</strong>: Include beta rollout, A/B testing, and app versions.</li>
			</ol>
			<p class="calibre3">It’s important to say that most, if not all, of the steps I detailed are not explicitly related to Swift – this is one of the good things about this question. Planning is a language and platform-agnostic<a id="_idIndexMarker365" class="calibre6 pcalibre pcalibre1"/> task, and you can<a id="_idIndexMarker366" class="calibre6 pcalibre pcalibre1"/> find plenty of people that can help you understand how to approach a technical document design even if you haven’t done one before.</p>
			<h1 id="_idParaDest-122" class="calibre5"><a id="_idTextAnchor204" class="calibre6 pcalibre pcalibre1"/>Testing</h1>
			<p class="calibre3">Testing is a crucial <a id="_idIndexMarker367" class="calibre6 pcalibre pcalibre1"/>part of being an iOS developer. It ensures our codebase’s quality and reliability and improves levels of confidence in our projects.</p>
			<p class="calibre3">Questions about testing in interviews are much more than just technical. Writing a unit test is an easy task and can be learned quickly. But experience in testing shows a different side of us as iOS developers. It offers our approach to managing a reliable and healthy code base.</p>
			<p class="calibre3">Answer the following questions:</p>
			<ol class="calibre15">
				<li class="calibre11">Do we write tests after a bug fix?</li>
				<li class="calibre11">How simple is it to test our code?</li>
				<li class="calibre11">What is the test role in the deployment process?</li>
			</ol>
			<p class="calibre3">Being a professional doesn’t mean just writing good code but also maintaining it well.</p>
			<p class="calibre3">Unlike most topics in this book, it is difficult to gain knowledge of testing without having some experience. I advise you to take one of your projects and write some tests. You need to feel it with<a id="_idIndexMarker368" class="calibre6 pcalibre pcalibre1"/> your fingers before you approach the interview.</p>
			<h2 id="_idParaDest-123" class="calibre7"><a id="_idTextAnchor205" class="calibre6 pcalibre pcalibre1"/>“What is the meaning of unit and integration testing in the context of iOS development?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">The testing <a id="_idIndexMarker369" class="calibre6 pcalibre pcalibre1"/>world is<a id="_idIndexMarker370" class="calibre6 pcalibre pcalibre1"/> full of different terms and approaches. Defining unit tests and integration tests is essential because they represent different use cases and coverage.</p>
			<p class="calibre3">This question aims to see whether we have enough experience understanding the different use cases.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">A <strong class="bold">unit test</strong> checks the<a id="_idIndexMarker371" class="calibre6 pcalibre pcalibre1"/> behavior of an individual component, while<a id="_idIndexMarker372" class="calibre6 pcalibre pcalibre1"/> an <strong class="bold">integration test</strong> checks how different components work together.</p>
			<p class="calibre3">It’s crucial to consider the app’s context when investing more time in unit or integration testing.</p>
			<p class="calibre3">For example – unit tests mainly check logic functions such as the following one:</p>
			<pre class="source-code">
import XCTestclass MyClassTests: XCTestCase {
    func testExample() {
        let myClass = MyClass()
        let result = myClass.doSomething()
        XCTAssertEqual(result, 42)
    }
}</pre>
			<p class="calibre3">We can see that the preceding code block tests a specific logic function. It doesn’t care about other app components such as the network, core data, or the app state, but rather isolates the scope to the function itself.</p>
			<p class="calibre3">On the other hand, an integration test checks a use case that involves multiple layers and functions, such as a network request:</p>
			<pre class="source-code">
import XCTestclass MyAppTests: XCTestCase {
    func testExample() {
        let apiClient = APIClient()
        let user = User(username: "testuser", password: "secret")
        apiClient.login(user) { (error) in XCTAssertNil(error)
            let data = apiClient.fetchData() XCTAssertNotNil(data)
        }
    }
}</pre>
			<p class="calibre3">The <a id="_idIndexMarker373" class="calibre6 pcalibre pcalibre1"/>preceding <a id="_idIndexMarker374" class="calibre6 pcalibre pcalibre1"/>code shows how we can test how two layers of our project work together. The network layer can work well, as can the local function of <code>apiClient</code>. But when working together, we may encounter a problem, and that’s an integration test.</p>
			<p class="calibre3">Most iOS apps need integration tests over unit tests because most functions handle user interaction and different app layers versus logic code. This is an essential insight into the balance between<a id="_idIndexMarker375" class="calibre6 pcalibre pcalibre1"/> integration and unit tests.</p>
			<h2 id="_idParaDest-124" class="calibre7"><a id="_idTextAnchor206" class="calibre6 pcalibre pcalibre1"/>“How do you perform performance testing in iOS applications?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3"><strong class="bold">Performance testing</strong> is less <a id="_idIndexMarker376" class="calibre6 pcalibre pcalibre1"/>common<a id="_idIndexMarker377" class="calibre6 pcalibre pcalibre1"/> in iOS development<a id="_idIndexMarker378" class="calibre6 pcalibre pcalibre1"/> than unit or integration testing and is considered a more advanced topic. This question aims to gauge your depth of knowledge and experience in testing. It is a good idea to set up one performance test to understand how it works, but there is no need to have significant experience with it.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Setting up a performance test is much simpler than it sounds. The first thing we need to do is to choose the function or code block we want to measure.</p>
			<p class="calibre3">Second, we need to write a test function that performs that code block, usually multiple times. Why do we need to run it multiple times? Because it is simpler for us to measure a test run with big numbers. If one test run takes around 3–4 milliseconds, it will be hard to measure the change over time. But if we run it 100 times, it will be much easier to measure any small tweaks we can make in the function’s code. Let’s see what a performance test looks like:</p>
			<pre class="source-code">
import XCTestclass MyClassPerformanceTests: XCTestCase {
    func testPerformanceExample() {
        let myClass = MyClass()
        measure {
            for _ in 0..&lt;1000 {
                let _ = myClass.doSomethingExpensive()
            }
        }
    }
}</pre>
			<p class="calibre3">The <code>XCTest</code> framework uses the average running time as a baseline, and every time the test is run, <code>XCTest</code> compares the results to that baseline.</p>
			<p class="calibre3">One disadvantage of performance tests is that their results depend on the device they run on. It is<a id="_idIndexMarker379" class="calibre6 pcalibre pcalibre1"/> best practice<a id="_idIndexMarker380" class="calibre6 pcalibre pcalibre1"/> to<a id="_idIndexMarker381" class="calibre6 pcalibre pcalibre1"/> ensure performance tests run <em class="italic">on the same device</em>, preferably an actual device and not a simulator.</p>
			<h2 id="_idParaDest-125" class="calibre7"><a id="_idTextAnchor207" class="calibre6 pcalibre pcalibre1"/>“Can you explain what it means to write a testable code?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Sure, we are now <a id="_idIndexMarker382" class="calibre6 pcalibre pcalibre1"/>talking about tests, but <strong class="bold">testable code</strong> is much<a id="_idIndexMarker383" class="calibre6 pcalibre pcalibre1"/> more than preparing our codebase for tests – it is about writing code that we can easily maintain and decouple.</p>
			<p class="calibre3">In this question, interviewers like to see that we understand what makes code testable, ensuring our code can be maintained easily.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Writing testable code means writing code designed to make it easy to write unit, integration, and performance tests for it.</p>
			<p class="calibre3">In practice, testable code means the following:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Keep the principle of separation of concerns</strong>: When each part of our code base has a single, clear responsibility, it is easier to test a use case without requiring several layers or classes.</li>
				<li class="calibre11"><strong class="bold">Ensure loose coupling</strong>: High coupling makes it hard to test one component independently.</li>
				<li class="calibre11"><strong class="bold">Design our objects for easy mocking</strong>: A clean, well-defined interface can help our objects to be easily mocked. One great example<a id="_idIndexMarker384" class="calibre6 pcalibre pcalibre1"/> is the usage of <strong class="bold">Protocol Oriented </strong><strong class="bold">Programming</strong> (<strong class="bold">POP</strong>).</li>
				<li class="calibre11"><strong class="bold">Use more pure functions</strong>: Pure functions are functions that don’t have a shared state or side effects. They are isolated in a way that makes them very easy to test.</li>
			</ul>
			<p class="calibre3">Here’s an example of testable versus non-testable code. I’ll start with the testable version:</p>
			<pre class="source-code">
class Calculator {  func add(a: Int, b: Int) -&gt; Int {
    return a + b
  }
}</pre>
			<p class="calibre3">And now the non-testable code version:</p>
			<pre class="source-code">
class Calculator {  func calculateResult() -&gt; Int {
    let a = UserDefaults.standard.integer(forKey: "a")
    let b = UserDefaults.standard.integer(forKey: "b")
    return a + b
  }
}</pre>
			<p class="calibre3">In the first <a id="_idIndexMarker385" class="calibre6 pcalibre pcalibre1"/>example, we<a id="_idIndexMarker386" class="calibre6 pcalibre pcalibre1"/> can see that the <code>add()</code> method takes two parameters and use them solely to return a result.</p>
			<p class="calibre3">However, in the second example, we see a function dependent on two <code>UserDefaults</code> keys that may return different results each time we run it. In testable code, we should get the same results each time we run the test, so that’s not an excellent example of testable code.</p>
			<p class="calibre3">That’s a great example of testable versus non-testable code snippets.</p>
			<p class="calibre3">Tests are a crucial part of interviews, much more than they used to be several years ago. The reason is<a id="_idIndexMarker387" class="calibre6 pcalibre pcalibre1"/> that<a id="_idIndexMarker388" class="calibre6 pcalibre pcalibre1"/> tests are not a topic of their own – they represent a whole approach to development, code design, and maintenance. Tests are a clear win in terms of our striving for perfection.</p>
			<h1 id="_idParaDest-126" class="calibre5"><a id="_idTextAnchor208" class="calibre6 pcalibre pcalibre1"/>Debugging</h1>
			<p class="calibre3">A famous <a id="_idIndexMarker389" class="calibre6 pcalibre pcalibre1"/>quote says:</p>
			<p class="author-quote">“Programming is not about being the best at writing code, it’s about being the best at debugging code.”</p>
			<p class="calibre3">This quote sounds weird, right? But, when we think about it, we spend many coding hours debugging our (or others') code.</p>
			<p class="calibre3">Our debugging skills can sometimes determine whether a phase lasts a few days or weeks.</p>
			<p class="calibre3">One of the mistakes developers make when practicing for job interviews is focusing only on code writing and forgetting about debugging. But debugging is one of the most important tools we have as developers, and we can expect at least one or two debug questions in our interview.</p>
			<h2 id="_idParaDest-127" class="calibre7"><a id="_idTextAnchor209" class="calibre6 pcalibre pcalibre1"/>“Can you explain how to debug memory leaks in iOS applications?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">First, let’s be<a id="_idIndexMarker390" class="calibre6 pcalibre pcalibre1"/> aligned on what a memory <a id="_idIndexMarker391" class="calibre6 pcalibre pcalibre1"/>leak is. A memory leak doesn’t <a id="_idIndexMarker392" class="calibre6 pcalibre pcalibre1"/>mean an app with high memory usage – that’s a widespread misconception.</p>
			<p class="calibre3">A memory leak means an app was allocated memory for something and then stopped using it, but the memory space wasn’t released.</p>
			<p class="calibre3">The result might be high memory usage, but increased memory usage does not indicate a memory leak.</p>
			<p class="calibre3">Memory leaks are hard to debug but point to inefficient resource consumption and can lead to app termination. That’s why memory leak debugging is an important topic in iOS development.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">Having said that, memory leaks are hard to debug. Fortunately, there are many ways to solve this:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Instruments</strong>: Instruments<a id="_idIndexMarker393" class="calibre6 pcalibre pcalibre1"/> is a powerful tool that comes with Xcode that can help us profile different aspects of our app, including memory allocations and leaks. It’s an advanced tool that can profile a specific object, log its retains/release operations, and even direct us to a particular location in our code base.</li>
				<li class="calibre11"><strong class="bold">Memory graph debugging</strong>: It’s a relatively new feature, and not many are aware of it yet. Using memory graph debugging, it is possible to stop the run at any point and look at the live objects list and the relationships between them. It can also highlight what it identifies as a memory leak and points to the reason.</li>
				<li class="calibre11"><strong class="bold">NSZombie</strong>: NSZombie is a tool that lets us detect and track elements before they are deallocated.</li>
				<li class="calibre11">The <strong class="source-inline1">deinit</strong> function: In certain cases, we can put a print statement or a breakpoint in the object’s <strong class="source-inline1">deinit()</strong> function. The <strong class="source-inline1">deinit()</strong> function gets called just before the object is deallocated. That’s a nice and simple way to see whether an object leaks without launching external and heavy tools.</li>
				<li class="calibre11"><strong class="bold">Memory gauge</strong>: We can use Xcode’s memory gauge regularly to see whether memory is being deallocated and doesn’t grow constantly. It’s a great sign we should investigate the issue further using the other tools on the list.</li>
			</ul>
			<p class="calibre3">As we can <a id="_idIndexMarker394" class="calibre6 pcalibre pcalibre1"/>see, there are plenty of methods<a id="_idIndexMarker395" class="calibre6 pcalibre pcalibre1"/> and <a id="_idIndexMarker396" class="calibre6 pcalibre pcalibre1"/>tools to debug memory leaks in iOS. Some are there to <em class="italic">monitor our memory</em> consumption, and some are very advanced and <em class="italic">help detect</em> precisely where and when the leak occurs. The combination of the tools provides us with the perfect toolset to track and fix memory leaks.</p>
			<h2 id="_idParaDest-128" class="calibre7"><a id="_idTextAnchor210" class="calibre6 pcalibre pcalibre1"/>“Can you explain how to debug UI-related issues in iOS applications?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Up until now, most<a id="_idIndexMarker397" class="calibre6 pcalibre pcalibre1"/> of the questions<a id="_idIndexMarker398" class="calibre6 pcalibre pcalibre1"/> dealt with Swift only, without <a id="_idIndexMarker399" class="calibre6 pcalibre pcalibre1"/>the context of the relevant layer of the framework. But moving forward with our book, we’ll find there is much more than Swift in iOS development. The UI is another main topic for iOS developers, and as part of it, debugging it is considered to be a very challenging task. If you have worked with UIKit, you have probably investigated issues with the UI throughout your career. The following answer organizes things for you.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">“UI-related” is an extensive definition of a problem. Some issues are related to the UI life cycle, some to user interaction, and others to layout and animation.</p>
			<p class="calibre3">So, the answer can be divided into three parts:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Inspect the layout</strong>: We have four primary ways to debug our UI layout:<ul class="calibre18"><li class="calibre11"><strong class="bold">Debug View Hierarchy</strong>: Debug View Hierarchy is a built-in tool in Xcode that lets us debug our layout in runtime with a nice 3D view showing up the different layers of<a id="_idIndexMarker400" class="calibre6 pcalibre pcalibre1"/> the screen, allowing us to inspect each layer for its properties, including color and layout. That’s a great <a id="_idTextAnchor211" class="calibre6 pcalibre pcalibre1"/>way to understand how the UI is organized, how the Auto Layout equations mechanism works, and what the hierarchy is.</li><li class="calibre11"><strong class="bold">Open Accessibility Inspector</strong>: This tool is part of the Xcode development suite and can help us debug our views from an accessibility point of view. <strong class="bold">Accessibility Inspector</strong> is a<a id="_idIndexMarker401" class="calibre6 pcalibre pcalibre1"/> less widely recognized tool that assists us in examining our application’s handling of accessibility issues.</li><li class="calibre11"><strong class="bold">Color our views</strong>: This is a primitive yet helpful way to debug our UI. We can just set our views’ background or border colors in the code and then rerun the app to examine the results. Other tools are more advanced, but coloring our views can sometimes be a very fast and efficient way to debug, for example, in animations and sophisticated layouts.</li><li class="calibre11"><strong class="bold">Simulator debug tools</strong>: The iOS Simulator has built-in debug tools for our UI, including color views and slow animations. These are great for a quick look at our layout during runtime.</li></ul></li>
				<li class="calibre11"><strong class="bold">Life cycle debug</strong>: Life cycle debug means debugging our screen’s various stages – when it is created, appears, pushed, and more. The way to do that is mainly around breakpoints and print statements. We can set breakpoints in life cycle methods such as <strong class="source-inline1">viewDidLoad</strong> and <strong class="source-inline1">viewDidAppear</strong>. Another great tip is to <a id="_idIndexMarker402" class="calibre6 pcalibre pcalibre1"/>use <strong class="bold">logs</strong> to track UI flows. Following those logs can help us debug during development and also debug QA issues. We can also inspect life cycle events using <a id="_idIndexMarker403" class="calibre6 pcalibre pcalibre1"/>the <strong class="bold">Instruments Time Profiler</strong> to track calls during screen launch.</li>
				<li class="calibre11"><strong class="bold">User interaction debugging</strong>: We can also use the Accessibility Inspector, print to <a id="_idIndexMarker404" class="calibre6 pcalibre pcalibre1"/>console, add breakpoints, and use <strong class="bold">View Debugger</strong> to understand the different hierarchies and properties.</li>
			</ul>
			<p class="calibre3">There are many <a id="_idIndexMarker405" class="calibre6 pcalibre pcalibre1"/>ways to debug a UI! And<a id="_idIndexMarker406" class="calibre6 pcalibre pcalibre1"/> there’s a reason – UI debugging <a id="_idIndexMarker407" class="calibre6 pcalibre pcalibre1"/>requires experience and many “hit and miss” tries, so we will need every possible tool.</p>
			<h2 id="_idParaDest-129" class="calibre7"><a id="_idTextAnchor212" class="calibre6 pcalibre pcalibre1"/>“How do you debug performance issues in iOS applications?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">In today’s mobile <a id="_idIndexMarker408" class="calibre6 pcalibre pcalibre1"/>development <a id="_idIndexMarker409" class="calibre6 pcalibre pcalibre1"/>world, performance is not as big<a id="_idIndexMarker410" class="calibre6 pcalibre pcalibre1"/> a topic as it used to be. We are now handling powerful devices, and most chances are that our product requirements are not even close to challenging the least powerful machine out there.</p>
			<p class="calibre3">Bad coding and design can lead to annoying lags and long waited for operations. These are the cases where performance debugging can help us nail problems quickly.</p>
			<p class="calibre3">This question tests a crucial skill set for an iOS developer, as users expect apps to be fast and responsive. It also checks the understanding of the iOS platform and the different debugging tools available.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There are several ideal steps to take when debugging performance issues:</p>
			<ol class="calibre15">
				<li class="calibre11"><strong class="bold">Reproduce the performance issues</strong>: Rerun the app and ensure we can quickly reproduce<a id="_idIndexMarker411" class="calibre6 pcalibre pcalibre1"/> the problem. It’s not an obvious task at all – because we don’t know the issue’s root cause yet, we can’t tell for sure that the problem will be reproduced.</li>
				<li class="calibre11"><strong class="bold">Profile the app</strong>: Use the Instruments time profile and/or <strong class="bold">Core Animation Instrument</strong> to inspect the app and collect information about the problem.</li>
				<li class="calibre11"><strong class="bold">Analyze the information</strong>: Try to make an assumption about the cause of the issue.</li>
				<li class="calibre11"><strong class="bold">Perform a fix or a change</strong>: Implement some sort of solution. It doesn’t have to be the final solution; it can be some temporary code modification to isolate the issue.</li>
				<li class="calibre11"><strong class="bold">Test and verify</strong>: Rerun the app to see whether there’s a change. Restart the process if needed.</li>
			</ol>
			<p class="calibre3">Notice that these steps are only an outline for a recommended debug procedure, and it is great <a id="_idIndexMarker412" class="calibre6 pcalibre pcalibre1"/>for<a id="_idIndexMarker413" class="calibre6 pcalibre pcalibre1"/> an <a id="_idIndexMarker414" class="calibre6 pcalibre pcalibre1"/>interview answer. However, we should note that performance issues are more complex and may require additional or different steps.</p>
			<h1 id="_idParaDest-130" class="calibre5"><a id="_idTextAnchor213" class="calibre6 pcalibre pcalibre1"/>Documentation</h1>
			<p class="calibre3">Documentation<a id="_idIndexMarker415" class="calibre6 pcalibre pcalibre1"/> questions are typically not included in technical job interviews, but they may be part of interviews whose purpose is to gain insight into us as developers.</p>
			<p class="calibre3">However, documentation is an essential part of being an iOS developer, and that part gets a special place when we are part of a team.</p>
			<p class="calibre3">Here are some reasons why documentation is crucial:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Better collaboration</strong>: Documentation makes it easier for multiple developers to work on the same code base, where they need to explain smaller parts of the code.</li>
				<li class="calibre11"><strong class="bold">Improve code understanding</strong>: Do you know what it’s like to write code and one week later look back and not understand why you did what you did? It is a common thing among developers. Documentation doesn’t eliminate that but can improve it dramatically.</li>
				<li class="calibre11"><strong class="bold">Onboarding new members</strong>: That’s a critical point. Explaining something to an old-timer developer is straightforward, but doing the same for a new team member is much more complex. That’s another reason why documentation plays a significant role here.</li>
				<li class="calibre11"><strong class="bold">Improving code reviews</strong>: A “code review” is an event where someone who didn’t write the code tries to read and understand it. It goes without saying why documenting it is a crucial thing to do.</li>
			</ul>
			<p class="calibre3">Looking at the list, we can understand why documentation is a powerful tool, especially in teams, and <a id="_idIndexMarker416" class="calibre6 pcalibre pcalibre1"/>why it is not a part of the technical interview but rather part of the “personality” review. But documentation is an integral part of being a professional developer, so it is better to be prepared with examples and point-of-view statements.</p>
			<h2 id="_idParaDest-131" class="calibre7"><a id="_idTextAnchor214" class="calibre6 pcalibre pcalibre1"/>“Can you explain how you document your iOS code?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">We already went<a id="_idIndexMarker417" class="calibre6 pcalibre pcalibre1"/> through why documentation<a id="_idIndexMarker418" class="calibre6 pcalibre pcalibre1"/> is essential as an iOS developer. Now, the interviewer wants to see our techniques and approach to comments and documents.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">The basis of iOS code documentation is done using comments throughout the code base.</p>
			<p class="calibre3">There are several types of comments we can use to document our project:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">A “Why” comment</strong>: This doesn’t <a id="_idIndexMarker419" class="calibre6 pcalibre pcalibre1"/>need us to explain <em class="italic">what</em> we did, but rather <em class="italic">why</em> we did it (that’s a typical mistake developers make). These comments should be in places where there is a reason for our decision, but it is not reflected in the code. This comment can help other developers, but also we can benefit from that. Here’s an example of such a comment:<pre class="source-code">
let password = "secret_password_1234"// Use the hashValue property to get a unique   identifier for the password stringlet passwordHash = password.hashValue</pre></li>			</ul>
			<p class="calibre3">We’re adding a <a id="_idIndexMarker420" class="calibre6 pcalibre pcalibre1"/>comment that explains why we used <code>hashValue</code> and not the fact that we used it.</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Code organization</strong>: One good use of comments is to organize code; a common practice is using a “pragma mark.” A pragma mark helps us separate our code into sections to be more readable and easier to navigate. Let’s see how to organize our code with pragma marks:<pre class="source-code">
// MARK: - Propertiesvar name: Stringvar age: Int// MARK: - Initializationinit(name: String, age: Int) {    self.name = name    self.age = age}// MARK: - Methodsfunc sayHello() {    print("Hello, my name is \(name) and I am \(age) years old.")}</pre></li>			</ul>
			<p class="calibre3">Xcode knows how to read these types of comments and provides an easy way to jump between the different sections.</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Method documentation</strong>: We can document methods, properties, and classes using <a id="_idIndexMarker421" class="calibre6 pcalibre pcalibre1"/>code-generation comments. These comments can be generated automatically by Xcode or other third-party tools and be a part of our project documentation. This <a id="_idIndexMarker422" class="calibre6 pcalibre pcalibre1"/>can be done easily using the <strong class="source-inline1">/** **/</strong> marks:<pre class="source-code">
/** * Generates a random password of a specified length. * * @param {number} length - The length of the password    to generate. * @return {string} The generated password. */function generatePassword(length) {  // Implementation details}</pre></li>			</ul>
			<p class="calibre3">The results of adding <code>@params</code> and <code>@return</code> information to our function declaration comment provide Xcode (or other relevant tools) the ability to automatically generate documentation similar to what we can find on Xcode Developer Documentation.</p>
			<p class="calibre3">In the end, it is important to understand the different types of comments to structure a good answer. A short<a id="_idIndexMarker423" class="calibre6 pcalibre pcalibre1"/> answer such as “Explain what I do” is not a “pro” answer and doesn’t reflect our expertise.</p>
			<p class="calibre3">It is also worth <a id="_idIndexMarker424" class="calibre6 pcalibre pcalibre1"/>saying that good naming conventions for methods, classes, and variables can make our code much more readable and self-explanatory and, by that, reduce the need for documentation.</p>
			<h2 id="_idParaDest-132" class="calibre7"><a id="_idTextAnchor215" class="calibre6 pcalibre pcalibre1"/>“Can you explain how to document design patterns and best practices in iOS development?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Technical <a id="_idIndexMarker425" class="calibre6 pcalibre pcalibre1"/>design documents <a id="_idIndexMarker426" class="calibre6 pcalibre pcalibre1"/>are not something junior or<a id="_idIndexMarker427" class="calibre6 pcalibre pcalibre1"/> even <a id="_idIndexMarker428" class="calibre6 pcalibre pcalibre1"/>mid-level developers do, but instead, senior developers and tech leads.</p>
			<p class="calibre3">So, this question’s relevance depends on our interviewing role.</p>
			<p class="calibre3">Also, our expertise in technical design documents is probably based on our current and previous workplaces. Small start-ups are not always strict about technical documents, and that’s something we can mention when receiving this question.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">A technical design document is not there just to create one. It is there to answer the following questions:</p>
			<ul class="calibre10">
				<li class="calibre11">What is the <em class="italic">purpose</em> of the feature?</li>
				<li class="calibre11">What were the <em class="italic">alternative</em> solutions?</li>
				<li class="calibre11">Why did we <em class="italic">choose</em> the selected solution?</li>
				<li class="calibre11">What is the <em class="italic">preferred solution</em> in detail?</li>
			</ul>
			<p class="calibre3">Now that we have these questions in mind, we understand that a technical document reflects the thinking process behind our solution and not just describes it.</p>
			<p class="calibre3">To document a feature, we need to follow these steps:</p>
			<ol class="calibre15">
				<li class="calibre11"><strong class="bold">Choose a format</strong>: Choose a suitable format for the document that will be consistent across different features.</li>
				<li class="calibre11"><strong class="bold">Include an introduction</strong>: Explain the feature’s goal and what it includes.</li>
				<li class="calibre11"><strong class="bold">Discuss alternatives</strong>: Explain the different ways to solve that feature and their tradeoffs.</li>
				<li class="calibre11"><strong class="bold">Describe the selected option</strong>: Describe the choice among the alternatives.</li>
				<li class="calibre11"><strong class="bold">Describe the selected option in detail</strong>: Provide code examples, diagrams, and flow charts to explain what we did.</li>
			</ol>
			<p class="calibre3">It is important to note that technical document formats and processes differ from place to place, but <a id="_idIndexMarker429" class="calibre6 pcalibre pcalibre1"/>the<a id="_idIndexMarker430" class="calibre6 pcalibre pcalibre1"/> idea <a id="_idIndexMarker431" class="calibre6 pcalibre pcalibre1"/>stays the<a id="_idIndexMarker432" class="calibre6 pcalibre pcalibre1"/> same. As long as we provide a detailed answer with confidence and understanding, it will be good enough to pass that question.</p>
			<h2 id="_idParaDest-133" class="calibre7"><a id="_idTextAnchor216" class="calibre6 pcalibre pcalibre1"/>“How do you handle the documentation of code that multiple team members are developing?”</h2>
			<p class="calibre3"><em class="italic">Why is this </em><em class="italic">question important?</em></p>
			<p class="calibre3">Writing<a id="_idIndexMarker433" class="calibre6 pcalibre pcalibre1"/> documentation for ourselves is straightforward. Most likely, we can communicate with ourselves easily…</p>
			<p class="calibre3">The real challenge starts when our code documentation needs to serve our teammates.</p>
			<p class="calibre3">This question tests how we see code documentation as part of a team when we need to read and write such documentation and maintain it over time.</p>
			<p class="calibre3"><em class="italic">What is </em><em class="italic">the answer?</em></p>
			<p class="calibre3">There isn’t a magic answer for that, as it depends on culture, project, and team size.</p>
			<p class="calibre3">But some best practices are helpful to follow:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Establish a documentation standard</strong>: The team must agree on some comments and document format guidelines. For example – what methods to comment? What types of comments to emphasize? How to explain design decisions? Guidelines are a great start to managing documentation in a team.</li>
				<li class="calibre11"><strong class="bold">Use a collaboration tool to manage documentation</strong>: Plenty of collaboration tools can help us work on the same document with our teammates, including comments and discussions. We should take advantage of these tools to ensure the whole team participates in the documentation.</li>
				<li class="calibre11"><strong class="bold">Encourage collaboration</strong>: This is not just using a collaboration tool. If we want everyone on the team to take part, we should encourage the team to review each other’s documentation and comment on their code as part of the code review. Remember – reviews are also part of the collaboration.</li>
				<li class="calibre11"><strong class="bold">Provide training</strong>: Onboard new team members on how to comment and write documents. Training doesn’t have to be overhead – it can be short or as part of a weekly meeting. Cross-team alignment is essential to make sure our documentation <a id="_idIndexMarker434" class="calibre6 pcalibre pcalibre1"/>is effective for everyone.</li>
			</ul>
			<p class="calibre3">Following these guidelines is a great start to ensure the whole team is responsible for documentation <em class="italic">together</em> with high standards and motivation.</p>
			<h1 id="_idParaDest-134" class="calibre5"><a id="_idTextAnchor217" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">In this chapter, we discussed topics that are not directly related to coding, but as iOS developers, they are crucial. Remember that most mobile teams are small – sometimes, a team includes only one developer, so being a mature and professional developer is crucial.</p>
			<p class="calibre3">This chapter is unique – instead of talking about coding, it examined quality and communication. These skills are harder to test and even harder to show in an interview. But in good workplaces with an effective process, these topics will pop up in one way or another.</p>
			<p class="calibre3">In the next chapter, we will discuss perhaps the most crucial framework of iOS development: UIKit. No iOS interview can conclude without questions being asked about that framework.</p>
		</div>
	</body></html>