- en: Chapter 2. Swift Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。Swift基础
- en: Okay, let's begin. But before we dive into Xcode, you need to learn Apple's
    new programming language—Swift. For people coming from a JavaScript background,
    this will look very familiar. Apple has taken the best parts and practices from
    both scripting and low-level languages, and integrated some amazing features of
    its own to make Swift easy for anyone to get into, and start coding. As we go
    further, we will see that Apple has also added a few features that really make
    Swift shine compared to other languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始。但在我们深入Xcode之前，你需要学习苹果的新编程语言——Swift。对于有其他语言编码经验的人来说，这看起来非常熟悉。苹果从脚本和底层语言中吸取了最好的部分和实践，并集成了它自己的几个惊人的特性，使得Swift对任何人来说都很容易入门，并开始编码。随着我们进一步学习，我们将看到苹果还增加了一些真正让Swift与其他语言相比更加出色的特性。
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    we will be using Xcode's playground to do all the coding. Playground is a very
    versatile tool. Whenever you create a new file, you can start working on it immediately
    without any further setup. It has an inbuilt **Results** panel on the right that
    will compile your code in real time every time you make changes to the file. There
    is also an **Assistant Editor** window, which will give a graphical representation
    of the changes we make in the code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第一章](ch01.html "第一章。入门")中看到的，我们将使用Xcode的playground来完成所有的编码。Playground是一个非常通用的工具。每次你创建一个新文件，你都可以立即开始工作，而无需任何进一步的设置。它有一个内置的**结果**面板在右侧，每次你更改文件时，它都会实时编译你的代码。还有一个**辅助编辑器**窗口，它将给出我们在代码中做出的更改的图形表示。
- en: In this chapter, we will start with the basics of the Swift language, from declaring
    variables to conditional statements, loops, arrays, functions, and classes. So,
    let's get started. Create a new playground file, name it whatever you like, and
    open it. If you have created a file in the first chapter, you will already have
    a file in the `_Playgrounds` folder that you can open.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从Swift语言的基础开始，从声明变量到条件语句、循环、数组、函数和类。那么，让我们开始吧。创建一个新的playground文件，你可以给它起任何你喜欢的名字，然后打开它。如果你在第一章中创建了一个文件，你将已经在`_Playgrounds`文件夹中有一个可以打开的文件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Data types and operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型和运算符
- en: Statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句
- en: Arrays and dictionaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和字典
- en: Functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Optionals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选参数
- en: Variables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: If you have some experience in coding in other languages, you should know what
    a variable is by now. If not, then know that a variable is something that holds
    a value that can be changed at any time. This is why it is called a variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些在其他语言中编码的经验，你现在应该知道什么是变量。如果不是，那么知道变量是某种可以随时更改值的实体。这就是为什么它被称为变量。
- en: In Swift, you can define a variable using the `var` keyword, similar to JavaScript.
    So, if I create a new variable called `age`, then I type `var age`, and that is
    all; a variable is defined.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你可以使用`var`关键字来定义一个变量，这与JavaScript类似。所以，如果我创建一个新的变量叫做`age`，然后我输入`var
    age`，这就足够了；变量已经定义了。
- en: Veteran C coders will notice that I missed the semicolon at the end. Well, it
    is not required in Swift, but if you want to use the semicolon, you are most welcome
    to do so. I do it out of habit and also because it is good practice. This is because
    after coding in Swift for a while, if you don't use colons and then use a C-based
    language, you will get errors all over the place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的C语言程序员会注意到我在末尾遗漏了分号。嗯，Swift中不需要分号，但如果你想使用分号，你当然可以这样做。我这样做是出于习惯，也是因为这是一个好的实践。这是因为当你用Swift编码了一段时间后，如果你不使用冒号，然后使用基于C的语言，你会在各个地方遇到错误。
- en: But wait! There is an error. Swift is not able to figure out implicitly what
    data type `age` is; that is, is it an integer, a float, a Boolean, or a string?
    For Swift to implicitly assign a type, you have to initialize the variable. I
    can depict the age of a person as an `int` variable of value `10`, a `float` variable
    with the value of `10.0`, or as a `string` variable with the value of `Ten`. Depending
    on the variable type you assign, Swift will know that the variable is an `int`,
    `float,` or `string` type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等！这里有一个错误。Swift无法隐式地确定`age`数据类型是什么；也就是说，它是整数、浮点数、布尔值还是字符串？为了Swift能够隐式地分配类型，你必须初始化变量。我可以将一个人的年龄表示为一个值为`10`的`int`变量，一个值为`10.0`的`float`变量，或者一个值为`Ten`的`string`变量。根据你分配的变量类型，Swift将知道该变量是`int`、`float`还是`string`类型。
- en: I am going to assign an `age` variable of value `10`. In the **Results** panel,
    you will see that the value of the variable is printed as **10**. This is the
    value that is stored in the `age` variable as of now. So, if you just type `age`
    in the next line, you will find the result displayed on the right side.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我将分配一个值为 `10` 的 `age` 变量。在 **结果** 面板中，你会看到变量的值被打印为 **10**。这就是目前存储在 `age` 变量中的值。所以，如果你在下一行只输入
    `age`，你将在右侧找到显示的结果。
- en: If you add `1` to `age`, you will see the result as **11**. This has not changed
    the value of `age`; only the line is evaluated and displayed. If you want to change
    the value of `age` to `11`, you can use the shorthand `age++` command to increment
    the value, as you do in Objective-C or any other C-based language.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给 `age` 加上 `1`，你会看到结果为 **11**。这并没有改变 `age` 的值；只是这一行被评估并显示。如果你想将 `age` 的值更改为
    `11`，你可以使用简写 `age++` 命令来增加值，就像你在 Objective-C 或任何其他基于 C 的语言中做的那样。
- en: Once a variable has been assigned a certain type, you cannot assign values of
    some other type. So now, if you try to assign `11.0` or `Eleven`, it won't be
    accepted and you will get errors.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个变量被分配了某种类型，你就不能再分配其他类型的值。所以现在，如果你尝试分配 `11.0` 或 `Eleven`，它将不会被接受，并且你会得到错误。
- en: 'Okay, we saw how to assign an `int` variable, but how do we assign the `float`,
    `string`, and `bool`? This can be done as shown in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们看到了如何分配 `int` 类型的变量，但如何分配 `float`、`string` 和 `bool` 呢？这可以通过以下代码片段来完成：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What if I don''t want to initialize a variable? We can tell Swift the type
    of the variable explicitly as well. We can tell Swift that a variable is of a
    certain type by telling it the variable type that we would like to assign. We
    do this by adding a colon and the type after the name of the variable, as shown
    in the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我不想初始化一个变量怎么办？我们可以明确地告诉 Swift 变量的类型。我们可以通过告诉 Swift 我们想要分配的变量类型来告诉 Swift 变量是某种类型。我们通过在变量名称后面添加一个冒号和类型来实现这一点，如下面的代码片段所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of the `var` keyword, you may have seen this new keyword called `let`,
    which is very common in Swift. If you don't want a variable's value to change
    throughout the code, then you should use the `let` keyword instead of `var`. This
    will also make sure that the value remains constant even if you change the value
    stored by `let` by accident. These are also known as constants in other languages,
    which you can define using the `const` keyword, but in Swift, you use the `let`
    keyword.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `var` 关键字之外，你可能还看到了这个名为 `let` 的新关键字，这在 Swift 中非常常见。如果你不希望变量的值在代码中改变，那么你应该使用
    `let` 关键字而不是 `var`。这也会确保即使你意外地更改了 `let` 存储的值，值也会保持不变。在其他语言中，这些也被称为常量，你可以使用 `const`
    关键字来定义它们，但在 Swift 中，你使用 `let` 关键字。
- en: 'In the preceding example, you know that no matter what, `male` remains a male
    throughout his life. So, `bool male` will remain `true` and remain constant; it
    will never change (well, unless the guy is really not happy with his gender).
    Once it is set to `true,` we can''t change it to `false` even by accident later
    on. So, the syntax will change to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你知道无论发生什么，`male` 在他的一生中始终是男性。所以，`bool male` 将保持 `true` 并保持不变；它永远不会改变（好吧，除非这个人真的很不满意他的性别）。一旦它被设置为
    `true`，我们就不可以后来意外地将其更改为 `false`。所以，语法将变为以下形式：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once again, if you are not explicitly giving the data type, you will still have
    to initialize the variable. So, you might think that you didn't change anything.
    The results panel still shows the same value as it did when the variables were
    `var`. But try changing the values now. Suppose, for example, you incremented
    the `age` variable; try doing it now and you are certain to get an error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，即使你没有明确给出数据类型，你仍然需要初始化变量。所以，你可能认为你没有做任何改变。结果面板仍然显示与变量为 `var` 时相同的值。但现在尝试改变值。例如，假设你增加了
    `age` 变量；现在尝试这样做，你一定会得到一个错误。
- en: So, if you know that a variable's value is bound to change, it is better to
    use `var`. Otherwise, you are safer using `let` to save yourself a whole lot of
    bugs in your code resulting from this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你知道一个变量的值肯定会改变，使用 `var` 会更好。否则，使用 `let` 会更安全，这样可以避免因这种原因在代码中产生大量的错误。
- en: Now that you have understood how to declare and initialize the variables, let's
    use these variables to conduct some operations using operators.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何声明和初始化变量，让我们使用这些变量通过运算符来进行一些操作。
- en: Operators
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: Operators are used in computer languages to perform various operations on variables.
    It could be an arithmetic operation (such as addition), a comparison operation
    to check whether a number is larger or smaller than the other, a logical operation
    to check whether a condition is true or false, or an arithmetic assignment such
    as increasing or decreasing a value. Let's now look at each type in detail.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符用于计算机语言中执行对变量的各种操作。这可能是一个算术操作（如加法），一个比较操作来检查一个数字是否大于或小于另一个数字，一个逻辑操作来检查条件是否为真或假，或者一个算术赋值，如增加或减少一个值。现在让我们详细看看每种类型。
- en: Arithmetic operators
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Computers were initially made to perform numerical operations such as addition,
    subtraction, multiplication, and division. In Swift also, we have operators such
    as `+`, `-`, `*`, `/`, and `%`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 电脑最初是为了执行数值运算，如加法、减法、乘法和除法而制造的。在 Swift 中，我们也有 `+`，`-`，`*`，`/` 和 `%` 等运算符。
- en: 'Let''s declare two variables, `a` and `b`, and initialize them with values
    `36` and `10`. If you want to make a single-line initialization in Swift, you
    can do it as shown in the following snippet of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明两个变量，`a` 和 `b`，并将它们初始化为 `36` 和 `10`。如果你想在 Swift 中进行单行初始化，你可以像以下代码片段所示那样做：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use the semicolon to separate them, as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用分号来分隔它们，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is useful if you want to initialize variables of different types. Now
    let''s use operators between the variables. The result should be `46`, `26`, `360`,
    `3`, and `6`. Notice that the result of dividing an `int` variable with an `int`
    variable, is an `int` variable, instead of a `float` variable such as `3.6`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要初始化不同类型的变量，这很有用。现在让我们在变量之间使用运算符。结果应该是 `46`，`26`，`360`，`3` 和 `6`。注意，将一个
    `int` 变量除以另一个 `int` 变量的结果是一个 `int` 变量，而不是像 `3.6` 这样的 `float` 变量：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the exact result, we will need to type cast the variables. Type casting
    is done very similarly to how it is done in other languages; the type that you
    want to convert the variable to is added prior to the variable in brackets, as
    shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到确切的结果，我们需要对变量进行类型转换。类型转换与其他语言中的做法非常相似；你想要转换的变量类型被添加到变量前面的方括号中，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Comparison operators
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'Logical operators are used to check whether a variable is equal to, less than,
    greater than, less than or equal to, or greater than or equal to the other variable:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符用于检查一个变量是否等于、小于、大于、小于等于或大于等于另一个变量：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logical operators
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Similar to other languages, you can use the `&&` sign to check for the logical
    AND condition and `||` to check the OR condition between two operations. These
    two are used to check whether both expressions satisfy their conditions or only
    either of the conditions is true:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他语言类似，你可以使用 `&&` 符号来检查两个操作之间的逻辑 AND 条件，使用 `||` 来检查 OR 条件。这两个符号用于检查两个表达式是否都满足其条件，或者只有其中一个条件为真：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the previous example, we know that `a` is not equal to `b` but `a` is greater
    than `b`. So, the first statement in the preceding example is `false` (because
    both its parts aren't `true`), but the second statement holds `true` because at
    least one condition is `true`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们知道 `a` 不等于 `b`，但 `a` 大于 `b`。因此，前面例子中的第一个语句是 `false`（因为它的两部分都不是 `true`），但第二个语句是
    `true`，因为至少有一个条件是 `true`。
- en: Arithmetic increment/decrement
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术增量/减量
- en: Just as we increased the age in the first example by adding a `++` sign at the
    end of the variable, we also assign a `--` sign to decrement the value of the
    variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一个例子中通过在变量末尾添加 `++` 符号来增加年龄一样，我们也可以给变量赋一个 `--` 符号来减少其值。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Keep in mind that `a++` is different from ++`a`. They are called post- and pre-increment
    operators respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`a++` 与 `++a` 不同。它们分别被称为后增量运算符和前增量运算符。
- en: In the following example, we start with a variable, `a`, with an initial value
    of `36`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们从初始值为 `36` 的变量 `a` 开始。
- en: If you do `a++,` it is called post-increment. It will first display the result
    and then increment the value of `a`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行 `a++`，这被称为后增量。它将首先显示结果，然后增加 `a` 的值。
- en: So, if you do `a++`, which should have incremented the value of `a`, the result
    will still show up as `36`, suggesting that the value has still not been incremented
    yet. Yet, immediately in the next line if you ask it to output the value of `a`,
    it will show up as `37`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你执行 `a++`，它应该会增加 `a` 的值，但结果显示仍然是 `36`，这表明值还没有被增加。然而，在下一行，如果你要求它输出 `a` 的值，它将显示为
    `37`。
- en: '![Arithmetic increment/decrement](img/B04014_02_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![算术增量/减量](img/B04014_02_01.jpg)'
- en: 'If you do `++a`, it is called pre-increment. It will increment the value first
    and then show the output. So in this case, it will show `37` in the same line
    where you incremented the value of `a`, and if you ask it to show the value of
    `a` in the next line, it will again show `37`, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行 `++a`，它被称为预增量。它将首先增加值，然后显示输出。所以在这种情况下，它将在你增加 `a` 的值的那一行显示 `37`，如果你要求它在下一行显示
    `a` 的值，它将再次显示 `37`，就像这样：
- en: '![Arithmetic increment/decrement](img/B04014_02_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![算术增量/减量](img/B04014_02_02.jpg)'
- en: This is just to keep in mind for the future, in case you encounter any bugs
    in the code and wonder why the correct value of your expression is not getting
    displayed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为了以防将来你遇到代码中的任何错误，并且想知道为什么你的表达式的正确值没有显示出来。
- en: Composite operations
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合操作
- en: 'We can also perform composite operations to increment, decrement, multiply,
    or divide by a much higher number, like this: `a+=10`, `a-=10`, `a*=10`, `a/=10`,
    and `a%=10`, which are shorthand ways of doing `a = a+10`, `a = a-10`, `a = a*10`,
    `a = a/10`, and `a = a%10` respectively. So, if you replace `a+=10` with `a =
    a + 10`, it will still give the same result. This is done for the sake of optimization
    and readability of code.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以执行复合操作来增加、减少、乘以或除以一个更大的数，例如：`a+=10`、`a-=10`、`a*=10`、`a/=10` 和 `a%=10`，这些都是
    `a = a+10`、`a = a-10`、`a = a*10`、`a = a/10` 和 `a = a%10` 的简写方式。所以，如果你用 `a+=10`
    替换 `a = a + 10`，它仍然会给出相同的结果。这样做是为了优化代码的可读性。
- en: '![Composite operations](img/B04014_02_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![复合操作](img/B04014_02_03.jpg)'
- en: Statements
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: Statements are of two kinds in any programming language—decision making statements
    and looping statements.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的语句有两种类型——决策语句和循环语句。
- en: Decision-making statements
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决策语句
- en: 'Decision making statements are of the following types: `if`, `if else`, `else
    if`, and `switch`. This is very standard in any programming language. Let''s look
    at the `if` statement first and see how the syntax differs from other C-based
    languages.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 决策语句有以下类型：`if`、`if else`、`else if` 和 `switch`。这在任何编程语言中都是非常标准的。让我们首先看看 `if`
    语句，看看其语法与其他基于 C 的语言有何不同。
- en: The if statement
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if 语句
- en: 'In Swift, the `if` statement is written like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，`if` 语句的写法如下：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Immediately, the guys using C will be like, "Blasphemy!! No brackets!!" Yes,
    in Swift for the sake of simplicity and readability, you don't have to use the
    brackets. If you want to, you can still use them, and you won't get any compile
    errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，使用 C 语言的那些人可能会说，“亵渎！！没有括号！！”是的，在 Swift 中，为了简洁和可读性，你不需要使用括号。如果你想用，你仍然可以使用它们，而且不会得到任何编译错误。
- en: But you absolutely must enclose the statement in the curly braces. Even if it
    is a single line statement, it is absolutely mandatory. If you don't, you will
    get compile errors for sure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但你绝对必须将语句包含在大括号内。即使它是一行语句，这也是绝对必要的。如果你不这样做，你肯定会得到编译错误。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here''s a small note about logging code on the screen: we will be using this
    feature quite extensively when we start developing the game to make sure that
    the program is doing exactly what we want it to do. So, we will be logging statements
    to check for logical errors.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个关于在屏幕上记录代码的小提示：当我们开始开发游戏时，我们将非常广泛地使用这个功能，以确保程序确实在执行我们想要它执行的操作。因此，我们将记录语句以检查逻辑错误。
- en: 'In Objective-C, we would use something such as `NSLog(@"Print Stuff to Screen")`
    or `NSLog(@"My age is: %d", age)`. In Swift, this is done a bit differently. For
    one, you don''t need to put the `@` sign in front of any string to log it out.
    Secondly, to print the values, we have to use `\()` with the variable in the bracket:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Objective-C 中，我们会使用类似 `NSLog(@"Print Stuff to Screen")` 或 `NSLog(@"My age
    is: %d", age)` 这样的代码。在 Swift 中，这有点不同。首先，你不需要在要记录的字符串前加上 `@` 符号。其次，为了打印值，我们必须使用
    `\()` 并在括号中放入变量：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The if statement](img/B04014_02_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![if 语句](img/B04014_02_04.jpg)'
- en: 'The same can be applied to strings:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于字符串：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![The if statement](img/B04014_02_05.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![if 语句](img/B04014_02_05.jpg)'
- en: The if else statement
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if else 语句
- en: 'Similar to the `if` statement, the `if else` statement is written as shown
    here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 语句类似，`if else` 语句的写法如下所示：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of checking whether `a` is greater than `b`, we are checking otherwise,
    and now it will print **30 is greater than 10** by entering the `else` statement.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是检查 `a` 是否大于 `b`，而是检查相反的情况，现在它将通过进入 `else` 语句来打印 **30 大于 10**。
- en: The else if statement
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else if 语句
- en: 'Similar to the `if` statement where we didn''t put the brackets around the
    condition, in `else if`, we are not required to put the brackets around the condition:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们未在条件周围放置括号的`if`语句类似，在`else if`中，我们不需要在条件周围放置括号：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So here, we're checking whether `a` is greater than `b`, then print the following
    statement (from the code snippet) instead of checking for just the `else` bit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们检查`a`是否大于`b`，然后打印以下语句（来自代码片段），而不是只检查`else`部分。
- en: Conditional expressions
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件表达式
- en: 'Instead of taking 10 lines of code for checking such a simple statement, you
    can use the conditional expression statement to do the work in one line. This
    is more popular if you are just checking for `if`-`else`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于检查这样简单的语句，不需要10行代码，你可以使用条件表达式语句在一行内完成工作。如果你只是检查`if`-`else`，这会更受欢迎：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we check whether `a` is greater than `b`. If `a` is greater than `b`, then
    the expression evaluates to `true` and the output becomes `36`. Otherwise, the
    output becomes `10`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们检查`a`是否大于`b`。如果`a`大于`b`，则表达式评估为`true`，输出变为`36`。否则，输出变为`10`。
- en: The switch statement
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: Switch statements in Swift are a little different from the way they are in other
    languages. Like the `if` statement, the brackets around the variable, or expression,
    are not required, but that's not the only difference.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的`switch`语句与其他语言的`switch`语句略有不同。像`if`语句一样，变量或表达式的括号不是必需的，但这不是唯一的区别。
- en: All statements need to print some value, or some condition needs to be checked.
    You cannot have an empty case; that will give an error. Secondly, as all statements
    will be evaluated, a break is not necessary at the end of every line. In other
    C-based languages, all lines will be evaluated and executed, unlike the `switch`
    statement in Swift, where only the valid cases will be executed. Finally, the
    cases need to be exhaustive. This means that there needs to be a default at the
    end so that if none of the cases match, then a default value or statement gets
    thrown.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有语句都需要打印某个值，或者需要检查某个条件。你不能有一个空的`case`；这将产生错误。其次，由于所有语句都将被评估，因此不需要在每一行的末尾使用`break`。在其他基于C的语言中，所有行都将被评估和执行，而Swift中的`switch`语句则不同，其中只有有效的`case`将被执行。最后，`case`需要是穷尽的。这意味着需要在末尾有一个默认值，以便如果没有任何`case`匹配，则抛出一个默认值或语句。
- en: 'Let''s look at an example of switch-case:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`switch-case`的一个例子：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, a new variable called `speed` is created. Based on the value of the speed,
    the system will print whether the value is slow or fastest. If `speed` is not
    a number, or the value is not between `10` and `50`, the default message will
    be printed. So in this case, as the value matches with `case 30`, it will print
    **fast enough**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个名为`speed`的新变量。根据速度的值，系统将打印值是慢还是最快。如果`speed`不是一个数字，或者值不在`10`到`50`之间，将打印默认消息。因此，在这种情况下，由于值与`case
    30`匹配，它将打印**足够快**。
- en: Instead of fixed values for case statements, you can also provide a range of
    values for which the statement will be `true`. So for example, if the value is
    between `0` and `10`, you would want the output to be **slow**. You can do so
    by giving the range from `0` to `10` as `0…10` in the first case. It is important
    that you put three dots between the values because they form an operator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于情况语句的固定值，你也可以提供一个范围，使得该语句为`true`。例如，如果值在`0`到`10`之间，你希望输出为**慢**。你可以通过在第一个情况中将范围从`0`到`10`表示为`0…10`来实现。重要的是，你需要在值之间放置三个点，因为它们形成一个运算符。
- en: 'So now, if you change the value of speed to anything between `0` and `10`,
    the output will be **slow**. Similarly, the range can be used with other case
    statements:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，如果你将速度的值更改为`0`到`10`之间的任何值，输出将变为**慢**。同样，范围也可以用于其他情况语句：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Looping statements
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环语句
- en: Looping statements are used to execute a particular block of code infinitely,
    for a said number of times, or until a certain condition is satisfied. As in any
    other language, we have the `while`, `do while`, and `for` loops, and we have
    a `for each` loop as in C# and C++11.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 循环语句用于无限执行特定代码块，或者执行指定次数，或者直到满足某个条件。像任何其他语言一样，我们有`while`、`do while`和`for`循环，以及像C#和C++11中的`for
    each`循环。
- en: The while loop
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: In a `while` loop, we first give a condition. If the condition holds `true`,
    the block following the code will keep on executing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，我们首先给出一个条件。如果条件保持`true`，则代码后面的块将一直执行。
- en: 'For this example, we create two variables, `n` and `t`. We set `n` equal to
    `1` and `t` equal to `10`. In the condition, we increment the value every time
    the code is executed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们创建了两个变量，`n`和`t`。我们将`n`设置为`1`，将`t`设置为`10`。在条件中，每次代码执行时我们都会增加值：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, there is no need to put the parentheses around the condition. But
    you will see that, in the results panel, nothing printed except nine times.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，没有必要在条件周围放置括号。但你会看到，在结果面板中，除了打印了九次之外，没有其他输出。
- en: There is a + icon, and there is another icon next to it. Pressing it will open
    a new pane. This is called **Assistant Editor**. In it, you will see a graph.
    This shows the increment of the value of `n` over the period of time the loop
    was running. It starts from `1` and goes all the way to `9`, since we told the
    loop to run only while the value of `n` is less than `10`. You can move the mouse
    arrow onto the nodes to know the value at each node. Alternatively, there is a
    scroll bar to scroll to the graph.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有一个加号图标，旁边还有一个图标。按下它将打开一个新面板。这被称为**辅助编辑器**。在其中，你会看到一个图表。这显示了循环运行期间`n`值的增加。它从`1`开始，一直增加到`9`，因为我们告诉循环只在`n`的值小于`10`时运行。你可以将鼠标箭头移到节点上，以了解每个节点的值。或者，还有一个滚动条可以滚动到图表。
- en: '![The while loop](img/B04014_02_06.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![while循环](img/B04014_02_06.jpg)'
- en: 'You can also open **Assistant Editor** in Xcode by going to **View** | **Assistant
    Editor** | **Show Assistant Editor**:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在Xcode中转到**视图** | **辅助编辑器** | **显示辅助编辑器**来打开**辅助编辑器**：
- en: '![The while loop](img/B04014_02_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![while循环](img/B04014_02_07.jpg)'
- en: 'Click on the value history icon to open the graph:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 点击值历史图标以打开图表：
- en: '![The while loop](img/B04014_02_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![while循环](img/B04014_02_08.jpg)'
- en: The do while loop
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`do while`循环'
- en: Similar to the `while` loop, the code block of the `do while` loop gets executed
    while the condition is `true`. However, in this case, the block executes at least
    once and then the condition is checked.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与`while`循环类似，`do while`循环的代码块在条件为`true`时执行。然而，在这种情况下，块至少执行一次，然后检查条件。
- en: 'Here, we are reducing the value of `n` by 1 every time it enters the loop and
    checking whether the value is greater than `0`. If it is, then the code block
    gets executed. The value of `n` from the previous piece of code is `10`, so it
    starts from `10` and goes back to `1`. Again, this is plotted in a graph, which
    can be seen by clicking on the icon on the results panel:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每次进入循环时，我们都会将`n`的值减1，并检查该值是否大于`0`。如果是，则执行代码块。前一条代码中`n`的值是`10`，所以它从`10`开始，回到`1`。再次，这可以通过点击结果面板上的图标在图表中看到：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![The do while loop](img/B04014_02_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![do while循环](img/B04014_02_09.jpg)'
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be carful to make sure that the condition will be met. Otherwise, it will lead
    to an infinite loop, causing your system to become unstable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必确保条件会被满足。否则，它将导致无限循环，使你的系统变得不稳定。
- en: The for loop
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `for` loop can be written as shown here. Even without the brackets, it
    will work fine:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可以写成如下所示。即使没有括号，它也能正常工作：'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, instead of adding `1` every time, we multiply the value of `i` to itself
    to get a curved line in the graph, ranging from `0` to `81`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是每次都加`1`，而是将`i`的值乘以自身，在图表中得到一条曲线，范围从`0`到`81`。
- en: '![The for loop](img/B04014_02_10.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![for循环](img/B04014_02_10.jpg)'
- en: The for in loop
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`for in`循环'
- en: 'Like the `for each` loop in other languages, you have a `for in` loop in Swift.
    It goes through each item in the loop and executes whatever has been stated by
    the code. Here, unlike other languages, it is not necessary to specify the type
    of variable. Swift will automatically understand the variable type according to
    the list of items you want it to loop through. For example, looping through a
    list of integers can be written as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他语言中的`for each`循环一样，Swift中也有`for in`循环。它遍历循环中的每个项目，并执行代码中声明的任何内容。在这里，与其他语言不同，没有必要指定变量的类型。Swift会根据你想要它遍历的项目列表自动理解变量类型。例如，遍历整数列表可以写成以下形式：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, even though we never mentioned in the code that `l` is an integer type,
    Swift automatically understood it, according to the list of values we gave in
    the code. Since the type of the list given is an `int`, the value of `l` automatically
    gets assigned the type `int`, and the output is provided:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尽管我们在代码中从未提到`l`是整型，但Swift根据我们在代码中给出的值列表自动理解了它。由于给出的列表类型是`int`，`l`的值自动被分配为`int`类型，并提供了输出：
- en: '![The for in loop](img/B04014_02_11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![for in循环](img/B04014_02_11.jpg)'
- en: 'Additionally, while looping through an index of an array, we would want to
    start from `0` and go to the last but one value. The same can be achieved using
    `..<` instead of the `…` operator when specifying the range. So, in the preceding
    example, if we have to go from `0` to `9`, we can rewrite the code as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在遍历数组的索引时，我们希望从`0`开始，到倒数第二个值结束。当指定范围时，可以使用`..<`而不是`…`运算符来实现这一点。因此，在前面的例子中，如果我们需要从`0`到`9`，我们可以将代码重写如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is obviously not limited to numbers; we can loop through any data type.
    For example, we can loop through the characters in a string like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不仅限于数字；我们可以遍历任何数据类型。例如，我们可以像这样遍历字符串中的字符：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here again, it was never explicitly mentioned that the type of the variable
    is `char`, and yet Swift was able to implicitly judge that `c` should be of the
    `char` type. In the console, each character will be displayed as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，并没有明确提到变量的类型是`char`，然而Swift能够隐式判断`c`应该是`char`类型。在控制台中，每个字符将显示如下：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Arrays
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a consecutive block of memory that holds a certain type of data.
    It can be a predefined data type, such as `int`, `float`, `char`, `string`, or
    `bool`, or it can be user-defined. Also, arrays are zero-based, which means that
    the first object in the array is `0`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一段连续的内存块，用于存储某种类型的数据。它可以是一个预定义的数据类型，如`int`、`float`、`char`、`string`或`bool`，或者它可以是用户定义的。此外，数组是零基的，这意味着数组中的第一个对象是`0`。
- en: 'Arrays can be either of the `var` or `let` type. If we create an array of the
    `var` type, then we can change, add, or remove the objects from the array similar
    to how we have `MutableArray` in Objective-C. If you want an `ImmutableArray`
    array in Swift, instead of `var`, use the `let` keyword. Arrays in Swift can be
    declared and initialized as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以是`var`或`let`类型。如果我们创建一个`var`类型的数组，那么我们可以像在Objective-C中拥有`MutableArray`一样更改、添加或从数组中删除对象。如果你想在Swift中有一个`ImmutableArray`数组，而不是使用`var`，请使用`let`关键字。Swift中的数组可以声明和初始化如下：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if we want to declare an array and initialize it later, we can declare
    it as shown in the following snippet of code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要声明一个数组并在稍后初始化它，我们可以按照以下代码片段所示进行声明：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, you will have to provide the data type that the array will be storing.
    It is very similar to defining a regular variable; it''s just that the type here
    is surrounded by square brackets. Now we can initialize it as we did earlier:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你必须提供数组将要存储的数据类型。它与定义常规变量非常相似；只是这里的类型被方括号包围。现在我们可以像之前一样初始化它：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To get an item at an index, you can use the variable name with the index number
    in square brackets:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个索引处的项目，你可以使用带有索引数字的变量名，放在方括号中：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looping through arrays
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'To loop through an array, we can use the `for in` loop, as we saw in loops.
    Here, instead of passing the range, we provide the range itself, and as before,
    the data type present in the array is automatically determined by Swift:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历数组，我们可以使用`for in`循环，就像我们在循环中看到的那样。在这里，我们不是传递范围，而是提供范围本身，并且像之前一样，Swift会自动确定数组中的数据类型：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Adding, removing, and inserting objects into arrays
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组中添加、删除和插入对象
- en: 'To add items to the array, you can use the `append` method. So, to add values
    to the `score` or `daysofweek` array, we do it as shown in the following code
    snippet. This will add the object at the end of the array:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要向数组中添加项目，你可以使用`append`方法。因此，要将值添加到`score`或`daysofweek`数组中，我们按照以下代码片段所示进行操作。这将把对象添加到数组的末尾：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can remove the last object from the array by calling this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用以下方法来移除数组中的最后一个对象：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want to remove an object at a particular index, you can use the following
    line:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除特定索引处的对象，你可以使用以下行：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will remove the element at the fifth index, which is `2` here. To insert
    an item at a particular index, we will have to provide the value and index at
    which the item has to be inserted:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将移除第五个索引处的元素，在这里是`2`。要在一个特定的索引处插入一个项目，我们必须提供值和项目要插入的索引：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Important array functions
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的数组函数
- en: 'Apart from functions such as `append`, `remove`, and `insert`, there are other
    built-in functions that we will be using quite often in games. The first is the
    `count` function, which tells us the number of elements present in the array:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`append`、`remove`和`insert`等函数之外，还有其他我们将经常在游戏中使用的内置函数。第一个是`count`函数，它告诉我们数组中有多少个元素：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The other function is `isEmpty`, which can be used to check whether an array
    has any items present in it or not:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数是 `isEmpty`，它可以用来检查一个数组中是否包含任何项目：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Dictionary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: Also known as a map or hash table in other languages, a dictionary—like arrays—is
    a data collection type. However, unlike arrays—in which each element in the array
    can be accessed only by an index number—in dictionaries, we will provide keys
    with which we will be able to access the element at a particular index. The values
    of `keys` and `values` can be `int`, `float`, `bool`, or `string` values. You
    cannot have duplicate keys, but you can obviously have duplicate values in the
    dictionary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中也称为映射或哈希表，字典——就像数组一样——是一种数据集合类型。然而，与数组不同——在数组中，每个元素只能通过索引号访问——在字典中，我们将提供键，通过这些键我们可以访问特定索引处的元素。键和值的值可以是
    `int`、`float`、`bool` 或 `string`。键不能重复，但在字典中显然可以有重复的值。
- en: 'For example, let''s look at the FIFA''s country code list:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看国际足联的国家代码列表：
- en: '| Code | Country |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| Code | 国家 |'
- en: '| --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| AFG | Afghanistan |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| AFG | 阿富汗 |'
- en: '| ALB | Albania |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| ALB | 阿尔巴尼亚 |'
- en: '| ALG | Algeria |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| ALG | 阿尔及利亚 |'
- en: '| ASA | American Samoa |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| ASA | 美属萨摩亚 |'
- en: '| AND | Andorra |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| AND | 安道尔 |'
- en: '| ANG | Angola |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| ANG | 安哥拉 |'
- en: '| AIA | Anguilla |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| AIA | 安圭拉 |'
- en: '| ATG | Antigua and Barbuda |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| ATG | 安提瓜和巴布达 |'
- en: '| ARG | Argentina |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| ARG | 阿根廷 |'
- en: '| ARM | Armenia |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| ARM | 亚美尼亚 |'
- en: 'The code in the left columns can be termed as **keys** and the **Country**
    column on the right represents the **value**. So, when I want to refer to Argentina,
    I can simply call ARG and Swift will automatically understand that I am referring
    to Argentina. Here''s another example: when we say, "get the value for the `ATG`
    key," the program will know that we are referring to Antigua and Barbuda.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧列中的代码可以称为 **键**，右侧的 **国家** 列表示 **值**。所以，当我想引用阿根廷时，我可以简单地调用 ARG，Swift 会自动理解我是在引用阿根廷。这里还有一个例子：当我们说，“获取
    `ATG` 键的值”时，程序将知道我们是在引用安提瓜和巴布达。
- en: The advantage of a dictionary is that the data doesn't have to be sorted. If
    we know that the key-value pair exists in the dictionary, irrespective of where
    it is in the list, we can get the value by asking for it by the key.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的优势在于数据不需要排序。如果我们知道键值对存在于字典中，无论它在列表中的位置如何，我们都可以通过键来获取值。
- en: This syntax is similar to arrays. The only difference is that instead of giving
    one type of variable, we have to provide two during declaration, the first being
    the type of the key and the second being the type of the value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法与数组类似。唯一的区别是在声明时，我们不仅要提供一个变量类型，还要提供两个类型，第一个是键的类型，第二个是值的类型。
- en: 'Once again, you don''t have to provide the types explicitly if you are already
    aware of the types of both `key` and `value`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你已经知道 `key` 和 `value` 的类型，你不需要显式提供类型：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The key-value pair can be of any combination. This means that you can have a
    `key` variable of type `int` and `value` of type `string`; `key` of type `string`
    and `value` of type `string`, as shown in the example; or `key` of type `string`
    and `value` of type `int`; and so on. You cannot change or provide a different
    type after declaring the dictionary keys and values with a certain type. Also,
    you cannot add a key of type `int` if you've already declared that the keys will
    be of type `string`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 键值对可以是任何组合。这意味着你可以有一个 `key` 变量是 `int` 类型，而 `value` 是 `string` 类型；`key` 是 `string`
    类型，而 `value` 也是 `string` 类型，如示例所示；或者 `key` 是 `string` 类型，而 `value` 是 `int` 类型；等等。一旦声明了字典键和值的类型，就不能更改或提供不同的类型。另外，如果你已经声明键将是
    `string` 类型，就不能添加 `int` 类型的键。
- en: 'We can also explicitly tell the types of the key-value pair, as shown here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以显式地指定键值对的数据类型，如下所示：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This tells us that the keys will be of type `string` and the values associated
    with those keys will also be of type `string`. If we want to store the population
    for a set of keys, it can be done as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们键将是 `string` 类型，与这些键关联的值也将是 `string` 类型。如果我们想存储一组键的种群，可以按照以下方式操作：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Adding and removing objects from the dictionary
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向字典中添加和删除对象
- en: 'To add a new key-value pair to an existing dictionary, we can simply run one
    of these two lines of code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要向现有字典中添加新的键值对，我们可以简单地运行以下两行代码之一：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Beware, however, because if the key already exists, it will overwrite the current
    value it holds.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，如果键已经存在，它将覆盖当前持有的值。
- en: 'If you want to remove a key-value pair, you can use either of the following
    statements to delete it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除一个键值对，你可以使用以下任一语句来删除它：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, if we try to access the key-value pair, we will notice that it has removed
    not only the value stored by the key, but the key as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试访问键值对，我们会注意到它不仅删除了由键存储的值，还删除了键本身。
- en: Looping through items in the dictionary
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历字典中的项
- en: 'Once again, we can use the `for`-`in` loop to access the data stored in each
    key-value pair, but instead of just one value, we will have to provide two values
    in parentheses, separated by a comma for separation of the key and value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们可以使用`for-in`循环来访问存储在每个键值对中的数据，但我们需要在括号中提供两个值，用逗号分隔键和值：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The console output will be as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出将如下所示：
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Dictionary functions
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典函数
- en: 'Similar to arrays, the dictionary also has inbuilt functions to determine the
    number of key-value pairs present in it. It also has an `isEmpty` function, which
    can be called on the dictionary to know whether it contains any key-value pair
    at all:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组类似，字典也有内置函数来确定其中存在的键值对数量。它还有一个`isEmpty`函数，可以调用字典来了解它是否包含任何键值对：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Functions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: A function is a block of code that is used to perform a certain task. It can
    be used to assign a block of reusable code that you can call again and again without
    rewriting the code every time to perform that task.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是一段用于执行特定任务的代码块。它可以用来分配一个可重用的代码块，你可以反复调用它而无需每次都重写代码来执行该任务。
- en: Simple functions
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单函数
- en: 'Functions in Swift are written as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的函数编写如下：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: So here, before a function, we will need to use the `func` keyword, followed
    by the name of the function, the parentheses, and the open and closed curly braces.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在函数之前，我们需要使用`func`关键字，后跟函数名，括号，以及大括号。
- en: 'Calling a function here is very similar to any other language, that is, the
    name of the function followed by parentheses:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数在这里与任何其他语言非常相似，即函数名后跟括号：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Passing a parameter
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递参数
- en: 'Now, to perform some task on a variable passed to a function, we first need
    to pass a parameter into the function. This can be done as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要对传递给函数的变量执行某些任务，我们首先需要将一个参数传递给函数。这可以这样做：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we have to provide the input variable type within the parentheses. We
    cannot provide an integer here when the function is expecting a string, as it
    takes the type explicitly.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们必须在括号内提供输入变量类型。当函数期望一个字符串时，我们不能在这里提供一个整数，因为它明确地接受类型。
- en: 'To perform the function, call the function and, within the parentheses, include
    the text that you want to perform the function on:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行函数，请调用函数，并在括号内包含你想要执行函数的文本：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It should be noted that the value passed to a function is a constant by default.
    This means that even though we don't specify whether `mtext` is a variable or
    constant, it will remain a constant. So, you will not be able to make any modifications
    to it within the function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，传递给函数的值默认是常量。这意味着即使我们没有指定`mtext`是变量还是常量，它仍然是一个常量。因此，你将无法在函数内对其进行任何修改。
- en: 'If your code requires the type to be a variable instead of a constant, you
    need to specify this while creating the function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码需要类型是变量而不是常量，你需要在创建函数时指定这一点：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Passing more than one parameter
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递多个参数
- en: 'We can obviously pass more than one variable. Here, you will need to separate
    the variables types with a comma, like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然可以传递多个变量。在这里，你需要用逗号分隔变量类型，如下所示：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we pass two numbers, `10` and `15`, to the function. We perform their
    addition, store the value in a constant called `sum`, and print it to the console
    by calling the following function:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们向函数传递两个数字，`10`和`15`。我们执行它们的加法，将值存储在名为`sum`的常量中，并通过调用以下函数将其打印到控制台：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Returning a value
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: For a C++ user, this might look a little strange. Also, people not comfortable
    with pointers might freak out looking at the syntax of a function returning a
    parameter as it uses the pointer operator in Swift. Don't fret! This has absolutely
    nothing to do with pointers. It is just a way to show that this function will
    return a data type, and that's all.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于C++用户来说，这可能会显得有些奇怪。同样，不习惯指针的人可能会对函数返回参数的语法感到恐慌，因为它在Swift中使用指针运算符。别担心！这绝对与指针无关。这只是显示这个函数将返回一个数据类型，仅此而已。
- en: The function is written as usual, but at the end, we specify the return type
    after the parentheses by typing the dash and greater than sign, and then typing
    the return type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的编写方式与通常一样，但在括号后面指定返回类型时，我们输入破折号和大于号，然后输入返回类型。
- en: Here, we are performing a multiplication using a function that takes in two
    `int` values and returns an `int` value. We calculate the value by performing
    the multiplication operation, store the value in a constant called `mult`, and
    then return the value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用一个接受两个`int`值并返回`int`值的函数执行乘法运算。我们通过执行乘法操作计算值，将值存储在一个名为`mult`的常量中，然后返回该值。
- en: 'The function is called, and the result is stored in a variable and then printed
    to the console:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 函数被调用，结果存储在一个变量中，然后打印到控制台：
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, the console will output the multiplied value—`200`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，控制台将输出乘积值——`200`。
- en: Default and named parameters
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认和命名参数
- en: 'If we want to assign a default value to the parameters in the function, we
    can certainly do it, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在函数的参数中指定默认值，我们当然可以这样做，如下所示：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we are assigning `20` and `30` as default values. We simply call the function
    to get an output of `300`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们指定`20`和`30`作为默认值。我们只需调用函数即可得到输出`300`。
- en: 'But what if we want to modify only one value and keep the other value as default?
    In that case, we will assign a value by name, while calling the function. So,
    if we want the value of `a` to be `80` instead of the default value, we will do
    it like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们只想修改一个值，而保留其他值使用默认值怎么办？在这种情况下，我们将在调用函数时通过名称指定一个值。所以，如果我们想将`a`的值设置为`80`而不是默认值，我们将这样做：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we wish to change both the values, we can also do that, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想改变两个值，我们也可以这样做，如下所示：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Returning more than one value
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回多个值
- en: In Swift, we can return more than one value using tuples.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，我们可以使用元组返回多个值。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tuples are variables that can hold two values, like an array. In fact, a variable
    with three values in it is called a 3-tuple.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是可以存储两个值的变量，就像数组一样。实际上，包含三个值的变量被称为3元组。
- en: 'A tuple can be initialized as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 元组可以这样初始化：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Individual values can be initialized as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 单个值可以初始化，如下所示：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also name your variables for convenience. Then you can access the names
    to assign values instead of the index:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为变量命名以方便使用。然后你可以通过名称来访问它们以分配值，而不是使用索引：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In Swift, you will be able to pass the actual value, perform some action on
    the variable, and then return the variable. When returning two values, we will
    need to provide the return type of both values, separated by a comma:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，你将能够传递实际值，对变量执行一些操作，然后返回变量。当返回两个值时，我们需要提供两个值的返回类型，用逗号分隔：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So, in the preceding function, we take in two integers and calculate the area
    and the perimeter of a rectangle. Then we return both the values:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在先前的函数中，我们接受两个整数，计算矩形的面积和周长，然后返回这两个值：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The value is stored in a constant called `value`, and to output the values
    to the console, we use the dot operator. It is used with `0` to get the first
    value and with `1` to get the second value:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 值存储在一个名为`value`的常量中，要将值输出到控制台，我们使用点操作符。它用`0`来获取第一个值，用`1`来获取第二个值：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This is a bit cumbersome, as we will have to remember that the first value
    returned is the area and the second value is the perimeter. But this can also
    be fixed quite easily in Swift. Just as we name the values while passing, we can
    also name the returned values. Then, instead of using index values, we can use
    the name itself to access the values:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点麻烦，因为我们必须记住返回的第一个值是面积，第二个值是周长。但在Swift中，这也可以很容易地解决。就像我们传递时命名值一样，我们也可以命名返回的值。然后，而不是使用索引值，我们可以使用名称本身来访问值：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Classes
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes are quite easy to create in Swift compared to Objective-C or C++. There
    is no need for separate files such as an interface file and then an implementation
    file. Also, there is no property keyword used to define properties. All Swift
    files end with an extension of `.swift`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 与Objective-C或C++相比，在Swift中创建类相当简单。不需要像接口文件和实现文件这样的单独文件。此外，也没有使用属性关键字来定义属性。所有Swift文件都以`.swift`扩展名结尾。
- en: Properties and initializers
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和初始化器
- en: 'We will have to use the `class` keyword when creating a class:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类时，我们必须使用`class`关键字：
- en: '[PRE61]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also notice that there is no semicolon after the closing brace. To instantiate
    a variable of the `character` type, you can use the following line of code. There
    is simply no need of `alloc` as was the case in Objective-C:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在结束括号之后没有分号。要实例化 `character` 类型的变量，可以使用以下代码行。在这种情况下，根本不需要 `alloc`，就像在 Objective-C
    中那样：
- en: '[PRE62]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `name` and `health` properties can be accessed using the dot operator:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用点操作符访问 `name` 和 `health` 属性：
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To initialize the variable, we will need to use the `init` function. This is
    the constructor for the class, and it doesn''t require the `func` keyword, which
    is required when creating any other function. So, if you want to initialize the
    `name` and `health` variables in the `init` function, you have to do it as shown
    in the following code snippet. Notice that you will need to explicitly provide
    the variable type for the `name` and `health` variables in this case:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化变量，我们需要使用 `init` 函数。这是类的构造函数，它不需要 `func` 关键字，这在创建任何其他函数时是必需的。所以，如果你想在 `init`
    函数中初始化 `name` 和 `health` 变量，你必须像以下代码片段中那样做。注意，在这种情况下，你需要明确为 `name` 和 `health`
    变量提供变量类型：
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can instantiate and access the properties of the class in the same way as
    before. We can definitely create as many custom initializers as we want. These
    will also use the `init` key word, and you can pass the type of variable in the
    parentheses and assign the value to the property:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以前一样实例化和访问类的属性。我们肯定可以创建尽可能多的自定义初始化器。这些也会使用 `init` 关键字，并且你可以在括号中传递变量的类型并将值分配给属性：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Notice that here, while assigning the variable passed to the property, we execute
    `self.name` to tell the code that we are assigning the name of the passed variable,
    to the `name` property of the class.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里，在将传递给属性的变量赋值时，我们执行 `self.name` 以告诉代码我们将传递变量的名称赋给类的 `name` 属性。
- en: 'Also, while passing the value, we have to mention that we are passing it to
    the `name` argument:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在传递值时，我们必须提到我们将它传递给 `name` 参数：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Custom methods
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义方法
- en: 'We can obviously create custom methods in a class. Here, suppose we want the
    character to take some damage after being hit. For this, we will create a new
    method, as shown here. Add this block before the closing bracket of the class:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然可以在类中创建自定义方法。这里，假设我们想让角色在被击中后受到一些伤害。为此，我们将创建一个新的方法，如下所示。在类的结束括号之前添加此块：
- en: '[PRE67]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Methods in a class are defined like any other function. Here, we are defining
    a method called `takeDamage`, and it takes in a variable called `damage` of type
    `int`. Now we can call this function on the `hero` variable we instantiated earlier,
    and pass `10` for the hero to take 10 points of damage. If we call the `health`
    property again, we will see that the hero''s health has dropped by 10 points:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的方法定义方式与其他任何函数一样。这里，我们定义了一个名为 `takeDamage` 的方法，它接受一个名为 `damage` 的 `int` 类型的变量。现在我们可以调用这个函数在之前实例化的
    `hero` 变量上，并传递 `10` 以让英雄受到 10 点伤害。如果我们再次调用 `health` 属性，我们会看到英雄的健康值下降了 10 点：
- en: '[PRE68]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now let''s add one more property to the class and call it `armour` of type
    `int`. Let the initial armor level of the player be `10`. Each time the player
    takes a hit, his armor also goes down:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给类添加一个名为 `armour` 的属性，类型为 `int`。让玩家的初始护甲等级为 `10`。每次玩家受到攻击，他的护甲也会下降：
- en: '[PRE69]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We add a new function called `reduceArmour`. In it, we take in an additional
    parameter called `damage` and reduce the `armour` property of the class by that
    amount:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `reduceArmour` 的新函数。在其中，我们接受一个名为 `damage` 的额外参数，并减少类中 `armour` 属性的相应数量：
- en: '[PRE70]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now, when we want to call the method, we have to explicitly mention that the
    second value passed is for `armour`. When we call the `health` and `armour` properties,
    we can see that `health` is reduced by 10 again and `armour` of the hero is now
    reduced by 2.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们想要调用方法时，我们必须明确指出传递的第二个值是用于 `armour` 的。当我们调用 `health` 和 `armour` 属性时，我们可以看到
    `health` 再次减少了 10 点，而英雄的护甲现在减少了 2 点。
- en: Inheritance
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: Like any other object-oriented language in which we wish to reuse or extend
    an existing class, Swift also allows inheritance. To inherit from another class,
    we will need to use a colon and specify the name of the class we want to extend
    while defining the current class.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在其他任何我们希望重用或扩展现有类的面向对象语言中一样，Swift 也允许继承。要继承另一个类，我们需要使用冒号并在定义当前类时指定我们想要扩展的类的名称。
- en: Tip
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Swift doesn't allow multiple inheritance.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 不允许多重继承。
- en: 'Suppose we want to create a `Mage` class, and the mage has a property called
    `magic` so that she can do some "magic" damage along with regular damage:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要创建一个 `Mage` 类，法师有一个名为 `magic` 的属性，这样她就可以在普通伤害之外造成一些“魔法”伤害：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, we create a new class called `Mage` and inherit it from the `Character2`
    class. We will need the `override` keyword to tell the code that we are overriding
    the `init` function of the `Character2` class, which is the superclass.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `Mage` 的新类，并从 `Character2` 类继承。我们需要使用 `override` 关键字来告诉代码我们正在重写
    `Character2` 类的 `init` 函数，这是超类。
- en: In Objective-C, we would usually call `super.init` first, but in Swift, we will
    need to initialize the `magic` property first, as this property doesn't exist
    in the superclass. So, we initialize it first and then call the `super.init` method.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，我们通常会先调用 `super.init`，但在 Swift 中，我们需要先初始化 `magic` 属性，因为这个属性在超类中不存在。因此，我们首先初始化它，然后调用
    `super.init` 方法。
- en: 'If we create a new variable for a character called `vereka`, which is of type
    `Mage` and name her `vereka`, we will see that the name and other values assigned
    are of the `Character2` superclass instead of the name that we assigned:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为名为 `vereka` 的角色创建一个新的变量，其类型为 `Mage` 并将其命名为 `vereka`，我们会看到分配的名称和其他值是 `Character2`
    超类的，而不是我们分配的名称：
- en: '[PRE72]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: For the new name to be assigned, we have to initialize it again after we call
    `super.init` in the `init` method of the `Mage` class. So, we uncomment the lines
    of code in the `Mage` class where we assign the name and the new `health` and
    `armour` values to the `Mage` class. Now, the correct `name`, `health`, `armour`,
    and `magic` values will be displayed.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为新名称分配，我们必须在 `Mage` 类的 `init` 方法中调用 `super.init` 之后再次初始化它。因此，我们在 `Mage` 类中取消注释分配名称和新的
    `health` 以及 `armour` 值的代码行。现在，将显示正确的 `name`、`health`、`armour` 和 `magic` 值。
- en: Access specifiers
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: In Swift, there are access specifiers that can be used to encapsulate classes,
    properties, and methods. Access specifiers provide read and write access to variables.
    Both the usual `public` and `private` access specifiers are present in Swift.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，有可以用来封装类、属性和方法的访问修饰符。访问修饰符提供了对变量的读写访问。Swift 中既有常规的 `public` 和 `private`
    访问修饰符。
- en: When creating a class, if a variable of a function is set to `public`, then
    any class can access that variable and modify it, but if it is set to `private`,
    then other classes cannot access that variable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个类时，如果一个变量或函数被设置为 `public`，那么任何类都可以访问并修改该变量，但如果它被设置为 `private`，那么其他类则不能访问该变量。
- en: Apart from public and private access specifiers, there is also an additional
    specifier called `internal`. If you have used encapsulation in Objective-C or
    C++, you will be pleased to know that public and private variables work pretty
    much the same in Swift, and `internal` replaces the `protected` encapsulation
    type.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了公共和私有访问修饰符之外，还有一个额外的修饰符称为 `internal`。如果你在 Objective-C 或 C++ 中使用过封装，你会很高兴地知道在
    Swift 中公共和私有变量几乎以相同的方式工作，而 `internal` 替换了 `protected` 封装类型。
- en: In Swift, the `internal` specification is the default specification type, unlike
    C++, where the default specification is private if not specified.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，`internal` 规范是默认规范类型，与 C++ 不同，在 C++ 中，如果没有指定，默认规范是私有。
- en: 'Even though we didn''t specify the access specifier in the `Character2` class,
    we were still able to access its variables and functions in the `Mage` class,
    as they are internal and can be accessed by the child class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有在 `Character2` 类中指定访问修饰符，但我们仍然能够在 `Mage` 类中访问其变量和函数，因为它们是内部的，可以被子类访问：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `myCharacter` class and `name` variable are public. The `age` variable is
    private and speed is assumed to be internal because it is not specified otherwise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`myCharacter` 类和 `name` 变量是公开的。`age` 变量是私有的，速度被假定为内部变量，因为它没有其他指定。'
- en: Optionals
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选类型
- en: Optionals are a new data type in Swift. In all the cases covered so far in this
    chapter, we have always initialized a variable, whether we initialized it inline
    or in an initializer in a class. If we don't initialize the variable and start
    using it, we get an error saying that we haven't initialized it yet. The quick
    fix is to initialize it to `0` or `""`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 可选类型是 Swift 中的新数据类型。在本章迄今为止的所有案例中，我们总是初始化了一个变量，无论是直接初始化还是在一个类的初始化器中初始化。如果我们没有初始化变量就开始使用它，我们会得到一个错误，说我们还没有初始化它。快速修复方法是将其初始化为
    `0` 或 `""`。
- en: Suppose this variable is `score` and we have initialized its value to zero to
    get rid of the error. Now we try to retrieve the last score stored in GameCenter.
    For some reason, there is no Internet connection or Wi-Fi, and so we are not able
    to retrieve that player's last `score`. If we display the score on the screen,
    it will say **0** because that is what is stored in score. The player will be
    very confused and frustrated, as they are sure that the score was a lot more than
    zero in their last attempt. Now, how will we tell the player that we weren't able
    to retrieve the score because they forgot to pay the Internet bill?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这个变量是`score`，我们将其值初始化为零以消除错误。现在我们尝试检索GameCenter中存储的最后分数。由于某种原因，没有互联网连接或Wi-Fi，所以我们无法检索该玩家的最后`score`。如果我们显示分数在屏幕上，它将显示**0**，因为这是存储在`score`中的值。玩家会非常困惑和沮丧，因为他们确信在他们的最后一次尝试中分数远高于零。现在，我们如何告诉玩家我们无法检索分数是因为他们忘记支付互联网账单呢？
- en: In other words, how do we tell the program that there is no value in `score`?
    We can't even equate score to `nil` because we will get an error saying that it
    is not of type `nil`. For this, we put a question mark after the type. This means
    that if we assign a value, it will be of type `int`; otherwise, it should be treated
    as `nil`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们如何告诉程序`score`中没有值？我们甚至不能将`score`等于`nil`，因为我们将会得到一个错误，说它不是`nil`类型。为此，我们在类型后加上一个问号。这意味着如果我们分配一个值，它将是`int`类型；否则，它应该被视为`nil`。
- en: 'Now, at the time of displaying the score, we can check whether the value is
    `nil`. If it is, then we can print a message saying there is no Internet connection,
    and if `score` holds a value, we can print that as well:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在显示分数的时候，我们可以检查值是否为`nil`。如果是，我们可以打印一条消息说明没有互联网连接，如果`score`包含一个值，我们也可以打印出来：
- en: '[PRE74]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The preceding code will print from the `else` block, as the value is not assigned—it
    is still `nil`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将从`else`块中打印出来，因为值没有被分配——它仍然是`nil`。
- en: Now, if we assign a value, say `score = 75`, it will print the value but with
    the optional keyword along with the value in parentheses. This is because, since
    the type we specified is optional, it is letting us know the data type.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们分配一个值，比如说`score = 75`，它将打印这个值，但会带上可选关键字以及括号内的值。这是因为，由于我们指定的类型是可选的，它让我们知道数据类型。
- en: 'For it not to show the optional keyword while logging out, we need to "unwrap"
    the optional type. This is done by following the `score` variable in the `if`
    block with an exclamation, as shown in this line of code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在记录时不出现在可选关键字，我们需要“展开”可选类型。这是通过在`if`块中跟随`score`变量并使用感叹号来完成的，如代码行所示：
- en: '[PRE75]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The optional keyword will now disappear when logging the score.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可选关键字现在在记录分数时将消失。
- en: You might not use optionals in the games you create, but if you do have to,
    you will at least not be surprised when you see one of them.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不会在你的游戏中使用可选参数，但如果你不得不这么做，当你看到其中一个时，至少不会感到惊讶。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw some basics of the Swift language. This should get you
    up to speed with the language so that from the next chapter onwards, you will
    have a good idea of the syntax and will know exactly what is happening in the
    code. You might also revisit the first chapter now and look at the code from the
    SpriteKit and SceneKit project files to see whether you are able to make any sense
    of the code.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了Swift语言的一些基础知识。这应该让你对语言有足够的了解，以便从下一章开始，你将有一个很好的语法概念，并确切地知道代码中发生了什么。你现在也可以回顾一下第一章，看看SpriteKit和SceneKit项目文件中的代码，看看你是否能理解这些代码。
- en: As the chapter says, this was just a basic introduction to the Swift language.
    This language is quite similar in certain aspects and quite different in others
    when compared to other languages. When we come across any of these differences
    in the following chapters, I will be pointing them out so that you will be well
    aware of the errors and will know how to get around them and understand them better.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 正如章节所说，这只是一个Swift语言的入门介绍。与其他语言相比，这个语言在某些方面非常相似，在其他方面则非常不同。在接下来的章节中，当我们遇到这些差异时，我会指出它们，这样你就能清楚地意识到错误，并知道如何绕过它们，更好地理解它们。
- en: In the next chapter, we will dive into Xcode, look at it in depth, and start
    from the basics of Xcode.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨Xcode，从Xcode的基础开始。
