- en: Chapter 2. Swift Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let's begin. But before we dive into Xcode, you need to learn Apple's
    new programming language—Swift. For people coming from a JavaScript background,
    this will look very familiar. Apple has taken the best parts and practices from
    both scripting and low-level languages, and integrated some amazing features of
    its own to make Swift easy for anyone to get into, and start coding. As we go
    further, we will see that Apple has also added a few features that really make
    Swift shine compared to other languages.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 1](ch01.html "Chapter 1. Getting Started"), *Getting Started*,
    we will be using Xcode's playground to do all the coding. Playground is a very
    versatile tool. Whenever you create a new file, you can start working on it immediately
    without any further setup. It has an inbuilt **Results** panel on the right that
    will compile your code in real time every time you make changes to the file. There
    is also an **Assistant Editor** window, which will give a graphical representation
    of the changes we make in the code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with the basics of the Swift language, from declaring
    variables to conditional statements, loops, arrays, functions, and classes. So,
    let's get started. Create a new playground file, name it whatever you like, and
    open it. If you have created a file in the first chapter, you will already have
    a file in the `_Playgrounds` folder that you can open.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Data types and operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and dictionaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have some experience in coding in other languages, you should know what
    a variable is by now. If not, then know that a variable is something that holds
    a value that can be changed at any time. This is why it is called a variable.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, you can define a variable using the `var` keyword, similar to JavaScript.
    So, if I create a new variable called `age`, then I type `var age`, and that is
    all; a variable is defined.
  prefs: []
  type: TYPE_NORMAL
- en: Veteran C coders will notice that I missed the semicolon at the end. Well, it
    is not required in Swift, but if you want to use the semicolon, you are most welcome
    to do so. I do it out of habit and also because it is good practice. This is because
    after coding in Swift for a while, if you don't use colons and then use a C-based
    language, you will get errors all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! There is an error. Swift is not able to figure out implicitly what
    data type `age` is; that is, is it an integer, a float, a Boolean, or a string?
    For Swift to implicitly assign a type, you have to initialize the variable. I
    can depict the age of a person as an `int` variable of value `10`, a `float` variable
    with the value of `10.0`, or as a `string` variable with the value of `Ten`. Depending
    on the variable type you assign, Swift will know that the variable is an `int`,
    `float,` or `string` type.
  prefs: []
  type: TYPE_NORMAL
- en: I am going to assign an `age` variable of value `10`. In the **Results** panel,
    you will see that the value of the variable is printed as **10**. This is the
    value that is stored in the `age` variable as of now. So, if you just type `age`
    in the next line, you will find the result displayed on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: If you add `1` to `age`, you will see the result as **11**. This has not changed
    the value of `age`; only the line is evaluated and displayed. If you want to change
    the value of `age` to `11`, you can use the shorthand `age++` command to increment
    the value, as you do in Objective-C or any other C-based language.
  prefs: []
  type: TYPE_NORMAL
- en: Once a variable has been assigned a certain type, you cannot assign values of
    some other type. So now, if you try to assign `11.0` or `Eleven`, it won't be
    accepted and you will get errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, we saw how to assign an `int` variable, but how do we assign the `float`,
    `string`, and `bool`? This can be done as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What if I don''t want to initialize a variable? We can tell Swift the type
    of the variable explicitly as well. We can tell Swift that a variable is of a
    certain type by telling it the variable type that we would like to assign. We
    do this by adding a colon and the type after the name of the variable, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of the `var` keyword, you may have seen this new keyword called `let`,
    which is very common in Swift. If you don't want a variable's value to change
    throughout the code, then you should use the `let` keyword instead of `var`. This
    will also make sure that the value remains constant even if you change the value
    stored by `let` by accident. These are also known as constants in other languages,
    which you can define using the `const` keyword, but in Swift, you use the `let`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, you know that no matter what, `male` remains a male
    throughout his life. So, `bool male` will remain `true` and remain constant; it
    will never change (well, unless the guy is really not happy with his gender).
    Once it is set to `true,` we can''t change it to `false` even by accident later
    on. So, the syntax will change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once again, if you are not explicitly giving the data type, you will still have
    to initialize the variable. So, you might think that you didn't change anything.
    The results panel still shows the same value as it did when the variables were
    `var`. But try changing the values now. Suppose, for example, you incremented
    the `age` variable; try doing it now and you are certain to get an error.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you know that a variable's value is bound to change, it is better to
    use `var`. Otherwise, you are safer using `let` to save yourself a whole lot of
    bugs in your code resulting from this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have understood how to declare and initialize the variables, let's
    use these variables to conduct some operations using operators.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operators are used in computer languages to perform various operations on variables.
    It could be an arithmetic operation (such as addition), a comparison operation
    to check whether a number is larger or smaller than the other, a logical operation
    to check whether a condition is true or false, or an arithmetic assignment such
    as increasing or decreasing a value. Let's now look at each type in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computers were initially made to perform numerical operations such as addition,
    subtraction, multiplication, and division. In Swift also, we have operators such
    as `+`, `-`, `*`, `/`, and `%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare two variables, `a` and `b`, and initialize them with values
    `36` and `10`. If you want to make a single-line initialization in Swift, you
    can do it as shown in the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the semicolon to separate them, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful if you want to initialize variables of different types. Now
    let''s use operators between the variables. The result should be `46`, `26`, `360`,
    `3`, and `6`. Notice that the result of dividing an `int` variable with an `int`
    variable, is an `int` variable, instead of a `float` variable such as `3.6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the exact result, we will need to type cast the variables. Type casting
    is done very similarly to how it is done in other languages; the type that you
    want to convert the variable to is added prior to the variable in brackets, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical operators are used to check whether a variable is equal to, less than,
    greater than, less than or equal to, or greater than or equal to the other variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to other languages, you can use the `&&` sign to check for the logical
    AND condition and `||` to check the OR condition between two operations. These
    two are used to check whether both expressions satisfy their conditions or only
    either of the conditions is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we know that `a` is not equal to `b` but `a` is greater
    than `b`. So, the first statement in the preceding example is `false` (because
    both its parts aren't `true`), but the second statement holds `true` because at
    least one condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic increment/decrement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we increased the age in the first example by adding a `++` sign at the
    end of the variable, we also assign a `--` sign to decrement the value of the
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that `a++` is different from ++`a`. They are called post- and pre-increment
    operators respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we start with a variable, `a`, with an initial value
    of `36`.
  prefs: []
  type: TYPE_NORMAL
- en: If you do `a++,` it is called post-increment. It will first display the result
    and then increment the value of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you do `a++`, which should have incremented the value of `a`, the result
    will still show up as `36`, suggesting that the value has still not been incremented
    yet. Yet, immediately in the next line if you ask it to output the value of `a`,
    it will show up as `37`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arithmetic increment/decrement](img/B04014_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you do `++a`, it is called pre-increment. It will increment the value first
    and then show the output. So in this case, it will show `37` in the same line
    where you incremented the value of `a`, and if you ask it to show the value of
    `a` in the next line, it will again show `37`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arithmetic increment/decrement](img/B04014_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is just to keep in mind for the future, in case you encounter any bugs
    in the code and wonder why the correct value of your expression is not getting
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Composite operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also perform composite operations to increment, decrement, multiply,
    or divide by a much higher number, like this: `a+=10`, `a-=10`, `a*=10`, `a/=10`,
    and `a%=10`, which are shorthand ways of doing `a = a+10`, `a = a-10`, `a = a*10`,
    `a = a/10`, and `a = a%10` respectively. So, if you replace `a+=10` with `a =
    a + 10`, it will still give the same result. This is done for the sake of optimization
    and readability of code.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composite operations](img/B04014_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Statements are of two kinds in any programming language—decision making statements
    and looping statements.
  prefs: []
  type: TYPE_NORMAL
- en: Decision-making statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Decision making statements are of the following types: `if`, `if else`, `else
    if`, and `switch`. This is very standard in any programming language. Let''s look
    at the `if` statement first and see how the syntax differs from other C-based
    languages.'
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift, the `if` statement is written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Immediately, the guys using C will be like, "Blasphemy!! No brackets!!" Yes,
    in Swift for the sake of simplicity and readability, you don't have to use the
    brackets. If you want to, you can still use them, and you won't get any compile
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: But you absolutely must enclose the statement in the curly braces. Even if it
    is a single line statement, it is absolutely mandatory. If you don't, you will
    get compile errors for sure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s a small note about logging code on the screen: we will be using this
    feature quite extensively when we start developing the game to make sure that
    the program is doing exactly what we want it to do. So, we will be logging statements
    to check for logical errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C, we would use something such as `NSLog(@"Print Stuff to Screen")`
    or `NSLog(@"My age is: %d", age)`. In Swift, this is done a bit differently. For
    one, you don''t need to put the `@` sign in front of any string to log it out.
    Secondly, to print the values, we have to use `\()` with the variable in the bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![The if statement](img/B04014_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The same can be applied to strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![The if statement](img/B04014_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The if else statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the `if` statement, the `if else` statement is written as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Instead of checking whether `a` is greater than `b`, we are checking otherwise,
    and now it will print **30 is greater than 10** by entering the `else` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The else if statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the `if` statement where we didn''t put the brackets around the
    condition, in `else if`, we are not required to put the brackets around the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So here, we're checking whether `a` is greater than `b`, then print the following
    statement (from the code snippet) instead of checking for just the `else` bit.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of taking 10 lines of code for checking such a simple statement, you
    can use the conditional expression statement to do the work in one line. This
    is more popular if you are just checking for `if`-`else`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we check whether `a` is greater than `b`. If `a` is greater than `b`, then
    the expression evaluates to `true` and the output becomes `36`. Otherwise, the
    output becomes `10`.
  prefs: []
  type: TYPE_NORMAL
- en: The switch statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Switch statements in Swift are a little different from the way they are in other
    languages. Like the `if` statement, the brackets around the variable, or expression,
    are not required, but that's not the only difference.
  prefs: []
  type: TYPE_NORMAL
- en: All statements need to print some value, or some condition needs to be checked.
    You cannot have an empty case; that will give an error. Secondly, as all statements
    will be evaluated, a break is not necessary at the end of every line. In other
    C-based languages, all lines will be evaluated and executed, unlike the `switch`
    statement in Swift, where only the valid cases will be executed. Finally, the
    cases need to be exhaustive. This means that there needs to be a default at the
    end so that if none of the cases match, then a default value or statement gets
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of switch-case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, a new variable called `speed` is created. Based on the value of the speed,
    the system will print whether the value is slow or fastest. If `speed` is not
    a number, or the value is not between `10` and `50`, the default message will
    be printed. So in this case, as the value matches with `case 30`, it will print
    **fast enough**.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of fixed values for case statements, you can also provide a range of
    values for which the statement will be `true`. So for example, if the value is
    between `0` and `10`, you would want the output to be **slow**. You can do so
    by giving the range from `0` to `10` as `0…10` in the first case. It is important
    that you put three dots between the values because they form an operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, if you change the value of speed to anything between `0` and `10`,
    the output will be **slow**. Similarly, the range can be used with other case
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Looping statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looping statements are used to execute a particular block of code infinitely,
    for a said number of times, or until a certain condition is satisfied. As in any
    other language, we have the `while`, `do while`, and `for` loops, and we have
    a `for each` loop as in C# and C++11.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a `while` loop, we first give a condition. If the condition holds `true`,
    the block following the code will keep on executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we create two variables, `n` and `t`. We set `n` equal to
    `1` and `t` equal to `10`. In the condition, we increment the value every time
    the code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once again, there is no need to put the parentheses around the condition. But
    you will see that, in the results panel, nothing printed except nine times.
  prefs: []
  type: TYPE_NORMAL
- en: There is a + icon, and there is another icon next to it. Pressing it will open
    a new pane. This is called **Assistant Editor**. In it, you will see a graph.
    This shows the increment of the value of `n` over the period of time the loop
    was running. It starts from `1` and goes all the way to `9`, since we told the
    loop to run only while the value of `n` is less than `10`. You can move the mouse
    arrow onto the nodes to know the value at each node. Alternatively, there is a
    scroll bar to scroll to the graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![The while loop](img/B04014_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also open **Assistant Editor** in Xcode by going to **View** | **Assistant
    Editor** | **Show Assistant Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The while loop](img/B04014_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the value history icon to open the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The while loop](img/B04014_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The do while loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the `while` loop, the code block of the `do while` loop gets executed
    while the condition is `true`. However, in this case, the block executes at least
    once and then the condition is checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are reducing the value of `n` by 1 every time it enters the loop and
    checking whether the value is greater than `0`. If it is, then the code block
    gets executed. The value of `n` from the previous piece of code is `10`, so it
    starts from `10` and goes back to `1`. Again, this is plotted in a graph, which
    can be seen by clicking on the icon on the results panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![The do while loop](img/B04014_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be carful to make sure that the condition will be met. Otherwise, it will lead
    to an infinite loop, causing your system to become unstable.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `for` loop can be written as shown here. Even without the brackets, it
    will work fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of adding `1` every time, we multiply the value of `i` to itself
    to get a curved line in the graph, ranging from `0` to `81`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The for loop](img/B04014_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The for in loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like the `for each` loop in other languages, you have a `for in` loop in Swift.
    It goes through each item in the loop and executes whatever has been stated by
    the code. Here, unlike other languages, it is not necessary to specify the type
    of variable. Swift will automatically understand the variable type according to
    the list of items you want it to loop through. For example, looping through a
    list of integers can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, even though we never mentioned in the code that `l` is an integer type,
    Swift automatically understood it, according to the list of values we gave in
    the code. Since the type of the list given is an `int`, the value of `l` automatically
    gets assigned the type `int`, and the output is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The for in loop](img/B04014_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Additionally, while looping through an index of an array, we would want to
    start from `0` and go to the last but one value. The same can be achieved using
    `..<` instead of the `…` operator when specifying the range. So, in the preceding
    example, if we have to go from `0` to `9`, we can rewrite the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is obviously not limited to numbers; we can loop through any data type.
    For example, we can loop through the characters in a string like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here again, it was never explicitly mentioned that the type of the variable
    is `char`, and yet Swift was able to implicitly judge that `c` should be of the
    `char` type. In the console, each character will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array is a consecutive block of memory that holds a certain type of data.
    It can be a predefined data type, such as `int`, `float`, `char`, `string`, or
    `bool`, or it can be user-defined. Also, arrays are zero-based, which means that
    the first object in the array is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays can be either of the `var` or `let` type. If we create an array of the
    `var` type, then we can change, add, or remove the objects from the array similar
    to how we have `MutableArray` in Objective-C. If you want an `ImmutableArray`
    array in Swift, instead of `var`, use the `let` keyword. Arrays in Swift can be
    declared and initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to declare an array and initialize it later, we can declare
    it as shown in the following snippet of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you will have to provide the data type that the array will be storing.
    It is very similar to defining a regular variable; it''s just that the type here
    is surrounded by square brackets. Now we can initialize it as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To get an item at an index, you can use the variable name with the index number
    in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Looping through arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To loop through an array, we can use the `for in` loop, as we saw in loops.
    Here, instead of passing the range, we provide the range itself, and as before,
    the data type present in the array is automatically determined by Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Adding, removing, and inserting objects into arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add items to the array, you can use the `append` method. So, to add values
    to the `score` or `daysofweek` array, we do it as shown in the following code
    snippet. This will add the object at the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove the last object from the array by calling this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to remove an object at a particular index, you can use the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove the element at the fifth index, which is `2` here. To insert
    an item at a particular index, we will have to provide the value and index at
    which the item has to be inserted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Important array functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from functions such as `append`, `remove`, and `insert`, there are other
    built-in functions that we will be using quite often in games. The first is the
    `count` function, which tells us the number of elements present in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The other function is `isEmpty`, which can be used to check whether an array
    has any items present in it or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also known as a map or hash table in other languages, a dictionary—like arrays—is
    a data collection type. However, unlike arrays—in which each element in the array
    can be accessed only by an index number—in dictionaries, we will provide keys
    with which we will be able to access the element at a particular index. The values
    of `keys` and `values` can be `int`, `float`, `bool`, or `string` values. You
    cannot have duplicate keys, but you can obviously have duplicate values in the
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at the FIFA''s country code list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Country |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| AFG | Afghanistan |'
  prefs: []
  type: TYPE_TB
- en: '| ALB | Albania |'
  prefs: []
  type: TYPE_TB
- en: '| ALG | Algeria |'
  prefs: []
  type: TYPE_TB
- en: '| ASA | American Samoa |'
  prefs: []
  type: TYPE_TB
- en: '| AND | Andorra |'
  prefs: []
  type: TYPE_TB
- en: '| ANG | Angola |'
  prefs: []
  type: TYPE_TB
- en: '| AIA | Anguilla |'
  prefs: []
  type: TYPE_TB
- en: '| ATG | Antigua and Barbuda |'
  prefs: []
  type: TYPE_TB
- en: '| ARG | Argentina |'
  prefs: []
  type: TYPE_TB
- en: '| ARM | Armenia |'
  prefs: []
  type: TYPE_TB
- en: 'The code in the left columns can be termed as **keys** and the **Country**
    column on the right represents the **value**. So, when I want to refer to Argentina,
    I can simply call ARG and Swift will automatically understand that I am referring
    to Argentina. Here''s another example: when we say, "get the value for the `ATG`
    key," the program will know that we are referring to Antigua and Barbuda.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of a dictionary is that the data doesn't have to be sorted. If
    we know that the key-value pair exists in the dictionary, irrespective of where
    it is in the list, we can get the value by asking for it by the key.
  prefs: []
  type: TYPE_NORMAL
- en: This syntax is similar to arrays. The only difference is that instead of giving
    one type of variable, we have to provide two during declaration, the first being
    the type of the key and the second being the type of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, you don''t have to provide the types explicitly if you are already
    aware of the types of both `key` and `value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The key-value pair can be of any combination. This means that you can have a
    `key` variable of type `int` and `value` of type `string`; `key` of type `string`
    and `value` of type `string`, as shown in the example; or `key` of type `string`
    and `value` of type `int`; and so on. You cannot change or provide a different
    type after declaring the dictionary keys and values with a certain type. Also,
    you cannot add a key of type `int` if you've already declared that the keys will
    be of type `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also explicitly tell the types of the key-value pair, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that the keys will be of type `string` and the values associated
    with those keys will also be of type `string`. If we want to store the population
    for a set of keys, it can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Adding and removing objects from the dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a new key-value pair to an existing dictionary, we can simply run one
    of these two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Beware, however, because if the key already exists, it will overwrite the current
    value it holds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to remove a key-value pair, you can use either of the following
    statements to delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we try to access the key-value pair, we will notice that it has removed
    not only the value stored by the key, but the key as well.
  prefs: []
  type: TYPE_NORMAL
- en: Looping through items in the dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, we can use the `for`-`in` loop to access the data stored in each
    key-value pair, but instead of just one value, we will have to provide two values
    in parentheses, separated by a comma for separation of the key and value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The console output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to arrays, the dictionary also has inbuilt functions to determine the
    number of key-value pairs present in it. It also has an `isEmpty` function, which
    can be called on the dictionary to know whether it contains any key-value pair
    at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function is a block of code that is used to perform a certain task. It can
    be used to assign a block of reusable code that you can call again and again without
    rewriting the code every time to perform that task.
  prefs: []
  type: TYPE_NORMAL
- en: Simple functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions in Swift are written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: So here, before a function, we will need to use the `func` keyword, followed
    by the name of the function, the parentheses, and the open and closed curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling a function here is very similar to any other language, that is, the
    name of the function followed by parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Passing a parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, to perform some task on a variable passed to a function, we first need
    to pass a parameter into the function. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have to provide the input variable type within the parentheses. We
    cannot provide an integer here when the function is expecting a string, as it
    takes the type explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the function, call the function and, within the parentheses, include
    the text that you want to perform the function on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that the value passed to a function is a constant by default.
    This means that even though we don't specify whether `mtext` is a variable or
    constant, it will remain a constant. So, you will not be able to make any modifications
    to it within the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your code requires the type to be a variable instead of a constant, you
    need to specify this while creating the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Passing more than one parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can obviously pass more than one variable. Here, you will need to separate
    the variables types with a comma, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pass two numbers, `10` and `15`, to the function. We perform their
    addition, store the value in a constant called `sum`, and print it to the console
    by calling the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Returning a value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a C++ user, this might look a little strange. Also, people not comfortable
    with pointers might freak out looking at the syntax of a function returning a
    parameter as it uses the pointer operator in Swift. Don't fret! This has absolutely
    nothing to do with pointers. It is just a way to show that this function will
    return a data type, and that's all.
  prefs: []
  type: TYPE_NORMAL
- en: The function is written as usual, but at the end, we specify the return type
    after the parentheses by typing the dash and greater than sign, and then typing
    the return type.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are performing a multiplication using a function that takes in two
    `int` values and returns an `int` value. We calculate the value by performing
    the multiplication operation, store the value in a constant called `mult`, and
    then return the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function is called, and the result is stored in a variable and then printed
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, the console will output the multiplied value—`200`.
  prefs: []
  type: TYPE_NORMAL
- en: Default and named parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to assign a default value to the parameters in the function, we
    can certainly do it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are assigning `20` and `30` as default values. We simply call the function
    to get an output of `300`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what if we want to modify only one value and keep the other value as default?
    In that case, we will assign a value by name, while calling the function. So,
    if we want the value of `a` to be `80` instead of the default value, we will do
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish to change both the values, we can also do that, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Returning more than one value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift, we can return more than one value using tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tuples are variables that can hold two values, like an array. In fact, a variable
    with three values in it is called a 3-tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Individual values can be initialized as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also name your variables for convenience. Then you can access the names
    to assign values instead of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift, you will be able to pass the actual value, perform some action on
    the variable, and then return the variable. When returning two values, we will
    need to provide the return type of both values, separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in the preceding function, we take in two integers and calculate the area
    and the perimeter of a rectangle. Then we return both the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The value is stored in a constant called `value`, and to output the values
    to the console, we use the dot operator. It is used with `0` to get the first
    value and with `1` to get the second value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a bit cumbersome, as we will have to remember that the first value
    returned is the area and the second value is the perimeter. But this can also
    be fixed quite easily in Swift. Just as we name the values while passing, we can
    also name the returned values. Then, instead of using index values, we can use
    the name itself to access the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes are quite easy to create in Swift compared to Objective-C or C++. There
    is no need for separate files such as an interface file and then an implementation
    file. Also, there is no property keyword used to define properties. All Swift
    files end with an extension of `.swift`.
  prefs: []
  type: TYPE_NORMAL
- en: Properties and initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will have to use the `class` keyword when creating a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Also notice that there is no semicolon after the closing brace. To instantiate
    a variable of the `character` type, you can use the following line of code. There
    is simply no need of `alloc` as was the case in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `name` and `health` properties can be accessed using the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To initialize the variable, we will need to use the `init` function. This is
    the constructor for the class, and it doesn''t require the `func` keyword, which
    is required when creating any other function. So, if you want to initialize the
    `name` and `health` variables in the `init` function, you have to do it as shown
    in the following code snippet. Notice that you will need to explicitly provide
    the variable type for the `name` and `health` variables in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate and access the properties of the class in the same way as
    before. We can definitely create as many custom initializers as we want. These
    will also use the `init` key word, and you can pass the type of variable in the
    parentheses and assign the value to the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice that here, while assigning the variable passed to the property, we execute
    `self.name` to tell the code that we are assigning the name of the passed variable,
    to the `name` property of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, while passing the value, we have to mention that we are passing it to
    the `name` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Custom methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can obviously create custom methods in a class. Here, suppose we want the
    character to take some damage after being hit. For this, we will create a new
    method, as shown here. Add this block before the closing bracket of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Methods in a class are defined like any other function. Here, we are defining
    a method called `takeDamage`, and it takes in a variable called `damage` of type
    `int`. Now we can call this function on the `hero` variable we instantiated earlier,
    and pass `10` for the hero to take 10 points of damage. If we call the `health`
    property again, we will see that the hero''s health has dropped by 10 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add one more property to the class and call it `armour` of type
    `int`. Let the initial armor level of the player be `10`. Each time the player
    takes a hit, his armor also goes down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We add a new function called `reduceArmour`. In it, we take in an additional
    parameter called `damage` and reduce the `armour` property of the class by that
    amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we want to call the method, we have to explicitly mention that the
    second value passed is for `armour`. When we call the `health` and `armour` properties,
    we can see that `health` is reduced by 10 again and `armour` of the hero is now
    reduced by 2.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like any other object-oriented language in which we wish to reuse or extend
    an existing class, Swift also allows inheritance. To inherit from another class,
    we will need to use a colon and specify the name of the class we want to extend
    while defining the current class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift doesn't allow multiple inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to create a `Mage` class, and the mage has a property called
    `magic` so that she can do some "magic" damage along with regular damage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a new class called `Mage` and inherit it from the `Character2`
    class. We will need the `override` keyword to tell the code that we are overriding
    the `init` function of the `Character2` class, which is the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: In Objective-C, we would usually call `super.init` first, but in Swift, we will
    need to initialize the `magic` property first, as this property doesn't exist
    in the superclass. So, we initialize it first and then call the `super.init` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create a new variable for a character called `vereka`, which is of type
    `Mage` and name her `vereka`, we will see that the name and other values assigned
    are of the `Character2` superclass instead of the name that we assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: For the new name to be assigned, we have to initialize it again after we call
    `super.init` in the `init` method of the `Mage` class. So, we uncomment the lines
    of code in the `Mage` class where we assign the name and the new `health` and
    `armour` values to the `Mage` class. Now, the correct `name`, `health`, `armour`,
    and `magic` values will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Access specifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Swift, there are access specifiers that can be used to encapsulate classes,
    properties, and methods. Access specifiers provide read and write access to variables.
    Both the usual `public` and `private` access specifiers are present in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a class, if a variable of a function is set to `public`, then
    any class can access that variable and modify it, but if it is set to `private`,
    then other classes cannot access that variable.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from public and private access specifiers, there is also an additional
    specifier called `internal`. If you have used encapsulation in Objective-C or
    C++, you will be pleased to know that public and private variables work pretty
    much the same in Swift, and `internal` replaces the `protected` encapsulation
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In Swift, the `internal` specification is the default specification type, unlike
    C++, where the default specification is private if not specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we didn''t specify the access specifier in the `Character2` class,
    we were still able to access its variables and functions in the `Mage` class,
    as they are internal and can be accessed by the child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The `myCharacter` class and `name` variable are public. The `age` variable is
    private and speed is assumed to be internal because it is not specified otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Optionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optionals are a new data type in Swift. In all the cases covered so far in this
    chapter, we have always initialized a variable, whether we initialized it inline
    or in an initializer in a class. If we don't initialize the variable and start
    using it, we get an error saying that we haven't initialized it yet. The quick
    fix is to initialize it to `0` or `""`.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose this variable is `score` and we have initialized its value to zero to
    get rid of the error. Now we try to retrieve the last score stored in GameCenter.
    For some reason, there is no Internet connection or Wi-Fi, and so we are not able
    to retrieve that player's last `score`. If we display the score on the screen,
    it will say **0** because that is what is stored in score. The player will be
    very confused and frustrated, as they are sure that the score was a lot more than
    zero in their last attempt. Now, how will we tell the player that we weren't able
    to retrieve the score because they forgot to pay the Internet bill?
  prefs: []
  type: TYPE_NORMAL
- en: In other words, how do we tell the program that there is no value in `score`?
    We can't even equate score to `nil` because we will get an error saying that it
    is not of type `nil`. For this, we put a question mark after the type. This means
    that if we assign a value, it will be of type `int`; otherwise, it should be treated
    as `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, at the time of displaying the score, we can check whether the value is
    `nil`. If it is, then we can print a message saying there is no Internet connection,
    and if `score` holds a value, we can print that as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will print from the `else` block, as the value is not assigned—it
    is still `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we assign a value, say `score = 75`, it will print the value but with
    the optional keyword along with the value in parentheses. This is because, since
    the type we specified is optional, it is letting us know the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'For it not to show the optional keyword while logging out, we need to "unwrap"
    the optional type. This is done by following the `score` variable in the `if`
    block with an exclamation, as shown in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The optional keyword will now disappear when logging the score.
  prefs: []
  type: TYPE_NORMAL
- en: You might not use optionals in the games you create, but if you do have to,
    you will at least not be surprised when you see one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw some basics of the Swift language. This should get you
    up to speed with the language so that from the next chapter onwards, you will
    have a good idea of the syntax and will know exactly what is happening in the
    code. You might also revisit the first chapter now and look at the code from the
    SpriteKit and SceneKit project files to see whether you are able to make any sense
    of the code.
  prefs: []
  type: TYPE_NORMAL
- en: As the chapter says, this was just a basic introduction to the Swift language.
    This language is quite similar in certain aspects and quite different in others
    when compared to other languages. When we come across any of these differences
    in the following chapters, I will be pointing them out so that you will be well
    aware of the errors and will know how to get around them and understand them better.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into Xcode, look at it in depth, and start
    from the basics of Xcode.
  prefs: []
  type: TYPE_NORMAL
