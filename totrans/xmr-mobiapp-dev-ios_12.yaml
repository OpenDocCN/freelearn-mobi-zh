- en: Chapter 12. Peripherals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole point of having a smartphone is that it is not just a phone, it's
    a GPS, a media center, a messenger system, and a video system. In short, that
    little device in your pocket is the proverbial "Jack of all trades, but master
    of *all*."
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps and GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage on the phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a phone call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving a text message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multimedia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The camera on the iPhone is capable of recording stills and video. We will be
    dealing with video shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The camera can be accessed in one of the two ways. Xamarin has released `Xamarin.Mobile`
    in its component store, which gives a cross platform method to access the GPS,
    camera, and address book. For completeness, we will cover both the native and
    component versions.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the camera (Xamarin.Mobile)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Xamarin.Mobile` component provides an easy way to access a camera. A simple
    method would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The issue with the Xamarin component is that it currently doesn't provide a
    method for accessing the front camera; however, the preceding code will save the
    clicked image.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the camera (Native)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The camera is accessed using `UIImagePickerController`. To use it, it's always
    wise to first check whether the device actually has a camera (the iPod Touch doesn't
    have one nor does the simulator). To do this, check the `IsSourceTypeAvailable`
    Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The delegate deals with dismissing the modal window and any other process you
    want (such as displaying the picture or saving the image). A simple delegate would
    look something like the following (it can be extended if required):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Saving to the Photo album (Native)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code would be placed in the `myCameraPicker.Delegate` code within
    the `FinishedPickingMedia()` method, which would save images to the camera roll
    natively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: GPS and Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is also covered by the `Xamarin.Mobile` component in part (the full functionality
    of **Core Location** is not replicated in the `Xamarin.Mobile` component, due
    to there not being an equivalent method on the other platforms that the component
    supports). Thankfully, the component and Core Location work together seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: GPS with Xamarin.Mobile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Xamarin.Mobile` component allows you to listen to the position of the
    device and act when the position has been changed, using the `PositionChanged`
    event. The following code demonstrates how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'While analyzing the preceding lines of code, we come across the following terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DesiredAccuracy`: It is the distance in meters that is needed before the event
    is triggered. This in itself can cause an issue. Anything under that value will
    mean that the event is not triggered. Too big a value, the accuracy is hit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StartListening`: It takes two parameters: `minimumTime` and `minDistance`.
    In this case, it should either return within the first minute, or if the phone
    is moved more than 10 m.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StopListening`: It stops the listening service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Xamarin.Mobile` module also provides you with an asynchronous method—`GetPositionAsync`,
    which retrieves your position asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The returned value stored in `Result` also provides the speed. This is not to
    be relied upon. It's far more accurate to use your own method, but to do that
    you need to know how far you have traveled.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating your speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `CoreLocation` namespace has in it a method named `DistanceFrom` for calculating
    the distance. The method works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the new location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gets the old location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates two instances of `CLManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Puts the coordinates of both the locations into the two instances respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uses `DistanceFrom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resulting `double` value gives you the distance in meters and the time in
    seconds, so the speed you have traveled is in meters/seconds (that is, distance/time).
    The issue here though is the calculation; it might consider how a bird flies rather
    than how you are travelling. For example, if the desired accuracy you have is
    too low and the timeout too high, the method with `DistanceFrom` will still work;
    however, if the distance is not 100 m, but apparently 35 m (consider that a bird
    flies straight across a field, and does not walk down a road, turn left, turn
    right, or go roundabout and then turn left again), the distance is much shorter
    and therefore will also change the speed considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Using Core Location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Core Location is the default framework for the GPS. It is a powerful system
    for determining the positioning of the device and is far reaching in what it does
    and how it does it. As with a number of other facilities within iOS, a delegate
    is required when setting up the Core Location framework. A delegate typically
    handles events.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Core Location and delegate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Core Location and delegate can be set up and used as demonstrated with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`CLLocationManager` is set up with the desired accuracy being set to the best
    it can. Next, to make it useful, we need to first catch any errors with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once the error system has been set, monitoring the changes to the positioning
    needs to be handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the app is paused, this event will need to be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To start the checks for update monitoring, use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the checks for update monitoring, use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `CLLocationManager` class also allows you to monitor the direction you are
    moving in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finding where the user is
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having coordinates is all well and good, but who can actually say what they
    mean? For example, if I were to give you the longitude/latitude coordinates of
    53.431/-2.956, would you know where that was? Chances are that you wouldn't!
  prefs: []
  type: TYPE_NORMAL
- en: This is where reverse geocoding comes into the picture. The `MKReverseGeocoder`
    class is in the `MonoTouch.MapKit` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Unlike `locManager`, the `ReverseGeocoder` class has to be placed into a delegate.
    `MKReverseGeocoder` doesn't contain any events to latch on to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Xamarin.Mobile` component does not contain the ability to perform a `ReverseGeocoder`
    operation. But it's not difficult to write one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the original example, the `LocationsUpdated` method was given as an inline
    example. If this is changed to point to a method, the `ReverseGeolocation` method
    can be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Adding a map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final part to the GPS is to add a map. For this, a `Map` view needs to be
    used by adding it in either Xcode or code. For my purpose, I will assume it was
    added via Xcode and is called `mapViewer`. There are three types of maps available,
    so a `UISegment` control is also added.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a map](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `mapViewer` object needs to be set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The resultant location corresponding to the coordinates passed in the preceding
    code is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a map](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next stage is to make the `UISegment` control go live:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding a map](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In case you didn't know, the geolocation is for **Anfield**, home of Liverpool
    FC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the properties need to be explained in short:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShowUserLocation`: It shows a blue dot to show where the user is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZoomEnabled`: It allows the user to zoom in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScrollEnabled`: It allows the user to scroll the view around'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserInteractionEnabled`: It enables a pin placed on the map to respond (or
    not) when clicked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKCoordinateSpan(0.5,0.5)`: This is the zoom setting— the smaller the number,
    the larger the zoom on the initial view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a pin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When it comes to maps, *pins* are very useful. While a little blue dot is neat,
    a pin really shows you where you are, and information can be added to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Finally, it is always good to center the map and pin on the screen
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pin does not always work on the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: '![Note](img/00001.gif)'
  prefs: []
  type: TYPE_IMG
- en: Storage on the phone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET specifies a number of places in the `SpecialFolders` enumeration (such
    as `Program Files`, `My Music`, and `My Pictures`; a full list can be found on
    the Microsoft website). Due to security restrictions on the iOS devices, only
    a few of them are available. It is safest to restrict saving any user data to
    `My Documents`. Within `My Documents`, you can create directories of your own
    and use them the way you like.
  prefs: []
  type: TYPE_NORMAL
- en: Making a phone call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This may sound daft. Why would you want to write code to make a phone call?
    In true developer tradition, the answer is *why not?* It is important to note
    that a string number is just that. It cannot contain spaces, hyphens, brackets,
    or the plus sign (+); it can only contain numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Moving on...
  prefs: []
  type: TYPE_NORMAL
- en: Sending and receiving a text message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iPhone comes with its own built-in messaging software. However, there are
    some rare times when you need to code a message before sending it. Apple, in its
    wisdom, though, does not allow you to send a message without it going through
    its own message software. This is not to say you can't send a message in another
    way (such as through a dedicated web or message service), but for standard users,
    you can't.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot code in a way that would intercept or block text messages. iOS provides
    no publicly available method to intercept and read a text message. With that in
    mind, sending a text message is a relatively straightforward affair. `MFMessageComposeViewController`
    is in the `MonoTouch.MessageUI` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access to the internet is via the `UIWebView` controller. Prior to trying to
    access an internet site, it's a good idea to ensure there is a live network connection.
    This is preformed via the `NetworkReachability` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WriteLine` command will result in one of the following flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Reachable` | The host is reachable |'
  prefs: []
  type: TYPE_TB
- en: '| `IsWWAN` | Connection is made through EDGE, 3G, or 4G |'
  prefs: []
  type: TYPE_TB
- en: '| `IsLocalDevice` | Connection is made to the local device |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionAutomatic` | Connection is made automatically. This is an alias
    for `ConnectionOnTraffic`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionOnTraffic` | A combination of `Reachable` and when data is requested,
    a connection is made |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionOnDemand` | Occurs when the connection starts. The connection
    occurs once the socket is connected. |'
  prefs: []
  type: TYPE_TB
- en: '| `ConnectionRequired` | The host can be reached, but the connection must be
    made |'
  prefs: []
  type: TYPE_TB
- en: '| `IsDirect` | The connection is made directly |'
  prefs: []
  type: TYPE_TB
- en: '| `InterventionRequired` | When connected to a host, the user must do something
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TransientConnection` | The host can be reached, but through a system which
    starts and stops (such as PPP or any other nonpersistent network connection) |'
  prefs: []
  type: TYPE_TB
- en: Assuming there is a network connection, the next stage is to load the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'I covered loading a web page and some of the settings back in [Chapter 3](../Text/part0022.html#page
    "Chapter 3. Views and Layouts"), *Views and Layouts*. It is also possible to load
    a web page from the data you have dynamically generated. This can be simply demonstrated
    using the following UI with the code. Firstly, set up an application structure
    as shown with `UIWebview` in the `.xib` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Accessing the Internet](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The HTML directory can be named as per your wish. I''ve kept it simple and
    just called it HTML. When generating your own HTML from within your app, you can
    either:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate your own file from scratch, save, and get the output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate your HTML file using `StringBuilder` and output that string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mix the preceding two options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In essence, the two generation methods are the same with the difference of
    generating the string either using `StringBuilder` or concatenate strings. Consider
    the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code should do what you would expect them to, once passed
    to `UIWebview` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While these lines of code do their work, creating your web page based on data
    from within an app using these lines of code can be time consuming. A simpler
    method is to pull the header and footer in from some HTML fragments within the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the files from within the app, though, a couple of steps have to be
    taken. The first is to set the HTML fragments to be built as `BundleResource`.
    You will be loading a file that is part of the bundle rather than a file in the
    app''s writable folder. The second part is to load the HTML bundles into the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`NSBundle.MainBundle.BundlePath` is the path to the installed application.
    The next step is to add the data; in my example, I am adding a league table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The top table section could as easily be its own HTML fragment. Once the final
    append has been made, the HTML is good to go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember, what you're doing is creating your own web page within the application.
    If you want to include stylesheets, you can. If you want to include JavaScript,
    you can; the only caveat is that you can use mobile Safari, which has JavaScript
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Multimedia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very vast topic. Thankfully, using a camera has been covered at the
    start of this chapter. Just about everything you need is inside the `MonoTouch.MediaPlayer`
    namespace. As with using a camera, it is important that you first check that the
    device has video capabilities in exactly the same way as you do for a camera (in
    fact, it uses the same `IsSourceTypeAvailable(myCamera)` command as used for a
    camera).
  prefs: []
  type: TYPE_NORMAL
- en: Playing a video
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with `webView`, a video can be external to the device or internal; if it
    is internal, it could be part of the bundle (not a good idea as video takes up
    a lot of space on a device, which will result in long download times), or within
    the `My Document` area (downloaded), or in the photo reel.
  prefs: []
  type: TYPE_NORMAL
- en: External URL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The video that I'll use here is on YouTube (you can choose any video of your
    choice).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Internal source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Playing from an internal source can be performed in a way similar to that of
    an external video file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: From the photo library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Choosing a video from the camera roll is performed in much the same way as picking
    an image from the photo library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code goes through the photo library looking for any file that
    returns the `public.movie` type. If found, the file is added to the array and
    can be seen via the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a video
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is not substantially different from taking a picture, except that you have
    a few additional parameters that can be altered, such as `VideoQuality` and `AllowEditing`.
  prefs: []
  type: TYPE_NORMAL
- en: To record a video
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Recording a video is a simple task as the following code demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `AllowEditing` has been set to `true`, which means
    that the user may edit this video. If that is the intention, editing should be
    performed using `UIVideoEditorController`. This controller allows for three events:
    `Failed` (the edit failed for some reason), `UserCancelled` (speaks for itself),
    and `Saved` (the user has selected to save the edit; the path is returned in the
    `e.Path` event).'
  prefs: []
  type: TYPE_NORMAL
- en: Saving the video
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the video has been processed, the next step is to save the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The audio system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iPhone and iPad range of devices is blessed (as are most Apple devices)
    with a fantastic audio system that allows for great playback quality and the ability
    to record as well. These facilities are available through the `AVAudioPlayer`
    class or `SystemSound`. If the file is held within the application bundle, it
    must be set to `Content` when building the app.
  prefs: []
  type: TYPE_NORMAL
- en: Playback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Audio playback can be considered short or long if it is under or over the 30
    seconds mark. In general, `SystemSound` is best used for audio files with a duration
    of less than 30 seconds and also for uncompressed audio formats, such as `.wav`
    and `.caf` (**Core Audio File**). MP3 files are not supported in `SystemSound`.
  prefs: []
  type: TYPE_NORMAL
- en: Short files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `SystemSound` method is a quick and easy way to play an audio file with
    very little overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you need an audio file to play but you are at some place requiring silence
    (say, a library), the device can be made to vibrate through the length of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Long (and compressed) files
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here the `AVAudioPlayer` class comes into its own, allowing you to alter power
    levels (the volume on a channel) effectively, pause, play, and stop an audio file.
    It also handles compressed audio formats, such as MP3.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the power levels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Prior to setting a power level, either or both the `AveragePower` and `PeakPower.MeteringEnabled`
    Booleans have to be set to `true` and a method named `UpdateMeters()` must be
    called. It is then just a case of setting `AveragePower(uint)` or `PeakPower(uint)`
    to the value you want (in dBs).
  prefs: []
  type: TYPE_NORMAL
- en: Playing the audio file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is not difficult to play an audio file; select the file and tell the device
    to play. The following code demonstrates how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Altering the volume
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don''t want Beethoven''s ninth blasting out of your iOS device, it''s
    a good idea to turn down the volume as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A word of caution, though, for setting a volume level: *don''t set it to zero*.
    This annoys the iOS device and will then annoy the user as the device will take
    great pleasure in reminding you that the volume is set to `0`. As the figure is
    a float value, `0.01` will do just as well as `0` to mute the device.'
  prefs: []
  type: TYPE_NORMAL
- en: Recording Audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recording is not as simple as playing. While a lot of the work is done by the
    `AVAudioRecorder` class, quite a bit of work also has to be done by the programmer
    to record the audio. The key point to remember is that `NSDictionary` needs to
    be set up before anything can happen. This dictionary contains important information,
    such as the type of audio, sample rate, quality, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the audio NSDictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `NSDictionary` (along with anything else that starts with `NS`) is an interface
    to the `Objective-C` bindings that `Xamarin.iOS` utilizes to allow development
    with the .NET framework on iOS and, as such, can't be set up like a normal dictionary.
    To get around that obstacle, a generic `NSObject` object can be used, one for
    the settings, the other for the description (which works out to be the same as
    the values and keys in .NET).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Setting up to record
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next step is to set up the recorder itself and, importantly, the location
    to save the audio file to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Recording the audio file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, it's time to record. As the file records, it's also saved to the device.
    Once finished with recording, the recorder object needs to be disposed. Thankfully,
    we can control how long a recording goes on by using the `RecordFor("float time")`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is simple enough to use the subsystems that the iOS devices make use of,
    as long as you remember the limitations, such as only being able to send texts
    and not receive. The devices offer far more than what the average user sees and
    it only requires a small amount of imagination to see how to create a really good
    application using the facilities offered to you; from maps to web views to making
    calls, it's all there for you. Now play!
  prefs: []
  type: TYPE_NORMAL
