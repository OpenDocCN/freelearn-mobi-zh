<html><head></head><body><div><h1 class="header-title">Testing</h1>
                
            
            
                
<p class="mce-root">The following recipes will be covered in this chapter:</p>
<ul>
<li style="font-weight: 400">Unit testing Kotlin code</li>
</ul>
<ul>
<li style="font-weight: 400">Unit testing with Mockito</li>
</ul>
<ul>
<li style="font-weight: 400">Running Instrumentation tests</li>
</ul>
<ul>
<li style="font-weight: 400">Writing JUnit rules in Kotlin (@Rule)</li>
</ul>
<ul>
<li style="font-weight: 400">Acceptance tests using Espresso Kotlin</li>
</ul>
<ul>
<li style="font-weight: 400">Writing assertEquals in Kotlin</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Testing is a fundamental part of software engineering if you want your code base to be scalable and maintainable. In Android, there are basically two types of testing: one is <strong>unit testing</strong> and the other is <strong>integrated testing</strong>. Unit testing is a type of testing where individual units are tested independently, while integrated testing, which is also sometimes known as instrumentation testing, requires an Android device or an emulator for the tests to run. Since integrated testing requires real devices or an emulator, these tests are often slower to execute. Unit tests are fast because they don’t have any such need for real devices or emulators in order to run. Since unit tests are faster and instrumentation tests are slower, it is often thought that a robust test suite should have these tests in the proportion of 80% to 20%. So your code base should consist of 80% unit tests and 20% instrumentation tests.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Unit testing Kotlin code</h1>
                
            
            
                
<p>Unit tests involve, basically, <em>testing in units</em>. These tests are often faster to execute because they are executed in the JVM, and hence do not require the dexing, packaging, and installing-on-the-emulator steps, reducing test cycles from minutes to seconds so that you can quickly iterate and refactor your code. Integration tests, on the other hand, require all the aforementioned steps. Apart from testing your code, unit tests also work as a great documentation of the code base. That's why it shouldn't surprise you if you see the names of methods phrased in odd ways—for example, <kbd>testIfConfirmationEmailIsSent</kbd>.</p>
<p>In this recipe, we will learn how to write unit tests for your Android code.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You’ll need Android Studio, as we will learn to write unit tests for Android code, and also because Android Studio provides great support for unit tests. You can also find the source code at <a href="https://gitlab.com/aanandshekharroy/Anko-examples" target="_blank">https://gitlab.com/aanandshekharroy/Anko-examples</a> in the 4-unit-tests branch.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Follow these steps to understand how to write unit tests for Android code in the Kotlin language:</p>
<ol>
<li>When you create a new Android project in Android Studio, Android Studio will provide support for both unit and Android tests. It provides you with separate directories where you can place your test. Take a look at the following screenshot:</li>
</ol>
<div><img height="199" width="366" src="img/bfa262d7-f272-4c9f-b64b-e85ffe7ae866.png"/></div>
<p style="padding-left: 60px">As you can see, test is where <em>unit tests</em> are placed and androidTest is where <em>Android tests</em> or <em>instrumentation tests</em> are placed.</p>
<ol start="2">
<li>There are two demo tests provided to you already: ExampleUnitTest and ExampleInstrumentedTest. To run them, just right-click on ExampleUnitTest and click on Run ExampleUnitTest. After running the tests, you can see the results of the tests in the console, as seen in the following screenshot:</li>
</ol>
<div><img src="img/85dbdee5-2048-4da5-9d8b-84d8677c3d52.png" width="1233" height="220"/></div>
<p>Now, let’s try creating our own unit test:</p>
<ol>
<li>We usually have the <kbd>Utility</kbd> class in our code, which has methods that can be used by any class, so instead of defining those methods in every class, we define them in the <kbd>Utility</kbd> class. So let’s create a method, <kbd>addTwoNumbers</kbd>, which will take two parameters, <kbd>a</kbd> and <kbd>b</kbd>, and return a result—<kbd>a+b</kbd>:</li>
</ol>
<pre style="padding-left: 60px">class Utility {<br/>  companion object {<br/>      fun addTwoNumbers(a:Int, b:Int):Int=a+b<br/>  }<br/>}</pre>
<ol start="2">
<li>In Android Studio, you can create tests directly from the class itself. Just right-click on the class name and click on Create test:</li>
</ol>
<div><img src="img/9c9e10f0-d047-42be-a12a-4ecd57878b30.png" width="1366" height="768"/></div>
<ol start="3">
<li>After that, you will be shown a dialog on which you can select all the methods for which you want to create a test. It is recommended that you have tests for every method:</li>
</ol>
<div><img height="545" width="466" src="img/18f873bc-d633-45c0-833e-dca9ff3e0950.png"/></div>
<ol start="4">
<li>When you click on OK, you will be shown another dialog box that will ask you where to place your tests. In this case, this is a unit test, so we will place it in <kbd>app/src/test…</kbd>:</li>
</ol>
<div><img src="img/390fa1db-e2fc-434d-ad77-48d1afcead43.png" width="1366" height="768"/></div>
<ol start="5">
<li>When you click on OK, Android Studio autogenerates boilerplate code in <kbd>UtilityTest.kt</kbd>, which looks like this:</li>
</ol>
<div><img src="img/90515872-8af2-4d12-957e-44ab5d7f1d91.png" width="899" height="179"/></div>
<ol start="6">
<li>Now we will add a few <kbd>assertEquals</kbd> statements, which check the expected value against the results:</li>
</ol>
<pre style="padding-left: 60px">class UtilityTest {<br/>  @Test<br/>  fun addTwoNumbers() {<br/>      assertEquals(5,Utility.addTwoNumbers(2,3))<br/>      assertEquals(5,Utility.addTwoNumbers(4,1))<br/>      assertNotEquals(5,Utility.addTwoNumbers(2,5))<br/>  }<br/>}</pre>
<p>The first argument is the expected value and the second argument is the output of the function. If you run the test, it will pass.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">When you run the unit tests, they test all the methods that have the <kbd>@Test</kbd> notation above them. There is also a <kbd>@Before</kbd> notation, which is placed above a method. The method with the <kbd>@Before</kbd> notation is run before any other method of the class. This can be helpful when you are setting up objects and variables that might be used later.</p>
<p>One thing to note here is that unit tests cannot use Android SDK components. To use those components, you need instrumentation tests, or use a mocking framework like <strong>Mockito</strong>, which mocks the Android components so that it can be used unit tests. We will cover this in the next recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Unit testing with Mockito</h1>
                
            
            
                
<p>As we discussed in the previous recipe, we cannot use Android components in unit tests. This is why we are able to run them faster, and without any device. If you want to use Android components in your tests, there are two options:</p>
<ul>
<li>Write integration tests, which run on your device or emulator.</li>
<li>Use a mocking framework, such as Mockito, which basically mocks the Android SDK components so that you can use them without any device or emulator, just like any other unit test. The benefit of a mocking framework is that it takes a lot less time to run the tests, as the tests are basically unit tests only. Here's an accurate definition of a mock object by Vogella:</li>
</ul>
<p>"A <em>mock object</em> is a dummy implementation for an interface or a class in which you define the output of certain method calls. Mock objects are configured to perform a certain behavior during a test. They typical record the interaction with the system and test can validate that."</p>
<p>With that in mind, let's try using Mockito to write unit tests.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>You’ll need Android Studio, as it provides great support for unit tests, and we will also be learning to write the unit tests for Android code.</p>
<p>You can also find the source code at <a href="https://gitlab.com/aanandshekharroy/Anko-examples">https://gitlab.com/aanandshekharroy/Anko-examples</a> in the 4-unit-tests branch.</p>
<p>First, you need to add the Mockito dependency to your project. You can do so by adding the following line in your <kbd>build.gradle</kbd> file at the app level:</p>
<pre>testImplementation 'org.mockito:mockito-core:2.8.47'<br/></pre>
<p class="mce-root">Once you have added the dependency, you are good to go ahead.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>We usually use Mockito to mock Android classes, but let's test a simple class using Mockito:</p>
<ol>
<li>Here's a small test that tests a <kbd>functionUnderTest</kbd> function of the <kbd>Utility</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">@Test<br/>fun test_functionUnderTest(){<br/>    val classUnderTest= mock(Utility::class.java)<br/>    classUnderTest.functionUnderTest()<br/>    verify(classUnderTest).functionUnderTest()<br/>}</pre>
<ol start="2">
<li>In the preceding class, we are calling the <kbd>functionUnderTest</kbd> method and then verifying whether the method has been called or not. (Yeah!, not a very good use case of a test, but let's try to run this test) When you run it, you'll see an error like this:</li>
</ol>
<pre style="padding-left: 60px"><strong>org.mockito.exceptions.base.MockitoException: </strong><br/><strong>Cannot mock/spy class com.ankoexamples.app.Utility</strong><br/><strong>Mockito cannot mock/spy because :</strong><br/><strong> - final class</strong></pre>
<ol start="3">
<li>The reason for the preceding error is that every class is final by default in Kotlin. You need to <em>open</em> them if you want to extend or mock them. However, does that mean that you need to add open modifier to every class that you want to test? That sounds like a bad idea, and it is. There is a hack around this problem. The hack is to manually add the option of mocking the final class. You need to create a file in <kbd>test/resources/mockito-extensions folder called org.mockito.plugins.MockMaker</kbd><em> </em>and put the following code into that file:</li>
</ol>
<pre style="padding-left: 60px" class="graf graf--pre graf-after--p">mock-maker-inline</pre>
<p style="padding-left: 60px">Now if you run the code, it will pass smoothly.</p>
<ol start="4">
<li>There are many variants of the <kbd>verify</kbd> method, such as the following:
<ul>
<li><kbd>verify(classUnderTest, never()).functionUnderTest()</kbd>, which tests whether it isn't ever called</li>
<li><kbd>atLeastOnce()</kbd>, <kbd>atLeast(2)</kbd>, <kbd>times(5)</kbd>, <kbd>atMost(3)</kbd>, which can also be used to verify the number of interactions with the method</li>
</ul>
</li>
</ol>
<ol start="5">
<li>Let's see another Mockito test that mocks <kbd>SharedPreferences</kbd> (an Android component):</li>
</ol>
<pre style="padding-left: 60px">@Test<br/>fun testSharedPreference(){<br/>    val sharedPreferences=mock(SharedPreferences::class.java)<br/>    `when`(sharedPreferences.getInt("random_int",-1)).thenReturn(1)<br/>    assertEquals(sharedPreferences.getInt("random_int",-1),1)<br/>}</pre>
<p style="padding-left: 60px">The <kbd>when(...).thenReturn(...)</kbd> construct keeps an eye on the object, and when the method inside the <kbd>when</kbd> construct is called, it returns the value under the <kbd>thenReturn</kbd> construct. Note the <kbd>``</kbd> surrounding <kbd>when</kbd>; this is because <kbd>when</kbd> is a reserved keyword in Kotlin, so we call it with back ticks.</p>
<ol start="6">
<li>You can also return multiple values, which simulates calling a method multiple times:</li>
</ol>
<pre style="padding-left: 60px">@Test<br/>fun testSharedPreference(){<br/>    val sharedPreferences=mock(SharedPreferences::class.java)<br/>    `when`(sharedPreferences.getInt("random_int",-1)).thenReturn(1).thenReturn(2)<br/>    assertEquals(sharedPreferences.getInt("random_int",-1),1)<br/>    assertEquals(sharedPreferences.getInt("random_int",-1),2)<br/>}</pre>
<p>In the preceding example, the first call to the <kbd>getInt</kbd> method will return <kbd>1</kbd>, and the second call will return <kbd>2</kbd>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>Let's understand a <kbd>spy</kbd> object in unit testing.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Spy object</h1>
                
            
            
                
<p>The mocking framework also provides a <kbd>spy</kbd> method that can be used to wrap the real objects. The calls to the spy objects are delegated to the real object. What's the use of that, you might be thinking. It can check the interactions on a real object, which wasn't possible if the object is not mocked. Let's take a look at the following example:</p>
<pre>@Test<br/>fun testSpyObject(){<br/>    val list = List(2,init = {-1})<br/>    val spy= spy(list)<br/>    assertEquals(spy.get(0),-1)<br/>    verify(spy).get(0)<br/>}</pre>
<p class="mce-root">The preceding test will pass.</p>
<p class="mce-root">Note that calling <kbd>spy.get(0)</kbd> returns <kbd>-1</kbd>, which is equal to what you'd get if you had interacted with the real object. Furthermore, you are also able to verify the interaction.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Mockito limitations</h1>
                
            
            
                
<p>Mockito has certain limitations—for example, you cannot mock <kbd>static</kbd> and <kbd>private</kbd> methods. This is out of the scope of this book, so to know more about the Mockito limitations, visit <a href="https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito">https://github.com/mockito/mockito/wiki/FAQ#what-are-the-limitations-of-mockito</a>.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Running instrumentation tests</h1>
                
            
            
                
<p>In the preceding recipes, we learned how to run and write unit tests. In this recipe, we will learn how to run instrumentation tests. The integration tests are placed under the androidTest directory in your Android project.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Since instrumentation tests require real devices or emulators to run on, ensure that you have one of either of these. We'll be using Android Studio 3.0 for our coding purposes. You can download the source code from <a href="https://gitlab.com/aanandshekharroy/Anko-examples">https://gitlab.com/aanandshekharroy/Anko-examples</a> and switch to the <kbd>5-instrumentation-tests</kbd> branch. We will also be using <em>Espresso</em> for writing instrumentation tests as it is the easiest software to use. Espresso is automatically included in your project when you create a new project.</p>
<div><strong>Espresso</strong> is targeted at developers who believe that automated testing is an integral part of the development lifecycle. While it can be used for black-box testing, Espresso's full power is unlocked by those who are familiar with the code base under test.</div>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In the following steps, you will learn how to run instrumentation tests:</p>
<ol>
<li>Let's create a simple app, which will just have the Hello World! text and a button:</li>
</ol>
<div><img height="1280" width="720" src="img/114c123e-0d88-4a8e-ab7b-b23e5068c5d2.jpeg"/></div>
<ol start="2">
<li>On clicking the button, the text will change to Goodbye World!:</li>
</ol>
<div><img height="1280" width="720" src="img/e55b5e1c-5aa0-45a6-82e8-555cae505e5e.jpeg"/></div>
<ol start="3">
<li>Now, let's write a test to verify this behavior.</li>
</ol>
<p>In this recipe, we will learn how to run the espresso test; in the next recipe, we will learn how to write an espresso test, so just bear with me until I explain how to write an espresso test in the later recipe because it is complicated and needs an entire recipe to do justice to it.</p>
<p style="padding-left: 60px">Here's an espresso test:</p>
<pre style="padding-left: 60px">class MainActivityTest {<br/>    @Rule<br/>    @JvmField var activityRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule(MainActivity::class.java)<br/><br/>    @Test<br/>    fun testButtonBehaviour() {<br/>        onView(withText("Hello World!"))<br/>                .check(matches(isDisplayed()))<br/>        onView(withId(button)).perform(click())<br/>        onView(withText("Goodbye World!"))<br/>                .check(matches(isDisplayed()))<br/><br/>    }<br/><br/>}</pre>
<p style="padding-left: 60px">In the first line of the <kbd>testButtonBehaviour</kbd> method, we are checking whether Hello World! is appearing on screen. Then, we are performing a click operation on the button and finally checking whether Goodbye World! is appearing on the screen.</p>
<ol start="4">
<li>To run the preceding test, just right-click on the test class and select Run MainActivityTest:</li>
</ol>
<div><img src="img/5eedabc6-eeea-4134-b0be-7296bdfb5797.png" width="1275" height="568"/></div>
<ol start="5">
<li>Once you select that option, you'll be shown a dialog box that will ask which device you want to run the test on. You can either choose a real device or an emulator.</li>
<li>After that, you can see your tests running on your device (you will see the steps written in the code being performed on the device).</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>If you run any instrumentation test, you'll note that it takes a lot of time to pass, even if it's a small test. In the current scenario, <strong>test-driven development </strong>(<strong>TDD</strong>) is becoming more and more popular, but its tests take a lot of time to execute; it's not a good way of using TDD. So the number of instrumentation tests should be kept to a minimum, and it's better to use a mocking framework, such as Mockito or Robolectric.</p>
<p>Wikipedia says that TDD<strong> </strong>is a software development process that relies on the repetition of a very short development cycle: Requirements are turned into very specific test cases, and then the software is improved to pass the new tests only.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing JUnit rules in Kotlin (@Rule)</h1>
                
            
            
                
<p>Rules are a way to add functionalities that apply to all tests of the class. For example, <kbd>ExternalResource</kbd> executes the code before and after a test method. This can be used to set up a database, network, and filesystem connection before the test method, and can tear them down when the tests are complete. Of course, you can also do it using the <kbd>@Before</kbd> and <kbd>@After</kbd> annotations, but doing it with <kbd>ExternalResource</kbd> (as a JUnit rule) helps with code reuse.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>I'll be using Android Studio 3.0 for coding.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In this recipe, we will be using <kbd>ExpectedException</kbd> as the JUnit rule because it helps the test declare that an exception is expected and also provides a way to clearly express the expected behavior. It is much more flexible than using the <kbd>@Test(expected= ...)</kbd> annotation because we can test specific error messages and custom fields.</p>
<p>In the following steps, we will learn how to write JUnit tests:</p>
<ol>
<li>Let's first create a simple method that throws an exception. We will then write a test to test this method:</li>
</ol>
<pre style="padding-left: 60px">fun methodThrowsException() {<br/>    throw IllegalArgumentException("Age must be integer")<br/>}</pre>
<ol start="2">
<li>Now, let's create a new rule of the <kbd>ExpectedException</kbd> class and write a test:</li>
</ol>
<pre style="padding-left: 60px">@Rule<br/>var thrown = ExpectedException.none()<br/><br/>@Test<br/>fun testExceptionFlow() {<br/>    thrown.expect(IllegalArgumentException::class.java)<br/>    thrown.expectMessage("Age must be integer")<br/>    Utility.methodThrowsException()<br/>}</pre>
<ol start="3">
<li>If you run the preceding code, you will get an error:</li>
</ol>
<pre style="padding-left: 60px">org.junit.internal.runners.rules.ValidationError: The @Rule 'thrown' must be public.</pre>
<ol start="4">
<li>The error is because JUnit allows the provision of rules through a test class field or a getter method. However, we don't have fields in Kotlin—we have properties; so what you've really annotated here is a property, not a field.</li>
<li>The easiest way around this problem is by adding the <kbd>@JvmField</kbd> annotation with <kbd>@Rule</kbd>:</li>
</ol>
<pre style="padding-left: 60px">@Rule @JvmField<br/>var thrown = ExpectedException.none()</pre>
<ol start="6">
<li>If you run the test now, it will pass.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works…</h1>
                
            
            
                
<p>We are aware of the fact that Kotlin plays with properties rather than fields in Java. However, to provide compatibility with the Java language, <kbd>@JvmField</kbd> can be used to instruct the Kotlin compiler not to generate getters–setters for this property and expose it as a field.</p>
<p>However, there are a few restrictions when using annotations. We can't use them with the following:</p>
<ul>
<li>Private properties</li>
<li>Properties with <kbd>open</kbd>, <kbd>override</kbd>, and <kbd>const</kbd> modifiers</li>
<li>Delegated properties</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Acceptance tests using Espresso Kotlin</h1>
                
            
            
                
<p>Espresso is the most popular UI testing framework for Android. It was released by Google in 2013 and is the easiest to use of its kind. It provides support for complex things, such as ensuring that an activity is run before the tests are run, or waiting till the observed background tasks are completed. These things were hard to synchronize prior to Espresso, and UI testing was considered a difficult thing to do.</p>
<p>In this recipe, we will learn how to use Espresso to perform acceptance testing.</p>
<div><strong>Acceptance testing</strong> is a level of software testing where a system is tested for acceptability. The purpose of this test is to evaluate the system's compliance with the business requirements and assess whether it is acceptable for delivery.<br/>
Source: <a href="http://softwaretestingfundamentals.com/">http://softwaretestingfundamentals.com/</a></div>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll be using Android Studio 3.0 for our coding purposes. You can download the source code from <a href="https://gitlab.com/aanandshekharroy/Anko-examples">https://gitlab.com/aanandshekharroy/Anko-examples</a> and switch to the 5-instrumentation-tests branch.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>In Espresso, we mainly have three components:</p>
<ul>
<li>
<p><kbd>ViewMatchers</kbd>: Allows you to find a view in the current view hierarchy. This can be done in various ways, such as searching by <kbd>id</kbd>, <kbd>name</kbd>, <kbd>child</kbd>, and so on. You can also use Hamcrest matchers, such as <kbd>containsString</kbd>.</p>
</li>
<li>
<p><kbd>ViewActions</kbd>: Allows you to perform actions on the views, such as clicking, typing, clearing text, and so on.</p>
</li>
<li>
<p><kbd>ViewAssertions</kbd>: Allows you to assert the state of a view that checks whether the condition under the view assertion passes.</p>
</li>
</ul>
<p class="mce-root">Let's take a look at the following steps to understand acceptance testing using Espresso:</p>
<ol>
<li>Here's an example of a text matcher (a text matcher matches the text; it's a part of <kbd>ViewMatchers</kbd>):</li>
</ol>
<pre style="padding-left: 60px">onView(withId(R.id.textView)).check(matches(withText(not(containsString("Hello")))));</pre>
<ol start="2">
<li>Now we will create a simple test that will test whether clicking on the button changes the text from Hello World! to Goodbye World!:</li>
</ol>
<div><img src="img/4094ebc1-c715-467b-a742-8161a5712f4c.png" width="1514" height="1326"/></div>
<ol start="3">
<li>The following is an espresso test written to test the preceding functionality:</li>
</ol>
<pre style="padding-left: 60px">class MainActivityTest {<br/>    @Rule<br/>    @JvmField var activityRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule(MainActivity::class.java)<br/><br/>    @Test<br/>    fun testButtonBehaviour() {<br/>        // Testing if the text is initially Hello World!        <br/>        onView(withText("Hello World!"))<br/>                .check(matches(isDisplayed()))<br/>        onView(withId(button)).perform(click())<br/>        // Testing if the text is initially Goodbye World!<br/>        onView(withText("Goodbye World!"))<br/>                .check(matches(isDisplayed()))<br/><br/>    }<br/><br/>}</pre>
<ol start="4">
<li>In the first line, we have created a rule that provides functional testing of a single activity. This will open the activity before the tests are run and close it once the tests are completed. The statements in the <kbd>testButtonBehaviour</kbd> method check the UI conditions, such as whether the text is initially Hello World! (first condition), then performs a click action on the button, and then finally checks whether the text is now Goodbye World!.</li>
<li>You can also get hold of the "God" object—that is, <kbd>Context</kbd>—using the instrumentation API:</li>
</ol>
<pre style="padding-left: 60px">var targetContext:Context = InstrumentationRegistry.getTargetContext()</pre>
<ol start="6">
<li>If you want to start the activity from the intent, you just need to provide <kbd>false</kbd> as the third argument in the constructor of <kbd>ActivityTestRule</kbd>; it can be used as shown:</li>
</ol>
<pre style="padding-left: 60px">@Rule<br/>@JvmField var intentActivityRule: ActivityTestRule&lt;MainActivity&gt; = ActivityTestRule(MainActivity::class.java,true,false)<br/><br/>@Test<br/>fun testIntentLaunch(){<br/>    val intent = Intent()<br/>    intentActivityRule.launchActivity(intent)<br/>    onView(withText("Hello World!"))<br/>            .check(matches(isDisplayed()))<br/>}</pre>
<p>Another cool feature of Espresso is to record the interactions using <strong>Record Espresso Test</strong>. This records all the interactions that you make with the app, and can generate tests from it. To use that feature, follow these steps:</p>
<ol>
<li>Go to Run on the toolbar and select Record Espresso Test:</li>
</ol>
<div><img src="img/5a560a97-496a-457d-9b3d-578e7b0a74c1.png" width="771" height="420"/></div>
<ol start="2">
<li>It will then open a dialog, on which you can see the recorded steps:</li>
</ol>
<div><img height="694" width="471" src="img/15f66e1f-49b8-4dd4-b7cc-588b73ddf575.png"/></div>
<ol start="3">
<li>Clicking on OK will automatically generate the tests based on your interaction.</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more…</h1>
                
            
            
                
<p>Note that we have used the <kbd>@JvmField</kbd> annotation with the rule. The reason for this is extensively discussed in the <em>How to write JUnit rules in Kotlin (@Rule)</em> recipe.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing assertEquals in Kotlin</h1>
                
            
            
                
<p>The <kbd>assertEquals</kbd> statement is widely used for testing code. It basically takes in two arguments—an expected value and an actual value—with an optional third argument message. If the expected value matches the actual value, the <kbd>assertEquals</kbd> passes—otherwise, it fails.</p>
<p>Using <kbd>assertEquals</kbd> with primitive types is straightforward, but if you want to use it with a custom object, you'll have to do a little more work. For example, the following <kbd>assertEquals</kbd> will not pass:</p>
<pre>assertEquals(MyObj("abc"),MyObj("abc"))</pre>
<p>In this recipe, we will learn how to write <kbd>assertEquals</kbd> statements.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll be using Android Studio 3.0 for our coding purposes. You can download the source code from <a href="https://gitlab.com/aanandshekharroy/Anko-examples">https://gitlab.com/aanandshekharroy/Anko-examples</a> and switch to the <kbd>5-instrumentation-tests</kbd> branch.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it…</h1>
                
            
            
                
<p>Let's go through the following steps to understand <kbd>assertEquals</kbd>:</p>
<ol>
<li>In the following code, if you run the given <kbd>assertEquals</kbd>, it will not pass:</li>
</ol>
<pre style="padding-left: 60px">assertEquals(MyObj("abc"),MyObj("abc"))</pre>
<ol start="2">
<li>If you check the difference, it will tell you that they aren't equal because they are two different objects:</li>
</ol>
<div><img src="img/febf47ed-5421-4289-a13a-ba0b6756b9d1.png" width="973" height="105"/></div>
<ol start="3">
<li>So we will need to override the <kbd>equals</kbd> method of the <kbd>MyObj</kbd> class, and we will check the following things:
<ul>
<li>Whether the other object references the same object—this can be done using the <kbd>===</kbd> operator, which checks the referential equality</li>
<li>Whether the object in question equals the other object's Java class</li>
<li>Whether the content of both objects is the same:</li>
</ul>
</li>
</ol>
<pre style="padding-left: 120px">override fun equals(other: Any?): Boolean {<br/>    if (this === other) return true<br/>    if (other?.javaClass != javaClass) return false<br/>    other as MyObj<br/><br/>    if (name != other.name) return false<br/><br/>    return true<br/>}</pre>
<p>Now, when you run <kbd>assertEquals</kbd> with two objects of the same content, it will pass smoothly.</p>


            

            
        
    </div>



  </body></html>