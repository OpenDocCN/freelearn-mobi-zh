- en: Chapter 5. Asset Bundles in Unity 5 Pro
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. Unity 5 Pro中的资产包
- en: This chapter will include an overview of Asset Bundles in Unity 5\. You will
    learn how to download new code and data in real time for Android devices. At the
    end of this chapter, the reader will discover the safeness technique of the asset
    bundles in practice.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将包括Unity 5中资产包的概述。您将学习如何为Android设备实时下载新代码和数据。在本章结束时，读者将发现资产包在实践中的安全性技术。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Overview of Asset Bundles in Unity 5
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 5中资产包概述
- en: Downloading new code and data in real time for Android devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Android设备实时下载新代码和数据
- en: Safeness techniques in practice
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实践中的安全性技术
- en: An overview of the asset bundles in Unity 5
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 5中资产包概述
- en: 'Asset bundles are **Unity Pro** features only. Two main ideas of the asset
    bundles are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 资产包是**Unity Pro**特有的功能。资产包的两个主要思想是：
- en: Easily download content in your application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中轻松下载内容
- en: Uploading new content in your application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中上传新内容
- en: 'Unity allows exporting your assets as files, which are known as asset bundles.
    Your application can download these compressed files whenever needed. This approach
    will reduce your final build size by streaming in: prefabs, animations, binary
    files, textures, audio clips, meshes, and scenes, where asset bundles will be
    utilized. All other asset types are supported by Unity. For binary files, you
    should set the extension to `.bytes` and Unity will recognize these files as `TextAsset`.
    To use asset bundles, you just need to create them and upload them to your server.
    In the Unity Editor, you can build asset bundles from your assets in the scene.
    In a situation when you need to upload your asset bundles to the server, you can
    use any data communication protocol; for example, SSH, FTP, FTPS, SFTP, or any
    other protocol depending on your choice. In real time, your application, which
    is written in your script, will download the necessary asset bundles for further
    work with your packed assets in these exported files.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Unity允许将您的资产导出为文件，这些文件被称为资产包。您的应用程序可以在需要时下载这些压缩文件。这种方法将通过流式传输以下内容来减少最终构建大小：预制体、动画、二进制文件、纹理、音频剪辑、网格和场景，其中将使用资产包。Unity支持所有其他资产类型。对于二进制文件，您应将扩展名设置为`.bytes`，Unity将识别这些文件为`TextAsset`。要使用资产包，您只需创建它们并将它们上传到您的服务器。在Unity编辑器中，您可以从场景中的资产构建资产包。在需要将您的资产包上传到服务器的情况下，您可以使用任何数据通信协议；例如，SSH、FTP、FTPS、SFTP或任何其他协议，具体取决于您的选择。在实时情况下，您在脚本中编写的应用程序将下载必要的资产包，以便进一步处理这些导出文件中的打包资产。
- en: We will cover what you should do to create the `AssetBundle` file. For this
    task, you should use the Unity Editor class known as `BuildPipeline`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍您应该做什么来创建`AssetBundle`文件。为此任务，您应使用名为`BuildPipeline`的Unity编辑器类。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using any of the Unity Editor classes in your scripts, then you should
    always remember to keep these scripts in a folder named `Editor` anywhere in your
    project within any subdirectory of the `Assets` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在脚本中使用任何Unity编辑器类，那么您应该始终记住将这些脚本保存在名为`Editor`的文件夹中，该文件夹位于项目中的任何子目录的`Assets`文件夹内。
- en: 'Now, let''s create a simple C# script to create `AssetBundle`. First of all,
    we should import two Unity namespaces:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个简单的C#脚本以创建`AssetBundle`。首先，我们应该导入两个Unity命名空间：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After these lines of code, you should declare your public class; for example,
    you can create very simple class declaration:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码行之后，您应该声明您的公共类；例如，您可以创建一个非常简单的类声明：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the next step, we will create a static function with its `MenuItem` for
    future selection from the Unity Editor menu:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将创建一个具有`MenuItem`的静态函数，以便将来从Unity编辑器菜单中选择：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, you need to fill in your static function with just a single instruction
    or line of code or something similar depending on your requirements, and you will
    see the already finished simple class to build your `AssetBundle`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要用单个指令或一行代码或类似的内容填充您的静态函数，根据您的需求，您将看到已经完成的简单类来构建您的`AssetBundle`：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function creates a compressed `Assets/Your/Path/To/YourAssetBundle.unity3d`
    file with a list of packed assets (any from your project folder) and returns `true`
    if `AssetBundle` was created successfully or `false` otherwise. The first variable
    in this function, `Selection.activeObject`, indicates which object to use for
    retrieving packed assets from `AssetBundle` using the `AssetBundle.mainAsset`
    property. You can set this value to `null` if you are not using it. The second
    variable is `array Object[]` and specifies which assets you need to pack. The
    third variable is very simple, and it is just a location where you want to save
    your `AssetBundle` file. By specifically adjusting `BuildAssetBundleOptions` flags,
    you can dictate to include all dependencies automatically or only include complete
    assets. Furthermore, with these options, you can specify that you don''t want
    your assets to be compressed in the `AssetBundle` file by setting up the `UncompressedAssetBundle`
    flag. If you want, you can check the `CRC` checksum of your asset bundles while
    downloading your exported files via the `WWW.LoadFromCacheOrDownload` call. To
    create asset bundles, you can use three different functions:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个压缩的`Assets/Your/Path/To/YourAssetBundle.unity3d`文件，其中包含打包的资产列表（来自项目文件夹中的任何资产），如果`AssetBundle`创建成功则返回`true`，否则返回`false`。此函数的第一个变量`Selection.activeObject`指示要使用哪个对象来从`AssetBundle`中检索打包的资产，使用`AssetBundle.mainAsset`属性。如果你不使用它，可以将此值设置为`null`。第二个变量是`array
    Object[]`，指定需要打包的资产。第三个变量非常简单，它只是你想要保存`AssetBundle`文件的位置。通过具体调整`BuildAssetBundleOptions`标志，你可以指定自动包含所有依赖项或仅包含完整资产。此外，使用这些选项，你可以通过设置`UncompressedAssetBundle`标志来指定你不想在`AssetBundle`文件中压缩资产。如果你想，你可以在通过`WWW.LoadFromCacheOrDownload`调用下载导出的文件时检查你的资产包的`CRC`校验和。要创建资产包，你可以使用三个不同的函数：
- en: '`BuildPipeline.BuildAssetBundle`: This will build any asset type.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildPipeline.BuildAssetBundle`：这将构建任何类型的资产。'
- en: '`BuildPipeline.BuildStreamedSceneAssetBundle`: This will include only scenes.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildPipeline.BuildStreamedSceneAssetBundle`：这将仅包含场景。'
- en: '`BuildPipeline.BuildAssetBundleExplicitAssetNames`: This is similar to `BuildPipeline.BuildAssetBundle`,
    but with a little difference. In this function, you can indicate your string identifier
    for all included objects.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildPipeline.BuildAssetBundleExplicitAssetNames`：这个函数与`BuildPipeline.BuildAssetBundle`类似，但有一些区别。在这个函数中，你可以指定所有包含对象的字符串标识符。'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can create the asset bundles for the Web-Player platform and use them in
    a standalone platform and vice versa. Alternatively, for mobile platforms, you
    can use only their built files. For example, you can create the asset bundles
    for Android devices and use them only for Android platforms, but you cannot use
    them for iOS platforms and vice versa. With built files for the iOS platform,
    you can use them only within iOS boundaries.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为Web-Player平台创建资产包并在独立平台上使用它们，反之亦然。或者，对于移动平台，你可以仅使用它们的构建文件。例如，你可以为Android设备创建资产包并仅用于Android平台，但不能用于iOS平台，反之亦然。对于iOS平台的构建文件，你只能在其内部使用。
- en: 'In order to use your class to create the asset bundle, you need to do two simple
    steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用你的类来创建资产包，你需要进行两个简单的步骤：
- en: You should select one single or many assets in your project, which will be packed
    into your `AssetBundle`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在项目中选择一个或多个资产，这些资产将被打包到你的`AssetBundle`中。
- en: From the Unity menu, you should navigate to **PacktPub** | **AssetBundles**
    | **Build Asset Bundle**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity菜单中，你应该导航到**PacktPub** | **AssetBundles** | **Build Asset Bundle**。
- en: 'The finished script to create `AssetBundle` should be similar to the code shown
    here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`AssetBundle`的完成脚本应类似于以下代码所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We''ve realized the asset bundles creation, now let''s explore how to use them
    from your scripts. To use your asset bundles, you should follow the next two simple
    steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了资产包的创建，现在让我们探索如何在脚本中使用它们。要使用你的资产包，你应该遵循以下两个简单的步骤：
- en: Download your `AssetBundle` files from any local storage like hard drive or
    remote storage like any web-server, Unity provides the `WWW` helper class for
    such issues.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从任何本地存储（如硬盘）或远程存储（如任何Web服务器）下载你的`AssetBundle`文件，Unity提供了`WWW`辅助类来处理此类问题。
- en: Load or, in other words, unpack your assets from your `AssetBundle` files in
    order to use them further in your game.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载，或者说，从你的`AssetBundle`文件中解包你的资产，以便在游戏中进一步使用。
- en: 'In the following code, we intend to understand the case of using `AssetBundle`.
    First of all, we need to create a simple C# script and name it, for example, `ImporterAssetBundle`.
    Open the script in your code editor and change it as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们打算了解使用`AssetBundle`的情况。首先，我们需要创建一个简单的C#脚本，例如命名为`ImporterAssetBundle`。在代码编辑器中打开脚本，并按以下所示进行更改：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Attach this script as a component to your GameObject. The URL in this script
    is just for example, so you should set your own URL for your `AssetBundle` file.
    Based on this version, Unity's caching system will decide whether to download
    your file or not. If this file was already cached with the same version number,
    then Unity will speed up your application. In this script, we called `Import`
    co-routine in the `Start` event, but you can call this function anywhere you need
    and as often as you want. In `Import` co-routine, we first used `WWW.LoadFromCacheOrDownload`
    with the sole purpose of loading the required `AssetBundle` file by given the
    URL path and the version number. During the downloading process, Unity will not
    execute the next instructions from the `yield return www` command. Only after
    the download is complete will Unity run the next commands in our co-routine example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将此脚本作为组件附加到你的GameObject上。此脚本中的URL仅作为示例，因此你应该设置你自己的`AssetBundle`文件URL。基于这个版本，Unity的缓存系统将决定是否下载你的文件。如果此文件已经以相同的版本号缓存，那么Unity将加快你的应用程序的速度。在这个脚本中，我们在`Start`事件中调用了`Import`协程，但你可以在需要的地方调用此函数，并且可以按需多次调用。在`Import`协程中，我们首先使用`WWW.LoadFromCacheOrDownload`，其唯一目的是通过提供URL路径和版本号来加载所需的`AssetBundle`文件。在下载过程中，Unity将不会执行`yield
    return www`命令之后的指令。只有当下载完成后，Unity才会运行我们协程示例中的下一个命令。
- en: Using the `www` instance to retrieve `mainAsset` as a GameObject instance from
    the downloaded `AssetBundle`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`www`实例从下载的`AssetBundle`中检索`mainAsset`作为GameObject实例
- en: Creating a new instance in real time in the current scene of the retrieved `GameObject`
    instance
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在当前场景中实时创建检索到的`GameObject`实例的新实例
- en: Unloading all the memory used for this **AssetBundle** (for increasing the performance).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卸载用于此**AssetBundle**的所有内存（以提高性能）。
- en: 'As making projects is an iterative procedure, you will probably alter your
    assets not once but multiple times, which may oblige remaking the asset bundles
    after every change to have the capacity to test them. Despite the fact that it
    is conceivable to load the asset bundles in the Unity editor, it is not the best
    solution. Rather, while testing in the Unity editor, you ought to utilize the
    aide function `Resources.LoadAssetAtPath` to abstain from needing to utilize and
    revamp the asset bundles. The function gives you a chance to load your asset as
    though it were being stacked from an asset bundle, yet we will skirt the building
    procedure, and your assets are constantly up and coming. Let''s create a new C#
    script that will improve our last example with some exception handling and with
    `Resources.LoadAssetAtPath` in event of importing within the Unity editor. Create
    a new script and name it, for example, `MyAssetBundleImporter`. The next step
    is to declare at the beginning of the file the required namespaces that we will
    use:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于制作项目是一个迭代过程，你可能会多次修改你的资源，这可能会迫使你在每次更改后重新制作资源包，以便能够测试它们。尽管在Unity编辑器中可以加载资源包，但这并不是最佳解决方案。相反，在Unity编辑器中进行测试时，你应该使用辅助函数`Resources.LoadAssetAtPath`来避免需要使用和更新资源包。该函数允许你以从资源包中加载的方式加载你的资源，但我们将跳过构建过程，你的资源始终是可用的。让我们创建一个新的C#脚本，它将改进我们的最后一个示例，并添加一些异常处理以及`Resources.LoadAssetAtPath`在Unity编辑器导入时的功能。创建一个新的脚本，例如命名为`MyAssetBundleImporter`。下一步是在文件的开始处声明我们将使用的所需命名空间：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s declare the `public` property in this class for objects that will be
    retrieved from your `AssetBundle`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在类中声明一个`public`属性，用于从你的`AssetBundle`中检索的对象：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, in this class, let''s declare our `public` and specific `AssetBundle`
    structure with its public properties for further usage:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在这个类中，让我们声明我们的`public`和特定的`AssetBundle`结构，以及其公共属性，以便进一步使用：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will declare the core of this script, the function which Unity will
    execute as a co-routine:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明此脚本的核心，即Unity将作为协程执行的功能：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first step in the co-routine is to initialize our `assetBundleObject` to
    `null`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 协程的第一步是将我们的`assetBundleObject`初始化为`null`：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that line of code, let''s declare the main condition in order to decide
    how to import your asset bundles:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在那行代码之后，让我们声明主要条件，以决定如何导入你的资源包：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s create a code for the first part of the `if`/`else`/`endif` pre-processor
    statement:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`if`/`else`/`endif`预处理器语句的第一部分编写代码：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will create the code for the second part of the `if`/`else`/`endif`
    preprocessor statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为`if`/`else`/`endif`预处理器语句的第二部分编写代码：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a simple script inherited from `MonoBehaviour`, which will show
    how you can use your example class `MyAssetBundleImporter`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的脚本，继承自`MonoBehaviour`，这将展示你如何使用你的示例类`MyAssetBundleImporter`：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's describe what happened in the last script. First, we declared one public
    `AssetBundleStruct` variable and two private variables. After that, we created
    the `Start` method, where we initialized our `AssetBundleStruct` variable with
    the right values. Next, we called the co-routine `Import` in our `Start` function.
    In the `Import` co-routine, we created one single instance of our class `MyAssetBundleImporter`
    to call its `Import` co-routine with our initialized structure `abs`. If we imported
    the object and it is not equal to `null`, then we instantiate that GameObject
    in our scene. Also, we show the simple `GUI` label that indicates whether we successfully
    imported our `AssetBundle` or not. For using this (only if your `AssetBundle`
    was already created and uploaded) script, you should just attach it as a component
    to your GameObject in your scene and set up correct values. If those two simple
    steps were done, then you can play and test your game in the Unity editor or within
    your build.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下最后一个脚本中发生了什么。首先，我们声明了一个公共的`AssetBundleStruct`变量和两个私有变量。然后，我们在`Start`方法中初始化我们的`AssetBundleStruct`变量。接下来，我们在`Start`函数中调用协程`Import`。在`Import`协程中，我们创建了我们类`MyAssetBundleImporter`的一个实例，并使用我们初始化的结构`abs`调用它的`Import`协程。如果我们导入了对象并且它不等于`null`，那么我们在场景中实例化那个GameObject。此外，我们展示了简单的`GUI`标签，指示我们是否成功导入了`AssetBundle`。为了使用这个（只有如果你的`AssetBundle`已经创建并上传）脚本，你只需将其作为组件附加到你的场景中的GameObject上，并设置正确的值。如果这两个简单的步骤已经完成，那么你就可以在Unity编辑器或构建中播放和测试你的游戏。
- en: If you need to get an array with all contained objects from your `AssetBundle`,
    you should use the function known as `AssetBundle.LoadAll`. In the event where
    you need to get a list of the string identifiers, you should keep a specific `TextAsset`
    as a map to save your assets' names there.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从你的`AssetBundle`获取包含的所有对象的数组，你应该使用名为`AssetBundle.LoadAll`的函数。在需要获取字符串标识符列表的情况下，你应该保留一个特定的`TextAsset`作为映射，以保存你的资源名称。
- en: 'In the following steps, we''re going to show a simple example about adjusting
    different texture compressions before building your asset bundle. All we need
    to remember is two simple steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将展示一个简单的例子，关于在构建资源包之前调整不同的纹理压缩。我们只需要记住两个简单的步骤：
- en: In order to force reimporting your assets before building the asset bundle,
    you should use the `AssetDatabase.ImportAsset` function.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在构建资源包之前强制重新导入你的资源，你应该使用`AssetDatabase.ImportAsset`函数。
- en: After you should use `AssetPostprocessor.OnPreprocessTexture` to adjust correct
    values for your texture compression.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你应该使用`AssetPostprocessor.OnPreprocessTexture`来调整纹理压缩的正确值。
- en: 'Now, let''s write a simple code example that you can use in your projects like
    any other examples from this book:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个简单的代码示例，你可以在你的项目中使用，就像这本书中的其他示例一样：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As always, we declare the required namespaces (remember this script will use
    `UnityEditor` and should be located in `Editor` folder, we spoke earlier about
    this Unity requirement). The next step is to define a simple class using the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们声明所需的命名空间（记住这个脚本将使用`UnityEditor`并且应该位于`Editor`文件夹中，我们之前已经讨论过这个Unity要求）。下一步是定义一个简单的类，使用以下代码：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After the simple class declaration, we need to set up one `public` and `static`
    variable, at the same time, and three different but elementary functions (you
    can use any desired texture format; in this example, we use `DXT1`, `DXT5`, and
    `ETC_RGB4`):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的类声明之后，我们需要设置一个`public`和`static`变量，同时还要设置三个不同但基本的功能（你可以使用任何想要的纹理格式；在这个例子中，我们使用`DXT1`、`DXT5`和`ETC_RGB4`）：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we can write our main function `CreateAssetBundle` that does all the dirty
    work:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写我们的主函数`CreateAssetBundle`，它将完成所有脏活累活：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our first step, we call the `EditorUtility.SaveFilePanel` method in order
    to show the Unity dialog and to get a selected path string from it. Also, we need
    to return from this function an empty location variable:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一步中，我们调用 `EditorUtility.SaveFilePanel` 方法以显示 Unity 对话框并从中获取选定的路径字符串。此外，我们还需要从这个函数返回一个空的位置变量：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The next step is to declare an array with our selected objects:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是声明一个包含我们选择对象的数组：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Further, we have to process each texture from our array in a loop in order
    to get path for that asset source with the help of the `AssetDatabase.GetAssetPath`
    method. For texture, we must use the `AssetDatabase.ImportAsset` function to force
    our texture preprocessing:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须在循环中处理我们数组中的每个纹理，以便使用 `AssetDatabase.GetAssetPath` 方法获取该资产源路径。对于纹理，我们必须使用
    `AssetDatabase.ImportAsset` 函数强制进行纹理预处理：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After this, we have to build our `AssetBundle`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们必须构建我们的 `AssetBundle`：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'At the last stage, we can initialize the `Selection.objects` list variable
    with our selected assets array in order to see all of them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后阶段，我们可以用我们选择的资产数组初始化 `Selection.objects` 列表变量，以便查看所有这些：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we should create a very simple class (this script should be placed into
    the `Editor` folder, we mentioned this requirement earlier) inherited from the
    `AssetPostprocessor` class as shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该创建一个非常简单的类（这个脚本应该放在我们之前提到的 `Editor` 文件夹中），它继承自 `AssetPostprocessor` 类，如下所示：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Downloading new code and data in real time for Android devices
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Android 设备实时下载新的代码和数据
- en: 'In the event of retrieving assets from your bundles, you can use three separate
    functions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在从你的包中检索资产时，你可以使用三个不同的函数：
- en: '`AssetBundle.Load`: This will load one object only by the given name; also
    it will block the main thread.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssetBundle.Load`: 这将按给定名称加载一个对象；它也会阻塞主线程。'
- en: '`AssetBundle.LoadAsync`: This will load one object only by a given name; it
    will not block the main thread. Use this method for huge assets.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssetBundle.LoadAsync`: 这将按给定名称加载一个对象；它不会阻塞主线程。对于大型资产，请使用此方法。'
- en: '`AssetBundle.LoadAll`: This will load every object from your `AssetBundle`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AssetBundle.LoadAll`: 这将加载你的 `AssetBundle` 中的所有对象。'
- en: 'Use the `AssetBundle.Unload` method in the event of unloading assets. Let''s
    look at a simple usage example of the asynchronous method as shown in the following
    code without any exception handling and any checks (just as `skeleton`):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在卸载资产时，可以使用 `AssetBundle.Unload` 方法。让我们看看以下代码中异步方法的简单用法示例，没有任何异常处理和任何检查（就像 `skeleton`）：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Managing loaded asset bundles
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理已加载的资产包
- en: 'Asset bundles cannot be loaded if a previous bundle has not been unloaded previously:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前没有卸载之前的包，则无法加载资产包：
- en: '[PRE26]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to always keep references for your imported assets, to avoid importing same
    assets multiple times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量始终保留导入的资产引用，以避免多次导入相同的资产。
- en: Unity will throw an exception and your asset bundle (in our example, `ab` variable)
    variable will be `null`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 将抛出异常，并且你的资产包变量（在我们的例子中是 `ab` 变量）将变为 `null`。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to unload your `AssetBundle` as early as possible.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能早地卸载你的 `AssetBundle`。
- en: 'You can use the next simple script (as shown in the following code) for your
    loaded bundles. All this code should be pretty clear to you, so let''s look at
    this C# script:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下简单的脚本（如下所示）为你加载的包使用。所有这些代码应该对你来说都很清楚，所以让我们看看这个 C# 脚本：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can use the dispatcher class as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用如下所示的调度器类：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to clone your previous instantiated objects to avoid unnecessary
    importing bundles (by calling Unity's function known as `GameObject.Instantiate`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能通过调用 Unity 的 `GameObject.Instantiate` 函数来克隆之前实例化的对象，以避免不必要的导入包。
- en: Asset bundles and binary data
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产包和二进制数据
- en: 'Unity treats binary files with a `.bytes` extension as a `TextAsset`, which
    can be included in your `AssetBundle`. Here''s an example of the C# script shown
    here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 将具有 `.bytes` 扩展名的二进制文件视为 `TextAsset`，它可以包含在你的 `AssetBundle` 中。以下是一个显示的
    C# 脚本示例：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Asset bundles and scripts
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产包和脚本
- en: 'You can build your asset bundles with scripts as `TextAsset` files, which can
    be executable only in the event of precompiling them into an assembly. This example
    is shown in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用脚本作为 `TextAsset` 文件构建你的资产包，这些文件只有在预编译成程序集时才能执行。以下代码展示了这个示例：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Asset bundle dependencies
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产包依赖
- en: 'Many of your assets will depend on other assets, such as materials, textures,
    shaders, and so on. You can build your bundle with all those assets, but this
    approach can reduce the size of the `AssetBundle` file. Furthermore, this approach
    will not be effective if all those dependencies are used for your other bundles.
    Too much memory will be wasted. Instead, you can create a separate asset bundle
    with all those shared dependencies, which will be used by other bundles. In the
    event of using these dependencies, firstly, you should call the function known
    as `BuildPipeline.PushAssetDependencies`, and then your shared bundle can be built
    for other bundles. Therefore, before each new level, you should always call this
    function to tell Unity to put your bundle in its stack for further usage by other
    bundles. At the end of your bundle creation, you should always empty this stack
    of bundles by a command known as `BuildPipeline.PopAssetDependencies`. In your
    application, you should always import all your shared bundles and only after that
    you can import your other bundles with those dependencies. Let''s see how to save
    separate `AssetBundle` with shared shaders (as shown here) in this action:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多你的资源将依赖于其他资源，例如材质、纹理、着色器等。你可以构建包含所有这些资源的包，但这种方法可以减小 `AssetBundle` 文件的大小。此外，如果所有这些依赖项都用于你的其他包，这种方法将不会有效。这将浪费太多内存。相反，你可以创建一个包含所有这些共享依赖项的单独资源包，该资源包将被其他包使用。在使用这些依赖项的情况下，首先，你应该调用名为
    `BuildPipeline.PushAssetDependencies` 的函数，然后你的共享包可以构建用于其他包。因此，在每次新关卡之前，你应该始终调用此函数，告诉
    Unity 将你的包放入其堆栈中以便其他包进一步使用。在资源包创建结束时，你应该始终通过名为 `BuildPipeline.PopAssetDependencies`
    的命令清空这个包堆栈。在你的应用程序中，你应该始终导入所有你的共享包，然后才能导入具有这些依赖项的其他包。让我们看看如何保存具有共享着色器的单独 `AssetBundle`（如图所示）在这个动作中：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create an empty GameObject and attach this script to it and save it (after
    populating array of shaders) as a prefab anywhere you want within your project
    files. The following step is to create the C# script to generate asset bundles
    as shown here, where `YourAssetBundle_2` requires `YourAssetBundle_1` and `YourAssetBundle_3`
    depends on the first and the second bundles. This is just an example, you should
    change it depending on your needs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的 GameObject 并将此脚本附加到它上，并在你的项目文件中的任何位置将其保存（在填充着色器数组之后）作为一个预制体。接下来的步骤是创建一个
    C# 脚本来生成资源包，如图所示，其中 `YourAssetBundle_2` 需要 `YourAssetBundle_1`，而 `YourAssetBundle_3`
    依赖于第一个和第二个包。这只是一个示例，你应该根据你的需求进行更改：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Safeness techniques in practice
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践中的安全性技术
- en: 'Next, the C# script example will cover how to protect the content of your asset
    bundles (as shown here):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，C# 脚本示例将涵盖如何保护你的资源包的内容（如图所示）：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Another secure way is to encrypt the whole asset bundle instead of just the
    `TextAsset` data as shown in the preceding code. Alternatively, in this approach,
    you cannot use the `WWW.LoadFromCacheOrDownload` method. You always need to import
    your bundles from `WWW` streaming as shown in the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种安全的方式是加密整个资源包，而不是仅仅加密 `TextAsset` 数据，如图中所示的前一个代码。或者，在此方法中，你不能使用 `WWW.LoadFromCacheOrDownload`
    方法。你始终需要从 `WWW` 流中导入你的包，如图中所示的下述代码：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last and the best protection approach is to keep your encrypted `AssetBundle`
    as `TextAsset` inside another (not encrypted) `AssetBundle`. Thus, we can use
    Unity''s caching system for our asset bundles as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后且最好的保护方法是将你的加密 `AssetBundle` 作为 `TextAsset` 放置在另一个（未加密的）`AssetBundle` 内部。因此，我们可以像这里所示一样使用
    Unity 的缓存系统来处理我们的资源包：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discovered asset bundles. There were a lot of code examples.
    We learned how to build and import your asset bundles and how to encrypt data
    for the asset bundle by different methods. Furthermore, in this chapter, we explored
    how to create and use your `AssetBundle` dependencies with other bundles. Also,
    we studied how to use binary data with asset bundles and executable scripts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了资源包。这里有很多代码示例。我们学习了如何构建和导入你的资源包，以及如何通过不同的方法加密资源包中的数据。此外，在本章中，我们还探讨了如何创建和使用你的
    `AssetBundle` 依赖项，以及如何使用二进制数据与资源包和可执行脚本。
- en: In the next chapter, we will introduce different optimization techniques. You
    will learn in practice how to use occlusion culling and level of details optimization
    techniques. You will see how to optimize native C# and Unity scripts. Finally,
    you will see how to transform native C# and JavaScript codes into Unity scripts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍不同的优化技术。你将在实践中学习如何使用遮挡剔除和细节级别优化技术。你将看到如何优化原生C#和Unity脚本。最后，你将了解如何将原生C#和JavaScript代码转换为Unity脚本。
