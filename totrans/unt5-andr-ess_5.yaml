- en: Chapter 5. Asset Bundles in Unity 5 Pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will include an overview of Asset Bundles in Unity 5\. You will
    learn how to download new code and data in real time for Android devices. At the
    end of this chapter, the reader will discover the safeness technique of the asset
    bundles in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of Asset Bundles in Unity 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading new code and data in real time for Android devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safeness techniques in practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the asset bundles in Unity 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Asset bundles are **Unity Pro** features only. Two main ideas of the asset
    bundles are:'
  prefs: []
  type: TYPE_NORMAL
- en: Easily download content in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading new content in your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unity allows exporting your assets as files, which are known as asset bundles.
    Your application can download these compressed files whenever needed. This approach
    will reduce your final build size by streaming in: prefabs, animations, binary
    files, textures, audio clips, meshes, and scenes, where asset bundles will be
    utilized. All other asset types are supported by Unity. For binary files, you
    should set the extension to `.bytes` and Unity will recognize these files as `TextAsset`.
    To use asset bundles, you just need to create them and upload them to your server.
    In the Unity Editor, you can build asset bundles from your assets in the scene.
    In a situation when you need to upload your asset bundles to the server, you can
    use any data communication protocol; for example, SSH, FTP, FTPS, SFTP, or any
    other protocol depending on your choice. In real time, your application, which
    is written in your script, will download the necessary asset bundles for further
    work with your packed assets in these exported files.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover what you should do to create the `AssetBundle` file. For this
    task, you should use the Unity Editor class known as `BuildPipeline`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using any of the Unity Editor classes in your scripts, then you should
    always remember to keep these scripts in a folder named `Editor` anywhere in your
    project within any subdirectory of the `Assets` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a simple C# script to create `AssetBundle`. First of all,
    we should import two Unity namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After these lines of code, you should declare your public class; for example,
    you can create very simple class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we will create a static function with its `MenuItem` for
    future selection from the Unity Editor menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you need to fill in your static function with just a single instruction
    or line of code or something similar depending on your requirements, and you will
    see the already finished simple class to build your `AssetBundle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function creates a compressed `Assets/Your/Path/To/YourAssetBundle.unity3d`
    file with a list of packed assets (any from your project folder) and returns `true`
    if `AssetBundle` was created successfully or `false` otherwise. The first variable
    in this function, `Selection.activeObject`, indicates which object to use for
    retrieving packed assets from `AssetBundle` using the `AssetBundle.mainAsset`
    property. You can set this value to `null` if you are not using it. The second
    variable is `array Object[]` and specifies which assets you need to pack. The
    third variable is very simple, and it is just a location where you want to save
    your `AssetBundle` file. By specifically adjusting `BuildAssetBundleOptions` flags,
    you can dictate to include all dependencies automatically or only include complete
    assets. Furthermore, with these options, you can specify that you don''t want
    your assets to be compressed in the `AssetBundle` file by setting up the `UncompressedAssetBundle`
    flag. If you want, you can check the `CRC` checksum of your asset bundles while
    downloading your exported files via the `WWW.LoadFromCacheOrDownload` call. To
    create asset bundles, you can use three different functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BuildPipeline.BuildAssetBundle`: This will build any asset type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BuildPipeline.BuildStreamedSceneAssetBundle`: This will include only scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BuildPipeline.BuildAssetBundleExplicitAssetNames`: This is similar to `BuildPipeline.BuildAssetBundle`,
    but with a little difference. In this function, you can indicate your string identifier
    for all included objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create the asset bundles for the Web-Player platform and use them in
    a standalone platform and vice versa. Alternatively, for mobile platforms, you
    can use only their built files. For example, you can create the asset bundles
    for Android devices and use them only for Android platforms, but you cannot use
    them for iOS platforms and vice versa. With built files for the iOS platform,
    you can use them only within iOS boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use your class to create the asset bundle, you need to do two simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You should select one single or many assets in your project, which will be packed
    into your `AssetBundle`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Unity menu, you should navigate to **PacktPub** | **AssetBundles**
    | **Build Asset Bundle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The finished script to create `AssetBundle` should be similar to the code shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve realized the asset bundles creation, now let''s explore how to use them
    from your scripts. To use your asset bundles, you should follow the next two simple
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download your `AssetBundle` files from any local storage like hard drive or
    remote storage like any web-server, Unity provides the `WWW` helper class for
    such issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load or, in other words, unpack your assets from your `AssetBundle` files in
    order to use them further in your game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following code, we intend to understand the case of using `AssetBundle`.
    First of all, we need to create a simple C# script and name it, for example, `ImporterAssetBundle`.
    Open the script in your code editor and change it as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Attach this script as a component to your GameObject. The URL in this script
    is just for example, so you should set your own URL for your `AssetBundle` file.
    Based on this version, Unity's caching system will decide whether to download
    your file or not. If this file was already cached with the same version number,
    then Unity will speed up your application. In this script, we called `Import`
    co-routine in the `Start` event, but you can call this function anywhere you need
    and as often as you want. In `Import` co-routine, we first used `WWW.LoadFromCacheOrDownload`
    with the sole purpose of loading the required `AssetBundle` file by given the
    URL path and the version number. During the downloading process, Unity will not
    execute the next instructions from the `yield return www` command. Only after
    the download is complete will Unity run the next commands in our co-routine example.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `www` instance to retrieve `mainAsset` as a GameObject instance from
    the downloaded `AssetBundle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new instance in real time in the current scene of the retrieved `GameObject`
    instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unloading all the memory used for this **AssetBundle** (for increasing the performance).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As making projects is an iterative procedure, you will probably alter your
    assets not once but multiple times, which may oblige remaking the asset bundles
    after every change to have the capacity to test them. Despite the fact that it
    is conceivable to load the asset bundles in the Unity editor, it is not the best
    solution. Rather, while testing in the Unity editor, you ought to utilize the
    aide function `Resources.LoadAssetAtPath` to abstain from needing to utilize and
    revamp the asset bundles. The function gives you a chance to load your asset as
    though it were being stacked from an asset bundle, yet we will skirt the building
    procedure, and your assets are constantly up and coming. Let''s create a new C#
    script that will improve our last example with some exception handling and with
    `Resources.LoadAssetAtPath` in event of importing within the Unity editor. Create
    a new script and name it, for example, `MyAssetBundleImporter`. The next step
    is to declare at the beginning of the file the required namespaces that we will
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare the `public` property in this class for objects that will be
    retrieved from your `AssetBundle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in this class, let''s declare our `public` and specific `AssetBundle`
    structure with its public properties for further usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will declare the core of this script, the function which Unity will
    execute as a co-routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in the co-routine is to initialize our `assetBundleObject` to
    `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After that line of code, let''s declare the main condition in order to decide
    how to import your asset bundles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a code for the first part of the `if`/`else`/`endif` pre-processor
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create the code for the second part of the `if`/`else`/`endif`
    preprocessor statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a simple script inherited from `MonoBehaviour`, which will show
    how you can use your example class `MyAssetBundleImporter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's describe what happened in the last script. First, we declared one public
    `AssetBundleStruct` variable and two private variables. After that, we created
    the `Start` method, where we initialized our `AssetBundleStruct` variable with
    the right values. Next, we called the co-routine `Import` in our `Start` function.
    In the `Import` co-routine, we created one single instance of our class `MyAssetBundleImporter`
    to call its `Import` co-routine with our initialized structure `abs`. If we imported
    the object and it is not equal to `null`, then we instantiate that GameObject
    in our scene. Also, we show the simple `GUI` label that indicates whether we successfully
    imported our `AssetBundle` or not. For using this (only if your `AssetBundle`
    was already created and uploaded) script, you should just attach it as a component
    to your GameObject in your scene and set up correct values. If those two simple
    steps were done, then you can play and test your game in the Unity editor or within
    your build.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to get an array with all contained objects from your `AssetBundle`,
    you should use the function known as `AssetBundle.LoadAll`. In the event where
    you need to get a list of the string identifiers, you should keep a specific `TextAsset`
    as a map to save your assets' names there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we''re going to show a simple example about adjusting
    different texture compressions before building your asset bundle. All we need
    to remember is two simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to force reimporting your assets before building the asset bundle,
    you should use the `AssetDatabase.ImportAsset` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you should use `AssetPostprocessor.OnPreprocessTexture` to adjust correct
    values for your texture compression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s write a simple code example that you can use in your projects like
    any other examples from this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As always, we declare the required namespaces (remember this script will use
    `UnityEditor` and should be located in `Editor` folder, we spoke earlier about
    this Unity requirement). The next step is to define a simple class using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the simple class declaration, we need to set up one `public` and `static`
    variable, at the same time, and three different but elementary functions (you
    can use any desired texture format; in this example, we use `DXT1`, `DXT5`, and
    `ETC_RGB4`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write our main function `CreateAssetBundle` that does all the dirty
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In our first step, we call the `EditorUtility.SaveFilePanel` method in order
    to show the Unity dialog and to get a selected path string from it. Also, we need
    to return from this function an empty location variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to declare an array with our selected objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we have to process each texture from our array in a loop in order
    to get path for that asset source with the help of the `AssetDatabase.GetAssetPath`
    method. For texture, we must use the `AssetDatabase.ImportAsset` function to force
    our texture preprocessing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we have to build our `AssetBundle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'At the last stage, we can initialize the `Selection.objects` list variable
    with our selected assets array in order to see all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should create a very simple class (this script should be placed into
    the `Editor` folder, we mentioned this requirement earlier) inherited from the
    `AssetPostprocessor` class as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Downloading new code and data in real time for Android devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the event of retrieving assets from your bundles, you can use three separate
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AssetBundle.Load`: This will load one object only by the given name; also
    it will block the main thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssetBundle.LoadAsync`: This will load one object only by a given name; it
    will not block the main thread. Use this method for huge assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AssetBundle.LoadAll`: This will load every object from your `AssetBundle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use the `AssetBundle.Unload` method in the event of unloading assets. Let''s
    look at a simple usage example of the asynchronous method as shown in the following
    code without any exception handling and any checks (just as `skeleton`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Managing loaded asset bundles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Asset bundles cannot be loaded if a previous bundle has not been unloaded previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to always keep references for your imported assets, to avoid importing same
    assets multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Unity will throw an exception and your asset bundle (in our example, `ab` variable)
    variable will be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to unload your `AssetBundle` as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the next simple script (as shown in the following code) for your
    loaded bundles. All this code should be pretty clear to you, so let''s look at
    this C# script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the dispatcher class as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to clone your previous instantiated objects to avoid unnecessary
    importing bundles (by calling Unity's function known as `GameObject.Instantiate`).
  prefs: []
  type: TYPE_NORMAL
- en: Asset bundles and binary data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity treats binary files with a `.bytes` extension as a `TextAsset`, which
    can be included in your `AssetBundle`. Here''s an example of the C# script shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Asset bundles and scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can build your asset bundles with scripts as `TextAsset` files, which can
    be executable only in the event of precompiling them into an assembly. This example
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Asset bundle dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of your assets will depend on other assets, such as materials, textures,
    shaders, and so on. You can build your bundle with all those assets, but this
    approach can reduce the size of the `AssetBundle` file. Furthermore, this approach
    will not be effective if all those dependencies are used for your other bundles.
    Too much memory will be wasted. Instead, you can create a separate asset bundle
    with all those shared dependencies, which will be used by other bundles. In the
    event of using these dependencies, firstly, you should call the function known
    as `BuildPipeline.PushAssetDependencies`, and then your shared bundle can be built
    for other bundles. Therefore, before each new level, you should always call this
    function to tell Unity to put your bundle in its stack for further usage by other
    bundles. At the end of your bundle creation, you should always empty this stack
    of bundles by a command known as `BuildPipeline.PopAssetDependencies`. In your
    application, you should always import all your shared bundles and only after that
    you can import your other bundles with those dependencies. Let''s see how to save
    separate `AssetBundle` with shared shaders (as shown here) in this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty GameObject and attach this script to it and save it (after
    populating array of shaders) as a prefab anywhere you want within your project
    files. The following step is to create the C# script to generate asset bundles
    as shown here, where `YourAssetBundle_2` requires `YourAssetBundle_1` and `YourAssetBundle_3`
    depends on the first and the second bundles. This is just an example, you should
    change it depending on your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Safeness techniques in practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, the C# script example will cover how to protect the content of your asset
    bundles (as shown here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Another secure way is to encrypt the whole asset bundle instead of just the
    `TextAsset` data as shown in the preceding code. Alternatively, in this approach,
    you cannot use the `WWW.LoadFromCacheOrDownload` method. You always need to import
    your bundles from `WWW` streaming as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last and the best protection approach is to keep your encrypted `AssetBundle`
    as `TextAsset` inside another (not encrypted) `AssetBundle`. Thus, we can use
    Unity''s caching system for our asset bundles as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered asset bundles. There were a lot of code examples.
    We learned how to build and import your asset bundles and how to encrypt data
    for the asset bundle by different methods. Furthermore, in this chapter, we explored
    how to create and use your `AssetBundle` dependencies with other bundles. Also,
    we studied how to use binary data with asset bundles and executable scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce different optimization techniques. You
    will learn in practice how to use occlusion culling and level of details optimization
    techniques. You will see how to optimize native C# and Unity scripts. Finally,
    you will see how to transform native C# and JavaScript codes into Unity scripts.
  prefs: []
  type: TYPE_NORMAL
