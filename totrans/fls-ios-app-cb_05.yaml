- en: Chapter 5. Multi-touch and Gesture Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the touch point input mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting multiple touch points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging multiple display objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the gesture input mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a swipe gesture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panning an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iPhone wasn't the first to use the technology, but its success kick-started
    the touch-screen revolution. Critical to that success was Apple's decision to
    include multi-touch support. Be it a single tap, swipe, or pinch; interaction
    with the iPhone's screen always feels intuitive and natural.
  prefs: []
  type: TYPE_NORMAL
- en: The Flash platform allows application developers to take full advantage of multi-touch
    when targeting iOS. In this chapter, we will explore how to work with multiple-touch
    points before covering how to detect and respond to gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the touch point input mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The success of the iPhone has changed how people use mobile devices, with users
    now expecting to interact directly with a device by physically touching its screen.
    While a mouse is limited to the selection of a single point, iOS devices can detect
    multiple touches and track the movement of each of them simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Flash provides full support for multi-touch but in order to take advantage of
    it you must first inform the platform of your intentions to receive and use touch-based
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An FLA has been provided as a starting point for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: From the book's accompanying code bundle, open `chapter5\recipe1\recipe.fla`
    into Flash Professional.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting on the stage is a dynamic text field named `output`. We will write some
    code to enable multi-touch input and write the success or failure of the request
    to the text field.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now within the constructor add some code to enable multi-touch support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class file as `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA file to your iOS device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the app, the following text should be output to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**inputMode = touchPoint**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flash provides various multi-touch input modes, which determine the type of
    events your application can receive. In order to receive touch events, you need
    to set the `Multitouch.inputMode` property to `MultitouchInputMode.TOUCH_POINT`.
    Here is the line of code from your document class that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to setting `Multitouch.inputMode`, you can also query it to determine
    the currently selected input mode. For this recipe, the current input mode is
    written to the `output` text field to confirm that it was successfully set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although Flash supports multi-touch across all iOS devices, the same is not
    true for all other operating systems and platforms. When writing cross-platform
    code, you may want to confirm support by checking the `Multitouch.supportsTouchEvents`
    property. In our code example, this is done before setting the input mode.
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding the multi-touch input mode, perform a search
    for `flash.ui.Multitouch` and `flash.ui.MultitouchInputMode` within Adobe Community
    Help.
  prefs: []
  type: TYPE_NORMAL
- en: It is also highly recommended that you spend time with Apple's iOS Human Interface
    Guidelines, where you will find best practices for driving the user experience
    through multi-touch. The documentation can be found on the iOS Dev Center at [http://developer.apple.com/devcenter/ios](http://developer.apple.com/devcenter/ios).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us look at some additional detail.
  prefs: []
  type: TYPE_NORMAL
- en: Available touch events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the input mode for touch allows you to listen for touch-specific events
    being dispatched by objects of type `InteractiveObject` or objects that inherit
    `InteractiveObject`, such as `Sprite, MovieClip`, and `Stage`. On a multi-touch
    screen, each point of contact that can be made by a finger is known as a touch
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following touch events are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Touch events | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_BEGIN` | A touch point has been pressed. |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_END` | A touch point has been released. |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_MOVE` | A touch point is being moved. This occurs when a finger is
    being dragged across the screen. |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_TAP` | A quick finger tap. |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_OVER` | A touch point has moved over an interactive object. |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_OUT` | A touch point has been moved away from an interactive object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_ROLL_OVER` | A touch point has moved over an interactive object. Unlike
    `TOUCH_OVER`, this event will not fire for any children belonging to the object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TOUCH_ROLL_OUT` | A touch point has been moved away from an interactive
    object. Unlike `TOUCH_OUT`, this event will not fire for any children belonging
    to the object. |'
  prefs: []
  type: TYPE_TB
- en: We will see some of these events in action during the next few recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the number of supported touch points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can determine the number of touch points supported by your iOS device by
    examining the static `Multitouch.maxTouchPoints` property.
  prefs: []
  type: TYPE_NORMAL
- en: While you will find that five touch points are supported across the range of
    iOS devices, this property is of more practical use on cross-platform projects,
    where the number of touch points can vary wildly depending on the operating system
    and choice of input device. When targeting multiple platforms, optimize your content
    with this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Touch point hit targets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For elements that can be tapped within your application, ensure that a hit area
    that is at least the size of a fingertip is used. This equates to approximately
    44x44 pixels on a standard resolution screen and 88x88 pixels on a Retina display.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default input mode is `MultitouchInputMode.NONE`, which specifies that all
    user interaction with a touch-enabled device is interpreted as a mouse event.
    However, unlike `MultitouchInputMode.TOUCH_POINT`, only a single touch point can
    be processed at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the input mode is set to `MultitouchInputMode.TOUCH_POINT`, you
    can continue to listen for and respond to mouse events provided by `flash.events.MouseEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in ADL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is most likely that testing this recipe''s code within ADL will result in
    the following message being output to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi-touch events not supported.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all desktop computers or operating systems support multi-touch. When using
    touch-based events within your code, it is advisable that you test directly on
    an iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a basic document class, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling user interaction, [Chapter 4](ch04.html "Chapter 4. Porting Flash
    Projects to iOS")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Detecting multiple touch points*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting the gesture input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting multiple touch points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term multi-touch refers to the ability to simultaneously detect and track
    two or more distinct points of contact on a touch-screen. Touch events are similar
    to the mouse events provided by Flash, except you can listen for and respond to
    multiple touch events all at once.
  prefs: []
  type: TYPE_NORMAL
- en: Let us revisit the Bubbles app from [Chapter 3](ch03.html "Chapter 3. Writing
    your First App") and add multi-touch interaction to it. We will add functionality
    to let the user trap multiple bubbles by holding a finger on top of each.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A version of the Bubbles FLA has been provided for you to work from.
  prefs: []
  type: TYPE_NORMAL
- en: From Flash Professional, open `chapter5\recipe2\recipe.fla` from the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be making changes to both the FLA's document class and `Bubble.as`.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Bubble class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start by adding some code to `Bubble.as` that prevents any of the bubble
    instances from moving if being held:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Bubble.as` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following member variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now write a getter and a setter method for the `_held` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the `update()` method and write a few lines of code at the start to
    prevent the bubble''s update logic from running if it is being held:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, within the constructor, disable user input for any child display objects
    within the bubble—we are only interested in receiving events for the bubble''s
    container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save `Bubble.as.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Responding to multiple touch events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now within the FLA''s document class, let us listen for multi-touch events
    and trap any bubbles that are being touched:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Main.as` document class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following three import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the constructor, set the input mode, and listen for `TouchEvent.TOUCH_BEGIN`
    and `TouchEvent.TOUCH_END` being dispatched from the stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a handler for the `TOUCH_BEGIN` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And add a handler for the `TOUCH_END` event too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA file to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the app and hold your fingers on multiple bubbles to stop them from floating
    upwards. Lifting your finger off a bubble will release it again.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe took advantage of multi-touch to allow the detection of touch points
    across multiple objects simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Touch was enabled with the following line of code within the `Main` class''
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Touch events can be dispatched by any `InteractiveObject` or sub-class of `InteractiveObject`,
    such as `Sprite, MovieClip`, and `Stage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listeners for the following two events were added to the stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TouchEvent.TOUCH_BEGIN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TouchEvent.TOUCH_END`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `TOUCH_BEGIN` event is fired when the user presses a finger onto any child
    interactive object of the stage. This is the case even if other areas of the screen's
    surface are already being touched. When the user lifts their finger from an interactive
    object, the `TOUCH_END` event is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the stage's child objects consist of bubble instances and a
    single background movie clip. The event handlers simply check to see if the event
    was dispatched from a `Bubble` instance, and if so the bubble's `held` property
    is set. For the `TOUCH_BEGIN` event, the bubble's `held` property is set to `true`,
    thus freezing it. When the `TOUCH_END` event is received, the bubble's held property
    is set to `false`, allowing it to start moving upwards again.
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain more information regarding the `flash.events.TouchEvent` class
    from Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: Handling roll out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes the user's finger may slide away from the bubble rather than being
    cleanly lifted from it. When this happens in this recipe's example code, the held
    bubble doesn't receive the `TOUCH_END` event and therefore doesn't start floating
    upwards again.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can rectify this by listening for `TouchEvent.TOUCH_ROLL_OUT` being dispatched
    from each of the bubble instances. Simply add the following line within the `Main`
    class'' constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now when the user slides his or her finger away from a bubble, the `touchEnd()`
    handler will get called and the bubble will start moving again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can carry your code from this recipe into the next. If you have added an
    event listener for `TouchEvent.TOUCH_ROLL_OUT`, then remove it again before continuing
    as it isn't required and will produce odd behavior if left in.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each event object that your handler receives contains a number of properties
    related to that touch event. You may find the following properties useful when
    detecting multiple touch points.
  prefs: []
  type: TYPE_NORMAL
- en: Primary touch point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When touching a screen at multiple locations, the primary touch point is deemed
    to be the location that was first touched. When your event handler receives a
    `TouchEvent` object, you can query its `isPrimaryTouchPoint` property to determine
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Touch point ID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A unique ID is assigned to every new touch point and is used across all events
    associated with that point of contact. You can determine the touch point that
    an event is associated with by examining its `touchPointID` property.
  prefs: []
  type: TYPE_NORMAL
- en: Local touch coordinates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the `localX` and `localY` properties to determine the coordinates
    at which a touch event occurred relative to the interactive object. Bear in mind
    that these two properties won't provide pixel-perfect accuracy on touch-screen
    devices due to the nature of the technology and the surface area that is covered
    by a finger tip.
  prefs: []
  type: TYPE_NORMAL
- en: Global touch coordinates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also obtain the position at which an event occurred in global stage
    coordinates. Simply inspect the value of the event's `stageX` and `stageY` properties.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Linking classes to movie-clip symbols, [Chapter 3](ch03.html "Chapter 3. Writing
    your First App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using an update loop, [Chapter 3](ch03.html "Chapter 3. Writing your First
    App")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting the touch point input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dragging multiple display objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging multiple display objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With touch-enabled screens, the act of dragging a display object with a finger
    is very intuitive. Adobe AIR provides API calls that allow this type of interaction
    without much effort. In addition, the multi-touch capabilities of iOS can be harnessed
    to allow multiple objects to be dragged at once.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue where we left off in the *Detecting multiple touch points*
    recipe and add the ability to drag the bubbles around the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already done so, complete the *Detecting multiple touch points*
    recipe before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    from the book's accompanying code bundle, open `chapter5\recipe3\recipe.fla` into
    Flash Professional and work from there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the FLA''s document class and perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare the following member variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This array will be used to map touch points to `Bubble` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Within the constructor, set the `touching` member variable to an empty array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the `touchBegin()` event handler and make the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now alter the `touchEnd()` handler too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you run the app, you will now be able to stop and drag the bubbles. You
    can even drag multiple bubbles simultaneously. Give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much of the work in this recipe is performed by `startTouchDrag()` and `stopTouchDrag()`.
    Both methods are defined by `flash.display.Sprite` and are also available to classes
    that inherit it, including our `Bubble` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `startTouchDrag()` method allows the user to drag a bubble across the screen.
    It does this by associating a touch point ID with a bubble, continuously updating
    the bubble's position to reflect that of the touch point.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `stopTouchDrag()` method stops the bubble from being
    dragged by the specified touch point ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the `touchBegin()` event handler where `startTouchDrag()`
    is called. Two lines of code that are of particular interest have been highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, the interactive object that was touched is obtained by querying the event's
    `target` property and an attempt is made to cast it to a `Bubble` object. If the
    object is a bubble, then its `startTouchDrag()` method is called with the event's
    touch point ID being passed as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every point of contact made with the screen is assigned a unique ID that can
    be used by methods such as `startTouchDrag()` and `stopTouchDrag().` You can determine
    the touch point that an event is associated with by examining its `touchPointID`
    property. We take advantage of these unique IDs within our code to associate a
    bubble with a touch point. You can see this mapping taking place near the end
    of the `touchBegin()` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The handler makes use of the `touching` member variable to store a reference
    to the bubble that is being dragged by the user. The bubble instance is placed
    in the `touching` array, with the event's touch point ID being used as the index
    position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now take a look at the `touchEnd()` event handler, where we obtain from
    the `touching` array, the bubble that has just been released by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the above method, the event's `touchPointID` is obtained and used to retrieve
    the associated bubble from the `touching` array. If a bubble instance was retrieved,
    then its `stopTouchDrag()` method is called with the event's touch point ID being
    passed as an argument. This will stop the bubble being dragged by the user's finger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the end of the method, the bubble reference is removed from the
    `touching` array as it is no longer required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That is all there is to it. With the use of the `Sprite` class' `startTouchDrag()`
    and `stopTouchDrag()` methods and by tracking touch point IDs, we were able to
    manage the dragging of multiple interactive objects.
  prefs: []
  type: TYPE_NORMAL
- en: You can obtain more information regarding the `flash.display.Sprite` class from
    Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following is some more information regarding `startTouchDrag().`
  prefs: []
  type: TYPE_NORMAL
- en: startTouchDrag() parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `startTouchDrag()` method expects three arguments with only the first being
    mandatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`touchPointID:` The ID of the touch point that will be used to drag the sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lockCenter:` Whether to lock the center of the sprite to the touch point `(true)`
    , or lock to the point where contact was made with the sprite `(false)` . Defaulted
    to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bounds:` A `Rectangle` that defines a constraint region for the sprite that
    is being dragged. Defaulted to `null` meaning there is to be no constraint region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe's example code only used the first argument. Meaning the center
    of the bubble wasn't locked to the user's finger and the user was free to drag
    the bubble anywhere on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force the bubble''s center to lock to the user''s finger, simply pass `true`
    as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example also constrains the bubble to a 200x200 pixel region
    at the top-left corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Try applying each example to your code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting the touch point input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Tracking movement*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One important touch-based event that we haven't looked at yet in detail is `TouchEvent.TOUCH_MOVE`.
    This event is fired whenever the user moves a finger across the screen and can
    be queried to determine the contact point's coordinates. Every time the user's
    finger changes position, a new `TOUCH_MOVE` event is dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: Although `startTouchDrag()` and `stopTouchDrag()` are recommended for dragging
    objects, you can instead update an object's position in response to `TOUCH_MOVE`
    events.
  prefs: []
  type: TYPE_NORMAL
- en: Let us make some changes to the code from the *Dragging multiple display objects*
    recipe to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already done so, complete the *Dragging multiple display objects*
    recipe before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: You can continue to work with your code from that recipe. Alternatively, from
    the book's accompanying code bundle, open `chapter5\recipe4\recipe.fla` into Flash
    Professional and work from there.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps within the FLA''s document class:'
  prefs: []
  type: TYPE_NORMAL
- en: Move to the constructor and add a listener for `TouchEvent.TOUCH_MOVE:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the call to `startTouchDrag()` from the `touchBegin()` handler by deleting
    the highlighted line of code from the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also remove the call to `stopTouchDrag()` from the `touchEnd()` handler by
    deleting the highlighted line of code from the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now write the `touchMove()` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example should behave in an identical way to the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although dragging was previously taken care of by `startTouchDrag()` and `stopTouchDrag()`,
    for this recipe we manually update the position of the bubbles by responding to
    `TouchEvent.TOUCH_MOVE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk of the work is performed within the `touchMove()` event handler, which
    is shown again as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using the event's touch point ID, a reference to the bubble associated with
    it (if any) is retrieved from the `touching` array. The bubble's `x` and `y` properties
    are then updated to reflect the on-screen position of the user's finger, which
    is retrieved from the event's `stageX` and `stageY` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Every time one of the user's fingers changes position on the device's screen,
    the `TOUCH_MOVE` event is dispatched, and any bubble associated with that contact
    point is re-positioned to match the finger's position.
  prefs: []
  type: TYPE_NORMAL
- en: While this recipe has concentrated on the use of `TOUCH_MOVE` to perform dragging,
    the event can be applied to many other tasks. For example, it could be used to
    track finger movement for a paint application or to trace a path for a game character
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: If you are implementing dragging within your app, it is recommended that you
    use `startTouchDrag()` and `stopTouchDrag()` instead, which has performance benefits
    over listening for `TOUCH_MOVE` events. However, now that you are comfortable
    working with the `TOUCH_MOVE` event, you should be able to put it to various other
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting the touch point input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dragging multiple display objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the gesture input mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with handling simple multi-touch events, AIR for iOS provides support
    for gestures such as zoom, rotation, and swipe. A gesture is a single event that
    is made up from a sequence of simpler multi-touch events. Although you can capture
    multi-touch events and translate them into gestures yourself, the Flash platform
    also provides support for the most common ones, reducing your workload.
  prefs: []
  type: TYPE_NORMAL
- en: In order to receive gesture events, you must select the appropriate input mode.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Flash Professional, open `chapter5\recipe5\recipe.fla` from the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting on the stage is a dynamic text field named `output`. We will write some
    code to enable gesture input and write the success or failure of the request to
    the text field.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following two import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now within the constructor, add some code to enable gesture support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class file as `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA file to your iOS device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the app, the following text should be output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**inputMode = gesture**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Flash provides various multi-touch input modes, which determine the type of
    events your application can receive. In order to receive gesture events, you need
    to set the `Multitouch.inputMode` property to `MultitouchInputMode.GESTURE`. The
    following is the line of code from your document class that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to setting `Multitouch.inputMode`, you can also query it to determine
    the currently selected input mode. In this recipe''s code example, the current
    input mode is written to the `output` text field to confirm that it was successfully
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Although Flash provides gesture support across all iOS devices, when writing
    cross-platform code you may want to confirm support by checking the `Multitouch.supportsGestureEvents`
    property. In our code example, this is done before setting the input mode.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that when the input mode is set for handling gestures you
    will be unable to receive basic touch events from the `TouchEvent` class. If you
    need to receive both touch and gesture events at the same time, then you will
    need to select the `MultitouchInputMode.TOUCH_POINT` input mode and capture multiple
    touch events before synthesizing them into gesture events yourself.
  prefs: []
  type: TYPE_NORMAL
- en: For more information regarding the gesture input mode, perform a search for
    `flash.ui.Multitouch` and `flash.ui.MultitouchInputMode` within Adobe Community
    Help.
  prefs: []
  type: TYPE_NORMAL
- en: Apple places a lot of importance on the correct use of gestures in order to
    provide consistency across applications. Apple's iOS Human Interface Guidelines
    contains a list of standard gestures and the actions users typically perform with
    them. When supporting gestures within your own applications, try not to deviate
    from the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are some additional details regarding gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Available gesture events and types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the input mode for gestures allows you to listen for gesture-specific
    events being dispatched by objects of type `InteractiveObject` or objects that
    inherit `InteractiveObject`, such as `Sprite, MovieClip`, and `Stage`.
  prefs: []
  type: TYPE_NORMAL
- en: As with touch point input, gestures can also take advantage of multiple touch
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following gesture events are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GestureEvent.GESTURE_TWO_FINGER_TAP:` Dispatched when two fingers are used
    to tap the screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_PAN:` An attempt is made to move content that
    is typically too large to fit on screen. The pan gesture is fired when two fingers
    are being moved across on-screen content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_ROTATE:` Dispatched when two touch points are
    rotated around each other. This gesture is typically used to rotate on-screen
    content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_SWIPE:` A quick stroke of a finger across the
    screen. Swipe gestures are commonly used to scroll lists or quickly flick between
    pages of information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TransformGestureEvent.GESTURE_ZOOM:` Two touch points are either being moved
    towards or away from one another. This gesture is commonly used to zoom on-screen
    content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will see some of these events in action throughout the remainder of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the supported gestures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can obtain a list of gestures supported by your iOS device using the static
    `Multitouch.supportedGestures` property. A vector array of strings will be returned,
    where each string represents a gesture event.
  prefs: []
  type: TYPE_NORMAL
- en: Mouse events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default input mode is `MultitouchInputMode.NONE`, which specifies that all
    user interaction with a touch-enabled device is interpreted as a mouse event.
    However, unlike `MultitouchInputMode.GESTURE` and `MultitouchInputMode.TOUCH_POINT`,
    only a single touch point can be processed at any one time.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when the input mode is set to `MultitouchInputMode.GESTURE`, you can
    continue to listen for and respond to mouse events provided by `flash.events.MouseEvents`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in ADL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is most likely that testing this recipe''s code within ADL will result in
    the following message being output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gesture events not supported.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all desktop computers or operating systems support gesture-based events.
    When using gestures within your code, it is advisable that you test directly on
    an iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Handling user interaction,*Chapter 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting the touch point input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handling a swipe gesture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Panning an object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a swipe gesture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The introduction of touch-screens has made the process of moving between pages
    of information more natural. The iPhone made simple touch gestures, such as swiping,
    popular. For example, many photo viewer applications allow the user to quickly
    flick their finger across the screen in order to view the next image in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The `TransformGestureEvent.GESTURE_SWIPE` event is available, allowing both
    vertical and horizontal swiping gestures to be detected and acted upon.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Flash Professional, open `chapter5\recipe6\recipe.fla` from the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting on the stage is a container movie clip named `content`, which is over
    twice the width of the stage. Inside the container are two distinct bubbles, with
    only a single bubble able to fit on screen at any one time. We will write code
    to let the user swipe horizontally between the two bubbles.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to listen for and respond to a horizontal swipe
    gesture:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code within the class'' constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the swipe gesture''s event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class file as `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quickly swipe your finger from right to left to move to the second bubble, and
    left to right to move back to the first.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gesture events can be dispatched by any `InteractiveObject` or sub-class of
    `InteractiveObject`, such as `Sprite, MovieClip`, and `Stage.`
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we took advantage of the gesture input mode to listen for and
    respond to `TransformGestureEvent.GESTURE_SWIPE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for gesture-based input was enabled with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A listener was then added for the `GESTURE_SWIPE` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice the listener was actually added to the stage, allowing the user to swipe
    anywhere on screen and not just on the `content` movie clip.
  prefs: []
  type: TYPE_NORMAL
- en: It is within the `swipe()` handler where we respond to the user's swipe gesture
    and slide the `content` movie clip either to its far-left or far-right.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide which direction to slide the movie clip, we inspect the `TransformGestureEvent`
    object''s `offsetX` property. A value of `1` indicates that the user swiped to
    the right, whereas a value of `-1` indicates the user swiped to the left. You
    can see the code for this highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally the actual scrolling of the content is performed. The `fl.transitions.Tween`
    class is used to slide the `content` movie clip into position. To perform a gradual
    acceleration and deceleration during the sliding transition, the `fl.motion.easing.Sine`
    class was used. Refer to Adobe Community Help for more information regarding these
    two classes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following is one more property of `TransformGestureEvent` that is relevant
    to swipe gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Swiping vertically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it wasn't covered in this recipe's example code, you can just as easily
    detect a vertical swipe by querying the event's `offsetY` property. A value of
    `-1` will be returned for an upwards swipe, whereas `1` will be returned for a
    downwards swipe.
  prefs: []
  type: TYPE_NORMAL
- en: Although both horizontal and vertical swiping motions are represented by separate
    properties, AIR for iOS does not support diagonal swiping gestures. A user can
    either swipe horizontally or vertically.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting the gesture input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Panning an object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panning an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the size constraints of screens on iOS devices, such as the iPhone and
    iPod touch, a user may need to pan or scroll to reveal content that is sitting
    out of view. The Flash platform provides the `TransformGestureEvent.GESTURE_PAN`
    event that you can listen for in order to detect a pan gesture on any interactive
    object. The gesture is initiated by the user placing two fingers on an object
    then sliding them across the screen to move it.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to take advantage of the pan gesture in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Flash Professional, open `chapter5\recipe7\recipe.fla` from the book's
    accompanying code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Sitting on the stage is a movie clip named `bubble`, which is too large to fit
    fully on screen. We will write some ActionScript to let the user pan the movie
    clip in order to see parts that are hidden from view.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a document class and name it `Main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following three import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Within the constructor, set the input mode and listen for `TransformGestureEvent.GESTURE_PAN:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a handler for the `GESTURE_PAN` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class file as `Main.as`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Touch the on-screen bubble with two fingers then slide them across the screen
    to pan the content.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to respond to a panning gesture, a listener for `TransformGestureEvent.GESTURE_PAN`
    was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GESTURE_PAN` event is repeatedly dispatched as the user slides both fingers
    across the screen. The actual panning of the content takes place within the `pan()`
    event handler. Here, we use the `offsetX` and `offsetY` properties of the `TransformGestureEvent`
    object that was passed to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Together, both properties provide the horizontal and vertical distance that
    the user's fingers have travelled since the last `GESTURE_PAN` event. We simply
    use these offsets to reposition the `bubble` movie clip.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, perform a search for `flash.events.TransformGestureEvent`
    within Adobe Community Help.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are a couple of final things regarding panning, including a property
    of the `TransformGestureEvent` class that you may find of interest.
  prefs: []
  type: TYPE_NORMAL
- en: Gesture phases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some gesture events are split into three distinct phases known as beginning,
    update, and end. If your application is required to respond to a gesture event's
    individual phase, then you can query the event's `phase` property. Each phase
    is represented by a constant provided by the `flash.events.GesturePhase` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when a user is panning on-screen content, the `GESTURE_PAN` event
    will go through each of these phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GesturePhase.BEGIN:` The user touches the screen with both fingers and starts
    to move them across the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GesturePhase.UPDATE:` The user is moving both fingers across the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GesturePhase.END:` The user lifts one or both fingers from the screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us look at a simple example where the `bubble` movie clip from this recipe
    is expanded in size at the beginning of a gesture phase, then shrinks back to
    its original size at the end. During the update phase, the user will be able to
    pan the content as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Make the changes to your code and add an import statement for `flash.events.GesturePhase`.
    Deploy the IPA to your device and try panning the on-screen content to get a feel
    of it when each of the gesture's phases occur.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can carry your code from this recipe into the next. If you have made the
    changes above, then remove them before continuing as they aren't required.
  prefs: []
  type: TYPE_NORMAL
- en: Neither the swipe nor two-finger tap gesture have multiple phases. When working
    with either of these gestures, the `phase` property will always return `GesturePhase.ALL`.
  prefs: []
  type: TYPE_NORMAL
- en: Single finger panning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GESTURE_PAN` event only detects panning that is initiated and controlled
    using two fingers. Single finger panning, which is the expected behavior on iOS,
    can be achieved using the `startTouchDrag()` and `stopTouchDrag()` methods provided
    by `flash.display.Sprite`. For details refer to the *Dragging multiple display
    objects* recipe earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting the gesture input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dragging multiple display objects*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rotating an object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rotation is another popular gesture used within iOS apps. It is performed by
    placing two fingers on your device's screen and rotating either one contact point
    around the other, or both around each other. To allow the rotation of content,
    you can listen for and respond to the `TransformGestureEvent.GESTURE_ROTATE` event.
  prefs: []
  type: TYPE_NORMAL
- en: We will continue from the *Panning an object* recipe and add the ability to
    rotate the on-screen content.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already done so, complete the *Panning an object* recipe before
    proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    open `chapter5\recipe8\recipe.fla` from the book's accompanying code bundle and
    work from there. You will also find the FLA's document class in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps within the FLA''s document class:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the constructor, listen for `TransformGestureEvent.GESTURE_ROTATE:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a handler that responds to the event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and test it on your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to rotate the on-screen content as well as being able
    to pan it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are testing on an older device, then you may find that the app performs
    poorly with the frame rate falling quite short of its target. This will be particularly
    true if you are developing with Flash Professional CS5\. Don't worry; there are
    ways to dramatically improve the performance, which we will cover in [Chapter
    6](ch06.html "Chapter 6. Graphics and Hardware Acceleration"),*Graphics and Hardware
    Acceleration.*
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Only a few simple steps were required to add rotation support.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a listener for the `TransformGestureEvent.GESTURE_ROTATE` event was
    added to the `bubble` movie clip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the actual event handler queried the event''s `rotation` property
    in order to determine how much to rotate the movie clip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `rotation` property specifies the change in rotation, measured in degrees,
    since the previous gesture event. This value was then added to the bubble's current
    angle of rotation in order to correctly update it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting the gesture input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Zooming an object*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final gesture we will look at in this chapter is "zoom", which allows a
    user to scale content. It is typically performed by pinching the screen with two
    fingers. Drawing your fingers closer will zoom-out while pulling them apart will
    zoom-in. The Flash platform provides the `TransformGestureEvent.GESTURE_ZOOM`
    event that you can listen for and respond to.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you haven't already done so, complete the *Rotating an object* recipe before
    performing this one.
  prefs: []
  type: TYPE_NORMAL
- en: You can continue to work with the code you wrote during that recipe. Alternatively,
    work from the FLA and document class found in the book's accompanying code bundle
    at `chapter5\recipe9\`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make these changes to the FLA''s document class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the constructor, listen for the `GESTURE_ZOOM` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add an event handler for the zoom gesture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the class file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the FLA and deploy the IPA to your device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now be able to pan, rotate, and zoom the bubble using the gestures
    provided by the Flash platform.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are testing on an older device, then you may find that the app performs
    poorly with the frame rate falling quite short of its target. This will be particularly
    true if you are developing with Flash Professional CS5\. Don't worry; there are
    ways to dramatically improve the performance, which we will cover in [Chapter
    6](ch06.html "Chapter 6. Graphics and Hardware Acceleration"),*Graphics and Hardware
    Acceleration.*
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the other gestures covered in this chapter, implementing pinch zoom
    isn't difficult.
  prefs: []
  type: TYPE_NORMAL
- en: An event listener for `TransformGestureEvent.GESTURE_ZOOM` was added followed
    by the event's handler, which was responsible for actually zooming into the `bubble`
    movie clip.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the line of code that was used to register the listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can see the bubble''s `scaleX` and `scaleY` properties being set within
    the `zoom()` event handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `TransformGestureEvent` object's `scaleX` and `scaleY` properties specify
    the change in horizontal and vertical scale since the previous gesture event.
    To apply these values to a display object, simply multiply the display object's
    `scaleX` and `scaleY` properties with the event object's `scaleX` and `scaleY`
    properties respectively. You can see this being done in the code earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be immediately obvious, but the bubble's library symbol has its registration
    point set at its center. When scaling content, make sure the artwork within your
    container clip is centered otherwise the user may be presented with unexpected
    behavior when performing a zoom gesture.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting the gesture input mode*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using Cache as Bitmap Matrix, [Chapter 6](ch06.html "Chapter 6. Graphics and
    Hardware Acceleration")*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
