- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating Colorful Kaleidoscope Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how we can animate colors with a modifier called
    `hueRotation`, where “hue” refers to the colors of the object, and “rotation”
    refers to the colors being rotated or animated. We will create a simple project
    that displays various images and then, using `hueRotation`, we can change or shift
    the colors of the images so that they will resemble somewhat of a kaleidoscope
    effect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Along with `hueRotation`, there are some other important concepts we will explore
    in this project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We will work with a Picker view for the first time, which is exactly what the
    name suggests; it lets the user pick from a variety of options, which can then
    be displayed on the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will look at how to pass data bidirectionally to another view. If you
    remember the moving circle project in [*Chapter 3*](B18674_03.xhtml#_idTextAnchor048),
    it was built inside one file and then within one view, the `ContentView`. In [*Chapter
    4*](B18674_04.xhtml#_idTextAnchor060), we built the record player using several
    files and then put those files together inside the `ContentView`. In both of those
    projects, we didn’t pass any data from file to file or view to view; the views
    contained blocks of code that just needed to be called in the main `ContentView`.
    But in this project, we will see how to pass data from different views using a
    special property wrapper called `@Binding`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s lay out the objectives before we dive in:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Binding variable and images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Picker control and using a `ForEach` view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the variables and background color
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Image view and using the `hueRotation` modifier
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the completed project and the images we will use in the `Chapter
    5` folder over on GitHub at [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Binding variable and images
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let’s get started. So, create a new Xcode project, give it a name, and
    we will get underway.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by adding a new SwiftUI file to the project, which I’ll call
    `selectedImage`, and make it of the `String` type. We will prefix this variable
    with the **@Binding** wrapper, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@Binding` property wrapper is used to create a two-way binding between
    a source of truth (for example, a state property in a parent view) and a view
    that depends on that state. This `ImagePickerView` is the source of truth as it’s
    the parent view here. The `@Binding` wrapper allows a view to read and write to
    a value, but also makes sure that any changes made to the value are propagated
    back to the original source of truth. This is how views can be updated and re-rendered
    automatically whenever the source of truth changes, without having to manually
    pass down new values and refresh the view.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add some images that we need to the project. You can find them in
    the GitHub repository – just download the resources for this chapter. There are
    five images: `ornament`, `landscape`, `dog`, `dice`, and `cat`. Open the Assets
    catalog and drop the five images into the catalog (just like we did when creating
    the record player).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将需要的图片添加到项目中。你可以在GitHub仓库中找到它们——只需下载本章的资源。共有五张图片：`ornament`、`landscape`、`dog`、`dice`和`cat`。打开资产目录，将这五张图片拖放到目录中（就像我们创建唱片机时做的那样）。
- en: 'With the images in place, let’s create an array of strings that can hold the
    names of the images. Here is the code, which gets placed under the `@Binding`
    property:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了图片之后，让我们创建一个字符串数组来存储图片的名称。以下是代码，它被放置在`@Binding`属性下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To create the array, we first give it a name, `images`, then use the `String`
    keyword within square brackets, then another pair of square brackets in which
    we fill the `images` array with five `String` elements, which are the names of
    the images we want to use. Each string is separated by a comma.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数组，我们首先给它一个名字，`images`，然后在方括号内使用`String`关键字，然后在另一对方括号中填充`images`数组，包含我们想要使用的五个`String`元素，即图片的名称。每个字符串之间用逗号分隔。
- en: Now the `images` array is ready to use. Let’s add a Picker control and see how
    we can loop through this array using a `ForEach` view to store each string name
    in the picker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`images`数组已经准备好了，让我们添加一个选择控件，看看我们如何使用`ForEach`视图遍历这个数组，将每个字符串名称存储在选择视图中。
- en: Adding a Picker control and using a ForEach view
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加选择控件和使用`ForEach`视图
- en: SwiftUI offers us a sufficient number of pre-built controls to help put together
    a user interface that is both nice to look at and very functional. One control
    that is useful for providing your user with a list of options is the **Picker
    view**, which can provide as few or as many values as you need to display for
    your app. A Picker view is a view that lets the user select an item from a list
    of options and is usually used together with a Binding variable, which will store
    the currently selected value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI为我们提供了足够多的预构建控件，以帮助构建既美观又实用的用户界面。一个有用的控件是用于向用户提供选项列表的**选择视图**，它可以提供你所需要的显示在应用中的任意数量的值。选择视图是一个允许用户从选项列表中选择一个项目的视图，通常与一个`Binding`变量一起使用，该变量将存储当前选中的值。
- en: 'We will be using a `forEach` view to iterate through the `images` array and
    populate the picker. Working in the `body` property, let’s add the `PickerView`
    first, and a `ForEach` view inside the picker:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`forEach`视图遍历`images`数组，并填充选择视图。在`body`属性中工作，我们首先添加`PickerView`，然后在选择视图中添加一个`ForEach`视图：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, there’s a lot going on here, so let’s break it down. Quick note though:
    don’t worry about the preview struct below the `ImagePickerView` just yet; that’s
    going to show an error, but we’ll fix that in a moment.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里有很多内容，所以让我们分解一下。不过，快速提醒一下：不要担心在`ImagePickerView`下面的预览结构；那将显示一个错误，但我们很快就会修复它。
- en: For the Picker’s first parameter, you’ll notice there’s an empty `String` value.
    The string will allow you to give the Picker a label if you think it needs one;
    however, we do not need it here so we’re leaving the `String` parameter empty.
    Inside the next parameter, called `selection`, is where the `selectedImage` binding
    property will go, and this property will bind to a `State` property in the `ContentView`
    later. We haven’t added any State properties in the `ContentView` yet, but we
    will soon.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择视图的第一个参数，你会注意到有一个空的`String`值。这个字符串将允许你为选择视图提供一个标签，如果你认为需要的话；然而，在这里我们不需要它，所以我们留空了`String`参数。在下一个参数，称为`selection`的参数中，`selectedImage`绑定属性将被放置，并且这个属性将绑定到`ContentView`中的`State`属性。我们还没有在`ContentView`中添加任何`State`属性，但我们很快就会这么做。
- en: Now the `selectedImage` property in this `ImagePickerView` file will be bidirectionally
    connected to a State property in the `ContentView`. That connection allows for
    the instant refreshing of views between those two structs when the value changes
    in either struct.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个`ImagePickerView`文件中的`selectedImage`属性将双向连接到`ContentView`中的`State`属性。这种连接允许当任一结构中的值发生变化时，这两个结构之间的视图立即刷新。
- en: The syntax does require that we put the dollar sign (`$`) before the property
    in order to tell SwiftUI that this property is a binding property and can connect
    to the `ContentView` (the source of truth) and update the views.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 语法要求我们在属性前放置美元符号（`$`），以便告诉SwiftUI这个属性是一个绑定属性，可以连接到`ContentView`（事实来源）并更新视图。
- en: The next line of code is the `ForEach` view. What we want to do is loop through
    the `images` array and display all those String labels of that array in the `Picker`
    view. In order to loop through the array of strings, they need to have some sort
    of ID that identifies each element in this array uniquely. And since they all
    have different names, why not use the names of each element, which already constitute
    unique IDs? To use each image’s name as an ID for the loop, we used the `\.self`
    syntax, placed after the `images` array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The `value` keyword in this code is the looping variable; it will store each
    element from the `images` array as the `ForEach` view loops through them. This
    looping variable can be named anything you like, but I called it `value` in this
    example as that makes the most sense (it temporarily holds the value of each element
    in the array, one at a time).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Now looking at the code in the `ForEach` view’s body, we only need to add one
    `Text` view with the `value` variable inside it. That will display everything
    that is in the `images` array in the `PickerView`. Next, we change the color of
    the text to white using the `foregroundColor` modifier. We do this because when
    we go into the `ContentView` file, we will make the screen’s background black;
    that way, we’ll see the white letters over the black background.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the `Picker` view functionality; let’s now style the appearance
    of the `Picker` view by adding some modifiers to it after the view’s closing bracket:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s look at each of the modifiers used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The first modifier I’ve added is `pickerStyle()`, which is used to change the
    appearance of the `Picker` view. There are four built-in styles we can select
    from to style the Picker using the `pickerStyle()` modifier. The following are
    the ones available:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultPickerStyle()`: The default style that is chosen automatically by the
    system based on the platform and current context. This presents the choices to
    the user in a menu style.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopUpButtonPickerStyle()`: This is a pop-up button-style picker, often used
    on macOS. This presents the choices in a button style to the user.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WheelPickerStyle()`: A wheel-style picker, often used on iOS. This presents
    the choices in a wheel style to the user.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SegmentedPickerStyle()`: A segmented control-style picker, commonly used on
    iOS, watchOS, and tvOS. This presents the choices in the style of a segmented
    button to the user.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We chose the `WheelPickerStyle` for this project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The second modifier is the `frame` modifier, which sets the dimensions of the
    picker control. Here, we set the dimensions as `300` points wide and `150` points
    tall.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the `background` modifier, which sets the background color of the picker
    to red. `colorMultiply` then modifies the red color instance by multiplying its
    RGB values with those of another color, blue in this case. The result is a dark
    shade of purple.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we used the `cornerRadius` modifier to round the corners of the
    picker by 20 points.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finish styling the picker using the `shadow` modifier. This will add a white
    shadow with a radius of 5 points and will be visible when we change the background
    to black.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s return to the error that our code is experiencing and see how we
    can make sure the app builds cleanly. The error says that we are missing an argument
    from the `ImagePickerView`’s call. And that’s true, because we added a `Binding`
    property into the `ImagePickerView` struct called `selectedImage`, and since the
    `Preview` struct is referencing the `ImagePickerView`, it needs to use that `Binding`
    variable in itself too in order to build cleanly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we need to go into the `Previews` struct at the bottom
    of the file and change the first line of code to this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using the `constant` function, the error goes away. The `constant` function
    will accept any value we want as long as it’s of the String type, because that’s
    the data type of the `selectedImage` property. I’m using the `"ornament"` string
    from the `images` array, and that string will be shown in the picker.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the code builds cleanly, the result should look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Picker View  ](img/B18674_05_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Picker View'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Spin the wheel picker and you can see all of the string names from the `images`
    array.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the `ImagePickerView` file, let’s continue by setting
    up the `ContentView` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables and background color
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving into the `ContentView` file now, our first task here will be to add a
    couple of variables and a constant. Let’s start with adding a variable that will
    bind to the `selectedImage` binding property in the `ImagePickerView` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to create a `State` variable, which needs to be the same
    data type as the `selectedImage` variable, a `String` type. We can give it the
    same name as the variable too, `selectedImage`, so that you know this variable
    is bidirectionally linked to the variable in the `ImagePickerView` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code inside the `ContentView` struct, at the top:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `selectedImage` variable gets set to a String value called `ornament`. Next
    is a variable to track the animation called `shiftColors`, which is set to `false`.
    Finally, we have a constant to hold the background color, which will be black.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `body` property, let’s add a `VStack`, which will take care
    of vertically organizing three views that the user interface needs: a background,
    which will be black; an `Image` view, to display the image selected by the user;
    and a call to the `ImagePickerView` that we created in the `ImagePickerView` file,
    which allows the user to select an image.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'To do all of this, first add a `VStack` into the `body` property of the `ContentView`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add the `ImagePickerView` into the `VStack` with the `frame` modifier
    on it, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To color the background, we need a `ZStack` so it can overlay the color onto
    the whole screen. Add this code inside the `VStack`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we have seen before, this code will color the background black, and by using
    the `scaleEffect` modifier and passing in the value of `1.4`, the black background
    will stretch out so it covers the entire screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Now that the background is set, let’s add an `Image` view to display the images,
    and then start animating some colors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Image view and using the hueRotation modifier
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the background set up and all of the variables in place, let’s add an `ImageView`
    to display the images, and add the `hueRotation` modifier to it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code right after the `scaleEffect` modifier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we are using the Image view to display the images on the screen, resizing
    it and adding a little padding to it. Then we set the frame of the image view
    to a size of `400` by `400`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the `hueRotation` modifier. Hue rotation is an image-processing effect
    that adjusts the hue of an image by rotating the colors in the hue color wheel
    by a specified angle. It changes the overall color tone of an image by shifting
    the hue of each pixel.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: The speed at which it does this is determined by the values that get passed
    into its parameter. And if you have an image with many different colors, then
    `hueRotation` will cycle through and rotate all of them, creating a sort of kaleidoscope
    color effect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `hueRotation` parameter, it needs a value to represent degrees,
    which is for the amount of rotation to apply to the colors in this view, and that
    is handled by the `degrees` function. Inside the `degrees` function is a ternary
    operator, which will select from two choices: either a value of `360` when the
    `shiftColors` variable is `true`, or `0` when it is `false`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `animation` modifier is added to animate to the color-changing effect.
    It uses an `easeInOut` timing curve with a duration of 2 seconds to complete the
    animation and a delay of 0.3 seconds between animations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the `onAppear` modifier, which runs the code within its body as
    soon as the view appears. This is a perfect place to trigger the animation by
    toggling the `shiftColors` variable to its opposite value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set a frame width and height of `350` by `200` for the `ImagePickerView`
    and colored the background of the `VStack` by using our `background` variable.
    We also used `edgesIgnoringSafeArea` for the bottom edges, so the background color
    will go below the screen. We want the whole screen black with our views on top
    of it, and this code does just that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Guess what? With all that finished, the project is done! Here’s what it should
    look like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Finished project ](img/B18674_05_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Finished project'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the project – you’ll see that the colors from your selected
    image will all shift and rotate over the span of 2 seconds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good work on completing the project! As you worked through it, you got to see
    how to use a `Binding` property so data can be bound between views, the `Picker`
    view, a view with different styles that allows users to select an image or other
    data, and finally the `hueRotation` modifier, which rotates colors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作，完成了这个项目！在完成的过程中，你看到了如何使用`Binding`属性来在视图之间绑定数据，`Picker`视图，一个具有不同样式的视图，允许用户选择图片或其他数据，最后是`hueRotation`修饰符，它可以旋转颜色。
- en: In the next chapter, we will explore the process of cutting up an image into
    different parts, then rotating those separate parts using the `rotationEffect`
    modifier, to create an animation of a girl on a swing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将图像切割成不同部分的过程，然后使用`rotationEffect`修饰符旋转这些单独的部分，以创建一个女孩在秋千上的动画。
