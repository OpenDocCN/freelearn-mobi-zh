- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Animating Colorful Kaleidoscope Effects
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画彩色万花筒效果
- en: In this chapter, we will look at how we can animate colors with a modifier called
    `hueRotation`, where “hue” refers to the colors of the object, and “rotation”
    refers to the colors being rotated or animated. We will create a simple project
    that displays various images and then, using `hueRotation`, we can change or shift
    the colors of the images so that they will resemble somewhat of a kaleidoscope
    effect.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何使用名为 `hueRotation` 的修改器来动画化颜色，其中“色调”指的是对象的颜色，“旋转”指的是正在旋转或动画化的颜色。我们将创建一个简单的项目来显示各种图像，然后使用
    `hueRotation`，我们可以改变或移动图像的颜色，使其呈现出类似万花筒的效果。
- en: Along with `hueRotation`, there are some other important concepts we will explore
    in this project.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `hueRotation`，我们还将探讨在这个项目中的一些其他重要概念。
- en: We will work with a Picker view for the first time, which is exactly what the
    name suggests; it lets the user pick from a variety of options, which can then
    be displayed on the screen.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将第一次使用选择器视图，正如其名称所暗示的那样；它允许用户从各种选项中进行选择，然后这些选项可以显示在屏幕上。
- en: Also, we will look at how to pass data bidirectionally to another view. If you
    remember the moving circle project in [*Chapter 3*](B18674_03.xhtml#_idTextAnchor048),
    it was built inside one file and then within one view, the `ContentView`. In [*Chapter
    4*](B18674_04.xhtml#_idTextAnchor060), we built the record player using several
    files and then put those files together inside the `ContentView`. In both of those
    projects, we didn’t pass any data from file to file or view to view; the views
    contained blocks of code that just needed to be called in the main `ContentView`.
    But in this project, we will see how to pass data from different views using a
    special property wrapper called `@Binding`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将看看如何双向传递数据到另一个视图。如果你还记得[*第 3 章*](B18674_03.xhtml#_idTextAnchor048)中的移动圆圈项目，它是在一个文件中构建的，然后在一个视图
    `ContentView` 中，而在[*第 4 章*](B18674_04.xhtml#_idTextAnchor060)中，我们使用几个文件构建了唱片机，然后将这些文件组合在
    `ContentView` 中。在这两个项目中，我们都没有从文件到文件或视图到视图传递任何数据；视图包含了一些只需要在主 `ContentView` 中调用的代码块。但在这个项目中，我们将看到如何使用一个称为
    `@Binding` 的特殊属性包装器在不同视图之间传递数据。
- en: 'So, let’s lay out the objectives before we dive in:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们深入之前，让我们先列出目标：
- en: Adding the Binding variable and images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加绑定变量和图像
- en: Adding a Picker control and using a `ForEach` view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加选择器控件和使用 `ForEach` 视图
- en: Adding the variables and background color
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加变量和背景颜色
- en: Adding the Image view and using the `hueRotation` modifier
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加图像视图和使用 `hueRotation` 修改器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the completed project and the images we will use in the `Chapter
    5` folder over on GitHub at [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上的 `Chapter 5` 文件夹中找到完成的项目和我们将使用的图像，网址为 [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications)。
- en: Adding the Binding variable and images
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加绑定变量和图像
- en: Okay, let’s get started. So, create a new Xcode project, give it a name, and
    we will get underway.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始吧。所以，创建一个新的 Xcode 项目，给它起个名字，然后我们就可以开始了。
- en: 'We will start by adding a new SwiftUI file to the project, which I’ll call
    `selectedImage`, and make it of the `String` type. We will prefix this variable
    with the **@Binding** wrapper, as shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向项目中添加一个新的 SwiftUI 文件，我将称之为 `selectedImage`，并将其类型设置为 `String`。我们将在这个变量前加上
    `@Binding` 包装器，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `@Binding` property wrapper is used to create a two-way binding between
    a source of truth (for example, a state property in a parent view) and a view
    that depends on that state. This `ImagePickerView` is the source of truth as it’s
    the parent view here. The `@Binding` wrapper allows a view to read and write to
    a value, but also makes sure that any changes made to the value are propagated
    back to the original source of truth. This is how views can be updated and re-rendered
    automatically whenever the source of truth changes, without having to manually
    pass down new values and refresh the view.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Binding` 属性包装器用于在真实来源（例如，父视图中的状态属性）和依赖于该状态的视图之间创建双向绑定。在这个例子中，`ImagePickerView`
    是真实来源，因为它在这里是父视图。`@Binding` 包装器允许视图读取和写入值，同时确保对值所做的任何更改都会传播回原始的真实来源。这就是视图如何在真实来源更改时自动更新和重新渲染，而无需手动传递新值并刷新视图。'
- en: 'Let’s now add some images that we need to the project. You can find them in
    the GitHub repository – just download the resources for this chapter. There are
    five images: `ornament`, `landscape`, `dog`, `dice`, and `cat`. Open the Assets
    catalog and drop the five images into the catalog (just like we did when creating
    the record player).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将需要的图片添加到项目中。你可以在GitHub仓库中找到它们——只需下载本章的资源。共有五张图片：`ornament`、`landscape`、`dog`、`dice`和`cat`。打开资产目录，将这五张图片拖放到目录中（就像我们创建唱片机时做的那样）。
- en: 'With the images in place, let’s create an array of strings that can hold the
    names of the images. Here is the code, which gets placed under the `@Binding`
    property:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了图片之后，让我们创建一个字符串数组来存储图片的名称。以下是代码，它被放置在`@Binding`属性下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To create the array, we first give it a name, `images`, then use the `String`
    keyword within square brackets, then another pair of square brackets in which
    we fill the `images` array with five `String` elements, which are the names of
    the images we want to use. Each string is separated by a comma.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数组，我们首先给它一个名字，`images`，然后在方括号内使用`String`关键字，然后在另一对方括号中填充`images`数组，包含我们想要使用的五个`String`元素，即图片的名称。每个字符串之间用逗号分隔。
- en: Now the `images` array is ready to use. Let’s add a Picker control and see how
    we can loop through this array using a `ForEach` view to store each string name
    in the picker.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`images`数组已经准备好了，让我们添加一个选择控件，看看我们如何使用`ForEach`视图遍历这个数组，将每个字符串名称存储在选择视图中。
- en: Adding a Picker control and using a ForEach view
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加选择控件和使用`ForEach`视图
- en: SwiftUI offers us a sufficient number of pre-built controls to help put together
    a user interface that is both nice to look at and very functional. One control
    that is useful for providing your user with a list of options is the **Picker
    view**, which can provide as few or as many values as you need to display for
    your app. A Picker view is a view that lets the user select an item from a list
    of options and is usually used together with a Binding variable, which will store
    the currently selected value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI为我们提供了足够多的预构建控件，以帮助构建既美观又实用的用户界面。一个有用的控件是用于向用户提供选项列表的**选择视图**，它可以提供你所需要的显示在应用中的任意数量的值。选择视图是一个允许用户从选项列表中选择一个项目的视图，通常与一个`Binding`变量一起使用，该变量将存储当前选中的值。
- en: 'We will be using a `forEach` view to iterate through the `images` array and
    populate the picker. Working in the `body` property, let’s add the `PickerView`
    first, and a `ForEach` view inside the picker:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`forEach`视图遍历`images`数组，并填充选择视图。在`body`属性中工作，我们首先添加`PickerView`，然后在选择视图中添加一个`ForEach`视图：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Okay, there’s a lot going on here, so let’s break it down. Quick note though:
    don’t worry about the preview struct below the `ImagePickerView` just yet; that’s
    going to show an error, but we’ll fix that in a moment.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里有很多内容，所以让我们分解一下。不过，快速提醒一下：不要担心在`ImagePickerView`下面的预览结构；那将显示一个错误，但我们很快就会修复它。
- en: For the Picker’s first parameter, you’ll notice there’s an empty `String` value.
    The string will allow you to give the Picker a label if you think it needs one;
    however, we do not need it here so we’re leaving the `String` parameter empty.
    Inside the next parameter, called `selection`, is where the `selectedImage` binding
    property will go, and this property will bind to a `State` property in the `ContentView`
    later. We haven’t added any State properties in the `ContentView` yet, but we
    will soon.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择视图的第一个参数，你会注意到有一个空的`String`值。这个字符串将允许你为选择视图提供一个标签，如果你认为需要的话；然而，在这里我们不需要它，所以我们留空了`String`参数。在下一个参数，称为`selection`的参数中，`selectedImage`绑定属性将被放置，并且这个属性将绑定到`ContentView`中的`State`属性。我们还没有在`ContentView`中添加任何`State`属性，但我们很快就会这么做。
- en: Now the `selectedImage` property in this `ImagePickerView` file will be bidirectionally
    connected to a State property in the `ContentView`. That connection allows for
    the instant refreshing of views between those two structs when the value changes
    in either struct.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个`ImagePickerView`文件中的`selectedImage`属性将双向连接到`ContentView`中的`State`属性。这种连接允许当任一结构中的值发生变化时，这两个结构之间的视图立即刷新。
- en: The syntax does require that we put the dollar sign (`$`) before the property
    in order to tell SwiftUI that this property is a binding property and can connect
    to the `ContentView` (the source of truth) and update the views.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 语法要求我们在属性前放置美元符号（`$`），以便告诉SwiftUI这个属性是一个绑定属性，可以连接到`ContentView`（事实来源）并更新视图。
- en: The next line of code is the `ForEach` view. What we want to do is loop through
    the `images` array and display all those String labels of that array in the `Picker`
    view. In order to loop through the array of strings, they need to have some sort
    of ID that identifies each element in this array uniquely. And since they all
    have different names, why not use the names of each element, which already constitute
    unique IDs? To use each image’s name as an ID for the loop, we used the `\.self`
    syntax, placed after the `images` array.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '下一行代码是`ForEach`视图。我们想要做的是遍历`images`数组，并在`Picker`视图中显示该数组中所有的String标签。为了遍历字符串数组，它们需要有一种某种ID来唯一标识这个数组中的每个元素。由于它们都有不同的名称，为什么不使用每个元素的名称，这些名称已经构成了唯一的ID呢？为了将每个图像的名称用作循环的ID，我们使用了在`images`数组之后放置的`\.self`语法。 '
- en: The `value` keyword in this code is the looping variable; it will store each
    element from the `images` array as the `ForEach` view loops through them. This
    looping variable can be named anything you like, but I called it `value` in this
    example as that makes the most sense (it temporarily holds the value of each element
    in the array, one at a time).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码中的`value`关键字是循环变量；它将存储`ForEach`视图遍历的`images`数组中的每个元素。这个循环变量可以命名为任何你喜欢的名字，但在这个例子中我将其命名为`value`，因为这最有意义（它暂时存储数组中每个元素的值，一次一个）。
- en: Now looking at the code in the `ForEach` view’s body, we only need to add one
    `Text` view with the `value` variable inside it. That will display everything
    that is in the `images` array in the `PickerView`. Next, we change the color of
    the text to white using the `foregroundColor` modifier. We do this because when
    we go into the `ContentView` file, we will make the screen’s background black;
    that way, we’ll see the white letters over the black background.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看`ForEach`视图体内的代码，我们只需要添加一个包含`value`变量的`Text`视图。这将显示`PickerView`中的`images`数组中的所有内容。接下来，我们使用`foregroundColor`修饰符将文本颜色更改为白色。我们这样做是因为当我们进入`ContentView`文件时，我们将屏幕的背景设置为黑色；这样我们就能在黑色背景上看到白色的字母。
- en: 'That completes the `Picker` view functionality; let’s now style the appearance
    of the `Picker` view by adding some modifiers to it after the view’s closing bracket:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了`Picker`视图的功能；现在让我们通过在视图的闭合括号后添加一些修饰符来样式化`Picker`视图的外观：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s look at each of the modifiers used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个使用的修饰符：
- en: 'The first modifier I’ve added is `pickerStyle()`, which is used to change the
    appearance of the `Picker` view. There are four built-in styles we can select
    from to style the Picker using the `pickerStyle()` modifier. The following are
    the ones available:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我添加的第一个修饰符是`pickerStyle()`，它用于更改`Picker`视图的外观。我们可以从四个内置样式中选择来使用`pickerStyle()`修饰符来样式化Picker。以下是可以用的样式：
- en: '`DefaultPickerStyle()`: The default style that is chosen automatically by the
    system based on the platform and current context. This presents the choices to
    the user in a menu style.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DefaultPickerStyle()`: 系统根据平台和当前上下文自动选择的默认样式。这将以菜单风格向用户展示选项。'
- en: '`PopUpButtonPickerStyle()`: This is a pop-up button-style picker, often used
    on macOS. This presents the choices in a button style to the user.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopUpButtonPickerStyle()`: 这是一种弹出按钮样式选择器，常用于macOS。这将以按钮风格向用户展示选项。'
- en: '`WheelPickerStyle()`: A wheel-style picker, often used on iOS. This presents
    the choices in a wheel style to the user.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WheelPickerStyle()`: 一种轮式选择器，常用于iOS。这将以轮式风格向用户展示选项。'
- en: '`SegmentedPickerStyle()`: A segmented control-style picker, commonly used on
    iOS, watchOS, and tvOS. This presents the choices in the style of a segmented
    button to the user.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SegmentedPickerStyle()`: 一种分段控制样式选择器，常用于iOS、watchOS和tvOS。这将以分段按钮的风格向用户展示选项。'
- en: We chose the `WheelPickerStyle` for this project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个项目选择了`WheelPickerStyle`。
- en: The second modifier is the `frame` modifier, which sets the dimensions of the
    picker control. Here, we set the dimensions as `300` points wide and `150` points
    tall.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个修饰符是`frame`修饰符，它设置了选择器控制的尺寸。在这里，我们将尺寸设置为`300`点宽和`150`点高。
- en: Next is the `background` modifier, which sets the background color of the picker
    to red. `colorMultiply` then modifies the red color instance by multiplying its
    RGB values with those of another color, blue in this case. The result is a dark
    shade of purple.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`background`修饰符，它将选择器的背景颜色设置为红色。然后`colorMultiply`通过将红色实例的RGB值与另一种颜色（在这种情况下是蓝色）相乘来修改红色颜色实例。结果是深紫色。
- en: After that, we used the `cornerRadius` modifier to round the corners of the
    picker by 20 points.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们使用了`cornerRadius`修饰符将选择器的角落圆滑到20点。
- en: We finish styling the picker using the `shadow` modifier. This will add a white
    shadow with a radius of 5 points and will be visible when we change the background
    to black.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `shadow` 修改器完成选择器的样式。这将添加一个半径为 5 点的白色阴影，并且当我们将背景色改为黑色时将变得可见。
- en: Now, let’s return to the error that our code is experiencing and see how we
    can make sure the app builds cleanly. The error says that we are missing an argument
    from the `ImagePickerView`’s call. And that’s true, because we added a `Binding`
    property into the `ImagePickerView` struct called `selectedImage`, and since the
    `Preview` struct is referencing the `ImagePickerView`, it needs to use that `Binding`
    variable in itself too in order to build cleanly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的代码正在遇到的错误，看看我们如何确保应用程序可以干净地构建。错误表示我们缺少 `ImagePickerView` 调用的一个参数。这是真的，因为我们向
    `ImagePickerView` 结构体中添加了一个名为 `selectedImage` 的 `Binding` 属性，并且由于 `Preview` 结构体引用了
    `ImagePickerView`，它也需要在自己的结构体中使用那个 `Binding` 变量才能干净地构建。
- en: 'To fix this problem, we need to go into the `Previews` struct at the bottom
    of the file and change the first line of code to this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要进入文件底部的 `Previews` 结构体，并将第一行代码更改为以下内容：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By using the `constant` function, the error goes away. The `constant` function
    will accept any value we want as long as it’s of the String type, because that’s
    the data type of the `selectedImage` property. I’m using the `"ornament"` string
    from the `images` array, and that string will be shown in the picker.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `constant` 函数，错误就会消失。`constant` 函数可以接受任何我们想要的值，只要它是 String 类型，因为 `selectedImage`
    属性的数据类型就是 String。我正在使用 `images` 数组中的 `"ornament"` 字符串，这个字符串将在选择器中显示。
- en: 'Now that the code builds cleanly, the result should look like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码构建干净，结果应该看起来像这样：
- en: '![Figure 5.1: Picker View  ](img/B18674_05_01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：选择器视图](img/B18674_05_01.jpg)'
- en: 'Figure 5.1: Picker View'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：选择器视图
- en: Spin the wheel picker and you can see all of the string names from the `images`
    array.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 拨动选择器轮盘，你可以看到 `images` 数组中的所有字符串名称。
- en: Now that we are done with the `ImagePickerView` file, let’s continue by setting
    up the `ContentView` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `ImagePickerView` 文件，让我们继续设置 `ContentView` 文件。
- en: Adding the variables and background color
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加变量和背景颜色
- en: Moving into the `ContentView` file now, our first task here will be to add a
    couple of variables and a constant. Let’s start with adding a variable that will
    bind to the `selectedImage` binding property in the `ImagePickerView` file.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入 `ContentView` 文件，我们在这里的第一个任务将是添加几个变量和一个常量。让我们从添加一个变量开始，该变量将绑定到 `ImagePickerView`
    文件中的 `selectedImage` 绑定属性。
- en: To do that, we need to create a `State` variable, which needs to be the same
    data type as the `selectedImage` variable, a `String` type. We can give it the
    same name as the variable too, `selectedImage`, so that you know this variable
    is bidirectionally linked to the variable in the `ImagePickerView` file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要创建一个 `State` 变量，它的数据类型需要与 `selectedImage` 变量相同，即 String 类型。我们可以给它与变量相同的名字，`selectedImage`，这样你就知道这个变量是双向链接到
    `ImagePickerView` 文件中的变量。
- en: 'Add this code inside the `ContentView` struct, at the top:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ContentView` 结构体中添加此代码，在顶部：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `selectedImage` variable gets set to a String value called `ornament`. Next
    is a variable to track the animation called `shiftColors`, which is set to `false`.
    Finally, we have a constant to hold the background color, which will be black.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`selectedImage` 变量被设置为名为 `ornament` 的 String 值。接下来是一个名为 `shiftColors` 的变量，用于跟踪动画，其设置为
    `false`。最后，我们有一个常量来保存背景颜色，它将是黑色。'
- en: 'Moving into the `body` property, let’s add a `VStack`, which will take care
    of vertically organizing three views that the user interface needs: a background,
    which will be black; an `Image` view, to display the image selected by the user;
    and a call to the `ImagePickerView` that we created in the `ImagePickerView` file,
    which allows the user to select an image.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 `body` 属性，让我们添加一个 `VStack`，它将负责垂直组织用户界面需要的三个视图：一个背景，将是黑色；一个 `Image` 视图，用于显示用户选择的照片；以及一个对我们在
    `ImagePickerView` 文件中创建的 `ImagePickerView` 的调用，允许用户选择照片。
- en: 'To do all of this, first add a `VStack` into the `body` property of the `ContentView`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成所有这些，首先将一个 `VStack` 添加到 `ContentView` 的 `body` 属性中：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add the `ImagePickerView` into the `VStack` with the `frame` modifier
    on it, as shown here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `ImagePickerView` 添加到 `VStack` 中，并在其上应用 `frame` 修改器，如图所示：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To color the background, we need a `ZStack` so it can overlay the color onto
    the whole screen. Add this code inside the `VStack`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了着色背景，我们需要一个 `ZStack`，以便它可以将颜色覆盖整个屏幕。在 `VStack` 中添加此代码：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we have seen before, this code will color the background black, and by using
    the `scaleEffect` modifier and passing in the value of `1.4`, the black background
    will stretch out so it covers the entire screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，此代码将背景着色为黑色，通过使用`scaleEffect`修饰符并传入`1.4`的值，黑色背景将拉伸以覆盖整个屏幕。
- en: Now that the background is set, let’s add an `Image` view to display the images,
    and then start animating some colors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在背景已经设置好了，让我们添加一个`Image`视图来显示图片，然后开始动画一些颜色。
- en: Adding the Image view and using the hueRotation modifier
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Image视图和使用色调旋转修饰符
- en: With the background set up and all of the variables in place, let’s add an `ImageView`
    to display the images, and add the `hueRotation` modifier to it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 背景设置完毕，所有变量都已就绪，现在让我们添加一个`ImageView`来显示图片，并将其`hueRotation`修饰符添加到其中。
- en: 'Add the following code right after the `scaleEffect` modifier:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`scaleEffect`修饰符之后立即添加以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we are using the Image view to display the images on the screen, resizing
    it and adding a little padding to it. Then we set the frame of the image view
    to a size of `400` by `400`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Image`视图在屏幕上显示图片，调整其大小并添加一点内边距。然后我们将图片视图的框架设置为`400` x `400`的大小。
- en: Next comes the `hueRotation` modifier. Hue rotation is an image-processing effect
    that adjusts the hue of an image by rotating the colors in the hue color wheel
    by a specified angle. It changes the overall color tone of an image by shifting
    the hue of each pixel.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`hueRotation`修饰符。色调旋转是一种图像处理效果，通过旋转色调颜色轮中的颜色来调整图像的色调，旋转角度由指定值决定。它通过改变每个像素的色调来改变图像的整体色彩调。
- en: The speed at which it does this is determined by the values that get passed
    into its parameter. And if you have an image with many different colors, then
    `hueRotation` will cycle through and rotate all of them, creating a sort of kaleidoscope
    color effect.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行此操作的速度由传递给其参数的值决定。如果你有一个包含许多不同颜色的图片，那么`hueRotation`将循环并通过旋转所有这些颜色，创建一种类似万花筒的色彩效果。
- en: 'Looking at the `hueRotation` parameter, it needs a value to represent degrees,
    which is for the amount of rotation to apply to the colors in this view, and that
    is handled by the `degrees` function. Inside the `degrees` function is a ternary
    operator, which will select from two choices: either a value of `360` when the
    `shiftColors` variable is `true`, or `0` when it is `false`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`hueRotation`参数，它需要一个表示度的值，这是应用于此视图中颜色的旋转量，由`degrees`函数处理。在`degrees`函数内部是一个三元运算符，它将选择两个选择之一：当`shiftColors`变量为`true`时，值为`360`；当它为`false`时，值为`0`。
- en: Next, the `animation` modifier is added to animate to the color-changing effect.
    It uses an `easeInOut` timing curve with a duration of 2 seconds to complete the
    animation and a delay of 0.3 seconds between animations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加`animation`修饰符以实现颜色变化动画效果。它使用`easeInOut`时间曲线，持续时间为2秒，动画之间有0.3秒的延迟来完成动画。
- en: Then we use the `onAppear` modifier, which runs the code within its body as
    soon as the view appears. This is a perfect place to trigger the animation by
    toggling the `shiftColors` variable to its opposite value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`onAppear`修饰符，它在视图出现时立即运行其体内的代码。这是一个通过切换`shiftColors`变量的相反值来触发动画的完美位置。
- en: After that, we set a frame width and height of `350` by `200` for the `ImagePickerView`
    and colored the background of the `VStack` by using our `background` variable.
    We also used `edgesIgnoringSafeArea` for the bottom edges, so the background color
    will go below the screen. We want the whole screen black with our views on top
    of it, and this code does just that.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为`ImagePickerView`设置了`350` x `200`的框架宽度和高度，并使用我们的`background`变量着色了`VStack`的背景。我们还使用了`edgesIgnoringSafeArea`来处理底部边缘，这样背景颜色就会延伸到屏幕下方。我们希望整个屏幕都是黑色，我们的视图在上面，这段代码正是这样做的。
- en: 'Guess what? With all that finished, the project is done! Here’s what it should
    look like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？所有这些都完成后，项目就完成了！它应该看起来是这样的：
- en: '![Figure 5.2: Finished project ](img/B18674_05_02.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：完成的项目](img/B18674_05_02.jpg)'
- en: 'Figure 5.2: Finished project'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：完成的项目
- en: Go ahead and run the project – you’ll see that the colors from your selected
    image will all shift and rotate over the span of 2 seconds.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行项目——你会看到你选择的图片中的所有颜色将在2秒内改变和旋转。
- en: Summary
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Good work on completing the project! As you worked through it, you got to see
    how to use a `Binding` property so data can be bound between views, the `Picker`
    view, a view with different styles that allows users to select an image or other
    data, and finally the `hueRotation` modifier, which rotates colors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作，完成了这个项目！在完成的过程中，你看到了如何使用`Binding`属性来在视图之间绑定数据，`Picker`视图，一个具有不同样式的视图，允许用户选择图片或其他数据，最后是`hueRotation`修饰符，它可以旋转颜色。
- en: In the next chapter, we will explore the process of cutting up an image into
    different parts, then rotating those separate parts using the `rotationEffect`
    modifier, to create an animation of a girl on a swing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨将图像切割成不同部分的过程，然后使用`rotationEffect`修饰符旋转这些单独的部分，以创建一个女孩在秋千上的动画。
