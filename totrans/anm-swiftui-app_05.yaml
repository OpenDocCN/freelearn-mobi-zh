- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animating Colorful Kaleidoscope Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at how we can animate colors with a modifier called
    `hueRotation`, where “hue” refers to the colors of the object, and “rotation”
    refers to the colors being rotated or animated. We will create a simple project
    that displays various images and then, using `hueRotation`, we can change or shift
    the colors of the images so that they will resemble somewhat of a kaleidoscope
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Along with `hueRotation`, there are some other important concepts we will explore
    in this project.
  prefs: []
  type: TYPE_NORMAL
- en: We will work with a Picker view for the first time, which is exactly what the
    name suggests; it lets the user pick from a variety of options, which can then
    be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we will look at how to pass data bidirectionally to another view. If you
    remember the moving circle project in [*Chapter 3*](B18674_03.xhtml#_idTextAnchor048),
    it was built inside one file and then within one view, the `ContentView`. In [*Chapter
    4*](B18674_04.xhtml#_idTextAnchor060), we built the record player using several
    files and then put those files together inside the `ContentView`. In both of those
    projects, we didn’t pass any data from file to file or view to view; the views
    contained blocks of code that just needed to be called in the main `ContentView`.
    But in this project, we will see how to pass data from different views using a
    special property wrapper called `@Binding`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s lay out the objectives before we dive in:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Binding variable and images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Picker control and using a `ForEach` view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the variables and background color
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Image view and using the `hueRotation` modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the completed project and the images we will use in the `Chapter
    5` folder over on GitHub at [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Binding variable and images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let’s get started. So, create a new Xcode project, give it a name, and
    we will get underway.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by adding a new SwiftUI file to the project, which I’ll call
    `selectedImage`, and make it of the `String` type. We will prefix this variable
    with the **@Binding** wrapper, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `@Binding` property wrapper is used to create a two-way binding between
    a source of truth (for example, a state property in a parent view) and a view
    that depends on that state. This `ImagePickerView` is the source of truth as it’s
    the parent view here. The `@Binding` wrapper allows a view to read and write to
    a value, but also makes sure that any changes made to the value are propagated
    back to the original source of truth. This is how views can be updated and re-rendered
    automatically whenever the source of truth changes, without having to manually
    pass down new values and refresh the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now add some images that we need to the project. You can find them in
    the GitHub repository – just download the resources for this chapter. There are
    five images: `ornament`, `landscape`, `dog`, `dice`, and `cat`. Open the Assets
    catalog and drop the five images into the catalog (just like we did when creating
    the record player).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the images in place, let’s create an array of strings that can hold the
    names of the images. Here is the code, which gets placed under the `@Binding`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To create the array, we first give it a name, `images`, then use the `String`
    keyword within square brackets, then another pair of square brackets in which
    we fill the `images` array with five `String` elements, which are the names of
    the images we want to use. Each string is separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `images` array is ready to use. Let’s add a Picker control and see how
    we can loop through this array using a `ForEach` view to store each string name
    in the picker.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Picker control and using a ForEach view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SwiftUI offers us a sufficient number of pre-built controls to help put together
    a user interface that is both nice to look at and very functional. One control
    that is useful for providing your user with a list of options is the **Picker
    view**, which can provide as few or as many values as you need to display for
    your app. A Picker view is a view that lets the user select an item from a list
    of options and is usually used together with a Binding variable, which will store
    the currently selected value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a `forEach` view to iterate through the `images` array and
    populate the picker. Working in the `body` property, let’s add the `PickerView`
    first, and a `ForEach` view inside the picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, there’s a lot going on here, so let’s break it down. Quick note though:
    don’t worry about the preview struct below the `ImagePickerView` just yet; that’s
    going to show an error, but we’ll fix that in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: For the Picker’s first parameter, you’ll notice there’s an empty `String` value.
    The string will allow you to give the Picker a label if you think it needs one;
    however, we do not need it here so we’re leaving the `String` parameter empty.
    Inside the next parameter, called `selection`, is where the `selectedImage` binding
    property will go, and this property will bind to a `State` property in the `ContentView`
    later. We haven’t added any State properties in the `ContentView` yet, but we
    will soon.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `selectedImage` property in this `ImagePickerView` file will be bidirectionally
    connected to a State property in the `ContentView`. That connection allows for
    the instant refreshing of views between those two structs when the value changes
    in either struct.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax does require that we put the dollar sign (`$`) before the property
    in order to tell SwiftUI that this property is a binding property and can connect
    to the `ContentView` (the source of truth) and update the views.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code is the `ForEach` view. What we want to do is loop through
    the `images` array and display all those String labels of that array in the `Picker`
    view. In order to loop through the array of strings, they need to have some sort
    of ID that identifies each element in this array uniquely. And since they all
    have different names, why not use the names of each element, which already constitute
    unique IDs? To use each image’s name as an ID for the loop, we used the `\.self`
    syntax, placed after the `images` array.
  prefs: []
  type: TYPE_NORMAL
- en: The `value` keyword in this code is the looping variable; it will store each
    element from the `images` array as the `ForEach` view loops through them. This
    looping variable can be named anything you like, but I called it `value` in this
    example as that makes the most sense (it temporarily holds the value of each element
    in the array, one at a time).
  prefs: []
  type: TYPE_NORMAL
- en: Now looking at the code in the `ForEach` view’s body, we only need to add one
    `Text` view with the `value` variable inside it. That will display everything
    that is in the `images` array in the `PickerView`. Next, we change the color of
    the text to white using the `foregroundColor` modifier. We do this because when
    we go into the `ContentView` file, we will make the screen’s background black;
    that way, we’ll see the white letters over the black background.
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes the `Picker` view functionality; let’s now style the appearance
    of the `Picker` view by adding some modifiers to it after the view’s closing bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at each of the modifiers used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first modifier I’ve added is `pickerStyle()`, which is used to change the
    appearance of the `Picker` view. There are four built-in styles we can select
    from to style the Picker using the `pickerStyle()` modifier. The following are
    the ones available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DefaultPickerStyle()`: The default style that is chosen automatically by the
    system based on the platform and current context. This presents the choices to
    the user in a menu style.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PopUpButtonPickerStyle()`: This is a pop-up button-style picker, often used
    on macOS. This presents the choices in a button style to the user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WheelPickerStyle()`: A wheel-style picker, often used on iOS. This presents
    the choices in a wheel style to the user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SegmentedPickerStyle()`: A segmented control-style picker, commonly used on
    iOS, watchOS, and tvOS. This presents the choices in the style of a segmented
    button to the user.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We chose the `WheelPickerStyle` for this project.
  prefs: []
  type: TYPE_NORMAL
- en: The second modifier is the `frame` modifier, which sets the dimensions of the
    picker control. Here, we set the dimensions as `300` points wide and `150` points
    tall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the `background` modifier, which sets the background color of the picker
    to red. `colorMultiply` then modifies the red color instance by multiplying its
    RGB values with those of another color, blue in this case. The result is a dark
    shade of purple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, we used the `cornerRadius` modifier to round the corners of the
    picker by 20 points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finish styling the picker using the `shadow` modifier. This will add a white
    shadow with a radius of 5 points and will be visible when we change the background
    to black.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s return to the error that our code is experiencing and see how we
    can make sure the app builds cleanly. The error says that we are missing an argument
    from the `ImagePickerView`’s call. And that’s true, because we added a `Binding`
    property into the `ImagePickerView` struct called `selectedImage`, and since the
    `Preview` struct is referencing the `ImagePickerView`, it needs to use that `Binding`
    variable in itself too in order to build cleanly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, we need to go into the `Previews` struct at the bottom
    of the file and change the first line of code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using the `constant` function, the error goes away. The `constant` function
    will accept any value we want as long as it’s of the String type, because that’s
    the data type of the `selectedImage` property. I’m using the `"ornament"` string
    from the `images` array, and that string will be shown in the picker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the code builds cleanly, the result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Picker View  ](img/B18674_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Picker View'
  prefs: []
  type: TYPE_NORMAL
- en: Spin the wheel picker and you can see all of the string names from the `images`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the `ImagePickerView` file, let’s continue by setting
    up the `ContentView` file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the variables and background color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving into the `ContentView` file now, our first task here will be to add a
    couple of variables and a constant. Let’s start with adding a variable that will
    bind to the `selectedImage` binding property in the `ImagePickerView` file.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, we need to create a `State` variable, which needs to be the same
    data type as the `selectedImage` variable, a `String` type. We can give it the
    same name as the variable too, `selectedImage`, so that you know this variable
    is bidirectionally linked to the variable in the `ImagePickerView` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code inside the `ContentView` struct, at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `selectedImage` variable gets set to a String value called `ornament`. Next
    is a variable to track the animation called `shiftColors`, which is set to `false`.
    Finally, we have a constant to hold the background color, which will be black.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `body` property, let’s add a `VStack`, which will take care
    of vertically organizing three views that the user interface needs: a background,
    which will be black; an `Image` view, to display the image selected by the user;
    and a call to the `ImagePickerView` that we created in the `ImagePickerView` file,
    which allows the user to select an image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do all of this, first add a `VStack` into the `body` property of the `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `ImagePickerView` into the `VStack` with the `frame` modifier
    on it, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To color the background, we need a `ZStack` so it can overlay the color onto
    the whole screen. Add this code inside the `VStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen before, this code will color the background black, and by using
    the `scaleEffect` modifier and passing in the value of `1.4`, the black background
    will stretch out so it covers the entire screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the background is set, let’s add an `Image` view to display the images,
    and then start animating some colors.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Image view and using the hueRotation modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the background set up and all of the variables in place, let’s add an `ImageView`
    to display the images, and add the `hueRotation` modifier to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code right after the `scaleEffect` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the Image view to display the images on the screen, resizing
    it and adding a little padding to it. Then we set the frame of the image view
    to a size of `400` by `400`.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the `hueRotation` modifier. Hue rotation is an image-processing effect
    that adjusts the hue of an image by rotating the colors in the hue color wheel
    by a specified angle. It changes the overall color tone of an image by shifting
    the hue of each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: The speed at which it does this is determined by the values that get passed
    into its parameter. And if you have an image with many different colors, then
    `hueRotation` will cycle through and rotate all of them, creating a sort of kaleidoscope
    color effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `hueRotation` parameter, it needs a value to represent degrees,
    which is for the amount of rotation to apply to the colors in this view, and that
    is handled by the `degrees` function. Inside the `degrees` function is a ternary
    operator, which will select from two choices: either a value of `360` when the
    `shiftColors` variable is `true`, or `0` when it is `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `animation` modifier is added to animate to the color-changing effect.
    It uses an `easeInOut` timing curve with a duration of 2 seconds to complete the
    animation and a delay of 0.3 seconds between animations.
  prefs: []
  type: TYPE_NORMAL
- en: Then we use the `onAppear` modifier, which runs the code within its body as
    soon as the view appears. This is a perfect place to trigger the animation by
    toggling the `shiftColors` variable to its opposite value.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we set a frame width and height of `350` by `200` for the `ImagePickerView`
    and colored the background of the `VStack` by using our `background` variable.
    We also used `edgesIgnoringSafeArea` for the bottom edges, so the background color
    will go below the screen. We want the whole screen black with our views on top
    of it, and this code does just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Guess what? With all that finished, the project is done! Here’s what it should
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Finished project ](img/B18674_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Finished project'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and run the project – you’ll see that the colors from your selected
    image will all shift and rotate over the span of 2 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good work on completing the project! As you worked through it, you got to see
    how to use a `Binding` property so data can be bound between views, the `Picker`
    view, a view with different styles that allows users to select an image or other
    data, and finally the `hueRotation` modifier, which rotates colors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the process of cutting up an image into
    different parts, then rotating those separate parts using the `rotationEffect`
    modifier, to create an animation of a girl on a swing.
  prefs: []
  type: TYPE_NORMAL
