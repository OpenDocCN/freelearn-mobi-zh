- en: Activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a new activity with an intent object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data to another activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a result from an activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving an activity's state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing persistent activity data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the activity life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android SDK provides a powerful tool to program mobile devices, and the
    best way to master such a tool is to jump right in. Although you can read this
    book from beginning to end, as it is a cookbook, it is specifically designed to
    allow you to jump to specific tasks and get the results immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '**Activities** are the fundamental building block of most Android applications
    as the activity class provides the interface between the application and screen.
    Most Android applications will have at least one activity, if not several (but
    they are not required). A background service application will not necessarily
    require an activity if there is no user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how to *declare* and *launch* activities within an application
    and how to manage several activities at once by sharing data between them, requesting
    results from them, and calling one activity from within another.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also briefly explores the **intent** object, which is often used
    in conjunction with activities. Intents can be used to transfer data between activities
    in your own application, as well as in external applications, such as those included
    with the Android operating system (a common example would be to use an intent
    to launch the default web browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin developing Android applications, head over to the Android Studio page
    to download the new Android Studio IDE and the **Android SDK** bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities and other application components, such as **services**, are declared
    in the `AndroidManifest.xml` file. Declaring an activity node is how we tell the
    OS about our Activity class and how it can be requested. For example, an application
    will usually indicate that at least one activity should be visible as a desktop
    icon and serve as the main entry point to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio, now at version 3.2, is used for all the code samples shown in
    this book. If you have not already installed it, visit the Android Studio website
    (see the link in the previous tip) to install the IDE and the SDK bundle for your
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this first example, we''ll guide you through creating a new project. Android
    Studio provides a Quick Start wizard, which makes the process extremely easy.
    Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch Android Studio, which brings up the Welcome to Android Studio dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a4aaf584-2968-4a7c-a067-f13f9c71cb3a.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Start a new Android Studio project option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter an application name; for this example, we used `DeclareAnActivity`. Click
    on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83ee42a4-cfdd-403c-b627-c6c798a16d60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Target Android Devices dialog, you can leave the Phone and Tablet checkbox
    selected with the default API 21: Android 5.0 (Lollipop) selection for the minimum
    SDK (for this example, it really doesn''t matter which API level you choose, as
    activities have existed since API level 1). Click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d713d5e3-4cc9-4254-adf4-5566baab9bec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Add an Activity to Mobile dialog, select the Empty Activity option.
    Click on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/33f5a871-aaa5-4e9a-8046-779236d3d84b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Configure Activity dialog, you can leave the defaults as provided, but
    note that the default activity name is `MainActivity`. Click on Finish:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ffb60187-d75d-483a-914f-cedf7b87f16e.png)'
  prefs: []
  type: TYPE_IMG
- en: After finishing the wizard, Android Studio will create the project files. For
    this recipe, the two files that we will examine are `MainActivity.java` (which
    corresponds to the activity name mentioned in step 6) and `AndroidManifest.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the `MainActivity.java` file, you will realize that it''s
    pretty basic. This is because we chose the Empty Activity option (in step 5).
    Now, look at the `AndroidManifest.xml` file. This is where we actually declare
    the activity. Within the `<application>` element is the `<activity>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When viewing this `xml` in Android Studio, you may notice that the label element
    shows the actual text (`DeclareAnActivity` in this case) as defined in the `strings.xml`
    resource file.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declaring an activity is a simple matter of declaring the `<activity>` element
    and specifying the name of the activity class with the `android:name` attribute.
    By adding the `<activity>` element to the **Android Manifest**, we are specifying
    our intention to include this component in our application. Any activities (or
    any other component for that matter) that are not declared in the manifest will
    not be available to the application. Attempting to access or utilize an undeclared
    component will result in an exception being thrown at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, there is another attribute: `android:label`. This attribute
    indicates the title shown on the screen, as well as the icon if this is the Launcher
    activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete list of available Activity attributes, take a look at this resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://developer.android.com/guide/topics/manifest/activity-element.html](http://developer.android.com/guide/topics/manifest/activity-element.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new activity with an intent object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android application model can be seen as a service-oriented one, with activities
    as components and intents as the messages sent between them. Here, an intent is
    used to start an activity that displays the user's call log, but intents can be
    used to do many things and we will encounter them throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep things simple, we are going to use an intent object to start one of
    Android's built-in applications rather than create a new one. This only requires
    a very basic application, so start a new Android project with Android Studio and
    call it `ActivityStarter`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, to keep the example simple so that we can focus on the task at hand,
    we will create a function to show an intent in action and call this function from
    a button on our activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your new project is created in Android Studio, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MainActivity.java` class and add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While you are typing this code, Android Studio will give this warning on View
    and intent: Cannot resolve symbol ''Intent''.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that you need to add the library reference to the project. You can
    do this manually by entering the following code in the `import` section:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, let Android Studio add the library reference for you: just click
    on the code highlighted with a red font and press *Alt *+* Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `activity_main.xml` file and replace the `<TextView />` block with
    the following XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9b4364cb-0f0e-432a-b49d-84dc72f42ffd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, it's time to run the application and see the intent in action. You will
    need to either create an Android emulator (in Android Studio, go to Tools | Android | AVDManager)
    or connect a physical device to your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you press the Launch Browser button, you will see the default web browser
    open with the URL specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though simple, this app demonstrates much of the power behind the Android OS.
    An intent is a message object. Intents can be used to communicate across your
    application's components (such as services and broadcast receivers) as well as
    with other applications on the device. In this recipe, we asked the OS to start
    any app that could handle the data we specified with the `setData()` method. (If
    the user has multiple browsers installed and no default set, the OS will show
    a list of apps for the user to choose from.)
  prefs: []
  type: TYPE_NORMAL
- en: To test this on a physical device, you may need to install drivers for your
    device (the drivers are specific to the hardware manufacturer). You will also
    need to enable Developer Mode on your device. Enabling Developer Mode varies according
    to the Android OS version. If you do not see the Developer Mode option in your
    device settings, open the About Phone option and begin tapping Build Number. After
    three taps, you should see a **Toast** message telling you that you are on your
    way to being a developer. Four more taps will enable the option.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we created an intent object with the `ACTION_VIEW` . as what
    we want to do (our intention). You may have noticed that when you typed `Intent`
    and the period, Android Studio provided a pop-up list of possibilities (this is
    the autocomplete feature), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/546a9d59-ea59-4c24-8eaa-68c2082ea760.png)'
  prefs: []
  type: TYPE_IMG
- en: '`ACTION_VIEW`, along with a URL in the data, indicates that the intention is
    to view the website, so the default browser is launched (different data could
    launch different apps). In this example, we just want to open a browser with the
    specified URL, so we call the `startActivity()` method. There are other ways to
    call the intent depending on our needs. In the *Returning a result from an activity*
    recipe, we will use the `startActivityForResult()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very common for Android users to download their favorite apps for web browsing,
    taking photos, text messaging, and so on. Using Intents, you allow your users
    to use their favorite apps instead of trying to reinvent all of this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start an activity from a menu selection, refer to the *Handling menu selections*
    recipe in [Chapter 4](271b832c-648f-4a10-967e-aac99272e9a9.xhtml), *Menus and
    Action Mode*.
  prefs: []
  type: TYPE_NORMAL
- en: Switching between activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, we will want to activate one activity from within another activity. Although
    this is not a difficult task, it will require a little more setting up to be done
    than the previous recipes as it requires two activities. We will create two activity
    classes and declare them both in the manifest. We'll also create a button, as
    we did in the previous recipe, to switch to the activity.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll create a new project in Android Studio, just as we did in the previous
    recipes, and call this one `ActivitySwitcher`. Android Studio will create the
    first activity, `ActivityMain`, and automatically declare it in the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the Android Studio New Project wizard has already created the first activity,
    we just need to create the second activity. Open the ActivitySwitcher project
    and navigate to File | New | Activity | Empty Activity, as shown in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/133e7491-872e-4b22-81eb-c369e92163d5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the New Android Activity dialog, you can leave the default Activity Name
    as is, or change it to `SecondActivity`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/21eca820-853d-4f58-8b34-40c1951f17b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `MainActivity.java` file and add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `activity_main.xml` file located in the `res/layout` folder and
    replace the `<TextView />` with the following XML to create the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can run the code at this point and see the second activity open. We're going
    to go further and add a button to `SecondActivity` to close it, which will bring
    us back to the first activity. Open the `SecondActivity.java` file and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'add this function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the Close button to the `SecondActivity` layout. Open the `activity_second.xml`
    file and add the following `<Button>` element to the auto-generated `ConstraintLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the application on your device or emulator and see the buttons in action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The real work of this exercise is in the `onClickSwitchActivity()` method from
    step 3\. This is where we declare the second activity for the Intent using `SecondActivity.class`.
    We went one step further by adding the close button to the second activity to
    show a common real-world situation: launching a new activity, then returning to
    the original calling activity. This behavior is accomplished in the `onClickClose()`
    function. All it does is call `finish()`, but that tells the OS that we''re done
    with the activity. Finish doesn''t actually return us to the calling activity
    (or any specific activity for that matter); it just closes the current activity
    and relies on the application''s **back stack** to show the last activity. If
    we want a specific activity, we can again use the Intent object and specify the
    activity class name when creating the Intent.'
  prefs: []
  type: TYPE_NORMAL
- en: This activity switching does not make a very exciting application. Our activity
    does nothing but demonstrates how to switch from one activity to another, which
    of course will form a fundamental aspect of almost any application that we develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had manually created the activities, we would need to add them to the
    manifest. Using the New Android Activity wizard will automatically add the necessary
    elements to the Android Manifest file. To see what Android Studio did for you,
    open the `AndroidManifest.xml` file and look at the `<application>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note in the preceding auto-generated code is that the second activity
    does not have the `<intent-filter>` element. The main activity is generally the
    entry point when starting the application. That's why `MAIN` and `LAUNCHER` are
    defined so that the system will know which activity to launch when the application
    starts.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about embedding widgets such as the Button, visit [Chapter 2](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml),
    *Views, Widgets, and Styles*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data to another activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intent object is defined as a messaging object. As a message object, its
    purpose is to communicate with other components of the application. In this recipe,
    we'll show you how to pass information with the intent and how to get it out again.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will pick up from where the previous one ended. We will call this
    project `SendData`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since this recipe is building on the previous recipe, most of the work is already
    done.  We''ll add an `EditText` element to the main activity so that we have something
    to send to `SecondActivity`. We''ll use the (auto-generated) `TextView` view to
    display the message. The following are the complete steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml` and add the following `<EditText>` element above the
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `<Button>` element that we created in the previous recipe doesn't change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `MainActivity.java` file and change the `onClickSwitchActivity()`
    method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, open the `activity_second.xml` file and add the following `<TextView>`
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last change is to edit the second activity to look for this new data and
    display it on the screen. Open `SecondActivity.java` and edit `onCreate()` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the project. Type some text in the main activity and press Launch Second
    Activity to see it send the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As expected, the Intent object is doing all the work. We created an intent just
    as in the previous recipe and then added some extra data. Did you notice the `putExtra()`
    method call? In our example, we used the already defined `Intent.EXTRA_TEXT` as
    the identifier, but we didn't have to. We can use any key we want (you've seen
    this concept before if you're familiar with name/value pairs).
  prefs: []
  type: TYPE_NORMAL
- en: The key point about using name/value pairs is that you have to use the same
    name to get the data back out. That's why we used the same key identifier when
    we read the extra data with `getStringExtra()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second activity was launched with the intent that we created, so it''s
    simply a matter of getting the intent and checking for the data sent along with
    it. We do this in `onCreate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We aren't limited to just sending `String` data. The intent object is very flexible
    and already supports basic data types. Go back to Android Studio and click on
    the `putExtra` method. Then, hit *Ctrl* and the spacebar. Android Studio will
    bring up the auto-complete list so that you can see the different data types that
    you can store.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a result from an activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to start one activity from another is very useful and commonly used,
    but there are times when we need to know the result from the called activity.
    The `startActivityForResult()` method provides the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returning a result from an activity is not very different from the way we just
    called the activity in the previous recipes. You can either use the project from
    the previous recipe or start a new project and call it `GettingResults`. Either
    way, once you have a project with two activities and the code needed to call the
    second activity, you're ready to begin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are only a few changes needed to get the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, open `MainActivity.java` and add the following constant to the
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, change the way the intent is called by modifying the `onClickSwitchActivity()`
    method to expect a result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add this new method to receive the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, modify `onClickClose` in `SecondActivity.java` to set the return value
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, getting the results back is relatively straightforward. We just
    call the intent with `startActivityForResult`, indicating we want a result back.
    We set up the `onActivityResult()` callback handler to receive the results. Finally,
    we make sure that the second activity returns a result with `setResult()` before
    closing the activity. In this example, we are just setting a result with a static
    value. We use a simple Toast to display the result back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: It's good practice to check the result code to make sure that the user didn't
    cancel the action. It's technically an integer, but the system uses it as a Boolean
    value. Check for either `RESULT_OK` or `RESULT_CANCEL` and proceed accordingly.
    In our example, the second activity doesn't have a cancel button, so why bother
    to check? What if the user hits the back button? Android will set the result code
    to `RESULT_CANCEL` and the intent to null, which would cause our code to throw
    an exception if we attempt to access the null result.
  prefs: []
  type: TYPE_NORMAL
- en: We made use of the **Toast** object, which displays a convenient pop-up **message **to
    unobtrusively notify the user. It also functions as a handy method for debugging
    as it doesn't need a special layout or screen space.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides the result code, `onActivityResults()` also includes a **Request Code**.
    Are you wondering where that came from? It is simply the integer value that was
    passed with the `startActivityForResult()` call, which takes this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We didn't check the request code because we knew we had only one result to handle,
    but in non-trivial applications with several activities, this value can be used
    to identify which Activity is returning a result.
  prefs: []
  type: TYPE_NORMAL
- en: If `startActivityForResult()` is called with a negative request code, it will
    behave the same as if we used `startActivity()`, that is, it will not return a
    result.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about creating new activity classes, refer to the *Switching between
    activities* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information about Toasts, check out the *Making a Toast* recipe in
    [Chapter 8](3d708b9b-223b-493a-bf48-48fc306aa0a5.xhtml), *Alerts and Notifications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving an activity's state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mobile environment is very dynamic, with users changing tasks much more
    often than on desktops. With generally fewer resources on a mobile device, it
    should be expected that your application will be interrupted at some point. It's
    also very possible that the system will shut down your app completely to give
    additional resources to the task at hand. It's the nature of mobiles.
  prefs: []
  type: TYPE_NORMAL
- en: A user might start typing something in your app, be interrupted by a phone call,
    or switch over to send a text message, and by the time they get back to your app,
    the OS may have closed your app completely to free up the memory. To provide the
    best user experience, you need to expect such behavior and make it easier for
    your user to resume from where they left off. The good thing is that the Android
    OS makes this easier by providing callbacks to notify your app of state changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply rotating your device will cause the OS to destroy and recreate your
    activity. This might seem a bit heavy-handed, but it''s done for a good reason:
    it''s very common to have different layouts for portrait and landscape, so this
    ensures that your app is using the correct resources.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you'll see how to handle the `onSaveInstanceState()` and `onRestoreInstanceState()`
    callbacks to save your application's state. We will demonstrate this by creating
    a counter variable and increment it each time the Count
  prefs: []
  type: TYPE_NORMAL
- en: button is pressed. We will also have an `EditText` and a `TextView` widget to
    see their default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new project in Android Studio and name it `StateSaver`. We need only
    a single activity, so the auto-generated main activity is sufficient. However,
    we will need a few widgets, including `EditText`, `Button`, and `TextView`. Their
    layout (in `activity_main.xml`) will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep track of the counter, we need to add a global variable to the project,
    along with a key for saving and restoring. Add the following code to the `MainActivity.java`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the code needed to handle the button press; it increments the counter
    and displays the result in the `TextView` widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive notifications of application state change, we need to add the `onSaveInstanceState()`
    and `onRestoreInstanceState()` methods to our application. Open `MainActivity.java`
    and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run the program and try changing the orientation to see how it behaves (if you're
    using the emulator, *Ctrl* + *F11* will rotate the device).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All activities go through multiple states during their lifetime. By setting
    up callbacks to handle the events, we can have our code save important information
    before the activity is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 is where the actual saving and restoring occurs. The OS sends a **Bundle**
    (a data object that also uses name/value pairs) to the methods. We use the `onSaveInstanceState()`
    callback to save the data and pull it out in the `onRestoreInstanceState()` callback.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! Did you try typing text in the `EditText` view before rotating the
    device? If so, you'd have noticed that the text was also restored, but we don't
    have any code to handle that view. By default, the system will automatically save
    the state, provided it has a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if you want Android to automatically save and restore the state of
    a view, it must have a unique ID (specified with the `android:id=` attribute in
    the layout). Bur beware: not all view types automatically save and restore the
    state of a view.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `onRestoreInstanceState()` callback is not the only place where the state
    can be restored. Look at the signature of `onCreate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Both methods receive the same `Bundle` instance named `savedInstanceState`.
    You could move the restore code to the `onCreate()` method and it would work the
    same. But one catch is that the `savedInstanceState` bundle will be null if there
    is no data, such as during the initial creation of the activity. If you want to
    move the code from the `onRestoreInstanceState()` callback, just check to make
    sure that the data is not null. Here''s how that code would look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Storing persistent activity data* recipe will introduce persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a look at [Chapter 7](2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml), Data
    Storage, for more examples on how to persist data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Understanding the activity life cycle* recipe explains the Android Activity
    life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing persistent activity data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to store information about our activities on a temporary basis is
    very useful, but more often than not, we will want our application to remember
    information across multiple sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Android supports SQLite, but that could be a lot of overhead for simple data,
    such as the user's name or a high score. Fortunately, Android also provides a
    lightweight option for these scenarios with `SharedPreferences`. (In a real-world
    application, you'll likely use both options for saving data.)
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can either use the project from the previous recipe or start a new project
    and call it `PersistentData`. In the previous recipe, we saved `mCounter` in the
    session state. In this recipe, we'll add a new method to handle `onPause()` and
    save `mCounter` to `SharedPreferences`. We'll restore the value in `onCreate()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have only two changes to make, and both are in `MainActivity.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `onPause()` method to save the data before the activity closes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following code at the end of `onCreate()` to restore the counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run the program and try it out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, this is very similar to saving state data, because it also uses
    name/value pairs. Here, we just stored an `int`, but we can just as easily store
    one of the other primitive data types. Each data type has equivalent getters and
    setters, for example, `SharedPreferences.getBoolean()` or `SharedPreferences.setString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our data requires the services of `SharedPreferences.Editor`. This is
    evoked with `edit()` and accepts `remove()` and `clear()` procedures, as well
    as setters such as `putInt()`. Note that we must conclude any changes with the
    `commit()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a slightly more sophisticated variant of the `getPreferences()` accessor:
    `getSharedPreferences()`. It can be used to store multiple preference sets.'
  prefs: []
  type: TYPE_NORMAL
- en: Using more than one preference file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `getSharedPreferences()` is no different from using its counterpart,
    but it allows for more than one preference file. It takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, `name` is the file. The `mode` can be either `MODE_PRIVATE`, `MODE_WORLD_READABLE`,
    or `MODE_WORLD_WRITABLE` and describes the file's access levels.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 7](2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml), *Data Storage*, for
    more examples on data storage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the activity life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mobile hardware continues to improve, so too does the demand placed on that
    hardware. With increasingly more powerful applications and user multi-tasking,
    the already limited resources can be quite challenging. The Android OS has many
    features built in to help the user get the best performance from their device,
    such as limiting background processes, disabling application notifications, and
    allowing data limits. The OS will also manage application lifetime based on foreground
    tasks. If your application is in the foreground, the life cycle is straightforward.
    But as soon as your user switches tasks and your application is moved to the background,
    understanding the Android application life cycle becomes very important.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the stages through which an activity passes during
    its lifetime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef2056bc-430c-4f66-b623-6c0055c0a21f.png)'
  prefs: []
  type: TYPE_IMG
- en: Along with the stages, the diagram also shows the methods that can be overridden.
    As you can see, we've already utilized most of these methods in the preceding
    recipes. Hopefully, getting the big picture will help your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new project in Android Studio with a Blank Activity, and call it `ActivityLifecycle`.
    We will use the (auto-generated) `TextView` method to display the state information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To see the application move through the various stages, we will create methods
    for all
  prefs: []
  type: TYPE_NORMAL
- en: 'the stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `activity_main.xml` and add an ID to the auto-generated `TextView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining steps will be in `MainActivity.java`. Modify the `onCreate()`
    method to set the initial text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following methods to handle the remaining events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and observe what happens when the activity is interrupted
    by pressing the Back and Home keys. Try other actions, such as task switching,
    to see how they impact your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our activity can exist in one of these three states: **active**, **paused**,
    or **stopped**. There is also'
  prefs: []
  type: TYPE_NORMAL
- en: 'a fourth state, **destroyed** (but there''s no guarantee the OS will ever call
    it):'
  prefs: []
  type: TYPE_NORMAL
- en: An activity is in the `active` state when its interface is available for the
    user. It persists from `onResume()` until `onPause()`, which is brought about
    when another activity comes to the foreground. If this new activity does not entirely
    obscure our activity, then ours will remain in the `paused` state until the new
    activity is finished or dismissed. It will then immediately call `onResume()`
    and continue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a newly started activity fills the screen or makes our activity invisible,
    then our activity will enter the `stopped` state, and resumption will always invoke
    a call to `onRestart()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an activity is in either the `paused` or `stopped` state, the operating
    system can (and will) remove it from the memory when the memory is low or when
    other applications demand it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is worth noting that we never actually see the results of the `onDestroy()`
    method, as the activity is removed by this point. If you want to explore these
    methods further, then it is well worth employing `Activity.isFinishing()` to see
    whether the activity is really finishing before `onDestroy()` is executed, as
    seen in the following snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When implementing these methods, always call the superclass before doing any
    work.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To shut down an activity, directly call its `finish()` method, which in turn
    calls `onDestroy()`. To perform the same action from a child activity, use `finishFromChild(Activity
    child)`, where `child` is the calling subactivity.
  prefs: []
  type: TYPE_NORMAL
- en: It is often useful to know whether an activity is being shut down or merely
    paused, and the `isFinishing(boolean)` method returns a value that indicates which
    of these two states the activity is in.
  prefs: []
  type: TYPE_NORMAL
