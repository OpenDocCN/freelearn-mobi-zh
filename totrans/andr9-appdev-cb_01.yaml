- en: Activities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下食谱：
- en: Declaring an activity
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个活动
- en: Starting a new activity with an intent object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用意图对象启动新的活动
- en: Switching between activities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动之间切换
- en: Passing data to another activity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据传递给另一个活动
- en: Returning a result from an activity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从活动返回结果
- en: Saving an activity's state
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存活动的状态
- en: Storing persistent activity data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储持久活动数据
- en: Understanding the activity life cycle
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解活动生命周期
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The Android SDK provides a powerful tool to program mobile devices, and the
    best way to master such a tool is to jump right in. Although you can read this
    book from beginning to end, as it is a cookbook, it is specifically designed to
    allow you to jump to specific tasks and get the results immediately.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK 提供了一个强大的工具来编程移动设备，而掌握这样一个工具的最佳方式就是直接上手。虽然您可以从头到尾阅读这本书，因为它是一本食谱书，但它特别设计成允许您跳转到特定的任务并立即获得结果。
- en: '**Activities** are the fundamental building block of most Android applications
    as the activity class provides the interface between the application and screen.
    Most Android applications will have at least one activity, if not several (but
    they are not required). A background service application will not necessarily
    require an activity if there is no user interface.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动**是大多数 Android 应用程序的基本构建块，因为活动类提供了应用程序和屏幕之间的接口。大多数 Android 应用程序至少将有一个活动，如果不是几个（但不是必需的）。一个没有用户界面的后台服务应用程序可能不需要活动。'
- en: This chapter explains how to *declare* and *launch* activities within an application
    and how to manage several activities at once by sharing data between them, requesting
    results from them, and calling one activity from within another.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了如何在应用程序中 *声明* 和 *启动* 活动，以及如何通过在它们之间共享数据、从它们请求结果以及在另一个活动内部调用它们来同时管理多个活动。
- en: This chapter also briefly explores the **intent** object, which is often used
    in conjunction with activities. Intents can be used to transfer data between activities
    in your own application, as well as in external applications, such as those included
    with the Android operating system (a common example would be to use an intent
    to launch the default web browser).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还简要探讨了 **意图** 对象，该对象通常与活动一起使用。意图可以用来在您的应用程序中的活动之间以及在外部应用程序（例如 Android 操作系统包含的应用程序）之间传输数据（一个常见的例子是使用意图启动默认的网页浏览器）。
- en: 'To begin developing Android applications, head over to the Android Studio page
    to download the new Android Studio IDE and the **Android SDK** bundle:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始开发 Android 应用程序，请转到 Android Studio 页面下载新的 Android Studio IDE 和 **Android
    SDK** 套件：
- en: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html).'
- en: Declaring an activity
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个活动
- en: Activities and other application components, such as **services**, are declared
    in the `AndroidManifest.xml` file. Declaring an activity node is how we tell the
    OS about our Activity class and how it can be requested. For example, an application
    will usually indicate that at least one activity should be visible as a desktop
    icon and serve as the main entry point to the application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 活动和其他应用程序组件（如 **服务**）在 `AndroidManifest.xml` 文件中声明。声明活动节点是我们告诉操作系统关于我们的 Activity
    类以及如何请求它的方式。例如，应用程序通常会指示至少有一个活动应作为桌面图标可见，并作为应用程序的主要入口点。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Android Studio, now at version 3.2, is used for all the code samples shown in
    this book. If you have not already installed it, visit the Android Studio website
    (see the link in the previous tip) to install the IDE and the SDK bundle for your
    platform.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio，现在版本为 3.2，用于本书中展示的所有代码示例。如果您尚未安装它，请访问 Android Studio 网站（参见前面的提示）以安装
    IDE 和 SDK 套件。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'For this first example, we''ll guide you through creating a new project. Android
    Studio provides a Quick Start wizard, which makes the process extremely easy.
    Follow these steps to get started:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个第一个示例，我们将引导您创建一个新的项目。Android Studio 提供了一个快速入门向导，这使得整个过程变得极其简单。按照以下步骤开始：
- en: 'Launch Android Studio, which brings up the Welcome to Android Studio dialog:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Android Studio，将弹出“欢迎使用 Android Studio”对话框：
- en: '![](img/a4aaf584-2968-4a7c-a067-f13f9c71cb3a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4aaf584-2968-4a7c-a067-f13f9c71cb3a.png)'
- en: Click on the Start a new Android Studio project option.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“启动新的 Android Studio 项目”选项。
- en: 'Enter an application name; for this example, we used `DeclareAnActivity`. Click
    on Next:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入应用程序名称；在这个例子中，我们使用了 `DeclareAnActivity`。点击“下一步”：
- en: '![](img/83ee42a4-cfdd-403c-b627-c6c798a16d60.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/83ee42a4-cfdd-403c-b627-c6c798a16d60.png)'
- en: 'In the Target Android Devices dialog, you can leave the Phone and Tablet checkbox
    selected with the default API 21: Android 5.0 (Lollipop) selection for the minimum
    SDK (for this example, it really doesn''t matter which API level you choose, as
    activities have existed since API level 1). Click on Next:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“目标 Android 设备”对话框中，您可以保留默认的“手机”和“平板电脑”复选框，并选择最低 SDK 的默认 API 21：Android 5.0（Lollipop）。点击“下一步”：
- en: '![](img/d713d5e3-4cc9-4254-adf4-5566baab9bec.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d713d5e3-4cc9-4254-adf4-5566baab9bec.png)'
- en: 'In the Add an Activity to Mobile dialog, select the Empty Activity option.
    Click on Next:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加活动到移动设备”对话框中，选择“空活动”选项。点击“下一步”：
- en: '![](img/33f5a871-aaa5-4e9a-8046-779236d3d84b.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33f5a871-aaa5-4e9a-8046-779236d3d84b.png)'
- en: 'In the Configure Activity dialog, you can leave the defaults as provided, but
    note that the default activity name is `MainActivity`. Click on Finish:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“配置活动”对话框中，您可以保留默认值，但请注意默认活动名称是 `MainActivity`。点击“完成”：
- en: '![](img/ffb60187-d75d-483a-914f-cedf7b87f16e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ffb60187-d75d-483a-914f-cedf7b87f16e.png)'
- en: After finishing the wizard, Android Studio will create the project files. For
    this recipe, the two files that we will examine are `MainActivity.java` (which
    corresponds to the activity name mentioned in step 6) and `AndroidManifest.xml`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 完成向导后，Android Studio 将创建项目文件。对于这个示例，我们将检查的两个文件是 `MainActivity.java`（对应于第 6 步中提到的活动名称）和
    `AndroidManifest.xml`。
- en: 'If you take a look at the `MainActivity.java` file, you will realize that it''s
    pretty basic. This is because we chose the Empty Activity option (in step 5).
    Now, look at the `AndroidManifest.xml` file. This is where we actually declare
    the activity. Within the `<application>` element is the `<activity>` element:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看 `MainActivity.java` 文件，您会意识到它非常基础。这是因为我们选择了“空活动”选项（在第 5 步中）。现在，查看 `AndroidManifest.xml`
    文件。这是我们实际声明活动的地方。在 `<application>` 元素内是 `<activity>` 元素：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When viewing this `xml` in Android Studio, you may notice that the label element
    shows the actual text (`DeclareAnActivity` in this case) as defined in the `strings.xml`
    resource file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中查看此 `xml` 文件时，您可能会注意到标签元素显示了在 `strings.xml` 资源文件中定义的实际文本（在这种情况下为
    `DeclareAnActivity`）。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Declaring an activity is a simple matter of declaring the `<activity>` element
    and specifying the name of the activity class with the `android:name` attribute.
    By adding the `<activity>` element to the **Android Manifest**, we are specifying
    our intention to include this component in our application. Any activities (or
    any other component for that matter) that are not declared in the manifest will
    not be available to the application. Attempting to access or utilize an undeclared
    component will result in an exception being thrown at runtime.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 声明活动是一个简单的过程，只需声明 `<activity>` 元素并使用 `android:name` 属性指定活动类的名称。通过将 `<activity>`
    元素添加到 **AndroidManifest**，我们指定了将此组件包含到我们的应用程序中的意图。任何未在清单中声明的活动（或任何其他组件）将不可用给应用程序。尝试访问或使用未声明的组件将在运行时抛出异常。
- en: In the preceding code, there is another attribute: `android:label`. This attribute
    indicates the title shown on the screen, as well as the icon if this is the Launcher
    activity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，还有一个属性：`android:label`。此属性表示屏幕上显示的标题，以及如果是启动器活动，还表示图标。
- en: 'For a complete list of available Activity attributes, take a look at this resource:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的活动属性完整列表，请参阅此资源：
- en: '[http://developer.android.com/guide/topics/manifest/activity-element.html](http://developer.android.com/guide/topics/manifest/activity-element.html).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[Android 开发者指南 - Activity 元素](http://developer.android.com/guide/topics/manifest/activity-element.html).'
- en: Starting a new activity with an intent object
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用意图对象启动新活动
- en: The Android application model can be seen as a service-oriented one, with activities
    as components and intents as the messages sent between them. Here, an intent is
    used to start an activity that displays the user's call log, but intents can be
    used to do many things and we will encounter them throughout this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序模型可以看作是一个面向服务的模型，其中活动是组件，意图是它们之间发送的消息。在这里，意图用于启动显示用户通话记录的活动，但意图可以用于做很多事情，我们将在整本书中遇到它们。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To keep things simple, we are going to use an intent object to start one of
    Android's built-in applications rather than create a new one. This only requires
    a very basic application, so start a new Android project with Android Studio and
    call it `ActivityStarter`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，我们将使用意图对象来启动Android的一个内置应用程序，而不是创建一个新的应用程序。这只需要一个非常基础的应用程序，所以使用Android
    Studio创建一个新的Android项目，并将其命名为`ActivityStarter`。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Again, to keep the example simple so that we can focus on the task at hand,
    we will create a function to show an intent in action and call this function from
    a button on our activity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了使示例简单，以便我们可以专注于手头的任务，我们将创建一个函数来展示意图的作用，并从我们的活动中的按钮调用此函数。
- en: 'Once your new project is created in Android Studio, follow these steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在Android Studio中创建了新的项目，请按照以下步骤操作：
- en: 'Open the `MainActivity.java` class and add the following function:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`类并添加以下函数：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While you are typing this code, Android Studio will give this warning on View
    and intent: Cannot resolve symbol ''Intent''.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您输入此代码时，Android Studio将在视图和意图上给出以下警告：无法解析符号'Intent'。
- en: 'This means that you need to add the library reference to the project. You can
    do this manually by entering the following code in the `import` section:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着您需要将库引用添加到项目中。您可以通过在`import`部分输入以下代码手动完成此操作：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Alternatively, let Android Studio add the library reference for you: just click
    on the code highlighted with a red font and press *Alt *+* Enter*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让Android Studio为您添加库引用：只需单击用红色字体突出显示的代码并按*Alt*+*Enter*。
- en: 'Open the `activity_main.xml` file and replace the `<TextView />` block with
    the following XML:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件并将`<TextView />`块替换为以下XML：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](img/9b4364cb-0f0e-432a-b49d-84dc72f42ffd.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b4364cb-0f0e-432a-b49d-84dc72f42ffd.png)'
- en: Now, it's time to run the application and see the intent in action. You will
    need to either create an Android emulator (in Android Studio, go to Tools | Android | AVDManager)
    or connect a physical device to your computer.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候运行应用程序并看到意图的作用了。您需要创建一个Android模拟器（在Android Studio中，转到工具 | Android | AVDManager）或将物理设备连接到您的计算机。
- en: When you press the Launch Browser button, you will see the default web browser
    open with the URL specified.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您点击启动浏览器按钮时，您将看到默认的网页浏览器打开并显示指定的URL。
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Though simple, this app demonstrates much of the power behind the Android OS.
    An intent is a message object. Intents can be used to communicate across your
    application's components (such as services and broadcast receivers) as well as
    with other applications on the device. In this recipe, we asked the OS to start
    any app that could handle the data we specified with the `setData()` method. (If
    the user has multiple browsers installed and no default set, the OS will show
    a list of apps for the user to choose from.)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单，但这个应用展示了Android操作系统背后的强大功能。意图是一个消息对象。意图可以用来在您的应用程序组件（如服务和广播接收器）之间以及与设备上的其他应用程序之间进行通信。在这个菜谱中，我们要求操作系统启动任何可以处理我们使用`setData()`方法指定的数据的应用程序。（如果用户安装了多个浏览器但没有默认设置，操作系统将显示一个应用程序列表供用户选择。）
- en: To test this on a physical device, you may need to install drivers for your
    device (the drivers are specific to the hardware manufacturer). You will also
    need to enable Developer Mode on your device. Enabling Developer Mode varies according
    to the Android OS version. If you do not see the Developer Mode option in your
    device settings, open the About Phone option and begin tapping Build Number. After
    three taps, you should see a **Toast** message telling you that you are on your
    way to being a developer. Four more taps will enable the option.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要在物理设备上测试此功能，您可能需要安装设备的驱动程序（驱动程序针对硬件制造商特定）。您还需要在设备上启用开发者模式。启用开发者模式的方法因Android操作系统版本而异。如果您在设备设置中看不到开发者模式选项，请打开“关于手机”选项并开始连续点击构建号。连续点击三次后，您应该会看到一个**Toast**消息告诉您您正在成为开发者的路上。再点击四次将启用该选项。
- en: 'In this recipe, we created an intent object with the `ACTION_VIEW` . as what
    we want to do (our intention). You may have noticed that when you typed `Intent`
    and the period, Android Studio provided a pop-up list of possibilities (this is
    the autocomplete feature), like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个意图对象，使用`ACTION_VIEW`作为我们想要执行的操作（我们的意图）。您可能已经注意到，当您输入`Intent`和点号时，Android
    Studio提供了一个弹出列表的可能选项（这是自动完成功能），如下所示：
- en: '![](img/546a9d59-ea59-4c24-8eaa-68c2082ea760.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/546a9d59-ea59-4c24-8eaa-68c2082ea760.png)'
- en: '`ACTION_VIEW`, along with a URL in the data, indicates that the intention is
    to view the website, so the default browser is launched (different data could
    launch different apps). In this example, we just want to open a browser with the
    specified URL, so we call the `startActivity()` method. There are other ways to
    call the intent depending on our needs. In the *Returning a result from an activity*
    recipe, we will use the `startActivityForResult()` method.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`ACTION_VIEW`与数据中的URL一起，表示意图是查看网站，因此默认浏览器被启动（不同的数据可以启动不同的应用）。在这个例子中，我们只想用指定的URL打开浏览器，所以我们调用`startActivity()`方法。根据我们的需求，还有其他调用intent的方法。在*从活动返回结果*的配方中，我们将使用`startActivityForResult()`方法。'
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: It's very common for Android users to download their favorite apps for web browsing,
    taking photos, text messaging, and so on. Using Intents, you allow your users
    to use their favorite apps instead of trying to reinvent all of this functionality.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android用户来说，下载他们喜欢的应用进行网页浏览、拍照、短信等是非常常见的。使用Intents，您可以让用户使用他们喜欢的应用，而不是试图重新发明所有这些功能。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To start an activity from a menu selection, refer to the *Handling menu selections*
    recipe in [Chapter 4](271b832c-648f-4a10-967e-aac99272e9a9.xhtml), *Menus and
    Action Mode*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要从菜单选择开始一个活动，请参考[第4章](271b832c-648f-4a10-967e-aac99272e9a9.xhtml)中的*处理菜单选择*配方，*菜单和动作模式*。
- en: Switching between activities
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在活动之间切换
- en: Often, we will want to activate one activity from within another activity. Although
    this is not a difficult task, it will require a little more setting up to be done
    than the previous recipes as it requires two activities. We will create two activity
    classes and declare them both in the manifest. We'll also create a button, as
    we did in the previous recipe, to switch to the activity.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将在一个活动内部激活另一个活动。尽管这不是一个困难的任务，但它需要比之前的配方更多的设置，因为它需要两个活动。我们将创建两个活动类，并在清单中声明它们。我们还将创建一个按钮，就像在之前的配方中做的那样，以切换到活动。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll create a new project in Android Studio, just as we did in the previous
    recipes, and call this one `ActivitySwitcher`. Android Studio will create the
    first activity, `ActivityMain`, and automatically declare it in the manifest.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Android Studio中创建一个新的项目，就像之前的配方中做的那样，并将其命名为`ActivitySwitcher`。Android Studio将创建第一个活动，`ActivityMain`，并自动在清单中声明它。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Since the Android Studio New Project wizard has already created the first activity,
    we just need to create the second activity. Open the ActivitySwitcher project
    and navigate to File | New | Activity | Empty Activity, as shown in this screenshot:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Android Studio新建项目向导已经创建了第一个活动，我们只需创建第二个活动。打开ActivitySwitcher项目，导航到文件 | 新建
    | 活动 | 空活动，如图所示：
- en: '![](img/133e7491-872e-4b22-81eb-c369e92163d5.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/133e7491-872e-4b22-81eb-c369e92163d5.png)'
- en: 'In the New Android Activity dialog, you can leave the default Activity Name
    as is, or change it to `SecondActivity`, as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“新建Android活动”对话框中，您可以保留默认的活动名称不变，或者将其更改为`SecondActivity`，如下所示：
- en: '![](img/21eca820-853d-4f58-8b34-40c1951f17b1.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/21eca820-853d-4f58-8b34-40c1951f17b1.png)'
- en: 'Open the `MainActivity.java` file and add the following function:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`文件，并添加以下函数：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, open the `activity_main.xml` file located in the `res/layout` folder and
    replace the `<TextView />` with the following XML to create the button:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开位于`res/layout`文件夹中的`activity_main.xml`文件，并用以下XML替换`<TextView />`以创建按钮：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can run the code at this point and see the second activity open. We're going
    to go further and add a button to `SecondActivity` to close it, which will bring
    us back to the first activity. Open the `SecondActivity.java` file and
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以运行代码并看到第二个活动打开。我们将进一步添加一个按钮到`SecondActivity`以关闭它，这将带我们回到第一个活动。打开`SecondActivity.java`文件并
- en: 'add this function:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加此功能：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, add the Close button to the `SecondActivity` layout. Open the `activity_second.xml`
    file and add the following `<Button>` element to the auto-generated `ConstraintLayout`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将关闭按钮添加到`SecondActivity`布局中。打开`activity_second.xml`文件，并将以下`<Button>`元素添加到自动生成的`ConstraintLayout`中：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the application on your device or emulator and see the buttons in action.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的设备或模拟器上运行应用程序，并查看按钮的实际效果。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The real work of this exercise is in the `onClickSwitchActivity()` method from
    step 3\. This is where we declare the second activity for the Intent using `SecondActivity.class`.
    We went one step further by adding the close button to the second activity to
    show a common real-world situation: launching a new activity, then returning to
    the original calling activity. This behavior is accomplished in the `onClickClose()`
    function. All it does is call `finish()`, but that tells the OS that we''re done
    with the activity. Finish doesn''t actually return us to the calling activity
    (or any specific activity for that matter); it just closes the current activity
    and relies on the application''s **back stack** to show the last activity. If
    we want a specific activity, we can again use the Intent object and specify the
    activity class name when creating the Intent.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的真正工作是在第3步中的 `onClickSwitchActivity()` 方法。这是我们使用 `SecondActivity.class`
    声明第二个活动的地方。我们更进一步，向第二个活动添加了关闭按钮，以展示一个常见的现实世界情况：启动一个新的活动，然后返回到原始调用活动。这种行为是在 `onClickClose()`
    函数中实现的。它所做的只是调用 `finish()`，但这告诉操作系统我们已经完成了这个活动。`finish()` 并不会实际上带我们回到调用活动（或任何特定的活动）；它只是关闭当前活动，并依赖于应用程序的 **返回栈**
    来显示最后一个活动。如果我们想要特定的活动，我们还可以再次使用 Intent 对象，并在创建 Intent 时指定活动类名。
- en: This activity switching does not make a very exciting application. Our activity
    does nothing but demonstrates how to switch from one activity to another, which
    of course will form a fundamental aspect of almost any application that we develop.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种活动切换并不会使应用程序变得非常吸引人。我们的活动什么也不做，只是演示了如何从一个活动切换到另一个活动，这当然将是几乎所有我们开发的应用程序的基本方面之一。
- en: 'If we had manually created the activities, we would need to add them to the
    manifest. Using the New Android Activity wizard will automatically add the necessary
    elements to the Android Manifest file. To see what Android Studio did for you,
    open the `AndroidManifest.xml` file and look at the `<application>` element:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们手动创建了活动，我们需要将它们添加到清单中。使用“新建 Android 活动”向导将自动将必要的元素添加到 Android Manifest 文件中。要查看
    Android Studio 为你做了什么，请打开 `AndroidManifest.xml` 文件并查看 `<application>` 元素：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One thing to note in the preceding auto-generated code is that the second activity
    does not have the `<intent-filter>` element. The main activity is generally the
    entry point when starting the application. That's why `MAIN` and `LAUNCHER` are
    defined so that the system will know which activity to launch when the application
    starts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面自动生成的代码中需要注意的一点是，第二个活动没有 `<intent-filter>` 元素。主活动通常是启动应用程序时的入口点。这就是为什么定义了
    `MAIN` 和 `LAUNCHER`，以便系统知道在应用程序启动时启动哪个活动。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about embedding widgets such as the Button, visit [Chapter 2](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml),
    *Views, Widgets, and Styles*
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于嵌入小部件（如按钮）的信息，请访问[第2章](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml)，*视图、小部件和样式*
- en: Passing data to another activity
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据传递给另一个活动
- en: The intent object is defined as a messaging object. As a message object, its
    purpose is to communicate with other components of the application. In this recipe,
    we'll show you how to pass information with the intent and how to get it out again.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 意图对象被定义为消息对象。作为一个消息对象，它的目的是与应用程序的其他组件进行通信。在这个菜谱中，我们将向你展示如何使用意图传递信息，以及如何再次获取它。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will pick up from where the previous one ended. We will call this
    project `SendData`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将从上一个菜谱结束的地方继续。我们将把这个项目命名为 `SendData`。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Since this recipe is building on the previous recipe, most of the work is already
    done.  We''ll add an `EditText` element to the main activity so that we have something
    to send to `SecondActivity`. We''ll use the (auto-generated) `TextView` view to
    display the message. The following are the complete steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个菜谱是在上一个菜谱的基础上构建的，所以大部分工作已经完成。我们将向主活动添加一个 `EditText` 元素，以便我们有东西可以发送到 `SecondActivity`。我们将使用（自动生成的）`TextView`
    视图来显示消息。以下是完全的步骤：
- en: 'Open `activity_main.xml` and add the following `<EditText>` element above the
    button:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并在按钮上方添加以下 `<EditText>` 元素：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<Button>` element that we created in the previous recipe doesn't change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中创建的 `<Button>` 元素没有变化。
- en: 'Now, open the `MainActivity.java` file and change the `onClickSwitchActivity()`
    method as follows:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainActivity.java` 文件，并按照以下方式修改 `onClickSwitchActivity()` 方法：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, open the `activity_second.xml` file and add the following `<TextView>`
    element:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `activity_second.xml` 文件并添加以下 `<TextView>` 元素：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The last change is to edit the second activity to look for this new data and
    display it on the screen. Open `SecondActivity.java` and edit `onCreate()` as
    follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个更改是编辑第二个活动以查找新数据并在屏幕上显示它。打开 `SecondActivity.java` 并按以下方式编辑 `onCreate()`：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, run the project. Type some text in the main activity and press Launch Second
    Activity to see it send the data.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目。在主活动中输入一些文本，然后按“启动第二个活动”以查看它发送数据。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As expected, the Intent object is doing all the work. We created an intent just
    as in the previous recipe and then added some extra data. Did you notice the `putExtra()`
    method call? In our example, we used the already defined `Intent.EXTRA_TEXT` as
    the identifier, but we didn't have to. We can use any key we want (you've seen
    this concept before if you're familiar with name/value pairs).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，Intent 对象正在做所有的工作。我们创建了一个意图，就像在先前的食谱中一样，然后添加了一些额外数据。您注意到 `putExtra()`
    方法的调用吗？在我们的例子中，我们使用了已定义的 `Intent.EXTRA_TEXT` 作为标识符，但我们不必这样做。我们可以使用任何我们想要的键（如果您熟悉名称/值对，您已经见过这个概念）。
- en: The key point about using name/value pairs is that you have to use the same
    name to get the data back out. That's why we used the same key identifier when
    we read the extra data with `getStringExtra()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称/值对的关键点是您必须使用相同的名称来获取数据。这就是为什么我们在使用 `getStringExtra()` 读取额外数据时使用了相同的键标识符。
- en: 'The second activity was launched with the intent that we created, so it''s
    simply a matter of getting the intent and checking for the data sent along with
    it. We do this in `onCreate()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个活动是使用我们创建的意图启动的，所以这只是一个获取意图并检查随它发送的数据的问题。我们在 `onCreate()` 中这样做：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We aren't limited to just sending `String` data. The intent object is very flexible
    and already supports basic data types. Go back to Android Studio and click on
    the `putExtra` method. Then, hit *Ctrl* and the spacebar. Android Studio will
    bring up the auto-complete list so that you can see the different data types that
    you can store.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于发送 `String` 数据。意图对象非常灵活，并且已经支持基本数据类型。回到 Android Studio，点击 `putExtra` 方法。然后，按
    *Ctrl* 和空格键。Android Studio 将显示自动完成列表，以便您可以看到可以存储的不同数据类型。
- en: Returning a result from an activity
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从一个活动返回结果
- en: Being able to start one activity from another is very useful and commonly used,
    but there are times when we need to know the result from the called activity.
    The `startActivityForResult()` method provides the solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从一个活动启动另一个活动非常有用且常用，但有时我们需要知道被调用活动的结果。`startActivityForResult()` 方法提供了解决方案。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Returning a result from an activity is not very different from the way we just
    called the activity in the previous recipes. You can either use the project from
    the previous recipe or start a new project and call it `GettingResults`. Either
    way, once you have a project with two activities and the code needed to call the
    second activity, you're ready to begin.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个活动返回结果与我们在前面的食谱中调用活动的方式非常相似。您可以使用上一个食谱中的项目，或者开始一个新的项目并将其命名为 `GettingResults`。无论哪种方式，一旦您有一个包含两个活动和调用第二个活动所需代码的项目，您就可以开始了。
- en: How to do it...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are only a few changes needed to get the results:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 只需进行少量更改即可获取结果：
- en: 'First of all, open `MainActivity.java` and add the following constant to the
    class:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开 `MainActivity.java` 并将以下常量添加到类中：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, change the way the intent is called by modifying the `onClickSwitchActivity()`
    method to expect a result:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过修改 `onClickSwitchActivity()` 方法来更改调用意图的方式，使其期望一个结果：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, add this new method to receive the result:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加此新方法以接收结果：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, modify `onClickClose` in `SecondActivity.java` to set the return value
    as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改 `SecondActivity.java` 中的 `onClickClose` 以设置返回值如下：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, getting the results back is relatively straightforward. We just
    call the intent with `startActivityForResult`, indicating we want a result back.
    We set up the `onActivityResult()` callback handler to receive the results. Finally,
    we make sure that the second activity returns a result with `setResult()` before
    closing the activity. In this example, we are just setting a result with a static
    value. We use a simple Toast to display the result back to the user.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，获取结果相对直接。我们只需使用 `startActivityForResult` 调用意图，表示我们想要返回一个结果。我们设置 `onActivityResult()`
    回调处理程序来接收结果。最后，在关闭活动之前，我们确保第二个活动使用 `setResult()` 返回一个结果。在这个例子中，我们只是使用一个静态值设置结果。我们使用一个简单的
    Toast 将结果显示给用户。
- en: It's good practice to check the result code to make sure that the user didn't
    cancel the action. It's technically an integer, but the system uses it as a Boolean
    value. Check for either `RESULT_OK` or `RESULT_CANCEL` and proceed accordingly.
    In our example, the second activity doesn't have a cancel button, so why bother
    to check? What if the user hits the back button? Android will set the result code
    to `RESULT_CANCEL` and the intent to null, which would cause our code to throw
    an exception if we attempt to access the null result.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果码是一个好习惯，以确保用户没有取消操作。技术上它是一个整数，但系统将其用作布尔值。检查`RESULT_OK`或`RESULT_CANCEL`并根据情况相应处理。在我们的例子中，第二个活动没有取消按钮，为什么还要检查？如果用户点击返回按钮怎么办？Android会将结果码设置为`RESULT_CANCEL`并将intent设置为null，如果我们尝试访问null结果，这会导致我们的代码抛出异常。
- en: We made use of the **Toast** object, which displays a convenient pop-up **message **to
    unobtrusively notify the user. It also functions as a handy method for debugging
    as it doesn't need a special layout or screen space.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了**Toast**对象，它显示一个方便的弹出**消息**来不引人注目地通知用户。它还作为一个方便的调试方法，因为它不需要特殊的布局或屏幕空间。
- en: There's more...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Besides the result code, `onActivityResults()` also includes a **Request Code**.
    Are you wondering where that came from? It is simply the integer value that was
    passed with the `startActivityForResult()` call, which takes this form:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结果码之外，`onActivityResults()`还包括一个**请求码**。你在想它从哪里来吗？它只是与`startActivityForResult()`调用一起传递的整数值，其形式如下：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We didn't check the request code because we knew we had only one result to handle,
    but in non-trivial applications with several activities, this value can be used
    to identify which Activity is returning a result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有检查请求码，因为我们知道我们只有一个结果要处理，但在具有多个活动的非平凡应用中，这个值可以用来识别哪个活动正在返回结果。
- en: If `startActivityForResult()` is called with a negative request code, it will
    behave the same as if we used `startActivity()`, that is, it will not return a
    result.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`startActivityForResult()`方法被调用时带有负请求码，它的行为将与使用`startActivity()`相同，即它不会返回结果。
- en: See also
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about creating new activity classes, refer to the *Switching between
    activities* recipe
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于创建新活动类的信息，请参考*在活动之间切换*食谱。
- en: For more information about Toasts, check out the *Making a Toast* recipe in
    [Chapter 8](3d708b9b-223b-493a-bf48-48fc306aa0a5.xhtml), *Alerts and Notifications*
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于Toast的信息，请参阅第8章的*制作Toast*食谱，*警报和通知*。
- en: Saving an activity's state
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存活动状态
- en: The mobile environment is very dynamic, with users changing tasks much more
    often than on desktops. With generally fewer resources on a mobile device, it
    should be expected that your application will be interrupted at some point. It's
    also very possible that the system will shut down your app completely to give
    additional resources to the task at hand. It's the nature of mobiles.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 移动环境非常动态，用户比在桌面电脑上更频繁地切换任务。由于移动设备上通常资源较少，预期你的应用在某个时刻会被中断是合理的。系统也可能完全关闭你的应用以向当前任务提供额外资源。这是移动设备的特性。
- en: A user might start typing something in your app, be interrupted by a phone call,
    or switch over to send a text message, and by the time they get back to your app,
    the OS may have closed your app completely to free up the memory. To provide the
    best user experience, you need to expect such behavior and make it easier for
    your user to resume from where they left off. The good thing is that the Android
    OS makes this easier by providing callbacks to notify your app of state changes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能在你的应用中开始输入某些内容，然后被电话中断，或者切换到发送短信，当他们回到你的应用时，操作系统可能已经完全关闭了你的应用以释放内存。为了提供最佳的用户体验，你需要预期这种行为，并让用户更容易从他们离开的地方继续。好消息是，Android操作系统通过提供回调来通知你的应用状态变化，这使得这一切变得更加容易。
- en: 'Simply rotating your device will cause the OS to destroy and recreate your
    activity. This might seem a bit heavy-handed, but it''s done for a good reason:
    it''s very common to have different layouts for portrait and landscape, so this
    ensures that your app is using the correct resources.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地旋转设备将导致操作系统销毁并重新创建你的活动。这可能会显得有些过于强硬，但这样做是有好理由的：在纵向和横向布局不同的情况下非常常见，这确保了你的应用正在使用正确的资源。
- en: In this recipe, you'll see how to handle the `onSaveInstanceState()` and `onRestoreInstanceState()`
    callbacks to save your application's state. We will demonstrate this by creating
    a counter variable and increment it each time the Count
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，您将了解如何处理 `onSaveInstanceState()` 和 `onRestoreInstanceState()` 回调以保存应用程序的状态。我们将通过创建一个计数变量并在每次计数时增加它来演示这一点。
- en: button is pressed. We will also have an `EditText` and a `TextView` widget to
    see their default behavior.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，我们将还有一个 `EditText` 和 `TextView` 小部件来查看它们的默认行为。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and name it `StateSaver`. We need only
    a single activity, so the auto-generated main activity is sufficient. However,
    we will need a few widgets, including `EditText`, `Button`, and `TextView`. Their
    layout (in `activity_main.xml`) will be as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `StateSaver`。我们只需要一个活动，因此自动生成的主活动就足够了。但是，我们需要一些小部件，包括
    `EditText`、`Button` 和 `TextView`。它们的布局（在 `activity_main.xml` 中）如下所示：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following set of steps:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'To keep track of the counter, we need to add a global variable to the project,
    along with a key for saving and restoring. Add the following code to the `MainActivity.java`
    class:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了跟踪计数器，我们需要向项目中添加一个全局变量，以及一个用于保存和恢复的键。将以下代码添加到 `MainActivity.java` 类中：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, add the code needed to handle the button press; it increments the counter
    and displays the result in the `TextView` widget:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加处理按钮点击所需的代码；它增加计数器并在 `TextView` 小部件中显示结果：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To receive notifications of application state change, we need to add the `onSaveInstanceState()`
    and `onRestoreInstanceState()` methods to our application. Open `MainActivity.java`
    and add the following:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要接收应用程序状态更改的通知，我们需要将 `onSaveInstanceState()` 和 `onRestoreInstanceState()` 方法添加到我们的应用程序中。打开
    `MainActivity.java` 并添加以下代码：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the program and try changing the orientation to see how it behaves (if you're
    using the emulator, *Ctrl* + *F11* will rotate the device).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并尝试更改方向以查看其行为（如果您使用的是模拟器，*Ctrl* + *F11* 将旋转设备）。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: All activities go through multiple states during their lifetime. By setting
    up callbacks to handle the events, we can have our code save important information
    before the activity is destroyed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有活动在其生命周期中都会经历多个状态。通过设置处理事件的回调，我们可以在活动被销毁之前保存重要信息。
- en: Step 3 is where the actual saving and restoring occurs. The OS sends a **Bundle**
    (a data object that also uses name/value pairs) to the methods. We use the `onSaveInstanceState()`
    callback to save the data and pull it out in the `onRestoreInstanceState()` callback.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 步是实际保存和恢复发生的地方。操作系统向方法发送一个 **Bundle**（一个使用名称/值对的数据对象）。我们使用 `onSaveInstanceState()`
    回调来保存数据，并在 `onRestoreInstanceState()` 回调中提取它。
- en: But wait! Did you try typing text in the `EditText` view before rotating the
    device? If so, you'd have noticed that the text was also restored, but we don't
    have any code to handle that view. By default, the system will automatically save
    the state, provided it has a unique ID.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！您在旋转设备之前尝试在 `EditText` 视图中输入文本了吗？如果是这样，您会注意到文本也被恢复了，但我们没有处理该视图的代码。默认情况下，如果系统有一个唯一的
    ID，它将自动保存状态。
- en: 'Note that if you want Android to automatically save and restore the state of
    a view, it must have a unique ID (specified with the `android:id=` attribute in
    the layout). Bur beware: not all view types automatically save and restore the
    state of a view.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您想让 Android 自动保存和恢复视图的状态，该视图必须有一个唯一的 ID（在布局中使用 `android:id=` 属性指定）。但请注意：并非所有视图类型都会自动保存和恢复视图的状态。
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `onRestoreInstanceState()` callback is not the only place where the state
    can be restored. Look at the signature of `onCreate()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`onRestoreInstanceState()` 回调并不是唯一可以恢复状态的地方。看看 `onCreate()` 的签名：'
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Both methods receive the same `Bundle` instance named `savedInstanceState`.
    You could move the restore code to the `onCreate()` method and it would work the
    same. But one catch is that the `savedInstanceState` bundle will be null if there
    is no data, such as during the initial creation of the activity. If you want to
    move the code from the `onRestoreInstanceState()` callback, just check to make
    sure that the data is not null. Here''s how that code would look:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都接收同一个名为 `savedInstanceState` 的 `Bundle` 实例。您可以将恢复代码移动到 `onCreate()` 方法，并且它将按相同的方式工作。但有一个要注意的是，如果没有数据，例如在活动的初始创建期间，`savedInstanceState`
    包将是一个空值。如果您想从 `onRestoreInstanceState()` 回调中移动代码，只需确保数据不是空值。以下是该代码的示例：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Storing persistent activity data* recipe will introduce persistent storage
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*存储持久活动数据*菜谱将介绍持久存储'
- en: Take a look at [Chapter 7](2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml), Data
    Storage, for more examples on how to persist data
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看第7章[数据存储](2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml)，了解更多关于如何持久化数据的示例
- en: The *Understanding the activity life cycle* recipe explains the Android Activity
    life cycle
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*理解活动生命周期*菜谱解释了Android Activity的生命周期'
- en: Storing persistent activity data
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储持久活动数据
- en: Being able to store information about our activities on a temporary basis is
    very useful, but more often than not, we will want our application to remember
    information across multiple sessions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 能够暂时存储关于我们活动的信息非常有用，但往往我们希望我们的应用程序能够在多个会话中记住信息。
- en: Android supports SQLite, but that could be a lot of overhead for simple data,
    such as the user's name or a high score. Fortunately, Android also provides a
    lightweight option for these scenarios with `SharedPreferences`. (In a real-world
    application, you'll likely use both options for saving data.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持SQLite，但对于简单的数据，如用户名或高分，这可能需要很多开销。幸运的是，Android还提供了`SharedPreferences`这样的轻量级选项来处理这些场景。（在实际应用中，您可能会同时使用这两种选项来保存数据。）
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can either use the project from the previous recipe or start a new project
    and call it `PersistentData`. In the previous recipe, we saved `mCounter` in the
    session state. In this recipe, we'll add a new method to handle `onPause()` and
    save `mCounter` to `SharedPreferences`. We'll restore the value in `onCreate()`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用前一个菜谱中的项目，或者启动一个新的项目并将其命名为`PersistentData`。在前一个菜谱中，我们在会话状态中保存了`mCounter`。在这个菜谱中，我们将添加一个新的方法来处理`onPause()`并将`mCounter`保存到`SharedPreferences`。我们将在`onCreate()`中恢复该值。
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We have only two changes to make, and both are in `MainActivity.java`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要做两个更改，这两个更改都在`MainActivity.java`中：
- en: 'Add the following `onPause()` method to save the data before the activity closes:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在活动关闭前添加以下`onPause()`方法以保存数据：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add the following code at the end of `onCreate()` to restore the counter:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`onCreate()`的末尾添加以下代码以恢复计数器：
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program and try it out.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并尝试使用它。
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see, this is very similar to saving state data, because it also uses
    name/value pairs. Here, we just stored an `int`, but we can just as easily store
    one of the other primitive data types. Each data type has equivalent getters and
    setters, for example, `SharedPreferences.getBoolean()` or `SharedPreferences.setString()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与保存状态数据非常相似，因为它也使用名称/值对。在这里，我们只存储了一个`int`，但我们同样可以轻松地存储其他原始数据类型之一。每种数据类型都有等效的获取器和设置器，例如，`SharedPreferences.getBoolean()`或`SharedPreferences.setString()`。
- en: Saving our data requires the services of `SharedPreferences.Editor`. This is
    evoked with `edit()` and accepts `remove()` and `clear()` procedures, as well
    as setters such as `putInt()`. Note that we must conclude any changes with the
    `commit()` statement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 保存我们的数据需要`SharedPreferences.Editor`服务的帮助。这可以通过`edit()`调用，并接受`remove()`和`clear()`过程，以及如`putInt()`之类的设置器。请注意，我们必须以`commit()`语句结束任何更改。
- en: There's more...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'There is a slightly more sophisticated variant of the `getPreferences()` accessor:
    `getSharedPreferences()`. It can be used to store multiple preference sets.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPreferences()`访问器的稍微复杂一些的变体是`getSharedPreferences()`。它可以用来存储多个偏好集。'
- en: Using more than one preference file
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个偏好文件
- en: 'Using `getSharedPreferences()` is no different from using its counterpart,
    but it allows for more than one preference file. It takes the following form:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getSharedPreferences()`与使用其对应方法没有区别，但它允许使用多个偏好文件。其形式如下：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, `name` is the file. The `mode` can be either `MODE_PRIVATE`, `MODE_WORLD_READABLE`,
    or `MODE_WORLD_WRITABLE` and describes the file's access levels.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`name`是文件名。`mode`可以是`MODE_PRIVATE`、`MODE_WORLD_READABLE`或`MODE_WORLD_WRITABLE`，它描述了文件的访问级别。
- en: See also
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '[Chapter 7](2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml), *Data Storage*, for
    more examples on data storage'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](2bf1b0ac-516b-48e1-95f6-ce76f2046d20.xhtml)，*数据存储*，了解更多关于数据存储的示例'
- en: Understanding the activity life cycle
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解活动生命周期
- en: As mobile hardware continues to improve, so too does the demand placed on that
    hardware. With increasingly more powerful applications and user multi-tasking,
    the already limited resources can be quite challenging. The Android OS has many
    features built in to help the user get the best performance from their device,
    such as limiting background processes, disabling application notifications, and
    allowing data limits. The OS will also manage application lifetime based on foreground
    tasks. If your application is in the foreground, the life cycle is straightforward.
    But as soon as your user switches tasks and your application is moved to the background,
    understanding the Android application life cycle becomes very important.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着移动硬件的不断改进，对硬件的需求也在增加。随着更多强大应用程序和用户多任务处理的出现，已经有限的资源可能会面临很大的挑战。Android 操作系统内置了许多功能来帮助用户从设备中获得最佳性能，例如限制后台进程、禁用应用程序通知以及允许数据限制。操作系统还将根据前台任务管理应用程序的生命周期。如果您的应用程序在前台，生命周期是直接的。但是，一旦用户切换任务并且您的应用程序被移动到后台，理解
    Android 应用程序生命周期就变得非常重要。
- en: 'The following diagram shows the stages through which an activity passes during
    its lifetime:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了活动在其生命周期中经过的阶段：
- en: '![](img/ef2056bc-430c-4f66-b623-6c0055c0a21f.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef2056bc-430c-4f66-b623-6c0055c0a21f.png)'
- en: Along with the stages, the diagram also shows the methods that can be overridden.
    As you can see, we've already utilized most of these methods in the preceding
    recipes. Hopefully, getting the big picture will help your understanding.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阶段之外，该图还显示了可以重写的方法。如您所见，我们已经在先前的菜谱中使用了这些方法中的大部分。希望了解整体情况能帮助您理解。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio with a Blank Activity, and call it `ActivityLifecycle`.
    We will use the (auto-generated) `TextView` method to display the state information.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，选择一个空白活动，并将其命名为 `ActivityLifecycle`。我们将使用（自动生成的）`TextView`
    方法来显示状态信息。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: To see the application move through the various stages, we will create methods
    for all
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到应用程序通过各个阶段，我们将为所有
- en: 'the stages:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段：
- en: 'Open `activity_main.xml` and add an ID to the auto-generated `TextView`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并为自动生成的 `TextView` 添加一个 ID：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The remaining steps will be in `MainActivity.java`. Modify the `onCreate()`
    method to set the initial text:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩余步骤将在 `MainActivity.java` 中进行。修改 `onCreate()` 方法以设置初始文本：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following methods to handle the remaining events:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法来处理剩余的事件：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the application and observe what happens when the activity is interrupted
    by pressing the Back and Home keys. Try other actions, such as task switching,
    to see how they impact your application.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，并观察当按下返回键和主页键中断活动时会发生什么。尝试其他操作，如任务切换，以查看它们如何影响您的应用程序。
- en: How it works...
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Our activity can exist in one of these three states: **active**, **paused**,
    or **stopped**. There is also'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动可以存在于以下三种状态之一：**活跃**、**暂停**或**停止**。还有一个
- en: 'a fourth state, **destroyed** (but there''s no guarantee the OS will ever call
    it):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种状态，**销毁**（但无法保证操作系统会调用它）：
- en: An activity is in the `active` state when its interface is available for the
    user. It persists from `onResume()` until `onPause()`, which is brought about
    when another activity comes to the foreground. If this new activity does not entirely
    obscure our activity, then ours will remain in the `paused` state until the new
    activity is finished or dismissed. It will then immediately call `onResume()`
    and continue.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当活动的界面可供用户使用时，活动处于 `活跃` 状态。它从 `onResume()` 开始，直到 `onPause()`，这是当另一个活动进入前台时触发的。如果这个新活动并没有完全遮挡我们的活动，那么我们的活动将保持在
    `暂停` 状态，直到新活动完成或被取消。然后它将立即调用 `onResume()` 并继续。
- en: When a newly started activity fills the screen or makes our activity invisible,
    then our activity will enter the `stopped` state, and resumption will always invoke
    a call to `onRestart()`.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个新启动的活动填满屏幕或使我们的活动不可见时，我们的活动将进入 `停止` 状态，并且恢复将始终调用 `onRestart()`。
- en: When an activity is in either the `paused` or `stopped` state, the operating
    system can (and will) remove it from the memory when the memory is low or when
    other applications demand it.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当活动处于 `暂停` 或 `停止` 状态时，操作系统可以在内存不足或其他应用程序需要时将其从内存中移除。
- en: 'It is worth noting that we never actually see the results of the `onDestroy()`
    method, as the activity is removed by this point. If you want to explore these
    methods further, then it is well worth employing `Activity.isFinishing()` to see
    whether the activity is really finishing before `onDestroy()` is executed, as
    seen in the following snippet:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，我们实际上从未看到`onDestroy()`方法的结果，因为到这时活动已经被移除。如果你想进一步探索这些方法，那么使用`Activity.isFinishing()`来查看在`onDestroy()`执行之前活动是否真的正在结束是非常有价值的，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When implementing these methods, always call the superclass before doing any
    work.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这些方法时，始终在执行任何工作之前调用超类。
- en: There's more...
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To shut down an activity, directly call its `finish()` method, which in turn
    calls `onDestroy()`. To perform the same action from a child activity, use `finishFromChild(Activity
    child)`, where `child` is the calling subactivity.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭一个活动，直接调用其`finish()`方法，该方法会依次调用`onDestroy()`。要从子活动中执行相同操作，使用`finishFromChild(Activity
    child)`，其中`child`是调用子活动。
- en: It is often useful to know whether an activity is being shut down or merely
    paused, and the `isFinishing(boolean)` method returns a value that indicates which
    of these two states the activity is in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有时知道活动是正在关闭还是仅仅暂停是有用的，`isFinishing(boolean)`方法返回一个值，表示活动处于这两种状态中的哪一种。
