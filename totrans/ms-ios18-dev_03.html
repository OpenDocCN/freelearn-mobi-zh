<html><head></head><body>
		<div><h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor097"/><st c="0">3</st></h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor098"/><st c="2">Understanding SwiftUI Observation</st></h1>
			<p><st c="35">In </st><a href="B21795_02.xhtml#_idTextAnchor043"><em class="italic"><st c="39">Chapter 2</st></em></a><st c="48">, we discussed SwiftData, an essential framework for our data management. </st><st c="122">However, for data management to be effective, we need something on the other side that can observe changes and display them for </st><st c="250">the user.</st></p>
			<p><st c="259">SwiftUI contains tools that allow us to observe these changes effectively and bind them to actions and UI updates. </st><st c="375">However, these tools have become complex and confusing over </st><st c="435">the years.</st></p>
			<p><st c="445">Now, we’re about to explore how observation has become significantly more straightforward, all while delving into the heart of SwiftUI’s </st><st c="583">data flow.</st></p>
			<p><st c="593">In this chapter, we will cover the </st><st c="629">following topics:</st></p>
			<ul>
				<li><st c="646">Go over the SwiftUI observation system and discuss </st><st c="698">its problems</st></li>
				<li><st c="710">Add the </st><code><st c="719">@Observable</st></code><st c="730"> macro and learn how </st><st c="751">it works</st></li>
				<li><st c="759">Discuss observing properties, including </st><st c="800">computed variables</st></li>
				<li><st c="818">Work with environment variables and adapt them to the </st><st c="873">new framework</st></li>
				<li><st c="886">Talk about the new </st><code><st c="906">@Bindable</st></code> <st c="915">property wrapper</st></li>
				<li><st c="932">Learn how to migrate our app to work with the </st><st c="979">Observation framework</st></li>
			</ul>
			<p><st c="1000">Are you ready </st><st c="1015">to start?</st></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor099"/><st c="1024">Technical requirements</st></h1>
			<p><st c="1047">This chapter includes many code examples, some of which can be found in the following GitHub </st><st c="1141">repository: </st><a href="https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3"><st c="1153">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3</st></a></p>
			<p><st c="1235">To run them, we will need Xcode 15 </st><st c="1271">or newer.</st></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor100"/><st c="1280">Going over the SwiftUI observation system</st></h1>
			<p><st c="1322">Before we discuss the</st><a id="_idIndexMarker107"/><st c="1344"> current SwiftUI observation system, let’s recap the SwiftUI </st><st c="1405">observation system.</st></p>
			<p><st c="1424">Before Xcode 15, nine property wrappers handled state and data updates </st><st c="1496">in SwiftUI.</st></p>
			<p><st c="1507">Let’s try to group them by </st><st c="1535">app levels:</st></p>
			<ul>
				<li><code><st c="1564">@</st></code><code><st c="1565">Binding</st></code><st c="1572">, </st><code><st c="1574">@Environment</st></code></li>
				<li><code><st c="1600">@State</st></code><st c="1606">, </st><code><st c="1608">@Binding</st></code><st c="1616">, </st><code><st c="1618">@</st></code><code><st c="1619">StateObject</st></code><st c="1630">, </st><code><st c="1632">@Environment</st></code></li>
				<li><code><st c="1668">@</st></code><code><st c="1669">ObservableObject</st></code><st c="1685">, </st><code><st c="1687">@Published</st></code></li>
				<li><code><st c="1715">@AppStorage</st></code><st c="1726">, </st><code><st c="1728">@</st></code><code><st c="1729">SceneStorage</st></code><st c="1741">, </st><code><st c="1743">@EnvironementObject</st></code></li>
			</ul>
			<p><st c="1762">The different levels give us an idea of the different roles of the different wrappers. </st><st c="1850">Let’s touch on some of these wrappers to understand how the </st><st c="1910">system works.</st></p>
			<p><st c="1923">A local </st><code><st c="1932">@State</st></code><st c="1938"> property wrapper manages the state of primitive properties within the view. </st><st c="2015">For example, whether a specific view is hidden, the number of available buttons, the current sorting method, and more are managed by </st><st c="2148">this wrapper.</st></p>
			<p><st c="2161">The reason why we use a </st><code><st c="2186">@State</st></code><st c="2192"> property wrapper is because SwiftUI views are immutable. </st><st c="2250">This means that SwiftUI rebuilds the view each time a change occurs, but the </st><code><st c="2327">@State</st></code><st c="2333"> values don’t change between one rendering session </st><st c="2384">and another.</st></p>
			<p><st c="2396">The problem begins when we base our view on data model information. </st><st c="2465">An example of this would be a bookstore app that displays a list of books from a local data file. </st><st c="2563">In this case, our view must work with another data model object using the </st><code><st c="2637">ObservableObject</st></code><st c="2653"> protocol.</st></p>
			<p><st c="2663">Let’s go over </st><st c="2678">it now.</st></p>
			<h2 id="_idParaDest-61"><st c="2685">Conforming to the ObservableObject protocol</st><a id="_idTextAnchor101"/><a id="_idTextAnchor102"/></h2>
			<p><st c="2729">We can use the </st><code><st c="2745">ObservableObject</st></code><st c="2761"> protocol in conjunction with the </st><code><st c="2795">@ObservedObject</st></code><st c="2810"> property </st><a id="_idIndexMarker108"/><st c="2820">wrapper for </st><a id="_idIndexMarker109"/><st c="2832">classes that need to </st><st c="2853">be observed.</st></p>
			<p><st c="2865">Here’s an example of a </st><code><st c="2889">UserData</st></code><st c="2897"> class which becomes an </st><code><st c="2921">@ObservedObject </st></code><st c="2937">property wrapper:</st></p>
			<pre class="source-code"><st c="2954">
class UserData: </st><strong class="bold"><st c="2971">ObservableObject</st></strong><st c="2987"> {
    </st><strong class="bold"><st c="2990">@Published </st></strong><st c="3001">var username = "Avi Tsadok"
}
struct ContentView: View {
</st><strong class="bold"><st c="3058">    @ObservedObject var userData = UserData()</st></strong><st c="3099">
    var body: some View {
        Text("Welcome, \(userData.username)!")
            .padding()
    }
}</st></pre>			<p><st c="3175">There are three parts to</st><a id="_idIndexMarker110"/><st c="3200"> implementing a data </st><st c="3221">class observation:</st></p>
			<ol>
				<li><code><st c="3254">ObservableObject</st></code><st c="3270">: If we want a class to be observed in SwiftUI, it must conform to the </st><code><st c="3342">ObservableObject</st></code><st c="3358"> protocol. </st><st c="3369">This indicates to SwiftUI that </st><a id="_idIndexMarker111"/><st c="3400">any instance derived from this class can be observed in </st><st c="3456">a view.</st></li>
				<li><code><st c="3475">@Published</st></code><code><st c="3536">@Published</st></code><st c="3546"> property wrapper, SwiftUI creates a publisher and uses it inside the </st><st c="3616">SwiftUI views.</st></li>
				<li><code><st c="3658">@ObservedObject</st></code><code><st c="3697">@ObservedObject</st></code><st c="3712"> property wrapper establishes a connection between the view and the object, allowing the view to be notified </st><st c="3821">of chan</st><a id="_idTextAnchor103"/><a id="_idTextAnchor104"/><st c="3828">ges.</st></li>
			</ol>
			<p><st c="3833">It’s essential to remember that the </st><code><st c="3870">@ObservedObject</st></code><st c="3885"> property wrapper is solely for observation purposes – this means that the view cannot modify the observed object </st><st c="3999">properties directly.</st></p>
			<p><st c="4019">If we want to change the observed object properties, we must use another property wrapper – </st><code><st c="4112">@</st></code><code><st c="4113">StateObj</st><a id="_idTextAnchor105"/><a id="_idTextAnchor106"/><st c="4121">ect</st></code><st c="4125">.</st></p>
			<p><st c="4126">A </st><code><st c="4129">@StateObject</st></code><st c="4141"> property wrapper is similar to </st><code><st c="4173">@State</st></code><st c="4179">, only that it works with observable objects and not </st><st c="4232">primitive values.</st></p>
			<p><st c="4249">However, that doesn’t end </st><a id="_idIndexMarker112"/><st c="4276">here – if we want to create a two-way connection between the view and its subview, we need </st><a id="_idIndexMarker113"/><st c="4367">to add a </st><code><st c="4376">@Binding</st></code><st c="4384"> property wrapper to the subview and a </st><code><st c="4423">@State</st></code><st c="4429"> property wrapper to the </st><st c="4454">parent view.</st></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor107"/><st c="4466">Explaining the problem with the current observation situation</st></h2>
			<p><st c="4528">The short recap of the current way observation works in SwiftUI emphasizes how complex and confusing it is to observe data </st><st c="4652">in SwiftUI.</st></p>
			<p><st c="4663">Take, for example, the </st><code><st c="4687">ObservableObject</st></code><st c="4703"> protocol – in most cases, we want to mark all of our properties with the </st><code><st c="4777">@Published</st></code><st c="4787"> property wrapper. </st><st c="4806">If that’s the case, why do we need to </st><a id="_idIndexMarker114"/><st c="4844">work hard? </st><st c="4855">Don’t we have a way to add a </st><code><st c="4884">@Published</st></code><st c="4894"> property wrapper to all </st><st c="4919">our properties?</st></p>
			<p><st c="4934">The observation framework uses Swift macros here, a feature that can help us reduce boilerplate code. </st><st c="5037">To read more about it, go to </st><a href="B21795_10.xhtml#_idTextAnchor329"><em class="italic"><st c="5066">Chapter 10</st></em></a><st c="5076"> and read about </st><st c="5092">Swift macros.</st></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor108"/><st c="5105">Adding the @Observable macro</st></h1>
			<p><st c="5134">The primary goal of the </st><a id="_idIndexMarker115"/><st c="5159">Observation framework is to simplify our work as much as possible, and it does that with the heavy use </st><st c="5262">of macros.</st></p>
			<p><st c="5272">Let’s take a </st><code><st c="5286">Book</st></code><st c="5290"> class, </st><st c="5298">for example:</st></p>
			<pre class="source-code"><st c="5310">
class Book: </st><strong class="bold"><st c="5323">ObservableObject</st></strong><st c="5339"> {
    </st><strong class="bold"><st c="5342">@Published</st></strong><st c="5352"> var title:String = ""
    </st><strong class="bold"><st c="5375">@Published</st></strong><st c="5385"> var author: String = ""
    </st><strong class="bold"><st c="5410">@Published </st></strong><st c="5421">var publishedYear: Date = Date()
    </st><strong class="bold"><st c="5454">@Published</st></strong><st c="5464"> var numberOfPages: Int = 0
}</st></pre>			<p><st c="5493">The </st><code><st c="5498">Book</st></code><st c="5502"> class is a standard </st><code><st c="5523">ObservableObject</st></code><st c="5539"> class that contains four properties with a </st><code><st c="5583">@Published</st></code> <st c="5593">property wrapper.</st></p>
			<p><st c="5611">Using the </st><code><st c="5622">Observation</st></code><st c="5633"> framework, we</st><a id="_idIndexMarker116"/><st c="5647"> can get rid of all the property wrappers and the </st><code><st c="5697">ObservableObject</st></code><st c="5713"> protocol and just add a macro attached to the </st><st c="5760">class decl</st><a id="_idTextAnchor109"/><a id="_idTextAnchor110"/><st c="5770">aration:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="5779">@Observable</st></strong><st c="5791">
class Book {
    var title:String = ""
    var author: String = ""
    var publishedYear: Date = Date()
    var numberOfPages: Int = 0
}</st></pre>			<p><st c="5912">The </st><code><st c="5917">@Observable</st></code><st c="5928"> macro, like most macros, handles the tedious work on our behalf. </st><st c="5994">It makes the </st><code><st c="6007">Book</st></code><st c="6011"> struct observable and adds a publisher to </st><st c="6054">its properties.</st></p>
			<p><st c="6069">Let’s try to use the </st><code><st c="6091">Book</st></code><st c="6095"> class in </st><st c="6105">a view:</st></p>
			<pre class="source-code"><st c="6112">
struct ContentView: View {
    </st><strong class="bold"><st c="6140">var book:Book = Book()</st></strong><st c="6162">
    var body: some View {
        VStack {
            Text(book.title)
            Button("Change") {
</st><strong class="bold"><st c="6230">                book.title = "Mastering iOS 17"</st></strong><st c="6261">
            }
        }
        .padding()
    }
}</st></pre>			<p><st c="6280">In the preceding code, we have a button and a view with a </st><code><st c="6339">Text</st></code><st c="6343"> view that displays the book title. </st><st c="6379">Tapping on the button changes the </st><st c="6413">book title.</st></p>
			<p><st c="6424">The change of the book</st><a id="_idIndexMarker117"/><st c="6447"> title updates the text; however, the updates happen even though the book is not marked with a </st><code><st c="6542">@ObserverdObject</st></code><st c="6558"> or </st><code><st c="6562">@StateObject</st></code> <st c="6574">property wrapper!</st></p>
			<p><st c="6592">How can </st><st c="6601">this be?</st></p>
			<p><st c="6609">Let’s dive a little bit deeper to </st><st c="6644">find out!</st></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor111"/><st c="6653">Learning how the @Observable macro works</st></h2>
			<p><st c="6694">I know speaking about macros</st><a id="_idIndexMarker118"/><st c="6723"> might get on your nerves, but do you remember that </st><code><st c="6775">@Observable</st></code><st c="6786"> is a macro, and that we can </st><st c="6815">expand it?</st></p>
			<p><st c="6825">So, let’s expand it and see what’s going </st><st c="6867">on there:</st></p>
			<pre class="source-code"><st c="6876">
@Observable
class Book {
</st><strong class="bold"><st c="6902">    @ObservationTracked</st></strong><st c="6921">
    var title:String = </st><a id="_idTextAnchor112"/><a id="_idTextAnchor113"/><st c="6941">""
</st><strong class="bold"><st c="6944">        @ObservationIgnored private var _title: String = ""</st></strong>
<strong class="bold"><st c="6995">    {</st></strong>
<strong class="bold"><st c="6997">        @storageRestrictions(initializes: _title)</st></strong>
<strong class="bold"><st c="7039">        init(initialValue) {</st></strong>
<strong class="bold"><st c="7060">          _title = initialValue</st></strong>
<strong class="bold"><st c="7082">        }</st></strong>
<strong class="bold"><st c="7084">        get {</st></strong>
<strong class="bold"><st c="7090">          access(keyPath: \.title)</st></strong>
<strong class="bold"><st c="7115">          return _title</st></strong>
<strong class="bold"><st c="7129">        }</st></strong>
<strong class="bold"><st c="7131">        set {</st></strong>
<strong class="bold"><st c="7137">          withMutation(keyPath: \.title) {</st></strong>
<strong class="bold"><st c="7170">            _title = newValue</st></strong>
<strong class="bold"><st c="7188">          }</st></strong>
<strong class="bold"><st c="7190">        }</st></strong>
<strong class="bold"><st c="7192">    }</st></strong>
<strong class="bold"><st c="7194">    @ObservationTracked</st></strong><st c="7214">
    var author: String = ""
</st><strong class="bold"><st c="7239">    @ObservationTracked</st></strong><st c="7258">
    var publishedYear: Date = Date()
</st><strong class="bold"><st c="7292">    @ObservationTracked</st></strong><st c="7311">
    var numberOfPages: Int = 0
</st><strong class="bold"><st c="7339">    @ObservationIgnored private let _$observationRegistrar</st></strong>
<strong class="bold"><st c="7393">      = Observation.ObservationRegistrar()</st></strong>
<strong class="bold"><st c="7430">    internal nonisolated func access&lt;Member&gt;(</st></strong>
<strong class="bold"><st c="7472">      keyPath: KeyPath&lt;Book , Member&gt;</st></strong>
<strong class="bold"><st c="7504">    ) {</st></strong>
<strong class="bold"><st c="7508">        _$observationRegistrar.access(self, keyPath:</st></strong>
<strong class="bold"><st c="7553">        keyPath)</st></strong>
<strong class="bold"><st c="7562">    }</st></strong>
<strong class="bold"><st c="7564">    internal nonisolated func withMutation&lt;Member,</st></strong>
<strong class="bold"><st c="7611">      MutationResult&gt;(</st></strong>
<strong class="bold"><st c="7628">      keyPath: KeyPath&lt;Book , Member&gt;,</st></strong>
<strong class="bold"><st c="7661">      _ mutation: () throws -&gt; MutationResult</st></strong>
<strong class="bold"><st c="7701">    ) rethrows -&gt; MutationResult {</st></strong>
<strong class="bold"><st c="7732">      try _$observationRegistrar.withMutation(of: self,</st></strong>
<strong class="bold"><st c="7782">        keyPath: keyPath, mutation)</st></strong>
<strong class="bold"><st c="7810">    }</st></strong>
<strong class="bold"><st c="7812">}</st></strong>
<strong class="bold"><st c="7813">extension Book: Observation.Observable {</st></strong>
<strong class="bold"><st c="7853">}</st></strong></pre>			<p><st c="7855">That’s a lot of work for one </st><st c="7884">tiny macro!</st></p>
			<p><st c="7895">It looks like there are also</st><a id="_idIndexMarker119"/><st c="7924"> internal macr</st><a id="_idTextAnchor114"/><a id="_idTextAnchor115"/><st c="7938">os, such as </st><code><st c="7951">@ObservationTracked</st></code><st c="7970">, one of which </st><st c="7985">I expanded.</st></p>
			<p><st c="7996">So, what’s go</st><a id="_idTextAnchor116"/><a id="_idTextAnchor117"/><st c="8010">ing </st><st c="8015">on here?</st></p>
			<p><st c="8023">There are five things we can </st><st c="8053">see here:</st></p>
			<ul>
				<li><code><st c="8157">Observable</st></code><st c="8167">, not a protocol. </st><st c="8185">The protocol itself is empty, but SwiftUI uses that to mark the class as observed. </st><st c="8268">Using an extension, you</st><a id="_idTextAnchor118"/><a id="_idTextAnchor119"/><st c="8291"> can see the protocol conformation at the end of the </st><st c="8344">macro code.</st></li>
				<li><code><st c="8378">observationRegistrar</st></code><st c="8398">: The </st><code><st c="8405">observationRegistrar</st></code><st c="8425"> variable is a singleton struct responsible for managing the registration of observed class properties. </st><st c="8529">SwiftUI relies on this struct to detect when an observed property is accessed </st><st c="8607">or modified.</st></li>
				<li><code><st c="8709">Observation</st></code><st c="8720"> framework needs these getters and setters to track every access or </st><a id="_idIndexMarker120"/><st c="8788">modification attempt.</st></li>
				<li><code><st c="8947">@Observable</st></code><st c="8958"> macro added a private variable for each original variable just for that. </st><st c="9032">The getter and the setter use the private variable to return and mutate the </st><st c="9108">stored values.</st></li>
				<li><code><st c="9172">access()</st></code><st c="9180"> and </st><code><st c="9185">withMutation()</st></code><st c="9199"> methods. </st><st c="9209">The computed variables call these methods to notify the </st><code><st c="9265">observationRegistrar</st></code><st c="9285"> instance about any data modification access. </st><st c="9331">Afterward, the </st><code><st c="9346">observationRegistrar</st></code><st c="9366">  instance tells SwiftUI about </st><st c="9396">these changes.</st></li>
			</ul>
			<p><st c="9410">The reason we have so much code underneath is that the </st><em class="italic"><st c="9466">Observation</st></em><st c="9477"> framework’s goal is to simplify the process of observing data models. </st><st c="9548">Conforming the class to the </st><em class="italic"><st c="9576">Observable</st></em><st c="9586"> protocol without the macro is not enough – marking the actual model with </st><code><st c="9660">@ObservedObject</st></code><st c="9675"> would still be required in the SwiftUI view. </st><st c="9721">The </st><em class="italic"><st c="9725">Observation</st></em><st c="9736"> framework tracks each property using its getter and setter methods, making it much cleaner to implement in </st><st c="9844">our views.</st></p>
			<p><st c="9854">Notice that there’s a small macro inside that expanded code we haven’t discussed – </st><code><st c="9938">@</st></code><code><st c="9939">ObservationIgnored</st></code><st c="9957">.</st></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor120"/><st c="9958">Excluding properties from observation using @ObservationIgnored</st></h2>
			<p><st c="10022">We already </st><a id="_idIndexMarker121"/><st c="10034">understand that, unlike the </st><a id="_idIndexMarker122"/><st c="10062">previous pattern of adding the </st><code><st c="10093">@Published</st></code><st c="10103"> property wrapper for each variable, in the </st><code><st c="10147">@Observable</st></code><st c="10158"> macro, all the properties are observed </st><st c="10198">by default.</st></p>
			<p><st c="10209">Let’s think of the consequences of that – how can it affect </st><st c="10270">our work?</st></p>
			<p><st c="10279">The fact that every property is now observed means that each time it appears in our SwiftUI view and we modify it, our view </st><st c="10404">gets updated.</st></p>
			<p><st c="10417">SwiftUI is indeed a highly optimized framework, but it is optimized because it only updates views when needed. </st><st c="10529">If a </st><a id="_idIndexMarker123"/><st c="10534">particular data model property doesn’t need to be dynamic and observed, we should exclude it from tracking. </st><st c="10642">It’s essential to balance observing many properties </st><a id="_idIndexMarker124"/><st c="10694">to keep our UI responsive and impact </st><st c="10731">its performance.</st></p>
			<p><st c="10747">Let’s try to add a property that is not supposed to </st><st c="10800">be observed:</st></p>
			<pre class="source-code"><st c="10812">
@Observable
class Book {
    var title:String = ""
    var author: String = ""
    var publishedYear: Date = Date()
    var numberOfPages: Int = 0
</st><strong class="bold"><st c="10944">    @ObservationIgnored</st></strong>
<strong class="bold"><st c="10963">    var lastPageRead: Int = 0</st></strong><st c="10989">
}</st></pre>			<p><st c="10991">In this code example, we added a property named </st><code><st c="11039">lastPageRead</st></code><st c="11051">. It’s an important property, but it doesn’t </st><a id="_idIndexMarker125"/><st c="11096">affect our UI state, and we don’t display or even consider it when laying our views. </st><st c="11181">Therefore, we will ignore it using the </st><code><st c="11220">@</st></code><code><st c="11221">ObservationIgnored</st></code><st c="11239"> macro.</st></p>
			<p><st c="11246">Unlike the </st><code><st c="11258">@ObservationTracked</st></code><st c="11277"> macro, which the </st><code><st c="11295">@Observable</st></code><st c="11306"> macro uses to create the getters and the setters for the observed properties, </st><code><st c="11385">@ObservationIgnored</st></code><st c="11404"> doesn’t modify the property. </st><st c="11434">SwiftUI uses that macro only to determine which property it doesn’t register using the </st><code><st c="11521">observati</st><a id="_idTextAnchor121"/><a id="_idTextAnchor122"/><st c="11530">onRegister</st></code><st c="11541"> object.</st></p>
			<p><st c="11549">The default observation of</st><a id="_idIndexMarker126"/><st c="11576"> all properties gives us another exciting and powerful feature out of the box – observing </st><strong class="bold"><st c="11666">computed variables</st></strong><st c="11684">.</st></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor123"/><st c="11685">Observing computed variables</st></h2>
			<p><st c="11714">First, a reminder – a computed variable is a property that has a getter and an optional setter. </st><st c="11811">This means that a </st><a id="_idIndexMarker127"/><st c="11829">computed variable doesn’t have its storage, and its value is derived from other variables (which can also be </st><a id="_idIndexMarker128"/><st c="11938">computed variables).</st></p>
			<p><st c="11958">Look at the </st><st c="11971">following code:</st></p>
			<pre class="source-code"><st c="11986">
class Book: ObservableObject {
    @Published var pages: Int = 0
    @Published var averageWordsPerPage: Int = 0
    </st><strong class="bold"><st c="12092">@Published var totalWordsInBook: Int {</st></strong>
<strong class="bold"><st c="12130">        return pages * averageWordsPerPage</st></strong>
<strong class="bold"><st c="12165">    }</st></strong><st c="12167">
}</st></pre>			<p><st c="12169">The </st><code><st c="12173">Book</st></code><st c="12177"> class conforms to the good old </st><code><st c="12209">ObservableObject</st></code><st c="12225"> protocol.</st></p>
			<p><st c="12235">Notice that the </st><code><st c="12252">totalWordsInBook</st></code><st c="12268"> property is a computed variable – it multiplies the </st><code><st c="12321">pages</st></code><st c="12326"> and </st><code><st c="12331">averageWordsPerPage</st></code><st c="12350"> variables to return the total number of words in </st><st c="12400">the book.</st></p>
			<p><st c="12409">We want to observe the computed variable to present its results in one of our SwiftUI views, so we have marked it with the </st><code><st c="12533">@Published</st></code> <st c="12543">property wrapper.</st></p>
			<p><st c="12561">Unfortunately, this is impossible. </st><st c="12597">Try to compile results with the </st><st c="12629">following error:</st></p>
			<p><em class="italic"><st c="12645">Property wrapper cannot be applied to a </st></em><em class="italic"><st c="12686">computed property</st></em></p>
			<p><st c="12703">That’s a big downside for conforming to the </st><code><st c="12748">ObservableObject</st></code><st c="12764"> protocol, as it can be a helpful </st><st c="12798">use case.</st></p>
			<p><st c="12807">Working with the Observable macro works t</st><a id="_idTextAnchor124"/><a id="_idTextAnchor125"/><st c="12849">his out </st><st c="12858">quite nicely:</st></p>
			<pre class="source-code"><st c="12871">
@Observable
class MyBook {
    var p</st><a id="_idTextAnchor126"/><a id="_idTextAnchor127"/><st c="12904">ages: Int = 0
    var averageWordsPerPage: Int = 0
    var totalWordsInBook: Int {
        return pages * averageWordsPerPage
    }
}</st></pre>			<p><st c="13018">In the preceding code, we just </st><a id="_idIndexMarker129"/><st c="13050">added the computed variable, and we can observe it in our view with </st><st c="13118">no problems.</st></p>
			<p><st c="13130">How does it work? </st><st c="13149">How can we observe a computed variable if it doesn’t have a back store for </st><st c="13224">its value?</st></p>
			<p><st c="13234">So, there’s a reason why I always make sure to explain how things work underneath. </st><st c="13318">If we go back to the </st><em class="italic"><st c="13339">Learning how the @Observable macro works</st></em><st c="13379"> section, we expanded the </st><code><st c="13405">@Observable</st></code><st c="13416"> macro and saw interesting details of how the observation and tracking work. </st><st c="13493">Every </st><a id="_idIndexMarker130"/><st c="13499">observed property becomes a computed value and is tracked using a getter and </st><st c="13576">a setter.</st></p>
			<p><st c="13585">So, when we add a computed variable whose value is derived from another observed property, it means that whenever we access this computed variable, we also access the other properties. </st><st c="13771">This access triggers the </st><st c="13796">observation framework.</st></p>
			<p><em class="italic"><st c="13818">Figure 3</st></em><em class="italic"><st c="13827">.1</st></em><st c="13829"> shows how observing computed variables works in a </st><st c="13880">visual way:</st></p>
			<div><div><img src="img/B21795_03_1.jpg" alt="Figure 3.1: How SwiftUI observes computed variables"/><st c="13891"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13988">Figure 3.1: How SwiftUI observes computed variables</st></p>
			<p><em class="italic"><st c="14039">Figure 3</st></em><em class="italic"><st c="14048">.1</st></em><st c="14050"> nicely shows </st><a id="_idIndexMarker131"/><st c="14064">how the computed variables are derived from other properties and how accessing them would eventually go </st><a id="_idIndexMarker132"/><st c="14168">down to the </st><code><st c="14180">observationRegister </st></code><st c="14200">object.</st></p>
			<p><st c="14207">Let’s try to see that </st><st c="14230">in action:</st></p>
			<pre class="source-code"><st c="14240">
@Observable
class Book {
    var title:String = ""
    var pages: Int = 0
    var averageWordsPerPage: Int = 0
</st><strong class="bold"><st c="14340">    var totalWordsInBook: Int {</st></strong>
<strong class="bold"><st c="14367">        return pages * averageWordsPerPage</st></strong>
<strong class="bold"><st c="14402">    }</st></strong><st c="14404">
}
struct ContentView: View {
    var book:Book = Book()
    var body: some View {
        VStack {
            Text(book.title)
            Button("Change") {
                </st><strong class="bold"><st c="14524">book.averageWordsPerPage = 300</st></strong>
<strong class="bold"><st c="14554">                book.pages = 200</st></strong>
<strong class="bold"><st c="14571">            }</st></strong>
<strong class="bold"><st c="14573">            Text("number of pages in the book:</st></strong>
<strong class="bold"><st c="14608">              \(book.totalWordsInBook)")</st></strong><st c="14635">
        .padding()
    }
}</st></pre>			<p><st c="14649">In the preceding code, we update the </st><code><st c="14687">averageWordsPerPage</st></code><st c="14706"> and </st><code><st c="14711">pages</st></code><st c="14716"> properties when</st><a id="_idIndexMarker133"/><st c="14732"> tapping the </st><strong class="bold"><st c="14745">Change</st></strong><st c="14751"> button.</st></p>
			<p><st c="14759">The update triggers the observation</st><a id="_idIndexMarker134"/><st c="14795"> framework and updates the view because we access </st><code><st c="14845">totalWordsInBook</st></code><st c="14861"> in the following line, even though it’s a </st><st c="14904">computed variable.</st></p>
			<p><st c="14922">However, adding the </st><code><st c="14943">@ObservationIgnored</st></code><st c="14962"> property to both of these properties (</st><code><st c="15001">averageWordsPerPage</st></code><st c="15021"> and </st><code><st c="15026">pages</st></code><st c="15031">) won’t trigger the </st><code><st c="15052">totalWordsInBook</st></code><st c="15068"> computed property because the </st><code><st c="15099">@Observation</st></code><st c="15111"> framework can’t tell that something has changed. </st><st c="15161">The nice thing is that we’ve learned how it works by expanding our </st><code><st c="15228">@</st></code><code><st c="15229">Observable</st></code><st c="15239"> macro.</st></p>
			<p><st c="15246">By now, </st><a id="_idTextAnchor128"/><a id="_idTextAnchor129"/><st c="15255">we know very well how the </st><code><st c="15281">@Observable</st></code><st c="15292"> macro works and how variables and computed variables </st><st c="15346">are observed.</st></p>
			<p><st c="15359">Now, let’s move one step</st><a id="_idIndexMarker135"/><st c="15384"> further and see how to use</st><a id="_idIndexMarker136"/><st c="15411"> these observed variables as </st><st c="15440">environment variables.</st></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor130"/><st c="15462">Working with environment variables</st></h1>
			<p><st c="15497">A view that works directly with an observed object is a common use case. </st><st c="15571">For example, a view can work with a </st><code><st c="15607">ViewModel</st></code><st c="15616"> class or have a SwiftData query that fetches data models from the </st><st c="15683">persistent store.</st></p>
			<p><st c="15700">However, there are</st><a id="_idIndexMarker137"/><st c="15719"> cases where we have an observed object shared across </st><st c="15773">different views.</st></p>
			<p><st c="15789">Some examples of such a use case are </st><st c="15827">as follows:</st></p>
			<ul>
				<li><strong class="bold"><st c="15838">App settings</st></strong><st c="15851">: The user profile is part of app settings and can be stored in an </st><st c="15919">environment variable</st></li>
				<li><strong class="bold"><st c="15939">Themes and styling</st></strong><st c="15958">: Primary color tint font style, spaces, </st><st c="16000">and more</st></li>
				<li><strong class="bold"><st c="16008">User authentication state</st></strong><st c="16034">: The login state is a good examp</st><a id="_idTextAnchor131"/><a id="_idTextAnchor132"/><st c="16068">le of an </st><st c="16078">environment variable</st></li>
			</ul>
			<p><st c="16098">Sharing the same object down a view hierarchy can be cumbersome, but SwiftUI offers a helpful feature known as </st><strong class="bold"><st c="16210">environment variables</st></strong><st c="16231">. While environment variables aren’t a recent addition to iOS (they have been available before iOS 17), the Observation framework provides </st><st c="16370">comprehensive support.</st></p>
			<p><st c="16392">There are two ways of adding </st><a id="_idIndexMarker138"/><st c="16422">an environment variable to our project – by type or by keys. </st><st c="16483">Let’s start with the more straightforward way: </st><st c="16530">by type.</st></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor133"/><st c="16538">Adding an environment variable by type</st></h2>
			<p><st c="16577">Let’s try to add theming support for</st><a id="_idIndexMarker139"/><st c="16614"> our books project. </st><st c="16634">We’ll start by creating our </st><code><st c="16662">Themes</st></code><st c="16668"> class:</st></p>
			<pre class="source-code">
<strong class="bold"><st c="16675">@Observable</st></strong><st c="16687">
class Themes {
    var primaryColor: Color = .red
}</st></pre>			<p><st c="16735">Our </st><code><st c="16740">Themes</st></code><st c="16746"> class has only one property for now: the primary color. </st><st c="16803">Notice that we added the </st><code><st c="16828">@Observable</st></code><st c="16839"> macro to update our UI when the </st><st c="16872">theme changes.</st></p>
			<p><st c="16886">Next, we will add our observed object to our </st><code><st c="16932">BookApp</st></code><st c="16939"> struct:</st></p>
			<pre class="source-code"><st c="16947">
@main
struct BookApp: App {
</st><strong class="bold"><st c="16976">    var themes: Themes = Themes()</st></strong><st c="17005">
    var body: some Scene {
        WindowGroup {
            ContentView()
                </st><strong class="bold"><st c="17057">.environment(themes)</st></strong><st c="17077">
        }
    }
}</st></pre>			<p><st c="17083">In the </st><code><st c="17091">BookApp</st></code><st c="17098"> struct, we’re making </st><st c="17120">two changes:</st></p>
			<ul>
				<li><code><st c="17264">@State</st></code> <st c="17270">or </st><code><st c="17274">@ObservedObject</st></code><st c="17289">.</st></li>
				<li><code><st c="17392">themes</st></code> <st c="17398">object easily.</st></li>
			</ul>
			<p><st c="17413">Now, let’s turn to our view </st><a id="_idIndexMarker140"/><st c="17442">and see how we can </st><st c="17461">use it:</st></p>
			<pre class="source-code">
<a id="_idTextAnchor134"/><a id="_idTextAnchor135"/><st c="17468">struct ContentView: View {
  </st><strong class="bold"><st c="17496">@Environment(Themes.self) var themes</st></strong><st c="17532">
  var book: Book = {
      let book = Book()
      book.title = "Mastering iOS 17"
      return book
  }()
  var body: some View {
    VStack {
      Text(book.title)</st><strong class="bold"><st c="17665">.foregroundStyle(themes.primaryColor)</st></strong><st c="17702">
    }
  }
}</st></pre>			<p><st c="17708">Adding the themes instance to our </st><code><st c="17743">ContentView</st></code><st c="17754"> struct is straightforward. </st><st c="17782">We’re using the </st><code><st c="17798">@Environment</st></code><st c="17810"> property wrapper to inject the themes object we </st><st c="17859">created earlier.</st></p>
			<p><st c="17875">We use the theme’s primary color in the body part to color our </st><st c="17939">book title.</st></p>
			<p><st c="17950">Now, we must note that we can use the environment variable in </st><em class="italic"><st c="18013">every</st></em><st c="18018"> view in the hierarchy, even if we haven’t </st><a id="_idIndexMarker141"/><st c="18061">initialized it with the </st><st c="18085">environment modifier.</st></p>
			<p><st c="18106">Here’s an example </st><st c="18125">of that:</st></p>
			<pre class="source-code"><st c="18133">
struct ContentView: View {
    var body: some View {
        VStack {
            MyTitle(text: "Mastering iOS 17")
        }
    }
}
struct MyTitle: View {
</st><strong class="bold"><st c="18255">    @Environment(Themes.self) var themes</st></strong><st c="18291">
    let text: String
    var body: some View {
        Text(text).foregroundStyle(</st><strong class="bold"><st c="18358">themes.primaryColor</st></strong><st c="18378">)
    }
}</st></pre>			<p><st c="18384">In the preceding code, we created another SwiftUI component called </st><code><st c="18452">MyTitle</st></code><st c="18459">, which has the environment </st><st c="18487">variable themes.</st></p>
			<p><st c="18503">The </st><code><st c="18508">MyTitle</st></code><st c="18515"> view is part of the </st><code><st c="18536">ContentView</st></code><st c="18547"> hierarchy. </st><st c="18559">Therefore, it has direct access to the </st><code><st c="18598">themes</st></code><st c="18604"> variable.</st></p>
			<p><st c="18614">Passing environment variables by type is simple! </st><st c="18664">However, when working on a big scale, it has some drawbacks. </st><st c="18725">I believe that the main disadvantage is that we are coupling our code to a specific type. </st><st c="18815">In the </st><code><st c="18822">themes</st></code><st c="18828"> example, we work with an explicit </st><st c="18863">variety (</st><code><st c="18872">Themes</st></code><st c="18879">).</st></p>
			<p><st c="18882">SwiftUI provides us with a</st><a id="_idIndexMarker142"/><st c="18909"> better way to manage environment variables, and that’s working with </st><st c="18978">environment keys.</st></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor136"/><st c="18995">Adding environment variable by key</st></h2>
			<p><st c="19030">Managing environment </st><a id="_idIndexMarker143"/><st c="19052">variables is much better when our project becomes </st><st c="19102">more significant.</st></p>
			<p><st c="19119">Using environment keys improves the separation between our view and the </st><st c="19192">actual variable.</st></p>
			<p><st c="19208">To better manage environment values, SwiftUI has two </st><st c="19262">primary components:</st></p>
			<ul>
				<li><code><st c="19281">EnvironmentValues</st></code><strong class="bold"><st c="19299"> struct</st></strong><st c="19306">: This is a container of different environment values structured in a key-value form. </st><st c="19393">It can be accessed from any view in the app. </st><st c="19438">We can extend the struct and add </st><st c="19471">new variables.</st></li>
				<li><code><st c="19485">EnvironmentKey</st></code><strong class="bold"><st c="19500"> protocol</st></strong><st c="19509">: It allows us to add a key for a new variable and use that key to add a new </st><st c="19587">environment value.</st></li>
			</ul>
			<p><st c="19605">Let’s see how it works </st><st c="19629">in practice:</st></p>
			<pre class="source-code"><st c="19641">
 struct ThemesKey: </st><strong class="bold"><st c="19660">EnvironmentKey</st></strong><st c="19674"> {
    static let defaultValue = Themes()
}
extension </st><strong class="bold"><st c="19724">EnvironmentValues</st></strong><st c="19741"> {
    var themes: Themes {
        get { self[ThemesKey.self]}
        set { self[ThemesKey.self] = newValue}
    }
}</st></pre>			<p><st c="19835">The first thing that we did was add a new </st><code><st c="19878">EnvironmentKey</st></code><st c="19892"> type named </st><code><st c="19904">ThemesKey</st></code><st c="19913">. Part of the </st><code><st c="19927">EnvironmentKey</st></code><st c="19941"> protocol is setting the variable default value, which is, in this case, a </st><code><st c="20016">Themes</st></code><st c="20022"> instance.</st></p>
			<p><st c="20032">Once we have a new environment key, we must add it to our </st><code><st c="20091">EnvironmentValues</st></code><st c="20108"> container. </st><st c="20120">We do that by extending the container and adding a new computed variable </st><st c="20193">named </st><code><st c="20199">themes</st></code><st c="20205">.</st></p>
			<p><st c="20206">The getter and the setter are straightforward – the </st><code><st c="20259">get</st></code><st c="20262"> function returns the value according to the relevant key (</st><code><st c="20321">ThemesKey</st></code><st c="20331">), and the </st><code><st c="20343">set</st></code><st c="20346"> function stores a new variable on </st><st c="20381">that key.</st></p>
			<p><st c="20390">After we have extended</st><a id="_idIndexMarker144"/><st c="20413"> the container, we can easily access that key from any view that </st><st c="20478">we have:</st></p>
			<pre class="source-code"><st c="20486">
struct ContentView: View {
</st><strong class="bold"><st c="20514">    @Environment(\.themes) var themes</st></strong><st c="20547">
    // rest of the view
}</st></pre>			<p><st c="20569">Remember the environment modifier from earlier? </st><st c="20618">We can remove </st><st c="20632">it now:</st></p>
			<pre class="source-code"><st c="20639">
ContentView()
</st><code><st c="20696">EnvironmentValues</st></code><st c="20713"> struct, we extended the global variables container of our app. </st><st c="20777">That’s the reason why we have access from </st><st c="20819">any view.</st></p>
			<p><st c="20828">Other than accessing the values from any view, working with environment variable keys has several </st><st c="20927">additional advantages:</st></p>
			<ul>
				<li><strong class="bold"><st c="20949">Quickly replacing the variable type in the future</st></strong><st c="20999">: Unlike adding an environment value by type, we are not tied to a specific type when adding the variable by key. </st><st c="21114">We can easily replace the type itself in one place and not have to replace it in all views as long as we keep the </st><st c="21228">same interface.</st></li>
				<li><strong class="bold"><st c="21243">Great for testing</st></strong><st c="21261">: Another advantage of not being coupled to a specific type is the ability to create mocks and add </st><st c="21361">unit tests.</st></li>
				<li><code><st c="21505">get</st></code><st c="21508"> and </st><code><st c="21513">set</st></code><st c="21516"> functions in the </st><code><st c="21534">EnvironmentValues</st></code><st c="21551"> struct? </st><st c="21560">Now, we can customize them the way we </st><st c="21598">want to.</st></li>
			</ul>
			<p><st c="21606">We can understand why environment keys are essential for big projects by looking at the list </st><st c="21700">of advantages.</st></p>
			<p><st c="21714">No matter how we work with environment variables, they are crucial for a clean and simple SwiftUI code, especially when we combine them with </st><code><st c="21856">@</st></code><code><st c="21857">Observable</st></code><st c="21867"> objects.</st></p>
			<p><st c="21876">By now, we already know how to create an observed object and inject it into child views using </st><st c="21971">environment variables.</st></p>
			<p><st c="21993">Our next topic revolves</st><a id="_idIndexMarker145"/><st c="22017"> around the compatibility problem that the </st><em class="italic"><st c="22060">Observation</st></em><st c="22071"> framework created for us, specifically </st><st c="22111">reg</st><a id="_idTextAnchor137"/><a id="_idTextAnchor138"/><st c="22114">arding binding.</st></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor139"/><st c="22130">Binding objects using @Bindable</st></h1>
			<p><st c="22162">Let’s start with a short recap of what </st><st c="22202">binding is.</st></p>
			<p><st c="22213">In some cases, a view and its </st><a id="_idIndexMarker146"/><st c="22244">child must share a state and create a two-way connection for reading and modifying a value. </st><st c="22336">To do that, we use</st><a id="_idIndexMarker147"/><st c="22354"> something </st><st c="22365">called </st><strong class="bold"><st c="22372">binding</st></strong><st c="22379">.</st></p>
			<p><st c="22380">One classic</st><a id="_idIndexMarker148"/><st c="22392"> example is </st><code><st c="22404">TextField</st></code><st c="22413"> – a </st><code><st c="22418">TextField</st></code><st c="22427"> view is a SwiftUI component with a </st><code><st c="22463">text</st></code><st c="22467"> variable. </st><st c="22478">Both </st><code><st c="22483">TextField</st></code><st c="22492"> and its parent view share the same value of text. </st><st c="22543">Therefore, it’s a </st><st c="22561">binding </st><a id="_idTextAnchor140"/><a id="_idTextAnchor141"/><st c="22569">variable:</st></p>
			<pre class="source-code"><st c="22578">
struct ContentView: View {
</st><strong class="bold"><st c="22606">    @State var email: String = ""</st></strong><st c="22635">
    var body: some View {
        VStack {
            TextField("Email", text: </st><strong class="bold"><st c="22692">$email</st></strong><st c="22698">)
        }
    }
}</st></pre>			<p><st c="22706">We see that the </st><code><st c="22723">email</st></code><st c="22728"> variable is marked as a state, but the </st><code><st c="22768">TextField</st></code><st c="22777"> view is the one that updates it. </st><st c="22811">The binding occurs using the </st><code><st c="22840">$</st></code> <st c="22841">character.</st></p>
			<p><st c="22851">We can create a binding variable ourselves using the </st><code><st c="22905">@Binding</st></code> <st c="22913">proper</st><a id="_idTextAnchor142"/><a id="_idTextAnchor143"/><st c="22920">ty wrapper:</st></p>
			<pre class="source-code"><st c="22932">
struct MyCounter: View {
</st><strong class="bold"><st c="22958">    @Binding var value: Int</st></strong><st c="22981">
    var body: some View {
        VStack {
            Button("Increase") {
                value += 1
            }
        }
    }
}
struct ContentView: View {
</st><strong class="bold"><st c="23080">    @State var count: Int = 0</st></strong><st c="23105">
    var body: some View {
        VStack {
            MyCounter(value: </st><strong class="bold"><st c="23154">$count</st></strong><st c="23160">)
            Text("Value = \(count)")
        }
    }
}</st></pre>			<p><st c="23193">The </st><code><st c="23198">count</st></code><st c="23203"> variable in the parent </st><a id="_idIndexMarker149"/><st c="23227">view (</st><code><st c="23233">ContentView</st></code><st c="23245">) and the </st><code><st c="23256">value</st></code><st c="23261"> variable in the child view (</st><code><st c="23290">ContentView</st></code><st c="23302">) share </st><a id="_idIndexMarker150"/><st c="23311">the same state, and now we have a two-way connection </st><st c="23364">between them.</st></p>
			<p><st c="23377">We can connect a binding variable to a </st><code><st c="23417">@State</st></code><st c="23423"> property wrapper (such as in the example we just saw) or a </st><code><st c="23483">@</st></code><code><st c="23484">ObservedObject</st></code><st c="23498"> variable.</st></p>
			<p><st c="23508">Can you guess what the problem is </st><a id="_idIndexMarker151"/><st c="23543">with trying to create a binding connection using the </st><code><st c="23596">Observation</st></code><st c="23607"> framework?</st></p>
			<p><st c="23618">So, apparently, classes</st><a id="_idIndexMarker152"/><st c="23642"> that are marked with the </st><code><st c="23668">@Observed</st></code><st c="23677"> macro are not eligible for </st><code><st c="23705">@State</st></code><st c="23711"> or </st><code><st c="23715">@ObservedObject</st></code><st c="23730">, so we can’t use </st><code><st c="23748">@Binding</st></code> <st c="23756">with them.</st></p>
			<p><st c="23767">Fortunately, with the </st><em class="italic"><st c="23790">Observation</st></em><st c="23801"> framework, we have a new property wrapper </st><st c="23844">called </st><strong class="bold"><st c="23851">@Bindable</st></strong><st c="23860">.</st></p>
			<p><st c="23861">Let’s see a short </st><a id="_idIndexMarker153"/><st c="23880">example of how to use </st><code><st c="23902">@Bindable</st></code><st c="23911"> with a </st><a id="_idIndexMarker154"/><st c="23919">counter object:</st></p>
			<pre class="source-code"><st c="23934">
struct ContentView: View {
    </st><strong class="bold"><st c="23962">var counter = Counter()</st></strong><st c="23985">
    var body: some View {
        VStack {
            CounterView(counter: </st><strong class="bold"><st c="24038">counter</st></strong><st c="24045">)
            Text("Value = \(counter.value)")
        }
    }
}
struct CounterView: View {
</st><strong class="bold"><st c="24114">    @Bindable var counter: Counter</st></strong><st c="24144">
    var body: some View {
        VStack {
            Button("Increase") {
</st><strong class="bold"><st c="24197">                counter.increment()</st></strong><st c="24216">
            }
        }
    }
}</st></pre>			<p><st c="24224">The code example has two views as before – a </st><code><st c="24270">ContentView</st></code><st c="24281"> view and a child view named </st><code><st c="24310">CounterView</st></code><st c="24321">. The </st><code><st c="24327">ContentView</st></code><st c="24338"> view has a variable called </st><code><st c="24366">counter</st></code><st c="24373"> of the </st><code><st c="24381">Counter</st></code><st c="24388"> type. </st><st c="24395">The </st><code><st c="24399">Counter</st></code><st c="24406"> class is marked</st><a id="_idIndexMarker155"/><st c="24422"> with </st><code><st c="24428">@Observed</st></code><st c="24437">, so we don’t need to mark the property as </st><code><st c="24480">@State</st></code> <st c="24486">or </st><code><st c="24490">@ObservedObject</st></code><st c="24505">.</st></p>
			<p><st c="24506">In the </st><code><st c="24514">CounterView</st></code><st c="24525"> structure, we </st><a id="_idIndexMarker156"/><st c="24540">also have a counter from the same type, but it is marked with </st><code><st c="24602">@Bindable</st></code><st c="24611">. This means we need to bind it to an object with a </st><st c="24663">similar type.</st></p>
			<p><st c="24676">The </st><code><st c="24681">CounterView.counter</st></code><st c="24700"> and </st><code><st c="24705">ContentView.counter</st></code><st c="24724"> variables are linked – whenever we change the value in the child view, it automatically reflects in the parent view. </st><st c="24842">Notice that with </st><code><st c="24859">@Bindable,</st></code><st c="24869"> we don’t need to add any </st><code><st c="24895">$</st></code><st c="24896"> signs to the variable expression. </st><st c="24931">Everything </st><st c="24942">just works.</st></p>
			<p><st c="24953">Binding is a critical usage of SwiftUI – it stands at the heart of many input views such as text fields, toggles, sheets, </st><st c="25076">and more.</st></p>
			<p><st c="25085">Working with the </st><code><st c="25103">@Bindable</st></code><st c="25112"> macro can be confusing – we now have both </st><code><st c="25155">@Binding</st></code><st c="25163"> and </st><code><st c="25168">@Bindable</st></code><st c="25177"> at the same time! </st><code><st c="25196">@Binding</st></code><st c="25204"> is used for states and observable objects and </st><code><st c="25251">@Bindable</st></code><st c="25260"> is used for... </st><st c="25276">observed objects?</st></p>
			<p><st c="25293">So yes, it feels like we are in a transition era. </st><st c="25344">The good news is that we can solve the issue easily by migrating our project </st><st c="25421">to </st><em class="italic"><st c="25424">Observable</st></em><st c="25434">.</st></p>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor144"/><st c="25435">Migrating to Observable</st></h1>
			<p><st c="25459">Before migrating to </st><em class="italic"><st c="25480">Observable</st></em><st c="25490">, we must ensure that our app deployment target is at least 17. </st><st c="25554">Remember that this </st><a id="_idIndexMarker157"/><st c="25573">feature (and most of the new features described in this book) are from iOS 17, and some are irrelevant if our app deployment target is </st><st c="25708">not 17.</st></p>
			<p><st c="25715">Let’s try to recap the different </st><st c="25749">Observable attributes:</st></p>
			<ul>
				<li><code><st c="25771">@State</st></code><st c="25778">: This is used to manage the state within a specific view. </st><st c="25838">A change to a </st><code><st c="25852">@State</st></code><st c="25858"> property triggers a view update. </st><st c="25892">For example, data related to a list or view visibility can be marked </st><st c="25961">as </st><code><st c="25964">@State</st></code><st c="25970">.</st></li>
				<li><code><st c="25971">@Observable</st></code><st c="25983">: This can </st><a id="_idIndexMarker158"/><st c="25995">be applied to a class to make the class observable. </st><st c="26047">Each class property is automatically marked with </st><code><st c="26096">@Published</st></code><st c="26106"> unless we mark them as </st><code><st c="26130">@ObservataionIgnored</st></code><st c="26150">. </st><code><st c="26152">@Observable</st></code><st c="26163"> can be added to view models or business </st><st c="26204">logic classes.</st></li>
				<li><code><st c="26218">@Bindable</st></code><st c="26228">: This creates a two-way connection between a property and another value. </st><st c="26303">Text field input, toggles, or a counter are examples of views for implementing a </st><code><st c="26384">@</st></code><code><st c="26385">Bindable</st></code><st c="26393"> connection.</st></li>
				<li><code><st c="26405">@Environment</st></code><st c="26418">: Mark an object to be shared down the view hierarchy with this attribute. </st><st c="26494">For example, configuration or a theme can be shared with all views in the hierarchy using the </st><code><st c="26588">@</st></code><code><st c="26589">Environemnt</st></code><st c="26600"> attribute.</st></li>
			</ul>
			<p><st c="26611">This list aims to summarize the different attributes in the Observable framework and their </st><st c="26703">use cases.</st></p>
			<p><st c="26713">Once we decide to move to the </st><em class="italic"><st c="26744">Observable</st></em><st c="26754"> framework, there are a few things we need </st><st c="26797">to do:</st></p>
			<ul>
				<li><st c="26803">Remove the pro</st><a id="_idTextAnchor145"/><a id="_idTextAnchor146"/><st c="26818">tocol conformation to </st><code><st c="26841">ObservableObject</st></code><st c="26857"> and add the </st><code><st c="26870">@Observable</st></code><st c="26881"> macro for all the </st><st c="26900">relevant classes</st></li>
				<li><st c="26916">Remove the </st><code><st c="26928">@Published</st></code><st c="26938"> property wrapper and add </st><code><st c="26964">@ObservationIgnored</st></code><st c="26983"> for the properties we don’t want </st><st c="27017">to observe</st></li>
				<li><st c="27027">Remove the </st><code><st c="27039">@ObservedObject</st></code> <st c="27054">property wrapper</st></li>
				<li><st c="27071">Rename </st><code><st c="27079">@Binding</st></code><st c="27087"> to </st><code><st c="27091">@Bindable</st></code><st c="27100"> for the properties that are based </st><st c="27135">on classes</st></li>
			</ul>
			<p><st c="27145">Once we finish migrating to the </st><code><st c="27178">Observable</st></code><st c="27188"> framework, things will be clearer and more straightforward, with fewer property wrappers and less protocol conformation. </st><st c="27310">The binding can also be simple – now it’s </st><code><st c="27352">@Binding</st></code><st c="27360"> for primitive values and </st><code><st c="27386">@Bindable</st></code><st c="27395"> for classes. </st><st c="27409">That’s not perfect, but not too bad either. </st><st c="27453">It’s time to </st><st c="27466">enjoy </st><em class="italic"><st c="27472">Observable</st></em><st c="27482">!</st></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor147"/><st c="27483">Summary</st></h1>
			<p><st c="27490">This was another chapter that made use of Swift macros and other advanced Swift techniques. </st><st c="27583">A small note: to understand topics such as </st><em class="italic"><st c="27626">Observable</st></em><st c="27636">, I recommend having good knowledge of Swift. </st><st c="27682">Otherwise, it becomes just another boring tutorial. </st><st c="27734">Knowing how things work on the inside is fascinating and can only make </st><st c="27805">us better.</st></p>
			<p><st c="27815">In this chapter, we did a recap of the SwiftUI observation system, and we discussed its problem. </st><st c="27913">We added the </st><code><st c="27926">@Observable</st></code><st c="27937"> macro and explored how it works. </st><st c="27971">We talked about computed variables, environment variables, and bindable. </st><st c="28044">Ultimately, we discussed migrating from the “old” observation system to the new </st><em class="italic"><st c="28124">Observable</st></em><st c="28134"> framework.</st></p>
			<p><st c="28145">Remember – observation is a core feature of SwiftUI and is crucial to delivering a superior experience to </st><st c="28252">our users.</st></p>
			<p><st c="28262">In the next chapter, we will learn about another critical feature, especially in mobile – navigation </st><st c="28364">and search.</st></p>
		</div>
	<div></body></html>