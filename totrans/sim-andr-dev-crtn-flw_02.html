<html><head></head><body>
		<div><h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Introduction to Asynchronous Programming in Android</h1>
			<p>There are Android applications that work on their own. But most apps retrieve data from or send data to a local database or a backend server. Examples of these include fetching posts from a social network, saving your favorites from a list, uploading an image, or updating your profile information. These tasks and other resource-intensive computations may happen instantly or take a while to finish. Factors such as internet connection, device specifications, and server settings affect how long these operations take.</p>
			<p>Long-running operations must not be performed on the main UI thread as the application will be blocked until they are completed. The application might become unresponsive to the users. Users may not be aware of what’s happening, and this might prompt them to close the app and reopen it (canceling the original task or doing it again). The app can also suddenly crash. Some users might even stop using your app if this happens frequently.</p>
			<p>To prevent this from happening, you need to use asynchronous programming. Tasks that can take an indefinite amount of time must be done asynchronously. They must run in the background, parallel to other tasks. For example, while posting information to your backend server, the app displays the UI, which the users can interact with. When the operation finishes, you can then update the UI or notify the users (with a dialog or a snackbar message).</p>
			<p>With this book, you will learn how to simplify asynchronous programming in Android using Kotlin coroutines and flows.</p>
			<p>In this chapter, you will first start by revisiting the concept of asynchronous programming. After that, you will look into the various ways it is being done now in Android and how they may no longer be the best way moving forward. Then, you will be introduced to the new, recommended way of performing asynchronous programming in Android: coroutines and flows.</p>
			<p>This chapter covers three main topics:</p>
			<ul>
				<li>Asynchronous programming</li>
				<li>Threads, AsyncTasks, and <code>Executors</code></li>
				<li>The new way to do it – coroutines and flows</li>
			</ul>
			<p>By the end of this chapter, you will have a basic understanding of asynchronous programming, and know how to do it in Android using threads, AsyncTasks, and <code>Executors</code>. Finally, you will discover Kotlin coroutines and flows as these are the recommended ways of doing asynchronous programming in Android. </p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: Intel Core i5 or equivalent or higher, 4 GB RAM minimum, and 4 GB available space.</p>
			<p>The code examples for this book can be found on GitHub at https: <a href="http://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows">github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows</a>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Understanding asynchronous programming</h1>
			<p>In this <a id="_idIndexMarker000"/>section, we will start by looking at asynchronous programming. Asynchronous programming is a programming method that allows work to be done independently of the main application thread.</p>
			<p>A normal program will run sequentially. It will perform one task and move to the next task after the previous one has finished. For simple operations, this is fine. However, there are some tasks that might take a long time to finish, such as the following:</p>
			<ul>
				<li>Fetching data from or saving data to a database</li>
				<li>Getting, adding, or updating data to a network</li>
				<li>Processing text, images, videos, or other files</li>
				<li>Complicated computations</li>
			</ul>
			<p>The app will look frozen and unresponsive to the users while it is performing these tasks. They won’t be able to do anything else in the app until the tasks are finished.</p>
			<p>Asynchronous programming <a id="_idIndexMarker001"/>solves this problem. You can run a task that may be processed indefinitely on a background thread (in parallel to the main thread) without freezing the app. This will allow the users to still interact with the app or the UI while the original task is running. When the task has finished or if an error was encountered, you can then inform the user using the main thread.</p>
			<p>A <a id="_idIndexMarker002"/>visual representation of asynchronous programming is shown in the following figure:</p>
			<div><div><img src="img/Figure_1.01_B17773.jpg" alt="Figure 1.1 – Asynchronous programming&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Asynchronous programming</p>
			<p><strong class="bold">Task 1</strong> and <strong class="bold">Task 2</strong> are running on the main thread. <strong class="bold">Task 2</strong> starts <strong class="bold">Task 3</strong> on the background thread. While <strong class="bold">Task 3</strong> is running, the main thread can continue to perform other tasks, such as <strong class="bold">Task 4</strong>. After <strong class="bold">Task 3</strong> is done, it will return to the main thread. </p>
			<p>Asynchronous programming<a id="_idIndexMarker003"/> is an important skill for developers to have, especially for mobile app development. Mobile devices have limited capabilities and not all locations have a stable network connection.</p>
			<p>In Android, if you run a task on the main thread and it takes too long, the app can become unresponsive or look frozen. The app can also crash unexpectedly. You will likely <a id="_idIndexMarker004"/>get an <strong class="bold">Application Not Responding</strong> (<strong class="bold">ANR</strong>) error, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_1.02_B17773.jpg" alt="Figure 1.2 – An ANR dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – An ANR dialog</p>
			<p>Starting <a id="_idIndexMarker005"/>with Android 3.0 (Honeycomb), running a <a id="_idIndexMarker006"/>network operation on the main thread will cause <code>android.os.NetworkOnMainThreadException</code>, which will crash your app. </p>
			<p>ANR dialogs and crashes can annoy your users. If they happen all the time, they might stop using your app altogether and choose another app. To prevent them in your app, you must run tasks<a id="_idIndexMarker007"/> that can take a long period of time on the background thread.</p>
			<p>In this section, you revisited the concept of asynchronous programming and how you can use it to run long-running tasks without freezing the app. You will explore various approaches for using asynchronous programming in Android in the next section.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Exploring threads, AsyncTasks, and Executors</h1>
			<p>There are many ways you can run tasks on the background thread in Android. In this section, you are going to explore various ways of doing asynchronous programming in Android, including using threads, AsyncTask, and <code>Executors</code>. You will learn how to start a task on the background thread and then update the main thread with the result.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Threads</h2>
			<p>A thread is a <a id="_idIndexMarker008"/>unit of execution that runs code concurrently. In Android, the UI thread is the main thread. You can perform a task on another thread by using the <code>java.lang.Thread</code> class: </p>
			<pre class="source-code">private fun fetchTextWithThread() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">        // get text from network</pre>
			<pre class="source-code">        val text = getTextFromNetwork()</pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p>To run the<a id="_idIndexMarker009"/> thread, call <code>Thread.start()</code>. Everything that is inside the braces will be performed on another thread. You can do any operation here, except updating the UI, as you will encounter <code>NetworkOnMainThreadException</code>.</p>
			<p>To update the UI, such as displaying the text fetched in a <code>TextView</code> from the network, you would need to use <code>Activity.runOnUiThread()</code>. The code inside <code>runOnUIThread</code> will be executed in the main thread, as follows:</p>
			<pre class="source-code">private fun fetchTextWithThread() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">          // get text from network</pre>
			<pre class="source-code">          val text = getTextFromNetwork()</pre>
			<pre class="source-code">    <strong class="bold">runOnUiThread {</strong></pre>
			<pre class="source-code"><strong class="bold">        // Display on UI</strong></pre>
			<pre class="source-code">        <strong class="bold">displayText(text)</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p><code>runOnUIThread</code> will <a id="_idIndexMarker010"/>perform the <code>displayText(text)</code> function on the main UI thread.</p>
			<p>If you are not starting the thread from an activity, you can use handlers instead of <code>runOnUiThread</code> to update the UI, as seen in <em class="italic">Figure 1.3</em>:  </p>
			<div><div><img src="img/Figure_1.03_B17773.jpg" alt=" Figure 1.3 – Threads and a handler&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 1.3 – Threads and a handler</p>
			<p>A handler (<code>android.os.Handler</code>) allows <a id="_idIndexMarker011"/>you to communicate between threads, such as from the background thread to the main thread, as shown in the preceding figure. You can pass a looper into the Handler constructor to specify the thread where the task will be run. A looper is an object that runs the messages in the thread’s queue. </p>
			<p>To attach<a id="_idIndexMarker012"/> the<a id="_idIndexMarker013"/> handler to the main thread, you should use <code>Looper.getMainLooper()</code>, like in the following example:</p>
			<pre class="source-code">private fun fetchTextWithThreadAndHandler() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">           val text = getTextFromNetwork()</pre>
			<pre class="source-code">    <strong class="bold">Handler(Looper.getMainLooper()).post {</strong></pre>
			<pre class="source-code"><strong class="bold">      // Display on UI</strong></pre>
			<pre class="source-code">      <strong class="bold">displayText(text)</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p><code>Handler(Looper.getMainLooper())</code> creates <a id="_idIndexMarker014"/>a handler tied to the main thread <a id="_idIndexMarker015"/>and posts the <code>displayText()</code> runnable function on the main thread. </p>
			<p>The <code>Handler.post (Runnable)</code> function enqueues the runnable function to be executed on the specified thread. Other variants of the post function include <code>postAtTime(Runnable)</code> and <code>postDelayed (Runnable, uptimeMillis)</code>.</p>
			<p>Alternatively, you can also send an <code>android.os.Message</code> object with your handler, as shown in <em class="italic">Figure 1.4</em>:</p>
			<div><div><img src="img/Figure_1.04_B17773.jpg" alt="Figure 1.4 – Threads, handlers, and messages&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Threads, handlers, and messages</p>
			<p>A thread’s handler allows you to send a message to the thread’s message queue. The handler’s looper will execute the messages in the queue.</p>
			<p>To <a id="_idIndexMarker016"/>include the <a id="_idIndexMarker017"/>actual messages you want to send in your Message object, you can use <code>setData(Bundle)</code> to pass a single bundle of data. You can also use the public fields of the message <code>class</code> (<code>arg1, arg2, and </code> <code>what</code> for integer values, and <code>obj</code> for an object value).</p>
			<p>You must then create a subclass of Handler and override the <code>handleMessage(Message)</code> function. There, you can then get the data from the message and process it in the handler’s thread.</p>
			<p>You can use the following functions to send a message: <code>sendMessage(Message)</code>, <code>sendMessageAtTime(Message, uptimeMillis)</code>, and <code>sendMessageDelayed(Message, delayMillis)</code>. The following code shows the use of the <code>sendMessage</code> function to send a message with a data bundle:</p>
			<pre class="source-code">private val key = "key"</pre>
			<pre class="source-code">private val messageHandler = object :</pre>
			<pre class="source-code">   Handler(Looper.getMainLooper()) {</pre>
			<pre class="source-code">    override fun handleMessage(message: Message) {</pre>
			<pre class="source-code">    val bundle = message.data</pre>
			<pre class="source-code">    val text = bundle.getString(key, "")</pre>
			<pre class="source-code">    //Display text</pre>
			<pre class="source-code">    displayText(text)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private fun fetchTextWithHandlerMessage() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">    val text = getTextFromNetwork()</pre>
			<pre class="source-code">    val message = handler.obtainMessage()</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">    val bundle = Bundle()</pre>
			<pre class="source-code">    bundle.putString(key, text)</pre>
			<pre class="source-code">    message.data = bundle</pre>
			<pre class="source-code">    messageHandler.sendMessage(message)</pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p>Here, <code>fetchTextWithHandlerMessage()</code> gets the text from the network in a background thread. It then creates a message with a bundle object containing a string with a key of <code>key</code> to send that text. The handler can then, through the <code>handleMessage()</code> function, get the message’s bundle and get the string from the bundle using the same key.</p>
			<p>You <a id="_idIndexMarker018"/>can also send empty messages with an integer value (the what) that <a id="_idIndexMarker019"/>you can use in your <code>handleMessage</code> function to identify what message was received. These send empty functions are <code>sendEmptyMessage(int)</code>, <code>sendEmptyMessageAtTime(int, long)</code>, and <code>sendEmptyMessageDelayed(int, long)</code>. </p>
			<p>This example uses <code>0</code> and <code>1</code> as values for what (“what” is a field of the <code>Message</code> class that is a user-defined message code so that the recipient can identify what this message is about): <code>1</code> for the case when the background task succeeded and <code>0</code> for the failure case:</p>
			<pre class="source-code">private val emptymesageHandler = object :</pre>
			<pre class="source-code">  Handler(Looper.getMainLooper()) {</pre>
			<pre class="source-code">  override fun handleMessage(message: Message) {</pre>
			<pre class="source-code">    if (message.what == 1) {</pre>
			<pre class="source-code">      //Update UI</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      //Show Error</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private fun fetchTextWithEmptyMessage() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">    if (failed) {  </pre>
			<pre class="source-code">      emptyMessageHandler.sendEmptyMessage(0)</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      emptyMessageHandler.sendEmptyMessage(1)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code snippet, the background thread fetches the text from the network. It then sends an empty message of <code>1</code> if the operation succeeded and <code>0</code> if not. The handler, through the <code>handleMessage()</code> function, gets the <code>what</code> integer value of the message, which corresponds to the <code>0</code> or <code>1</code> empty message. Depending on this value, it can either update the UI or show an error to the main thread. </p>
			<p>Using threads and handlers works for<a id="_idIndexMarker020"/> background processing, but they have the following <a id="_idIndexMarker021"/>disadvantages: </p>
			<ul>
				<li>Every time you need to run a task in the background, you should create a new thread and use <code>runOnUiThread</code> or a new handler to post back to the main thread. </li>
				<li>Creating threads can consume a lot of memory and resources. </li>
				<li>It can also slow down your app.</li>
				<li>Multiple threads make your code harder to debug and test.</li>
				<li>Code <a id="_idIndexMarker022"/>can become complicated to read and maintain.</li>
			</ul>
			<p>Using <a id="_idIndexMarker023"/>threads makes it difficult to handle exceptions, which can lead to crashes.</p>
			<p>As a thread is<a id="_idIndexMarker024"/> a low-level API for asynchronous programming, it is better to use the ones that are built on top of threads, such as executors and, until it was deprecated, <code>AsyncTask</code>. You can avoid it altogether by using Kotlin coroutines, which you will learn more about later in this chapter.</p>
			<p>In the next section, you will explore callbacks, another approach to asynchronou<a id="_idTextAnchor020"/>s Android programming.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Callbacks</h2>
			<p>Another<a id="_idIndexMarker025"/> common approach to asynchronous programming in Android is using callbacks. A callback is a function that will be run when the asynchronous code has finished executing. Some libraries offer callback functions that developers can use in their projects.</p>
			<p>The following is a simple example of a callback:</p>
			<pre class="source-code">private fun fetchTextWithCallback() {</pre>
			<pre class="source-code">  fetchTextWithCallback { text -&gt;</pre>
			<pre class="source-code">    //display text</pre>
			<pre class="source-code">    displayText(text)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fun fetchTextWithCallback(onSuccess: (String) -&gt; Unit) {    </pre>
			<pre class="source-code">     Thread {</pre>
			<pre class="source-code">          val text = getTextFromNetwork()    </pre>
			<pre class="source-code">          onSuccess(text)</pre>
			<pre class="source-code">    }.start()</pre>
			<pre class="source-code">}</pre>
			<p>In the<a id="_idIndexMarker026"/> preceding example, after fetching the text in the background, the <code>onSuccess</code> callback will be called and will display the text on the UI thread.</p>
			<p>Callbacks work fine for simple asynchronous tasks. They can, however, become complicated easily, especially when nesting callback functions and handling errors. This makes it hard to read and test. You can avoid this by avoiding nesting callbacks and splitting functions into subfunctions. It is better to use coroutines, which you will learn more about shortly in this chapter.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>AsyncTask</h2>
			<p><code>AsyncTask</code>, you don’t have to manually handle threads.</p>
			<p>To<a id="_idIndexMarker028"/> use <code>AsyncTask</code>, you have to create a subclass of it with three generic types:</p>
			<pre class="source-code">AsyncTask&lt;Params?, Progress?, Result?&gt;()</pre>
			<p>These types are as follows:</p>
			<ul>
				<li><code>Params</code>: This<a id="_idIndexMarker029"/> is the type of input for <code>AsyncTask</code> or is void if there’s no input needed.</li>
				<li><code>Progress</code>: This<a id="_idIndexMarker030"/> argument is used to specify the progress of the background operation or Void if there’s no need to track the progress.</li>
				<li><code>Result</code>: This is the<a id="_idIndexMarker031"/> type of output of <code>AsyncTask</code> or is void if there’s no output to be displayed.</li>
			</ul>
			<p>For example, if you are going to create <code>AsyncTask</code> to download text from a specific endpoint, your <code>Params</code> will be the URL (<code>String</code>) and <code>Result</code> will be the text output (<code>String</code>). If you want to <a id="_idIndexMarker032"/>track the percentage of time remaining to download the text, you can use <code>Integer</code> for <code>Progress</code>. Your class declaration would look like this:</p>
			<pre class="source-code">class DownloadTextAsyncTask : AsyncTask&lt;String, Integer,</pre>
			<pre class="source-code"> String&gt;()</pre>
			<p>You can then start <code>AsyncTask</code> with the following code:</p>
			<pre class="source-code">DownloadTextAsyncTask().execute("https://example.com")</pre>
			<p><code>AsyncTask</code> has four events that you can override for your background processing:</p>
			<ul>
				<li><code>doInBackground</code>: This<a id="_idIndexMarker033"/> event specifies the actual task that will be run in the background, such as fetching/saving data to a remote server. This is the only event that you are required to override.</li>
				<li><code>onPostExecute</code>: This<a id="_idIndexMarker034"/> event specifies the tasks that will be run in the UI thread after the background operation finishes, such as displaying the result.</li>
				<li><code>onPreExecute</code>: This <a id="_idIndexMarker035"/>event runs on the UI thread before doing the actual task, usually displaying a progress loading indicator.</li>
				<li><code>onProgressUpdate</code>: This <a id="_idIndexMarker036"/>event runs in the UI thread to denote progress on the background process, such as displaying the amount of time remaining to finish the task.</li>
			</ul>
			<p>The diagram in <em class="italic">Figure 1.5</em> visualizes these <code>AsyncTask</code> events and in what threads they are run:</p>
			<div><div><img src="img/Figure_1.05_B17773.jpg" alt="Figure 1.5 – AsyncTask events in main and background threads&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – AsyncTask events in main and background threads</p>
			<p>The <code>onPreExecute</code>, <code>onProgressUpdate</code>, and <code>onPostExecute</code> functions will run on the<a id="_idIndexMarker037"/> main thread, while <code>doInBackground</code> executes on the background thread.</p>
			<p>Coming back to our example, your <code>DownloadTextAsync</code> class could look like the following:</p>
			<pre class="source-code">class DownloadTextAsyncTask : AsyncTask&lt;String, Void,</pre>
			<pre class="source-code"> String&gt;() {</pre>
			<pre class="source-code">        override fun doInBackground(vararg params:</pre>
			<pre class="source-code">          String?): String? {</pre>
			<pre class="source-code">            valtext = getTextFromNetwork(params[0] ?: "")</pre>
			<pre class="source-code">            //get text from network</pre>
			<pre class="source-code">            return text</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        override fun onPostExecute(result: String?) {</pre>
			<pre class="source-code">            //Display on UI</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>In <code>DownloadTextAsync</code>, <code>doInBackground</code> fetches the text from the network and returns it as a string. <code>onPostExecute</code> will then be called with that string that can be displayed in the UI thread.</p>
			<p><code>AsyncTask</code> can<a id="_idIndexMarker038"/> cause context leaks, missed callbacks, or crashes on configuration changes. For example, if you rotate the screen, the activity will be recreated and another <code>AsyncTask</code> instance can be created. The original instance won’t be automatically canceled and when it finishes and returns to <code>onPostExecute()</code>, the original activity is already gone. </p>
			<p>Using <code>AsyncTask</code> also makes your code more complicated and less readable. As of Android 11, <code>AsyncTask</code> has been deprecated. It is recommended to use <code>java.util.concurrent</code> or Kotlin coroutines instead.</p>
			<p>In the next section, you will explore one of the <code>java.util.concurrent</code> classes for asynchronous programming, <code>Executors</code>.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Executors</h2>
			<p>One<a id="_idIndexMarker039"/> of the classes in the <code>java.util.concurrent</code> package that you can use for asynchronous programming is <code>java.util.concurrent.Executor</code>. An executor is a high-level Java API for managing threads. It is an interface that has a single function, <code>execute(Runnable)</code>, for performing tasks.</p>
			<p>To create an<a id="_idIndexMarker040"/> executor, you can use the utility methods from the <code>java.util.concurrent.Executors</code> class. <code>Executors.newSingleThreadExecutor()</code> creates an executor with a single thread.</p>
			<p>Your asynchronous<a id="_idIndexMarker041"/> code with <code>Executor</code> will look like the following:</p>
			<pre class="source-code">val handler = Handler(Looper.getMainLooper())</pre>
			<pre class="source-code">private fun fetchTextWithExecutor() {</pre>
			<pre class="source-code">  val executor = Executors.newSingleThreadExecutor()</pre>
			<pre class="source-code">  executor.execute {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">           val text = getTextFromNetwork()</pre>
			<pre class="source-code">    handler.post {</pre>
			<pre class="source-code">      // Display on UI</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>The handler with <code>Looper.getMainLooper()</code> allows you to communicate back to the main thread so you can update the UI after your background task has been done.</p>
			<p><code>ExecutorService</code> is an executor that can do more than just <code>execute(Runnable)</code>. One of its subclasses is <code>ThreadPoolExecutor</code>, an <code>ExecutorService</code> class that implements a thread pool that you can customize. </p>
			<p><code>ExecutorService</code> has <code>submit(Runnable)</code> and <code>submit(Callable)</code> functions, which can execute a background task. They both return a <code>Future</code> object that represents the result. </p>
			<p>The <code>Future</code> object has two functions you can use, <code>Future.isDone()</code> to check whether the executor has finished the task and <code>Future.get()</code> to get the results of the task, as follows:</p>
			<pre class="source-code">val handler = Handler(Looper.getMainLooper()</pre>
			<pre class="source-code">private fun fetchTextWithExecutorService() {</pre>
			<pre class="source-code">  val executor = Executors.newSingleThreadExecutor()</pre>
			<pre class="source-code">  val future = executor.submit {</pre>
			<pre class="source-code">     displayText(getTextFromNetwork())    </pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  val result = <strong class="bold">future.get()</strong></pre>
			<pre class="source-code">}</pre>
			<p>In the preceding <a id="_idIndexMarker042"/>code, the executor created with a new single thread executor was used to submit the runnable function to get and display text from the network. The <code>submit</code> function returns a <code>Future</code> object, which you can later use to fetch the result with <code>Future.get()</code>.</p>
			<p>In this section, you learned some of the methods that you can use for asynchronous programming in Android. While they do work and you can still use them (except for the now-deprecated <code>AsyncTask</code>), nowadays, they are not the best method to use moving forward. </p>
			<p>In the next section, you will learn the new, recommended way of asynchronous programming in Android: using Kotlin coroutines and flows.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor024"/>The new way to do it – coroutines and flows</h1>
			<p>In this section, you will learn about the recommended approach for Android asynchronous<a id="_idIndexMarker043"/> programming: using coroutines and flows. Coroutines is a Kotlin library you can use in Android to perform asynchronous tasks. Coroutines is a library for managing background tasks that return a single value. Flows are built on top of coroutines that can return multiple values.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Kotlin coroutines</h2>
			<p>Coroutines is a <a id="_idIndexMarker044"/>Kotlin library for managing background tasks, such as making network calls and accessing files or databases, or performing long-running background tasks. Using Kotlin coroutines is Google’s official recommendation for asynchronous programming on Android. Their Android Jetpack libraries, such as Lifecycle, WorkManager, and Room-KTX, now include support for coroutines. Other Android libraries, such as Retrofit, Ktor, and Coil, provide first-class support for Kotlin coroutines.</p>
			<p>With <a id="_idIndexMarker045"/>Kotlin coroutines, you can write your code in a sequential way. A long-running task can be made into a <code>suspend</code> function. A <code>suspend</code> function is a function that can perform its task by suspending the thread without blocking it, so the thread can still run other tasks. When the suspending function is done, the current thread will resume execution. This makes the code easier to read, debug, and test. Coroutines follow a principle of structured concurrency.</p>
			<p>You can add coroutines to your Android project by adding the following lines to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source-code">implementation "org.jetbrains.kotlinx:kotlinx-coroutines-</pre>
			<pre class="source-code">  core:1.6.0"</pre>
			<pre class="source-code">implementation "org.jetbrains.kotlinx:kotlinx-coroutines-</pre>
			<pre class="source-code">  android:1.6.0"</pre>
			<p><code>kotlinx-coroutines-core</code> is the main library for Kotlin coroutines, while <code>kotlinx-coroutines-android</code> adds support for the main Android thread (<code>Dispatchers.Main</code>).</p>
			<p>To mark a function as a suspending function, you can add the <code>suspend</code> keyword to it; for example, here we have a function that calls the <code>fetchText()</code> function, which retrieves text from an endpoint and then displays it in the UI thread:</p>
			<pre class="source-code">fun fetchText(): String {</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>You can make the <code>fetchText()</code> function a suspending function by prefixing the <code>suspend</code> keyword, as follows:</p>
			<pre class="source-code">suspend fun fetchText(): String { ... }</pre>
			<p>Then, you <a id="_idIndexMarker046"/>can create<a id="_idIndexMarker047"/> a coroutine that will call the <code>fetchText()</code> suspending function and display the list, as follows:</p>
			<pre class="source-code">lifecycleScope.launch(Dispatchers.IO) {</pre>
			<pre class="source-code">    val fetchedText = fetchText()  </pre>
			<pre class="source-code">    withContext(Dispatchers.Main) {</pre>
			<pre class="source-code">      displayText(fetchedText)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p><code>lifecycleScope</code> is the scope with which the coroutine will run. <code>launch</code> creates a coroutine to run in <code>Dispatchers.IO</code>, which is a thread for I/O or network operations.</p>
			<p>The <code>fetchText()</code> function will suspend the coroutine before it starts the network request. While the coroutine is suspended, the main thread can do other work.</p>
			<p>After getting the text, it will resume the coroutine. <code>withContext(Dispatchers.Main)</code> will switch the coroutine context to the main thread, where the <code>displayText(text)</code> function will be executed (<code>Dispatchers.Main</code>).</p>
			<p>In Android Studio, the <code>suspend</code> function calls in your code with a gutter icon next to the line number. As shown in lines <code>fetchText()</code> and <code>withContext()</code> lines have the <code>suspend</code> function call gutter icon:</p>
			<div><div><img src="img/Figure_1.06_B17773.jpg" alt="Figure 1.6 – Android Studio suspend function call gutter icon&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Android Studio suspend function call gutter icon</p>
			<p>You can<a id="_idIndexMarker048"/> learn <a id="_idIndexMarker049"/>more about Kotlin coroutines in <a href="B17773_02_Epub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Kotlin Coroutines</em>. </p>
			<p>In the next section, you will learn about Kotlin Flows, built on top of coroutines, which can return multiple sequences of values.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Kotlin Flows</h2>
			<p>Flow is a new Kotlin<a id="_idIndexMarker050"/> asynchronous stream library that is built on top of Kotlin coroutines. A flow <a id="_idIndexMarker051"/>can emit multiple values instead of a single value and over a period of time. Kotlin Flow is ideal to use when you need to return multiple values asynchronously, such as automatic updates from your data source. </p>
			<p>Flow is now used in Jetpack libraries such as Room-KTX and Android developers are already using Flow in their applications.</p>
			<p>To use<a id="_idIndexMarker052"/> Kotlin Flows in your Android project, you have to add coroutines. An easy way to create a flow of objects is to use the <code>flow{}</code> builder. With the <code>flow{}</code> builder function, you can add values to the stream by calling emit.</p>
			<p>Let’s say in your Android app you have a <code>getTextFromNetwork</code> function that fetches text from a network endpoint and returns it as a <code>String</code> object:</p>
			<pre class="source-code">fun getTextFromNetwork(): String { ... }</pre>
			<p>If we want to <a id="_idIndexMarker053"/>create a<a id="_idIndexMarker054"/> flow of each word of the text, we can do it with the following code:</p>
			<pre class="source-code">private fun getWords(): Flow&lt;String&gt; = flow {</pre>
			<pre class="source-code">  getTextFromNetwork().split(" ").forEach {</pre>
			<pre class="source-code">    delay(1_000)</pre>
			<pre class="source-code">    emit(it)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Flow does not run or emit values until the flow is collected with any terminal operators, such as <code>collect</code>, <code>launchIn</code>, or <code>single</code>. You can use the <code>collect()</code> function to start the flow and process each value, as follows:</p>
			<pre class="source-code">private suspend fun displayWords() {</pre>
			<pre class="source-code">          getWords().collect {</pre>
			<pre class="source-code">          Log.d("flow", it)</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">}</pre>
			<p>A visual representation of this flow is shown in the following figure:</p>
			<div><div><img src="img/Figure_1.07_B17773.jpg" alt="Figure 1.7 – Kotlin Flow visual representation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Kotlin Flow visual representation</p>
			<p>As you<a id="_idIndexMarker055"/> can <a id="_idIndexMarker056"/>see in <em class="italic">Figure 1.7</em>, as soon as the <code>getWords()</code> flow emits a string, the <code>displayWords</code> function collects the string and displays it immediately on the logs.</p>
			<p>You will learn more about Kotlin Flows in <a href="B17773_05_Epub.xhtml#_idTextAnchor062"><em class="italic">Chapter 5</em></a>, <em class="italic">Using Kotlin Flows</em>.</p>
			<p>In this section, you learned about Kotlin coroutines and flows, the recommended way to carry out asynchronous programming in Android. Coroutines is a Kotlin library for managing long-running tasks in the background. Flow is a new Kotlin asynchronous stream library, built on top of coroutines, that can emit multiple values over a period of time.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor027"/>Summary</h1>
			<p>In this chapter, you revisited the concept of asynchronous programming. We learned that asynchronous programming helps you execute long-running tasks in the background without freezing the app and annoying your users.</p>
			<p>You then learned about various ways you can do asynchronous programming in Android, including with threads, AsyncTask, and <code>Executors</code>. We also learned that they allow you to perform tasks in the background and update the main thread. AsyncTask is already deprecated, and threads and <code>Executors</code> are not the best ways to carry out asynchronous programming in Android.</p>
			<p>Finally, you were introduced to the new, recommended way to carry out asynchronous programming in Android: with Kotlin’s Coroutines and Flow. We learned that Coroutines is a Kotlin library that you can use to easily perform asynchronous, non-blocking, and long-running tasks in the background. Flow, built on top of Coroutines, allows you to handle functions that return multiple values over time.</p>
			<p>In the next chapter, you will dive deeper into Kotlin coroutines and learn how to use them in your Android project.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/>Further reading</h1>
			<p>This book assumes that you have experience and skills in Android development with Kotlin. If you would like to learn more about this, you can read the book <em class="italic">How to Build Android Apps with Kotlin</em> (<em class="italic">Packt Publishing, 2021, ISBN 9781838984113</em>).</p>
		</div>
	</body></html>