<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Introduction to Asynchronous Programming in Android</h1>
			<p>There are Android applications that work on their own. But most apps retrieve data from or send data to a local database or a backend server. Examples of these include fetching posts from a social network, saving your favorites from a list, uploading an image, or updating your profile information. These tasks and other resource-intensive computations may happen instantly or take a while to finish. Factors such as internet connection, device specifications, and server settings affect how long these operations take.</p>
			<p>Long-running operations must not be performed on the main UI thread as the application will be blocked until they are completed. The application might become unresponsive to the users. Users may not be aware of what’s happening, and this might prompt them to close the app and reopen it (canceling the original task or doing it again). The app can also suddenly crash. Some users might even stop using your app if this happens frequently.</p>
			<p>To prevent this from happening, you need to use asynchronous programming. Tasks that can take an indefinite amount of time must be done asynchronously. They must run in the background, parallel to other tasks. For example, while posting information to your backend server, the app displays the UI, which the users can interact with. When the operation finishes, you can then update the UI or notify the users (with a dialog or a snackbar message).</p>
			<p>With this book, you will learn how to simplify asynchronous programming in Android using Kotlin coroutines and flows.</p>
			<p>In this chapter, you will first start by revisiting the concept of asynchronous programming. After that, you will look into the various ways it is being done now in Android and how they may no longer be the best way moving forward. Then, you will be introduced to the new, recommended way of performing asynchronous programming in Android: coroutines and flows.</p>
			<p>This chapter covers three main topics:</p>
			<ul>
				<li>Asynchronous programming</li>
				<li>Threads, AsyncTasks, and <strong class="source-inline">Executors</strong></li>
				<li>The new way to do it – coroutines and flows</li>
			</ul>
			<p>By the end of this chapter, you will have a basic understanding of asynchronous programming, and know how to do it in Android using threads, AsyncTasks, and <strong class="source-inline">Executors</strong>. Finally, you will discover Kotlin coroutines and flows as these are the recommended ways of doing asynchronous programming in Android. </p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>You will need to download and install the latest version of Android Studio. You can find the latest version at <a href="https://developer.android.com/studio">https://developer.android.com/studio</a>. For an optimal learning experience, a computer with the following specifications is recommended: Intel Core i5 or equivalent or higher, 4 GB RAM minimum, and 4 GB available space.</p>
			<p>The code examples for this book can be found on GitHub at https: <a href="http://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows">github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows</a>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Understanding asynchronous programming</h1>
			<p>In this <a id="_idIndexMarker000"/>section, we will start by looking at asynchronous programming. Asynchronous programming is a programming method that allows work to be done independently of the main application thread.</p>
			<p>A normal program will run sequentially. It will perform one task and move to the next task after the previous one has finished. For simple operations, this is fine. However, there are some tasks that might take a long time to finish, such as the following:</p>
			<ul>
				<li>Fetching data from or saving data to a database</li>
				<li>Getting, adding, or updating data to a network</li>
				<li>Processing text, images, videos, or other files</li>
				<li>Complicated computations</li>
			</ul>
			<p>The app will look frozen and unresponsive to the users while it is performing these tasks. They won’t be able to do anything else in the app until the tasks are finished.</p>
			<p>Asynchronous programming <a id="_idIndexMarker001"/>solves this problem. You can run a task that may be processed indefinitely on a background thread (in parallel to the main thread) without freezing the app. This will allow the users to still interact with the app or the UI while the original task is running. When the task has finished or if an error was encountered, you can then inform the user using the main thread.</p>
			<p>A <a id="_idIndexMarker002"/>visual representation of asynchronous programming is shown in the following figure:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.01_B17773.jpg" alt="Figure 1.1 – Asynchronous programming&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Asynchronous programming</p>
			<p><strong class="bold">Task 1</strong> and <strong class="bold">Task 2</strong> are running on the main thread. <strong class="bold">Task 2</strong> starts <strong class="bold">Task 3</strong> on the background thread. While <strong class="bold">Task 3</strong> is running, the main thread can continue to perform other tasks, such as <strong class="bold">Task 4</strong>. After <strong class="bold">Task 3</strong> is done, it will return to the main thread. </p>
			<p>Asynchronous programming<a id="_idIndexMarker003"/> is an important skill for developers to have, especially for mobile app development. Mobile devices have limited capabilities and not all locations have a stable network connection.</p>
			<p>In Android, if you run a task on the main thread and it takes too long, the app can become unresponsive or look frozen. The app can also crash unexpectedly. You will likely <a id="_idIndexMarker004"/>get an <strong class="bold">Application Not Responding</strong> (<strong class="bold">ANR</strong>) error, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.02_B17773.jpg" alt="Figure 1.2 – An ANR dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – An ANR dialog</p>
			<p>Starting <a id="_idIndexMarker005"/>with Android 3.0 (Honeycomb), running a <a id="_idIndexMarker006"/>network operation on the main thread will cause <strong class="source-inline">android.os.NetworkOnMainThreadException</strong>, which will crash your app. </p>
			<p>ANR dialogs and crashes can annoy your users. If they happen all the time, they might stop using your app altogether and choose another app. To prevent them in your app, you must run tasks<a id="_idIndexMarker007"/> that can take a long period of time on the background thread.</p>
			<p>In this section, you revisited the concept of asynchronous programming and how you can use it to run long-running tasks without freezing the app. You will explore various approaches for using asynchronous programming in Android in the next section.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Exploring threads, AsyncTasks, and Executors</h1>
			<p>There are many ways you can run tasks on the background thread in Android. In this section, you are going to explore various ways of doing asynchronous programming in Android, including using threads, AsyncTask, and <strong class="source-inline">Executors</strong>. You will learn how to start a task on the background thread and then update the main thread with the result.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>Threads</h2>
			<p>A thread is a <a id="_idIndexMarker008"/>unit of execution that runs code concurrently. In Android, the UI thread is the main thread. You can perform a task on another thread by using the <strong class="source-inline">java.lang.Thread</strong> class: </p>
			<pre class="source-code">private fun fetchTextWithThread() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">        // get text from network</pre>
			<pre class="source-code">        val text = getTextFromNetwork()</pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p>To run the<a id="_idIndexMarker009"/> thread, call <strong class="source-inline">Thread.start()</strong>. Everything that is inside the braces will be performed on another thread. You can do any operation here, except updating the UI, as you will encounter <strong class="source-inline">NetworkOnMainThreadException</strong>.</p>
			<p>To update the UI, such as displaying the text fetched in a <strong class="source-inline">TextView</strong> from the network, you would need to use <strong class="source-inline">Activity.runOnUiThread()</strong>. The code inside <strong class="source-inline">runOnUIThread</strong> will be executed in the main thread, as follows:</p>
			<pre class="source-code">private fun fetchTextWithThread() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">          // get text from network</pre>
			<pre class="source-code">          val text = getTextFromNetwork()</pre>
			<pre class="source-code">    <strong class="bold">runOnUiThread {</strong></pre>
			<pre class="source-code"><strong class="bold">        // Display on UI</strong></pre>
			<pre class="source-code">        <strong class="bold">displayText(text)</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">runOnUIThread</strong> will <a id="_idIndexMarker010"/>perform the <strong class="source-inline">displayText(text)</strong> function on the main UI thread.</p>
			<p>If you are not starting the thread from an activity, you can use handlers instead of <strong class="source-inline">runOnUiThread</strong> to update the UI, as seen in <em class="italic">Figure 1.3</em>:  </p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.03_B17773.jpg" alt=" Figure 1.3 – Threads and a handler&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 1.3 – Threads and a handler</p>
			<p>A handler (<strong class="source-inline">android.os.Handler</strong>) allows <a id="_idIndexMarker011"/>you to communicate between threads, such as from the background thread to the main thread, as shown in the preceding figure. You can pass a looper into the Handler constructor to specify the thread where the task will be run. A looper is an object that runs the messages in the thread’s queue. </p>
			<p>To attach<a id="_idIndexMarker012"/> the<a id="_idIndexMarker013"/> handler to the main thread, you should use <strong class="source-inline">Looper.getMainLooper()</strong>, like in the following example:</p>
			<pre class="source-code">private fun fetchTextWithThreadAndHandler() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">           val text = getTextFromNetwork()</pre>
			<pre class="source-code">    <strong class="bold">Handler(Looper.getMainLooper()).post {</strong></pre>
			<pre class="source-code"><strong class="bold">      // Display on UI</strong></pre>
			<pre class="source-code">      <strong class="bold">displayText(text)</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">Handler(Looper.getMainLooper())</strong> creates <a id="_idIndexMarker014"/>a handler tied to the main thread <a id="_idIndexMarker015"/>and posts the <strong class="source-inline">displayText()</strong> runnable function on the main thread. </p>
			<p>The <strong class="source-inline">Handler.post (Runnable)</strong> function enqueues the runnable function to be executed on the specified thread. Other variants of the post function include <strong class="source-inline">postAtTime(Runnable)</strong> and <strong class="source-inline">postDelayed (Runnable, uptimeMillis)</strong>.</p>
			<p>Alternatively, you can also send an <strong class="source-inline">android.os.Message</strong> object with your handler, as shown in <em class="italic">Figure 1.4</em>:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.04_B17773.jpg" alt="Figure 1.4 – Threads, handlers, and messages&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Threads, handlers, and messages</p>
			<p>A thread’s handler allows you to send a message to the thread’s message queue. The handler’s looper will execute the messages in the queue.</p>
			<p>To <a id="_idIndexMarker016"/>include the <a id="_idIndexMarker017"/>actual messages you want to send in your Message object, you can use <strong class="source-inline">setData(Bundle)</strong> to pass a single bundle of data. You can also use the public fields of the message <strong class="source-inline">class</strong> (<strong class="source-inline">arg1, arg2, and </strong> <strong class="source-inline">what</strong> for integer values, and <strong class="source-inline">obj</strong> for an object value).</p>
			<p>You must then create a subclass of Handler and override the <strong class="source-inline">handleMessage(Message)</strong> function. There, you can then get the data from the message and process it in the handler’s thread.</p>
			<p>You can use the following functions to send a message: <strong class="source-inline">sendMessage(Message)</strong>, <strong class="source-inline">sendMessageAtTime(Message, uptimeMillis)</strong>, and <strong class="source-inline">sendMessageDelayed(Message, delayMillis)</strong>. The following code shows the use of the <strong class="source-inline">sendMessage</strong> function to send a message with a data bundle:</p>
			<pre class="source-code">private val key = "key"</pre>
			<pre class="source-code">private val messageHandler = object :</pre>
			<pre class="source-code">   Handler(Looper.getMainLooper()) {</pre>
			<pre class="source-code">    override fun handleMessage(message: Message) {</pre>
			<pre class="source-code">    val bundle = message.data</pre>
			<pre class="source-code">    val text = bundle.getString(key, "")</pre>
			<pre class="source-code">    //Display text</pre>
			<pre class="source-code">    displayText(text)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private fun fetchTextWithHandlerMessage() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">    val text = getTextFromNetwork()</pre>
			<pre class="source-code">    val message = handler.obtainMessage()</pre>
			<pre class="source-code">  </pre>
			<pre class="source-code">    val bundle = Bundle()</pre>
			<pre class="source-code">    bundle.putString(key, text)</pre>
			<pre class="source-code">    message.data = bundle</pre>
			<pre class="source-code">    messageHandler.sendMessage(message)</pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p>Here, <strong class="source-inline">fetchTextWithHandlerMessage()</strong> gets the text from the network in a background thread. It then creates a message with a bundle object containing a string with a key of <strong class="source-inline">key</strong> to send that text. The handler can then, through the <strong class="source-inline">handleMessage()</strong> function, get the message’s bundle and get the string from the bundle using the same key.</p>
			<p>You <a id="_idIndexMarker018"/>can also send empty messages with an integer value (the what) that <a id="_idIndexMarker019"/>you can use in your <strong class="source-inline">handleMessage</strong> function to identify what message was received. These send empty functions are <strong class="source-inline">sendEmptyMessage(int)</strong>, <strong class="source-inline">sendEmptyMessageAtTime(int, long)</strong>, and <strong class="source-inline">sendEmptyMessageDelayed(int, long)</strong>. </p>
			<p>This example uses <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> as values for what (“what” is a field of the <strong class="source-inline">Message</strong> class that is a user-defined message code so that the recipient can identify what this message is about): <strong class="source-inline">1</strong> for the case when the background task succeeded and <strong class="source-inline">0</strong> for the failure case:</p>
			<pre class="source-code">private val emptymesageHandler = object :</pre>
			<pre class="source-code">  Handler(Looper.getMainLooper()) {</pre>
			<pre class="source-code">  override fun handleMessage(message: Message) {</pre>
			<pre class="source-code">    if (message.what == 1) {</pre>
			<pre class="source-code">      //Update UI</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      //Show Error</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private fun fetchTextWithEmptyMessage() {</pre>
			<pre class="source-code">  Thread {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">...</pre>
			<pre class="source-code">    if (failed) {  </pre>
			<pre class="source-code">      emptyMessageHandler.sendEmptyMessage(0)</pre>
			<pre class="source-code">    } else {</pre>
			<pre class="source-code">      emptyMessageHandler.sendEmptyMessage(1)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }.start()</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code snippet, the background thread fetches the text from the network. It then sends an empty message of <strong class="source-inline">1</strong> if the operation succeeded and <strong class="source-inline">0</strong> if not. The handler, through the <strong class="source-inline">handleMessage()</strong> function, gets the <strong class="source-inline">what</strong> integer value of the message, which corresponds to the <strong class="source-inline">0</strong> or <strong class="source-inline">1</strong> empty message. Depending on this value, it can either update the UI or show an error to the main thread. </p>
			<p>Using threads and handlers works for<a id="_idIndexMarker020"/> background processing, but they have the following <a id="_idIndexMarker021"/>disadvantages: </p>
			<ul>
				<li>Every time you need to run a task in the background, you should create a new thread and use <strong class="source-inline">runOnUiThread</strong> or a new handler to post back to the main thread. </li>
				<li>Creating threads can consume a lot of memory and resources. </li>
				<li>It can also slow down your app.</li>
				<li>Multiple threads make your code harder to debug and test.</li>
				<li>Code <a id="_idIndexMarker022"/>can become complicated to read and maintain.</li>
			</ul>
			<p>Using <a id="_idIndexMarker023"/>threads makes it difficult to handle exceptions, which can lead to crashes.</p>
			<p>As a thread is<a id="_idIndexMarker024"/> a low-level API for asynchronous programming, it is better to use the ones that are built on top of threads, such as executors and, until it was deprecated, <strong class="source-inline">AsyncTask</strong>. You can avoid it altogether by using Kotlin coroutines, which you will learn more about later in this chapter.</p>
			<p>In the next section, you will explore callbacks, another approach to asynchronou<a id="_idTextAnchor020"/>s Android programming.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Callbacks</h2>
			<p>Another<a id="_idIndexMarker025"/> common approach to asynchronous programming in Android is using callbacks. A callback is a function that will be run when the asynchronous code has finished executing. Some libraries offer callback functions that developers can use in their projects.</p>
			<p>The following is a simple example of a callback:</p>
			<pre class="source-code">private fun fetchTextWithCallback() {</pre>
			<pre class="source-code">  fetchTextWithCallback { text -&gt;</pre>
			<pre class="source-code">    //display text</pre>
			<pre class="source-code">    displayText(text)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">fun fetchTextWithCallback(onSuccess: (String) -&gt; Unit) {    </pre>
			<pre class="source-code">     Thread {</pre>
			<pre class="source-code">          val text = getTextFromNetwork()    </pre>
			<pre class="source-code">          onSuccess(text)</pre>
			<pre class="source-code">    }.start()</pre>
			<pre class="source-code">}</pre>
			<p>In the<a id="_idIndexMarker026"/> preceding example, after fetching the text in the background, the <strong class="source-inline">onSuccess</strong> callback will be called and will display the text on the UI thread.</p>
			<p>Callbacks work fine for simple asynchronous tasks. They can, however, become complicated easily, especially when nesting callback functions and handling errors. This makes it hard to read and test. You can avoid this by avoiding nesting callbacks and splitting functions into subfunctions. It is better to use coroutines, which you will learn more about shortly in this chapter.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>AsyncTask</h2>
			<p><strong class="bold">AsyncTask</strong> has<a id="_idIndexMarker027"/> been the go-to class for running background tasks in Android. It makes it easier to do background processing and post data to the main thread. With <strong class="source-inline">AsyncTask</strong>, you don’t have to manually handle threads.</p>
			<p>To<a id="_idIndexMarker028"/> use <strong class="source-inline">AsyncTask</strong>, you have to create a subclass of it with three generic types:</p>
			<pre class="source-code">AsyncTask&lt;Params?, Progress?, Result?&gt;()</pre>
			<p>These types are as follows:</p>
			<ul>
				<li><strong class="source-inline">Params</strong>: This<a id="_idIndexMarker029"/> is the type of input for <strong class="source-inline">AsyncTask</strong> or is void if there’s no input needed.</li>
				<li><strong class="source-inline">Progress</strong>: This<a id="_idIndexMarker030"/> argument is used to specify the progress of the background operation or Void if there’s no need to track the progress.</li>
				<li><strong class="source-inline">Result</strong>: This is the<a id="_idIndexMarker031"/> type of output of <strong class="source-inline">AsyncTask</strong> or is void if there’s no output to be displayed.</li>
			</ul>
			<p>For example, if you are going to create <strong class="source-inline">AsyncTask</strong> to download text from a specific endpoint, your <strong class="source-inline">Params</strong> will be the URL (<strong class="source-inline">String</strong>) and <strong class="source-inline">Result</strong> will be the text output (<strong class="source-inline">String</strong>). If you want to <a id="_idIndexMarker032"/>track the percentage of time remaining to download the text, you can use <strong class="source-inline">Integer</strong> for <strong class="source-inline">Progress</strong>. Your class declaration would look like this:</p>
			<pre class="source-code">class DownloadTextAsyncTask : AsyncTask&lt;String, Integer,</pre>
			<pre class="source-code"> String&gt;()</pre>
			<p>You can then start <strong class="source-inline">AsyncTask</strong> with the following code:</p>
			<pre class="source-code">DownloadTextAsyncTask().execute("https://example.com")</pre>
			<p><strong class="source-inline">AsyncTask</strong> has four events that you can override for your background processing:</p>
			<ul>
				<li><strong class="source-inline">doInBackground</strong>: This<a id="_idIndexMarker033"/> event specifies the actual task that will be run in the background, such as fetching/saving data to a remote server. This is the only event that you are required to override.</li>
				<li><strong class="source-inline">onPostExecute</strong>: This<a id="_idIndexMarker034"/> event specifies the tasks that will be run in the UI thread after the background operation finishes, such as displaying the result.</li>
				<li><strong class="source-inline">onPreExecute</strong>: This <a id="_idIndexMarker035"/>event runs on the UI thread before doing the actual task, usually displaying a progress loading indicator.</li>
				<li><strong class="source-inline">onProgressUpdate</strong>: This <a id="_idIndexMarker036"/>event runs in the UI thread to denote progress on the background process, such as displaying the amount of time remaining to finish the task.</li>
			</ul>
			<p>The diagram in <em class="italic">Figure 1.5</em> visualizes these <strong class="source-inline">AsyncTask</strong> events and in what threads they are run:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.05_B17773.jpg" alt="Figure 1.5 – AsyncTask events in main and background threads&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – AsyncTask events in main and background threads</p>
			<p>The <strong class="source-inline">onPreExecute</strong>, <strong class="source-inline">onProgressUpdate</strong>, and <strong class="source-inline">onPostExecute</strong> functions will run on the<a id="_idIndexMarker037"/> main thread, while <strong class="source-inline">doInBackground</strong> executes on the background thread.</p>
			<p>Coming back to our example, your <strong class="source-inline">DownloadTextAsync</strong> class could look like the following:</p>
			<pre class="source-code">class DownloadTextAsyncTask : AsyncTask&lt;String, Void,</pre>
			<pre class="source-code"> String&gt;() {</pre>
			<pre class="source-code">        override fun doInBackground(vararg params:</pre>
			<pre class="source-code">          String?): String? {</pre>
			<pre class="source-code">            valtext = getTextFromNetwork(params[0] ?: "")</pre>
			<pre class="source-code">            //get text from network</pre>
			<pre class="source-code">            return text</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">        override fun onPostExecute(result: String?) {</pre>
			<pre class="source-code">            //Display on UI</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">}</pre>
			<p>In <strong class="source-inline">DownloadTextAsync</strong>, <strong class="source-inline">doInBackground</strong> fetches the text from the network and returns it as a string. <strong class="source-inline">onPostExecute</strong> will then be called with that string that can be displayed in the UI thread.</p>
			<p><strong class="source-inline">AsyncTask</strong> can<a id="_idIndexMarker038"/> cause context leaks, missed callbacks, or crashes on configuration changes. For example, if you rotate the screen, the activity will be recreated and another <strong class="source-inline">AsyncTask</strong> instance can be created. The original instance won’t be automatically canceled and when it finishes and returns to <strong class="source-inline">onPostExecute()</strong>, the original activity is already gone. </p>
			<p>Using <strong class="source-inline">AsyncTask</strong> also makes your code more complicated and less readable. As of Android 11, <strong class="source-inline">AsyncTask</strong> has been deprecated. It is recommended to use <strong class="source-inline">java.util.concurrent</strong> or Kotlin coroutines instead.</p>
			<p>In the next section, you will explore one of the <strong class="source-inline">java.util.concurrent</strong> classes for asynchronous programming, <strong class="source-inline">Executors</strong>.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Executors</h2>
			<p>One<a id="_idIndexMarker039"/> of the classes in the <strong class="source-inline">java.util.concurrent</strong> package that you can use for asynchronous programming is <strong class="source-inline">java.util.concurrent.Executor</strong>. An executor is a high-level Java API for managing threads. It is an interface that has a single function, <strong class="source-inline">execute(Runnable)</strong>, for performing tasks.</p>
			<p>To create an<a id="_idIndexMarker040"/> executor, you can use the utility methods from the <strong class="source-inline">java.util.concurrent.Executors</strong> class. <strong class="source-inline">Executors.newSingleThreadExecutor()</strong> creates an executor with a single thread.</p>
			<p>Your asynchronous<a id="_idIndexMarker041"/> code with <strong class="source-inline">Executor</strong> will look like the following:</p>
			<pre class="source-code">val handler = Handler(Looper.getMainLooper())</pre>
			<pre class="source-code">private fun fetchTextWithExecutor() {</pre>
			<pre class="source-code">  val executor = Executors.newSingleThreadExecutor()</pre>
			<pre class="source-code">  executor.execute {</pre>
			<pre class="source-code">    // get text from network</pre>
			<pre class="source-code">           val text = getTextFromNetwork()</pre>
			<pre class="source-code">    handler.post {</pre>
			<pre class="source-code">      // Display on UI</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>The handler with <strong class="source-inline">Looper.getMainLooper()</strong> allows you to communicate back to the main thread so you can update the UI after your background task has been done.</p>
			<p><strong class="source-inline">ExecutorService</strong> is an executor that can do more than just <strong class="source-inline">execute(Runnable)</strong>. One of its subclasses is <strong class="source-inline">ThreadPoolExecutor</strong>, an <strong class="source-inline">ExecutorService</strong> class that implements a thread pool that you can customize. </p>
			<p><strong class="source-inline">ExecutorService</strong> has <strong class="source-inline">submit(Runnable)</strong> and <strong class="source-inline">submit(Callable)</strong> functions, which can execute a background task. They both return a <strong class="source-inline">Future</strong> object that represents the result. </p>
			<p>The <strong class="source-inline">Future</strong> object has two functions you can use, <strong class="source-inline">Future.isDone()</strong> to check whether the executor has finished the task and <strong class="source-inline">Future.get()</strong> to get the results of the task, as follows:</p>
			<pre class="source-code">val handler = Handler(Looper.getMainLooper()</pre>
			<pre class="source-code">private fun fetchTextWithExecutorService() {</pre>
			<pre class="source-code">  val executor = Executors.newSingleThreadExecutor()</pre>
			<pre class="source-code">  val future = executor.submit {</pre>
			<pre class="source-code">     displayText(getTextFromNetwork())    </pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">  val result = <strong class="bold">future.get()</strong></pre>
			<pre class="source-code">}</pre>
			<p>In the preceding <a id="_idIndexMarker042"/>code, the executor created with a new single thread executor was used to submit the runnable function to get and display text from the network. The <strong class="source-inline">submit</strong> function returns a <strong class="source-inline">Future</strong> object, which you can later use to fetch the result with <strong class="source-inline">Future.get()</strong>.</p>
			<p>In this section, you learned some of the methods that you can use for asynchronous programming in Android. While they do work and you can still use them (except for the now-deprecated <strong class="source-inline">AsyncTask</strong>), nowadays, they are not the best method to use moving forward. </p>
			<p>In the next section, you will learn the new, recommended way of asynchronous programming in Android: using Kotlin coroutines and flows.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor024"/>The new way to do it – coroutines and flows</h1>
			<p>In this section, you will learn about the recommended approach for Android asynchronous<a id="_idIndexMarker043"/> programming: using coroutines and flows. Coroutines is a Kotlin library you can use in Android to perform asynchronous tasks. Coroutines is a library for managing background tasks that return a single value. Flows are built on top of coroutines that can return multiple values.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Kotlin coroutines</h2>
			<p>Coroutines is a <a id="_idIndexMarker044"/>Kotlin library for managing background tasks, such as making network calls and accessing files or databases, or performing long-running background tasks. Using Kotlin coroutines is Google’s official recommendation for asynchronous programming on Android. Their Android Jetpack libraries, such as Lifecycle, WorkManager, and Room-KTX, now include support for coroutines. Other Android libraries, such as Retrofit, Ktor, and Coil, provide first-class support for Kotlin coroutines.</p>
			<p>With <a id="_idIndexMarker045"/>Kotlin coroutines, you can write your code in a sequential way. A long-running task can be made into a <strong class="source-inline">suspend</strong> function. A <strong class="source-inline">suspend</strong> function is a function that can perform its task by suspending the thread without blocking it, so the thread can still run other tasks. When the suspending function is done, the current thread will resume execution. This makes the code easier to read, debug, and test. Coroutines follow a principle of structured concurrency.</p>
			<p>You can add coroutines to your Android project by adding the following lines to your <strong class="source-inline">app/build.gradle</strong> file dependencies:</p>
			<pre class="source-code">implementation "org.jetbrains.kotlinx:kotlinx-coroutines-</pre>
			<pre class="source-code">  core:1.6.0"</pre>
			<pre class="source-code">implementation "org.jetbrains.kotlinx:kotlinx-coroutines-</pre>
			<pre class="source-code">  android:1.6.0"</pre>
			<p><strong class="source-inline">kotlinx-coroutines-core</strong> is the main library for Kotlin coroutines, while <strong class="source-inline">kotlinx-coroutines-android</strong> adds support for the main Android thread (<strong class="source-inline">Dispatchers.Main</strong>).</p>
			<p>To mark a function as a suspending function, you can add the <strong class="source-inline">suspend</strong> keyword to it; for example, here we have a function that calls the <strong class="source-inline">fetchText()</strong> function, which retrieves text from an endpoint and then displays it in the UI thread:</p>
			<pre class="source-code">fun fetchText(): String {</pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>You can make the <strong class="source-inline">fetchText()</strong> function a suspending function by prefixing the <strong class="source-inline">suspend</strong> keyword, as follows:</p>
			<pre class="source-code">suspend fun fetchText(): String { ... }</pre>
			<p>Then, you <a id="_idIndexMarker046"/>can create<a id="_idIndexMarker047"/> a coroutine that will call the <strong class="source-inline">fetchText()</strong> suspending function and display the list, as follows:</p>
			<pre class="source-code">lifecycleScope.launch(Dispatchers.IO) {</pre>
			<pre class="source-code">    val fetchedText = fetchText()  </pre>
			<pre class="source-code">    withContext(Dispatchers.Main) {</pre>
			<pre class="source-code">      displayText(fetchedText)</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p><strong class="source-inline">lifecycleScope</strong> is the scope with which the coroutine will run. <strong class="source-inline">launch</strong> creates a coroutine to run in <strong class="source-inline">Dispatchers.IO</strong>, which is a thread for I/O or network operations.</p>
			<p>The <strong class="source-inline">fetchText()</strong> function will suspend the coroutine before it starts the network request. While the coroutine is suspended, the main thread can do other work.</p>
			<p>After getting the text, it will resume the coroutine. <strong class="source-inline">withContext(Dispatchers.Main)</strong> will switch the coroutine context to the main thread, where the <strong class="source-inline">displayText(text)</strong> function will be executed (<strong class="source-inline">Dispatchers.Main</strong>).</p>
			<p>In Android Studio, the <strong class="bold">Editor</strong> window identifies the <strong class="source-inline">suspend</strong> function calls in your code with a gutter icon next to the line number. As shown in lines <strong class="bold">13</strong> and <strong class="bold">15</strong> in <em class="italic">Figure 1.6</em>, the <strong class="source-inline">fetchText()</strong> and <strong class="source-inline">withContext()</strong> lines have the <strong class="source-inline">suspend</strong> function call gutter icon:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_1.06_B17773.jpg" alt="Figure 1.6 – Android Studio suspend function call gutter icon&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Android Studio suspend function call gutter icon</p>
			<p>You can<a id="_idIndexMarker048"/> learn <a id="_idIndexMarker049"/>more about Kotlin coroutines in <a href="B17773_02_Epub.xhtml#_idTextAnchor029"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Kotlin Coroutines</em>. </p>
			<p>In the next section, you will learn about Kotlin Flows, built on top of coroutines, which can return multiple sequences of values.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Kotlin Flows</h2>
			<p>Flow is a new Kotlin<a id="_idIndexMarker050"/> asynchronous stream library that is built on top of Kotlin coroutines. A flow <a id="_idIndexMarker051"/>can emit multiple values instead of a single value and over a period of time. Kotlin Flow is ideal to use when you need to return multiple values asynchronously, such as automatic updates from your data source. </p>
			<p>Flow is now used in Jetpack libraries such as Room-KTX and Android developers are already using Flow in their applications.</p>
			<p>To use<a id="_idIndexMarker052"/> Kotlin Flows in your Android project, you have to add coroutines. An easy way to create a flow of objects is to use the <strong class="source-inline">flow{}</strong> builder. With the <strong class="source-inline">flow{}</strong> builder function, you can add values to the stream by calling emit.</p>
			<p>Let’s say in your Android app you have a <strong class="source-inline">getTextFromNetwork</strong> function that fetches text from a network endpoint and returns it as a <strong class="source-inline">String</strong> object:</p>
			<pre class="source-code">fun getTextFromNetwork(): String { ... }</pre>
			<p>If we want to <a id="_idIndexMarker053"/>create a<a id="_idIndexMarker054"/> flow of each word of the text, we can do it with the following code:</p>
			<pre class="source-code">private fun getWords(): Flow&lt;String&gt; = flow {</pre>
			<pre class="source-code">  getTextFromNetwork().split(" ").forEach {</pre>
			<pre class="source-code">    delay(1_000)</pre>
			<pre class="source-code">    emit(it)</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Flow does not run or emit values until the flow is collected with any terminal operators, such as <strong class="source-inline">collect</strong>, <strong class="source-inline">launchIn</strong>, or <strong class="source-inline">single</strong>. You can use the <strong class="source-inline">collect()</strong> function to start the flow and process each value, as follows:</p>
			<pre class="source-code">private suspend fun displayWords() {</pre>
			<pre class="source-code">          getWords().collect {</pre>
			<pre class="source-code">          Log.d("flow", it)</pre>
			<pre class="source-code">           }</pre>
			<pre class="source-code">}</pre>
			<p>A visual representation of this flow is shown in the following figure:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.07_B17773.jpg" alt="Figure 1.7 – Kotlin Flow visual representation&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Kotlin Flow visual representation</p>
			<p>As you<a id="_idIndexMarker055"/> can <a id="_idIndexMarker056"/>see in <em class="italic">Figure 1.7</em>, as soon as the <strong class="source-inline">getWords()</strong> flow emits a string, the <strong class="source-inline">displayWords</strong> function collects the string and displays it immediately on the logs.</p>
			<p>You will learn more about Kotlin Flows in <a href="B17773_05_Epub.xhtml#_idTextAnchor062"><em class="italic">Chapter 5</em></a>, <em class="italic">Using Kotlin Flows</em>.</p>
			<p>In this section, you learned about Kotlin coroutines and flows, the recommended way to carry out asynchronous programming in Android. Coroutines is a Kotlin library for managing long-running tasks in the background. Flow is a new Kotlin asynchronous stream library, built on top of coroutines, that can emit multiple values over a period of time.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor027"/>Summary</h1>
			<p>In this chapter, you revisited the concept of asynchronous programming. We learned that asynchronous programming helps you execute long-running tasks in the background without freezing the app and annoying your users.</p>
			<p>You then learned about various ways you can do asynchronous programming in Android, including with threads, AsyncTask, and <strong class="source-inline">Executors</strong>. We also learned that they allow you to perform tasks in the background and update the main thread. AsyncTask is already deprecated, and threads and <strong class="source-inline">Executors</strong> are not the best ways to carry out asynchronous programming in Android.</p>
			<p>Finally, you were introduced to the new, recommended way to carry out asynchronous programming in Android: with Kotlin’s Coroutines and Flow. We learned that Coroutines is a Kotlin library that you can use to easily perform asynchronous, non-blocking, and long-running tasks in the background. Flow, built on top of Coroutines, allows you to handle functions that return multiple values over time.</p>
			<p>In the next chapter, you will dive deeper into Kotlin coroutines and learn how to use them in your Android project.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/>Further reading</h1>
			<p>This book assumes that you have experience and skills in Android development with Kotlin. If you would like to learn more about this, you can read the book <em class="italic">How to Build Android Apps with Kotlin</em> (<em class="italic">Packt Publishing, 2021, ISBN 9781838984113</em>).</p>
		</div>
	</body></html>