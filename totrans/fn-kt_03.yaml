- en: Immutability - It's Important
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性 - 它很重要
- en: So, we are in the third chapter of, *Functional Kotlin*. In this chapter, we
    are going to discuss immutability. Immutability is probably the most important
    aspect of functional programming; actually, not only in functional programming,
    but OOP also gives some room to nurture immutability with immutable objects. So,
    why is it so important? What does it mean? How can we implement immutability in
    Kotlin? Let's answer these questions in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在进入了《函数式 Kotlin》的第三章。在本章中，我们将讨论不可变性。不可变性可能是函数式编程最重要的方面；实际上，不仅在函数式编程中，面向对象编程也通过不可变对象为培养不可变性留出了一些空间。那么，为什么它如此重要？这意味着什么？我们如何在
    Kotlin 中实现不可变性？让我们在本章中回答这些问题。
- en: 'The following are the points we are going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中讨论的要点：
- en: What is immutability?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是不可变性？
- en: The advantages of immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性的优点
- en: How to implement immutability in Kotlin?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 中如何实现不可变性？
- en: Immutability in variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量中的不可变性
- en: '`val` versus `var`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val` 与 `var`'
- en: '`val` and `const val`—are they truly immutable?'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val` 和 `const val`——它们真的是不可变的吗？'
- en: Compiler optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器优化
- en: Immutable collections
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变集合
- en: The disadvantages of immutability
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性的缺点
- en: What is immutability?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是不可变性？
- en: Functional programming, by its nature, is thread safe; immutability has a great
    role in making it thread safe. If you go by the dictionary definition, **immutability**
    means that something is unchangeable. So, as per the dictionary, an **immutable
    variable** is a variable that cannot change. Now, how can that be of any help
    to thread safety?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程由于其本质是线程安全的；不可变性在使其线程安全方面起着重要作用。如果你按照词典的定义，**不可变性**意味着某物是不可改变的。所以，按照词典，一个**不可变变量**是一个不能改变的变量。那么，这如何有助于线程安全？
- en: 'The following example shows a simple class, with no extra protective measures
    for thread safety:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个简单的类，没有额外的线程安全保护措施：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Just think of a situation when you're calling this class from multiple threads
    at the same time. There is no guarantee of integrity in this, right?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下同时从多个线程调用这个类的情况。这里没有保证完整性，对吧？
- en: Now, imagine making `mutableProperty` immutable; the problem is partly solved,
    right?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设将 `mutableProperty` 变为不可变的；问题部分解决了，对吧？
- en: 'However, if you think of immutability as creating a class and making all its
    variables read-only, then such a simplified explanation would not only be wrong,
    but would also be horrible. Actually, immutability is not about forbidding change,
    but about handling change. Instead of changing the underlying value of a property
    directly, create a new property and copy the value with applied changes. This
    applies to things such as the primitive data types in Kotlin and Java (or even
    in C). For instance, in the following example, when we''re writing `var y = x.capitalize()`,
    the value of `x` remains unchanged, instead the `x` value is copied to `y` with
    applied changes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你认为不可变性就是创建一个类并使其所有变量为只读，那么这样的简化解释不仅错误，而且糟糕。实际上，不可变性不是关于禁止改变，而是关于处理改变。不是直接改变属性的底层值，而是创建一个新的属性，并应用更改后复制值。这适用于
    Kotlin 和 Java（甚至 C）中的原始数据类型。例如，在以下示例中，当我们编写 `var y = x.capitalize()` 时，`x` 的值保持不变，而是将应用更改后的
    `x` 值复制到 `y`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of the primitive types operate in the same way; that is what is called
    **immutability**. Now, let's see how can we implement immutability in Kotlin and
    then, we will have a look at its advantages and disadvantages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数原始类型都以相同的方式操作；这就是所谓的**不可变性**。现在，让我们看看如何在 Kotlin 中实现不可变性，然后我们将探讨其优点和缺点。
- en: Implementing immutability in Kotlin
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中实现不可变性
- en: Unlike Clojure, Haskell, F#, and the likes, Kotlin is not a pure functional
    programming language, where immutability is forced; rather, we may refer to Kotlin
    as a perfect blend of functional programming and OOP languages. It contains the
    major benefits of both worlds. So, instead of forcing immutability like pure functional
    programming languages, Kotlin encourages immutability, giving it automatic preference
    wherever possible.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Clojure、Haskell、F# 等语言不同，Kotlin 不是一个纯函数式编程语言，其中不可变性是强制性的；相反，我们可以将 Kotlin 称为函数式编程和面向对象语言完美融合的典范。它包含了两个世界的重大好处。因此，与纯函数式编程语言强制不可变性不同，Kotlin
    鼓励不可变性，并在可能的情况下自动优先考虑它。
- en: In other words, Kotlin has immutable variables (`val`), but no language mechanisms
    that would guarantee true deep immutability of the state. If a `val` variable
    references a mutable object, its contents can still be modified. We will have
    a more elaborate discussion and a deeper dive on this topic, but first let us
    have a look at how we can get referential immutability in Kotlin and the differences
    between `var`, `val`, and `const val`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Kotlin 有不可变变量（`val`），但没有保证状态真正深度不可变的语言机制。如果一个 `val` 变量引用了一个可变对象，其内容仍然可以被修改。我们将对此进行更详细的讨论和深入探讨，但首先让我们看看如何在
    Kotlin 中实现引用不可变性和 `var`、`val` 和 `const val` 之间的区别。
- en: By true deep immutability of the state, we mean a property will always return
    the same value whenever it is called and that the property never changes its value;
    we can easily avoid this if we have a `val`  property that has a custom getter.
    You can find more details at the following link: [https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/](https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过真正的状态深度不可变性，我们指的是一个属性在每次被调用时都会返回相同的值，并且该属性永远不会改变其值；如果我们有一个具有自定义获取器的 `val`
    属性，我们就可以轻松避免这种情况。更多详细信息，请参阅以下链接：[https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/](https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/)
- en: The difference between var and val
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`var` 和 `val` 的区别'
- en: So, in order to encourage immutability but still let the developers have the
    choice, Kotlin introduced two types of variables. The first one is `var`, which
    is just a simple variable, just like in any imperative language. On the other
    hand, `val` brings us a bit closer to immutability; again, it doesn't guarantee
    immutability. So, what exactly does the `val` variable provide us? It enforces
    read-only, you cannot write into a `val` variable after initialization. So, if
    you use a `val` variable without a custom getter, you can achieve referential
    immutability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了鼓励不可变性，同时仍然让开发者有选择权，Kotlin 引入了两种类型的变量。第一种是 `var`，它只是一个简单的变量，就像在任何命令式语言中一样。另一方面，`val`
    让我们更接近不可变性；再次强调，它并不保证不可变性。那么，`val` 变量究竟为我们提供了什么？它强制只读，初始化后你不能写入 `val` 变量。所以，如果你使用没有自定义获取器的
    `val` 变量，你可以实现引用不可变性。
- en: 'Let''s have a look; the following program will not compile:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看；以下程序将无法编译：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As I mentioned earlier, the preceding program will not compile; it will give
    an error on comment `(1)`. As we've declared variable `x` as `val`, `x` will be
    read-only and once we initialize `x`; we cannot modify it afterwards.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，前面的程序将无法编译；它将在注释 `(1)` 处产生错误。因为我们已将变量 `x` 声明为 `val`，所以 `x` 将是只读的，一旦我们初始化
    `x`，之后就不能修改它。
- en: 'So, now you''re probably asking why we cannot guarantee immutability with `val`
    ? Let''s inspect this with the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你现在可能想知道为什么我们不能用 `val` 保证不可变性？让我们通过以下示例来检查：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this program, we declared `myString` as a `val` property, but implemented
    a custom `get` function, where we tweaked the value of `myString` before returning
    it. Have a look at the output first, then we will further look into the program:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将 `myString` 声明为一个 `val` 属性，但实现了一个自定义的 `get` 函数，我们在返回之前修改了 `myString`
    的值。首先看看输出，然后我们将进一步查看程序：
- en: '![](img/252f866a-6301-4199-a212-ef1396d1f3a2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/252f866a-6301-4199-a212-ef1396d1f3a2.png)'
- en: As you can see, the `myString` property, despite being `val`, returned different
    values every time we accessed it. So, now, let us look into the code to understand
    such behavior.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管 `myString` 属性是 `val`，但它每次被访问时都返回不同的值。现在，让我们查看代码以了解这种行为。
- en: On comment `(1)`, we declared a custom getter for the `val` property `myString`.
    On comment `(2)`, we pre-incremented the value of `count` and added it after the
    value of the `field` value, `myString`, and returned the same from the getter.
    So, whenever we requested the `myString` property, `count` got incremented and,
    on the next request, we got a different value. As a result, we broke the immutable
    behavior of a `val` property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们为 `val` 属性 `myString` 声明了一个自定义获取器。在注释 `(2)` 中，我们预增加了 `count` 的值，并将其添加到
    `field` 值，即 `myString` 的值之后，并从获取器返回相同的值。所以，每次我们请求 `myString` 属性时，`count` 都会增加，在下一次请求时，我们得到不同的值。因此，我们破坏了
    `val` 属性的不可变行为。
- en: Compile time constants
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时常量
- en: So, how can we overcome this? How can we enforce immutability? The `const val`
    properties are here to help us. Just modify `val myString` with `const val myString`
    and you cannot implement the custom getter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何克服这个问题？如何强制不可变性？`const val`属性就是为了帮助我们而存在的。只需将`val myString`修改为`const
    val myString`，您就不能实现自定义获取器。
- en: 'While `val` properties are read-only variables, `const val` on the other hand
    are compile time constants. You cannot assign the outcome (result) of a function
    to `const val`. Let''s discuss some of the differences between `val` and `const val`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`val`属性是只读变量，但另一方面，`const val`是编译时常量。您不能将函数的结果（结果）分配给`const val`。让我们讨论一下`val`和`const
    val`之间的一些区别：
- en: The `val` properties are read-only variables, while `const val` are compile
    time constants
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`属性是只读变量，而`const val`是编译时常量'
- en: The `val` properties can have custom getters, but `const val` cannot
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val`属性可以有自定义获取器，但`const val`不能'
- en: We can have `val` properties anywhere in our Kotlin code, inside functions,
    as a class member, anywhere, but `const val` has to be a top-level member of a
    class/object
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在Kotlin代码的任何地方拥有`val`属性，在函数内部，作为类成员，任何地方，但`const val`必须是一个类/对象的顶层成员
- en: You cannot write delegates for the `const val` properties
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不能为`const val`属性编写委托
- en: We can have the `val` property of any type, be it our custom class or any primitive
    data type, but only primitive data types and `String` are allowed with a `const
    val` property
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以拥有任何类型的`val`属性，无论是我们的自定义类还是任何原始数据类型，但只有原始数据类型和`String`可以使用`const val`属性
- en: We cannot have nullable data types with the `const val` properties; as a result,
    we cannot have null values for the `const val` properties either
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在`const val`属性中使用可空数据类型；因此，`const val`属性也不能有null值
- en: As a result, the `const val` properties guarantee immutability of value, but
    have lesser flexibility and you are bound to use only primitive data types with
    `const val`, which cannot always serve our purposes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`const val`属性保证了值的不可变性，但灵活性较低，并且您必须仅使用原始数据类型与`const val`一起使用，这并不总是能满足我们的需求。
- en: Now, that I've used the word *referential immutability* quite a few times, let
    us now inspect what it means and how many types of immutability there are.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经多次使用了“引用不可变性”这个词，让我们现在检查它的含义以及有多少种不可变性类型。
- en: Types of immutability
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性的类型
- en: 'There are basically the following two types of immutability:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上有以下两种不可变性类型：
- en: Referential immutability
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用不可变性
- en: Immutable values
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变值
- en: Immutable reference  (referential immutability)
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变引用（引用不可变性）
- en: '**Referential immutability** enforces that, once a reference is assigned, it
    can''t be assigned to something else. Think of having it as a `val` property of
    a custom class, or even `MutableList` or `MutableMap`; after you initialize the
    property, you cannot reference something else from that property, except the underlying
    value from the object. For example, take the following program:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用不可变性**强制规定，一旦分配了引用，就不能将其分配给其他对象。想想看，就像它是一个自定义类的`val`属性，甚至是`MutableList`或`MutableMap`；初始化属性后，您不能从该属性引用其他对象，除非是对象的基本值。例如，考虑以下程序：'
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Have a look at the output before we proceed with explaining the program:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释程序之前，先看看输出结果：
- en: '![](img/23651ee2-2e8c-42e0-98f7-d2b7d2b64777.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23651ee2-2e8c-42e0-98f7-d2b7d2b64777.png)'
- en: So, in this program we've two `val` properties—`list` and `mutableObj`. We initialized
    `mutableObj` with the default constructor of `MutableObj`, since it's a `val`
    property it'll always refer to that specific object; but, if you concentrate on
    comment `(2)`, we changed the `value` property of `mutableObj`, as the `value`
    property of the `MutableObj` class is mutable (`var`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们有两个`val`属性——`list`和`mutableObj`。我们使用`MutableObj`的默认构造函数初始化`mutableObj`，因为它是一个`val`属性，它将始终引用那个特定的对象；但是，如果您关注注释（2），我们已经改变了`mutableObj`的`value`属性，因为`MutableObj`类的`value`属性是可变的（`var`）。
- en: It's the same with the `list` property, we can add items to the list after initialization,
    changing its underlying value. Both `list` and `mutableObj` are perfect examples
    of immutable reference; once initialized, the properties can't be assigned to
    something else, but their underlying values can be changed (you can refer the
    output). The reason behind that is the data type we used to assign to those properties.
    Both the `MutableObj` class and the `MutableList<String>` data structures are
    mutable themselves, so we cannot restrict value changes for their instances.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `list` 属性类似，我们可以在初始化后向列表中添加项目，改变其底层值。`list` 和 `mutableObj` 都是不可变引用的完美例子；一旦初始化，属性就不能被分配给其他东西，但它们的底层值可以改变（你可以参考输出）。背后的原因是分配给这些属性的
    数据类型。`MutableObj` 类和 `MutableList<String>` 数据结构本身都是可变的，因此我们无法限制其实例的值变化。
- en: Immutable values
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变值
- en: The **immutable values**, on the other hand, enforce no change on values as
    well; it is really complex to maintain. In Kotlin, the `const val` properties
    enforces immutability of value, but they lack flexibility (we already discussed
    them) and you're bound to use only primitive types, which can be troublesome in
    real-life scenarios.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**不可变值**同样不允许对值进行更改；维护起来非常复杂。在 Kotlin 中，`const val` 属性强制值的不可变性，但它们缺乏灵活性（我们已讨论过它们）并且你只能使用原始类型，这在实际场景中可能会带来麻烦。
- en: Immutable collections
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: Kotlin gives preference to immutability wherever possible, but leaves the choice
    to the developer whether or when to use it. This power of choice makes the language
    even more powerful. Unlike most languages, where they have either only mutable
    (like Java, C#, and so on) or only immutable collections (like F#, Haskell, Clojure,
    and so on), Kotlin has both and distinguishes between them, leaving the developer
    with the freedom to choose whether to use an immutable or mutable one.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 在可能的情况下会优先考虑不可变性，但将选择权留给开发者，决定是否以及何时使用它。这种选择权使语言更加强大。与大多数语言不同，它们要么只有可变集合（如
    Java、C# 等），要么只有不可变集合（如 F#、Haskell、Clojure 等），Kotlin 两者都有，并且区分它们，让开发者有选择使用不可变或可变集合的自由。
- en: 'Kotlin has two interfaces for collection objects—`Collection<out E>` and `MutableCollection<out
    E>`; all the collection classes (for example, `List`, `Set`, or `Map`) implement
    either of them. As the name suggests, the two interfaces are designed to serve
    immutable and mutable collections respectively. Let us have an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 为集合对象提供了两个接口——`Collection<out E>` 和 `MutableCollection<out E>`；所有集合类（例如
    `List`、`Set` 或 `Map`）都实现了这两个接口之一。正如其名所示，这两个接口是为不可变和可变集合分别设计的。让我们举一个例子：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d50cd60d-e688-4025-9783-28ae0ed4a38f.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d50cd60d-e688-4025-9783-28ae0ed4a38f.png)'
- en: So, in this program, we created an immutable list with the help of the `listOf`
    method of Kotlin, on comment `(1)`. The `listOf` method creates an immutable list
    with the elements (`varargs`) passed to it. This method also has a generic type
    parameter, which can be skipped if the elements array is not empty. The `listOf`
    method also has a mutable version—`mutableListOf()` which is identical except
    that it returns `MutableList` instead. We can convert an immutable list to a mutable
    one with the help of the `toMutableList()` extension function, we did the same
    in comment `(2)`, to add an element to it on comment `(3)`. However, if you check
    the output, the original `Immutable List` remains the same without any changes,
    the item is, however, added to the newly created `MutableList` instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们通过 Kotlin 的 `listOf` 方法创建了一个不可变列表，注释（1）中提到。`listOf` 方法使用传递给它的元素（可变参数）创建一个不可变列表。此方法还有一个泛型类型参数，如果元素数组不为空，则可以省略。`listOf`
    方法还有一个可变版本——`mutableListOf()`，除了返回 `MutableList` 而外，其余都相同。我们可以使用 `toMutableList()`
    扩展函数将不可变列表转换为可变列表，注释（2）中我们就是这样做的，以便在注释（3）中向其添加一个元素。然而，如果你检查输出，原始的 `Immutable List`
    没有任何变化，而项目已经被添加到了新创建的 `MutableList` 中。
- en: The advantages of immutability
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性的优势
- en: 'We''ve mentioned several times that immutability brings safety along with it.
    But that''s not all; the following is a brief list of advantages that immutability
    brings with it, we will discuss them one by one:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到，不可变性带来了安全性，但这并非全部；以下是一个简短的列表，列出了不可变性带来的优势，我们将逐一讨论：
- en: Thread safety
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程安全
- en: Low coupling
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低耦合
- en: Referential transparency
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用透明性
- en: Failure atomicity
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败原子性
- en: Compiler optimization
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器优化
- en: Pure functions
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯函数
- en: Let us now discuss each of the advantages to understand them better.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论这些优点，以便更好地理解它们。
- en: Thread safety
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程安全
- en: We have probably seen a thousand times that immutability brings thread safety
    to the table along with it. What does it actually mean and how does immutability
    achieve thread safety? Working with multiple threads is itself a complex job.
    When you are accessing a class from multiple threads, you need to ensure certain
    things, like locking and releasing of the object and synchronization, but none
    of them are required if you are accessing any immutable data from multiple threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经看到过一千次不可变性如何带来线程安全。这实际上意味着什么？不可变性是如何实现线程安全的？与多个线程一起工作本身就是一项复杂的工作。当你从多个线程访问一个类时，你需要确保某些事情，比如锁定和释放对象以及同步，但如果你从多个线程访问任何不可变数据，则不需要这些。
- en: 'Confused? Let''s have an example with threads and mutable data:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我们用一个关于线程和可变数据的例子来说明：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this program, we''ve used two coroutines (we will cover coroutines in detail
    in [Chapter 7](cf296fd7-ee56-4fac-8078-c97779111daf.xhtml), *Asynchronous Processing
    with Coroutines*) which works on the same mutable data. Let''s have a look in
    the following output and then we will describe and discuss the problems in this
    program:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了两个协程（我们将在第7章中详细讨论协程，*使用协程的异步处理*），它们在相同的数据上工作。让我们看看以下输出，然后我们将描述和讨论这个程序中的问题：
- en: '![](img/b7855232-3fee-4080-b075-5a30ee5b2071.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7855232-3fee-4080-b075-5a30ee5b2071.png)'
- en: So, look closely at the output. As both the coroutines works simultaneously
    on `myData.someData`, data consistency is not ensured in either one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仔细观察输出。由于两个协程同时在工作`myData.someData`上，数据一致性在任何一个中都没有得到保证。
- en: The traditional solution to this problem is to use locking-releasing techniques
    and synchronization, but then also you'll need to write a lot of code for that
    and to avoid deadlock while implementing locking and releasing of data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的传统方法是使用锁定-释放技术和同步，但这样你也需要为它编写大量的代码，并且为了避免在实现锁定和释放数据时出现死锁。
- en: 'Functional programming provides a one-stop solution to this problem through
    immutability. Let''s have a look how immutability and local variables can save
    you in multithreading:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程通过不可变性提供了一个一站式解决方案来解决这个问题。让我们看看不可变性和局部变量如何在多线程中拯救你：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've modified the previous program to make `someData` immutable (as we're not
    using custom getter with this variable, so it will remain immutable) and used
    local variables inside both the coroutines.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了之前的程序，将`someData`设置为不可变（因为我们不使用这个变量的自定义获取器，所以它将保持不可变）并在两个协程内部使用了局部变量。
- en: 'Have a look at the following output; it clearly shows that the problem is solved:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下输出；它清楚地表明问题已解决：
- en: '![](img/5e4db5ac-0ef5-4026-8ca3-57d4b2519242.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e4db5ac-0ef5-4026-8ca3-57d4b2519242.png)'
- en: Low coupling
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低耦合
- en: 'The code dependency between threads is referred to as coupling. We should try
    to keep coupling as low as possible, to avoid complexity and make the code base
    easy to read and maintain. Now, what does that actually mean? Refer to the program
    with threading where we accessed and modified the `someData` value from two threads
    simultaneously. That can be called **coupling**, as both the threads were dependent
    on each other. For your reference, we copied the following code-snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 线程之间的代码依赖性被称为耦合。我们应该尽量降低耦合度，以避免复杂性并使代码库易于阅读和维护。现在，这实际上意味着什么？请参考我们访问和修改`someData`值的程序，该程序使用了线程。这可以被称为**耦合**，因为两个线程都相互依赖。为了您的参考，我们复制了以下代码片段：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the next program, where we introduced immutability, the coupling is reduced.
    Here, both the threads were reading the same element, but one thread's operations
    and changes didn't affect the other one.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个程序中，我们引入了不可变性，耦合度降低了。在这里，两个线程都在读取相同的元素，但一个线程的操作和更改没有影响到另一个线程。
- en: Referential transparency
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用透明性
- en: The concept of **referential transparency** says that, an expression always
    evaluates to the same value, irrespective of context or any other variance. To
    be more specific, you can replace a function with its return value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用透明性**的概念表明，一个表达式总是评估为相同的值，无论上下文或任何其他变化。更具体地说，你可以用一个函数的返回值来替换该函数。'
- en: Immutability, with help of pure functions, can establish referential transparency.
    Referential transparency strongly denies the mutable state of data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过纯函数的帮助，不可变性可以建立引用透明性。引用透明性强烈否认数据的可变状态。
- en: Failure atomicity
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 失败原子性
- en: In traditional programming, failure in one thread can easily affect the other
    one. As immutability enforces low coupling, the internal state of the application
    will be consistent, even when we have exceptions on any module/thread.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统编程中，一个线程的失败很容易影响另一个线程。由于不可变性强制低耦合，即使我们在任何模块/线程上有异常，应用程序的内部状态也将保持一致。
- en: The reason is simple, the immutable objects never change state. So, even if
    failure occurs in one part/module/thread, it stops right there and doesn't get
    any chance to get spread to other parts of the application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单，不可变对象永远不会改变状态。因此，即使某个部分/模块/线程发生故障，它就会停止，并且没有机会传播到应用程序的其他部分。
- en: Caching
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'As immutable objects are not going to change, they can be easily cached to
    improve performance. Thus, you can easily avoid making multiple calls to the same
    function/variable and, instead, cache it locally and save an ample amount of processing
    time. The following are some of the advantages of caching:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可变对象不会改变，它们可以很容易地缓存以提高性能。因此，你可以轻松避免对同一函数/变量进行多次调用，而是将其本地缓存，从而节省大量处理时间。以下是一些缓存的优势：
- en: It reduces the overhead from server resources
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了服务器资源的开销
- en: It increases the performance of the application by serving it with the cached
    output
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供缓存的输出，它提高了应用程序的性能
- en: It decreases CPU round trips for fetching data from the database by persisting
    data in the memory
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在内存中持久化数据，它减少了从数据库获取数据的 CPU 循环次数
- en: It increases reliability
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了可靠性
- en: Compiler optimization
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器优化
- en: Immutability and referential transparency help compilers to perform extensive
    optimizations, replacing the need of manual optimization of code and free programmers
    from this trade-off.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性和引用透明性有助于编译器执行广泛的优化，取代了手动优化代码的需要，并使程序员从这种权衡中解脱出来。
- en: For example, this applies when you're using compile time constants (`const val`),
    as the compiler knows that the value of those variables will never change.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当你使用编译时常量（`const val`）时，这适用，因为编译器知道这些变量的值永远不会改变。
- en: Pure functions
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: Probably the biggest gift we can get by using immutability are the *pure functions*
    (covered in the next chapter). Basically, pure functions and immutability are
    not only companions, but are complimentary to each other.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不可变性，我们可能得到的最大礼物是*纯函数*（下一章将介绍）。基本上，纯函数和不可变性不仅是伴侣，而且是互补的。
- en: We cannot implement pure functions without immutability and immutability isn't
    complete without pure functions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有不可变性，我们无法实现纯函数，而没有纯函数，不可变性也不完整。
- en: 'So, as we''ve learned a lot about immutability and its advantages, let us now
    focus on the other side: the disadvantages of immutability and check if they truly
    are disadvantages.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经了解了不可变性和其优点，那么现在让我们关注另一方面：不可变性的缺点，并检查它们是否真的是缺点。
- en: The disadvantages of immutability
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性的缺点
- en: Nothing in the world comes only with advantages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上没有只带来好处的东西。
- en: 'There''s a great proverb: everything comes at its own price.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个伟大的谚语：一切皆有其价。
- en: The only thing you can hear against immutability is that you need to create
    a new object every time you want to modify it. That's true in some scenarios,
    especially where you're working with large sets of objects. However, when you
    are working with small datasets or objects, it doesn't have any effect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你能听到的唯一反对不可变性的说法是，每次你想修改它时都需要创建一个新的对象。在某些情况下这是真的，尤其是在你处理大量对象时。然而，当你处理小数据集或对象时，它没有任何影响。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about immutability and how to implement immutability
    with Kotlin. We learned that Kotlin provides us with the freedom to choose between
    immutability or mutable objects, based on our requirements. We not only discussed
    the advantages of immutability, but talked about its limitations as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了不可变性和如何使用 Kotlin 实现不可变性。我们了解到 Kotlin 为我们提供了根据需求选择不可变对象或可变对象的自由。我们不仅讨论了不可变性的优点，还讨论了其局限性。
- en: The next chapter focuses on function, function types, and side effects. We will
    also learn about pure functions, which are not only a companion but a complimentary
    part of immutability, in the next chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍函数、函数类型和副作用。我们还将学习纯函数，它们不仅是不可变性的伴侣，而且是不可变性的补充部分，将在下一章中介绍。
- en: So what are you waiting for? Turn the page right now.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那你还在等什么？现在就翻页吧。
