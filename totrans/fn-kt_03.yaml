- en: Immutability - It's Important
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we are in the third chapter of, *Functional Kotlin*. In this chapter, we
    are going to discuss immutability. Immutability is probably the most important
    aspect of functional programming; actually, not only in functional programming,
    but OOP also gives some room to nurture immutability with immutable objects. So,
    why is it so important? What does it mean? How can we implement immutability in
    Kotlin? Let's answer these questions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the points we are going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is immutability?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The advantages of immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement immutability in Kotlin?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutability in variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val` versus `var`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`val` and `const val`—are they truly immutable?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantages of immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is immutability?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming, by its nature, is thread safe; immutability has a great
    role in making it thread safe. If you go by the dictionary definition, **immutability**
    means that something is unchangeable. So, as per the dictionary, an **immutable
    variable** is a variable that cannot change. Now, how can that be of any help
    to thread safety?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a simple class, with no extra protective measures
    for thread safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just think of a situation when you're calling this class from multiple threads
    at the same time. There is no guarantee of integrity in this, right?
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine making `mutableProperty` immutable; the problem is partly solved,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you think of immutability as creating a class and making all its
    variables read-only, then such a simplified explanation would not only be wrong,
    but would also be horrible. Actually, immutability is not about forbidding change,
    but about handling change. Instead of changing the underlying value of a property
    directly, create a new property and copy the value with applied changes. This
    applies to things such as the primitive data types in Kotlin and Java (or even
    in C). For instance, in the following example, when we''re writing `var y = x.capitalize()`,
    the value of `x` remains unchanged, instead the `x` value is copied to `y` with
    applied changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Most of the primitive types operate in the same way; that is what is called
    **immutability**. Now, let's see how can we implement immutability in Kotlin and
    then, we will have a look at its advantages and disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing immutability in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike Clojure, Haskell, F#, and the likes, Kotlin is not a pure functional
    programming language, where immutability is forced; rather, we may refer to Kotlin
    as a perfect blend of functional programming and OOP languages. It contains the
    major benefits of both worlds. So, instead of forcing immutability like pure functional
    programming languages, Kotlin encourages immutability, giving it automatic preference
    wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Kotlin has immutable variables (`val`), but no language mechanisms
    that would guarantee true deep immutability of the state. If a `val` variable
    references a mutable object, its contents can still be modified. We will have
    a more elaborate discussion and a deeper dive on this topic, but first let us
    have a look at how we can get referential immutability in Kotlin and the differences
    between `var`, `val`, and `const val`.
  prefs: []
  type: TYPE_NORMAL
- en: By true deep immutability of the state, we mean a property will always return
    the same value whenever it is called and that the property never changes its value;
    we can easily avoid this if we have a `val`  property that has a custom getter.
    You can find more details at the following link: [https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/](https://artemzin.com/blog/kotlin-val-does-not-mean-immutable-it-just-means-readonly-yeah/)
  prefs: []
  type: TYPE_NORMAL
- en: The difference between var and val
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, in order to encourage immutability but still let the developers have the
    choice, Kotlin introduced two types of variables. The first one is `var`, which
    is just a simple variable, just like in any imperative language. On the other
    hand, `val` brings us a bit closer to immutability; again, it doesn't guarantee
    immutability. So, what exactly does the `val` variable provide us? It enforces
    read-only, you cannot write into a `val` variable after initialization. So, if
    you use a `val` variable without a custom getter, you can achieve referential
    immutability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look; the following program will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned earlier, the preceding program will not compile; it will give
    an error on comment `(1)`. As we've declared variable `x` as `val`, `x` will be
    read-only and once we initialize `x`; we cannot modify it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now you''re probably asking why we cannot guarantee immutability with `val`
    ? Let''s inspect this with the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we declared `myString` as a `val` property, but implemented
    a custom `get` function, where we tweaked the value of `myString` before returning
    it. Have a look at the output first, then we will further look into the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/252f866a-6301-4199-a212-ef1396d1f3a2.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the `myString` property, despite being `val`, returned different
    values every time we accessed it. So, now, let us look into the code to understand
    such behavior.
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(1)`, we declared a custom getter for the `val` property `myString`.
    On comment `(2)`, we pre-incremented the value of `count` and added it after the
    value of the `field` value, `myString`, and returned the same from the getter.
    So, whenever we requested the `myString` property, `count` got incremented and,
    on the next request, we got a different value. As a result, we broke the immutable
    behavior of a `val` property.
  prefs: []
  type: TYPE_NORMAL
- en: Compile time constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, how can we overcome this? How can we enforce immutability? The `const val`
    properties are here to help us. Just modify `val myString` with `const val myString`
    and you cannot implement the custom getter.
  prefs: []
  type: TYPE_NORMAL
- en: 'While `val` properties are read-only variables, `const val` on the other hand
    are compile time constants. You cannot assign the outcome (result) of a function
    to `const val`. Let''s discuss some of the differences between `val` and `const val`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `val` properties are read-only variables, while `const val` are compile
    time constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `val` properties can have custom getters, but `const val` cannot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can have `val` properties anywhere in our Kotlin code, inside functions,
    as a class member, anywhere, but `const val` has to be a top-level member of a
    class/object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot write delegates for the `const val` properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can have the `val` property of any type, be it our custom class or any primitive
    data type, but only primitive data types and `String` are allowed with a `const
    val` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot have nullable data types with the `const val` properties; as a result,
    we cannot have null values for the `const val` properties either
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, the `const val` properties guarantee immutability of value, but
    have lesser flexibility and you are bound to use only primitive data types with
    `const val`, which cannot always serve our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that I've used the word *referential immutability* quite a few times, let
    us now inspect what it means and how many types of immutability there are.
  prefs: []
  type: TYPE_NORMAL
- en: Types of immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are basically the following two types of immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: Referential immutability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable reference  (referential immutability)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Referential immutability** enforces that, once a reference is assigned, it
    can''t be assigned to something else. Think of having it as a `val` property of
    a custom class, or even `MutableList` or `MutableMap`; after you initialize the
    property, you cannot reference something else from that property, except the underlying
    value from the object. For example, take the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the output before we proceed with explaining the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23651ee2-2e8c-42e0-98f7-d2b7d2b64777.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in this program we've two `val` properties—`list` and `mutableObj`. We initialized
    `mutableObj` with the default constructor of `MutableObj`, since it's a `val`
    property it'll always refer to that specific object; but, if you concentrate on
    comment `(2)`, we changed the `value` property of `mutableObj`, as the `value`
    property of the `MutableObj` class is mutable (`var`).
  prefs: []
  type: TYPE_NORMAL
- en: It's the same with the `list` property, we can add items to the list after initialization,
    changing its underlying value. Both `list` and `mutableObj` are perfect examples
    of immutable reference; once initialized, the properties can't be assigned to
    something else, but their underlying values can be changed (you can refer the
    output). The reason behind that is the data type we used to assign to those properties.
    Both the `MutableObj` class and the `MutableList<String>` data structures are
    mutable themselves, so we cannot restrict value changes for their instances.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **immutable values**, on the other hand, enforce no change on values as
    well; it is really complex to maintain. In Kotlin, the `const val` properties
    enforces immutability of value, but they lack flexibility (we already discussed
    them) and you're bound to use only primitive types, which can be troublesome in
    real-life scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin gives preference to immutability wherever possible, but leaves the choice
    to the developer whether or when to use it. This power of choice makes the language
    even more powerful. Unlike most languages, where they have either only mutable
    (like Java, C#, and so on) or only immutable collections (like F#, Haskell, Clojure,
    and so on), Kotlin has both and distinguishes between them, leaving the developer
    with the freedom to choose whether to use an immutable or mutable one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin has two interfaces for collection objects—`Collection<out E>` and `MutableCollection<out
    E>`; all the collection classes (for example, `List`, `Set`, or `Map`) implement
    either of them. As the name suggests, the two interfaces are designed to serve
    immutable and mutable collections respectively. Let us have an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d50cd60d-e688-4025-9783-28ae0ed4a38f.png)'
  prefs: []
  type: TYPE_IMG
- en: So, in this program, we created an immutable list with the help of the `listOf`
    method of Kotlin, on comment `(1)`. The `listOf` method creates an immutable list
    with the elements (`varargs`) passed to it. This method also has a generic type
    parameter, which can be skipped if the elements array is not empty. The `listOf`
    method also has a mutable version—`mutableListOf()` which is identical except
    that it returns `MutableList` instead. We can convert an immutable list to a mutable
    one with the help of the `toMutableList()` extension function, we did the same
    in comment `(2)`, to add an element to it on comment `(3)`. However, if you check
    the output, the original `Immutable List` remains the same without any changes,
    the item is, however, added to the newly created `MutableList` instead.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve mentioned several times that immutability brings safety along with it.
    But that''s not all; the following is a brief list of advantages that immutability
    brings with it, we will discuss them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure atomicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us now discuss each of the advantages to understand them better.
  prefs: []
  type: TYPE_NORMAL
- en: Thread safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have probably seen a thousand times that immutability brings thread safety
    to the table along with it. What does it actually mean and how does immutability
    achieve thread safety? Working with multiple threads is itself a complex job.
    When you are accessing a class from multiple threads, you need to ensure certain
    things, like locking and releasing of the object and synchronization, but none
    of them are required if you are accessing any immutable data from multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? Let''s have an example with threads and mutable data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we''ve used two coroutines (we will cover coroutines in detail
    in [Chapter 7](cf296fd7-ee56-4fac-8078-c97779111daf.xhtml), *Asynchronous Processing
    with Coroutines*) which works on the same mutable data. Let''s have a look in
    the following output and then we will describe and discuss the problems in this
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7855232-3fee-4080-b075-5a30ee5b2071.png)'
  prefs: []
  type: TYPE_IMG
- en: So, look closely at the output. As both the coroutines works simultaneously
    on `myData.someData`, data consistency is not ensured in either one.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional solution to this problem is to use locking-releasing techniques
    and synchronization, but then also you'll need to write a lot of code for that
    and to avoid deadlock while implementing locking and releasing of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functional programming provides a one-stop solution to this problem through
    immutability. Let''s have a look how immutability and local variables can save
    you in multithreading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've modified the previous program to make `someData` immutable (as we're not
    using custom getter with this variable, so it will remain immutable) and used
    local variables inside both the coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following output; it clearly shows that the problem is solved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e4db5ac-0ef5-4026-8ca3-57d4b2519242.png)'
  prefs: []
  type: TYPE_IMG
- en: Low coupling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code dependency between threads is referred to as coupling. We should try
    to keep coupling as low as possible, to avoid complexity and make the code base
    easy to read and maintain. Now, what does that actually mean? Refer to the program
    with threading where we accessed and modified the `someData` value from two threads
    simultaneously. That can be called **coupling**, as both the threads were dependent
    on each other. For your reference, we copied the following code-snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the next program, where we introduced immutability, the coupling is reduced.
    Here, both the threads were reading the same element, but one thread's operations
    and changes didn't affect the other one.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of **referential transparency** says that, an expression always
    evaluates to the same value, irrespective of context or any other variance. To
    be more specific, you can replace a function with its return value.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability, with help of pure functions, can establish referential transparency.
    Referential transparency strongly denies the mutable state of data.
  prefs: []
  type: TYPE_NORMAL
- en: Failure atomicity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional programming, failure in one thread can easily affect the other
    one. As immutability enforces low coupling, the internal state of the application
    will be consistent, even when we have exceptions on any module/thread.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is simple, the immutable objects never change state. So, even if
    failure occurs in one part/module/thread, it stops right there and doesn't get
    any chance to get spread to other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As immutable objects are not going to change, they can be easily cached to
    improve performance. Thus, you can easily avoid making multiple calls to the same
    function/variable and, instead, cache it locally and save an ample amount of processing
    time. The following are some of the advantages of caching:'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces the overhead from server resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases the performance of the application by serving it with the cached
    output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It decreases CPU round trips for fetching data from the database by persisting
    data in the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It increases reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Immutability and referential transparency help compilers to perform extensive
    optimizations, replacing the need of manual optimization of code and free programmers
    from this trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: For example, this applies when you're using compile time constants (`const val`),
    as the compiler knows that the value of those variables will never change.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the biggest gift we can get by using immutability are the *pure functions*
    (covered in the next chapter). Basically, pure functions and immutability are
    not only companions, but are complimentary to each other.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot implement pure functions without immutability and immutability isn't
    complete without pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as we''ve learned a lot about immutability and its advantages, let us now
    focus on the other side: the disadvantages of immutability and check if they truly
    are disadvantages.'
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantages of immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing in the world comes only with advantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a great proverb: everything comes at its own price.'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing you can hear against immutability is that you need to create
    a new object every time you want to modify it. That's true in some scenarios,
    especially where you're working with large sets of objects. However, when you
    are working with small datasets or objects, it doesn't have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about immutability and how to implement immutability
    with Kotlin. We learned that Kotlin provides us with the freedom to choose between
    immutability or mutable objects, based on our requirements. We not only discussed
    the advantages of immutability, but talked about its limitations as well.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter focuses on function, function types, and side effects. We will
    also learn about pure functions, which are not only a companion but a complimentary
    part of immutability, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So what are you waiting for? Turn the page right now.
  prefs: []
  type: TYPE_NORMAL
