- en: Chapter 6. Map, Filter, and Reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we briefly touched on the `map` function as an example
    of built-in higher-order functions. In this chapter, we will explore this topic
    further and get familiar with `map`, `flatMap`, `filter`, and `reduce` functions
    in Swift with examples. We will also get familiar with the category theory concepts
    such as Monad, Functor, and Applicative Functor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics with coding examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applicative Functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FlatMap and flatten
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Join
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections are used everywhere in our day-to-day development, and to be able
    to use collections declaratively, we need means such as `map`, `filter`, and `reduce`.
    Before going through these functions that are built-in into Swift, let's explore
    the theoretical background of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of Functor comes from the category theory. In the category theory,
    a Functor contains morphisms such as a `map` function, which transforms the Functor.
    We can think about a Functor as a functional design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the category theory is great but we do not have to, so simply put, a
    Functor is a structure that we can map over. In other words, a Functor is any
    type that implements the `map` function. Examples of Functors are `Dictionary`,
    `Array`, `Optional`, and `Closure` types. Whenever we talk about Functors, the
    first thing that comes to our mind is that we can call the `map` function over
    them and transform them.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike its name, the concept is very simple. We will talk about the `map` function
    in more detail in the upcoming sections and explore the usage of Functors.
  prefs: []
  type: TYPE_NORMAL
- en: Applicative Functor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of Applicative Functor also comes from the category theory and we can
    think of an **Applicative Functor** as a functional design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: An Applicative Functor is a Functor equipped with a function that takes a value
    to an instance of a Functor containing that value. Applicative Functors provide
    us the ability to operate on not just values, but values in a functorial context,
    such as optionals, without needing to unwrap or `map` over their contents.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we have an optional Functor (an optional that has the `map`
    function). We cannot directly apply the `map` function on optionals as we need
    to unwrap them first. Applicative Functors come to the rescue. They add a new
    function, for instance, `apply` to the Functor to make it possible to apply `map`
    on the Functor. Again, unlike its name, the concept is simple; we will talk about
    the `apply` function in an upcoming section.
  prefs: []
  type: TYPE_NORMAL
- en: Monad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of Monad comes from the category theory too and again we can think
    of a Monad as a functional design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: A Monad is a type of Functor, a type which, along with `map`, implements the
    `flatMap` function. It is simple, right? We have a Functor with an extra functionality
    and that's the `flatMap` implementation. So, any type that we can call `map` and
    `flatMap` functions over are Monads. In the following sections, we will talk about
    `map` and `flatMap` functions.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we learned that Functors are structures with `map` functions. Applicative
    Functors are Functors with `apply` functions and Monads are Functors with `flatMap`
    functions. Now, let's talk about these important functions.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift has a built-in higher-order function named `map` that can be used with
    collection types such as arrays. The `map` function solves the problem of transforming
    the elements of an array using a function. The following example presents two
    different approaches to transform a set of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first approach to solve the problem is imperative and uses for-in loops
    to go through the collection and transform each element in the array. This iteration
    technique is known as external iteration because we specify how to iterate. It
    requires us to explicitly access the elements sequentially from beginning to end.
    Also, it is required to create a variable that is mutated repeatedly while the
    task is performed in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: This process is error prone as we could initialize `formattedNumbers` incorrectly.
    Instead of the external iteration technique, we can use the internal iteration
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: Without specifying how to iterate through the elements or declare and use any
    mutable variables, Swift can determine how to access all the elements to perform
    the task and hide the details from us. This technique is known as internal iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the internal iteration methods is the `map` method. The `map` method
    elegantly simplifies our code and makes it declarative. Let''s examine the second
    approach using the `map` function this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As seen in this example, we could achieve the same result in one line of code.
    One of the benefits of using `map` is that we can clearly declare the transformation
    that we are trying to apply to the list of elements. The `map` function allows
    us to declare what we want to achieve rather than how it is implemented. This
    makes reading and reasoning about our code simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The `map` function can be applied to any container type that wraps a value or
    multiple values inside itself. Any container that provides the `map` function
    becomes the Functor, as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: We know what the benefits of the `map` function/method usage are and how it
    is used. Let's explore the dynamics of it and create a `map` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. Generics and Associated Type Protocols")
    , *Generics and Associated Type Protocols*, we had the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calculate` function could take `a`, `b`, `funcA`, and `funcB` as parameters.
    Let''s simplify this function with only two parameters and change the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `calculate` function takes `a` of type `T` and `funcA` that transforms
    `T` into `U`. The `calculate` function returns `U`. Even though this function
    does not work on arrays, it would be easy to add the array transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have a `calculate` function that takes an array of the generic type
    `T` and a function that transforms an array of `T` into an array of `U` and finally
    returns the transformed array of `U`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By just changing the name of the function and parameters, we can make this
    even more generic. So let''s change the function and parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a half-baked `map` function that takes an array of `T`
    and applies the `transform` function to it to return a transformed array of `U`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, this function does nothing and mapping happens in the transform. Let''s
    make this function usable and more understandable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, our `map` function takes an array of elements (domain in the category theory),
    iterates through each element in array, transforms it, and appends it to a new
    array (codomain in the category theory).
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be another array of the `ElementResult` type, which has in
    fact transformed elements of the input array. Let''s test this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `[12, 32, 93, 52, 102, 41, 76]`.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows us that with higher-order functions and generics, we are
    able to define functions such as `map` that are already a part of the Swift language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s examine the `map` function provided in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This definition is very similar to our implementation with some differences
    that we will cover here.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, this is a method that can be called on collections such as an
    array, so we do not need any input type such as `[ElementInput]`.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, `@noescape` is an attribute in Swift that is used to communicate to
    the function user that the argument will not live longer than the call. In escape
    scenarios, if the function dispatches to a different thread, an argument may be
    captured so that it will exist at a later time when its needed. The `@noescape`
    attribute ensures that this will not happen for this function.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `transform` is the name of the parameter. The type of the parameter
    is declared as `(Self.Generator.Element) -> T`. This is a closure that takes an
    argument of the `Self.Generator.Element` type and returns an instance of the `T`
    type. The `Self.Generator.Element` type is the same type of object as the type
    contained in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: FlatMap and flatten
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `flatMap` method on arrays can be used to flatten one level of dimension
    of an array. The following example presents a two-dimensional array, in other
    words, nested arrays. Calling `flatMap` on this array reduces one dimension and
    flattens it so the resulting array becomes `[1, 3, 5, 2, 4, 6]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `flatMap` returns an `Array` containing the concatenated results
    of the mapping transform over itself. We can achieve the same result by calling
    flatten on our array and then map, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to transform each element into an array, we will need to provide
    a `map` method as the closure to the `flatMap` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `[3, 5, 7, 4, 6, 8]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same result can be achieved with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine another example with an `Array` of three dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The resulting array will be `[1, [3, 5], 2, [4, 6]]`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, `flatMap` and `flatten` only flatten one dimension, and to handle
    more dimensions and transformations, we need to call the `flatMap` and `map` methods
    multiple times accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We also know that `twoDimensionalArray` and `threeDimensionalArray` are Monads,
    as we could call `map` and `flatMap` on them.
  prefs: []
  type: TYPE_NORMAL
- en: Filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `filter` function takes a function that, given an element in `Array`, returns
    `Bool` indicating whether the element should be included in the resulting `Array`.
    The `filter` method is declared as follows in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition is similar to the `map` method with the following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The `filter` function takes a closure that receives elements of itself and returns
    a `Bool` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The result of the `filter` method will be an array of its own type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s examine the following code to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The resulting `evenNumbers` array will be `[10, 30, 50, 100, 74]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `filter` function ourselves. In fact, its implementation
    is going to be similar to the implementation of `map`, except that it does not
    require a second generic specifying the codomain. Instead, it conditionally adds
    the original elements to the new `Array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter` function iterates through each element in our `Array` and applies
    the predicate to it. If the result of the predicate function becomes `true`, then
    `element` is added to our new `Array`. We can test our `filter` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The resulting array will be `[10, 30, 50, 100, 74]`, which is identical to the
    Swift-provided `filter` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reduce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reduce` function reduces a list into a single value. Often referred to
    as `fold` or `aggregate`, it takes two parameters: a starting value and a function.'
  prefs: []
  type: TYPE_NORMAL
- en: A function takes a running total and an element of the list as parameters and
    returns a value that is created by combining the elements in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `map`, `filter`, and `flatMap`, which would return the same type, `reduce`
    changes the type. In other words, `map`, `filter`, and `flatMap` would take `Array`
    and provide a changed `Array`. This is not the case with `reduce` as it can change
    an array to, for instance, a tuple or single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift provides the `reduce` method on arrays and has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the `reduce` method on our `numbers` `Array`, the result of this
    call becomes `394`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also call `reduce`, as follows, as the `+` operator is a function
    in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `map` and `filter` methods, developing a `reduce` function is also
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve the same result (`394`) with the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `reduce` method can be used with other types such as arrays of Strings.
  prefs: []
  type: TYPE_NORMAL
- en: The map function in terms of reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reduction pattern is so powerful that every other function that traverses
    a list can be specified in terms of it. Let''s develop a `map` function in terms
    of `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result is identical to our `map` function's result that we developed earlier
    in this chapter. This is a good example to understand the basics of `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we provide `elements` and an initial empty array of `ElementResult`,
    and finally, we provide a closure to combine the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The filter function in terms of reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is also possible to develop a `filter` function in terms of `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, the result is identical to our previously developed filter function.
  prefs: []
  type: TYPE_NORMAL
- en: In the function body, we provide elements, an empty initial array, and finally
    `predicate` as a combinator.
  prefs: []
  type: TYPE_NORMAL
- en: The flatMap function in terms of reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the power of reduce, we can implement the `flatMap` function
    in terms of reduce as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The flatten function in terms of reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, let''s implement the `flatten` function in terms of `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes a two-dimensional array and converts it to a one-dimensional
    array. Let''s test this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `[1, 3, 5, 2, 4, 6]`.
  prefs: []
  type: TYPE_NORMAL
- en: Apply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apply is a function that applies a function to a list of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, Swift does not provide any `apply` method on `Arrays`. To be
    able to implement Applicative Functors, we need to develop the `apply` function.
    The following code presents a simple version of the `apply` function with only
    one argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `apply` function takes a function and an array of any type and applies
    the function to the first element of the array. Let''s test this function as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Join
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `join` function takes an array of objects and joins them with a provided
    separator. The following example presents a simple version of join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes an array with a separator, joins elements in `Array`, and
    provides a single `String`. We can test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `"First, Second, Third"`.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we learned different functions with some examples for each. Let's see
    if we can combine them to solve problems that we may encounter in our day-to-day
    application development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we need to receive an object from a backend system as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to calculate the total of ages in the `users` array. We can use
    a combination of the `map` and `reduce` functions to calculate `totalAge` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We were able to chain the map and reduce methods to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Zip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `zip` function is provided by the Swift standard library and creates a sequence
    of pairs built out of two underlying sequences, where the elements of the *i^(th)*
    pair are the *i^(th)* elements of each underlying sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the following example, `zip` takes two `Arrays` and creates
    a pair of these two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The value for `zipped` will be `[("Three", 3), ("Five", 5), ("Nine", 9), ("Ten",
    10)]`.
  prefs: []
  type: TYPE_NORMAL
- en: Practical examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explore some practical examples of higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sum of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `reduce` to calculate the sum of a list of numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `55`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Product of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `reduce` to calculate the product of array values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `3628800`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Removing nil values from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `flatMap` to get values out of optional arrays and remove `nil`
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `["First", "Second", "Fourth"]`, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Removing duplicates in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `reduce` to remove duplicate elements in an array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The result will be `[1, 2, 3, 4, 5, 6, 7]` as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Partitioning an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use `reduce` to partition an array with a specific criterion. For instance,
    in the following example, we partition `numbersToPartition` `Array` into two partitions,
    keeping all even numbers in the left partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make this function generic as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the category theory concepts such as Functor,
    Applicative Functor, and Monad and explored higher-order functions such as `map`,
    `filter`, `flatMap`, `flatten`, and `reduce`. Then, we examined Swift-provided
    versions of higher-order functions and implemented a simple version ourselves.
    Also, we developed `map`, `filter`, `flatMap`, and `flatten` functions in terms
    of the `reduce` function.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we continued with the `apply`, `join`, and `zip` functions and were introduced
    to chaining higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored some practical examples of higher-order functions such
    as removing `nil` values from an array, removing duplicates, and partitioning
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: These functions are going to be great tools in our day-to-day development toolkit
    to use and solve a lot of different kinds of problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will get familiar with optional types and discuss
    non-functional and functional ways to deal with them.
  prefs: []
  type: TYPE_NORMAL
