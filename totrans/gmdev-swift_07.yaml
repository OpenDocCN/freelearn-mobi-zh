- en: Chapter 7. Implementing Collision Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 实现碰撞事件
- en: 'So far, we have let the SpriteKit physics simulation detect and handle collisions
    between game objects. You have seen that Pierre Penguin sends enemies and coins
    flying off into space when he flies into them. This is because the physics simulation
    automatically monitors collisions and sets the post-collision trajectory and velocity
    of each colliding body. In this chapter, we will add our own game logic when two
    objects come into contact: taking damage from enemies, granting the player invulnerability
    after touching the star, and tracking points as the player collects coins. The
    game will become more fun to play as the game mechanics come to life.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们让 SpriteKit 物理模拟检测和处理游戏对象之间的碰撞。你已经看到，当皮埃尔企鹅飞入敌人或金币时，它会将它们发送到太空。这是因为物理模拟自动监控碰撞并设置每个碰撞物体的碰撞后轨迹和速度。在本章中，当两个物体接触时，我们将添加自己的游戏逻辑：从敌人那里受到伤害、在接触星星后给予玩家无敌状态，以及玩家收集金币时跟踪分数。随着游戏机制变得生动，游戏将变得更加有趣。
- en: 'The topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Learning the SpriteKit collision vocabulary
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 SpriteKit 碰撞词汇
- en: Adding contact events to our game
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将接触事件添加到我们的游戏中
- en: Player health and damage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家健康和伤害
- en: Collecting coins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集金币
- en: The power-up star logic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提升星级逻辑
- en: Learning the SpriteKit collision vocabulary
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习 SpriteKit 碰撞词汇
- en: SpriteKit uses some unique concepts and terms to describe physics events. If
    you familiarize yourself with these terms now, it will be easier to understand
    the implementation steps later in the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 使用一些独特概念和术语来描述物理事件。如果你现在熟悉这些术语，那么在章节后面的实现步骤中理解起来会更容易。
- en: Collision versus contact
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞与接触
- en: 'There are two types of interactions when physics bodies come together in the
    same space:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当物理体在相同空间中聚集时，有两种类型的交互：
- en: 'A **collision** is the physics simulation''s mathematical analysis and repositioning
    of bodies after they touch. Collisions include all the automatic physical interactions
    between bodies: preventing overlap, bouncing apart, spinning through the air,
    and transferring momentum. By default, physics bodies collide with every other
    physics body in the scene; we have witnessed this automatic collision behavior
    in our game so far.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞**是物理模拟在物体接触后对物体进行数学分析和重新定位。碰撞包括物体之间所有的自动物理交互：防止重叠、弹开、空中旋转和传递动量。默认情况下，物理体与场景中的其他所有物理体发生碰撞；到目前为止，我们在游戏中已经见证了这种自动碰撞行为。'
- en: A **contact** event also occurs when two bodies touch. Contact events allow
    us to wire in our custom game logic when two bodies come into contact. Contact
    events do not create any change on their own; they only provide us with the chance
    to execute our own code. For instance, we will use contact events to assign damage
    to the player when he or she runs into an enemy. There are no contact events by
    default; we will manually configure contacts in this chapter.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当两个物体接触时，也会发生**接触**事件。接触事件允许我们在两个物体接触时，将自定义游戏逻辑连接进去。接触事件本身不会产生任何变化；它们只为我们提供了执行自己代码的机会。例如，当玩家或玩家遇到敌人时，我们将使用接触事件来分配伤害。默认情况下没有接触事件；在本章中，我们将手动配置接触。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Physics bodies collide with every other body in the scene by default, but you
    can configure specific bodies to ignore collisions and pass through each other
    without any physical reaction.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 物理体默认情况下与场景中的其他所有物体发生碰撞，但你可以配置特定的物体以忽略碰撞并相互穿过而不产生任何物理反应。
- en: Additionally, collisions and contacts are independent; you can disable physical
    collision between two types of bodies and still fire custom code with a contact
    event when the bodies pass through each other.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，碰撞和接触是独立的；你可以禁用两种类型物体之间的物理碰撞，并在物体穿过彼此时仍然使用接触事件来执行自定义代码。
- en: Physics category masks
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理类别掩码
- en: You can assign physics categories to each physics body in your game. These categories
    allow you to specify the bodies that should collide, the bodies that should contact,
    and the bodies that should pass through each other without any event. When two
    bodies try to share the same space, the physics simulation will compare each body's
    categories and test if collision or contact events should fire.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为游戏中的每个物理体分配物理类别。这些类别允许你指定应该发生碰撞的物体、应该接触的物体以及应该无事件地相互穿过的物体。当两个物体尝试共享同一空间时，物理模拟将比较每个物体的类别并测试是否应该触发碰撞或接触事件。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our game will include physics categories for the penguin, the ground, the coins,
    and the enemies.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏将包括企鹅、地面、金币和敌人的物理类别。
- en: Physics categories are stored as 32-bit masks, which allow the physics simulation
    to perform these tests with processor-efficient bitwise operations. It is not
    strictly necessary to understand bitwise operations to use physics categories,
    but it is a nice topic for further reading, if you are interested in enhancing
    your knowledge. If you are interested, try an Internet search for `swift bitwise
    operations`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 物理类别以 32 位掩码存储，这使得物理模拟可以通过处理器高效的位操作执行这些测试。虽然理解位操作不是使用物理类别所必需的，但如果您有兴趣扩展您的知识，这是一个很好的阅读主题。如果您感兴趣，可以尝试在互联网上搜索
    `swift bitwise operations`。
- en: 'Each physics body has three properties which you can use to control collisions
    in your game. Let''s begin with a very simple summary of each property, and then
    explore them in depth:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个物理物体都有三个属性，您可以使用这些属性来控制游戏中的碰撞。让我们先简单总结每个属性，然后再深入探讨：
- en: '`categoryBitMask`: The physics body''s physical categories'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`categoryBitMask`：物理物体的物理类别'
- en: '`collisionBitMask`: Collide with these physical categories'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collisionBitMask`：与这些物理类别发生碰撞'
- en: '`contactTestBitMask`: Contact with these physical categories'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contactTestBitMask`：与这些物理类别接触'
- en: The `categoryBitMask` property stores the body's current physics categories.
    The default value is `0xFFFFFFFF`, equating to every category. This means that,
    by default, every physics body belongs to every physics category.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`categoryBitMask` 属性存储了物体当前的物理类别。默认值是 `0xFFFFFFFF`，相当于所有类别。这意味着默认情况下，每个物理物体都属于所有物理类别。'
- en: The `collisionBitMask` property specifies the physical categories the body should
    collide with, preventing two bodies from sharing the same space. The starting
    value is `0xFFFFFFFF`, or all bits set, meaning that the body will collide with
    every category by default. When one body begins to overlap with another, the physics
    simulation compares each body's `collisionBitMask` against the other body's `categoryBitMask`.
    If there is a match, a collision takes place. Note that this test works two ways;
    each body can independently participate or ignore a collision.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`collisionBitMask` 属性指定了物体应该与之碰撞的物理类别，防止两个物体共享相同的空间。起始值是 `0xFFFFFFFF`，或所有位都设置，意味着默认情况下，物体将与每个类别发生碰撞。当一个物体开始与另一个物体重叠时，物理模拟将比较每个物体的
    `collisionBitMask` 与另一个物体的 `categoryBitMask`。如果匹配，则发生碰撞。请注意，这个测试是双向的；每个物体可以独立参与或忽略碰撞。'
- en: The `contactTestBitMask` property works just like the collision property, but
    specifies categories for contact events, instead of collisions. The default value
    is `0x00000000`, or no bits set, meaning that the body will not contact with anything
    by default.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`contactTestBitMask` 属性与碰撞属性的工作方式相同，但指定了接触事件而不是碰撞的类别。默认值是 `0x00000000`，或没有设置位，意味着默认情况下，物体不会与任何物体接触。'
- en: This is a dense subject. It is ok to move forward if you do not yet fully understand
    this topic. Implementing category masks into our game will help you learn.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的话题。如果你还没有完全理解这个主题，可以继续前进。将类别掩码实现到我们的游戏中将帮助你学习。
- en: Using category masks in Swift
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Swift 中使用类别掩码
- en: 'Apple''s Adventure game demo provides a good implementation of bitmasks in
    Swift. We will follow their example and use an `enum` to store our categories
    as `UInt32` values, writing these bitmasks in an easy-to-read manner. The following
    is an example of a physics category `enum` for a theoretical war game:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的冒险游戏演示提供了在 Swift 中使用位掩码的良好实现。我们将遵循他们的例子，并使用 `enum` 来存储我们的类别作为 `UInt32` 值，并以易于阅读的方式编写这些位掩码。以下是一个理论战争游戏的物理类别
    `enum` 的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is very important to double the value for each subsequent group; this is
    a necessary step to create proper bitmasks for the physics simulation. For example,
    if we were to add `fighterJets`, the value would need to be `32`. Always remember
    to double subsequent values to create unique bitmasks that perform as expected
    in the physics tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个后续组，双倍其值非常重要；这是创建适当的位掩码以进行物理模拟的必要步骤。例如，如果我们添加 `fighterJets`，则值需要是 `32`。始终记得双倍后续值以创建独特的位掩码，以便在物理测试中按预期执行。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Bitmasks are binary values that the CPU can very quickly compare to check for
    a match. You do not need to understand bitwise operators to complete this material,
    but if you are already familiar and curious, this doubling method works because
    `2` is equivalent to `1 << 1` (binary: `10`), `4` is equivalent to `1 << 2` (binary:
    `100`), `8` is equivalent to `1 << 3` (binary: `1000`), and so on. We opt for
    the manual doubling since `enum` values must be literals, and these values are
    easier for humans to read.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 位掩码是 CPU 可以非常快速比较的二进制值，以检查是否匹配。您不需要理解位运算符来完成此材料，但如果您已经熟悉并且好奇，这种加倍方法之所以有效，是因为
    `2` 等同于 `1 << 1`（二进制：`10`），`4` 等同于 `1 << 2`（二进制：`100`），`8` 等同于 `1 << 3`（二进制：`1000`），依此类推。我们选择手动加倍，因为
    `enum` 值必须是字面量，这些值对人类来说更容易阅读。
- en: Adding contact events to our game
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的游戏添加接触事件
- en: Now that you are familiar with SpriteKit's physics concepts, we can head into
    Xcode to implement physics categories and contact logic for our penguin game.
    We will start by adding in our physics categories.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了 SpriteKit 的物理概念，我们可以进入 Xcode 为我们的企鹅游戏实现物理类别和接触逻辑。我们将首先添加我们的物理类别。
- en: Setting up the physics categories
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置物理类别
- en: 'To create our physics categories, open your `GameScene.swift` file and enter
    the following code at the bottom, completely outside the `GameScene` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的物理类别，请打开您的 `GameScene.swift` 文件，并在 `GameScene` 类外部底部输入以下代码：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice how we double each succeeding value, as in our previous example. We are
    also creating an extra category for our penguin to use after he takes damage.
    We will use the `damagedPenguin` physics category to allow the penguin to pass
    through enemies for a few seconds after taking damage.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何像之前的例子那样将每个后续值翻倍的。我们还为我们的企鹅在受到伤害后使用创建了一个额外的类别。我们将使用 `damagedPenguin`
    物理类别，以便企鹅在受到伤害后几秒钟内能够穿过敌人。
- en: Assigning categories to game objects
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将类别分配给游戏对象
- en: Now that we have the physics categories, we need to go back through our existing
    game objects and assign the categories to the physics bodies. We will start with
    the `Player` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了物理类别，我们需要回到现有的游戏对象并将类别分配给物理体。我们将从 `Player` 类开始。
- en: The player
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩家
- en: 'Open `Player.swift` and add the following code at the bottom of the spawn function:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Player.swift` 并在 `spawn` 函数底部添加以下代码：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We assigned the penguin physics category to the `Player` physics body, and used
    the `contactTestBitMask` property to set up contact tests with enemies, the ground,
    power-ups, and coins.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将企鹅物理类别分配给 `Player` 物理体，并使用 `contactTestBitMask` 属性设置与敌人、地面、提升和金币的接触测试。
- en: Also, notice how we use the `rawValue` property of our `enum` values. You will
    need to use the `rawValue` property whenever you are using the physics category
    bitmasks.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意我们如何使用 `enum` 值的 `rawValue` 属性。当您使用物理类别位掩码时，您将需要使用 `rawValue` 属性。
- en: The ground
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 地面
- en: 'Next, let''s assign the physics category for the `Ground` class. Open `Ground.swift`,
    and add the following code at the bottom of the `spawn` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为 `Ground` 类分配物理类别。打开 `Ground.swift`，并在 `spawn` 函数底部添加以下代码：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All we need to do is assign the ground bitmask to the `Ground` class physics
    body, since it already collides with everything by default.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的只是将地面位掩码分配给 `Ground` 类的物理体，因为它默认情况下已经与所有物体发生碰撞。
- en: The star power-up
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 星星提升
- en: 'Open `Star.swift` and add the following code at the bottom of the `spawn` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `Star.swift` 并在 `spawn` 函数底部添加以下代码：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This assigns the power-up physics category to the `Star` class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将功率提升物理类别分配给 `Star` 类。
- en: Enemies
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敌人
- en: 'Perform this same action in `Bat.swift`, `Bee.swift`, `Blade.swift`, `Ghost.swift`,
    and `MadFly.swift`. Add the following code inside their `spawn` functions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Bat.swift`、`Bee.swift`、`Blade.swift`、`Ghost.swift` 和 `MadFly.swift` 中执行此相同操作。在它们的
    `spawn` 函数内部添加以下代码：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use the bitwise `NOT` operator (`~`) to remove the `damagedPenguin` physics
    category from collisions with enemies. Enemies will collide with all categories
    except the `damagedPenguin` physics category. This allows us to change the penguin's
    category to the `damagedPenguin` value when we want the penguin to ignore enemy
    collisions and pass straight through.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用位运算的 `NOT` 操作符 (`~`) 从与敌人的碰撞中移除 `damagedPenguin` 物理类别。敌人将与所有类别发生碰撞，除了 `damagedPenguin`
    物理类别。这允许我们在想要企鹅忽略敌人碰撞并直接穿过时，将企鹅的类别更改为 `damagedPenguin` 值。
- en: Coins
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金币
- en: 'Lastly, we will add the coin physics category. We do not want coins to collide
    with other game objects, but we still want to monitor for contact events. Open
    `Coin.swift` and add the following code at the bottom of the `spawn` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加金币的物理类别。我们不希望金币与其他游戏对象发生碰撞，但我们仍然想要监控接触事件。打开 `Coin.swift` 文件，在 `spawn`
    函数的底部添加以下代码：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Preparing GameScene for contact events
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备 GameScene 以处理接触事件
- en: 'Now that we have assigned the physics categories to our game objects, we can
    monitor for contact events in the `GameScene` class. Follow these steps to wire
    up the `GameScene` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为游戏对象分配了物理类别，我们可以在 `GameScene` 类中监控接触事件。按照以下步骤连接 `GameScene` 类：
- en: 'First, we need to tell the `GameScene` class to implement the `SKPhysicsContactDelegate`
    protocol. SpriteKit can then inform the `GameScene` class when contact events
    occur. Change the `GameScene` class declaration line to look like this:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要告诉 `GameScene` 类实现 `SKPhysicsContactDelegate` 协议。SpriteKit 就可以在接触事件发生时通知
    `GameScene` 类。将 `GameScene` 类声明行修改为如下所示：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will tell SpriteKit to inform `GameScene` of contact events by setting the
    `GameScene physicsWorld contactDelegate` property to the `GameScene` class. At
    the bottom of the `GameScene didMoveToView` function, add this line:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过将 `GameScene physicsWorld contactDelegate` 属性设置为 `GameScene` 类来告诉 SpriteKit
    通知 `GameScene` 类接触事件。在 `GameScene didMoveToView` 函数的底部添加以下行：
- en: '[PRE8]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`SKPhysicsContactDelegate` defines a `didBeginContact` function that will fire
    when contact occurs. We can now implement this `didBeginContact` function in the
    `GameScene` class. Create a new function in the `GameScene` class named `didBeginContact`,
    as shown in the following code:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SKPhysicsContactDelegate` 定义了一个 `didBeginContact` 函数，当发生接触时将会触发。我们现在可以在 `GameScene`
    类中实现这个 `didBeginContact` 函数。在 `GameScene` 类中创建一个新的函数，命名为 `didBeginContact`，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This function will serve as a central hub for our contact events. We will print
    to the console when our various contact events occur, to test that our code is
    working.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将作为我们接触事件的中心枢纽。当我们的各种接触事件发生时，我们将向控制台打印信息，以测试我们的代码是否正常工作。
- en: Viewing console output
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看控制台输出
- en: 'You can use the `println` function to write information to the console, which
    is very useful for debugging. If you have not yet used the console in Xcode, follow
    these simple steps to view it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `println` 函数将信息写入控制台，这对于调试非常有用。如果您尚未在 Xcode 中使用控制台，请按照以下简单步骤查看它：
- en: In the upper right-hand corner of Xcode, make sure the debug area is turned
    on, as shown in this screenshot:![Viewing console output](img/Image_B04532_07_01.jpg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 的右上角，确保调试区域已开启，如图所示：![查看控制台输出](img/Image_B04532_07_01.jpg)
- en: In the bottom right-hand corner of Xcode, make sure the console is turned on,
    as shown in this screenshot:![Viewing console output](img/Image_B04532_07_02.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 的右下角，确保控制台已开启，如图所示：![查看控制台输出](img/Image_B04532_07_02.jpg)
- en: Testing our contact code
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的接触代码
- en: 'Now that you can see your console output, run the project. You should see our
    `println` strings appear in the console as you fly Pierre into various game objects.
    Your console should look something like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以看到控制台输出了，运行项目。当您将皮埃尔飞入各种游戏对象时，应该会在控制台中看到我们的 `println` 字符串。您的控制台应该看起来像这样：
- en: '![Testing our contact code](img/Image_B04532_07_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的接触代码](img/Image_B04532_07_03.jpg)'
- en: Congratulations – if you see the contact output in the console, you have completed
    the structure for our contact system.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜——如果您在控制台中看到了接触输出，您已经完成了我们接触系统的结构。
- en: You may notice that flying into coins produces strange collision behavior, which
    we will enhance later in the chapter. Next, we will add game logic for each type
    of contact.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到飞入金币会产生奇怪的碰撞行为，我们将在本章后面增强这一点。接下来，我们将为每种接触类型添加游戏逻辑。
- en: Checkpoint 7-A
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 7-A
- en: 'To download my project to this point, visit this URL:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载到这一点的项目，请访问此 URL：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-7](http://www.thinkingswiftly.com/game-development-with-swift/chapter-7)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-7](http://www.thinkingswiftly.com/game-development-with-swift/chapter-7)'
- en: Player health and damage
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家生命值和伤害
- en: 'The first custom contact logic is player damage. We will assign the player
    health points and take them away when damaged. The game will end when the player
    runs out of health. This is one of the core mechanics of our gameplay. Follow
    these steps to implement the health logic:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首个自定义接触逻辑是玩家伤害。我们将为玩家分配健康点数，并在受伤时扣除。当玩家耗尽健康点数时，游戏结束。这是我们游戏玩法的基础机制之一。按照以下步骤实现健康逻辑：
- en: 'In the `Player.swift` file, add six new properties to the `Player` class:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Player.swift` 文件中，向 `Player` 类添加六个新属性：
- en: '[PRE10]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `update` function, change the code that moves the player through
    the world to use the new `forwardVelocity` property:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `update` 函数中，更改移动玩家通过世界的代码以使用新的 `forwardVelocity` 属性：
- en: '[PRE11]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the very beginning of the `startFlapping` function, add this line to prevent
    the player from flying higher when dead:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `startFlapping` 函数的非常开始处添加此行，以防止玩家在死亡时飞得更高：
- en: '[PRE12]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the same line at the very beginning of the `stopFlapping` function to prevent
    the soar animation from running after death:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `stopFlapping` 函数的非常开始处添加相同的行，以防止在死亡后运行飞翔动画：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a new function named `die` to the `Player` class:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Player` 类添加一个名为 `die` 的新函数：
- en: '[PRE14]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a new function named `takeDamage` to the `Player` class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `Player` 类添加一个名为 `takeDamage` 的新函数：
- en: '[PRE15]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the `GameScene.swift` file. Inside the `didBeginContact` function, update
    the switch case that fires when contact is made with an enemy:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GameScene.swift` 文件。在 `didBeginContact` 函数中，更新与敌人接触时触发的 switch 案例：
- en: '[PRE16]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also take damage when we hit the ground. Update the ground case in
    the same way:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们撞击地面时，我们也会受到伤害。以相同的方式更新地面情况：
- en: '[PRE17]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Good work – let's test our code to make sure everything is working correctly.
    Run the project and smash into some enemies. You can watch the printed output
    in the console to make sure everything is working correctly. After taking damage
    three times, the penguin should drop to the ground and become unresponsive.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好——让我们测试我们的代码以确保一切正常工作。运行项目并撞击一些敌人。你可以在控制台输出的打印内容中检查一切是否正常工作。受到三次伤害后，企鹅应该掉到地上并变得无反应。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice that there is no way for the player to tell how many health points
    he or she has remaining as they play the game. We will add a health meter to the
    scene in the next chapter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，玩家在玩游戏时无法知道他们剩余多少健康点数。我们将在下一章中向场景添加一个健康计。
- en: Next, we will enhance the feel of the game with new animations when the player
    takes damage and when the game ends.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当玩家受到伤害和游戏结束时，我们将通过新的动画增强游戏的感受。
- en: Animations for damage and game over
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受伤和游戏结束动画
- en: We will use `SKAction` sequences to create fun animations when the player takes
    damage. By combining actions, we will grant temporary safety in a damaged state
    after the player hits an enemy. We will show a fade animation that slowly pulses
    at first and then speeds up as the safe state starts to wear off.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家受到敌人打击时，我们将使用 `SKAction` 序列创建有趣的动画。通过组合动作，我们将在玩家击中敌人后提供一个受伤状态下的临时安全。我们将展示一个逐渐脉冲然后随着安全状态开始减弱而加速的淡入淡出动画。
- en: The damage animation
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 受伤动画
- en: 'To add the new animation, add this code at the bottom of the `Player` class
    `createAnimations` function:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新动画，请将此代码添加到 `Player` 类的 `createAnimations` 函数底部：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, update the `takeDamage` function to flag the player as damaged, immediately
    after taking a hit. The damage animation you just created will turn the damaged
    flag back off once it has completed. After this change, the first four lines of
    the `takeDamage` function should look like this (the new code is written in bold):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 `takeDamage` 函数，在受到打击后立即标记玩家为受伤。你刚刚创建的受伤动画将在完成后关闭受伤标记。在此更改后，`takeDamage`
    函数的前四行应该看起来像这样（新代码用粗体表示）：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the project. Directly after taking damage, your penguin should fade and
    be able to pass through enemies, as shown in this image:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。在受到伤害后，你的企鹅应该逐渐消失并能够穿过敌人，如图所示：
- en: '![The damage animation](img/Image_B04532_07_04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![受伤动画](img/Image_B04532_07_04.jpg)'
- en: We are starting to see some good results from our hard work. Notice how the
    penguin can pass through enemies but still collides with coins, the star, and
    the ground while in the invulnerable state. Next, we will add a game over animation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始看到我们辛勤工作的良好成果。注意企鹅在无敌状态下可以穿过敌人，但仍然与金币、星星和地面发生碰撞。接下来，我们将添加一个游戏结束动画。
- en: The game over animation
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏结束动画
- en: 'We will create a funny, over-the-top death animation when the penguin runs
    out of health. When Pierre loses his last hit point, he will hang in the air,
    scale larger, flip over on to his back, and then finally fall to the ground. To
    implement this animation, add the following code at the bottom of the `Player`
    class `createAnimations` function:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当企鹅的生命值耗尽时，我们将创建一个有趣且夸张的死亡动画。当皮埃尔失去最后一点生命值时，他将悬挂在空中，放大体型，翻转到背部，然后最终跌落到地面。为了实现这个动画，在
    `Player` 类的 `createAnimations` 函数底部添加以下代码：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the project and bump into three enemies. You will see the comedic death
    animation play, as shown in this screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目并与三个敌人碰撞。你会看到如截图所示的喜剧死亡动画播放：
- en: '![The game over animation](img/Image_B04532_07_05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![游戏结束动画](img/Image_B04532_07_05.jpg)'
- en: Poor Pierre Penguin! Good job implementing the damage and death animations.
    Next, we will handle coin collection on the coin contact event.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可怜的皮埃尔企鹅！你很好地实现了伤害和死亡动画。接下来，我们将处理硬币接触事件上的硬币收集。
- en: Collecting coins
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集硬币
- en: 'As a main goal for the player, collecting coins should be one of the most enjoyable
    aspects of our game. We will create a rewarding animation when the player contacts
    a coin. Follow these steps to implement coin collection:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 作为玩家的主要目标之一，收集硬币应该是我们游戏中最令人愉快的方面之一。当玩家接触硬币时，我们将创建一个奖励动画。按照以下步骤实现硬币收集：
- en: 'In `GameScene.swift`, add a new property to the `GameScene` class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 中，向 `GameScene` 类添加一个新属性：
- en: '[PRE21]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In `Coin.swift`, add a new function to the `Coin` class named `collect`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Coin.swift` 中，向 `Coin` 类添加一个名为 `collect` 的新函数：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `GameScene.swift`, call the new `collect` function from the coin contact
    case in the `didBeginContact` function:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 中，在 `didBeginContact` 函数的硬币接触情况下调用新的 `collect` 函数：
- en: '[PRE23]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Great work! Run the project and try to collect some coins. You will see the
    coins perform their collection animation. The game will keep track of how many
    coins you are collecting and print the number to the console. The player cannot
    see that number yet; we will add a text counter on the game screen in the next
    chapter. Next, we will implement the power-up star game logic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！运行项目并尝试收集一些硬币。你会看到硬币执行它们的收集动画。游戏将跟踪你收集的硬币数量，并将数字打印到控制台。玩家目前还看不到这个数字；我们将在下一章中在游戏屏幕上添加一个文本计数器。接下来，我们将实现升级星的游戏逻辑。
- en: The power-up star logic
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级星逻辑
- en: 'When the player contacts the star, we will grant invulnerability for a short
    time and give the player great speed to power through encounters. Follow these
    steps to implement the power-up:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家接触星星时，我们将授予玩家短暂的不可伤害状态，并给予玩家极大的速度以通过遭遇。按照以下步骤实现升级：
- en: 'In `Player.swift`, add a new function to the `Player` class, as shown here:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Player.swift` 中，向 `Player` 类添加一个新函数，如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Invoke the new function from the `GameScene` class `didBeginContact` function,
    under the power-up case:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene` 类的 `didBeginContact` 函数中，在升级情况下调用新的函数：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You may find it helpful to increase the spawn rate of the star power-up in
    order to test. Remember that we are generating a random number in the `didSimulatePhysics`
    function of `GameScene` to determine how often we spawn the star. To spawn the
    star more often, comment out the line that generates a random number and replace
    it with a hardcoded `0`, as shown here (the new code is written in bold):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现增加星星升级的生成率来测试很有帮助。记住，我们在 `GameScene` 的 `didSimulatePhysics` 函数中生成一个随机数，以确定星星生成的频率。为了更频繁地生成星星，注释掉生成随机数的行，并用硬编码的
    `0` 替换它，如下所示（新代码用粗体标出）：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Great, now it will be easy to test the star power-up. Run the project and find
    a star. The penguin should scale to a large size and start charging forward, blowing
    enemies aside as he passes, as shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在测试星星升级会很容易。运行项目并找到一个星星。企鹅应该放大体型并开始向前冲，在经过时吹飞敌人，如截图所示：
- en: '![The power-up star logic](img/Image_B04532_07_06.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![升级星逻辑](img/Image_B04532_07_06.jpg)'
- en: Remember to change the star-spawning code back to a random number before you
    continue, or the star will spawn too often.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续之前，记得将星星生成代码改回随机数，否则星星会生成得太频繁。
- en: Checkpoint 7-B
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 7-B
- en: 'We have made terrific progress in this chapter. To download my project up to
    this point, visit this URL:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中取得了巨大的进步。要下载到这一点的项目，请访问此网址：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-7](http://www.thinkingswiftly.com/game-development-with-swift/chapter-7)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-7](http://www.thinkingswiftly.com/game-development-with-swift/chapter-7)'
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Our penguin game is looking great! You have brought the core mechanics to life
    by implementing the sprite contact events. You learned how SpriteKit handles collisions
    and contacts, used bitmasks to assign collision categories to different types
    of sprites, wired up a contact system in our penguin game, and added custom game
    logic for taking damage, collecting coins, and gaining the star power-up.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小企鹅游戏看起来棒极了！你通过实现精灵接触事件，让核心机制变得生动起来。你学习了SpriteKit如何处理碰撞和接触，使用了位掩码为不同类型的精灵分配碰撞类别，在我们的企鹅游戏中搭建了一个接触系统，并添加了自定义游戏逻辑，包括受到伤害、收集金币和获得星级增强。
- en: We have a playable game at this point; the next step is adding polish, menus,
    and features to make the game stand out. We will make our game shine by adding
    a HUD, background images, particle emitters, and more in [Chapter 8](ch08.html
    "Chapter 8. Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and More"),
    *Polishing to a Shine – HUD, Parallax Backgrounds, Particles, and More*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有一个可玩的游戏了；下一步是添加润色、菜单和功能，使游戏脱颖而出。我们将在第8章“Polishing to a Shine – HUD,
    Parallax Backgrounds, Particles, and More”中，通过添加HUD、背景图像、粒子发射器等，让我们的游戏更加闪耀。[第8章](ch08.html
    "第8章. 润色至闪耀 – HUD、透视背景、粒子等")。
