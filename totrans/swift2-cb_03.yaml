- en: Chapter 3. Using Structs and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an exam app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for the right answer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the copying of structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a generic array initializer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a priority list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a protocol for the priority queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could say that structures are something similar to classes. They store values
    with attributes, and they have initializers and methods. But their usage is a
    bit different. The idea of structs in Swift came from Objective-C, which by itself
    was using the C struct.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use generics, so we can create generic containers. The idea of
    generics is not new; other languages such as C++ and Java already had it. However,
    this feature didn't exist in Objective-C, so the programmer was responsible for
    casting the retrieved data and as a consequence of this, the code was unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an exam app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an exam app. For this exam, we will choose some
    random questions and the user will answer them. At the end, the app will show
    the user score and start again with a new exam.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, open Xcode and create a project called `Chapter 3 Examination`, then
    create a file called `question.swift`. This is where we will define a question
    for an exam.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an exam app, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the storyboard and add a label and three buttons to the view controller.
    You will have something similar to the following screenshot:![How to do it…](img/00033.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following code into the `question.swift` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ok, now we can create our array of questions. This will be like a template
    because it is not the exam yet; it will be a container of every question. So,
    go to the only view controller we have and add the following attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to fill this array with questions; as you may imagine, we
    will not add a lot of questions in this recipe, but a real application can have
    many of them. In this case, we need to divide it into different methods by category,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Good! Now, we can initialize our exam, so let''s create a method to do it.
    We will also need an attribute that will contain the current exam and another
    one that knows the current question:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Okay, it''s time to start! We only need to show the question with its possible
    answers, like the method shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we only need to add this action for the buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you click on play now, you will realize that the app still doesn''t work;
    we have to initialize it, so let''s finish this application by filling the `viewDidLoad`
    method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main difference between a class and a structure is that structures are copied
    every time they are assigned. What does this mean? This means that in this case
    if we've created this program with classes, the exam attribute and the exam template
    will point to the same objects (questions).
  prefs: []
  type: TYPE_NORMAL
- en: With this problem in mind, you can see that if we used classes when we start
    again, the new exam would come with the previous user's answers. Also, there is
    more; if you would like to store the exams with their answers, you would have
    to clone the objects; otherwise, everybody would have the same answers. Using
    structs, you don't have to worry about it; every time you create a new exam, you
    have new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting part that I'd like to comment on is the `createExam` function.
    As you can see, we have another function inside of it. Swift allows you to have
    auxiliary functions. This is very useful, mainly when we want to divide our code
    into small tasks.
  prefs: []
  type: TYPE_NORMAL
- en: On the same function (`createExam`), you can see that we had a large call for
    creating a random number. The reason for this weird call is that Swift doesn't
    have a function for random numbers yet. Actually, Objective-C doesn't have a random
    function either; we have to use the C function `arc4random_uniform`.
  prefs: []
  type: TYPE_NORMAL
- en: Such a function receives as an argument a 32-bit unsigned integer, but Swift
    can't convert its integer to this type. So, we used `UInt32` to convert this number.
    As this function also returns an unsigned integer, it is necessary to cast its
    result to the Swift integer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more functions to retrieve random numbers, such as `rand`, `random`,
    and `arc4random`. Have a look at the manual page of the command line and check
    their differences.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for the right answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will complete the previous one by checking the user's answer and
    validating that it is correct. If for any reason the answer receives a value out
    of range, this will be set to `nil`. Of course, in this application, it's not
    possible to answer with a wrong value, but remember that a good developer is always
    thinking about the possible software evolution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copy the previous recipe; if you like, you can rename the product `Chapter
    3 Examination 2` by simply renaming the target name, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps in order to check the answers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the `question.swift` file. Now, replace the current class with the following
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, return to the view controller and replace the `showCurrentQuestion` method
    with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This recipe can stop here. However, as we want to check this, an out-of-range
    value will be corrected to `nil`; we can replace the `answer` method with this
    one here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift has a good feature for properties called `property observer`. This feature
    is equivalent to triggers on relational databases. With `willSet`, you can correct
    the input and with `didSet`, you can trigger actions that are needed after the
    value has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: We also changed the way we check a valid answer; this is done because the logic
    of a question should be inside its class or structure.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, this recipe is related to the *Quizzing the user* recipe in
    [Chapter 2](part0025_split_000.html#NQU21-bba3081a9dc049b7aa5e4f7cc42ef8bb "Chapter 2. Standard
    Library and Collections"), *Standard Library and Collections*. If you want to
    create a more complete example, you can merge both apps into one.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the copying of structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we are working with structs and we don't want to copy them.
    In this recipe, we will see this example and the solution for it by creating a
    small app where the user can see the coordinates of two supposed characters, and
    we can press a button to change their coordinates to a center point between them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new single view project called `Chapter3 Vector2D`. For this recipe,
    we will need only one new file, which we will call `Position.swift`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the app that prevents the copying of structs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the model part, as usual. Click on the `Position.swift` file.
    Let''s create a struct with the same name, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, go to the storyboard and add nine buttons and two labels to it, something
    similar to the following screenshot:![How to do it…](img/00035.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s link our labels with the following attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we will create two attributes that represent the coordinates of
    the characters. Of course, in a real game, these attributes will belong to objects
    of another type, probably of something like a character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, these objects will start at the 0 x 0 position, but the labels
    won''t know it if we don''t initialize it with the `viewDidLoad` method. So, let''s
    add the following code to the view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the events that move the characters. As you can imagine, they
    are very straightforward because, each action will proxy to the equivalent method
    on the struct. Here is the code for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, the application is done. Click on play and move the characters with the
    buttons. The most important part is that no struct was copied or cloned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, we had to add a modifier on the methods of our structs. This
    is because struct methods, by default, are constants. If you need to change an
    attribute, you have to use the `mutating` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: When receiving an argument that you don't want to copy, such as a struct, you
    have to use the `inout` parameter. This parameter will allow you to modify the
    corresponding argument. However, when using this feature, you have to call the
    function adding an ampersand (`&`) before the variable and you can't pass expressions
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a generic array initializer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use generics. This feature is used a lot
    in languages such as C++, Java, and C# because this way, we don't need to overload
    a function for each possible type that could be used in our function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will create a function that receives the input items and returns
    an array with these elements but completely shuffled.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Swift single view project called `Chapter3 Array initializer`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a generic array initializer, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file called `ArrayInit` and add this code into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to add two buttons and a text view to our storyboard to see this
    function working. So, let''s link the text view with the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create the events of each button, so add these actions
    into your view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, it's time to test our code. Run your application and press each button,
    and you should have results like these screenshots:![How to do it…](img/00036.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One advantage of object-oriented programming is avoiding the duplication of
    code. Some languages will force you to create a function for the array of strings,
    another one for the array of integers, and another new one for each new type that
    we need to use with this function.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Swift allows us to create a generic function. This means that we
    only need to implement the function once and the same code will be applied each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside the function, the arguments are treated as a constant array, but calling
    the function with an array as an argument has another meaning; the compiler will
    think that you have only one argument that is an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function has something different: the ellipsis that is used after the
    input argument. This means that the function is not restricted to a number of
    arguments; this has a variable number of arguments. In our case, we can call it
    with six integers and with five strings. This feature is very useful, for example,
    when creating functions to calculate the average of some numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overloading generic functions is allowed; it's used when there is a type that,
    for any reason, needs a different code. For example, now you can use this code
    to shuffle cards.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a priority list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine that we need to manage a queue of passengers on a flight. We know
    that business class should embark first, then passengers in first class, and finally,
    economy class.
  prefs: []
  type: TYPE_NORMAL
- en: This is a typical case of a priority queue, but the nagging question is, can
    we create a priority queue only once? Or should we create a new priority queue
    in every new app? An Objective-C programmer who recently arrived at Swift will
    probably create this container storing objects of the type `AnyObject`. This solution
    can be acceptable; however, Swift has a better solution that is even safer, and
    as you know, that is generics.
  prefs: []
  type: TYPE_NORMAL
- en: A priority queue needs to organize its elements using criteria. In this case,
    we can create our queue of any element but ensure that it is created for elements
    of a class that implements the `Comparable` protocol; that's what we call a type
    constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Swift single view project called `Chapter3 Flight`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to create a priority list:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Swift file called `PriorityQueue.swift`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, let''s create a class with the same name. Here, we will need
    an array as an attribute to store our elements and a few methods to work with
    this queue: `enqueue` for adding a new element; `dequeue` for removing the first
    element of the queue; `size`, which returns the number of elements on our queue;
    and `toArray`, which will return the elements of our queue to an array. So, add
    the following code into your file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new file called `Passenger.swift`. Here, we will define a passenger
    with his data. Remember that we need to compare the priority of a passenger. For
    this reason, this class must implement the `Comparable` protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, open your storyboard and add two text fields (one for passenger name and
    another one for his identification number and ID document), one table view to
    choose the seat type, two buttons to queue and dequeue, and a text field to display
    the current queue status. You should have a layout similar to the following one:![How
    to do it…](img/00037.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to open the view controller and add the protocol `UITableViewDataSource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ok, now link the corresponding components with the attribute, and beside this,
    create a passenger queue as an attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this moment, we can start implementing the `tableview` code. As you know,
    we must implement at least two mandatory methods of `UITableViewDataSource`. Let''s
    start with the easiest one that returns the number of rows. Right now, there is
    no way to detect the number of elements of an enumeration, so we will hardcode
    this value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create the method that returns the seat type cells:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you click on play at this moment, you should at least see the table view
    with its values. Now, we need to create a method to display the current queue
    passengers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we only need to create the actions for our buttons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The app is done. Now, try to add different passengers and check how your queue
    grows.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generics save us from rewriting a lot of code, but as it needs to be safe, you
    can't use operators or methods that might not exist on the type that you are working
    with. To solve this problem, you can specify a constraint that will tell the compiler
    which methods are allowed to be used with this type. In our case, we specified
    that T is Comparable; so we can use the operators of Comparators on our code.
  prefs: []
  type: TYPE_NORMAL
- en: Some new knowledge that we can retrieve from this code is the nested enumeration.
    Swift has no namespace or package, but you can create nested enumerations, classes,
    and structs. This way we can avoid clashing names.
  prefs: []
  type: TYPE_NORMAL
- en: Another new feature is the typed enumeration; as you can see, we specified that
    each enumeration value is associated with an integer number. You can retrieve
    this value using `rawValue` or use `init(rawValue:)` to do the inverted process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first version of Swift used to have a method called `toRaw()` instead of
    the property `rawValue`, and `fromRaw()` instead of using the initializer `init(rawValue:)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also implement your own function or computed property as we did in this
    enumeration; sometimes, it's better than using the raw value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating your function or computed property to convert enumerations is a good
    practice for software maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is more than one way to solve this problem; if you need performance, you
    might use a double linked list instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify more than one constraint if you want to by using the `where`
    clause. For example, if you would like to store elements that are also `CustomStringConvertable`,
    you can change the class header to `class PriorityQueue<T:Comparable where T:
    CustomStringConvertable > {`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a protocol for the priority queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we created a generic code which can be used in our future
    programs, but we have to remember that priority queues are only one kind of queue.
    It is good practice to define an interface for this abstract data type, and after
    this, have different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, in Swift, we have protocols for cases such as this; however, we
    have a problem: protocols don''t have generics. What is the solution? The answer
    is **associated types**.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the project of the previous recipe and name it `Chapter 3 Flight Protocol`,
    and create a new file called `Queue.swift`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a protocol for the priority queue, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code onto the `Queue.swift` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, return to the priority queue and change its header to this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click on play, and of course, the result is visually the same, but your code
    is now more recyclable. Try to remove one method such as `enqueue`, and you will
    see that the compiler will complain about the missing method of the protocol.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately, we can't create protocols with generics, but we can solve this
    problem with associated types. You only need to create `typealias` inside the
    protocol without specifying its real type, and then, we can declare the protocol's
    methods with this type. When you inherit from this protocol, your type can be
    anything, even a generic type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try to use protocols when you have a concept such as a queue, a list, or a stack.
    Then, you can have different implementations and use the best one for the occasion.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have learned how to make reusable code with generics, you will
    improve even more in the next chapter where we will use design patterns with Swift.
  prefs: []
  type: TYPE_NORMAL
