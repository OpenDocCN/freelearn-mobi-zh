- en: Chapter 3. Using Structs and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用结构体和泛型
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Creating an exam app
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建考试应用
- en: Checking for the right answer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查正确答案
- en: Avoiding the copying of structs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复制结构体
- en: Creating a generic array initializer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建泛型数组初始化器
- en: Creating a priority list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建优先级列表
- en: Creating a protocol for the priority queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为优先级队列创建协议
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: We could say that structures are something similar to classes. They store values
    with attributes, and they have initializers and methods. But their usage is a
    bit different. The idea of structs in Swift came from Objective-C, which by itself
    was using the C struct.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说结构体类似于类。它们存储具有属性的值，并且有初始化器和方法。但它们的用法略有不同。Swift中结构体的想法来自Objective-C，而Objective-C本身正在使用C结构体。
- en: We will also use generics, so we can create generic containers. The idea of
    generics is not new; other languages such as C++ and Java already had it. However,
    this feature didn't exist in Objective-C, so the programmer was responsible for
    casting the retrieved data and as a consequence of this, the code was unsafe.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用泛型，因此我们可以创建泛型容器。泛型的想法并不新鲜；像C++和Java这样的其他语言已经有了它。然而，这个特性在Objective-C中并不存在，因此程序员负责转换检索到的数据，因此代码是不安全的。
- en: Creating an exam app
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建考试应用
- en: In this recipe, we will create an exam app. For this exam, we will choose some
    random questions and the user will answer them. At the end, the app will show
    the user score and start again with a new exam.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个考试应用。对于这个考试，我们将选择一些随机问题，用户将回答它们。最后，应用将显示用户得分并重新开始新的考试。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, open Xcode and create a project called `Chapter 3 Examination`, then
    create a file called `question.swift`. This is where we will define a question
    for an exam.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开Xcode，创建一个名为`Chapter 3 Examination`的项目，然后创建一个名为`question.swift`的文件。这是我们定义考试问题的位置。
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To create an exam app, follow these steps:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个考试应用，请按照以下步骤操作：
- en: Open the storyboard and add a label and three buttons to the view controller.
    You will have something similar to the following screenshot:![How to do it…](img/00033.jpeg)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开故事板，并向视图控制器添加一个标签和三个按钮。您将得到以下截图类似的内容：![如何操作…](img/00033.jpeg)
- en: 'Copy the following code into the `question.swift` file:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码复制到`question.swift`文件中：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Ok, now we can create our array of questions. This will be like a template
    because it is not the exam yet; it will be a container of every question. So,
    go to the only view controller we have and add the following attribute:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在我们可以创建我们的问题数组。这将像是一个模板，因为它还不是考试；它将是一个包含每个问题的容器。所以，前往我们唯一的视图控制器，并添加以下属性：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step is to fill this array with questions; as you may imagine, we
    will not add a lot of questions in this recipe, but a real application can have
    many of them. In this case, we need to divide it into different methods by category,
    as follows:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将问题填充到这个数组中；正如您可能想象的那样，在这个菜谱中，我们不会添加很多问题，但一个真实的应用程序可以有很多。在这种情况下，我们需要按类别将其分成不同的方法，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Good! Now, we can initialize our exam, so let''s create a method to do it.
    We will also need an attribute that will contain the current exam and another
    one that knows the current question:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的！现在，我们可以初始化我们的考试了，所以让我们创建一个方法来完成它。我们还需要一个属性来包含当前考试，另一个属性知道当前问题：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Okay, it''s time to start! We only need to show the question with its possible
    answers, like the method shown here:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，是时候开始了！我们只需要显示问题及其可能的答案，就像这里显示的方法一样：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we only need to add this action for the buttons:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要为按钮添加以下操作：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you click on play now, you will realize that the app still doesn''t work;
    we have to initialize it, so let''s finish this application by filling the `viewDidLoad`
    method, as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您点击“现在播放”，您会发现应用仍然不起作用；我们必须初始化它，所以让我们通过填充`viewDidLoad`方法来完成这个应用程序，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The main difference between a class and a structure is that structures are copied
    every time they are assigned. What does this mean? This means that in this case
    if we've created this program with classes, the exam attribute and the exam template
    will point to the same objects (questions).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 类和结构体之间的主要区别是结构体在每次赋值时都会被复制。这意味着什么？这意味着在这种情况下，如果我们用类创建了程序，考试属性和考试模板将指向相同的对象（问题）。
- en: With this problem in mind, you can see that if we used classes when we start
    again, the new exam would come with the previous user's answers. Also, there is
    more; if you would like to store the exams with their answers, you would have
    to clone the objects; otherwise, everybody would have the same answers. Using
    structs, you don't have to worry about it; every time you create a new exam, you
    have new objects.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个问题，你可以看到如果我们再次开始时使用类，新的考试将带有前一个用户的答案。还有更多；如果你想要存储带有答案的考试，你必须克隆对象；否则，每个人都会有相同的答案。使用结构体，你不必担心这个问题；每次你创建一个新的考试，你都会有新的对象。
- en: Another interesting part that I'd like to comment on is the `createExam` function.
    As you can see, we have another function inside of it. Swift allows you to have
    auxiliary functions. This is very useful, mainly when we want to divide our code
    into small tasks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我想评论的另一个有趣的部分是`createExam`函数。正如你所看到的，我们在这个函数内部还有一个函数。Swift允许你拥有辅助函数。这在我们需要将代码分成小任务时非常有用。
- en: On the same function (`createExam`), you can see that we had a large call for
    creating a random number. The reason for this weird call is that Swift doesn't
    have a function for random numbers yet. Actually, Objective-C doesn't have a random
    function either; we have to use the C function `arc4random_uniform`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个函数（`createExam`）中，你可以看到我们有一个创建随机数的巨大调用。这个奇怪调用的原因是因为Swift还没有随机数的函数。实际上，Objective-C也没有随机函数；我们必须使用C函数`arc4random_uniform`。
- en: Such a function receives as an argument a 32-bit unsigned integer, but Swift
    can't convert its integer to this type. So, we used `UInt32` to convert this number.
    As this function also returns an unsigned integer, it is necessary to cast its
    result to the Swift integer.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接收一个32位无符号整数作为参数，但Swift不能将其整数转换为这种类型。所以，我们使用了`UInt32`来转换这个数字。因为这个函数也返回一个无符号整数，所以有必要将其结果转换为Swift整数。
- en: There's more…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are more functions to retrieve random numbers, such as `rand`, `random`,
    and `arc4random`. Have a look at the manual page of the command line and check
    their differences.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多函数可以检索随机数，如`rand`、`random`和`arc4random`。查看命令行手册并检查它们的区别。
- en: Checking for the right answer
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查正确答案
- en: This recipe will complete the previous one by checking the user's answer and
    validating that it is correct. If for any reason the answer receives a value out
    of range, this will be set to `nil`. Of course, in this application, it's not
    possible to answer with a wrong value, but remember that a good developer is always
    thinking about the possible software evolution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将通过检查用户的答案并验证其正确性来完成前一个菜谱。如果由于任何原因答案接收到的值超出范围，这将设置为`nil`。当然，在这个应用程序中，不可能用错误的值回答，但请记住，一个好的开发者总是思考软件可能的演变。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Copy the previous recipe; if you like, you can rename the product `Chapter
    3 Examination 2` by simply renaming the target name, as shown here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 复制前一个菜谱；如果你愿意，可以通过简单地重命名目标名称来将产品重命名为`Chapter 3 Examination 2`，如下所示：
- en: '![Getting ready](img/00034.jpeg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00034.jpeg)'
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Follow these steps in order to check the answers:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤检查答案：
- en: 'Go to the `question.swift` file. Now, replace the current class with the following
    one:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`question.swift`文件。现在，用以下代码替换当前的类：
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, return to the view controller and replace the `showCurrentQuestion` method
    with the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到视图控制器，用以下代码替换`showCurrentQuestion`方法：
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This recipe can stop here. However, as we want to check this, an out-of-range
    value will be corrected to `nil`; we can replace the `answer` method with this
    one here:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个菜谱可以到此为止。然而，因为我们想检查这个，超出范围的值将被更正为`nil`；我们可以用这里的这个替换`answer`方法：
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works…
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Swift has a good feature for properties called `property observer`. This feature
    is equivalent to triggers on relational databases. With `willSet`, you can correct
    the input and with `didSet`, you can trigger actions that are needed after the
    value has been changed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Swift有一个很好的属性特性，称为`property observer`。这个特性等同于关系数据库中的触发器。使用`willSet`，你可以纠正输入，使用`didSet`，你可以在值改变后触发所需的操作。
- en: We also changed the way we check a valid answer; this is done because the logic
    of a question should be inside its class or structure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还改变了检查有效答案的方式；这样做是因为问题的逻辑应该在其类或结构内部。
- en: There's more…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As you can see, this recipe is related to the *Quizzing the user* recipe in
    [Chapter 2](part0025_split_000.html#NQU21-bba3081a9dc049b7aa5e4f7cc42ef8bb "Chapter 2. Standard
    Library and Collections"), *Standard Library and Collections*. If you want to
    create a more complete example, you can merge both apps into one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个菜谱与[第2章](part0025_split_000.html#NQU21-bba3081a9dc049b7aa5e4f7cc42ef8bb
    "第2章。标准库和集合")中的*用户问答*菜谱相关，*标准库和集合*。如果你想创建一个更完整的例子，你可以将两个应用程序合并为一个。
- en: Avoiding the copying of structs
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复制结构体
- en: There are times when we are working with structs and we don't want to copy them.
    In this recipe, we will see this example and the solution for it by creating a
    small app where the user can see the coordinates of two supposed characters, and
    we can press a button to change their coordinates to a center point between them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们在处理结构体时，并不想复制它们。在这个菜谱中，我们将通过创建一个小应用程序来展示这个例子和解决方案，用户可以在其中看到两个假设角色的坐标，我们可以按一个按钮来改变它们的坐标到一个中心点。
- en: Getting ready
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new single view project called `Chapter3 Vector2D`. For this recipe,
    we will need only one new file, which we will call `Position.swift`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter3 Vector2D`的新单视图项目。对于这个菜谱，我们只需要一个新文件，我们将称之为`Position.swift`。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s create the app that prevents the copying of structs:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个防止复制结构体的应用程序：
- en: 'Let''s start with the model part, as usual. Click on the `Position.swift` file.
    Let''s create a struct with the same name, as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像往常一样从模型部分开始。点击`Position.swift`文件。让我们创建一个具有相同名称的结构体，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, go to the storyboard and add nine buttons and two labels to it, something
    similar to the following screenshot:![How to do it…](img/00035.jpeg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到故事板，并向其中添加九个按钮和两个标签，类似于以下截图：![如何做…](img/00035.jpeg)
- en: 'Now, let''s link our labels with the following attributes:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的标签与以下属性链接：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After this, we will create two attributes that represent the coordinates of
    the characters. Of course, in a real game, these attributes will belong to objects
    of another type, probably of something like a character:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建两个表示角色坐标的属性。当然，在一个真正的游戏中，这些属性将属于另一种类型的对象，可能是类似角色的东西：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, these objects will start at the 0 x 0 position, but the labels
    won''t know it if we don''t initialize it with the `viewDidLoad` method. So, let''s
    add the following code to the view controller:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，这些对象将从0 x 0位置开始，但如果我们没有使用`viewDidLoad`方法初始化它，标签将不知道这一点。所以，让我们向视图控制器添加以下代码：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can add the events that move the characters. As you can imagine, they
    are very straightforward because, each action will proxy to the equivalent method
    on the struct. Here is the code for this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加移动角色的事件。正如你所想象的那样，它们非常直接，因为每个动作都将代理到结构体上的等效方法。以下是这段代码：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, the application is done. Click on play and move the characters with the
    buttons. The most important part is that no struct was copied or cloned.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，应用已经完成。点击播放并使用按钮移动角色。最重要的是没有复制或克隆任何结构体。
- en: How it works…
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see, we had to add a modifier on the methods of our structs. This
    is because struct methods, by default, are constants. If you need to change an
    attribute, you have to use the `mutating` modifier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不得不在我们的结构体方法上添加一个修饰符。这是因为结构体方法默认是常量。如果你需要更改一个属性，你必须使用`mutating`修饰符。
- en: When receiving an argument that you don't want to copy, such as a struct, you
    have to use the `inout` parameter. This parameter will allow you to modify the
    corresponding argument. However, when using this feature, you have to call the
    function adding an ampersand (`&`) before the variable and you can't pass expressions
    as arguments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到你不想复制的参数时，例如结构体，你必须使用`inout`参数。这个参数将允许你修改相应的参数。然而，当使用这个功能时，你必须调用函数，在变量前加上一个连字符（`&`），并且不能将表达式作为参数传递。
- en: Creating a generic array initializer
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个泛型数组初始化器
- en: In this recipe, we will learn how to use generics. This feature is used a lot
    in languages such as C++, Java, and C# because this way, we don't need to overload
    a function for each possible type that could be used in our function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用泛型。这个特性在C++、Java和C#等语言中使用得很多，因为这样我们就不需要为函数中可能使用的每种类型重载一个函数。
- en: In this case, we will create a function that receives the input items and returns
    an array with these elements but completely shuffled.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将创建一个函数，它接收输入项并返回一个包含这些元素的数组，但完全打乱顺序。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Swift single view project called `Chapter3 Array initializer`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter3 Array initializer` 的新 Swift 单视图项目。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To create a generic array initializer, follow these steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个泛型数组初始化器，请按照以下步骤操作：
- en: 'Add a new file called `ArrayInit` and add this code into it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `ArrayInit` 的新文件，并将以下代码添加到其中：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we need to add two buttons and a text view to our storyboard to see this
    function working. So, let''s link the text view with the following property:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的故事板中添加两个按钮和一个文本视图来查看这个函数的工作情况。所以，让我们将文本视图链接到以下属性：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to create the events of each button, so add these actions
    into your view controller:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建每个按钮的事件，所以将这些操作添加到你的视图控制器中：
- en: '[PRE17]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, it's time to test our code. Run your application and press each button,
    and you should have results like these screenshots:![How to do it…](img/00036.jpeg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候测试我们的代码了。运行你的应用程序并按每个按钮，你应该得到以下截图所示的结果：![如何操作…](img/00036.jpeg)
- en: How it works…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: One advantage of object-oriented programming is avoiding the duplication of
    code. Some languages will force you to create a function for the array of strings,
    another one for the array of integers, and another new one for each new type that
    we need to use with this function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的一个优点是避免代码重复。一些语言会强制你为字符串数组创建一个函数，为整数数组创建另一个函数，以及为每个我们需要与这个函数一起使用的新类型创建另一个新函数。
- en: Fortunately, Swift allows us to create a generic function. This means that we
    only need to implement the function once and the same code will be applied each
    time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Swift 允许我们创建泛型函数。这意味着我们只需要实现一次函数，每次都会应用相同的代码。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inside the function, the arguments are treated as a constant array, but calling
    the function with an array as an argument has another meaning; the compiler will
    think that you have only one argument that is an array.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，参数被视为一个常量数组，但用数组作为参数调用函数有另一个含义；编译器会认为你只有一个参数，它是一个数组。
- en: 'This function has something different: the ellipsis that is used after the
    input argument. This means that the function is not restricted to a number of
    arguments; this has a variable number of arguments. In our case, we can call it
    with six integers and with five strings. This feature is very useful, for example,
    when creating functions to calculate the average of some numbers.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数有一些不同之处：在输入参数之后使用的省略号。这意味着该函数不受参数数量的限制；它具有可变数量的参数。在我们的例子中，我们可以用六个整数和五个字符串来调用它。这个特性非常有用，例如，在创建计算一些数字平均值的函数时。
- en: There's more…
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Overloading generic functions is allowed; it's used when there is a type that,
    for any reason, needs a different code. For example, now you can use this code
    to shuffle cards.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 允许泛型函数重载；当存在某种类型，由于任何原因需要不同的代码时，就会使用它。例如，现在你可以使用这段代码来洗牌。
- en: Creating a priority list
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建优先列表
- en: Let's imagine that we need to manage a queue of passengers on a flight. We know
    that business class should embark first, then passengers in first class, and finally,
    economy class.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们需要管理航班上的乘客队列。我们知道商务舱应该首先登机，然后是头等舱乘客，最后是经济舱乘客。
- en: This is a typical case of a priority queue, but the nagging question is, can
    we create a priority queue only once? Or should we create a new priority queue
    in every new app? An Objective-C programmer who recently arrived at Swift will
    probably create this container storing objects of the type `AnyObject`. This solution
    can be acceptable; however, Swift has a better solution that is even safer, and
    as you know, that is generics.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的优先队列案例，但一个令人烦恼的问题是，我们是否只能创建一个优先队列？或者我们应该在每一个新应用中创建一个新的优先队列？一个最近加入 Swift
    的 Objective-C 程序员可能会创建一个存储 `AnyObject` 类型对象的容器。这个解决方案可能是可以接受的；然而，Swift 有一个更好的解决方案，甚至更安全，正如你所知，那就是泛型。
- en: A priority queue needs to organize its elements using criteria. In this case,
    we can create our queue of any element but ensure that it is created for elements
    of a class that implements the `Comparable` protocol; that's what we call a type
    constraint.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列需要使用标准来组织其元素。在这种情况下，我们可以创建任何元素的队列，但确保它是为实现了 `Comparable` 协议的类的元素创建的；这就是我们所说的类型约束。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Swift single view project called `Chapter3 Flight`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter3 Flight` 的新 Swift 单视图项目。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create a priority list:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建优先列表：
- en: Add a new Swift file called `PriorityQueue.swift`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `PriorityQueue.swift` 的新 Swift 文件。
- en: 'In this file, let''s create a class with the same name. Here, we will need
    an array as an attribute to store our elements and a few methods to work with
    this queue: `enqueue` for adding a new element; `dequeue` for removing the first
    element of the queue; `size`, which returns the number of elements on our queue;
    and `toArray`, which will return the elements of our queue to an array. So, add
    the following code into your file:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，让我们创建一个具有相同名称的类。在这里，我们需要一个数组作为属性来存储我们的元素，以及一些与队列一起工作的方法：`enqueue` 用于添加新元素；`dequeue`
    用于从队列中移除第一个元素；`size` 返回队列上的元素数量；以及 `toArray`，它将队列的元素返回到一个数组中。所以，将以下代码添加到你的文件中：
- en: '[PRE18]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, create a new file called `Passenger.swift`. Here, we will define a passenger
    with his data. Remember that we need to compare the priority of a passenger. For
    this reason, this class must implement the `Comparable` protocol:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为 `Passenger.swift` 的新文件。在这里，我们将定义一个带有其数据的乘客。记住，我们需要比较乘客的优先级。因此，这个类必须实现
    `Comparable` 协议：
- en: '[PRE19]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, open your storyboard and add two text fields (one for passenger name and
    another one for his identification number and ID document), one table view to
    choose the seat type, two buttons to queue and dequeue, and a text field to display
    the current queue status. You should have a layout similar to the following one:![How
    to do it…](img/00037.jpeg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开你的故事板，添加两个文本字段（一个用于乘客姓名，另一个用于他的身份证号和身份证件），一个用于选择座位类型的表格视图，两个用于入队和出队的按钮，以及一个用于显示当前队列状态的文本字段。你应该有一个类似于以下布局：![如何做到这一点…](img/00037.jpeg)
- en: 'The next step is to open the view controller and add the protocol `UITableViewDataSource`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是打开视图控制器并添加协议 `UITableViewDataSource`：
- en: '[PRE20]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Ok, now link the corresponding components with the attribute, and beside this,
    create a passenger queue as an attribute:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，现在将相应的组件与属性链接，并且在此旁边，创建一个乘客队列作为属性：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this moment, we can start implementing the `tableview` code. As you know,
    we must implement at least two mandatory methods of `UITableViewDataSource`. Let''s
    start with the easiest one that returns the number of rows. Right now, there is
    no way to detect the number of elements of an enumeration, so we will hardcode
    this value:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个时刻，我们可以开始实现 `tableview` 代码。正如你所知，我们必须实现 `UITableViewDataSource` 至少两个强制方法。让我们从最简单的开始，即返回行数的方法。目前，我们还没有办法检测枚举元素的数量，所以我们将硬编码这个值：
- en: '[PRE22]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next step is to create the method that returns the seat type cells:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建返回座位类型单元格的方法：
- en: '[PRE23]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you click on play at this moment, you should at least see the table view
    with its values. Now, we need to create a method to display the current queue
    passengers:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在点击播放，你应该至少能看到带有其值的表格视图。现在，我们需要创建一个方法来显示当前队列乘客：
- en: '[PRE24]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we only need to create the actions for our buttons:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要为我们的按钮创建动作：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The app is done. Now, try to add different passengers and check how your queue
    grows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经完成。现在，尝试添加不同的乘客并检查你的队列如何增长。
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Generics save us from rewriting a lot of code, but as it needs to be safe, you
    can't use operators or methods that might not exist on the type that you are working
    with. To solve this problem, you can specify a constraint that will tell the compiler
    which methods are allowed to be used with this type. In our case, we specified
    that T is Comparable; so we can use the operators of Comparators on our code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型可以帮我们避免重写大量代码，但是因为它需要安全，你不能使用可能在你正在操作的类型上不存在的操作符或方法。为了解决这个问题，你可以指定一个约束，告诉编译器哪些方法可以与这个类型一起使用。在我们的例子中，我们指定了
    T 是可比较的；因此我们可以使用比较器的操作符在我们的代码中。
- en: Some new knowledge that we can retrieve from this code is the nested enumeration.
    Swift has no namespace or package, but you can create nested enumerations, classes,
    and structs. This way we can avoid clashing names.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中我们可以获取的一些新知识是嵌套枚举。Swift 没有命名空间或包，但你可以创建嵌套枚举、类和结构体。这样我们可以避免名称冲突。
- en: Another new feature is the typed enumeration; as you can see, we specified that
    each enumeration value is associated with an integer number. You can retrieve
    this value using `rawValue` or use `init(rawValue:)` to do the inverted process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新特性是类型化枚举；正如你所见，我们指定了每个枚举值都与一个整数相关联。你可以使用 `rawValue` 获取这个值，或者使用 `init(rawValue:)`
    来执行逆过程。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first version of Swift used to have a method called `toRaw()` instead of
    the property `rawValue`, and `fromRaw()` instead of using the initializer `init(rawValue:)`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的第一个版本曾经有一个名为 `toRaw()` 的方法，而不是 `rawValue` 属性，以及 `fromRaw()` 而不是使用初始化器
    `init(rawValue:)`。
- en: You can also implement your own function or computed property as we did in this
    enumeration; sometimes, it's better than using the raw value.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像我们在这个枚举中做的那样实现你自己的函数或计算属性；有时，这比使用原始值更好。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Creating your function or computed property to convert enumerations is a good
    practice for software maintenance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的函数或计算属性以转换枚举是软件维护的良好实践。
- en: There's more…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There is more than one way to solve this problem; if you need performance, you
    might use a double linked list instead.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题不止一种方法；如果你需要性能，你可能使用双链表。
- en: 'You can specify more than one constraint if you want to by using the `where`
    clause. For example, if you would like to store elements that are also `CustomStringConvertable`,
    you can change the class header to `class PriorityQueue<T:Comparable where T:
    CustomStringConvertable > {`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想要，你可以使用 `where` 子句指定多个约束。例如，如果你想存储也是 `CustomStringConvertable` 的元素，你可以将类头更改为
    `class PriorityQueue<T:Comparable where T: CustomStringConvertable > {`。'
- en: Creating a protocol for the priority queue
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为优先队列创建一个协议
- en: In the previous recipe, we created a generic code which can be used in our future
    programs, but we have to remember that priority queues are only one kind of queue.
    It is good practice to define an interface for this abstract data type, and after
    this, have different implementations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们创建了一般化的代码，可以在未来的程序中使用，但我们必须记住，优先队列只是队列的一种类型。定义这个抽象数据类型的接口是一种良好的做法，然后，有不同的实现。
- en: 'As you know, in Swift, we have protocols for cases such as this; however, we
    have a problem: protocols don''t have generics. What is the solution? The answer
    is **associated types**.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，在 Swift 中，我们有像这种情况的协议；然而，我们有一个问题：协议没有泛型。解决方案是什么？答案是 **关联类型**。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Copy the project of the previous recipe and name it `Chapter 3 Flight Protocol`,
    and create a new file called `Queue.swift`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 复制之前菜谱的项目，并将其命名为 `Chapter 3 Flight Protocol`，然后创建一个名为 `Queue.swift` 的新文件。
- en: How to do it…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a protocol for the priority queue, follow these steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要为优先队列创建一个协议，请遵循以下步骤：
- en: 'Add the following code onto the `Queue.swift` file:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Queue.swift` 文件中：
- en: '[PRE26]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, return to the priority queue and change its header to this one:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到优先队列并更改其头为以下这个：
- en: '[PRE27]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Click on play, and of course, the result is visually the same, but your code
    is now more recyclable. Try to remove one method such as `enqueue`, and you will
    see that the compiler will complain about the missing method of the protocol.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放，当然，结果在视觉上是相同的，但你的代码现在更具可重用性。尝试删除一个方法，比如 `enqueue`，你就会看到编译器会抱怨缺少协议的方法。
- en: How it works…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Unfortunately, we can't create protocols with generics, but we can solve this
    problem with associated types. You only need to create `typealias` inside the
    protocol without specifying its real type, and then, we can declare the protocol's
    methods with this type. When you inherit from this protocol, your type can be
    anything, even a generic type `T`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们无法使用泛型创建协议，但我们可以通过关联类型解决这个问题。你只需要在协议内部创建 `typealias` 而不指定其实际类型，然后，我们可以使用此类型声明协议的方法。当你从这个协议继承时，你的类型可以是任何东西，甚至是泛型类型
    `T`。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to use protocols when you have a concept such as a queue, a list, or a stack.
    Then, you can have different implementations and use the best one for the occasion.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有像队列、列表或栈这样的概念时，尽量使用协议。然后，你可以有不同的实现，并使用最适合当前场合的最佳实现。
- en: There's more…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Now that you have learned how to make reusable code with generics, you will
    improve even more in the next chapter where we will use design patterns with Swift.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用泛型制作可重用代码，你将在下一章中进一步提高，我们将使用 Swift 中的设计模式。
