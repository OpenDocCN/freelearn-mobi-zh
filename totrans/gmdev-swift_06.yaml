- en: Chapter 6. Generating a Never-Ending World
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 生成无尽世界
- en: The unique challenge of an endless flyer-style game is in procedurally generating
    a rich, entertaining game world that extends as far as your player can fly. We
    will first explore level design concepts and tooling in Xcode; Apple added a built-in
    level designer to Xcode 6, allowing developers to arrange nodes visually within
    a scene. Once we become familiar with the SpriteKit level design methodology,
    we will create a custom solution to generate our world. In this chapter, you will
    build an entertaining world for our penguin game and learn to design and implement
    levels in SpriteKit for any genre of game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无尽飞行游戏独特的挑战在于以程序方式生成丰富、有趣的游戏世界，其范围延伸到玩家可以飞行的距离。我们将首先探索Xcode中的关卡设计概念和工具；Apple在Xcode
    6中添加了一个内置关卡设计师，允许开发者在一个场景中直观地排列节点。一旦我们熟悉了SpriteKit关卡设计方法，我们将创建一个自定义解决方案来生成我们的世界。在本章中，您将为我们的企鹅游戏构建一个有趣的世界，并学习如何在SpriteKit中为任何类型的游戏设计和实现关卡。
- en: 'The topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Designing levels with the SpriteKit scene editor
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SpriteKit场景编辑器设计关卡
- en: Building encounters for Pierre Penguin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为皮埃尔企鹅构建遭遇战
- en: Integrating scenes into the game
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将场景集成到游戏中
- en: Looping encounters for a never-ending world
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为永无止境的世界循环遭遇战
- en: Adding the star power-up at random
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机添加星级提升
- en: Designing levels with the SpriteKit scene editor
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SpriteKit场景编辑器设计关卡
- en: The scene editor is a valuable addition to SpriteKit. Previously, developers
    would be forced to hardcode positional values or rely on third party tools or
    custom solutions. Now, we can lay out our levels directly within Xcode. We can
    create nodes, attach physics bodies and constraints, create physics fields, and
    edit properties directly from the interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 场景编辑器是SpriteKit的一个宝贵补充。以前，开发者被迫硬编码位置值或依赖第三方工具或自定义解决方案。现在，我们可以在Xcode中直接布局我们的关卡。我们可以创建节点，附加物理体和约束，创建物理场，并直接从界面中编辑属性。
- en: 'Feel free to experiment with the scene editor and familiarize yourself with
    its interface. To use the scene editor, add a new scene file to your game and
    then select the scene in the project navigator. Here is a simple example scene
    you might build for a platformer game:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试场景编辑器，熟悉其界面。要使用场景编辑器，请向您的游戏添加一个新的场景文件，然后在项目导航器中选择场景。以下是一个您可能为平台游戏构建的简单示例场景：
- en: '![Designing levels with the SpriteKit scene editor](img/Image_B04532_06_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用SpriteKit场景编辑器设计关卡](img/Image_B04532_06_01.jpg)'
- en: In this example, I simply dragged and positioned **Color Sprite** in the scene.
    If you are making an unsophisticated game, you can paint nodes that do not require
    texture-based animation directly within the scene editor. By editing physics bodies
    in the editor, you can even create entire physics-based games in the editor, adding
    only a few lines of code for the controls.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我只是在场景中拖动并定位了**彩色精灵**。如果您正在制作一个简单的游戏，您可以直接在场景编辑器中绘制不需要基于纹理动画的节点。通过在编辑器中编辑物理体，您甚至可以在编辑器中创建整个基于物理的游戏，只需添加几行控制代码。
- en: Complex games require custom logic and texture animation for every object, so
    we will implement a system in our penguin game that only uses the scene editor
    as a layout generation tool. We will write code to parse the layout data from
    the editor and turn it into fully functioning versions of the game classes we
    have created throughout this book. In this way, we will separate our game logic
    from our data with minimal effort.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的游戏需要为每个对象定制逻辑和纹理动画，因此我们将在我们的企鹅游戏中实现一个系统，该系统仅使用场景编辑器作为布局生成工具。我们将编写代码来解析编辑器中的布局数据，并将其转换为本书中创建的游戏类的完整功能版本。这样，我们将以最小的努力将游戏逻辑与数据分离。
- en: Separating level data from game logic
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将关卡数据与游戏逻辑分离
- en: 'Level layout is data, and it is best to separate data from code. You increase
    flexibility by separating the level data into scene files. The benefits include:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关卡布局是数据，最好将数据与代码分离。通过将关卡数据分离到场景文件中，您可以提高灵活性。其好处包括：
- en: Non-technical contributors, such as artists and designers, can add and edit
    levels without changing any code.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非技术贡献者，如艺术家和设计师，可以在不更改任何代码的情况下添加和编辑关卡。
- en: Iteration time improves since you do not need to run the game in the simulator
    each time you need to view your changes. Scene editor layouts provide immediate
    visual feedback.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代时间得到改善，因为您每次需要查看更改时不需要在模拟器中运行游戏。场景编辑器布局提供即时视觉反馈。
- en: Each level is in a unique file, which is ideal for avoiding merge conflicts
    when using source control solutions like Git.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个级别都在一个独特的文件中，这在使用像Git这样的源代码控制解决方案时避免合并冲突是理想的。
- en: Using empty nodes as placeholders
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用空节点作为占位符
- en: The scene editor lacks the ability to create reusable classes and there is no
    strongly typed method to link your code classes to scene editor nodes. Instead,
    we will use empty nodes as placeholders in the scene editor and replace them in
    the code with instances of our own classes. You will often see variations of this
    technique. For instance, the SpriteKit adventure game demo from Apple uses this
    technique for parts of its level design.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 场景编辑器缺乏创建可重用类的能力，也没有将您的代码类链接到场景编辑器节点的方法。相反，我们将使用空节点作为场景编辑器中的占位符，并在代码中使用我们自己的类的实例来替换它们。您经常会看到这种技术的变体。例如，苹果的SpriteKit冒险游戏演示使用这种技术进行其部分关卡设计。
- en: You can assign names to nodes in the scene editor and then query those names
    in your code. For example, you can create empty nodes named **Bat** in the scene
    editor, and then write code to replace every node named "Bat" with an instance
    of our `Bat` class in the `GameScene` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在场景编辑器中为节点分配名称，然后在代码中查询这些名称。例如，您可以在场景编辑器中创建名为**Bat**的空节点，然后在`GameScene`类中编写代码，将每个名为“Bat”的节点替换为我们的`Bat`类的实例。
- en: To illustrate this concept, we will create our first encounter for the penguin
    game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个概念，我们将为企鹅游戏创建我们的第一次相遇。
- en: Encounters in endless flying
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无尽飞行中的相遇
- en: Endless flyer games continue until the player loses. They do not feature distinct
    levels; instead, we will design "encounters" for our protagonist penguin to explore.
    We can create an endless world by stringing together encounters one after the
    other and randomly recycling from the beginning when we need more content.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无尽飞行动作游戏会一直进行，直到玩家失败。它们没有特定的级别；相反，我们将为我们的主角企鹅设计“相遇”。我们可以通过将一次又一次的相遇连接起来，并在需要更多内容时从开始处随机回收，来创建一个无尽的世界。
- en: 'The following image illustrates the basic concept:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像说明了基本概念：
- en: '![Encounters in endless flying](img/Image_B04532_06_10.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![无尽飞行中的相遇](img/Image_B04532_06_10.jpg)'
- en: A finished game might include 20 or more encounters to feel varied and random.
    We will create three encounters in this chapter to populate the encounter recycling
    system.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一款完成的游戏可能包含20个或更多的相遇，以感觉多样化且随机。在本章中，我们将创建三个相遇来充实相遇回收系统。
- en: We will build each encounter in its own scene file, in the same way we would
    approach a separate level in a standard platformer or physics game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像对待标准平台游戏或物理游戏中的单独关卡一样，在各自的场景文件中构建每个相遇。
- en: Creating our first encounter
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的第一次相遇
- en: First, create an encounter folder group to keep our project organized. Right-click
    your project in the project navigator and create a new group named `Encounters`.
    Then, right-click on `Encounters` and add a new SpriteKit scene file (from the
    **iOS** | **Resource** category) named `EncounterBats.sks`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个相遇文件夹组以保持我们的项目有序。在项目导航器中右键单击您的项目，创建一个名为“Encounters”的新组。然后，在“Encounters”上右键单击，并添加一个名为`EncounterBats.sks`的新SpriteKit场景文件（从**iOS**
    | **资源**类别）。
- en: Xcode will add the new scene file to your project and open the scene editor.
    You should see a gray background with a yellow border, indicating the boundaries
    of the new scene. Scenes default to 1024 points wide by 768 points tall. We should
    change these values. It will be easy to chain encounters together if each encounter
    is 1000 pixels wide and 650 points tall.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode会将新的场景文件添加到您的项目中，并打开场景编辑器。您应该看到一个灰色背景和黄色边框，指示新场景的边界。场景默认宽度为1024点，高度为768点。我们应该更改这些值。如果每个相遇宽度为1000像素，高度为650点，那么将它们连接起来会更容易。
- en: 'You can easily change the scene''s size values in the SKNode inspector. Towards
    the upper right of the scene editor, make sure you have the SKNode inspector open
    by selecting the far right icon, and then change the width and height, as shown
    in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地在SKNode检查器中更改场景的大小值。在场景编辑器的右上角，确保您已通过选择最右边的图标打开SKNode检查器，然后更改宽度和高度，如下面的截图所示：
- en: '![Creating our first encounter](img/Image_B04532_06_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的第一次相遇](img/Image_B04532_06_02.jpg)'
- en: 'Next, we will create our first placeholder node for the `Bat` class. Follow
    these steps to create an **Empty Node** in the scene editor:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为`Bat`类创建第一个占位符节点。按照以下步骤在场景编辑器中创建一个**空节点**：
- en: You can drag nodes from the object library. To open the object library, look
    towards the lower right side of the scene editor and select the circular icon,
    as shown in the following screenshot:![Creating our first encounter](img/Image_B04532_06_03.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从对象库中拖动节点。要打开对象库，请看向场景编辑器的右下角并选择圆形图标，如图所示：![创建我们的第一个遭遇](img/Image_B04532_06_03.jpg)
- en: Drag an **Empty Node** onto your scene.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**空节点**拖动到你的场景中。
- en: Using the SKNode inspector on the upper right side, name your node `Bat`, as
    shown in this screenshot:![Creating our first encounter](img/Image_B04532_06_04.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用右上角的SKNode检查器，将你的节点命名为`Bat`，如图所示：![创建我们的第一个遭遇](img/Image_B04532_06_04.jpg)
- en: 'You will see **Bat** appear above the Empty Node. Great, we have created our
    first placeholder. We will repeat this process until we have built an entire encounter
    for Pierre Penguin to navigate. We can use more than just bats, but we need to
    first define the names we will use to label each node. If you are making games
    in a team, you will want to agree on labels beforehand. Here are the labels I
    will use for each game object:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到**蝙蝠**出现在空节点上方。太好了，我们已经创建了一个占位符。我们将重复此过程，直到为皮埃尔企鹅构建一个完整的遭遇。我们不仅可以使用蝙蝠，但我们需要首先定义我们将用于标记每个节点的名称。如果你是在团队中制作游戏，你将想要事先达成一致。以下是我将用于每个游戏对象的标签：
- en: '| Game object class | Scene editor node name |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 游戏对象类 | 场景编辑器节点名称 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Bat` | Bat |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `Bat` | 蝙蝠 |'
- en: '| `Bee` | Bee |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `Bee` | 蜜蜂 |'
- en: '| `Blade` | Blade |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `Blade` | 刀片 |'
- en: '| `Coin` (bronze) | BronzeCoin |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `Coin` (bronze) | 青铜币 |'
- en: '| `Coin` (gold) | GoldCoin |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `Coin` (gold) | 金币 |'
- en: '| `Ghost` | Ghost |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `Ghost` | 幽灵 |'
- en: '| `MadFly` | MadFly |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `MadFly` | 疯狂飞虫 |'
- en: Feel free to build out your bat encounter. Add more empty nodes and use the
    labels until you are satisfied with the design. Try to picture the penguin character
    flying through the encounter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随意构建你的蝙蝠遭遇。添加更多空节点，并使用标签，直到你对设计满意为止。试着想象企鹅角色在遭遇中飞翔。
- en: 'In my encounter, I created an easier path through the bats, filled with bronze
    coins, and a more difficult path below the bats and above a blade, filled with
    gold coins. You can use my bat encounter, shown in the following image, for inspiration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的遭遇中，我创建了一条通过蝙蝠的简单路径，路径上布满了青铜币，以及一条在蝙蝠下方和刀片上方的更难路径，路径上布满了金币。你可以使用以下图像中的我的蝙蝠遭遇作为灵感：
- en: '![Creating our first encounter](img/Image_B04532_06_05.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建我们的第一个遭遇](img/Image_B04532_06_05.jpg)'
- en: Integrating scenes into the game
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将场景集成到游戏中
- en: 'Next, we will create a new class to manage the encounters in our game. Add
    a new Swift file to your project and name it `EncounterManager.swift`. The `EncounterManager`
    class will loop through our encounter scenes and use the positional data to create
    the appropriate game object classes in the game world. Add the following code
    inside the new file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的类来管理我们游戏中的遭遇。将一个新的Swift文件添加到你的项目中，并将其命名为`EncounterManager.swift`。`EncounterManager`类将遍历我们的遭遇场景，并使用位置数据在游戏世界中创建适当的游戏对象类。在新的文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Great, you just added the functionality to use our scene file data inside the
    game world. Next, follow these steps to wire up the `EncounterManager` class in
    the `GameScene` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你刚刚添加了在游戏世界中使用我们的场景文件数据的功能。接下来，按照以下步骤在`GameScene`类中连接`EncounterManager`类：
- en: 'Add a new instance of the `EncounterManager` class as a constant on the `GameScene`
    class:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameScene`类上添加`EncounterManager`类的新实例作为常量：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At the bottom of the `didMoveToView` function, call `addEncountersToWorld`
    to add each encounter node as a child of the `GameScene` class world node:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`didMoveToView`函数的底部，调用`addEncountersToWorld`以将每个遭遇节点作为`GameScene`类世界节点的子节点添加：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the `EncounterManager` class spawns encounters far off the screen, we
    will temporarily move our first encounter directly in front of the starting player
    position to test our code. Add this line in the `didMoveToView` function:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`EncounterManager`类在屏幕外生成遭遇，我们将暂时将我们的第一个遭遇直接移动到起始玩家位置以测试我们的代码。在`didMoveToView`函数中添加此行：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the project. You will see Pierre flying through your new bat encounter.
    Your game should look something like this screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你将看到皮埃尔在新的蝙蝠遭遇中飞翔。你的游戏应该看起来像以下截图：
- en: '![Integrating scenes into the game](img/Image_B04532_06_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![将场景集成到游戏中](img/Image_B04532_06_06.jpg)'
- en: Congratulations, you have implemented the core functionality of using placeholder
    nodes in the scene editor. You can remove the line that positions this encounter
    at the beginning of the game, which we added in step 3\. Next, we will create
    a system that repositions each encounter ahead of Pierre Penguin.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经实现了在场景编辑器中使用占位符节点的核心功能。你可以移除在步骤 3 中添加的定位这个遭遇的行，即添加到遭遇数组中的行（加粗的新行）。接下来，我们将创建一个系统，在皮埃尔企鹅之前重新定位每个遭遇。
- en: Checkpoint 6-A
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 6-A
- en: 'You can download my project to this point at this URL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这个 URL 下载到这个点的我的项目：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-6](http://www.thinkingswiftly.com/game-development-with-swift/chapter-6)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-6](http://www.thinkingswiftly.com/game-development-with-swift/chapter-6)'
- en: Spawning endless encounters
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成无限遭遇
- en: We need at least three encounters to endlessly cycle and create a never-ending
    world; two can be on the screen at any one time and a third positioned ahead of
    the player. We can track Pierre's progress and reposition the encounter nodes
    ahead of him.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至少需要三个遭遇来无限循环并创建一个永无止境的世界；任何时候可以有任意两个在屏幕上，第三个在玩家前方。我们可以跟踪皮埃尔的进度并重新定位他前方的遭遇节点。
- en: Building more encounters
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建更多遭遇
- en: 'We need to build at least two more encounters before we can implement the repositioning
    system. You can create more if you like; the system will support any number of
    encounters. For now, add two more scene files to your game: `EncounterBees.sks`
    and `EncounterCoins.sks`. You can completely fill these encounters with bees,
    ghosts, blades, coins, and bats – have fun!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以实现重新定位系统之前，我们需要构建至少两个更多的遭遇。如果你愿意，可以创建更多；系统将支持任意数量的遭遇。现在，向你的游戏中添加两个额外的场景文件：`EncounterBees.sks`
    和 `EncounterCoins.sks`。你可以完全用蜜蜂、幽灵、刀片、金币和蝙蝠填充这些遭遇——享受乐趣吧！
- en: 'For inspiration, here is my bee encounter:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得灵感，这里是我的蜜蜂遭遇经历：
- en: '![Building more encounters](img/Image_B04532_06_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![构建更多遭遇](img/Image_B04532_06_07.jpg)'
- en: 'Here is my coin encounter:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我的金币遭遇：
- en: '![Building more encounters](img/Image_B04532_06_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![构建更多遭遇](img/Image_B04532_06_08.jpg)'
- en: Updating the EncounterManager class
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 EncounterManager 类
- en: 'We have to let the `EncounterManager` class know about these new encounters.
    Open the `EncounterManager.swift` file and add the new encounter names to the
    `encounterNames` constant:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须让 `EncounterManager` 类了解这些新的遭遇。打开 `EncounterManager.swift` 文件并将新的遭遇名称添加到
    `encounterNames` 常量中：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We also need to keep track of the encounters that can potentially be on the
    screen at any given time. Add two new properties to the `EncounterManager` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要跟踪在任意给定时间可能出现在屏幕上的遭遇。向 `EncounterManager` 类添加两个新属性：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Storing metadata in SKSpriteNode userData property
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 SKSpriteNode 的 userData 属性中存储元数据
- en: We are going to recycle the encounter nodes as Pierre moves through the world,
    so we need to add the functionality to reset all of the game objects in an encounter
    before placing it in front of the player. Otherwise, Pierre's previous trips through
    the encounter would knock nodes out of place.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当皮埃尔在世界中移动时，我们将回收遭遇节点，因此我们需要在将其放置在玩家前方之前重置遭遇中的所有游戏对象的功能。否则，皮埃尔之前的遭遇之旅可能会将节点移位。
- en: 'The `SKSpriteNode` class provides a property named `userData` that we can use
    to store any miscellaneous data about the sprite. We will use the `userData` property
    to store the initial position of each sprite in the encounter so we can reset
    the sprites when we reposition an encounter. Add these two new functions to the
    `EncounterManager` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKSpriteNode` 类提供了一个名为 `userData` 的属性，我们可以用它来存储有关精灵的任何杂项数据。我们将使用 `userData`
    属性来存储遭遇中每个精灵的初始位置，这样我们就可以在重新定位遭遇时重置精灵。向 `EncounterManager` 类添加这两个新函数：'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We want to call our new `saveSpritePositions` function on `init`, when we are
    first spawning the encounters. Update the `init` function of `EncounterManager`,
    below the line that appends the encounter node to the encounters array (the new
    line in bold):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在 `init` 时调用我们的新 `saveSpritePositions` 函数，当我们首次生成遭遇时。更新 `EncounterManager`
    的 `init` 函数，在将遭遇节点添加到遭遇数组中的行下面（加粗的新行）：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Lastly, we need a function to reset encounters and reposition them in front
    of the player. Add this new function to the `EncounterManager` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个函数来重置遭遇并在玩家前方重新定位它们。向 `EncounterManager` 类添加这个新函数：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Wiring up EncounterManager in the GameScene class
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 GameScene 类中连接 EncounterManager
- en: 'We will track Pierre''s progress in the `GameScene` class and call the `EncounterManager`
    class code when appropriate. Follow these steps to wire up the `EncounterManager`
    class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `GameScene` 类中跟踪皮埃尔的进度，并在适当的时候调用 `EncounterManager` 类代码。按照以下步骤连接 `EncounterManager`
    类：
- en: 'Add a new property to the `GameScene` class to track when we should next position
    an encounter in front of the player. We will start with a value of `150` to spawn
    the first encounter right away:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GameScene` 类添加一个新属性，以跟踪何时在玩家前方定位下一次遭遇。我们将从 `150` 开始，以便立即生成第一个遭遇：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we simply need to check if the player moves past this position in the
    `didSimulatePhysics` function. Add this code at the bottom of `didSimulatePhysics`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需在 `didSimulatePhysics` 函数中检查玩家是否移动到这个位置。在 `didSimulatePhysics` 的底部添加此代码：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fantastic – we have added all the functionality we need for endlessly looping
    encounters in front of the player. Run the project. You should see your encounters
    looping in front of you forever. Enjoy flying through your hard work!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了 - 我们已经添加了所有需要的功能，以在玩家前方无限循环遭遇。运行项目。你应该会看到你的遭遇无限循环在你面前。享受飞越你的辛勤工作！
- en: Spawning the star power-up at random
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在随机位置生成星力升级
- en: 'We still need to add the star power-up into the world. We can randomly spawn
    a star every 10 encounters to add some extra excitement. Follow these steps to
    add the star logic:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将星力升级添加到世界中。我们可以随机在每 10 次遭遇中生成一个星力，以增加一些额外的兴奋感。按照以下步骤添加星力逻辑：
- en: 'Add a new instance of the `Star` class as a constant on the `GameScene` class:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene` 类中添加 `Star` 类的新实例作为常量：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call the star''s `spawn` function, anywhere inside the `GameScene didMoveToView`
    function:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene didMoveToView` 函数的任何地方调用星力的 `spawn` 函数：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Inside the `GameScene didSimulatePhysics` function, update your new encounter
    code as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene didSimulatePhysics` 函数中，按照以下方式更新你的新遭遇代码：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the game again and you should see a star spawn occasionally inside your
    encounters, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你应该会看到星力偶尔在遭遇中生成，如下面的截图所示：
- en: '![Spawning the star power-up at random](img/Image_B04532_06_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![在随机位置生成星力升级](img/Image_B04532_06_09.jpg)'
- en: Checkpoint 6-B
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 6-B
- en: 'To download my project to this point, visit this URL:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载到这一点的我的项目，请访问此 URL：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-6](http://www.thinkingswiftly.com/game-development-with-swift/chapter-6)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-6](http://www.thinkingswiftly.com/game-development-with-swift/chapter-6)'
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Great job – we have covered a lot of ground in this chapter. You learned about
    Xcode's new scene editor, learned to use the scene editor to lay out placeholder
    nodes, and interpreted the node data to spawn game objects in our game world.
    Then, you created a system to loop encounters for our endless flyer game.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好 - 我们在本章中覆盖了大量的内容。你了解了 Xcode 的新场景编辑器，学会了如何使用场景编辑器来布局占位符节点，并解释了节点数据以在游戏世界中生成游戏对象。然后，你创建了一个系统来循环我们的无尽飞行游戏中的遭遇。
- en: Congratulate yourself; the encounter system you built in this chapter is the
    most complex system in our game. You are officially in a great position to finish
    your first SpriteKit game!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你；在本章中构建的遭遇系统是我们游戏中最复杂的系统。你现在正式处于一个很好的位置来完成你的第一个 SpriteKit 游戏！
- en: Next, we will look at creating custom events when game objects collide. We will
    add health, damage, coin pick-up, invincibility, and more in [Chapter 7](ch07.html
    "Chapter 7. Implementing Collision Events"), *Implementing Collision Events*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨在游戏对象碰撞时创建自定义事件。我们将在第 7 章 [实现碰撞事件](ch07.html "第 7 章。实现碰撞事件") 中添加健康、伤害、金币拾取、无敌状态等功能。
