- en: Chapter 6. Generating a Never-Ending World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unique challenge of an endless flyer-style game is in procedurally generating
    a rich, entertaining game world that extends as far as your player can fly. We
    will first explore level design concepts and tooling in Xcode; Apple added a built-in
    level designer to Xcode 6, allowing developers to arrange nodes visually within
    a scene. Once we become familiar with the SpriteKit level design methodology,
    we will create a custom solution to generate our world. In this chapter, you will
    build an entertaining world for our penguin game and learn to design and implement
    levels in SpriteKit for any genre of game.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing levels with the SpriteKit scene editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building encounters for Pierre Penguin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating scenes into the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looping encounters for a never-ending world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the star power-up at random
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing levels with the SpriteKit scene editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scene editor is a valuable addition to SpriteKit. Previously, developers
    would be forced to hardcode positional values or rely on third party tools or
    custom solutions. Now, we can lay out our levels directly within Xcode. We can
    create nodes, attach physics bodies and constraints, create physics fields, and
    edit properties directly from the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to experiment with the scene editor and familiarize yourself with
    its interface. To use the scene editor, add a new scene file to your game and
    then select the scene in the project navigator. Here is a simple example scene
    you might build for a platformer game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing levels with the SpriteKit scene editor](img/Image_B04532_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, I simply dragged and positioned **Color Sprite** in the scene.
    If you are making an unsophisticated game, you can paint nodes that do not require
    texture-based animation directly within the scene editor. By editing physics bodies
    in the editor, you can even create entire physics-based games in the editor, adding
    only a few lines of code for the controls.
  prefs: []
  type: TYPE_NORMAL
- en: Complex games require custom logic and texture animation for every object, so
    we will implement a system in our penguin game that only uses the scene editor
    as a layout generation tool. We will write code to parse the layout data from
    the editor and turn it into fully functioning versions of the game classes we
    have created throughout this book. In this way, we will separate our game logic
    from our data with minimal effort.
  prefs: []
  type: TYPE_NORMAL
- en: Separating level data from game logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Level layout is data, and it is best to separate data from code. You increase
    flexibility by separating the level data into scene files. The benefits include:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-technical contributors, such as artists and designers, can add and edit
    levels without changing any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration time improves since you do not need to run the game in the simulator
    each time you need to view your changes. Scene editor layouts provide immediate
    visual feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each level is in a unique file, which is ideal for avoiding merge conflicts
    when using source control solutions like Git.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using empty nodes as placeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The scene editor lacks the ability to create reusable classes and there is no
    strongly typed method to link your code classes to scene editor nodes. Instead,
    we will use empty nodes as placeholders in the scene editor and replace them in
    the code with instances of our own classes. You will often see variations of this
    technique. For instance, the SpriteKit adventure game demo from Apple uses this
    technique for parts of its level design.
  prefs: []
  type: TYPE_NORMAL
- en: You can assign names to nodes in the scene editor and then query those names
    in your code. For example, you can create empty nodes named **Bat** in the scene
    editor, and then write code to replace every node named "Bat" with an instance
    of our `Bat` class in the `GameScene` class.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this concept, we will create our first encounter for the penguin
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Encounters in endless flying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Endless flyer games continue until the player loses. They do not feature distinct
    levels; instead, we will design "encounters" for our protagonist penguin to explore.
    We can create an endless world by stringing together encounters one after the
    other and randomly recycling from the beginning when we need more content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates the basic concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Encounters in endless flying](img/Image_B04532_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A finished game might include 20 or more encounters to feel varied and random.
    We will create three encounters in this chapter to populate the encounter recycling
    system.
  prefs: []
  type: TYPE_NORMAL
- en: We will build each encounter in its own scene file, in the same way we would
    approach a separate level in a standard platformer or physics game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first encounter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, create an encounter folder group to keep our project organized. Right-click
    your project in the project navigator and create a new group named `Encounters`.
    Then, right-click on `Encounters` and add a new SpriteKit scene file (from the
    **iOS** | **Resource** category) named `EncounterBats.sks`.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode will add the new scene file to your project and open the scene editor.
    You should see a gray background with a yellow border, indicating the boundaries
    of the new scene. Scenes default to 1024 points wide by 768 points tall. We should
    change these values. It will be easy to chain encounters together if each encounter
    is 1000 pixels wide and 650 points tall.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily change the scene''s size values in the SKNode inspector. Towards
    the upper right of the scene editor, make sure you have the SKNode inspector open
    by selecting the far right icon, and then change the width and height, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our first encounter](img/Image_B04532_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create our first placeholder node for the `Bat` class. Follow
    these steps to create an **Empty Node** in the scene editor:'
  prefs: []
  type: TYPE_NORMAL
- en: You can drag nodes from the object library. To open the object library, look
    towards the lower right side of the scene editor and select the circular icon,
    as shown in the following screenshot:![Creating our first encounter](img/Image_B04532_06_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag an **Empty Node** onto your scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the SKNode inspector on the upper right side, name your node `Bat`, as
    shown in this screenshot:![Creating our first encounter](img/Image_B04532_06_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see **Bat** appear above the Empty Node. Great, we have created our
    first placeholder. We will repeat this process until we have built an entire encounter
    for Pierre Penguin to navigate. We can use more than just bats, but we need to
    first define the names we will use to label each node. If you are making games
    in a team, you will want to agree on labels beforehand. Here are the labels I
    will use for each game object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Game object class | Scene editor node name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Bat` | Bat |'
  prefs: []
  type: TYPE_TB
- en: '| `Bee` | Bee |'
  prefs: []
  type: TYPE_TB
- en: '| `Blade` | Blade |'
  prefs: []
  type: TYPE_TB
- en: '| `Coin` (bronze) | BronzeCoin |'
  prefs: []
  type: TYPE_TB
- en: '| `Coin` (gold) | GoldCoin |'
  prefs: []
  type: TYPE_TB
- en: '| `Ghost` | Ghost |'
  prefs: []
  type: TYPE_TB
- en: '| `MadFly` | MadFly |'
  prefs: []
  type: TYPE_TB
- en: Feel free to build out your bat encounter. Add more empty nodes and use the
    labels until you are satisfied with the design. Try to picture the penguin character
    flying through the encounter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my encounter, I created an easier path through the bats, filled with bronze
    coins, and a more difficult path below the bats and above a blade, filled with
    gold coins. You can use my bat encounter, shown in the following image, for inspiration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our first encounter](img/Image_B04532_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Integrating scenes into the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will create a new class to manage the encounters in our game. Add
    a new Swift file to your project and name it `EncounterManager.swift`. The `EncounterManager`
    class will loop through our encounter scenes and use the positional data to create
    the appropriate game object classes in the game world. Add the following code
    inside the new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, you just added the functionality to use our scene file data inside the
    game world. Next, follow these steps to wire up the `EncounterManager` class in
    the `GameScene` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new instance of the `EncounterManager` class as a constant on the `GameScene`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom of the `didMoveToView` function, call `addEncountersToWorld`
    to add each encounter node as a child of the `GameScene` class world node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the `EncounterManager` class spawns encounters far off the screen, we
    will temporarily move our first encounter directly in front of the starting player
    position to test our code. Add this line in the `didMoveToView` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project. You will see Pierre flying through your new bat encounter.
    Your game should look something like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating scenes into the game](img/Image_B04532_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations, you have implemented the core functionality of using placeholder
    nodes in the scene editor. You can remove the line that positions this encounter
    at the beginning of the game, which we added in step 3\. Next, we will create
    a system that repositions each encounter ahead of Pierre Penguin.
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoint 6-A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download my project to this point at this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-6](http://www.thinkingswiftly.com/game-development-with-swift/chapter-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning endless encounters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need at least three encounters to endlessly cycle and create a never-ending
    world; two can be on the screen at any one time and a third positioned ahead of
    the player. We can track Pierre's progress and reposition the encounter nodes
    ahead of him.
  prefs: []
  type: TYPE_NORMAL
- en: Building more encounters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to build at least two more encounters before we can implement the repositioning
    system. You can create more if you like; the system will support any number of
    encounters. For now, add two more scene files to your game: `EncounterBees.sks`
    and `EncounterCoins.sks`. You can completely fill these encounters with bees,
    ghosts, blades, coins, and bats – have fun!'
  prefs: []
  type: TYPE_NORMAL
- en: 'For inspiration, here is my bee encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building more encounters](img/Image_B04532_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is my coin encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building more encounters](img/Image_B04532_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Updating the EncounterManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to let the `EncounterManager` class know about these new encounters.
    Open the `EncounterManager.swift` file and add the new encounter names to the
    `encounterNames` constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to keep track of the encounters that can potentially be on the
    screen at any given time. Add two new properties to the `EncounterManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Storing metadata in SKSpriteNode userData property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to recycle the encounter nodes as Pierre moves through the world,
    so we need to add the functionality to reset all of the game objects in an encounter
    before placing it in front of the player. Otherwise, Pierre's previous trips through
    the encounter would knock nodes out of place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SKSpriteNode` class provides a property named `userData` that we can use
    to store any miscellaneous data about the sprite. We will use the `userData` property
    to store the initial position of each sprite in the encounter so we can reset
    the sprites when we reposition an encounter. Add these two new functions to the
    `EncounterManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to call our new `saveSpritePositions` function on `init`, when we are
    first spawning the encounters. Update the `init` function of `EncounterManager`,
    below the line that appends the encounter node to the encounters array (the new
    line in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need a function to reset encounters and reposition them in front
    of the player. Add this new function to the `EncounterManager` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Wiring up EncounterManager in the GameScene class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will track Pierre''s progress in the `GameScene` class and call the `EncounterManager`
    class code when appropriate. Follow these steps to wire up the `EncounterManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new property to the `GameScene` class to track when we should next position
    an encounter in front of the player. We will start with a value of `150` to spawn
    the first encounter right away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we simply need to check if the player moves past this position in the
    `didSimulatePhysics` function. Add this code at the bottom of `didSimulatePhysics`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fantastic – we have added all the functionality we need for endlessly looping
    encounters in front of the player. Run the project. You should see your encounters
    looping in front of you forever. Enjoy flying through your hard work!
  prefs: []
  type: TYPE_NORMAL
- en: Spawning the star power-up at random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We still need to add the star power-up into the world. We can randomly spawn
    a star every 10 encounters to add some extra excitement. Follow these steps to
    add the star logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new instance of the `Star` class as a constant on the `GameScene` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the star''s `spawn` function, anywhere inside the `GameScene didMoveToView`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `GameScene didSimulatePhysics` function, update your new encounter
    code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the game again and you should see a star spawn occasionally inside your
    encounters, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spawning the star power-up at random](img/Image_B04532_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checkpoint 6-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To download my project to this point, visit this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-6](http://www.thinkingswiftly.com/game-development-with-swift/chapter-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great job – we have covered a lot of ground in this chapter. You learned about
    Xcode's new scene editor, learned to use the scene editor to lay out placeholder
    nodes, and interpreted the node data to spawn game objects in our game world.
    Then, you created a system to loop encounters for our endless flyer game.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulate yourself; the encounter system you built in this chapter is the
    most complex system in our game. You are officially in a great position to finish
    your first SpriteKit game!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at creating custom events when game objects collide. We will
    add health, damage, coin pick-up, invincibility, and more in [Chapter 7](ch07.html
    "Chapter 7. Implementing Collision Events"), *Implementing Collision Events*.
  prefs: []
  type: TYPE_NORMAL
