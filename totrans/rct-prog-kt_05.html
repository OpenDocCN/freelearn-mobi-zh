<html><head></head><body>
        

                            
                    <h1 class="header-title">Asynchronous Data Operators and Transformations</h1>
                
            
            
                
<p>Through the previous chapters, we got a strong grip on the producer (Observable and Flowable) and consumer (Observer and Subscriber). While learning them, we used the <kbd>map</kbd> method a lot. As already mentioned, the <kbd>map</kbd> method is actually an Rx-Operator. There are also a number of operators in RxKotlin. I can guess you have an itching question in your mind from the very first time we used the <kbd>map</kbd> operator. Why do we call it an operator when it looks like a method? Well, in this chapter, we will first try to answer this question by defining RxKotlin operators. We will then take a deeper look at the various operators available and their implementations. With the help of operators, we will transform, accumulate, map, group, and filter our data efficiently and with ease.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Operator</h1>
                
            
            
                
<p>When we started with programming for the first time, we learned about operators. We learned that operators are those special characters/sequence of characters that perform some specific tasks on the operands and return the final results. In the reactive world, the definition remains merely the same; they take one or more Observable/Flowable as operands, transform them, and return the resultant Observable/Flowable.</p>
<p>Operators work such as a consumer to the preceding Observable/Flowable, listen to their emissions, transform them, and emit them to the downstream consumer. For instance, think of the <kbd>map</kbd> operator, it listens to the upstream producer, performs some operations on their emissions, and then emits those modified items to the downstream.</p>
<p>Operators help us leverage and express business logic and behaviors. There are a lot of operators available with RxKotlin. Throughout this book, we will be covering various types of operators comprehensively so that you know when to use which operator.</p>
<p>Remember, to implement business logic and behavior in your applications, you should use operators instead of writing blocking code or mixing imperative programming with reactive programming. By keeping algorithms and processes purely reactive, you can easily leverage lower memory usage, flexible concurrency, and disposability, which are reduced or not achieved if you mix reactive programming with imperative programming.</p>
<p>These are the five types of operators:</p>
<ul>
<li><kbd>Filtering</kbd>/<kbd>suppressing</kbd> operators</li>
<li>Transforming operators</li>
<li>Reducing operators</li>
<li>Collection operators</li>
<li>Error handling operators</li>
<li>Utility operators</li>
</ul>
<p>So, now, let's take a closer look at them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The filtering/suppressing operators</h1>
                
            
            
                
<p>Think of a situation when you want to receive some emissions from the producer but want to discard the rest. There may be some logic to determine the qualifying emissions, or you may even wish to discard in bulk. The <kbd>filtering</kbd>/<kbd>suppressing</kbd> operators are there to help you in these situations.</p>
<p>Here is a brief list of <kbd>filtering</kbd>/<kbd>suppressing</kbd> operators:</p>
<ul>
<li><kbd>debounce</kbd></li>
<li><kbd>distinct</kbd> and <kbd>distinctUntilChanged</kbd></li>
<li><kbd>elementAt</kbd></li>
<li><kbd>Filter</kbd></li>
<li><kbd>first</kbd> and <kbd>last</kbd></li>
<li><kbd>ignoreElements</kbd></li>
<li><kbd>skip</kbd>, <kbd>skipLast</kbd>, <kbd>skipUntil</kbd>, and <kbd>skipWhile</kbd></li>
<li><kbd>take</kbd>, <kbd>takeLast</kbd>, <kbd>takeUntil</kbd>, and <kbd>takeWhile</kbd></li>
</ul>
<p>Let's now take a closer look at all of them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The debounce operator</h1>
                
            
            
                
<p>Think of a situation where you're receiving emissions rapidly, and are willing to take the last one after taking some time to be sure about it.</p>
<p>When developing an application UI/UX, we often come to such a situation. For example, you have created a text input and are willing to perform some operation when the user types something, but you don't want to perform this operation on each keystroke. You would like to wait a little bit for the user to stop typing (so you've got a good query matching what the user actually wants) and then send it to the downstream operator. The <kbd>debounce</kbd> operator serves that exact purpose.</p>
<p>For the sake of simplicity, we will not use any UI/UX code of any platform here (we will definitely try that in the later chapters while learning to implement RxKotlin in Android). Rather, we will try to simulate this using the <kbd>Observable.create</kbd> method (if you have any doubt about the <kbd>Observable.create</kbd> method, then rush to <a href="135f52d1-f19c-4f88-9299-d3c5bcec4898.xhtml" target="_blank">Chapter 3</a>, <em>Observables, Observers, and Subjects</em> before this). Please refer to the following code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      createObservable()//(1) 
        .debounce(200, TimeUnit.MILLISECONDS)//(2) 
        .subscribe { 
           println(it)//(3) 
         } 
    } 
 
    inline fun createObservable():Observable&lt;String&gt; = <br/>    Observable.create&lt;String&gt; { 
      it.onNext("R")//(4) 
      runBlocking { delay(100) }//(5) 
      it.onNext("Re") 
      it.onNext("Reac") 
      runBlocking { delay(130) } 
      it.onNext("Reactiv") 
      runBlocking { delay(140) } 
      it.onNext("Reactive") 
      runBlocking { delay(250) }//(6) 
      it.onNext("Reactive P") 
      runBlocking { delay(130) } 
      it.onNext("Reactive Pro") 
      runBlocking { delay(100) } 
      it.onNext("Reactive Progra") 
      runBlocking { delay(100) } 
      it.onNext("Reactive Programming") 
      runBlocking { delay(300) } 
      it.onNext("Reactive Programming in") 
      runBlocking { delay(100) } 
      it.onNext("Reactive Programming in Ko") 
      runBlocking { delay(150) } 
      it.onNext("Reactive Programming in Kotlin") 
      runBlocking { delay(250) } 
      it.onComplete() 
    } </pre>
<p>In this program, we tried to keep the <kbd>main</kbd> function clean by exporting the Observable creation to another function (<kbd>createObservable()</kbd>) to help you understand better. On comment <kbd>(1)</kbd>, we called the <kbd>createObservable()</kbd> function to create an <kbd>Observable</kbd> instance.</p>
<p>Inside the <kbd>createObservable()</kbd> function, we tried to simulate user typing behavior by emitting a series of incremental <kbd>Strings</kbd> with intervals, until it reached the final version (<kbd>Reactive Programming in Kotlin</kbd>). We provided bigger intervals after completing each word depicting an ideal user behavior.</p>
<p>On comment <kbd>(2)</kbd>, we used the <kbd>debounce()</kbd> operator with <kbd>200</kbd> and <kbd>TimeUnit.MILLISECONDS</kbd> as parameters that'll make the downstream wait for <kbd>200</kbd> milliseconds after each emission and take the emissions only if no other emissions occurred in between.</p>
<p>The output is as follows:</p>
<div><img class=" image-border" src="img/4540fae7-df2a-4d25-880f-dd62549e8fee.png"/></div>
<p>Observer receives only three emits, after which the Observable took at least <kbd>200</kbd> milliseconds before emitting the next one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The distinct operators – distinct, distinctUntilChanged</h1>
                
            
            
                
<p>This operator is quite simple; it helps you filter duplicate emissions from the upstream. Take a look at the following example for better understanding:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      listOf(1,2,2,3,4,5,5,5,6,7,8,9,3,10)//(1) 
        .toObservable()//(2) 
        .distinct()//(3) 
        .subscribe { println("Received $it") }//(4) 
   } </pre>
<p>On comment <kbd>(1)</kbd>, we created a list of <kbd>Int</kbd> containing many duplicate values. On comment <kbd>(2)</kbd>, we created an <kbd>Observable</kbd> instance from that <kbd>list</kbd> with the help of the <kbd>toObservable()</kbd> method. On comment <kbd>(3)</kbd>, we used the <kbd>distinct</kbd> operator to filter out all duplicate emissions.</p>
<p>Here is the output:</p>
<div><img class=" image-border" src="img/54af4bd8-4f6c-4d89-bbc6-e62afe8a6bbd.png"/></div>
<p>What the <kbd>distinct</kbd> operator does is remember all the emissions that took place and filters any such emissions in future.</p>
<p>The <kbd>distinctUntilChange</kbd> operator is slightly different. Instead of discarding all duplicate emissions, it discards only consecutive duplicate emissions, keeping the rest at its place. Please, refer to the following code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      listOf(1,2,2,3,4,5,5,5,6,7,8,9,3,10)//(1) 
        .toObservable()//(2) 
        .distinctUntilChanged()//(3) 
        .subscribe { println("Received $it") }//(4) 
    } </pre>
<p>Here is the output:</p>
<div><img class=" image-border" src="img/5101ede1-6cf2-418b-a576-acdf7d35f4d6.png"/></div>
<p>Take a cautious look at the output; item <kbd>3</kbd> is printed twice, second time after <kbd>9</kbd>. The <kbd>distinct</kbd> operator remembers each item until it receives <kbd>onComplete</kbd>, but the <kbd>distinctUntilChanged</kbd> operator remembers them only until it receives a new item.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The elementAt operator</h1>
                
            
            
                
<p>With imperative programming, we have the ability to access the <em>n<sup>th</sup></em> element of any array/list, which is quite a common requirement. The <kbd>elementAt</kbd> operator is really helpful in this regard; it pulls the <em>n<sup>th</sup></em> element from the producer and emits it as its own sole emission.</p>
<p>Take a look at the following piece of code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = listOf(10,1,2,5,8,6,9) 
        .toObservable() 
 
      observable.elementAt(5)//(1) 
        .subscribe { println("Received $it") } 
 
      observable.elementAt(50)//(2) 
        .subscribe { println("Received $it") } 
    } </pre>
<p>Take a look at the following output before we continue to inspect the code:</p>
<div><img height="78" width="331" class=" image-border" src="img/813c056d-4e54-40ba-ab4b-970e676d76d4.png"/></div>
<p>On comment <kbd>(1)</kbd>, we requested the <kbd>5</kbd><sup>th</sup> element from <kbd>Observable</kbd>, and it emitted the same (count starts with zero). However, on comment <kbd>(2)</kbd>, we requested the <kbd>50</kbd><sup>th</sup> element, which doesn't even exist in <kbd>Observable</kbd>, so it didn't emit anything.</p>
<p>This operator achieves this behavior with the help of the <kbd>Maybe</kbd> monad, which will be covered later.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Filtering emissions - filter operator</h1>
                
            
            
                
<p>The <kbd>filter</kbd> operator is arguably the most used <kbd>filtering</kbd>/<kbd>suppressing</kbd> operator. It lets you implement custom logic to filter emissions.</p>
<p>The following code snippet is the simplest implementation of the <kbd>filter</kbd> operator:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,20)//(1) 
        .filter{//(2) 
          it%2==0 
     }<br/>      .subscribe { 
         println("Received $it")  
      } 
   }</pre>
<p>On comment <kbd>(1)</kbd>, we created an <kbd>Observable</kbd> instance with the help of the <kbd>Observable.range()</kbd> operator. We filtered out odd numbers from the emissions with the help of the <kbd>filter</kbd> operator on comment <kbd>(2)</kbd>.</p>
<p>The following is the output:</p>
<div><img class=" image-border" src="img/4a6182ea-29ff-4038-a5bf-9696973fdffb.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The first and last operator</h1>
                
            
            
                
<p>These operators help you listen only for the first or last emission and discard the remaining ones.</p>
<p>Check out the following example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.range(1,10) 
      observable.first(2)//(1) 
       .subscribeBy { item -&gt; println("Received $item") } 
 
      observable.last(2)//(2) 
       .subscribeBy { item -&gt; println("Received $item") } 
 
      Observable.empty&lt;Int&gt;().first(2)//(3) 
       .subscribeBy { item -&gt; println("Received $item") } 
    }</pre>
<p>The output is as follows:</p>
<div><img height="104" width="275" class=" image-border" src="img/f4325037-3079-4fcd-85eb-ce66fe9d71b8.png"/></div>
<p>On comment <kbd>(1)</kbd>, we used the <kbd>first</kbd> operator, with the <kbd>defaultValue</kbd> parameter set to <kbd>2</kbd> so that it will emit the <kbd>defaultValue</kbd> parameter if it can't access the first element. On comment <kbd>(2)</kbd>, we used the <kbd>last</kbd> operator. On comment <kbd>(3)</kbd>, we used the <kbd>first</kbd> operator again, this time, with an empty <kbd>Observable</kbd>; so, instead of emitting the first element, it emits <kbd>defaultValue</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The ignoreElements operator</h1>
                
            
            
                
<p>Sometimes, you may require to listen only on the <kbd>onComplete</kbd> of a producer. The <kbd>ignoreElements</kbd> operator helps you to do that. Please refer to the following code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = Observable.range(1,10) 
      observable 
        .ignoreElements() 
        .subscribe { println("Completed") }//(1) 
    } </pre>
<div><img height="75" width="342" class=" image-border" src="img/5f5e614c-bc9e-40a9-b8cf-57cf4ebbddb7.png"/></div>
<p>The <kbd>ignoreElements</kbd> operator returns a Completable monad, which only has the <kbd>onComplete</kbd> event.</p>
<p>We will look into the <kbd>skip</kbd> and <kbd>take</kbd> operators in <a href="dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml" target="_blank">Chapter 6</a>, <em>More on Operators and Error Handling</em> while discussing conditional operators.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The transforming operators</h1>
                
            
            
                
<p>As the name suggests, the <kbd>transforming</kbd> operators help you transform items emitted by a producer.</p>
<p>Here is a brief list of <kbd>transforming</kbd> operators:</p>
<ul>
<li><kbd>map</kbd></li>
<li><kbd>flatMap</kbd>, <kbd>concatMap</kbd>, and <kbd>flatMapIterable</kbd></li>
<li><kbd>switchMap</kbd></li>
<li><kbd>switchIfEmpty</kbd></li>
<li><kbd>scan</kbd></li>
<li><kbd>groupBy</kbd></li>
<li><kbd>startWith</kbd></li>
<li><kbd>defaultIfEmpty</kbd></li>
<li><kbd>sorted</kbd></li>
<li><kbd>buffer</kbd></li>
<li><kbd>window</kbd></li>
<li><kbd>cast</kbd></li>
<li><kbd>delay</kbd></li>
<li><kbd>repeat</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The map operator</h1>
                
            
            
                
<p>The <kbd>map</kbd> operator performs a given task (lambda) on each of the emitted items and emits them to the downstream. We have already seen a little use of the <kbd>map</kbd> operator. For a given <kbd>Observable&lt;T&gt;</kbd> or <kbd>Flowable&lt;T&gt;</kbd>, the <kbd>map</kbd> operator will transform an emitted item of type <kbd>T</kbd> into an emission of type <kbd>R</kbd> by applying the provided lambda of <kbd>Function&lt;T,R&gt;</kbd> to it.</p>
<p>So, now, let's take a look at another example with the <kbd>map</kbd> operator:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = listOf(10,9,8,7,6,5,4,3,2,1).toObservable() 
      observable.map {//(1) 
        number-&gt; "Transforming Int to String $number" 
      }.subscribe { 
        item-&gt; println("Received $item") 
      } 
    }</pre>
<p>On comment <kbd>(1)</kbd>, we used the <kbd>map</kbd> operator, which will transform the emitted item of type <kbd>Int</kbd> to an emission of type <kbd>String</kbd>. Although we have a clear idea of what the output will be, let's validate that by taking a look at the following screenshot:</p>
<div><img height="205" width="304" class=" image-border" src="img/b1899088-5c70-474a-bf0b-8e42a69158bb.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Casting emissions (cast operator)</h1>
                
            
            
                
<p>Think of a situation where you want to cast emissions from the Observable to another data type. Passing a lambda just to cast the emissions doesn't seem like a good idea. The <kbd>cast</kbd> operator is here to help in this scenario. Let's take a look:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val list = listOf&lt;MyItemInherit&gt;( 
         MyItemInherit(1), 
         MyItemInherit(2), 
         MyItemInherit(3), 
         MyItemInherit(4), 
         MyItemInherit(5), 
         MyItemInherit(6), 
         MyItemInherit(7), 
         MyItemInherit(8), 
         MyItemInherit(9), 
         MyItemInherit(10) 
       )//(1) 
 
       list.toObservable()//(2) 
         .map { it as MyItem }//(3) 
         .subscribe { 
             println(it) 
         } 
 
        println("cast") 
 
        list.toObservable() 
            .cast(MyItem::class.java)//(4) 
            .subscribe { 
                println(it) 
            } 
      } 
 
      open class MyItem(val id:Int) {//(5) 
      override fun toString(): String { 
        return "[MyItem $id]" 
      } 
     } 
 
    class MyItemInherit(id:Int):MyItem(id) {//(6) 
      override fun toString(): String { 
        return "[MyItemInherit $id]" 
      } 
    } </pre>
<p>In this program, we have defined two classes: <kbd>MyItem</kbd> and <kbd>MyItemInherit</kbd> on comment <kbd>(5)</kbd> and <kbd>(6)</kbd> respectively. We will be using these two classes to demonstrate the uses of the <kbd>cast</kbd> operator. So, on comment <kbd>(1)</kbd>, we created a list of <kbd>MyItemInherit</kbd>; for this program, our approach is to try the same thing, first with the <kbd>map</kbd> operator, and then we will do the same with the <kbd>cast</kbd> operator. On comment <kbd>(2)</kbd>, we created an observable with a list, and then, on comment <kbd>(3)</kbd>, we used the <kbd>map</kbd> operator and passed a lambda, where we type-casted the emission to <kbd>MyItemInherit</kbd>.</p>
<p>We did the same on comment <kbd>(4)</kbd>, but, this time with the <kbd>cast</kbd> operator. Just look at the simplicity of the code now, it looks a lot cleaner and simpler.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The flatMap operator</h1>
                
            
            
                
<p>Where the <kbd>map</kbd> operator takes each emission and transforms them, the <kbd>flatMap</kbd> operator creates a new producer, applying the function you passed to each emission of the source producer.</p>
<p>So, let's look at this example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = listOf(10,9,8,7,6,5,4,3,2,1).toObservable() 
      observable.flatMap { 
        number-&gt; Observable.just("Transforming Int to String $number") 
      }.subscribe { 
        item-&gt; println("Received $item") 
      } 
   } </pre>
<p>Here is the output:</p>
<div><img height="203" width="322" class=" image-border" src="img/db9dbc0d-026c-46da-8357-da73b0ec601f.png"/></div>
<p>The output is similar to the previous one, but the logic is different. Instead of just returning the <kbd>String</kbd>, we are returning <kbd>Observable</kbd> with the desired <kbd>String</kbd>. Although, for this example, you seem to have no benefit using it, think of a situation when you need to derive multiple items from a single emission. Consider the following example where we will create multiple items from each emission:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      val observable = listOf(10,9,8,7,6,5,4,3,2,1).toObservable() 
      observable.flatMap { 
        number-&gt; 
        Observable.create&lt;String&gt; {//(1) 
          it.onNext("The Number $number") 
          it.onNext("number/2 ${number/2}") 
          it.onNext("number%2 ${number%2}") 
          it.onComplete()//(2) 
        } 
      }.subscribeBy ( 
         onNext = { 
            item-&gt; println("Received $item") 
         }, 
         onComplete = { 
            println("Complete") 
         } 
       ) 
    }   </pre>
<p>Let's take a look at the output, and then we will try to understand the program:</p>
<div><img height="494" width="300" class=" image-border" src="img/68b366a5-c649-4eae-962b-b43c9892f597.png"/></div>
<p>In this program, we've created a new instance of <kbd>Observable</kbd> inside the <kbd>flatMap</kbd> operator, which will emit three strings. On comment <kbd>(1)</kbd>, we created the <kbd>Observable</kbd> instance with the <kbd>Observable.create</kbd> operator. We will emit three strings from the <kbd>Observable.create</kbd> operator, and, on comment <kbd>(2)</kbd>, we will send an <kbd>onComplete</kbd> notification after emitting three items from <kbd>Observable</kbd>.</p>
<p>However, take a look at the output; it emitted all the items before sending the <kbd>onComplete</kbd> notification. The reason is that all <kbd>Obervables</kbd> are combined together and then subscribed to the downstream. The <kbd>flatMap</kbd> operator internally uses the <kbd>merge</kbd> operator to combine multiple <kbd>Observables</kbd>.</p>
<p>The <kbd>concatMap</kbd> performs the same operation using the <kbd>concat</kbd> operator instead of the <kbd>merge</kbd> operator to combine two <kbd>Observable</kbd>/<kbd>Flowables</kbd>.</p>
<p>We will learn more about these operators (<kbd>merge</kbd>, <kbd>concat</kbd>, and other combining operators) in the next chapter.</p>
<p>We will again take a look at <kbd>flatMap</kbd>, along with <kbd>concatMap</kbd>, <kbd>switchMap</kbd>, and <kbd>flatMapIterable</kbd> in <a href="dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml" target="_blank">Chapter 6</a>, <em>More on Operators and Error Handling</em> after gaining some knowledge on merging and concatenating producers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The defaultIfEmpty operator</h1>
                
            
            
                
<p>While working with filtering operators and/or working on complex requirements, it may occur that we encounter an empty producer (see the following code block):</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(0,10)//(1) 
       .filter{it&gt;15}//(2) 
       .subscribe({ 
         println("Received $it") 
      }) 
    } </pre>
<p>Here, on comment <kbd>(1)</kbd>, we will create <kbd>Observable</kbd> of range <kbd>0</kbd> to <kbd>10</kbd>; however, on comment <kbd>(2)</kbd>, we will filter it for emission value <kbd>&gt;15</kbd>. So, basically, we will end up with an empty Observable.</p>
<p>The <kbd>defaultIfEmpty</kbd> operator helps us deal with such situations. The preceding example, with <kbd>defaultIfEmpty</kbd> looks like this:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(0,10)//(1) 
       .filter{it&gt;15}//(2) 
       .defaultIfEmpty(15)//(3) 
       .subscribe({ 
           println("Received $it") 
        }) 
    } </pre>
<p>This is the same program, but, just on comment <kbd>(3)</kbd>, we added the <kbd>defaultIfEmpty</kbd> operator.</p>
<p>The output looks like the following screenshot:</p>
<div><img height="65" width="345" class=" image-border" src="img/88efc565-61bf-4801-86d2-3e99901cdfb5.png"/></div>
<p>The output shows that, although <kbd>Observable</kbd> doesn't contain any number above <kbd>10</kbd>, <kbd>defaultIfEmpty</kbd> adds <kbd>15</kbd> to the <kbd>Observable</kbd> as it's empty after filtering.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The switchIfEmpty operator</h1>
                
            
            
                
<p>This operator is similar to the <kbd>defaultIfEmpty</kbd> operator; the only difference is that, for the <kbd>defaultIfEmpty</kbd> operator, it adds an emission to empty producers, but for the <kbd>switchIfEmpty</kbd> operator, it starts emitting from the specified alternative producer if the source producer is empty.</p>
<p>Unlike the <kbd>defaultIfEmpty</kbd> operator, where you needed to pass an item, here, you have to pass an alternate producer to the <kbd>switchIfEmpty</kbd> operator. If the source producer is empty, it will start taking emissions from the alternate producer.</p>
<p>Here is an example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(0,10)//(1) 
        .filter{it&gt;15}//(2) 
        .switchIfEmpty(Observable.range(11,10))//(3) 
        .subscribe({ 
            println("Received $it") 
        }) 
    } </pre>
<p>This is the same example as the previous one; just on comment <kbd>(3)</kbd>, we used <kbd>switchIfEmpty</kbd> instead of <kbd>defaultIfEmpty</kbd> with an alternate Observable. The following output shows that the emissions were taken from the alternate Observable passed with the <kbd>switchIfEmpty</kbd> operator:</p>
<div><img height="200" width="324" class=" image-border" src="img/e5cc506f-14a2-45ab-be68-da67ce63e703.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The startWith operator</h1>
                
            
            
                
<p>The <kbd>startWith</kbd> operator is simple; it enables you to add an item to the producer at the top of all preexisting items.</p>
<p>Let's take a look at how it works:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(0,10)//(1) 
        .startWith(-1)//(2) 
        .subscribe({ 
           println("Received $it") 
        }) 
     
        listOf("C","C++","Java","Kotlin","Scala","Groovy")//(3) 
          .toObservable() 
          .startWith("Programming Languages")//(4) 
          .subscribe({ 
            println("Received $it") 
          }) 
    }</pre>
<p>The output is as follows:</p>
<div><img height="375" width="379" class=" image-border" src="img/2033e7a6-e4d1-40f2-b14e-010d254c4ad2.png"/></div>
<p>As we can see, the <kbd>startWith</kbd> operator on comment <kbd>(2)</kbd> and <kbd>(4)</kbd> worked just like a prefix on the existing list of emissions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sorting emissions (sorted operator)</h1>
                
            
            
                
<p>There are some scenarios where you would like to sort the emissions. The <kbd>sorted</kbd> operator helps you do that. It will internally collect and reemit all the emissions from the source producer after sorting.</p>
<p>Let's take a look at this example and try to understand this operator better:</p>
<pre>     fun main(args: Array&lt;String&gt;) { 
       println("default with integer") 
       listOf(2,6,7,1,3,4,5,8,10,9) 
         .toObservable() 
         .sorted()//(1) 
         .subscribe { println("Received $it") } 
 
      println("default with String") 
      listOf("alpha","gamma","beta","theta") 
         .toObservable() 
         .sorted()//(2) 
         .subscribe { println("Received $it") } 
 
      println("custom sortFunction with integer") 
      listOf(2,6,7,1,3,4,5,8,10,9) 
         .toObservable() 
         .sorted { item1, item2 -&gt; if(item1&gt;item2) -1 else 1 }//(3) 
         .subscribe { println("Received $it") } 
 
      println("custom sortFunction with custom class-object") 
      listOf(MyItem1(2),MyItem1(6), 
         MyItem1(7),MyItem1(1),MyItem1(3), 
         MyItem1(4),MyItem1(5),MyItem1(8), 
         MyItem1(10),MyItem1(9)) 
        .toObservable() 
        .sorted { item1, item2 -&gt; <br/>        if(item1.item&lt;item2.item) -1 else 1 }//(4) 
        .subscribe { println("Received $it") } 
     } 
 
    data class MyItem1(val item:Int)</pre>
<p>Take a look at the output first, and then we will explore the program:</p>
<div><img height="539" width="484" class=" image-border" src="img/644eaf81-347e-4470-9016-9a2d4985cd29.png"/></div>
<p>Now, let's explore the program. As we already know, the <kbd>sorted</kbd> operator helps sorting emissions; to sort, we need to compare, thus, the <kbd>sorted</kbd> operator requires a <kbd>Comparable</kbd> instance to compare emitted items and sort them respectively. This operator has two overloads, one with no parameter—it assumes that the producer (here <kbd>Observable</kbd>) type will implement <kbd>Comparable</kbd> and calls <kbd>compareTo</kbd> function, failing which will generate error; the other overload is with a method (lambda) for comparing. On comment <kbd>(1)</kbd> and <kbd>(2)</kbd>, we implemented the <kbd>sorted</kbd> operator with a default <kbd>sort</kbd> function, that is, it will call the <kbd>compareTo</kbd> function from the item instance and will throw error if the datatype doesn't implement <kbd>Comparable</kbd>.</p>
<p>On comment <kbd>(3)</kbd>, we used our own custom <kbd>sortFunction</kbd> to sort the integers in descending order.</p>
<p>On comment <kbd>(4)</kbd>, we used an Observable of type <kbd>MyItem1</kbd>, which obviously is a custom class and doesn't implement <kbd>Comparable</kbd>, so we passed the <kbd>sortFunction</kbd> lambda here as well.</p>
<div><strong>Caution</strong>: As we already mentioned, the <kbd>sorted</kbd> operator collects all emissions and then sorts them before reemitting them in a sorted order; thus, using this operator can cause significant performance implications. Moreover, while using with large producers, it can cause <kbd>OutOfMemory Error</kbd> as well. So, use the sorted operator cautiously, or try to avoid it unless extensively required.</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Accumulating data – scan operator</h1>
                
            
            
                
<p>The <kbd>scan</kbd> operator is a rolling aggregator; it emits incremental accumulation by adding previous emissions to it.</p>
<p>Let's take a look at the following example before delving deeper:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,10) 
      .scan { previousAccumulation, newEmission -&gt;<br/>       previousAccumulation+newEmission }//(1) 
      .subscribe { println("Received $it") } 
 
      listOf("String 1","String 2", "String 3", "String 4") 
       .toObservable() 
       .scan{ previousAccumulation, newEmission -&gt; <br/>        previousAccumulation+" "+newEmission }//(2) 
       .subscribe { println("Received $it") } 
 
       Observable.range(1,5) 
       .scan { previousAccumulation, newEmission -&gt; <br/>        previousAccumulation*10+newEmission }//(3) 
        .subscribe { println("Received $it") } 
      } </pre>
<p>The output is as follows:</p>
<div><img height="377" width="371" class=" image-border" src="img/8acca42d-df8c-4385-884b-078fa75f3df2.png"/></div>
<p>So, in this program, we used the <kbd>scan</kbd> operator to implement three types of operations, which we will discuss in detail, but, first, let's try to understand the <kbd>scan</kbd> operator itself. It takes a lambda with two arguments. The first parameter is the result of a rolling aggregation of all previous emissions; the second one is the current emission.</p>
<p>The following graph will allow you to understand it better:</p>
<div><img height="238" width="501" src="img/5bce443b-389b-4fe1-8dd2-9537b09bebf4.png"/></div>
<p>As we can see in the graph, the <kbd>scan</kbd> operator will accumulate all the previous emissions with the current emission based on the provided accumulation function.</p>
<p>So, in the preceding program, on comment <kbd>(1)</kbd>, we did the same thing with the <kbd>scan</kbd> operator as it is described in the graph. We used it to get the sum of all <kbd>integers</kbd> emitted up until then. On comment <kbd>(2)</kbd>, we used it with <kbd>Observable</kbd> of type <kbd>String</kbd> and got concatenated strings.</p>
<p>On comment <kbd>(3)</kbd>, we used the <kbd>scan</kbd> operator to concatenate the <kbd>integers</kbd> by multiplying the previous accumulation by <kbd>10</kbd> and adding the present emission to it.</p>
<p>One thing to note is that we can use the <kbd>scan</kbd> operator for almost any operation, not just for summing, as long as it returns items of the same datatype.</p>
<p>Note that the <kbd>scan</kbd> operator has similarities with the <kbd>reduce</kbd> operator, which we will cover soon in this chapter; however, be cautious not to get confused. The <kbd>scan</kbd> operator is a rolling aggregator, which transforms all the emissions it receives into accumulation; whereas, the <kbd>reduce</kbd> operator reduces emissions to just one by accumulating all the emissions once it receives the <kbd>onComplete</kbd> notification.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reducing operators</h1>
                
            
            
                
<p>While developing applications, you may face such a situation where you may need to accumulate and consolidate emissions. Note that nearly all the operators under this criteria will only work on a finite producer (Observable/Flowable) that calls <kbd>onComplete()</kbd> because typically, we can consolidate only finite datasets. We will explore this behavior as we cover these operators.</p>
<p>Here is a short list of reducing operators, which we will cover in this chapter:</p>
<ul>
<li><kbd>count</kbd></li>
<li><kbd>reduce</kbd></li>
<li><kbd>all</kbd></li>
<li><kbd>any</kbd></li>
<li><kbd>contains</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Counting emissions (count operator)</h1>
                
            
            
                
<p>The <kbd>count</kbd> operator subscribes to a producer, counts the emissions, and emits a <kbd>Single</kbd>, containing the count of emissions by the producer.</p>
<p>Here is an example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      listOf(1,5,9,7,6,4,3,2,4,6,9).toObservable() 
      .count() 
      .subscribeBy { println("count $it") } 
    } </pre>
<p>The following is the output:</p>
<div><img height="70" width="378" class=" image-border" src="img/aa05b80c-734a-40a9-bd4d-9e303e3868c0.png"/></div>
<p>As we can see from the output, this operator counts the emissions from the producer, and emits the count once it receives the <kbd>onComplete</kbd> notification.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accumulating emissions – reduce operator</h1>
                
            
            
                
<p>Reduce is a perfect accumulation operator. It accumulates all the emissions by the producer and emits them once it receives the <kbd>onComplete</kbd> notification from the producer.</p>
<p>Here is an example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.range(1,10) 
      .reduce { previousAccumulation, newEmission -&gt; <br/>       previousAccumulation+newEmission  } 
      .subscribeBy { println("accumulation $it") } 
 
       Observable.range(1,5) 
       .reduce { previousAccumulation, newEmission -&gt; <br/>        previousAccumulation*10+newEmission  } 
       .subscribeBy { println("accumulation $it") } 
      } </pre>
<p>The output is shown as follows:</p>
<div><img height="84" width="355" class=" image-border" src="img/2248a518-06cd-4d24-a21b-f31636c3605d.png"/></div>
<p>The <kbd>reduce</kbd> operator works similar to the <kbd>scan</kbd> operator, the only difference is that instead of accumulating and emitting them on each emission, it accumulates all the emissions and emits them on receiving the <kbd>onComplete</kbd> notification.</p>
<p>The <kbd>all</kbd> and <kbd>any</kbd> operators help validate emissions by the producer; we will look into them in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The collection operators</h1>
                
            
            
                
<p>Though it is not good practice, keeping some rare situations in mind, RxKotlin provides you with operators that can listen to all the emissions and accumulate them to a collection object.</p>
<p>The <kbd>collection</kbd> operators are basically a subset of the reducing operators.</p>
<p>The following list consists of the most important <kbd>collection</kbd> operators:</p>
<ul>
<li><kbd>toList</kbd> and <kbd>toSortedList</kbd></li>
<li><kbd>toMap</kbd></li>
<li><kbd>toMultiMap</kbd></li>
<li><kbd>collect</kbd></li>
</ul>
<p>We will be covering <kbd>collection</kbd> operators in detail later in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The error handling operators</h1>
                
            
            
                
<p>We already learned about the <kbd>onError</kbd> event in the Subscriber/Observer. However, the problem with the <kbd>onError</kbd> event is that the error is emitted to the downstream consumer chain, and the subscription is terminated instantly. For example, take a look at the following program:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      Observable.just(1,2,3,5,6,7,"Errr",8,9,10) 
       .map { it.toIntOrError() } 
       .subscribeBy ( 
           onNext = { 
              println("Next $it") 
           }, 
           onError = { 
              println("Error $it") 
           } 
        ) 
     } </pre>
<p>The output of the program is shown in the following screenshot:</p>
<div><img height="163" width="415" class=" image-border" src="img/bfe8c4e0-644e-485b-9935-2595bb337a87.png"/></div>
<p>The program throws an exception in the <kbd>map</kbd> operator when the string <strong>Errr</strong> is emitted from the Observable. The exception was caught by the <kbd>onError</kbd> handler, but the Subscription doesn't get any further emissions.</p>
<p>This may not be the desired behavior every time. Although we cannot pretend the error never happened and continue (we should not do this either), there should be a way to at least resubscribe or switch to an alternate source producer.</p>
<p>Error handling operators help you achieve the same.</p>
<p>The following are the error handling operators.</p>
<ul>
<li><kbd>onErrorResumeNext( )</kbd></li>
<li><kbd>onErrorReturn( )</kbd></li>
<li><kbd>onExceptionResumeNext( )</kbd></li>
<li><kbd>retry( )</kbd></li>
<li><kbd>retryWhen( )</kbd></li>
</ul>
<p>We will cover error handling operators in detail in <a href="dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml" target="_blank">Chapter 6</a>, <em>More on Operators and Error Handling</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The utility operators</h1>
                
            
            
                
<p>These operators help us to perform various utility operations, such as performing some action on emissions, remembering timestamps of each items emitted, caching, and much more.</p>
<p>The following is the list of utility operators:</p>
<ul>
<li><kbd>doOnNext</kbd>, <kbd>doOnComplete</kbd>, and <kbd>doOnError</kbd></li>
<li><kbd>doOnSubscribe</kbd>, <kbd>doOnDispose</kbd>, and <kbd>doOnSuccess</kbd></li>
<li><kbd>serialize</kbd></li>
<li><kbd>cache</kbd></li>
</ul>
<p>We will cover utility operators in detail in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we learned about operators and the types of operators available, and we learned in detail about operators, especially the ones useful for transforming, filtering, and accumulating emissions by the source producer. We also learned about the necessity of the error handling operators, which we will cover in the next chapter.</p>
<p>This chapter and the next chapter, that is, <a href="dd987490-6324-42e8-9598-c409fb2ea9cb.xhtml" target="_blank">Chapter 6</a>, <em>More on Operators and Error Handling</em> are highly related; while discussing topics in this chapter, we got a glance about the contents of the next chapter. In the next chapter as well, we will refer to and use the contents learned in this chapter.</p>
<p>While in this chapter we focused on the basics of operators, operator types, and operators specifically useful for filtering, transforming, and accumulating emissions (aka data), in the next chapter, we will cover the operators useful to combine Observable/Flowables and error handling and for conditional purposes.</p>
<p>Turn the page right now to get started.</p>


            

            
        
    </body></html>