<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Object Creation and Storage</h1></div></div></div><p class="calibre8">In this chapter, we will cover objects and classes in more depth, showing the mechanisms behind their creation, handling, and customization.</p><p class="calibre8">We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Object creation and initialization</li><li class="listitem">Object immutability</li><li class="listitem">Object mutability</li><li class="listitem">Object inheritance</li><li class="listitem">Convenience initializers</li><li class="listitem">The singleton pattern</li><li class="listitem">Using @property</li><li class="listitem">Types of classes</li><li class="listitem">Custom methods</li><li class="listitem">Format specifiers</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec27" class="calibre1"/>Creation and initialization of objects</h1></div></div></div><p class="calibre8">For a developer, building<a id="id64" class="calibre1"/> iOS and OS X applications requires a lot of time in creating and handling objects. In Objective-C, like any other object-oriented programming language, the object acts like a data package with predefined behaviors. We can think about an application as an environment containing objects that connect with each other, passing<a id="id65" class="calibre1"/> and receiving information such as how to build a graphical interface, how to proceed with user interactions, how and where to store and take data from, how to perform calculations, and much more. The complexity of tasks that can be performed by an object can be very large, but it's not reflected on the complexity to create an object. </p><p class="calibre8">Cocoa (for OS X) and Cocoa Touch (iOS) already provide a library containing an extensive list of objects for you to use as they are or create your own objects based on them—we call it code reuse.</p><p class="calibre8">One of the most important development processes is thinking about the app base structure, when you <a id="id66" class="calibre1"/>decide which object to use, combine, customize, how they will communicate in order to generate the <a id="id67" class="calibre1"/>expected output, and so on. Some of them are provided by Cocoa and Cocoa Touch for immediate use such as NSString, NSArray, NSDictionary, UIView, and UILabel, but such importance is due to others who might need customization to act as required and/or in order to create an unique framework—features for your application.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec28" class="calibre1"/>What is a class?</h1></div></div></div><p class="calibre8">In <a id="id68" class="calibre1"/>object-oriented programming approaches, an object is an instance of a class. The class will determine the behavior of the object, the messages (methods) it receives, and sometimes who has access to send these messages in order to obtain a response.</p><p class="calibre8">A class describes the properties and behaviors of a specified object, just like the blueprint of a house will describe the properties of the house, such as the number of doors in the house. Similarly, for a number, an instance of a class named <code class="email">NSNumber</code>, its class provides many ways to obtain, analyze, compare, and convert the object's internal numeric value.</p><p class="calibre8">Except the internal contents stored in multiple instances of a class, all the properties and actions behave identically. Check out the following example:</p><div><pre class="programlisting">/*
  =============================================
  Our object is created here as instance of NSNumber.
  We directly assign a float number to it;
  =============================================
*/

NSNumber *sampleNumber = @(3.1415);

/*
  =============================================
  Now, we send the built-in message "intValue" to convert the float value stored in it to an integer value.
  =============================================
*/

NSNumber firstNumber = @([ sampleNumber intValue]);</pre></div><p class="calibre8">Our numeric object, <code class="email">firstNumber</code>, now has the numeric value <code class="email">3</code>, which is an integer, after sending the message <code class="email">intValue</code>, which is predefined in the <code class="email">NSNumber</code> class. The object will behave as expected by converting its value to an integer. Any object instance of the class will act in the same way.</p><p class="calibre8">Objects<a id="id69" class="calibre1"/> are created to be used in different expected ways, but it's not a requirement for you to know how the internal mechanisms of their behavior happens, which is also known as encapsulation. Instead, the single requirement is to know how to handle the objects in order to behave in the way you want. It means you need to know the predefined messages to send to your object. If you have a string, an instance of the <code class="email">NSString</code> class containing six uppercase characters, and you want them to be lowercase, all you have to know is the message to be sent:</p><div><pre class="programlisting">/*
  =============================================
  We create our string with the uppercase characters: "QWERTY"
  =============================================
*/

NSString *sampleString = @"QWERTY";

/*
  =============================================
  Now, we send a message to it, requesting to convert the uppercase characters to lowercase
  =============================================
*/

sampleString = [sampleString lowercaseString];

/*
  =============================================
  After this process, our string has now the characters: "qwerty"
  =============================================
*/</pre></div><p class="calibre8">To specify <a id="id70" class="calibre1"/>how an object is intended to be used, we use the class interface. It defines a public interface to be used in other parts of your code, outside the class itself.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec10" class="calibre1"/>Classes</h2></div></div></div><p class="calibre8">In order to <a id="id71" class="calibre1"/>create your own class, go to <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> in the menu bar<a id="id72" class="calibre1"/> or just click <em class="calibre9">Command</em> + <em class="calibre9">N</em>, select <strong class="calibre2">iOS</strong> or <strong class="calibre2">OS X</strong> based on your project and select <strong class="calibre2">Cocoa Class</strong> or <strong class="calibre2">Cocoa Touch Class</strong>. After this, you can name your class and select its super class (from which it will inherit). Xcode will automatically create a header and an implementation file for you, <code class="email">.h</code> and <code class="email">.m</code>. As in other programming languages, the header file is kind of a summary, a quick view about the contents in the class, what will be used, and so on.</p><p class="calibre8">Your public methods and properties will be declared in the header file. Here, you can see a sample of a newly created header file (<code class="email">mySpecialTableViewController.h</code>):</p><div><img src="img/00006.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Our class is<a id="id73" class="calibre1"/> named <code class="email">mySpecialTableViewController</code>, a subclass of <code class="email">UITableViewController</code>. It creates a UI element, as its name suggests, a table view, which is very common in iOS applications.</p><p class="calibre8">Still in our header file, we will create a public property, <code class="email">NSArray</code>, to receive and hold the data that will be shown on each <code class="email">UITableViewCell</code>. Our table view will show a list of programming languages:</p><div><img src="img/00007.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">By <a id="id74" class="calibre1"/>specifying the<a id="id75" class="calibre1"/> superclass during the creation, Xcode already prepared your class with the built-in methods available/required to run it. As we can see in our implementation file (<code class="email">mySpecialTableViewController.m</code>), we just need to implement our code:</p><div><img src="img/00008.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Our table <a id="id76" class="calibre1"/>view <a id="id77" class="calibre1"/>will be simple, only showing each programming language stored in the <code class="email">myProgrammingLanguages</code> array on a different cell. It will only have one section, which means we are free to return this number in the <code class="email">numberOfSectionsInTableView:</code> method:</p><div><img src="img/00009.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The next <a id="id78" class="calibre1"/>modification is to specify the number of rows, which <a id="id79" class="calibre1"/>means the number of cells. If it relies on a property where this number might be different, we can't hardcode it as we did with the number of sections; instead, we return the number of objects our array is holding:</p><div><img src="img/00010.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The next step when creating a table view in Objective-C is to set the content of the cells. We use the <code class="email">tableView:cellForRowAtIndexPath:</code> method (already provided in the implementation file). By default, it comes commented. Uncomment the method in order to use it:</p><div><img src="img/00011.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The first thing you should notice is that it creates <code class="email">UITableViewCell</code> and returns it to be seen on the table view. It is between these two steps that we will configure our cell.</p><p class="calibre8">The <code class="email">UITableViewCell</code> class<a id="id80" class="calibre1"/> already comes with a property called <code class="email">textLabel</code>. We will use it to show<a id="id81" class="calibre1"/> the values stored in the <code class="email">myProgrammingLanguages</code> array. Once the <code class="email">tableView:numberOfRowsInSection:</code> method returns the <a id="id82" class="calibre1"/>number of elements in the array, for each iteration, it configures and returns a cell for the respective item in the array. The first cell is for the first item, the second cell for second item, and so on. Inside this method, the current cell is already the correct cell for <code class="email">indexPath</code>, but in order to get the correct value set to it, we use <code class="email">indexPath.row</code> to select the proper item in the array:</p><div><img src="img/00012.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The preceding code sets the first item in the <code class="email">myProgrammingLanguages</code> array to the <code class="email">textLabel</code> property of the first cell and so on until it reaches the number of rows in the table view (the number of the elements in the array).</p><p class="calibre8">By hardcoding our array, setting the items of <code class="email">myProgrammingLanguages</code> inside the <code class="email">viewDidLoad</code> method, and building our project, we are able to see a table view with the items of the array on each cell:</p><div><img src="img/00013.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Here, you can see our custom <code class="email">UITableViewController</code> with three <code class="email">UITableViewCell</code> classes, the items of the <code class="email">myProgrammingLanguages</code> array:</p><div><img src="img/00014.jpeg" alt="Classes" class="calibre10"/></div><p class="calibre11"> </p><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">Creating a cell with <code class="email">[tableView:dequeueReusableCellWithIdentifier:@"anyReusableIdentifier" forIndexPath:indexPath]</code> sets an identifier to the cell in order to reuse it with other content when it's no longer visible on the screen.</p><p class="calibre8">For example, if there is a table view with 15 elements, and in your iOS device, there are 12 cells visible in the screen, when you scroll up to see the other 3 elements, there will still be 12 cells visible. In this case, using reuse identifiers, instead of creating 15 <code class="email">UITableViewCells</code>, it will create at least 13 different cells (11 fully visible cells and 2 partially visible cells), and when a cell disappears from the screen (scroll up), it is reused to load the newest visible element, appearing at the bottom.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec29" class="calibre1"/>Object immutability</h1></div></div></div><p class="calibre8">Most <a id="id83" class="calibre1"/>of the classes provided by Cocoa and Cocoa Touch create objects with immutable values. In short, an immutable object has its contents set only once, and can never modify its values after that. These objects have their contents specified during their creation. The object's creation might occur in the initialization process or later, but it happens once.</p><p class="calibre8">Here, we can see an array that is initialized and created at the same time. Its contents are immutable:</p><div><pre class="programlisting">/*
  =============================================
  sampleArray is allocated, initialized and created with the strings "Item 1" and "Item 2"
  =============================================
*/
NSArray *sampleArray = [[NSArray alloc] initWithArray:@[
              @"Item 1",
              @"Item 2"]];
//This will throw a compile time error as NSArray is not mutable.
[sampleArray addObject:@"Item 3"];</pre></div><p class="calibre8">In the preceding line of code, <code class="email">[sampleArray addObject:@"Item 3"];</code> will show you a compile time error as <code class="email">sampleArray</code> is declared as an <code class="email">NSArray</code> and not as an <code class="email">NSMutableArray</code>, so <code class="email">sampleArray</code> cannot have any objects added to it after it is initialized.</p><p class="calibre8">Now, we create another array, firstly initializing it before its creation, which might happen somewhere later in the code:</p><div><pre class="programlisting">/*
  =============================================
  secondSampleArray is allocated and initialized but not yet created.
  =============================================
*/
NSArray *secondSampleArray = nil;

/*
  =============================================
  Later in our code, we can create it setting contents to it, but it also happens once, the contents won't be changed.
  =============================================
*/
secondSampleArray = @[@"Item 1", @"Item 2"];</pre></div><p class="calibre8">You can see that we set <code class="email">secondSampleArray</code> to <code class="email">nil</code>, and in Objective-C, <code class="email">nil</code> means that <code class="email">secondSampleArray</code> has no value or an address. It is only later that we insert the two <a id="id84" class="calibre1"/>NSStrings <code class="email">"Item 1"</code> and <code class="email">"Item 2"</code> into <code class="email">secondSampleArray</code> to make the size of the array 2.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec30" class="calibre1"/>Object mutability</h1></div></div></div><p class="calibre8">Cocoa and Cocoa Touch also<a id="id85" class="calibre1"/> provide some mutable versions of its immutable classes. Once a mutable object is created, its contents can be partially or completely removed or modified. As we saw immutable array objects—an instance of NSArray—in the previous topic, I will now show you its mutable version, the <code class="email">NSMutableArray</code> class, from which we will create our objects as an instance, as you can see in the following code:</p><div><pre class="programlisting">/*
  =============================================
  We will create now a mutable version of an array, using the class NSMutableArray.
  =============================================
*/
NSMutableArray *mutableSampleArray = [[NSMutableArray alloc] init];

/*
  =============================================
  Now, we assign to it the list of strings:
  "String 1", "String 2", "String 3"
  =============================================
*/
mutableSampleArray = @[@"String 1",
       @"String 2",
        @"String 3"];

/*
  =============================================
  Later, we change the 2nd item of the list with the string "Replacement String", having our array the list: "String 1", "Replacement String", "String 3"
  The indexes are 0 based and starts from 0
  =============================================
*/

[mutableSampleArray replaceObjectAtIndex:1 withObject:@"Replacement String"];</pre></div><p class="calibre8">The mutable versions of a class (in our example, <code class="email">NSMutableArray</code>) have many similarities with the original immutable version, <code class="email">NSArray</code>; however, they are different classes. Intending<a id="id86" class="calibre1"/> to use methods from one that is not available for the other will generate compilation errors. Generally, immutability is what you should try to use as immutability provides a guarantee that an object won't have its value changed while you are using it. Immutability also brings performance benefits when used in things such as strings and dictionaries as mutability will bring some overhead due to the need to allocate and deallocate chunks of memory when the string or dictionary is modified.</p><p class="calibre8">In the case of <code class="email">NSArray</code> and <code class="email">NSMutableArray</code>, <code class="email">NSMutableArray</code> is not thread-safe and can present weird bugs if you use multithreading. So, generally, try to use <code class="email">NSArray</code> as the de facto array to use unless you really need <code class="email">NSMutableArray</code>.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec31" class="calibre1"/>Inheritance</h1></div></div></div><p class="calibre8">To<a id="id87" class="calibre1"/> understand inheritance, think about it as a perfect biological tree, where you have inherited some behavioral traits from your father, but more than that you have your own. Something like this happens in Objective-C when a class is inherited from another.</p><p class="calibre8">Basic samples are the classes whose names start with <code class="email">NS</code> provided by Cocoa and Cocoa Touch, such as <code class="email">NSString</code>, <code class="email">NSArray</code>, and <code class="email">NSDictionary</code>. They are all inherited from <code class="email">NSObject</code>. Each of them has their particular methods to handle the different types of contents they hold, but everyone shares methods such as <code class="email">alloc</code> and <code class="email">init</code>. These two class methods, inherited from <code class="email">NSObject</code>, respectively allocate memory and initialize the object:</p><div><img src="img/00015.jpeg" alt="Inheritance" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The <code class="email">alloc</code> method <a id="id88" class="calibre1"/>will rarely be overridden, performing a single task and allocating memory to the object being created. However, another inheritance example is the <code class="email">init</code> method, which is also inherited from <code class="email">NSObject</code>. It received modifications in each child class, creating other initialization methods to quickly assign content to the object. These new <code class="email">init</code> methods are inherited from the original <code class="email">init</code> method. This is an example for <code class="email">NSString</code>:</p><div><pre class="programlisting">  /*
  =============================================
    The variable is allocated and initialized but still has no content, its value is nil.
  ============================================= */
  NSString *simpleInitializedString = [[NSString alloc] init];
  /*
  =============================================
    Allocated and initialized by it's custom method, initWithString:, inherited from init. In this case, the variable is initialized with a content, "Hey!"
  ============================================= */
  NSString *customInitializedString = [[NSString alloc] initWithString:@"Hey!"];</pre></div><div><img src="img/00016.jpeg" alt="Inheritance" class="calibre10"/></div><p class="calibre11"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec32" class="calibre1"/>Convenience initializers</h1></div></div></div><p class="calibre8">The allocation <a id="id89" class="calibre1"/>and initialization methods will allocate a chunk of memory to hold the object's content and set an empty value to it, until you assign a value yourself. The empty value differs depending on the object's type: Boolean (BOOL) objects receive the value <code class="email">NO</code>, integers (int) receive <code class="email">0</code>, float numbers (float) receive <code class="email">0.0</code>, and the rest of the objects receive <code class="email">nil</code>.</p><p class="calibre8">It's possible to first allocate memory for your object, and later in the code, initialize it, but it's not recommended at all.</p><p class="calibre8">On the other hand, you can use or even create what we call convenience initializers, which are initialization methods that receive arguments to assign different and/or additional values for instance variables.</p><p class="calibre8">For a better understanding, we will now create our own object class and create convenience initializers to<a id="id90" class="calibre1"/> be used in different scenarios. First, we will create a class, inherited from <code class="email">NSObject</code>. It will return a float number, which is a result of a fraction of a multiplication; we will call it <code class="email">MultiFraction</code>:</p><div><img src="img/00017.jpeg" alt="Convenience initializers" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In our header file, <code class="email">MultiFraction.h</code>, we will specify the instance variables to be included in our object. It will have three values and we will use the <code class="email">property</code> keyword to define the information that the <code class="email">MultiFraction</code> class intends to encapsulate, which in this case are the objects of the type <code class="email">NSInteger</code>, which are named <code class="email">firstNumerator</code>, <code class="email">secondNumerator</code>, and <code class="email">denominator</code> respectively:</p><div><img src="img/00018.jpeg" alt="Convenience initializers" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the<a id="id91" class="calibre1"/> implementation file, <code class="email">MultiFraction.m</code>, by omitting the <code class="email">init</code> method, it will use the inherited initialization method from the superclass, in our case, <code class="email">NSObject</code>, which will return a <code class="email">nil</code> value. However, we want to implement a convenience initializer to take three arguments, save the values to be used by another method in order to perform a calculation, and return its result. Our initialization method will be named <code class="email">initWithFirstNumerator:</code>, <code class="email">secondNumerator:</code>, <code class="email">denominator:</code>:</p><div><img src="img/00019.jpeg" alt="Convenience initializers" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Inside our initialization method, we will store the arguments passed to our object on its respective instance <a id="id92" class="calibre1"/>variables in case we want to access any of these values in the future, instead of calculating the result directly:</p><div><img src="img/00020.jpeg" alt="Convenience initializers" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now, we can create our object elsewhere in our Xcode project, by importing our header file:</p><div><pre class="programlisting">#import MultiFraction.h

/*
  =============================================
  Creating a MultiFraction object with the default init method, inherited from NSObject.
  ============================================= */
MultiFraction *firstMultiFraction = [[MultiFraction alloc] init];
// Later, when calling a method to calculate the fraction we will
// get a nil if we handle our instance variables or an error, if
// we try to calculate as they are, nil values.

/*
  =============================================
  Creating a MultiFraction object with the convenience initialization method we've created.
  ============================================= */
MultiFraction *secondMultiFraction = [[MultiFraction alloc] initWithFirstNumerator:25 secondNumerator:3 denominator:4];
// For the secondMultiFraction, when trying to calculate the
// fraction, we will get 18.75 as a float, if we take any
// argument as float when calculating the result.</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec33" class="calibre1"/>An Objective-C programmer's responsibility</h1></div></div></div><p class="calibre8">If you have experience in <a id="id93" class="calibre1"/>other programming languages, such as Java, and are coming to Objective-C now, forget about constructors, they don't exist in Objective-C. Constructors are language-level constructs that merge the allocation and initialization actions, but they have restrictions:</p><div><ul class="itemizedlist"><li class="listitem">They don't return anything. While the Objective-C class initialization method, + (<code class="email">void</code>) initialize, does not return anything, the default—(<code class="email">id</code>) <code class="email">init</code> method of an Objective-C class returns an object of the type <code class="email">id</code>.</li><li class="listitem">The constructor's name must be identical with the class.</li><li class="listitem">When you call the superclass, being the first statement is a must.</li></ul></div><p class="calibre8">The last point ensures you won't deal with garbage data, but this is a restriction. In Objective-C, as in C, without this restriction, you, the programmer, have more flexibility and power, but it is also your responsibility to deal with garbage data.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec34" class="calibre1"/>The singleton pattern</h1></div></div></div><p class="calibre8">Besides <a id="id94" class="calibre1"/>taking responsibility for garbage management, a good programmer should also be aware of programming design patterns. Design patterns are solutions, mostly reusable code solutions, to solve and prevent common issues. It makes a developer's life easier. In this section, I'll show you the singleton pattern. Singletons are useful if you need a single instance and need to manage that single instance such as writing to a log file. However, singletons can be misused as global variables, which makes for bad programming practice. Singletons are also implemented using static methods, which is not good for unit testing as they cannot be mocked or stubbed. So, only use a singleton in the correct context and not in every situation that you encounter.</p><p class="calibre8">In Objective-C, it's completely possible to have more than one instance of a class (objects) at a time. However, what if you don't need it? What if, for some reason, you need only one instance and nothing more and want to avoid multiple instances for that class? In this case, you use the singleton pattern. It ensures that there is only a single instance of a class and there is a method globally available for it.</p><p class="calibre8">An example already <a id="id95" class="calibre1"/>implemented by Apple in the <code class="email">UIScreen</code> class is the <code class="email">mainScreen</code> method. It's globally available and returns a instance of its class, ensuring it's the only one. The reason is obvious, we don't need more than one main screen. It's called from anywhere in your project, as shown here:</p><div><pre class="programlisting"> [UIScreen mainScreen]</pre></div><p class="calibre8">When you first call the method, the instance is not created yet. It will then be initialized and returned as expected; however, from the second time the method is called, it doesn't create a new instance but returns the existing one. That's how it ensures only one instance exists. Let's go through the following sample code:</p><p class="calibre8">In the header file, we will first create a global method to access its instance:</p><div><pre class="programlisting">@interface connectionLibrary : NSObject
+ (connectionLibrary*)mySharedInstance;
@end</pre></div><p class="calibre8">Then, in your implementation file, implement the method, as shown here:</p><div><pre class="programlisting">+ (connectionLibrary*)mySharedInstance {
  // First, we create a static variable to hold our instance 
  static connectionLibrary *_mySharedInstance = nil;
  /*
  Create a static variable to ensure the instance will be initialized only once
  */
  static dispatch_once_t initOnce;
/*
    Now, the core of the singleton pattern is GCD, Grand Central Dispatch, that executes a block where the initialization method is never called once the class was already initiated.
*/
    dispatch_once(&amp;initOnce, ^{
    _mySharedInstance = [[connectionLibrary alloc] init];
});
  return _mySharedInstance;
}</pre></div><p class="calibre8">Now, you can initialize and access this instance from anywhere in your code:</p><div><pre class="programlisting">connectionLibrary *sharedInstance = [connectionLibrary mySharedInstance];</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec35" class="calibre1"/>Creating @property</h1></div></div></div><p class="calibre8">There are two<a id="id96" class="calibre1"/> ways to store data in objects, they are properties and instance variables. The latter should be used just for objects and values exclusively handled by the class itself, not from outside. Properties, on the other hand, for objects and values are accessible from outside (by other classes).</p><p class="calibre8">While using instance variables, you can create public or private ones. The difference is basically where you declare them as sometimes you need them to be accessible by other classes, while in other situations, there is no need to expose them to other classes. If they are declared in the header file as part of the <code class="email">@interface</code> block, they have public scope and if declared in the implementation file as part of the <code class="email">@implementation</code> block, they have private scope. Generally, they should be private:</p><div><pre class="programlisting">@implementation Book {
  int _numberOfPages;
  int _numberOfChapters;
  NSArray *_authorsInfo;
}</pre></div><p class="calibre8">To easily understand your code, instance variable starts with an underscore; it doesn't affect the way they work, but it's a convention highly recommended to be followed.</p><p class="calibre8">Instance variables are private and accessible only by the class or subclass, plus it is encapsulated by the class, which contains it, while a property is public and can be accessed by other classes. Properties can also be private when declared as part of the class extension, but they are often public since you want to access them from the outside. By accessing, there are two options, get or set their content. Objective-C automatically generates getters and setters for each declared property. In order to declare a property with public scope, do it in your header file as shown here:</p><div><pre class="programlisting">@interface Book : NSObject
@property (strong, nonatomic) NSString *chapterNote;
@end</pre></div><p class="calibre8">The preceding code mostly tells other classes that the <code class="email">Book</code> class has a public property, which can be accessed by <code class="email">chapterNote</code>:</p><div><pre class="programlisting">Book *objCBook = [[Book alloc] init];
// This is our setter, we are setting an value to it
objCBook.chapterNote = "I really love this chapter";
//This non dot syntax setter is also valid [objCBook setChapterNote:@"I really love this chapter"];
/*
  This is our getter, we get the value hold on chapterNote and save it in myLastNote
*/
NSString *myLastNote = objCBook.chapterNote</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec36" class="calibre1"/>Creating custom methods</h1></div></div></div><p class="calibre8">In Objective-C, methods<a id="id97" class="calibre1"/> when declared start with <code class="email">–</code> or <code class="email">+</code>, as you will see in this section. The latter declares a static method, while the former, <code class="email">–</code> , declares instance methods. As a developer, you won't declare static methods (starting with <code class="email">+</code>) regularly.</p><p class="calibre8">Static methods<a id="id98" class="calibre1"/> are generally used if you don't need an instance of a class in that method, while instance methods are used when you need that instance to modify its state. Instance methods are more commonly used as instance methods give you access to a class instance variables.</p><p class="calibre8">To declare a method, you follow a syntax. You will need the following entities:</p><div><ul class="itemizedlist"><li class="listitem">The symbol to specify the type of the method</li><li class="listitem">The type of the data it will return</li><li class="listitem">The method's name</li><li class="listitem">For each parameter:<div><ul class="itemizedlist1"><li class="listitem">The type of parameter</li><li class="listitem">The name of parameter</li></ul></div></li><li class="listitem">Your code inside the method</li></ul></div><p class="calibre8">Following our example, in <code class="email">mySpecialTableViewController</code>, let's declare an instance method that will take one parameter, a string (<code class="email">NSString</code>). Our method will return the content of the <code class="email">myProgrammingLanguages</code> array as a single string. Each object will be followed by the parameter given. Our method will be called <code class="email">convertToStringWith</code>.</p><p class="calibre8">Before we go to the implementation file, the method must be declared in the header file, not doing this may cause errors when calling the method because the header file defines what methods are exposed to the outside.</p><div><img src="img/00021.jpeg" alt="Creating custom methods" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Now, move to<a id="id99" class="calibre1"/> the implementation file and implement the method:</p><div><img src="img/00022.jpeg" alt="Creating custom methods" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In this case, when calling the method, if the <code class="email">myProgrammingLanguages</code> array contains the string values: <code class="email">"Objective-C", "Swift", and "PHP"</code>, the result would be a unique string with the passed parameter between the values, as shown in the following examples:</p><div><img src="img/00023.jpeg" alt="Creating custom methods" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">There are occasions when you don't want to pass any parameter to a method. It's possible; you just need the type of the data returned and the name of the method:</p><div><pre class="programlisting">-(BOOL) doYouLikeThisBook
{
  return true;
}</pre></div><p class="calibre8">There are two<a id="id100" class="calibre1"/> special cases about the type of the data retuned by a method, when you don't know it and when you won't return anything. In the first case, you should use <code class="email">id</code>, as shown here:</p><div><pre class="programlisting">-(id) initSomethingWithoutKnowingTheType
{
  self = [super class];
  return self;
}</pre></div><p class="calibre8">On the other hand, if you don't want to return nothing, use <code class="email">void</code>.</p><div><pre class="programlisting">-(void) storeUserDetails:(NSString *)userName withID(int)userID
{
  self.name = userName;
  self.id = userID;
}</pre></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec37" class="calibre1"/>String formatting</h1></div></div></div><p class="calibre8">When dealing <a id="id101" class="calibre1"/>with different types of objects, especially inserting/appending them into a string, you need to specify their types inside the string, for which we use format specifiers. Printing to the console, for example, requires a string to be printed; it's the only accepted format. Let's see how to insert different objects inside it, to be properly printed to the console:</p><div><pre class="programlisting">// Here we print a message, it's already a string.
NSLog(@"I'm a message. A string");</pre></div><p class="calibre8">However, if you want to print a value stored in a property or instance variable, you should specify its type inside in order to properly replace it with the value outside:</p><div><pre class="programlisting">/*
    Now we print the string value stored on a property
    The console will print the message: "Hello, Mr. Gaius Julius Caesar"
*/
NSString *myStringObject = @"Gaius Julius Caesar";
NSLog(@"Hello, Mr. %@", myStringObject);</pre></div><p class="calibre8">Notice <code class="email">%@</code> inside the message. It specifies that the value is a string. This is how we can specify the object's type, using <a id="id102" class="calibre1"/>a percentage sign, <code class="email">%</code>, followed by a specific keyword (conversion specifier). Using a different conversion specifier for a string will result in compilation error.</p><p class="calibre8">Mostly, specifiers <a id="id103" class="calibre1"/>support more than one data type:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">The format specifier</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Supported object's type</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%d</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Integer (signed int), 32-bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%u</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Integer (unsigned int), 32-bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%x</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Integer (unsigned int) as hexadecimal value, 32-bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%o</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Integer (unsigned int) as octal value, 32-bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%%</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">print "%"</code>
</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%f</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Float, double (point float number), 64-bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%e</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Float, double (point float number) in scientific notation, 64-bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%g</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Float, double (point float number) as <code class="literal">%e</code> if the exponent is less than –4, otherwise as <code class="literal">%f</code>, 64 bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%c</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Unsigned character (unsigned char), 8 bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%S</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">An array of 16-bit Unicode characters, which terminates with a null pointer</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%p</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">A void pointer character (<code class="literal">void *</code>) in hexadecimal, starting with 0x</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%a</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Double (point float number) in scientific notation, starting with 0x and one hexadecimal digit before the decimal point using a lowercase <code class="literal">p</code> to introduce the exponent, 64 bit</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%F</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Double (point float number) in decimal notation</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">%hhd</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">BOOL</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec38" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we were able to see objects in detail, how inheritance works and how you can use it to create even more powerful classes. You learned about an object's mutability and immutability, how instance variables and property work, what they are, and how to create them besides allocation, initialization, and custom methods, and how to create your own. In the next chapter, we will cover application data management such as resource optimization, caching, and data saving. So, see you in the next chapter.</p></div></body></html>