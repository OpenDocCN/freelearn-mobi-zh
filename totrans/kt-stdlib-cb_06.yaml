- en: Friendly I/O Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 友好的I/O操作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Reading the contents of a file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: Ensuring stream closing with the `use` function
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`use`函数确保流关闭
- en: Reading the contents of a file line by line
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐行读取文件内容
- en: Writing the contents to a file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将内容写入文件
- en: Appending a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追加文件
- en: Easy files copying
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的文件复制
- en: Traversing files in a directory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历目录中的文件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter focuses on explaining the Kotlin approach to working with JVM  `File`, `InputStream`,
    and `OutputStream` types. We are going to explore the group of extension functions
    offered by the standard library under the `kotlin.io` package, which focus on
    enhancing support for I/O operations. Note that at the moment, with the Kotlin
    version 1.2, the following recipes are applicable only to code targeting the JVM
    platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍Kotlin在JVM上使用`File`、`InputStream`和`OutputStream`类型的方法。我们将探索由标准库在`kotlin.io`包下提供的扩展函数组，这些函数专注于增强对I/O操作的支持。请注意，目前，在Kotlin版本1.2中，以下食谱仅适用于针对JVM平台的目标代码。
- en: Reading the contents of a file
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取文件内容
- en: In this recipe, we are going to retrieve the contents of a file as text and
    print it to the console. We are going to use the standard library `File.readText()` extension
    function, returning a `String` representing the text content of the given `File`
    instance.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将检索文件内容作为文本并将其打印到控制台。我们将使用标准库的`File.readText()`扩展函数，它返回一个表示给定`File`实例文本内容的`String`。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have a sample non-empty file included in your project to read
    its contents. You can clone the sample project provided with the book's GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook).
    In this recipe, we are going to use the `file1.txt` file located in the `src/main/resources` directory
    in the sample project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的项目中包含一个非空样本文件以读取其内容。你可以克隆书中GitHub仓库提供的样本项目：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)。在本食谱中，我们将使用位于样本项目`src/main/resources`目录中的`file1.txt`文件。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`File.separator`常量并将其分配一个别名：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare a `String` storing a path to the file we are going to read:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个存储将要读取的文件路径的`String`：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instantiate a `File` using the specified path:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的路径实例化一个`File`：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Read the text from the file and print it to the console:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取文本并将其打印到控制台：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `readText()` extension function is returning the `String` value representing
    the text of the given file. This is a convenient way of reading the file contents
    since it wraps the low-level logic of reading bytes from the `FileInputStream`
    class. Under the hood, before reading the bytes of the file, the function checks
    whether the file has the proper size to be stored in memory.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`readText()`扩展函数返回表示给定文件文本的`String`值。这是一个方便读取文件内容的方法，因为它封装了从`FileInputStream`类读取字节的底层逻辑。在底层，在读取文件字节之前，该函数会检查文件是否有适当的大小以存储在内存中。'
- en: Keep in mind that, if the file size is too large, `OutOfMemoryError` is thrown.
    Whenever the file is too big to be processed at once, you should access its content
    using `BufferedReader`. You can easily obtain the `BufferedReader` instance by
    calling the `File.bufferedReader()` extension function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果文件太大，将抛出`OutOfMemoryError`。每当文件太大而无法一次性处理时，你应该使用`BufferedReader`来访问其内容。你可以通过调用`File.bufferedReader()`扩展函数轻松地获得`BufferedReader`实例。
- en: 'The `readText()` function can also take the `charset: Charset` argument, which
    by default is set to the `Charsets.UTF_8` value. If you''d like to use another
    `charset`, you can specify it by passing a proper one as the `charset` argument.
    You can find the available charset types inside the `kotlin.text.Charsets` object.
    You can also find them listed in the official documentation: [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`readText()`函数还可以接受`charset: Charset`参数，默认设置为`Charsets.UTF_8`值。如果你想使用另一个`charset`，你可以通过传递适当的参数作为`charset`来指定它。你可以在`kotlin.text.Charsets`对象中找到可用的charset类型。你还可以在官方文档中找到它们：[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets)。'
- en: You may have noticed we are using the `File.separator` constant instead of the
    hardcoded `"/"` char. Thanks to that, we can be sure the correct directory-separating
    character will be used on different platforms. For the sake of brevity, you can
    import `File.separator` with an alias, for example `import java.io.File.separator
    as separator`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们正在使用`File.separator`常量而不是硬编码的`"/"`字符。多亏了这一点，我们可以确保在不同的平台上使用正确的目录分隔符。为了简洁起见，您可以将`File.separator`导入为别名，例如`import
    java.io.File.separator as separator`。
- en: See also
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can also check out the *Reading the contents of a file line by line* recipe,
    which explains how to read the text content of a file line by line effectively
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以查看*逐行读取文件内容*配方，该配方解释了如何有效地逐行读取文件文本内容。
- en: Ensuring stream closing with the use function
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用use函数确保流关闭
- en: Whenever we are accessing the contents of a `File` via `FileInputStream` or `FileOutputStream`,
    we should remember to close them once we've finished working on the file. Unclosed
    streams may lead to memory leaks and a significant decrease in performance. In
    this recipe, we are going to explore how to employ the `use()` extension function
    offered by the standard library under the `kotlin.io` package for automatic stream
    closing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们通过`FileInputStream`或`FileOutputStream`访问`File`的内容时，我们应该记住在完成文件操作后关闭它们。未关闭的流可能导致内存泄漏和性能显著下降。在这个配方中，我们将探讨如何使用标准库中`kotlin.io`包提供的`use()`扩展函数来自动关闭流。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have a sample non-empty file included in your project to read
    its contents. You can clone the sample project provided with the book's GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook).
    In this recipe, we are going to use the `file1.txt` file located in the `src/main/resources` directory
    in the sample project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的项目中包含一个非空样本文件以读取其内容。您可以通过克隆书中GitHub存储库提供的样本项目：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)。在这个配方中，我们将使用位于样本项目`src/main/resources`目录中的`file1.txt`文件。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`File.separator`常量并将其分配别名：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Declare a `String` storing a path to the file we are going to read:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个存储将要读取的文件路径的`String`：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instantiate a `FileInputStream` for the `file1.txt` file:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`file1.txt`文件实例化`FileInputStream`：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Read the bytes from the stream inside the `use()` function:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`use()`函数内部从流中读取字节：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create the `FileInputStream` instance using the `File.inputStream()`
    extension function. Next, we invoke the `use()` extension function on our stream
    instance, passing a lambda block containing operations we want to perform on the
    stream as the argument.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`File.inputStream()`扩展函数创建`FileInputStream`实例。接下来，我们在我们的流实例上调用`use()`扩展函数，将包含我们想要在流上执行的操作的lambda块作为参数。
- en: 'Under the hood, after invoking the lambda expression, the `use()` function
    calls the `close()` function on the stream variable. We can check that, when we
    try to access the file using the `stream` variable once again, we will get a `java.io.IOException:
    Stream Closed` exception thrown.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '在底层，在调用lambda表达式之后，`use()`函数会在流变量上调用`close()`函数。我们可以检查，当我们再次尝试使用`stream`变量访问文件时，将会抛出一个`java.io.IOException:
    Stream Closed`异常。'
- en: The `use()` function extends any type that implements the `Closeable` interface.
    It takes a lambda block as the argument, passing an instance of the closeable
    resource to the lambda as the parameter. The `use` function returns the value
    returned by the lambda block. Under the hood, there is a `try…catch` block being
    used where the `close()` function of the resource is invoked inside the `finally`
    block.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`use()`函数扩展了实现`Closeable`接口的任何类型。它接受一个lambda块作为参数，将可关闭资源实例作为参数传递给lambda。`use`函数返回lambda块返回的值。在底层，使用了一个`try…catch`块，其中在`finally`块中调用了资源的`close()`函数。'
- en: Reading the contents of a file line by line
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐行读取文件内容
- en: In this recipe, we are going to retrieve the contents of a file as a set of
    consecutive text lines. We are going to use the standard library extension function, `File.readLines()`,
    to return a `List` of a `String` type representing the next lines of the given `File` instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将检索文件内容作为一系列连续的文本行。我们将使用标准库扩展函数`File.readLines()`来返回一个表示给定`File`实例后续行的`String`类型的`List`。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have a sample non-empty file included in your project to read
    its contents. You can clone the sample project provided with the book at the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook).
    In this recipe, we are going to use the `file1.txt` file located in the `src/main/resources` directory
    in the sample project.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的项目中包含一个非空样本文件以读取其内容。你可以在GitHub仓库中找到本书提供的样本项目：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)。在这个菜谱中，我们将使用样本项目中位于`src/main/resources`目录下的`file1.txt`文件。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`File.separator`常量并为其指定别名：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declare a `String` storing a path to the file we are going to read:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`String`，用于存储我们将要读取的文件的路径：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instantiate a `File` using the specified path:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的路径实例化一个`File`：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Read the text from the file and print it to the console:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取文本并将其打印到控制台：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `readLines()` extension function returns the `List<String>` instance representing
    the lines of text of the given file. This is a convenient way of reading the file
    contents since it wraps the low-level logic of reading bytes from the `FileInputStream`
    class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`readLines()`扩展函数返回一个`List<String>`实例，表示给定文件的文本行。这是一种方便读取文件内容的方法，因为它封装了从`FileInputStream`类读取字节的底层逻辑。'
- en: Keep in mind that, if the file size is too large, `OutOfMemoryError` is thrown.
    Whenever the file is too big to be processed at once, you should access its content
    using `BufferedReader`. You can easily obtain the `BufferedReader` instance by
    calling the `File.bufferedReader()` extension function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果文件太大，将抛出`OutOfMemoryError`。每当文件太大而无法一次性处理时，你应该使用`BufferedReader`来访问其内容。你可以通过调用`File.bufferedReader()`扩展函数轻松地获得`BufferedReader`实例。
- en: 'The `readLines()` function can also take the `charset: Charset` argument, which
    by default is set to the `Charsets.UTF_8` value. If you''d like to use another
    charset, you can specify it by passing a proper one as the `charset` argument.
    You can find the available charset types inside the `kotlin.text.Charsets` object.
    You can also find them listed in the official documentation: [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`readLines()`函数还可以接受`charset: Charset`参数，默认设置为`Charsets.UTF_8`值。如果你想使用其他字符集，你可以通过传递适当的参数作为`charset`来指定它。你可以在`kotlin.text.Charsets`对象中找到可用的字符集类型。你还可以在官方文档中找到它们：[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets)。'
- en: You may have noticed we are using the `File.separator` constant instead of the
    hardcoded `"/"` char. Thanks to that, we can be sure the correct directory-separating
    character will be used on different platforms. For the sake of brevity, you can
    import `File.separator` with an alias, for example `import java.io.File.separator
    as separator`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们使用的是`File.separator`常量而不是硬编码的`"/"`字符。多亏了这一点，我们可以确保在不同的平台上使用正确的目录分隔符。为了简洁起见，你可以使用别名导入`File.separator`，例如`import
    java.io.File.separator as separator`。
- en: See also
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考内容
- en: You can also check out the *Reading the contents of a file* recipe, which explains
    how to retrieve the text contents of the file at once as the `String` value
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以查看*读取文件内容*菜谱，它解释了如何一次性检索文件的文本内容作为`String`值
- en: Writing the contents to a file
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将内容写入文件
- en: In this recipe, we are going to learn how to easily create a new `File` and
    write text to it. We are going to use the `File.writeText()` extension function
    offered by the standard library. Then, we are going to verify whether the file
    was successfully created and whether it contains the proper contents by printing
    it to the console.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何轻松创建一个新的`File`并向其写入文本。我们将使用标准库提供的`File.writeText()`扩展函数。然后，我们将通过将其打印到控制台来验证文件是否已成功创建以及是否包含正确的内容。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`File.separator`常量并为其指定别名：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Specify the path to the new file we are going to create:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定我们将要创建的新文件的路径：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instantiate the file using the specified file path:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的文件路径实例化文件：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Write the text to the file using the `writeText()` function inside the `apply`
    block:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`apply`块中使用`writeText()`函数将文本写入文件：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Print the contents of `temp_file` to the console:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`temp_file`的内容打印到控制台：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As the result of executing the preceding code, a new `temp_file` file is going
    to be created under the `src/main/resources` directory. Keep in mind that in case
    the `temp_file` already exists it is going to be overridden. Next, with the help
    of the `writeText()` function its contents are going to be printed to the console:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，将在`src/main/resources`目录下创建一个新的`temp_file`文件。请注意，如果`temp_file`已存在，它将被覆盖。接下来，使用`writeText()`函数，其内容将被打印到控制台：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `writeText()` function wraps the `java.io.FileOutputStream` API, providing
    a neat way of writing content to the file. Under the hood, it accesses `FileOutputStream`
    inside the `use()` function, so you can be sure that it autocloses any streams
    that are opened during the write operation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeText()`函数封装了`java.io.FileOutputStream` API，提供了一种优雅的方式将内容写入文件。在底层，它访问`use()`函数中的`FileOutputStream`，因此您可以确信它会在写入操作期间自动关闭任何打开的流。'
- en: If the text you want to write to the file is too large to be processed at once,
    you can use the `BufferedWriter` API to allow you to write and append the file.
    You can easily obtain an instance of `BufferedWriter` using the `File.bufferedWriter()`
    extension function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要写入文件中的文本太大，无法一次性处理，您可以使用`BufferedWriter` API来允许您写入和追加文件。您可以使用`File.bufferedWriter()`扩展函数轻松地获取`BufferedWriter`的实例。
- en: 'You can also pass the additional `charset: Charset` argument to `writeText()`,
    which by default is equal to the `Charsets.UTF_8` value. If you''d like to use
    another charset, you can specify it by passing a proper one as the `charset` argument.
    You can find the available charset types inside the `kotlin.text.Charsets` object.
    You can also find them listed in the official documentation at [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '您还可以向`writeText()`函数传递额外的`charset: Charset`参数，默认值为`Charsets.UTF_8`。如果您想使用其他字符集，可以通过传递适当的参数作为`charset`来指定它。您可以在`kotlin.text.Charsets`对象中找到可用的字符集类型。您也可以在官方文档中找到它们，链接为[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets)。'
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: Check out the *Appending a file* recipe to learn how to modify a file's content
    in a flexible way by appending it
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看关于*追加文件*的食谱，了解如何通过追加内容以灵活的方式修改文件内容
- en: Appending a file
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追加文件
- en: In this recipe, we are going to learn how to easily create a new `File` and
    write text to it by appending its content a number of times. We are going to use
    the `File.appendText()` extension function offered by the standard library. Then,
    we are going to verify whether the file was successfully created and whether it
    contains the proper content by printing it to the console.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何通过使用标准库提供的`File.appendText()`扩展函数轻松地创建一个新的`File`并写入文本。我们将通过多次追加其内容来验证文件是否成功创建以及是否包含正确的内容，并将其打印到控制台。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`File.separator`常量并将其分配一个别名：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Specify the path to the new file we are going to create:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定将要创建的新文件的路径：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instantiate the file using the specified file path:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指定的文件路径实例化文件：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Delete the file if it already exists:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件已存在，则删除该文件：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Append the file with the next String values:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用下一个字符串值追加文件：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Print the file''s contents to the console:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件内容打印到控制台：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result of executing the preceding code, a new `temp_file` file is going
    to be created under the `src/main/resources` directory, and its content is going
    to be printed out to the console:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码后，将在`src/main/resources`目录下创建一个新的`temp_file`文件，并且其内容将被打印到控制台：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `appendText()` and `appendBytes()` functions wrap the `java.io.FileOutputStream`
    API, providing a neat way of appending content to the file. Under the hood, they
    access `FileOutputStream` inside the `use()` function, so you can be sure that
    it autocloses any streams that are opened during the write operation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`appendText()`和`appendBytes()`函数封装了`java.io.FileOutputStream` API，提供了一种优雅的方式将内容追加到文件中。在底层，它们在`use()`函数中访问`FileOutputStream`，因此您可以确信它会在写入操作期间自动关闭任何打开的流。'
- en: If the text you want to write to the file is too large to be processed at once,
    you can use the `BufferedWriter` API, which allows you to write and append the
    file. You can easily obtain an instance of `BufferedWriter` using the `File.bufferedWriter()`
    extension function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想写入文件中的文本太大，一次无法处理，你可以使用`BufferedWriter` API，它允许你写入和追加文件。你可以通过使用`File.bufferedWriter()`扩展函数轻松地获得`BufferedWriter`实例。
- en: 'You can also pass the additional `charset: Charset` argument to the `appendText()`
    function, which by default is equal to the `Charsets.UTF_8` value. If you''d like
    to use another charset, you can specify it by passing a proper one as the `charset`
    argument. You can find the available charset types inside the `kotlin.text.Charsets`
    object. You can also find them listed in the official documentation at [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '你还可以将额外的`charset: Charset`参数传递给`appendText()`函数，默认值等于`Charsets.UTF_8`。如果你想使用其他字符集，你可以通过传递适当的参数作为`charset`参数来指定它。你可以在`kotlin.text.Charsets`对象中找到可用的字符集类型。你还可以在官方文档中找到它们，网址为[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-charsets)。'
- en: Easy file copying
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的文件复制
- en: In this recipe, we are going to explore a neat way of copying a file's contents
    into a new file. We are going to obtain a sample `File` instance from the specified
    path and copy its content into the new file. Finally, we are going to print the
    contents of both files to the console to verify the operation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索一种将文件内容复制到新文件中的巧妙方法。我们将从指定的路径获取一个样本`File`实例，并将其内容复制到新文件中。最后，我们将打印两个文件的内容到控制台以验证操作。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have a sample non-empty file included in your project to read
    its contents. You can clone the sample project provided with the book at the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook).
    In this recipe, we are going to use the `file2.txt` file located in the `src/main/resources` directory
    in the sample project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的项目中包含一个非空样本文件以读取其内容。你可以在GitHub仓库中克隆本书提供的样本项目：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)。在这个菜谱中，我们将使用位于样本项目`src/main/resources`目录中的`file2.txt`文件。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`File.separator`常量并为其指定别名：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Instantiate a `File` instance for the specified `file2.txt` path:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为指定的`file2.txt`路径实例化一个`File`对象：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create a new `File` called `file2_copy.txt`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`file2_copy.txt`的新`File`：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If `file2_copy.txt` exists, delete it:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`file2_copy.txt`存在，则删除它：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Copy the contents of `file2.txt` to the `file2_copy.txt` file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`file2.txt`的内容复制到`file2_copy.txt`文件中：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Print both files to the console for verification:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个文件打印到控制台以进行验证：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You can run the sample code to verify that, after invoking the `copyTo()` extension
    function, both files contain the same text content. In our case, we get the following
    output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行样本代码以验证，在调用`copyTo()`扩展函数后，两个文件包含相同的内容。在我们的例子中，我们得到以下输出：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Under the hood, the `copyTo()` function reads `InputStream` in the source file
    to the buffer and writes it to the `OutputStream` target file. Internally, streams
    are being accessed inside the `use()` function block, which closes them automatically
    after the operation finishes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`copyTo()`函数读取源文件中的`InputStream`到缓冲区，并将其写入目标文件的`OutputStream`。内部，流在`use()`函数块中被访问，操作完成后会自动关闭它们。
- en: 'Apart from the target `File` instance, the `copyTo()` function takes two optional
    parameters—`overwrite: Boolean`, which is set to false by default, and `bufferSize:
    Int`, which is assigned to the default value. Keep in mind that, whenever some
    directories on a way to the target file are missing, they will be created. Also,
    if the target file already exists, the `copyTo()` function will fail, unless the
    override argument is set to `true`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '除了目标`File`实例外，`copyTo()`函数还接受两个可选参数——`overwrite: Boolean`，默认设置为`false`，以及`bufferSize:
    Int`，默认值。请注意，无论目标文件路径上的哪些目录缺失，它们都将被创建。此外，如果目标文件已存在，`copyTo()`函数将失败，除非覆盖参数设置为`true`。'
- en: When the `overwrite` parameter is set to `true` and `target` points to a directory,
    it will be replaced only if it is empty.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`overwrite`参数设置为`true`且`target`指向一个目录时，只有当它为空时才会替换。
- en: If you invoke `copyTo()` on a `File` instance that points to a directory, it
    will be copied without its content. Only an empty directory will be created under
    the target path.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在一个指向目录的 `File` 实例上调用 `copyTo()`，它将不带内容进行复制。在目标路径下只会创建一个空目录。
- en: The `copyTo()` function doesn't preserve copied file attributes, that is, the creation/modification
    date and permissions.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copyTo()` 函数不会保留复制的文件属性，也就是说，不会保留创建/修改日期和权限。'
- en: Traversing files in a directory
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历目录中的文件
- en: In this recipe, we are going to explore how to traverse files in a given directory.
    We are going to obtain a `FileTreeWalk` class instance from a given `File` pointing
    to the directory. We are going to iterate through all the files inside the given
    directory, including any nested subdirectories. We will also filter the files
    to exclude those without the `.txt` extension and print their paths and contents
    to the console.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何遍历给定目录中的文件。我们将从指向目录的给定 `File` 获取 `FileTreeWalk` 类实例。我们将遍历给定目录内的所有文件，包括任何嵌套的子目录。我们还将过滤文件，排除那些没有
    `.txt` 扩展名的文件，并将它们的路径和内容打印到控制台。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure you have the sample files with the `.txt` extension included in your
    project. You can clone the sample project provided with the book at the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook).
    In this recipe, we are going to use the `src/main/resources` directory and its
    contents from the sample project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的项目中包含了具有 `.txt` 扩展名的样本文件。您可以从 GitHub 仓库中克隆本书提供的样本项目：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook)。在这个菜谱中，我们将使用样本项目的
    `src/main/resources` 目录及其内容。
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Import the `File.separator` constant and assign an alias to it:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `File.separator` 常量并将其分配一个别名：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Obtain the `FileTreeWalk` instance from the `File` pointing to the `src/main/resources`
    directory:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从指向 `src/main/resources` 目录的 `File` 获取 `FileTreeWalk` 实例：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Iterate through the all non-empty `.txt` files and print:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有非空 `.txt` 文件并打印：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We start by instantiating the `File` type instance that references the `src/main/resources`
    directory and invoking the `walk()` function on it. `walk()` returns the `FileTreeWalk`
    instance, which is a high-level abstraction layer over the filesystem and allows
    us to iterate through the files and subdirectories of the original `File` object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实例化一个引用 `src/main/resources` 目录的 `File` 类型实例，并在其上调用 `walk()` 函数。`walk()`
    返回 `FileTreeWalk` 实例，这是一个在文件系统之上的高级抽象层，允许我们遍历原始 `File` 对象的文件和子目录。
- en: '`FileTreeWalk` extends a `Sequence<File>` interface and provides an `Iterator<File>`
    implementation, which allows us to iterate through the files and apply any transforming
    operations to them, in the same way we do while working with collections.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileTreeWalk` 扩展了 `Sequence<File>` 接口，并提供了 `Iterator<File>` 实现，这允许我们遍历文件并对它们应用任何转换操作，就像我们在处理集合时做的那样。'
- en: Next, we apply a few filtering operations—removing the `File` objects referencing
    directories, removing files that don't contain the `.txt` extension, and removing
    any empty files from the sequence. Finally, we use the `forEach()` function to
    print the paths of the consecutive files together with their contents.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应用一些过滤操作——移除引用目录的 `File` 对象，移除不包含 `.txt` 扩展名的文件，以及从序列中移除任何空文件。最后，我们使用
    `forEach()` 函数一起打印连续文件的路径及其内容。
- en: As you can observe, the default order provided by the `FileTreeWalk` sequence
    is from top to bottom. We can define a reversed sequence by calling the `walk()`
    function with a `direction` parameter set to `FileWalkDirection.BOTTOM_UP`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所观察到的，`FileTreeWalk` 序列提供的默认顺序是从上到下。我们可以通过调用 `walk()` 函数并设置 `direction` 参数为
    `FileWalkDirection.BOTTOM_UP` 来定义一个反向序列。
- en: There are also two out-of-the-box specialized variants of the `walk()` function
    available—`File.walkTopDown()` and `File.walkBottomUp()`. The first one returns
    the `FileTreeWalk` instance with the direction property set to `FileWalkDirection.TOP_DOWN`,
    and the second one sets `direction` to `FileWalkDirection.BOTTOM_UP`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`walk()` 函数也有两种现成的专用变体可用——`File.walkTopDown()` 和 `File.walkBottomUp()`。前者返回一个
    `FileTreeWalk` 实例，其方向属性设置为 `FileWalkDirection.TOP_DOWN`，而后者将 `direction` 设置为 `FileWalkDirection.BOTTOM_UP`。'
