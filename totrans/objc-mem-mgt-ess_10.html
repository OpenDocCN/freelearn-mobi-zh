<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10" class="calibre1"/>Chapter 10. Tips and Tricks for Memory Management</h1></div></div></div><p class="calibre8">Memory management<a id="id340" class="calibre1"/> is something that every programmer dealing with Objective-C will encounter although Apple introduces a lot of tools to assist in ferreting out memory-related issues such as Instruments and NSZombies. There are some more subtle techniques and tools that are present in Objective-C and Xcode, which we will be looking into in this chapter. Some are obvious and some will give you a new perspective with regards to Objective-C. We will also cover some important topics such as:</p><div><ul class="itemizedlist"><li class="listitem">Using the @property keyword</li><li class="listitem">Using the getter/setter methods</li><li class="listitem">Understand the property attribute in Objective-C</li><li class="listitem">When to avoid KVC and KVO</li></ul></div><p class="calibre8">So, let's get started!</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch10lvl1sec72" class="calibre1"/>Objective-C, C, and memory management</h1></div></div></div><p class="calibre8">Objective-C<a id="id341" class="calibre1"/> and the C programming language<a id="id342" class="calibre1"/> are closely related as Objective-C is a proper superset <a id="id343" class="calibre1"/>of C, which means that anything that works in<a id="id344" class="calibre1"/> C will work with Objective-C. So inherently, it also means that memory management methods and protocols that you are familiar with in C or C++ will also apply to Objective-C. However, a good thing about Objective-C is that the compiler does a lot of this memory management for you under the hood. This means that you do not need to write too much code to handle memory management in Objective-C compared to C or C++. </p><p class="calibre8">However, do note that although you can mix C++ and Objective-C together, Objective-C is not a superset of C++. This does not mean that you can be totally hands off with regards to memory management since Objective-C does not have a garbage collector like what you get in Java.</p><p class="calibre8">With the release of <strong class="calibre2">Automatic Reference Counting</strong> (<strong class="calibre2">ARC</strong>)<a id="id345" class="calibre1"/> support in Xcode 4.2 and iOS 4 and 5 onwards, developers everywhere thought that their days of laborious memory management are over, but make no mistake as you need to keep in mind that ARC is a compile time memory management mechanism, where the compiler will examine the source code and then add the <code class="email">retain</code> and <code class="email">release</code> messages into the compiled code. ARC is not the traditional garbage collection mechanism that Java and C# programmers are familiar with where garbage collection is done during runtime by the garbage collector.</p><p class="calibre8">So, the introduction of ARC means that there is even less typing for you as a developer as you do not need to type in <code class="email">retain</code> and <code class="email">release</code> messages explicitly into your code, which makes your code more verbose. However, as we saw in the previous chapters where we introduced retain cycles and other types of memory leaks, using ARC means that you will still need to be aware of memory management principles and that is where Objective-C and Xcode shines compared to their C programming language counterparts. Its built-in mechanism helps programmers avoid leaking memory through a series of good practices. So, let's start by looking at these good practices in detail in this chapter.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec73" class="calibre1"/>Getters and setters</h1></div></div></div><p class="calibre8">If you have <a id="id346" class="calibre1"/>done some Java and C# programming and come from a Java or C# background, you should be familiar with getter and setter methods or you may also know them as accessors and mutators, respectively. They are a fundamental pillar of good programming. Getters/setters or accessors/mutators, are also known as methods used in keeping the principle of encapsulation where member variables are made private to protect them from other code which could be potentially malicious, and the getter/setter acts as a gatekeeper or intermediary between the private member variable and other code. Take a look at the following lines of code:</p><div><pre class="programlisting">public int getAge()
{
  return Age;
}
public void setAge(int _age)
{
  Age = _age
}</pre></div><p class="calibre8">The preceding<a id="id347" class="calibre1"/> two methods should not be unfamiliar to you from a Java or C# perspective. Getters and setters can be considered bad if used improperly. Making a variable public and yet writing a getter and setter method is a good example as this violates the concept of encapsulation. Now, getter and setter methods are a good foundation for recommended programming practices as they confer the following benefits and more:</p><div><ul class="itemizedlist"><li class="listitem">Hiding the internal state of the objects</li><li class="listitem">Setting different access levels such as read only, write only, and so on</li><li class="listitem">Creating a public interface will make it easier for you to make code changes when you need to change the implementation layer, which will be apparent when you need to make changes across many files</li><li class="listitem">Allowing you to enforce strict rules on what can be done and not be done with your objects via these getter and setter methods</li></ul></div><p class="calibre8">Getter and setter methods generally start with the get and set prefix. This may come as a surprise to you, but Objective-C has very strong support for getter and setter methods. However, you may ask, "where are the getter and setter methods in Objective-C? I don't recall setting any methods or writing any code that start with <code class="email">get</code> or <code class="email">set</code>?" However, actually, they are present and are already in your code, but you just do not realize it yet since Objective-C has an abstraction layer for you so that you do not need to spend too much time writing getter and setter methods. This abstraction layer allows you to customize your getter and setter methods as we shall see later on. The way that Objective-C lets you define get and set methods and the various attributes such as <code class="email">readonly</code>, <code class="email">readwrite</code>, and so on is via the <code class="email">@property</code> keyword in your code. Getters and setters go hand in hand with memory management as you can write code to clean up the memory in these methods if you need to.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec74" class="calibre1"/>The property attribute in Objective-C</h1></div></div></div><p class="calibre8">If you <a id="id348" class="calibre1"/>have <a id="id349" class="calibre1"/>been doing some Objective-C programming, you would have come across the following syntax:</p><div><pre class="programlisting">@property (nonatomic, readonly) UIView *rearView;
or
@property (nonatomic, retain) UIActivityIndicatorView *loadingView;</pre></div><p class="calibre8">Now, I <a id="id350" class="calibre1"/>would bet that you would generally have a foggy idea of what terms such as <code class="email">nonatomic</code> or <code class="email">retain</code> mean when you are assigning these properties such as <code class="email">nonatomic</code> and so on to your objects. These keywords, such as <code class="email">nonatomic</code> or <code class="email">readonly</code>, actually define the properties of your objects, which are used in the getter and setter methods <a id="id351" class="calibre1"/>automatically created for you in Xcode. These terms are coding keywords related to memory management and access control and were not created just to baffle you or to give you additional typing to do (at least not as much typing as typing getter and setter methods themselves). Anyway, let's go through what these terms mean so that you will get a better understanding of these keywords in relation to getter and setters:</p><div><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Attribute name</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Description</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">nonatomic</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This<a id="id352" class="indexterm"/> property is not thread safe, but it is faster than <code class="literal">atomic</code>.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">atomic</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This<a id="id353" class="indexterm"/> property is used for completeness and will not allow bad things to happen if a different thread tries to access this object at some point in your code. However, it is slower than <code class="literal">nonatomic</code> due to additional bookkeeping overhead required.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">strong</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This is <a id="id354" class="indexterm"/>used with ARC and helps by not letting you worry about the retain count of an object as it is autoreleased when you are done with it. In code that does not support ARC, it is a synonym for the retain property.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">weak</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This <a id="id355" class="indexterm"/>means that the reference count is not increased by 1, and it does not become an owner of an object, but it does hold a reference to it. This is just another term for <code class="literal">unsafe_unretained</code> for the non-ARC code.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">assign</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This<a id="id356" class="indexterm"/> property will generate a setter method, which will assign the value to the object instead of copying or retaining it.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">copy</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This is <a id="id357" class="indexterm"/>used for when the object is mutable where you create a copy of the object. Do note that copy cannot be used together with retain as the copy of the object will already have its retain count incremented by 1.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">readonly</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This<a id="id358" class="indexterm"/> property will make the object read-only and no setter method will be created in the <code class="literal">@implementation</code> section of the code.</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">
<code class="literal">readwrite</code>
</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">This <a id="id359" class="indexterm"/>means that the <code class="literal">read</code> and <code class="literal">write</code> attribute properties are applicable and the getter and setter methods are automatically created for you.</p>
</td></tr></tbody></table></div><p class="calibre8">So, <code class="email">@property(nonatomic, retain) NSString *text</code> will tell the compiler, "I have a member variable of the type NSString named text, so I will need a pair of getter/setter methods, which will use the retain/release procedure."</p><p class="calibre8">Now that <a id="id360" class="calibre1"/>you have defined the attributes of your member variables such as which one has <code class="email">readonly</code>, which one has <code class="email">readwrite</code>, and so on, what next?</p><p class="calibre8">Next, you <a id="id361" class="calibre1"/>will use the <code class="email">@synthesize</code> keyword. The <code class="email">@synthesize</code> keyword will tell the compiler, "Now that I have declared the property <code class="email">nonatomic</code> and <code class="email">retain</code> for my <code class="email">NSString *text</code> object, please create the code now for the getter and setter pair of methods for my <code class="email">NSString *text</code> object."</p><p class="calibre8">So, with just these two lines of code, we can tell Objective-C to create our getter and setter methods for us and assign properties such as read-only, write-only, and so on for our objects or variables. This is much better than typing in verbose getter and setter code as you would do in Java or C#.</p><div><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre8">Do note that <code class="email">@synthesize</code> is automatically provided to you by default in Xcode 4.4 and onwards, but there may be cases where you need to add in the <code class="email">@synthesize</code> keyword yourself explicitly, which we will go through later.</p></div><p class="calibre8">Now you know why <code class="email">@synthesize</code> does what it does. <code class="email">@property</code> and <code class="email">@synthesize</code> helps to automate the creation of getter and setter methods along with ease of creation with regards to access rules and controls with only a few lines of code. The getter and setter methods <a id="id362" class="calibre1"/>do exist once you use <code class="email">@property</code> and <code class="email">@synthesize</code>, but you do not see them physically in your code as these methods do not show up in your code base, but you can actually have access to them.</p><p class="calibre8">Take a look at my property declaration here:</p><div><pre class="programlisting">@property (nonatomic, readwrite) int myInt;

@synthesize myInt;</pre></div><p class="calibre8">In your implementation file, you will find that the following code will compile perfectly fine, and this shows that <code class="email">_myInt</code> is accessing the variable directly:</p><div><pre class="programlisting">int yourInt = _myInt;</pre></div><p class="calibre8">Once the <a id="id363" class="calibre1"/>variable is synthesized, an instance variable (or iVar for short) is automatically created and prefaced with an underscore. The presence of this underscore in a variable name is a naming convention to indicate that this is an iVar, and this is done automatically for you within Objective-C.</p><p class="calibre8">So, this is why there is no compiler error when you call <code class="email">_myInt</code> as <code class="email">_myInt</code> is automatically created for you by the compiler when you tell the compiler the properties of what <code class="email">myInt</code> will do.</p><p class="calibre8">
<code class="email">@synthesize</code> will also create the validation rules, which you assign to a variable using your <code class="email">@property</code> keyword. Validation rules such as <code class="email">readonly</code> means that when you try to assign a value to your variable, you will get a compiler error <strong class="calibre2">read only property cannot be reassigned</strong>, and that is the validation rule of your automatically created setter (mutator) method at work without the writing of verbose code.</p><p class="calibre8">Let's look at some code, shall we? Let's create an object called <code class="email">UserObject</code> and assign a variable call <code class="email">Age</code> to it.</p><p class="calibre8">So, let's get started!</p><div><ol class="orderedlist"><li class="listitem" value="1">We begin by clicking on <strong class="calibre2">File</strong> | <strong class="calibre2">New</strong> or by pressing <em class="calibre9">Command</em> + <em class="calibre9">N</em> on your keyboard, and select <strong class="calibre2">Cocoa Touch</strong> and <strong class="calibre2">Objective-C class</strong>, as shown here:<div><img src="img/00050.jpeg" alt="The property attribute in Objective-C" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="2">Next, we <a id="id364" class="calibre1"/>put in the<a id="id365" class="calibre1"/> name of the class, which is <code class="email">UserObject</code>, and leave it as a subclass of <code class="email">NSObject</code>:<div><img src="img/00051.jpeg" alt="The property attribute in Objective-C" class="calibre10"/></div><p class="calibre23"> </p></li><li class="listitem" value="3">Then, click <a id="id366" class="calibre1"/>on <strong class="calibre2">Next</strong> followed by <strong class="calibre2">Create</strong> and your <code class="email">UserObject</code> class will be created for you. Then, you should end up with<a id="id367" class="calibre1"/> this in your <code class="email">UserObject.h</code> file. Add an integer called <code class="email">age</code> and assign the <code class="email">nonatomic</code> and <code class="email">readonly</code> properties to it in your <code class="email">UserObject</code> header file, as shown here:<div><pre class="programlisting">#import &lt;Foundation/Foundation.h&gt;

@interface UserObject : NSObject
{
    int age;
}
@property (readwrite, nonatomic) int age;
@end</pre></div></li><li class="listitem" value="4">Now if you try to build your code, you will get a warning, <strong class="calibre2">Autosynthesized property 'age' will use synthesized instance variable '_age', not existing instance variable 'age',</strong> because <a id="id368" class="calibre1"/>you have not explicitly added in the code <code class="email">@synthesize age</code> in the <code class="email">.m</code> implementation file of your <code class="email">UserObject</code> class.<p class="calibre25">This warning is just a friendly reminder that since you did not add in the <code class="email">@synthesize age</code> code, Xcode will create an instance variable called <code class="email">_age</code> for all your setter and getter methods. This is a harmless warning, but for me, I prefer to keep my code as warning free as possible, so I will add the <code class="email">@synthesize age;</code> line of code to my <code class="email">.m</code> implementation file of <code class="email">UserObject</code> and get something like this:</p><div><pre class="programlisting">@implementation UserObject

@synthesize age;//This is to remove the warning

@end</pre></div></li><li class="listitem" value="5">Next, we <a id="id369" class="calibre1"/>add <code class="email">NSString *name</code> to our <code class="email">UserObject</code> class and assign the <code class="email">readwrite</code>, <code class="email">nonatomic</code> property so that our code will now look as follows. The <code class="email">readwrite</code> property as shown previously will tell the compiler that we want getter and setter methods to be automatically created for us and that the <code class="email">nonatomic</code> property means that we are okay with the <code class="email">age</code> variable being non-thread-safe:<div><pre class="programlisting">@interface UserObject : NSObject
{
    int _age;
    NSString *name;
}

@property (readwrite, nonatomic) int age;
@property (readwrite, nonatomic) NSString *name;
@end

while our .m implementation file will look like this



#import "UserObject.h"

@implementation UserObject

@synthesize age, name;

@end</pre></div></li><li class="listitem" value="6">We can now create an instance of the <code class="email">UserObject</code> class using <code class="email">UserObject *user = [[UserObject alloc] init]</code>.</li><li class="listitem" value="7">Next, we <a id="id370" class="calibre1"/>can see the magic of Xcode, where we put in the following code:<div><pre class="programlisting">[user setName:"Joe"];</pre></div><p class="calibre25">Notice that we did not create a getter or setter method for our <code class="email">NSString *name</code>, but Xcode was smart enough to create it for us once we assigned the properties to <code class="email">NSString *name</code>.</p></li><li class="listitem" value="8">However, in <a id="id371" class="calibre1"/>some specific cases, you may want to override the default getter and setter methods that Xcode provides. Doing so is very easy, and using our <code class="email">int age</code> as an example, we just create the following methods in our <code class="email">UserObject .h</code> header file:<div><pre class="programlisting">-(void) setAge:(int)aAge;
-(int) getAge;</pre></div></li><li class="listitem" value="9">We put in our custom getter and setter methods in our <code class="email">.m</code>, <code class="email">UserObject</code> implementation file as follows:<div><pre class="programlisting">-(void) setAge:(int)aAge;
{
    int MIN_AGE = 20;//add in our validation logic for our setter here
    if (aAge &lt; MIN_AGE)
        age = 20;
    else
        age = aAge;
}

-(int) getAge
{
    return age;
}</pre></div></li></ol><div></div><p class="calibre8">So now, when you call the <code class="email">setAge</code> method explicitly using the syntax such as <code class="email">[self setAge];</code>, the code will call your custom setter method, since you have added your own getter and setter <a id="id372" class="calibre1"/>code to override the default getter and setter code that Xcode has created for you. This gives you efficiency and flexibility as Xcode will assume<a id="id373" class="calibre1"/> that you want the default getter and setter methods for your variables, and yet, you are free to override them if you need to which could occur in special cases.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec75" class="calibre1"/>Performance guidelines</h1></div></div></div><p class="calibre8">Although<a id="id374" class="calibre1"/> iOS devices such as iPhones and iPads have a lot of memory compared to the early Nokia phones, it does not mean that you can be sloppy with regards to memory management. The iOS memory model and other mobile OSes do not include disk swap space, which are present on computer OSes, where persistent storage space is used as an extension of the memory space so that persistent storage can be used as a form of RAM for situations where low memory is encountered. So, the apps that you develop for iOS devices are more limited in the amount of memory that you can access.</p><p class="calibre8">Using large amounts of memory will lead to a serious degradation of system performance and triggering of the three memory warning levels, where the last warning level will lead to your application crashing. Plus, apps running under multitasking will share system memory with all other running apps that have higher priority such as the SMS application and phone application. So, you will never have 100 percent of the phone memory available for your application under any circumstance and even a brand new iOS device will have background processes running. So, reducing the amount of memory used by your iOS app should be a high priority task and not something that should be filed under a low priority tag.</p><p class="calibre8">If there is less free memory available in your device, that means the system will have a higher probability of being unable to fulfill future memory requests. If such a situation was to occur, the system will remove suspected apps and nonvolatile resources from memory. However, this is not a good solution as this is only temporary and those suspended apps and nonvolatile resources may be needed again a short while later.</p><p class="calibre8">The <code class="email">UIViewController</code> class<a id="id375" class="calibre1"/> in <code class="email">UIKit</code> in the iOS SDK provides useful ways to help you receive memory warnings in the console, which we saw in the previous chapters. I have listed three <a id="id376" class="calibre1"/>ways to<a id="id377" class="calibre1"/> implement memory warning notifications:</p><div><ul class="itemizedlist"><li class="listitem">You should implement the <code class="email">applicationDidReceiveMemoryWarning</code> delegate method as this will be triggered when your application has some low memory warnings.</li><li class="listitem">To get a more granular memory warning such as <code class="email">Received memory warning. Level=1</code> or <code class="email">Received memory warning. Level=2</code> in your debug console, specifically for your <code class="email">UIViewController</code>, you can implement the <code class="email">didReceiveMemoryWarning</code> method of your custom <code class="email">UIViewController</code> subclass.</li><li class="listitem">To get down to a class level, you can register your object to receive the <code class="email">UIApplicationDidReceiveMemoryWarningNotification</code> notification via the <code class="email">addObserver</code> method to call a specific method once the memory is running low, as shown here:<div><pre class="programlisting">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(seeMemoryWarning:) name: UIApplicationDidReceiveMemoryWarningNotification object:nil];
- (void) seeMemoryWarning:(NSNotification *)notification
{
  NSLog(@"Low memory");
}</pre></div></li></ul></div><p class="calibre8">Once you see any of these warnings triggered in your code, you should respond immediately by looking at how you can write the code to free up any unwanted memory. A few ways to do this can be:</p><div><ul class="itemizedlist"><li class="listitem">Removing any views that are not visible to the user but are still loaded in memory by calling the <code class="email">removeFromSuperview</code> method such as <code class="email">[myView removeFromSuperview];</code></li><li class="listitem">Releasing any images that are not on screen by setting them to <code class="email">nil</code></li><li class="listitem">Purging any data structures that are not used by your code at this point in time by calling the <code class="email">release</code> method</li></ul></div><p class="calibre8">Imagine that you have a memory leak in your application and the leak causing the crash only appears after using the application for 2 hours. So, if you wish to replicate the memory leak and<a id="id378" class="calibre1"/> trigger the crash in your code, you need to run the application for 2 hours each time to see the crash. This can be a time consuming task as you need to leave your app running, but thankfully, Xcode provides a way to trigger the memory warning without actually producing a memory leak, and this feature comes courtesy of the iOS simulator. You <a id="id379" class="calibre1"/>can click on <strong class="calibre2">Hardware</strong> | <strong class="calibre2">Simulate Memory Warning</strong> in order to trigger a memory warning so that you can write and test your memory cleanup code under the relevant memory warning method handler. </p><p class="calibre8">The following diagram shows where you need to click to trigger a memory warning:</p><div><img src="img/00052.jpeg" alt="Performance guidelines" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Doing so will allow you to test your iOS application under low memory conditions and then write the relevant code to reduce memory usage.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec76" class="calibre1"/>Don't overthink about memory management</h1></div></div></div><p class="calibre8">Memory management is <a id="id380" class="calibre1"/>not something that is overly complex or difficult to wrap your head around. So, in order to further aid you with memory management, here are a few handy tips:</p><div><ul class="itemizedlist"><li class="listitem">You can try to make your resource files such as audio, images, and property lists as small as possible. To reduce the space occupied by property list files, you can use the <code class="email">NSPropertyListSerialization</code> class while the free, open source command-line tool called Pngcrush can be used to compress PNG files as you can have savings of 20 percent or more depending on your PNG files.</li><li class="listitem">Core Data is more than just a persistent storage framework. Core Data provides a memory efficient way of managing large data sets, and if you manipulate large structured data, using the Core Data persistent store or SQLite database as a data store as opposed to NSData or NSUserDefault will ensure that you can have efficient memory usage provided by Apple's own Core Data framework.</li><li class="listitem">Resources should always be loaded when you need it, such as when you only need to see it on the device screen. This is called lazy loading, which we have seen in the previous chapter. You could be tempted to load all resources much in advance before you actually use it. However, this will actually mean that your resource is occupying memory when it is actually not being used at the current moment. So to optimize memory usage, always practice lazy loading.</li><li class="listitem">Finally, this is a little-known tip that you can use in your <strong class="calibre2">Build Settings</strong>: you can add the <code class="email">-mthumb</code> compiler flag to help reduce the size of your code by using 16-bit instructions instead of 32-bit instructions, which uses up less space and this can result in savings of up to 35 percent. However, one caveat is that if your iOS application floating point intensive code and your application needs to support ARMv6 such as older generation iPod Touches and older iPhones, then the <code class="email">-mthumb</code> option should not be used for your application. However, if your code is for ARMv7, then you can enable the <code class="email">-mthumb</code> option in your Xcode project, which is enabled by default.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec77" class="calibre1"/>When to avoid KVC and KVO</h1></div></div></div><p class="calibre8">KVC and KVO, which<a id="id381" class="calibre1"/> we covered previously in <a class="calibre1" title="Chapter 7. Key-value Programming Approaches" href="part0056_split_000.html#page">Chapter 7</a>, <em class="calibre9">Key-value Programming Approaches</em>, seems like a great mechanism for notifications at a very granular level, but it is possible to go wrong with KVO if you use it incorrectly. The <code class="email">removeObserver</code> method will crash if you are not the observer for that key path, so keeping an exact track of the properties that you are observing is a must.</p><p class="calibre8">KVO only has <a id="id382" class="calibre1"/>one callback method. If you have multiple notifications, you need to handle them within one callback method, which makes your code inelegant and clunky like this:</p><div><pre class="programlisting">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
  if ([keyPath isEqualToString:@"mySize"])
  {
            //Do something else
      }
   else if ([keyPath isEqualToString:@"anotherSize"])
   {
    //Do something else
  }
}</pre></div><p class="calibre8">With a few more notifications, you will write a lot of if-else statements and you will be able to see how unwieldy the code will be and many bad things such as crashes, bugs, and so on will appear, and this requires more debugging time.</p><p class="calibre8">KVO registering can crash your app if you do it multiple times. If you have a superclass that is observing the same parameter on the same object, the <code class="email">removeObserver</code> method will be called twice and it would lead to a crash on the second time.</p><p class="calibre8">KVO works in a wonderful and magical way in the same way as callbacks. Code utilizing callback can be painful to debug. So, I would recommend KVO usage if you have adequate experience with KVO and start with small projects as the API documentation is sparse and it can lead to debugging problems down the road if you are not well versed with KVO.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec78" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Finally, we reached the end of this chapter. This chapter covers some details of Objective-C, such as property attributes, which you have been typing in but do not have a clear idea of. We also covered memory management guidelines, where I have outlined some tips and tricks to add to your knowledge of memory management and debugging memory-related issues in your code. This chapter just covers a small subset of memory management and I hope that you have dived deep into the previous chapters, where the various memory management techniques are covered more in-depth. Finally, one more chapter lies ahead, where we will go through some of the new tools and functionalities of Xcode 6, which you can use in your projects. So, let's proceed, shall we?</p></div></body></html>