- en: Discovering Kernel, HAL, and Virtual Hardware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现内核、HAL和虚拟硬件
- en: 'Once we set up the development environment and get the source code ready to
    use. We can start to explore the Android system architecture in more depth. We
    will look at the AOSP source tree first. After that, we will study the virtual
    hardware platforms that we are going to use in this book. Based on our understanding
    of the virtual hardware, we will look at the layers related to the system customization.
    In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了开发环境并准备好了可用的源代码，我们就可以更深入地探索Android系统架构。我们首先将查看AOSP源代码树。之后，我们将研究本书中将使用的虚拟硬件平台。基于我们对虚拟硬件的理解，我们将查看与系统定制相关的层。在本章中，我们将涵盖以下主题：
- en: Deep analysis of Android HAL using the goldfish lights service
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用goldfish灯光服务对Android HAL进行深度分析
- en: Review the hardware specification for goldfish
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看goldfish的硬件规范
- en: Overview about QEMU pipe implementation in the goldfish kernel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: goldfish内核中QEMU管道实现的概述
- en: What is inside the AOSP?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AOSP内部有什么？
- en: 'Before we move to the details, let''s take a look at the top level of the AOSP
    source code tree again:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们再次查看AOSP源代码树的顶层：
- en: '![](img/image_03_001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_001.png)'
- en: 'The following table gives a brief description about each folder. We will look
    at some of them throughout this book:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要描述了每个文件夹。我们将在本书中查看其中的一些：
- en: '| **Directory** | **Description** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **目录** | **描述** |'
- en: '| `packages` | Stock Android applications. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `packages` | 库存Android应用程序。|'
- en: '| `libcore` | Core Java library. Apache Harmony is used before Nougat. OpenJDK
    is used with Nougat. Some features of Java 8 are used in Nougat. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `libcore` | 核心Java库。Nougat之前使用Apache Harmony。Nougat使用OpenJDK。Nougat中使用了Java
    8的一些功能。|'
- en: '| `frameworks/*` | Android framework core components. |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/*` | Android框架核心组件。|'
- en: '| `frameworks/base/services` | Android system services. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/base/services` | Android系统服务。|'
- en: '| `art` | Android runtime. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `art` | Android运行时。|'
- en: '| `dalvik` | Dalvik virtual machine. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `dalvik` | Dalvik虚拟机。|'
- en: '| `libnativehelper` | Helper functions for use with JNI. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `libnativehelper` | 与JNI一起使用的辅助函数。|'
- en: '| `system/*` | Native services and libraries. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `system/*` | 原生服务和库。|'
- en: '| `system/core` | A minimal Linux system to boot Android. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `system/core` | 启动Android所需的最小Linux系统。|'
- en: '| `bionic` | C library. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `bionic` | C库。|'
- en: '| `external` | External projects imported into the AOSP. It includes both the
    HAL layer and system services. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `external` | 导入到AOSP的外部项目。它包括HAL层和系统服务。|'
- en: '| `hardware` | HAL and hardware libraries. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `hardware` | HAL和硬件库。|'
- en: '| `device` | Device-specific files and components. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `device` | 设备特定的文件和组件。|'
- en: '| `bootable` | Recovery and bootloader. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `bootable` | 恢复和引导加载程序。|'
- en: '| `abi` | Minimal C++ runtime type information support. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `abi` | 最小C++运行时类型信息支持。|'
- en: '| `build` | Build system and Makefiles. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `build` | 构建系统和Makefiles。|'
- en: '| `sdk` | Android SDK. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `sdk` | Android SDK。|'
- en: '| `cts` | Compatibility test suite. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `cts` | 兼容性测试套件。|'
- en: '| `development` | Development tools. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `development` | 开发工具。|'
- en: '| `ndk` | Android NDK. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `ndk` | Android NDK。|'
- en: '| `tools` | Various IDE tools. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `tools` | 各种IDE工具。|'
- en: '| `prebuilts` | Prebuilt images and binaries. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `prebuilts` | 预构建的镜像和二进制文件。|'
- en: For a particular module or component, we may have to dig into multiple levels
    of subfolders to figure out what is included in it. This is especially true for
    the `frameworks`, `system`, and `external` folders. The subfolders in `frameworks`
    include Android framework layer code, but Android system services also reside
    in `frameworks/base/services` and we will look at them later in this session.
    The same is true for the contents in the `system` and `external` folders.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的模块或组件，我们可能需要深入多个子文件夹的多个层级来了解其中包含的内容。这对于`frameworks`、`system`和`external`文件夹尤其如此。`frameworks`中的子文件夹包含Android框架层代码，但Android系统服务也位于`frameworks/base/services`中，我们将在本节稍后查看它们。`system`和`external`文件夹中的内容也是如此。
- en: Android emulator HAL
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android模拟器HAL
- en: 'We built the Android emulator in [Chapter 2](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml),
    *Setting Up the Development Environment*. In order to have an overview of Android
    emulator HAL, we can take a look at the `$OUT/system/lib/hw` folder as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml)“设置开发环境”中构建了Android模拟器。为了对Android模拟器HAL有一个概览，我们可以查看以下`$OUT/system/lib/hw`文件夹：
- en: '![](img/image_03_002.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_002.png)'
- en: 'We can see that there is a list of shared libraries. These are the shared libraries
    of goldfish HAL. The source code of the preceding shared libraries can be found
    in the `device/generic/goldfish` folder. The following table shows the relationship
    between the shared library, device node, and hardware module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到有一系列共享库。这些都是goldfish HAL的共享库。上述共享库的源代码可以在`device/generic/goldfish`文件夹中找到。下表显示了共享库、设备节点和硬件模块之间的关系：
- en: '| **Hardware** | **Device** | **Lib (HAL)** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **硬件** | **设备** | **库 (HAL)** |'
- en: '| `audio` | `/dev/eac` | `audio.primary.goldfish.so` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `audio` | `/dev/eac` | `audio.primary.goldfish.so` |'
- en: '| `camera` | `/dev/qemu_pipe` | `camera.goldfish.jpeg.so` `camera.goldfish.so`
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `camera` | `/dev/qemu_pipe` | `camera.goldfish.jpeg.so` `camera.goldfish.so`
    |'
- en: '| `fingerprint` | `/dev/qemu_pipe` | `fingerprint.goldfish.so` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `fingerprint` | `/dev/qemu_pipe` | `fingerprint.goldfish.so` |'
- en: '| `gps` | `/dev/qemu_pipe` | `gps.goldfish.so` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `gps` | `/dev/qemu_pipe` | `gps.goldfish.so` |'
- en: '| `lights` | `/dev/qemu_pipe` | `lights.goldfish.so` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `lights` | `/dev/qemu_pipe` | `lights.goldfish.so` |'
- en: '| `power` | `/dev/qemu_pipe` | `power.goldfish.so` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `power` | `/dev/qemu_pipe` | `power.goldfish.so` |'
- en: '| `sensors` | `/dev/qemu_pipe` | `sensors.goldfish.so` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `sensors` | `/dev/qemu_pipe` | `sensors.goldfish.so` |'
- en: '| `vibrator` | `/dev/qemu_pipe` | `vibrator.goldfish.so` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `vibrator` | `/dev/qemu_pipe` | `vibrator.goldfish.so` |'
- en: '| `graphics` | `/dev/qemu_pipe` | `gralloc.goldfish.so` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `graphics` | `/dev/qemu_pipe` | `gralloc.goldfish.so` |'
- en: '| `serial` | `/dev/ttyS[0 - 2]` | simple device don''t need a separate shared
    library |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `serial` | `/dev/ttyS[0 - 2]` | 简单设备不需要单独的共享库 |'
- en: As we can see from the preceding table, except for the serial port and audio,
    all the other hardware modules use a device node `/dev/qemu_pipe` to talk to the
    kernel. The QEMU pipe device provides a bridge between emulated devices and Android
    emulator. Since the QEMU pipe is an important device for the emulator, we will
    introduce it later in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从前表可以看出，除了串行端口和音频外，所有其他硬件模块都使用设备节点`/dev/qemu_pipe`与内核通信。QEMU管道设备在模拟设备和Android模拟器之间提供了一个桥梁。由于QEMU管道是模拟器的重要设备，我们将在本章后面介绍它。
- en: Usually, the HAL implementation is a shared library and it will be loaded by
    system service at runtime. It actually depends on the complexity of the hardware
    itself when it comes to deciding the actual implementation. For example, there
    is no separate shared library for simple hardware such as serial ports. The system
    service implementation of a serial port accesses the device node directly.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，HAL实现是一个共享库，它将在运行时由系统服务加载。实际上，当决定实际实现时，它取决于硬件本身的复杂性。例如，对于像串行端口这样的简单硬件，没有单独的共享库。串行端口的系统服务实现直接访问设备节点。
- en: For more complicated hardware devices, such as graphics, there is a dedicated
    daemon SurfaceFlinger running in the background as well as multiple shared libraries
    associated with it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的硬件设备，例如图形设备，还有一个在后台运行的专用守护进程SurfaceFlinger，以及与之相关的多个共享库。
- en: In this chapter, we will analyze the HAL of device goldfish lights and use it
    as an example to understand the relationship between frameworks, system servers,
    and HAL implementation. After that, we will go through the hardware interface
    for goldfish devices. Finally, we will analyze the QEMU pipe implementation in
    the goldfish kernel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析goldfish设备的HAL，并以此为例了解框架、系统服务器和HAL实现之间的关系。然后，我们将介绍goldfish设备的硬件接口。最后，我们将分析goldfish内核中的QEMU管道实现。
- en: Calling sequence
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用序列
- en: We will use the lights hardware interface as an example to explain how HAL,
    system services, and hardware managers work together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以灯光硬件接口为例，解释HAL、系统服务和硬件管理器是如何协同工作的。
- en: '![](img/image_03_003.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_003.png)'
- en: Lights HAL, system service, and hardware manager
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光HAL、系统服务和硬件管理器
- en: 'As shown in the preceding figure, when an application wants to access hardware
    resources, it has to get an instance of the hardware manager first. For goldfish
    lights, the code in the application may look as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，当应用程序想要访问硬件资源时，它首先需要获取硬件管理器的一个实例。对于goldfish灯光，应用程序中的代码可能如下所示：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The hardware manager talks to the system service to get hardware access. Usually,
    the hardware manager is implemented in Java. It calls to the system service using
    a binder interface since the hardware manager and system service run in different
    process spaces. The upper layer of the system service also implements in Java.
    After the system service gets the request, it will call to HAL library using JNI
    since the HAL is implemented using C or C++ usually.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件管理器与系统服务通信以获取硬件访问权限。通常，硬件管理器是用Java实现的。由于硬件管理器和系统服务在不同的进程空间中运行，它通过binder接口调用系统服务。系统服务的上层也是用Java实现的。在系统服务接收到请求后，它将使用JNI调用HAL库，因为HAL通常是用C或C++实现的。
- en: '![](img/image_03_004.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_03_004.png)'
- en: Calling sequence of lights service
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光服务的调用序列
- en: The preceding figure shows the calling sequence when an application wants to
    change the light on the device. We will use a bottom-up approach in this section
    to look at the calling sequence from HAL to the application layer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示了当应用程序想要更改设备上的灯光时的调用序列。在本节中，我们将使用自下而上的方法来查看从HAL到应用程序层的调用序列。
- en: Goldfish lights HAL
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金鱼灯HAL
- en: 'The goldfish lights HAL implementation can be found in the `$AOSP/device/generic/goldfish/lights`
    folder. To implement the HAL layer, the hardware vendor usually needs to implement
    the following three data structures:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: goldfish灯光HAL实现可以在`$AOSP/device/generic/goldfish/lights`文件夹中找到。要实现HAL层，硬件供应商通常需要实现以下三个数据结构：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All the preceding three data structures are implemented in the `lights_qemu.c`
    file for goldfish. In the HAL implementation, we need to define `struct hw_module_t`
    named `HAL_MODULE_INFO_SYM` first as follows. This registers the hardware module
    ID `LIGHTS_HARDWARE_MODULE_ID` in the system. After this, lights system service
    can get the module using the `hw_get_module` function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前三个数据结构都在goldfish的`lights_qemu.c`文件中实现。在HAL实现中，我们首先需要定义名为`HAL_MODULE_INFO_SYM`的`struct
    hw_module_t`，如下所示。这将在系统中注册硬件模块ID `LIGHTS_HARDWARE_MODULE_ID`。之后，灯光系统服务可以使用`hw_get_module`函数获取该模块：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You may notice that the `method` field has a pointer of `lights_module_methods`
    inside the preceding data structure. It is defined as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在前面的数据结构中`method`字段有一个指向`lights_module_methods`的指针。它如下定义：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This defines the second HAL data structure `hw_module_methods_t`. Inside this
    data structure, it defines an `open_lights` method, which is the HAL function
    to initialize the hardware. Let''s take a look at this function as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了第二个HAL数据结构`hw_module_methods_t`。在这个数据结构内部，它定义了一个`open_lights`方法，这是HAL初始化硬件的函数。让我们看一下这个函数如下：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Inside `open_lights`, it allocates the memory for the `light_device_t` data
    structure, which inherits the third HAL data structure, `hw_device_t`. When it
    initializing the data structure `light_device_t`, it registers two functions,
    `close_lights` and `set_light`, so the system service can call these functions
    to change the light or close the device. The function pointer `set_light` is set
    to a specific function according to the type of light.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`open_lights`内部，它为继承自第三个HAL数据结构`hw_device_t`的`light_device_t`数据结构分配内存。当初始化`light_device_t`数据结构时，它注册了两个函数，`close_lights`和`set_light`，这样系统服务就可以调用这些函数来改变灯光或关闭设备。`set_light`函数指针根据灯光类型设置为特定的函数。
- en: 'Inside each `set_light_xxx` function, it talks to the kernel space through
    the QEMU pipe device `/dev/qemu_pipe`. For example, we can take a look at `set_light_backlight`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`set_light_xxx`函数内部，它通过QEMU管道设备`/dev/qemu_pipe`与内核空间通信。例如，我们可以看一下`set_light_backlight`：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inside the `set_light_backlight` function, it calls `qemud_channel_open` and
    `qemud_channel_send` to do the actual work. Both functions use the QEMU pipe device
    `/dev/qemu_pipe` eventually.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`set_light_backlight`函数内部，它调用`qemud_channel_open`和`qemud_channel_send`来完成实际工作。这两个函数最终都使用QEMU管道设备`/dev/qemu_pipe`。
- en: The system service and hardware manager
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统服务和硬件管理器
- en: 'To analyze how the application accesses light hardware, refer to the figure
    of the lights service calling sequence. In an application, what calls the `getService(LightsManager.class)`
    function to get an instance of `LightsManager` as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析应用程序如何访问灯光硬件，请参考灯光服务调用序列的图示。在一个应用程序中，调用`getService(LightsManager.class)`函数以获取`LightsManager`实例如下：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Usually the hardware manager and system service are implemented in different
    processes for most hardware interfaces. However, the hardware of the light is
    so simple, so both the system service and hardware manager are implemented in
    the same process.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，硬件管理器和系统服务在大多数硬件接口中是分别在不同的进程中实现的。然而，灯的硬件非常简单，所以系统服务和硬件管理器都在同一个进程中实现。
- en: 'The system service includes two parts: Java and JNI. The JNI implementation
    can be found at `frameworks/base/services/core/jni`, while the Java implementation
    can be found at `frameworks/base/services/core/java/com/android/server`. Both
    `LightsManager` and `LightsService` are implemented in `frameworks/base/services/core/java/com/android/server/lights`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 系统服务包括两部分：Java 和 JNI。JNI 的实现可以在 `frameworks/base/services/core/jni` 目录下找到，而
    Java 的实现可以在 `frameworks/base/services/core/java/com/android/server` 目录下找到。`LightsManager`
    和 `LightsService` 都是在 `frameworks/base/services/core/java/com/android/server/lights`
    目录下实现的。
- en: 'There are three files in this folder as follows. They implement both `LightsManager`
    and `LightsService`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录中有三个文件，如下所示。它们实现了 `LightsManager` 和 `LightsService`：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s look at `LightsManager` first. We can see from the following snippet
    that `LightsManager` only returns an abstract class, `Light`, to the caller:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `LightsManager`。从以下代码片段中我们可以看到，`LightsManager` 只向调用者返回一个抽象类 `Light`：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s follow the code to look at the abstract class `Light`. In the abstract
    class `Light`, it defines a list of functions that have to be implemented for
    `Light`. These functions are implemented in the `LightsService` class:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跟随代码来查看抽象类 `Light`。在 `Light` 抽象类中，它定义了一系列必须实现的功能。这些功能在 `LightsService` 类中实现：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In `LightsService.java` in the following snippet, it implements the list of
    functions defined by the `Light` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中的 `LightsService.java` 中，它实现了 `Light` 类定义的功能列表：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This set of functions in the abstract class `Light` calls a `setLightLocked`
    function to do the actual work. In this function, it calls a native function,
    `setLight_native`, to invoke the native part of `LightsService`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类 `Light` 中的这组函数调用 `setLightLocked` 函数来完成实际工作。在这个函数中，它调用一个本地函数，`setLight_native`，来调用
    `LightsService` 的本地部分：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Besides `setLight_native`, `LightService` also calls two more native functions,
    `init_native` and `finalize_native`. We can see this in the following code snippet.
    These two functions call to the HAL layer functions, as we discussed in the previous
    section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `setLight_native`，`LightService` 还调用了另外两个本地函数，`init_native` 和 `finalize_native`。我们可以在以下代码片段中看到这一点。这两个函数调用到
    HAL 层函数，正如我们在上一节中讨论的那样：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We have looked at the implementation of `LightsManager` and the Java implementation
    of `LightsService`. Now let''s explore the JNI part of the `LightsService` implementation.
    The JNI part is implemented in `com_android_server_lights_LightsService.cpp`,
    which can be found in the `$AOSP/frameworks/base/services/core/jni` folder. We
    will look at how these three native functions used in `LightsService` are connected
    to the HAL layer:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `LightsManager` 的实现和 `LightsService` 的 Java 实现。现在，让我们探索 `LightsService`
    实现的 JNI 部分。JNI 部分在 `com_android_server_lights_LightsService.cpp` 中实现，可以在 `$AOSP/frameworks/base/services/core/jni`
    目录下找到。我们将看看这些在 `LightsService` 中使用的三个本地函数是如何连接到 HAL 层的：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the `init_native` function, it calls the `hw_get_module` function to get
    the light HAL module using `LIGHTS_HARDWARE_MODULE_ID` as the hardware ID. If
    you look back, it is defined in the HAL. This function loads the shared library
    of HAL implementations. In this case, it loads `lights.goldfish.so`. After loading
    the shared library, it calls `get_device` to initialize all the light devices.
    We can see the implementation of `get_device` in the following snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init_native` 函数中，它调用 `hw_get_module` 函数使用 `LIGHTS_HARDWARE_MODULE_ID` 作为硬件
    ID 来获取灯 HAL 模块。如果你回顾一下，它在 HAL 中定义。这个函数加载了 HAL 实现的共享库。在这种情况下，它加载了 `lights.goldfish.so`。在加载共享库之后，它调用
    `get_device` 来初始化所有灯设备。我们可以在以下代码片段中看到 `get_device` 的实现：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In `get_device`, it invokes the `open` method and gets the instance of HAL data
    structure `hw_device_t`. We discussed the `open` method in the goldfish lights
    HAL.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `get_device` 函数中，它调用了 `open` 方法并获取了 HAL 数据结构 `hw_device_t` 的实例。我们之前在金鱼灯 HAL
    中讨论了 `open` 方法。
- en: 'Now let''s look at another native function, `setLight_native`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个本地函数，`setLight_native`：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `setLight_native` function, it gets the pointer of the data structure
    `Devices` first. After that, it calls the HAL function `set_light` to do the actual
    work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setLight_native` 函数中，它首先获取数据结构 `Devices` 的指针。之后，它调用 HAL 函数 `set_light` 来完成实际工作。
- en: 'Finally, let''s look at the implementation of the native method, `finalize_native`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看本地方法`finalize_native`的实现：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can see that the `finalize_native` function just frees all resources used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`finalize_native`函数只是释放了所有使用的资源。
- en: Android emulator kernel and hardware
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android模拟器内核和硬件
- en: We use goldfish lights as an example to perform the calling sequence analysis
    from an application to the goldfish HAL. Now we can look at the kernel layer and
    the underlying hardware. We can also take an overview from the top to the bottom
    again to understand how the entire system works.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以金鱼灯为例，从应用程序到金鱼HAL执行调用序列分析。现在我们可以查看内核层和底层硬件。我们也可以从上到下再次概述，以了解整个系统是如何工作的。
- en: '![](img/image_03_005.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_03_005.png)'
- en: The goldfish architecture
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 金鱼架构
- en: We use the preceding figure to explain goldfish kernel and hardware in detail.
    As you can see, the preceding figure is similar to the architecture diagram that
    we saw in [Chapter 1](4ddc5eff-b4d7-452c-b83c-0c3c1d40da57.xhtml), *Introduction
    to Android System Programming*. This architecture diagram is the general architecture
    diagram for Android, but the preceding figure is specific to goldfish.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用前面的图来详细解释金鱼内核和硬件。正如您所看到的，前面的图与我们在[第1章](4ddc5eff-b4d7-452c-b83c-0c3c1d40da57.xhtml)“Android系统编程简介”中看到的架构图相似。这个架构图是Android的一般架构图，但前面的图是针对金鱼的特定图。
- en: From the diagram, we can see the parts that we are interested in the goldfish
    kernel and emulator hardware. From the top to the bottom, the application utilizes
    the Android framework to implement functionalities and access the hardware. The
    framework usually resides in a different process from the system service layer,
    so they use Binder IPC to communicate with each other. The system service talks
    to the **HAL** using **JNI**, since **HAL** usually implements in the native language.
    The **HAL** is the user space implementation of hardware control and it communicates
    to the device driver in the kernel space through system calls. In the case of
    the goldfish hardware, the device driver accesses the virtual hardware through
    memory I/O registers, as we will see in the following section on Android emulator
    hardware.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中，我们可以看到我们感兴趣的goldfish内核和模拟器硬件的部分。从上到下，应用程序利用Android框架实现功能并访问硬件。框架通常位于与系统服务层不同的进程中，因此它们使用Binder
    IPC进行通信。系统服务通过JNI与**HAL**通信，因为**HAL**通常是用本地语言实现的。**HAL**是硬件控制的用户空间实现，它通过系统调用与内核空间中的设备驱动程序通信。在金鱼硬件的情况下，设备驱动程序通过内存I/O寄存器访问虚拟硬件，正如我们将在下一节中讨论的Android模拟器硬件。
- en: Android emulator hardware
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android模拟器硬件
- en: Unlike real hardware, most Android emulator hardware interfaces are emulated
    using QEMU, which is a popular open source emulator engine used by many open source
    projects. The Android development team customized QEMU and added a virtual hardware
    platform called goldfish. As we mentioned in [Chapter 2](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml),
    *Setting Up the Development Environment*, there are currently two versions of
    Android emulator available in the latest SDK. The code name for the original Android
    emulator is goldfish and the new one is ranchu. However, the virtual hardware
    code base for device emulation in QEMU is the same for both versions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与真实硬件不同，大多数Android模拟器硬件接口都是使用QEMU进行模拟的，QEMU是一个流行的开源模拟器引擎，被许多开源项目使用。Android开发团队定制了QEMU并添加了一个名为goldfish的虚拟硬件平台。正如我们在[第2章](984e0cef-7bf6-4454-bede-bb34c553be12.xhtml)“设置开发环境”中提到的，在最新的SDK中目前有Android模拟器的两个版本可用。原始Android模拟器的代号是goldfish，新的一个是ranchu。然而，在QEMU中用于设备模拟的虚拟硬件代码库在这两个版本中是相同的。
- en: Detailed information about goldfish hardware interfaces can be found in the
    document `GOLDFISH-VIRTUAL-HARDWARE.TXT`. This document can be found in the AOSP
    source code at `$AOSP/platform/external/qemu/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于goldfish硬件接口的详细信息可以在文档`GOLDFISH-VIRTUAL-HARDWARE.TXT`中找到。该文档可以在AOSP源代码的`$AOSP/platform/external/qemu/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT`中找到。
- en: For different kernel versions, the hardware interfaces may have some differences.
    In this book, we will look at the Intel x86-based ranchu virtual hardware, which
    uses Android Linux version 3.10.0\. Let's look at the goldfish devices that we
    will discuss in this chapter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不同的内核版本，硬件接口可能会有一些差异。在这本书中，我们将查看基于Intel x86的ranchu虚拟硬件，它使用Android Linux版本3.10.0。让我们看看本章中我们将讨论的金鱼设备。
- en: Goldfish platform bus
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goldfish平台总线
- en: In the architecture diagram for goldfish, we have a detailed diagram for the
    kernel and goldfish hardware. We can see that all goldfish devices are enumerated
    through the goldfish platform bus. The platform bus is a special device that is
    capable of enumerating other platform devices found on the system to the kernel.
    This flexibility allows us to customize which virtual devices are available when
    running a given emulated system configuration. The following table defines goldfish
    platform bus registers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 goldfish 的架构图中，我们有一个内核和 goldfish 硬件的详细图。我们可以看到所有 goldfish 设备都是通过 goldfish
    平台总线进行枚举的。平台总线是一种特殊设备，能够将系统上找到的其他平台设备枚举到内核中。这种灵活性允许我们在运行特定的模拟系统配置时自定义哪些虚拟设备可用。以下表格定义了
    goldfish 平台总线寄存器。
- en: '**Goldfish platform bus 32-bit I/O registers**:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Goldfish 平台总线 32 位 I/O 寄存器**：'
- en: '| **Offset** | **Name** | **Abstract** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **名称** | **摘要** |'
- en: '| `0x00` | `BUS_OP` | R: Iterate to the next device in enumeration.W: Start
    device enumeration. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `0x00` | `BUS_OP` | R: 迭代到枚举中的下一个设备。W: 开始设备枚举。|'
- en: '| `0x04` | `GET_NAME` | W: Copy device name to kernel memory. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `0x04` | `GET_NAME` | W: 将设备名称复制到内核内存。|'
- en: '| `0x08` | `NAME_LEN` | R: Read length of current device''s name. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `0x08` | `NAME_LEN` | R: 读取当前设备名称的长度。|'
- en: '| `0x0c` | `ID` | R: Read ID of the current device. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `0x0c` | `ID` | R: 读取当前设备的 ID。|'
- en: '| `0x10` | `IO_BASE` | R: Read I/O base address of the current device. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `0x10` | `IO_BASE` | R: 读取当前设备的 I/O 基础地址。|'
- en: '| `0x14` | `IO_SIZE` | R: Read I/O base size of the current device. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `0x14` | `IO_SIZE` | R: 读取当前设备的 I/O 基础大小。|'
- en: '| `0x18` | `IRQ_BASE` | R: Read base IRQ of the current device. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `0x18` | `IRQ_BASE` | R: 读取当前设备的基中断。|'
- en: '| `0x1c` | `IRQ_COUNT` | R: Read IRQ count of the current device. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `0x1c` | `IRQ_COUNT` | R: 读取当前设备的中断计数。|'
- en: '| `0x20` | `NAME_ADDR_HIGH` | # For 64-bit guest architectures only:W: Write
    high 32-bit of kernel address of name buffer used by `GET_NAME`. Must be written
    to before the `GET_NAME` write. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `0x20` | `NAME_ADDR_HIGH` | # 仅适用于 64 位虚拟机架构：W: 将 `GET_NAME` 使用的名称缓冲区内核地址的高
    32 位写入。必须在 `GET_NAME` 写入之前写入。|'
- en: QEMU pipe device
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QEMU 管道设备
- en: One of the most important emulated devices in goldfish hardware is the QEMU
    pipe device. This is a special device that is totally specific to QEMU, but allows
    guest processes to communicate directly with the emulator with extremely high
    performance. This is achieved by avoiding any in-kernel memory copies, relying
    on the fact that QEMU can access guest memory at runtime (under proper conditions
    controlled by the kernel). As we can see from the goldfish architecture diagram,
    many other hardware interfaces, such as GPS, sensors, basebands, cameras, and
    so on, are emulated through the QEMU pipe. The following table defines QEMU pipe
    device registers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 goldfish 硬件中，最重要的模拟设备之一是 QEMU 管道设备。这是一个完全特定于 QEMU 的特殊设备，但允许虚拟进程以极高的性能直接与模拟器通信。这是通过避免任何内核内存复制来实现的，依赖于
    QEMU 能够在运行时（在内核控制的适当条件下）访问虚拟内存。从 goldfish 架构图中我们可以看到，许多其他硬件接口，如 GPS、传感器、基带、摄像头等，都是通过
    QEMU 管道进行模拟的。以下表格定义了 QEMU 管道设备寄存器。
- en: '**QEMU pipe device registers**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**QEMU 管道设备寄存器**：'
- en: '| **Offset** | **Name** | **Abstract** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **名称** | **摘要** |'
- en: '| `0x00` | `COMMAND` | W: Write to perform command (see the following). |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `0x00` | `COMMAND` | W: 写入以执行命令（见以下）。|'
- en: '| `0x04` | `STATUS` | R: Read status. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `0x04` | `STATUS` | R: 读取状态。|'
- en: '| `0x08` | `CHANNEL` | RW: Read or set current channel ID. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `0x08` | `CHANNEL` | RW: 读取或设置当前通道 ID。|'
- en: '| `0x0c` | `SIZE` | RW: Read or set current buffer size. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `0x0c` | `SIZE` | RW: 读取或设置当前缓冲区的大小。|'
- en: '| `0x10` | `ADDRESS` | RW: Read or set current buffer physical address. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `0x10` | `ADDRESS` | RW: 读取或设置当前缓冲区的物理地址。|'
- en: '| `0x14` | `WAKES` | R: Read wake flags. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `0x14` | `WAKES` | R: 读取唤醒标志。|'
- en: '| `0x18` | `PARAMS_ADDR_LOW` | RW: Read/set low bytes of parameter''s block
    address. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `0x18` | `PARAMS_ADDR_LOW` | RW: 读取/设置参数块地址的低字节。|'
- en: '| `0x1c` | `PARAMS_ADDR_HIGH` | RW: Read/set high bytes of parameter''s block
    address. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `0x1c` | `PARAMS_ADDR_HIGH` | RW: 读取/设置参数块地址的高字节。|'
- en: '| `0x20` | `ACCESS_PARAMS` | W: Perform access with parameter block. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `0x20` | `ACCESS_PARAMS` | W: 使用参数块执行访问。|'
- en: Refer to the AOSP document `ANDROID-QEMU-PIPE.TXT` for details about the device's
    operations.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设备操作的详细信息，请参阅 AOSP 文档 `ANDROID-QEMU-PIPE.TXT`。
- en: Goldfish audio device
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goldfish 音频设备
- en: 'The goldfish audio device implements a virtual sound card with the following
    properties:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: goldfish 音频设备实现了具有以下属性的虚拟声卡：
- en: Stereo output at fixed 44.1 kHz frequency, using signed 16-bit samples. This
    is mandatory.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以固定的 44.1 kHz 频率进行立体声输出，使用有符号 16 位样本。这是强制性的。
- en: Mono input at fixed 8 kHz frequency, using signed 16-bit samples. This is optional.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以固定 8 kHz 频率进行单声道输入，使用有符号 16 位样本。这是可选的。
- en: 'The following table defines goldfish audio device registers:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格定义了 goldfish 音频设备寄存器：
- en: '| **Offset** | **Name** | **Abstract** |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **名称** | **摘要** |'
- en: '| `0x00` | `INT_STATUS` |  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `0x00` | `INT_STATUS` |  |'
- en: '| `0x04` | `INT_ENABLE` |  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `0x04` | `INT_ENABLE` |  |'
- en: '| `0x08` | `SET_WRITE_BUFFER_1` | W: Set address of first kernel output buffer.
    |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `0x08` | `SET_WRITE_BUFFER_1` | W: 设置第一个内核输出缓冲区的地址。|'
- en: '| `0x0c` | `SET_WRITE_BUFFER_2` | W: Set address of second kernel output buffer.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `0x0c` | `SET_WRITE_BUFFER_2` | W: 设置第二个内核输出缓冲区的地址。|'
- en: '| `0x10` | `WRITE_BUFFER_1` | W: Send first kernel buffer samples to output.
    |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `0x10` | `WRITE_BUFFER_1` | W: 将第一个内核缓冲区样本发送到输出。|'
- en: '| `0x14` | `WRITE_BUFFER_2` | W: Send second kernel buffer samples to output.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `0x14` | `WRITE_BUFFER_2` | W: 将第二个内核缓冲区样本发送到输出。|'
- en: '| `0x18` | `READ_SUPPORTED` | R: Reads 1 if input is supported, 0 otherwise.
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `0x18` | `READ_SUPPORTED` | R: 如果输入受支持则读取 1，否则为 0。|'
- en: '| `0x1c` | `SET_READ_BUFFER` |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `0x1c` | `SET_READ_BUFFER` |  |'
- en: '| `0x20` | `START_READ` |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `0x20` | `START_READ` |  |'
- en: '| `0x24` | `READ_BUFFER_AVAILABLE` |  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `0x24` | `READ_BUFFER_AVAILABLE` |  |'
- en: '| `0x28` | `SET_WRITE_BUFFER_1_HIGH` | # For 64-bit guest CPUs:W: Set high
    32 bits of the first kernel output buffer address. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `0x28` | `SET_WRITE_BUFFER_1_HIGH` | # 仅适用于 64 位虚拟机 CPU：W: 设置第一个内核输出缓冲区地址的高
    32 位。|'
- en: '| `0x30` | `SET_WRITE_BUFFER_2_HIGH` | # For 64-bit guest CPUs:W: Set high
    32 bits of second kernel output buffer address. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `0x30` | `SET_WRITE_BUFFER_2_HIGH` | # 仅适用于 64 位虚拟机 CPU：W: 设置第二个内核输出缓冲区地址的高
    32 位。|'
- en: '| `0x34` | `SET_READ_BUFFER_HIGH` | # For 64-bit guest CPUs:W: Set high 32
    bits of kernel input buffer address. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `0x34` | `SET_READ_BUFFER_HIGH` | # 仅适用于 64 位虚拟机 CPU：W: 设置内核输入缓冲区地址的高 32
    位。|'
- en: Goldfish serial port
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goldfish 串口
- en: 'Android emulator has its own implementation of a virtual serial port. It always
    reserves the first two virtual serial ports:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Android 模拟器有其自己的虚拟串口实现。它始终保留前两个虚拟串口：
- en: The first one is used to receive kernel messages. This is done by adding the
    `console=ttyS0` parameter to the kernel command line.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个用于接收内核消息。这是通过在内核命令行中添加 `console=ttyS0` 参数来实现的。
- en: The second one is used to set up the legacy `qemud` channel, used on older Android
    platform revisions. This is done by adding `android.qemud=ttyS1` on the kernel
    command line. The `qemud` channel is implemented as a Linux daemon process used
    as a channel between the guest and emulator. In the latest emulator version, a
    QEMU pipe is used instead of `qemud`.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个用于设置旧的 `qemud` 通道，用于较老的 Android 平台版本。这是通过在内核命令行中添加 `android.qemud=ttyS1`
    来实现的。`qemud` 通道作为 Linux 守护进程实现，用作虚拟机和模拟器之间的通道。在最新的模拟器版本中，使用 QEMU 管道代替 `qemud`。
- en: 'The following table defines goldfish serial port registers:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格定义了 goldfish 串口寄存器：
- en: '| **Offset** | **Name** | **Abstract** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **偏移量** | **名称** | **摘要** |'
- en: '| `0x00` | `PUT_CHAR` | W: Write a single 8-bit value to the serial port. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `0x00` | `PUT_CHAR` | W: 将单个 8 位值写入串口。|'
- en: '| `0x04` | `BYTES_READY` | R: Read the number of available buffered input bytes.
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `0x04` | `BYTES_READY` | R: 读取可用的缓冲输入字节数。|'
- en: '| `0x08` | `CMD` | W: Send command (see the following). |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `0x08` | `CMD` | W: 发送命令（见下文）。|'
- en: '| `0x10` | `DATA_PTR` | W: Write kernel buffer address. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `0x10` | `DATA_PTR` | W: 写入内核缓冲区地址。|'
- en: '| `0x14` | `DATA_LEN` | W: Write kernel buffer size. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `0x14` | `DATA_LEN` | W: 写入内核缓冲区大小。|'
- en: '| `0x18` | `DATA_PTR_HIGH` | # For 64-bit guest CPUs only:W: Write high 32
    bits of kernel buffer address. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `0x18` | `DATA_PTR_HIGH` | # 仅适用于 64 位虚拟机 CPU：W: 写入内核缓冲区地址的高 32 位。|'
- en: 'The CMD I/O register is used to send various commands to the device, identified
    by the following values:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CMD I/O 寄存器用于向设备发送各种命令，以下值用于标识：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each device instance uses one IRQ, raised to indicate that there is incoming/buffered
    data to read.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备实例使用一个中断请求（IRQ），用于指示有 incoming/buffered 数据要读取。
- en: Goldfish kernel
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goldfish 内核
- en: 'Goldfish kernel can be downloaded from the AOSP source repository. You can
    download and build the kernel source code using the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Goldfish 内核可以从 AOSP 源代码库中下载。您可以使用以下命令下载和构建内核源代码：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The following table is a list of goldfish device drivers. This is based on kernel
    version 3.10.0\. At the moment, kernel version 3.10.0 is for ranchu and 3.4.67
    is for goldfish. The following table lists some goldfish specific devices. In
    ranchu, Virtio devices are used as block devices to simulate EMMC. Virtio devices
    are paravirtualized devices in QEMU that have better performance than emulated
    hardware devices.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了金鱼设备驱动程序。这是基于内核版本 3.10.0。目前，内核版本 3.10.0 适用于 ranchu，而 3.4.67 适用于 goldfish。下表列出了一些金鱼特定设备。在
    ranchu 中，Virtio 设备用作块设备来模拟 EMMC。Virtio 设备是 QEMU 中的半虚拟化设备，其性能优于模拟硬件设备。
- en: '| **Device** | **Path** |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **路径** |'
- en: '| goldfish platform bus | `drivers/platform/goldfish/pdev_bus.c` |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼平台总线 | `drivers/platform/goldfish/pdev_bus.c` |'
- en: '| QEMU pipe | `drivers/platform/goldfish/goldfish_pipe.c` |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| QEMU 管道 | `drivers/platform/goldfish/goldfish_pipe.c` |'
- en: '| Frame buffer | `drivers/video/goldfishfb.c` |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 帧缓冲 | `drivers/video/goldfishfb.c` |'
- en: '| goldfish audio | `drivers/staging/goldfish/goldfish_audio.c` |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼音频 | `drivers/staging/goldfish/goldfish_audio.c` |'
- en: '| goldfish NAND | `drivers/staging/goldfish/goldfish_nand.c` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼 NAND | `drivers/staging/goldfish/goldfish_nand.c` |'
- en: '| goldfish battery | `drivers/power/goldfish_battery.c` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼电池 | `drivers/power/goldfish_battery.c` |'
- en: '| goldfish events | `drivers/input/keyboard/goldfish_events.c` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼事件 | `drivers/input/keyboard/goldfish_events.c` |'
- en: '| goldfish MMC | `drivers/mmc/host/android-goldfish.c` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼 MMC | `drivers/mmc/host/android-goldfish.c` |'
- en: '| goldfish serial | `drivers/tty/goldfish.c` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 金鱼串行 | `drivers/tty/goldfish.c` |'
- en: QEMU pipe
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QEMU 管道
- en: 'Since QEMU pipe is used as a channel to emulate many goldfish devices, we can
    review one of the major functions, `goldfish_pipe_read_write`, to understand data
    transmission between guest and host:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 QEMU 管道被用作模拟许多金鱼设备的通道，我们可以回顾其中一个主要功能，`goldfish_pipe_read_write`，以了解虚拟机和主机之间的数据传输：
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see from the preceding code, it invokes the `access_with_param` function
    first. This is the fastest way to transfer data between the guest and emulator
    using shared memory. With this method, the goldfish kernel allocates a piece of
    memory at boot time. The guest and emulator will use this shared memory to transfer
    parameters between them. If the `access_with_param` function fails, it will use
    the following sequence to transfer data through the QEMU pipe device:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，它首先调用了 `access_with_param` 函数。这是在虚拟机和模拟器之间使用共享内存进行数据传输的最快方式。使用这种方法，金鱼内核在启动时分配一块内存。虚拟机和模拟器将使用这块共享内存来交换它们之间的参数。如果
    `access_with_param` 函数失败，它将通过以下序列通过 QEMU 管道设备传输数据：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s take a look at the `access_with_param` function as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下下面的 `access_with_param` 函数：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The address of `aps` is the pre-allocated shared memory between the guest and
    emulator. All data structures that need to be used for a single operation are
    filled in this data structure `aps`. The command will be written to register `PIPE_REG_ACCESS_PARAMS`.
    The write to `PIPE_REG_ACCESS_PARAMS` will trigger the operation. QEMU will read
    the content of the `access_params` block, use its fields to perform the operation,
    and then write back the return value into `aps->result`. The difference between
    shared memory `aps` and the QEMU pipe device is similar to DMA and register-based
    device I/O. The shared memory or DMA is much more efficient in large blocks of
    memory access.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`aps` 的地址是虚拟机和模拟器之间预先分配的共享内存。所有需要用于单个操作的数据结构都填充在这个数据结构 `aps` 中。命令将被写入寄存器 `PIPE_REG_ACCESS_PARAMS`。对
    `PIPE_REG_ACCESS_PARAMS` 的写入将触发操作。QEMU 将读取 `access_params` 块的内容，使用其字段执行操作，然后将返回值写回
    `aps->result`。共享内存 `aps` 和 QEMU 管道设备之间的区别类似于 DMA 和基于寄存器的设备 I/O。在大量内存访问中，共享内存或
    DMA 要高效得多。'
- en: You can explore the rest of the goldfish device drivers by yourself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自行探索金鱼设备驱动程序的其余部分。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the content of the AOSP source code. After that,
    we used goldfish lights HAL as an example to analyze the calling sequence from
    the application to HAL. Finally, we reviewed the Android architecture again using
    the Android system for the emulator. We also reviewed goldfish kernel and hardware
    to understand how they work together with the rest of the software stacks. In
    the next chapter, we will start to work on our own x86emu device and use it to
    explore how to extend an emulator to support additional functionalities.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 AOSP 源代码的内容。之后，我们以 goldfish lights HAL 为例，分析了从应用程序到 HAL 的调用序列。最后，我们再次回顾了
    Android 架构，使用 Android 系统为模拟器。我们还回顾了 goldfish 内核和硬件，以了解它们如何与其他软件栈协同工作。在下一章中，我们将开始着手构建我们自己的
    x86emu 设备，并使用它来探索如何扩展模拟器以支持额外的功能。
