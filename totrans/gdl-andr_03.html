<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Managing Dependencies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Managing Dependencies</h1></div></div></div><p>Dependency management<a id="id102" class="indexterm"/> is one of the areas where Gradle really shines. In the best case scenario, all you need to do is add one line to your build file, and Gradle will download the dependency from a remote repository and make sure its classes are available to your project. Gradle even goes a step further. In case a dependency for your project has dependencies of its own, Gradle will resolve those, and take care of everything. These dependencies of dependencies are called <a id="id103" class="indexterm"/>
<span class="strong"><strong>transitive dependencies</strong></span>.</p><p>This chapter introduces the concepts of dependency management, and explains the multiple ways of adding dependencies to Android projects. These are the main topics we will be talking about:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Repositories</li><li class="listitem" style="list-style-type: disc">Local dependencies</li><li class="listitem" style="list-style-type: disc">Dependency concepts</li></ul></div><div class="section" title="Repositories"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Repositories</h1></div></div></div><p>When we discuss dependencies, we <a id="id104" class="indexterm"/>usually mean external dependencies, such as libraries that are provided by other developers. Manually managing dependencies can be a big hassle. You have to locate the library, download the JAR file, copy it into your project, and reference it. Often these JAR files have no version in their name, so you need to remember to add it yourself, in order to know when to update. You also need to make sure the libraries are stored in a source control system, so that the team members can work with the code base without manually downloading the dependencies themselves.</p><p>Using repositories can solve these issues. A repository can be seen as a collection of files. Gradle does not define any repositories for your project by default, so you need to add them to the <code class="literal">repositories</code> block. If you use Android Studio, this is done for you. We have mentioned the <code class="literal">repositories</code> block briefly in the previous chapters; it looks like this:</p><div class="informalexample"><pre class="programlisting">repositories {
    jcenter()
}</pre></div><p>Gradle supports three different kinds of repositories: Maven, Ivy, and static files or directories. Dependencies are fetched from the repositories during the execution phase of the build. Gradle also keeps a local cache, so a particular version of a dependency only needs to be downloaded to your machine once.</p><p>A dependency is<a id="id105" class="indexterm"/> identified by three elements: group, name, and version. The group specifies the organization that created the library and is usually a reverse domain name. The name is a unique identifier for the library. The version specifies which version of the library you want to use. Using these three elements, a dependency can be declared in the <code class="literal">dependencies</code> block with the following structure:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile 'com.google.code.gson:gson:2.3'
    compile 'com.squareup.retrofit:retrofit:1.9.0'
}</pre></div><p>This is shorthand for the full Groovy map notation, which looks like this:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile group: 'com.google.code.gson', name: 'gson', version: '2.3'
    compile group: 'com.squareup.retrofit', name: 'retrofit' version: '1.9.0'
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>The only required field for a dependency is the name. Group and version are optional elements. Nonetheless, it is recommended to add the group for clarity, and the version in order to make sure libraries are not updated automatically, which could cause a build to break.</p></div></div><div class="section" title="Preconfigured repositories"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Preconfigured repositories</h2></div></div></div><p>For your <a id="id106" class="indexterm"/>convenience, Gradle has<a id="id107" class="indexterm"/> preconfigured three Maven repositories: JCenter, Maven Central, and the local Maven repository. To include them in your build script, you need to include these lines:</p><div class="informalexample"><pre class="programlisting">repositories {
    mavenCentral()
    jcenter()
    mavenLocal()
}</pre></div><p>Maven Central and JCenter are two well-known online repositories. There is no reason to use both of them at the same time, and it is always recommended to use JCenter, which is also the default repository in Android projects created with Android Studio. JCenter is a superset of Maven Central, so when you make the switch, you can leave your already defined dependencies intact. On top of that, it supports HTTPS, unlike Maven Central.</p><p>The local Maven repository is a<a id="id108" class="indexterm"/> local cache of all the dependencies you have used, and you can add your own dependencies as well. By default, the repository can be found in the home directory in a folder called <code class="literal">.m2</code>. On Linux or Mac OS X, the path is <code class="literal">~/.m2</code>. On Microsoft Windows, it is <code class="literal">%UserProfile%\.m2</code>.</p><p>Besides these preconfigured<a id="id109" class="indexterm"/> repositories, you can also add other public, or even private repositories.</p></div><div class="section" title="Remote repositories"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Remote repositories</h2></div></div></div><p>Some <a id="id110" class="indexterm"/>organizations create<a id="id111" class="indexterm"/> interesting plugins or libraries, and prefer to host them on their own Maven or Ivy server, instead of publishing them to Maven Central or JCenter. To add those repositories to your build, all you need to do is to add the URL to a <code class="literal">maven</code> block.</p><div class="informalexample"><pre class="programlisting">repositories {
    maven {
        url "http://repo.acmecorp.com/maven2"
    }
}</pre></div><p>The same goes for Ivy repositories. Apache Ivy is a dependency manager that is popular in the Ant world. Gradle supports these repositories in a format that is identical to the one that is used for Maven repositories. Add the repository URL to an <code class="literal">ivy</code> block, and you are good to go:</p><div class="informalexample"><pre class="programlisting">repositories {
    ivy {
        url "http://repo.acmecorp.com/repo"
    }
}</pre></div><p>If your organization is running its own repository, chances are that it is secured, and you need credentials to access it. This is how you add credentials for a repository:</p><div class="informalexample"><pre class="programlisting">repositories {
    maven {
        url "http://repo.acmecorp.com/maven2"
        credentials {
            username 'user'
            password 'secretpassword'
        }
    }
}</pre></div><p>The approach for Maven <a id="id112" class="indexterm"/>and Ivy is the same here as well. You can add<a id="id113" class="indexterm"/> a <code class="literal">credentials</code> block with the same format to the configuration of your Ivy repository.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>
<span class="strong"><strong>Storing credentials</strong></span>
</p><p>It is not a <a id="id114" class="indexterm"/>good idea to store your credentials in the build configuration file. The build configuration file is plain text, and is checked into the source control system. A better idea would be to use a separate Gradle properties file, as we have seen in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <span class="emphasis"><em>Basic Build Customization</em></span>.</p></div></div></div><div class="section" title="Local repositories"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Local repositories</h2></div></div></div><p>It is possible to run <a id="id115" class="indexterm"/>Maven and Ivy<a id="id116" class="indexterm"/> repositories on your own hard drive or a network drive. To add these to the build, you just need to configure the URL to a relative or absolute path to the location on the drive:</p><div class="informalexample"><pre class="programlisting">repositories {
    maven {
        url "../repo"
    }
}</pre></div><p>New Android projects have a dependency on the Android Support Library by default. When installing the Google repositories using the SDK manager, two Maven repositories are created on your hard drive <code class="literal">ANDROID_SDK/extras/google/m2repository</code> and <code class="literal">ANDROID_SDK/extras/android/m2repository</code>. This is where Gradle gets the libraries provided by Google, such as the Android Support Library and Google Play Services.</p><p>You can add a regular directory as a repository as well, using <code class="literal">flatDirs</code>. This enables you to add files from that directory in the <code class="literal">dependency</code> block.</p><div class="informalexample"><pre class="programlisting">repositories {
    flatDir {
        dirs 'aars'
    }
}</pre></div><p>Later in this chapter, when we talk about library projects, we will look at an example of how this can be used.</p></div></div></div>
<div class="section" title="Local dependencies"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Local dependencies</h1></div></div></div><p>In some cases, you might still <a id="id117" class="indexterm"/>need to manually download a JAR file or a native library. Perhaps you want to create your own library that you can reuse in several projects, without publishing it to a public or private repository. In those cases, it is impossible to use any of the online resources, and you will have to use different ways to add the dependencies. We will describe how to use file dependencies, how to include native libraries, and how you can include library projects in your project.</p><div class="section" title="File dependencies"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>File dependencies</h2></div></div></div><p>To add a JAR <a id="id118" class="indexterm"/>file as a <a id="id119" class="indexterm"/>dependency, you can use the <code class="literal">files</code> method that Gradle provides. This is what it looks like:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile files('libs/domoarigato.jar')
}</pre></div><p>This can get tedious if you have a lot of JAR files, so it might be easier to add an entire folder at once:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile fileTree('libs')
}</pre></div><p>By default, a newly created Android project will have a libs folder, and declare it to be used for dependencies. Instead of simply depending on all files in the folder, there is a filter that makes sure that only JAR files are used:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
}</pre></div><p>This means that in any Android project that is created in Android Studio, you can drop a JAR in the libs folder, and it will automatically be included in the compile classpath and the final APK.</p></div><div class="section" title="Native libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Native libraries</h2></div></div></div><p>Libraries<a id="id120" class="indexterm"/> written in <a id="id121" class="indexterm"/>C or C++ can be compiled to platform-specific native code. These libraries typically consist of several <code class="literal">.so</code> files, one for every platform. The Android plugin supports native libraries by default, all you need to do is create a directory called <code class="literal">jniLibs</code> on the module level, and create subdirectories for each platform. Drop the <code class="literal">.so</code> files in the applicable directory, and you are good to go.</p><p>Your structure <a id="id122" class="indexterm"/>should look like this:</p><div class="informalexample"><pre class="programlisting">app
├── AndroidManifest.xml
└── jniLibs
    ├── armeabi
    │   └── nativelib.so
    ├── armeabi-v7a
    │   └── nativelib.so
    ├── mips
    │   └── nativelib.so
    └── x86
        └── nativelib.so</pre></div><p>If this convention does not work <a id="id123" class="indexterm"/>for you, you can just set the location yourself in the build file:</p><div class="informalexample"><pre class="programlisting">android {
    sourceSets.main {
        jniLibs.srcDir 'src/main/libs'
    }
}</pre></div></div><div class="section" title="Library projects"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Library projects</h2></div></div></div><p>If you want to share a library<a id="id124" class="indexterm"/> that uses Android APIs, or includes Android resources, you need<a id="id125" class="indexterm"/> to create a library project. Library projects generally behave the same as application projects. You can use the same tasks to build and test library projects, and they can have different build variants. The difference is in the output. Where an application project generates an APK that can be installed and run on an Android device, a library project generates a <code class="literal">.aar</code> file. This file can be used as a library for Android application projects.</p><div class="section" title="Creating and using library project modules"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Creating and using library project modules</h3></div></div></div><p>Instead of applying the <a id="id126" class="indexterm"/>Android application plugin, the build script <a id="id127" class="indexterm"/>applies the Android library plugin:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'com.android.library'</pre></div><p>There are two ways to include a library project in your application. One is to have it as a module inside your project; another is to create a <code class="literal">.aar</code> file, which can be reused in multiple applications.</p><p>If you set up a library project as a module in your project, you need to add the module to <code class="literal">settings.gradle</code> and add it as a dependency to the application module. The settings file should look like this:</p><div class="informalexample"><pre class="programlisting">include ':app', ':library'</pre></div><p>In this case, the library module is called <code class="literal">library</code>, and this corresponds to a folder with the same name. To use the library in the Android module, a dependency needs to be added to the <code class="literal">build.gradle</code> file of the Android module:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile project(':library')
}</pre></div><p>This will include the<a id="id128" class="indexterm"/> output of the library in the classpath of the <a id="id129" class="indexterm"/>application module. We will look at this approach in more detail in <a class="link" href="ch05.html" title="Chapter 5. Managing Multimodule Builds">Chapter 5</a>, <span class="emphasis"><em>Managing Multimodule Builds</em></span>.</p></div><div class="section" title="Using .aar files"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec09"/>Using .aar files</h3></div></div></div><p>If you create a library that you <a id="id130" class="indexterm"/>want to reuse in different Android applications, you can<a id="id131" class="indexterm"/> build a <code class="literal">.aar</code> file, and add it to your project as a dependency. The <code class="literal">.aar</code> file will be generated in the <code class="literal">build/output/aar/</code> folder of the module's directory when building the library. To add the <code class="literal">.aar</code> file as a dependency, you need to create a folder in the application module, copy the <code class="literal">.aar</code> file to it, and add the folder as a repository:</p><div class="informalexample"><pre class="programlisting">repositories {
    flatDir {
        dirs 'aars'
    }
}</pre></div><p>This will make it possible to add any file inside that folder as a dependency. You can reference the dependency as follows:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile(name:'libraryname', ext:'aar')
}</pre></div><p>This tells Gradle to look for a library with a certain name that has the <code class="literal">.aar</code> extension.</p></div></div></div>
<div class="section" title="Dependency concepts"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Dependency concepts</h1></div></div></div><p>There are a few<a id="id132" class="indexterm"/> dependency-related concepts that are interesting to understand, even if you might not need to use them today. One of them is the concept of configurations, which explains the <code class="literal">compile</code> keyword that we have been using for dependencies throughout this chapter.</p><div class="section" title="Configurations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Configurations</h2></div></div></div><p>Sometimes you<a id="id133" class="indexterm"/> might have to work with an SDK that is only <a id="id134" class="indexterm"/>present on certain devices, like a Bluetooth SDK from a specific vendor, for example. In order to be able to compile the code, you need to add the SDK to your compile classpath. You do not need to include the SDK in your APK though, because it is already on the device. This is where dependency configurations come in.</p><p>Gradle groups dependencies into configurations, which are just named sets of files. These are the standard configurations for an Android app or library:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">compile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">apk</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">provided</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">testCompile</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">androidTestCompile</code></li></ul></div><p>The <code class="literal">compile</code> configuration<a id="id135" class="indexterm"/> is the default one and contains all dependencies required to compile the main application. Everything in this configuration is not only added to the classpath, but also to the generated APK.</p><p>The dependencies in the <code class="literal">apk</code> configuration <a id="id136" class="indexterm"/>will only be added to the package, and are not added to the compilation classpath. The <code class="literal">provided</code> configuration<a id="id137" class="indexterm"/> does the exact opposite, and its dependencies will not be packaged. These two configurations only take JAR dependencies. Trying to add library projects to them will result in an error.</p><p>Finally, the <code class="literal">testCompile</code> and <code class="literal">androidTestCompile</code> configurations add extra libraries specifically for <a id="id138" class="indexterm"/>testing. These<a id="id139" class="indexterm"/> configurations are used when running test-related tasks, which can be useful when adding a testing framework such as JUnit or Espresso. You only want these frameworks to be present in the test APK, not in the release APK.</p><p>Besides those standard configurations, the Android plugin also generates configurations for every build variant, making it possible to add dependencies to configurations such as <code class="literal">debugCompile</code>, <code class="literal">releaseProvided</code>, and so on. This can be useful if you want to add a logging framework to only your debug builds, for example. You can find more information on this in <a class="link" href="ch04.html" title="Chapter 4. Creating Build Variants">Chapter 4</a>, <span class="emphasis"><em>Creating Build Variants</em></span>.</p></div><div class="section" title="Semantic versioning"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Semantic versioning</h2></div></div></div><p>Versioning is an <a id="id140" class="indexterm"/>important aspect of dependency management. Dependencies<a id="id141" class="indexterm"/> added to repositories such as JCenter are assumed to follow a set of rules for versioning, called semantic versioning. With semantic versioning, a version number always has the format <code class="literal">major.minor.patch</code>, and the numbers are incremented according to the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A major <a id="id142" class="indexterm"/>version goes up when you make incompatible <a id="id143" class="indexterm"/>API changes</li><li class="listitem" style="list-style-type: disc">A minor version gets updated when you add functionality in a backwards-compatible manner</li><li class="listitem" style="list-style-type: disc">A patch is incremented when you make bug fixes</li></ul></div></div><div class="section" title="Dynamic versions"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec34"/>Dynamic versions</h2></div></div></div><p>In some situations, you <a id="id144" class="indexterm"/>might <a id="id145" class="indexterm"/>want to get the latest version of a dependency every time you build your app or library. The best way to accomplish this is by using dynamic versions. There are several ways to apply dynamic versions, here are some examples:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile 'com.android.support:support-v4:22.2.+'
    compile 'com.android.support:appcompat-v7:22.2+'
    compile 'com.android.support:recyclerview-v7:+'
}</pre></div><p>In the first line, we tell Gradle to get the latest patch release. In line two, we specify that we want to get every new minor version, and it has to be at least minor version 2. In the last line, we tell Gradle always to get the newest version of the library.</p><p>You should be careful with using dynamic versions. If you allow Gradle to pick up the latest version, it might pick up a dependency version that is unstable, causing the build to break. Even worse, you could end up with different versions of a dependency on the build server and on your personal machine, causing your application's behavior to be inconsistent.</p><p>Android Studio will warn you about the possible problems with dynamic versions when you try to use it in your build file, as you can see in the following screenshot:</p><div class="mediaobject"><img src="graphics/B01061_03_01.jpg" alt="Dynamic versions"/></div></div></div>
<div class="section" title="Inside Android Studio"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Inside Android Studio</h1></div></div></div><p>The easiest way to<a id="id146" class="indexterm"/> add new dependencies is to use <a id="id147" class="indexterm"/>Android Studio's <span class="strong"><strong>Project Structure</strong></span> dialog. Open the dialog from the <span class="strong"><strong>File</strong></span> menu and navigate to the <span class="strong"><strong>Dependencies</strong></span> tab to get an overview of your current dependencies:</p><div class="mediaobject"><img src="graphics/B01061_03_02.jpg" alt="Inside Android Studio"/></div><p>From this dialog, you can add new dependencies by clicking on the green plus icon. You can add other modules, files, and you can even search JCenter for libraries:</p><div class="mediaobject"><img src="graphics/B01061_03_03.jpg" alt="Inside Android Studio"/></div><p>Using the Android <a id="id148" class="indexterm"/>Studio dialog makes it easy to get <a id="id149" class="indexterm"/>an overview of the dependencies in your project, and to add new libraries. You do not need to manually add lines to the <code class="literal">build.gradle</code> file, and it is easy to search JCenter straight from the IDE.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we looked at several ways to add dependencies to an Android project. We learned about repositories, all the forms they can come in, and how we can depend on files without using repositories.</p><p>You now also know about some important concepts regarding dependencies, namely configurations, semantic versioning, and dynamic versions.</p><p>We have mentioned build variants on several occasions already, and in the next chapter, we will finally explain what build variants are, and why they are useful. Build variants can make it easier to develop, test, and distribute apps. Understanding how variants work can significantly speed up your development and distribution process.</p></div></body></html>