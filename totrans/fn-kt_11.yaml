- en: Working with Streams in Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kotlin中使用流
- en: So, we are gradually moving towards completing this book. In this chapter, we
    are going to cover Streams in Kotlin and how to work with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们正在逐步完成这本书。在本章中，我们将介绍Kotlin中的流以及如何使用它们。
- en: Streams were first introduced in Java from Java 8\. The Streams API in Kotlin
    is almost identical to the Java API, but contains a few little additions and extension
    functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 流首次在Java 8中被引入。Kotlin中的Stream API几乎与Java API相同，但包含了一些小的补充和扩展函数。
- en: 'This is the contents that we will be covering in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章我们将要涵盖的内容：
- en: Introduction to Streams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的介绍
- en: Collections versus Streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合与流
- en: Streams versus Observable (ReactiveX-RxKotlin/RxJava)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流与可观察对象（ReactiveX-RxKotlin/RxJava）
- en: Working with Streams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的使用
- en: Different ways to create Streams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流的多种方式
- en: Collecting Streams
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的收集
- en: So, let's get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Introduction to Streams
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流的介绍
- en: As we mentioned earlier, Streams were first introduced from Java 8\. Starting
    from Java 8, Java started to give more focus to functional programming and started
    to add functional features gradually.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，流（Streams）首次在Java 8中被引入。从Java 8开始，Java开始更加关注函数式编程，并逐渐添加了函数式特性。
- en: Kotlin, on the other hand, started to add functional features from day one.
    Kotlin added functional features and interfaces. While working with Java, you
    can use Streams only if you use Java 8 and later versions, but with Kotlin you
    can still use Streams, even when working with JDK 6.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Kotlin从第一天开始就添加了函数式特性。Kotlin添加了函数式特性和接口。当使用Java时，只有在使用Java 8及更高版本时才能使用流，但使用Kotlin，即使在与JDK
    6一起工作时，你仍然可以使用流。
- en: 'So, what are Streams? You can think of Streams as an abstract layer over a
    sequence of elements to perform aggregate operations. Confused? Let''s take a
    code example and then try to understand:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是流呢？你可以将流想象为一个抽象层，它覆盖了一系列元素以执行聚合操作。困惑吗？让我们通过一个代码示例来尝试理解：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '![](img/eedf1b52-a70a-4df2-a3fd-bb9be43d9878.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eedf1b52-a70a-4df2-a3fd-bb9be43d9878.jpg)'
- en: In the preceding program, what we did was create an `IntRange` value, create
    a `Sequence` value from it, and then get the `stream` value from it. We then skipped
    the first five items and then collected it back to a `List` instance. We will
    have a detailed look at all the functions used in the preceding code later in
    this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的程序中，我们所做的是创建一个`IntRange`值，从它创建一个`Sequence`值，然后从它获取`stream`值。然后我们跳过了前五个元素，并将其收集回一个`List`实例。我们将在本章后面详细查看之前代码中使用的所有函数。
- en: The preceding program utilized the functional interfaces of the Stream API.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序使用了Stream API的函数式接口。
- en: Stream API has a rich set of functional interfaces like we saw in the Collections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Stream API拥有丰富的函数式接口，就像我们在集合中看到的那样。
- en: Collections versus Streams
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合与流
- en: 'Reading up till here, you''re probably thinking that all operations we performed
    in that program is possible with Collections itself in Kotlin, so why should we
    use Streams? To answer that, we should first learn the differences between Streams
    and Collections. So, let''s have a look at the following list consisting of differences
    between Collections and Streams:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 读到这儿，你可能正在想，在那个程序中我们执行的所有操作在Kotlin的集合中也是可能的，那么为什么我们要使用流呢？为了回答这个问题，我们首先应该了解流和集合之间的区别。让我们看一下以下列出的集合和流之间的区别列表：
- en: As the definition of Collections says, a **Collection** is a data structure
    which stores and lets you work with a group of data. **Streams**, on the other
    hand, aren't data structures and don't store anything; they work like a pipeline
    or IO channel, which fetches data from its source on demand.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如集合的定义所说，**集合**是一个数据结构，它存储并允许你处理一组数据。另一方面，**流**不是数据结构，不存储任何东西；它们像管道或IO通道一样工作，按需从其源获取数据。
- en: Every data structure must have a finite size limit, and the same applies to
    Collections as well. But, as Streams are not data structures, they don't need
    to have any specific size limit.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个数据结构都必须有一个有限的大小限制，集合也是如此。但是，由于流不是数据结构，它们不需要有特定的尺寸限制。
- en: While accessing elements of a Collection directly, you can do it any time, even
    for the same position, without the requirement of recreating the Collection. But
    when working with Streams, elements of a Stream are only visited once during the
    life of a Stream. Like an iterator, a new Stream must be generated to revisit
    the same elements of the source.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当直接访问集合的元素时，你可以随时进行，即使是相同的位置，也不需要重新创建集合。但是，当与流（Streams）一起工作时，流中的元素在流的生命周期内只会被访问一次。就像迭代器一样，必须生成一个新的流来重新访问源中的相同元素。
- en: The Collection API constructs objects in an eager manner, always ready to be
    consumed. The Stream API creates objects in a lazy, on-demand basis.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合API以急切的方式构建对象，总是准备好被消费。流API以懒加载、按需的方式创建对象。
- en: The Collection API is used for storing data in different kinds of data structures.
    The Stream API is used for the computation of data on a large set of objects.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合（Collection）API用于在多种数据结构中存储数据。流（Stream）API用于在大量对象上计算数据。
- en: 'So, these were very basic differences between the Collection API and the Stream
    API. At a glance, the Streams seem like RxKotlin, Observables which provide a
    way to consume the data, but there are a lot of significant differences between
    Streams and Observables. These are the differences between Streams and Observables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些是集合API和流API之间非常基本的不同之处。乍一看，流（Streams）似乎像是RxKotlin的可观察者（Observables），它们提供了一种消费数据的方式，但流（Streams）和可观察者（Observables）之间有很多显著的差异。这些是流（Streams）和可观察者（Observables）之间的差异：
- en: The first notable difference is that Streams are pull-based, and Observables
    are push-based. This may sound too abstract, but it has significant consequences
    that are very concrete.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个值得注意的区别是，流（Streams）是基于拉取的，而可观察者（Observables）是基于推送的。这可能听起来过于抽象，但它有非常具体的重大影响。
- en: With Observables, it's easy to change threads or specify thread pools for a
    chain with ease, thanks to Schedulers. But, with Streams, it's a bit tricky.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可观察者（Observables），由于调度器（Schedulers）的存在，很容易更改线程或轻松指定链的线程池。但是，使用流（Streams）则有点棘手。
- en: Observables are synchronized all the way through. This spares you from checking
    all the time whether these basic operations are thread safe.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察者（Observables）在整个过程中都是同步的。这让你不必总是检查这些基本操作是否线程安全。
- en: One more significant difference is that Observables have a lot more functional
    interfaces than the Streams API, which makes Observables easy to use with a lot
    of options to accomplish a certain task.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个显著的区别是，可观察者（Observables）比流（Streams）API拥有更多的功能接口，这使得可观察者易于使用，并且有更多选项来完成特定任务。
- en: So, we learned that Streams are not a data structure but are like an abstract
    layer on top of the data source (which may be Collections or anything else), and
    even though Streams construct objects in a lazy, on-demand basis, they are still
    pull-based and use loops inside them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到了流（Streams）不是数据结构，而是数据源（可能是集合或其他任何东西）上方的抽象层，尽管流（Streams）以懒加载、按需的方式构建对象，但它们仍然是基于拉取的，并在其中使用循环。
- en: To know more about push-based architecture and Observables, you can have a read
    of the book, *Reactive Programming in Kotlin, *by Rivu Chakraborty.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于基于推送的架构和可观察者（Observables）的信息，你可以阅读Rivu Chakraborty所著的《Kotlin中的响应式编程》一书。
- en: Working with Streams
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理流（Streams）
- en: So, we learned a lot of theories regarding Streams, and we also learned that
    Streams have a set of functional interfaces to work with (actually, the functional
    interfaces is the only way to work with Streams), but as I mentioned before, they
    work in a slightly different way than the Collections API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们学习了许多关于流（Streams）的理论，我们还了解到流（Streams）有一组功能接口来与之交互（实际上，功能接口是唯一与流（Streams）交互的方式），但正如我之前提到的，它们的工作方式与集合API略有不同。
- en: 'To make things clearer, have a look back at the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，请回顾以下示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding program is a simple one; we just grabbed a stream of numbers `1`
    through `10` and filtered out the odd numbers from that stream, and then collected
    the results inside a new `List`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序是一个简单的例子；我们只是抓取了一个从`1`到`10`的数字流，并从该流中过滤出奇数，然后将结果收集到一个新的`List`中。
- en: But let's try to understand the mechanism of how it works. We are already familiar
    with functional interfaces and with the `filter` function, as we got introduced
    to them in the previous chapters, but the thing that's different here is the `collect`
    function and the `Collectors` value, which help collect the resultant data in
    a new `List`. We will have a closer look at the `collect` method and the `Collectors` value
    later in this chapter, but for now, let's have a look at the functional interfaces
    Streams offers, and types of Streams.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们尝试理解它是如何工作的机制。我们已经熟悉了函数式接口和 `filter` 函数，因为我们已经在前面的章节中介绍了它们，但这里不同的是 `collect`
    函数和 `Collectors` 值，它们有助于将结果数据收集到新的 `List` 中。我们将在本章后面更详细地讨论 `collect` 方法以及 `Collectors`
    值，但现在，让我们看看 Streams 提供的函数式接口和流类型。
- en: 'So, the following is the list of operations/functional interfaces from the
    Stream API and their descriptions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是从 Stream API 中提取的操作/函数式接口及其描述：
- en: '`filter()`: Works in the same way like `Collection.filter` in Kotlin. It returns
    a `stream` values consisting of the elements of this `stream` that match the given
    predicate.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`: 与 Kotlin 中的 `Collection.filter` 功能相同。它返回一个由与此 `stream` 中匹配给定谓词的元素组成的
    `stream` 值。'
- en: '`map()`: Works in the same way as `Collection.map` in Kotlin. It returns a
    `stream` value consisting of the results of applying the given function to each
    element of this `stream`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`: 与 Kotlin 中的 `Collection.map` 功能相同。它返回一个由将给定函数应用于此 `stream` 的每个元素的结果组成的
    `stream` 值。'
- en: '`mapToInt()`/`mapToLong()`/`mapToDouble()`: Works the same way as `map`, but
    instead of returning a `stream` value, they return `IntStream`, `LongStream` and
    `IntStream` values, respectively. We are covering `IntStream`, `LongStream`, and `IntStream`
    in detail later in this chapter.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapToInt()`/`mapToLong()`/`mapToDouble()`: 与 `map` 的功能相同，但返回的不是 `stream` 值，而是分别返回
    `IntStream`、`LongStream` 和 `DoubleStream` 值。我们将在本章后面详细讨论 `IntStream`、`LongStream`
    和 `DoubleStream`。'
- en: '`flatMap()`: Works the same way as `Collection.flatMap` in Kotlin.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap()`: 与 Kotlin 中的 `Collection.flatMap` 功能相同。'
- en: '`flatMapToInt()`/`flatMapToLong()`/`flatMapToDouble()`: Works the same way
    as `flatMap`, but instead of returning a `stream` value, they return the `IntStream`,
    `LongStream`, and `IntStream` values, respectively.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMapToInt()`/`flatMapToLong()`/`flatMapToDouble()`: 与 `flatMap` 的功能相同，但返回的不是
    `stream` 值，而是分别返回 `IntStream`、`LongStream` 和 `DoubleStream` 值。'
- en: '`distinct()`: Works in the same way as `Collection.distinct`. It returns a
    `stream` value of distinct elements.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`: 与 `Collection.distinct` 的功能相同。它返回一个包含不同元素的 `stream` 值。'
- en: '`peek()`: This function doesn''t have any Kotlin Collection counterpart, however,
    it has a counterpart in RxKotlin/RxJava. This function returns the `stream` value
    consisting of the elements of this `stream`, additionally performing the provided
    action on each element, as elements are consumed from the resulting `stream`,
    much like the `doOnNext` operator of RxJava.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 这个函数在 Kotlin 集合中没有对应的函数，然而在 RxKotlin/RxJava 中有对应的函数。这个函数返回由这个 `stream`
    的元素组成的 `stream` 值，并在每个元素被消费的同时执行提供的操作，就像 RxJava 中的 `doOnNext` 操作符一样。'
- en: '`anyMatch()`: Similar to `Collection.any()`, it returns whether any elements
    of this `stream` match the provided predicate. It may not evaluate the predicate
    on all elements, if not necessary for determining the result. If the `stream` value
    is empty, then the `false` value is returned and the predicate is not evaluated.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anyMatch()`: 与 `Collection.any()` 类似，它返回此 `stream` 的任何元素是否都匹配提供的谓词。如果不需要评估所有元素来确定结果，则可能不会评估谓词。如果
    `stream` 值为空，则返回 `false` 值，并且不会评估谓词。'
- en: '`allMatch()`: Similar to `Collection.all`, it returns whether all elements
    of this `stream` match the provided predicate. It may not evaluate the predicate
    on all elements, if not necessary for determining the result. If the `stream` value
    is empty, then the `true` value is returned and the predicate is not evaluated.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allMatch()`: 与 `Collection.all` 类似，它返回此 `stream` 的所有元素是否都匹配提供的谓词。如果不需要评估所有元素来确定结果，则可能不会评估谓词。如果
    `stream` 值为空，则返回 `true` 值，并且不会评估谓词。'
- en: '`noneMatch()`: Similar to `Collection.none`, it returns whether no elements
    of this `stream` match the provided predicate. It may not evaluate the predicate
    on all elements, if not necessary for determining the result. If the `stream`
    is empty, then the `false` value is returned and the predicate is not evaluated.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`noneMatch()`：类似于`Collection.none`，它返回此`stream`中是否有元素匹配提供的谓词。如果不需要确定结果，则可能不会评估谓词。如果`stream`为空，则返回`false`值，并且不会评估谓词。'
- en: We are skipping examples of these functions, as they are similar to the `Collection`
    functions and RxJava/RxKotlin operators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了这些函数的示例，因为它们与`Collection`函数和RxJava/RxKotlin操作符类似。
- en: If you're wondering about it then yes, if your project is purely in Kotlin (without
    any Java or any other language code), you can safely ditch Streams in favor of
    Collections and coroutines altogether.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此有所疑问，那么是的，如果你的项目完全是Kotlin（没有任何Java或其他语言代码），你可以安全地放弃Streams，转而使用Collections和协程。
- en: So, let's now take a look at the `IntStream`, `DoubleStream`, and `LongStream` values
    we mentioned earlier and explore what purpose they serve.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看之前提到的`IntStream`、`DoubleStream`和`LongStream`值，并探讨它们的作用。
- en: Primitive streams
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始流
- en: '**Primitive streams** were introduced in Java 8, to take advantage of primitive
    data types in Java while using Streams (again, Streams are basically from Java,
    and Kotlin just adds a few extension functions to the Streams API). `IntStream`,
    `LongStream`, and `DoubleStream` are part of those primitive Streams.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**原始流**是在Java 8中引入的，以便在使用Streams的同时利用Java中的原始数据类型（再次强调，Streams基本上来自Java，而Kotlin只是为Streams
    API添加了一些扩展函数）。`IntStream`、`LongStream`和`DoubleStream`是这些原始流的一部分。'
- en: These primitive streams work similarly to the normal Stream with some added
    features of the primitive data types.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些原始流的工作方式与普通Stream类似，但增加了一些原始数据类型的功能。
- en: 'So, let''s take an example; have a look at the following program:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们举一个例子；看看以下程序：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, we created an `IntStream` value with the `IntStream.range()` function, the
    `range` function takes two integers as the starting and ending point and creates
    a Stream ranging from the specified integers, with both included. We then calculated
    the sum and printed it. The program seems quite easy, and credit goes to `IntStream`
    obviously, why? Think of calculating the sum of elements with that ease; without
    `IntStream`, we would have to loop through all the elements to calculate the sum.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们使用`IntStream.range()`函数创建了一个`IntStream`值，`range`函数接受两个整数作为起始点和结束点，并创建一个从指定整数开始的Stream，包括这两个整数。然后我们计算了总和并打印出来。程序看起来相当简单，显然要归功于`IntStream`，为什么？想想用这种方式轻松计算元素的总和；没有`IntStream`，我们就必须遍历所有元素来计算总和。
- en: 'The following is another example of primitive streams:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个原始流的例子：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Have a look at the following output before we explain the program:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释程序之前，先看看以下输出：
- en: '![](img/5d610692-ea36-4f48-a0ce-6250c7695cdd.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5d610692-ea36-4f48-a0ce-6250c7695cdd.jpg)'
- en: 'So, let''s explain the program:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来解释一下这个程序：
- en: On comment `(1)`, we created a `DoubleStream` value with the factory method
    `iterate()`. The iterate method takes a `double` as the seed of the Stream, and
    an operand, which will be iteratively applied to generate the elements of the
    Stream, for example if you pass *x* as the seed and *f* as the operator, the Stream
    will return *x* as the first element, *f(x)* as the second element, *f(f(x))*
    as the third element, and so on. This function creates a Stream of infinite size.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在注释`(1)`中，我们使用`iterate()`工厂方法创建了一个`DoubleStream`值。`iterate`方法接受一个`double`作为Stream的种子，以及一个操作符，该操作符将被迭代应用以生成Stream的元素，例如，如果你传递*x*作为种子和*f*作为操作符，Stream将返回*x*作为第一个元素，*f(x)*作为第二个元素，*f(f(x))*作为第三个元素，依此类推。此函数创建了一个无限大小的Stream。
- en: We used the `limit` operator at comment `(2)`, as we wanted only 10 elements
    from that stream, not all the elements till infinity. On comment `(3)`, we calculated
    `average`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在注释`(2)`处使用了`limit`操作符，因为我们只想从这个Stream中获取10个元素，而不是无限多的所有元素。在注释`(3)`处，我们计算了`average`。
- en: So, let's have a look at the different ways to create a Stream.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看看创建Stream的不同方法。
- en: Stream factory methods
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream工厂方法
- en: 'The Streams API provides numerous ways to get a `Stream` instance. The following
    is the list of ways to create Streams that we are covering:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Streams API提供了多种获取`Stream`实例的方法。以下是创建Streams的几种方式，我们将对其进行介绍：
- en: '`Stream Builder`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream Builder`'
- en: '`Stream.empty()`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.empty()`'
- en: '`Stream.of()`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.of()`'
- en: '`Stream.generate()`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.generate()`'
- en: '`Stream.iterate()`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream.iterate()`'
- en: Kotlin extension—`asStream()`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin扩展——`asStream()`
- en: Among the preceding list, we've already seen how the Kotlin extension—`asStream`
    and the `Stream.iterate` function works (it'll work in the same way as the `DoubleStream.iterate` value,
    covered in the previous example). We will have a look at the rest.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们已经看到了Kotlin扩展`asStream`和`Stream.iterate`函数的工作方式（它将以与前面示例中覆盖的`DoubleStream.iterate`值相同的方式工作）。我们将查看其余部分。
- en: Stream Builder
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream Builder
- en: 'The `Stream Builder` interface makes it really easy to create an instance of
    Stream with ease. Have a look at the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream Builder`接口使得轻松创建流实例变得非常容易。看看以下示例：'
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/5845a533-33b5-4825-9357-accd2a26e701.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5845a533-33b5-4825-9357-accd2a26e701.jpg)'
- en: The `Stream.builder()` method returns an instance of `Streams.Builder`. Then,
    we used the `Builder.add` function; the `add` function accepts an item for the
    `stream` value to be built, and returns the same instance of `Stream.Builder`.
    The `build` function then created the `stream` instance with the items provided
    to the builder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.builder()`方法返回一个`Streams.Builder`实例。然后，我们使用了`Builder.add`函数；`add`函数接受要构建的`stream`值的项，并返回相同的`Stream.Builder`实例。然后`build`函数使用提供给构建器的项创建`stream`实例。'
- en: Creating empty Streams – Stream.empty()
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建空流 – Stream.empty()
- en: 'Creating empty Streams is really easy with the `Streams.empty()` factory method.
    Consider the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Streams.empty()`工厂方法创建空流非常简单。考虑以下示例：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, we created an `emptyStream` value with `Stream.empty()`,
    we then used the `findAny()` function to get hold of any element randomly selected
    from that Stream. The `findAny()` method returns an `Optional` value with a randomly
    selected item from the Stream, or an empty `Optional`, if the Stream is empty.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`Stream.empty()`创建了`emptyStream`值，然后使用`findAny()`函数随机从该流中获取任何元素。`findAny()`方法返回一个包含从流中随机选择的项的`Optional`值，如果流为空，则返回一个空的`Optional`。
- en: 'The following is the output of the preceding program:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为前一个程序生成的输出：
- en: '![](img/5fdd9fe5-4c3e-423f-adc3-e9771bf2701b.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5fdd9fe5-4c3e-423f-adc3-e9771bf2701b.jpg)'
- en: Creating a Stream by passing elements – Stream.of()
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过传递元素创建流 – Stream.of()
- en: We can also get an instance of Stream by providing its elements to the `of`
    function. The `of` function works in a similar way to the `Observable.just` method
    from RxJava/RxKotlin.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将元素提供给`of`函数来获取流的一个实例。`of`函数的工作方式与RxJava/RxKotlin中的`Observable.just`方法类似。
- en: 'Have a look at the following example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/65744259-056b-4ad5-8524-3dd958898399.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/65744259-056b-4ad5-8524-3dd958898399.jpg)'
- en: Straightforward and easy, isn't it?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 简单直接，不是吗？
- en: Generating Streams – Stream.generate()
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成流 – Stream.generate()
- en: We can also create a Stream by using the `Stream.generate()` factory method.
    It accepts a lambda/supplier instance as a parameter, and will use it to generate
    the item for each time the item is demanded. This method also creates an infinite
    Stream.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`Stream.generate()`工厂方法来创建流。它接受一个lambda/supplier实例作为参数，并在每次需要项时使用它来生成项。此方法也会创建一个无限流。
- en: 'Consider the following example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/209892c9-f76a-4891-8697-07b88b05c32d.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/209892c9-f76a-4891-8697-07b88b05c32d.jpg)'
- en: So, the Stream API called the lambda to get each of the elements of the Stream—awesome.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Stream API调用了lambda来获取流中的每个元素——太棒了。
- en: So, now as we are quite familiar with how to use Streams and we know about primitive
    Streams, let's move forward and see how to work with `Collectors`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们相当熟悉如何使用流以及原始流，让我们继续前进，看看如何使用`Collectors`。
- en: Collector and Stream.collect – collecting Streams
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集器和Stream.collect – 收集流
- en: We can perform numerous operations with Stream, but we may come into a situation
    where we need to repack the elements from the Stream into a data structure. The
    `Stream.collect()` method helps us achieve the same. It's one of the terminal
    methods of the Streams API. It allows you to perform mutable `fold` operations
    (repackaging elements to some data structures and applying some additional logic,
    concatenating them, and many more) on data elements held in a Stream instance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用流执行许多操作，但我们可能会遇到需要将流中的元素重新包装到数据结构中的情况。`Stream.collect()`方法帮助我们实现这一点。它是Streams
    API的终端方法之一。它允许你在流实例中持有的数据元素上执行可变的`fold`操作（将元素重新包装到某些数据结构中并应用一些附加逻辑，连接它们等）。
- en: The `collect()` method takes a `Collector` interface implementation as a parameter,
    for the strategy (whether to repackage them to a data structure, concatenate them,
    or anything else) of collecting.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect()` 方法接受一个 `Collector` 接口实现作为参数，用于收集策略（是否将它们重新包装到数据结构中、连接它们，或其他任何操作）。'
- en: So, do we need to write our own implementation of the `Collector` interface
    for repackaging the Stream into a `List`/`Set` values? Of course not, the Streams
    API provides you with some of the predefined `Collector` implementations for some
    of the most common use cases.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们是否需要编写自己的 `Collector` 接口实现来将 Stream 重新包装成 `List`/`Set` 值？当然不需要，Streams
    API 为一些最常见的用例提供了一些预定义的 `Collector` 实现。
- en: 'The `Collectors` class holds the predefined `Collector` implementations. All
    of them can be imported with the following line:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors` 类包含预定义的 `Collector` 实现。所有这些都可以通过以下行导入：'
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following list contains the predefined `Collector` implementations:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含预定义的 `Collector` 实现：
- en: '`Collectors.toList()`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors.toList()`'
- en: '`Collectors.toSet()`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors.toSet()`'
- en: '`Collectors.toMap()`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors.toMap()`'
- en: '`Collectors.toCollection()`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors.toCollection()`'
- en: '`Collectors.joining()`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors.joining()`'
- en: '`Collectors.groupingBy()`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors.groupingBy()`'
- en: So, let's have a brief look at each of them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们简要地看一下每个方法。
- en: The Collectors.toList(), Collectors.toSet(), and Collectors.toCollection() methods
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Collectors.toList()`、`Collectors.toSet()` 和 `Collectors.toCollection()` 方法'
- en: We've already seen the implementations of `Collectors.toList()`. The `Collectors.toList()`
    method helps collect the elements of a Stream into a `List`. The important thing
    to note here is that you can't specify which `List` implementation to use; instead,
    it'll always use the default one.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `Collectors.toList()` 的实现。`Collectors.toList()` 方法帮助将 Stream 的元素收集到
    `List` 中。这里需要注意的是，你不能指定要使用哪个 `List` 实现；相反，它将始终使用默认的实现。
- en: '`Collectors.toSet()` is similar to the `Collectors.toList()` method, just instead
    of `List,` it repackages the elements into a set. Again, with `Collectors.toSet(),`
    you won''t be able to specify which set implementation to use.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors.toSet()` 与 `Collectors.toList()` 方法类似，只是它将元素重新包装到集合中。同样，使用 `Collectors.toSet()`，你将无法指定要使用哪个集合实现。'
- en: The `Collectors.toCollection()` method is a complementing version of the `toList()`
    and `toSet()`; it lets you provide a custom Collection to accumulate the list
    into.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors.toCollection()` 方法是 `toList()` 和 `toSet()` 的补充版本；它允许你提供一个自定义的 Collection
    来累积列表。'
- en: 'Consider the following example to explain it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例来解释它：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/703b52ce-d51e-4885-90c5-df8ebe17827f.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/703b52ce-d51e-4885-90c5-df8ebe17827f.jpg)'
- en: Collecting into Map – Collectors.toMap()
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集到 Map – Collectors.toMap()
- en: The `Collectors.toMap()` function helps us repackage the Stream into `Map` implementation.
    This function offers a lot of customizations. The simplest version accepts two
    lambdas; the first one is to determine the key of Map Entry, and the second lambda
    is to determine the value of Map Entry. Please note, each element in the Stream
    will be represented in an entry in the `Map`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors.toMap()` 函数帮助我们重新包装 Stream 成 `Map` 实现。此函数提供了许多自定义选项。最简单的版本接受两个
    lambda 表达式；第一个用于确定 Map Entry 的键，第二个用于确定 Map Entry 的值。请注意，Stream 中的每个元素都将表示为 `Map`
    中的一个条目。'
- en: Those two lambdas will get each element of the Stream in separate iterations
    and are expected to generate a key/value based on them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 lambda 表达式将在单独的迭代中获取 Stream 的每个元素，并基于它们生成键/值。
- en: 'Have a look at the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this program, we have used the simplest version of the `Collectors.toMap()`
    function. We passed two lambdas to it, the first one, determining the key for
    the entry will return the same value passed to it, the second one, on the other
    hand, computing and returning the square of the value passed. The important thing
    to note here is that both the lambdas will have the same parameter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用了 `Collectors.toMap()` 函数的最简单版本。我们向其传递了两个 lambda 表达式，第一个用于确定条目的键，将返回传递给它的相同值，第二个则相反，计算并返回传递值的平方。这里需要注意的是，这两个
    lambda 表达式将具有相同的参数。
- en: 'The output is shown as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![](img/3689bcd5-aafe-4565-b7d2-1cb5d9932bf7.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3689bcd5-aafe-4565-b7d2-1cb5d9932bf7.jpg)'
- en: Joining Stream of strings – Collectors.joining()
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串 Stream 的连接 – Collectors.joining()
- en: The `Collectors.joining()` function helps you join elements of a Stream, containing
    strings. It has three optional parameters, namely—`delimiter`, `prefix`, and `postfix`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collectors.joining()` 函数帮助您将包含字符串的 Stream 的元素连接起来。它有三个可选参数，即——`delimiter`（分隔符）、`prefix`（前缀）和`postfix`（后缀）。'
- en: 'Consider the following example of the program:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下程序的示例：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/618b5cbc-e614-41a3-b846-a98955c87cc7.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/618b5cbc-e614-41a3-b846-a98955c87cc7.jpg)'
- en: Grouping elements of Stream – Collectors.groupingBy()
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream 元素分组 – Collectors.groupingBy()
- en: This function lets us collect the elements of a Stream into a `Map` function
    while grouping them. The basic difference of this function with `Collectors.toMap`
    is that this function lets you create a `Map<K,List<T>>` function, that is, it
    lets you create a `Map` function that will hold a `List` value as its value for
    each of the groups.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许我们在分组的同时将 Stream 的元素收集到一个 `Map` 函数中。此函数与 `Collectors.toMap` 的基本区别在于，此函数允许您创建一个
    `Map<K,List<T>>` 函数，也就是说，它允许您创建一个 `Map` 函数，该函数将为每个组保留一个 `List` 值作为其值。
- en: 'Consider the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/d9845b5e-654c-4512-9e5d-362cafc3a4aa.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9845b5e-654c-4512-9e5d-362cafc3a4aa.jpg)'
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, in this chapter, we learned about Streams. We learned how to create Streams,
    learned how to work with Streams, and how to repackage a Stream into Collections.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们学习了关于 Streams 的内容。我们学习了如何创建 Streams，学习了如何与 Streams 一起工作，以及如何将 Stream
    打包成 Collections。
- en: In the next chapter, we will get started with the Arrow library, which makes
    it easy to implement functional programming in Kotlin. So, don't just wait, turn
    the page and get started with Arrow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习 Arrow 库，它使得在 Kotlin 中实现函数式编程变得容易。所以，不要只是等待，翻到下一页，开始学习 Arrow。
