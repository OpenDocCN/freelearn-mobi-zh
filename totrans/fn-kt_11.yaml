- en: Working with Streams in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we are gradually moving towards completing this book. In this chapter, we
    are going to cover Streams in Kotlin and how to work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Streams were first introduced in Java from Java 8\. The Streams API in Kotlin
    is almost identical to the Java API, but contains a few little additions and extension
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the contents that we will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections versus Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams versus Observable (ReactiveX-RxKotlin/RxJava)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different ways to create Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned earlier, Streams were first introduced from Java 8\. Starting
    from Java 8, Java started to give more focus to functional programming and started
    to add functional features gradually.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin, on the other hand, started to add functional features from day one.
    Kotlin added functional features and interfaces. While working with Java, you
    can use Streams only if you use Java 8 and later versions, but with Kotlin you
    can still use Streams, even when working with JDK 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are Streams? You can think of Streams as an abstract layer over a
    sequence of elements to perform aggregate operations. Confused? Let''s take a
    code example and then try to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eedf1b52-a70a-4df2-a3fd-bb9be43d9878.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding program, what we did was create an `IntRange` value, create
    a `Sequence` value from it, and then get the `stream` value from it. We then skipped
    the first five items and then collected it back to a `List` instance. We will
    have a detailed look at all the functions used in the preceding code later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding program utilized the functional interfaces of the Stream API.
  prefs: []
  type: TYPE_NORMAL
- en: Stream API has a rich set of functional interfaces like we saw in the Collections.
  prefs: []
  type: TYPE_NORMAL
- en: Collections versus Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reading up till here, you''re probably thinking that all operations we performed
    in that program is possible with Collections itself in Kotlin, so why should we
    use Streams? To answer that, we should first learn the differences between Streams
    and Collections. So, let''s have a look at the following list consisting of differences
    between Collections and Streams:'
  prefs: []
  type: TYPE_NORMAL
- en: As the definition of Collections says, a **Collection** is a data structure
    which stores and lets you work with a group of data. **Streams**, on the other
    hand, aren't data structures and don't store anything; they work like a pipeline
    or IO channel, which fetches data from its source on demand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every data structure must have a finite size limit, and the same applies to
    Collections as well. But, as Streams are not data structures, they don't need
    to have any specific size limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While accessing elements of a Collection directly, you can do it any time, even
    for the same position, without the requirement of recreating the Collection. But
    when working with Streams, elements of a Stream are only visited once during the
    life of a Stream. Like an iterator, a new Stream must be generated to revisit
    the same elements of the source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Collection API constructs objects in an eager manner, always ready to be
    consumed. The Stream API creates objects in a lazy, on-demand basis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Collection API is used for storing data in different kinds of data structures.
    The Stream API is used for the computation of data on a large set of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, these were very basic differences between the Collection API and the Stream
    API. At a glance, the Streams seem like RxKotlin, Observables which provide a
    way to consume the data, but there are a lot of significant differences between
    Streams and Observables. These are the differences between Streams and Observables:'
  prefs: []
  type: TYPE_NORMAL
- en: The first notable difference is that Streams are pull-based, and Observables
    are push-based. This may sound too abstract, but it has significant consequences
    that are very concrete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Observables, it's easy to change threads or specify thread pools for a
    chain with ease, thanks to Schedulers. But, with Streams, it's a bit tricky.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observables are synchronized all the way through. This spares you from checking
    all the time whether these basic operations are thread safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One more significant difference is that Observables have a lot more functional
    interfaces than the Streams API, which makes Observables easy to use with a lot
    of options to accomplish a certain task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, we learned that Streams are not a data structure but are like an abstract
    layer on top of the data source (which may be Collections or anything else), and
    even though Streams construct objects in a lazy, on-demand basis, they are still
    pull-based and use loops inside them.
  prefs: []
  type: TYPE_NORMAL
- en: To know more about push-based architecture and Observables, you can have a read
    of the book, *Reactive Programming in Kotlin, *by Rivu Chakraborty.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we learned a lot of theories regarding Streams, and we also learned that
    Streams have a set of functional interfaces to work with (actually, the functional
    interfaces is the only way to work with Streams), but as I mentioned before, they
    work in a slightly different way than the Collections API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things clearer, have a look back at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program is a simple one; we just grabbed a stream of numbers `1`
    through `10` and filtered out the odd numbers from that stream, and then collected
    the results inside a new `List`.
  prefs: []
  type: TYPE_NORMAL
- en: But let's try to understand the mechanism of how it works. We are already familiar
    with functional interfaces and with the `filter` function, as we got introduced
    to them in the previous chapters, but the thing that's different here is the `collect`
    function and the `Collectors` value, which help collect the resultant data in
    a new `List`. We will have a closer look at the `collect` method and the `Collectors` value
    later in this chapter, but for now, let's have a look at the functional interfaces
    Streams offers, and types of Streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the following is the list of operations/functional interfaces from the
    Stream API and their descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()`: Works in the same way like `Collection.filter` in Kotlin. It returns
    a `stream` values consisting of the elements of this `stream` that match the given
    predicate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`: Works in the same way as `Collection.map` in Kotlin. It returns a
    `stream` value consisting of the results of applying the given function to each
    element of this `stream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapToInt()`/`mapToLong()`/`mapToDouble()`: Works the same way as `map`, but
    instead of returning a `stream` value, they return `IntStream`, `LongStream` and
    `IntStream` values, respectively. We are covering `IntStream`, `LongStream`, and `IntStream`
    in detail later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap()`: Works the same way as `Collection.flatMap` in Kotlin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMapToInt()`/`flatMapToLong()`/`flatMapToDouble()`: Works the same way
    as `flatMap`, but instead of returning a `stream` value, they return the `IntStream`,
    `LongStream`, and `IntStream` values, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`distinct()`: Works in the same way as `Collection.distinct`. It returns a
    `stream` value of distinct elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This function doesn''t have any Kotlin Collection counterpart, however,
    it has a counterpart in RxKotlin/RxJava. This function returns the `stream` value
    consisting of the elements of this `stream`, additionally performing the provided
    action on each element, as elements are consumed from the resulting `stream`,
    much like the `doOnNext` operator of RxJava.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anyMatch()`: Similar to `Collection.any()`, it returns whether any elements
    of this `stream` match the provided predicate. It may not evaluate the predicate
    on all elements, if not necessary for determining the result. If the `stream` value
    is empty, then the `false` value is returned and the predicate is not evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allMatch()`: Similar to `Collection.all`, it returns whether all elements
    of this `stream` match the provided predicate. It may not evaluate the predicate
    on all elements, if not necessary for determining the result. If the `stream` value
    is empty, then the `true` value is returned and the predicate is not evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noneMatch()`: Similar to `Collection.none`, it returns whether no elements
    of this `stream` match the provided predicate. It may not evaluate the predicate
    on all elements, if not necessary for determining the result. If the `stream`
    is empty, then the `false` value is returned and the predicate is not evaluated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are skipping examples of these functions, as they are similar to the `Collection`
    functions and RxJava/RxKotlin operators.
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering about it then yes, if your project is purely in Kotlin (without
    any Java or any other language code), you can safely ditch Streams in favor of
    Collections and coroutines altogether.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's now take a look at the `IntStream`, `DoubleStream`, and `LongStream` values
    we mentioned earlier and explore what purpose they serve.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Primitive streams** were introduced in Java 8, to take advantage of primitive
    data types in Java while using Streams (again, Streams are basically from Java,
    and Kotlin just adds a few extension functions to the Streams API). `IntStream`,
    `LongStream`, and `DoubleStream` are part of those primitive Streams.'
  prefs: []
  type: TYPE_NORMAL
- en: These primitive streams work similarly to the normal Stream with some added
    features of the primitive data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s take an example; have a look at the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, we created an `IntStream` value with the `IntStream.range()` function, the
    `range` function takes two integers as the starting and ending point and creates
    a Stream ranging from the specified integers, with both included. We then calculated
    the sum and printed it. The program seems quite easy, and credit goes to `IntStream`
    obviously, why? Think of calculating the sum of elements with that ease; without
    `IntStream`, we would have to loop through all the elements to calculate the sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is another example of primitive streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the following output before we explain the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d610692-ea36-4f48-a0ce-6250c7695cdd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s explain the program:'
  prefs: []
  type: TYPE_NORMAL
- en: On comment `(1)`, we created a `DoubleStream` value with the factory method
    `iterate()`. The iterate method takes a `double` as the seed of the Stream, and
    an operand, which will be iteratively applied to generate the elements of the
    Stream, for example if you pass *x* as the seed and *f* as the operator, the Stream
    will return *x* as the first element, *f(x)* as the second element, *f(f(x))*
    as the third element, and so on. This function creates a Stream of infinite size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `limit` operator at comment `(2)`, as we wanted only 10 elements
    from that stream, not all the elements till infinity. On comment `(3)`, we calculated
    `average`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's have a look at the different ways to create a Stream.
  prefs: []
  type: TYPE_NORMAL
- en: Stream factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Streams API provides numerous ways to get a `Stream` instance. The following
    is the list of ways to create Streams that we are covering:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream Builder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream.empty()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream.of()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream.generate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream.iterate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin extension—`asStream()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among the preceding list, we've already seen how the Kotlin extension—`asStream`
    and the `Stream.iterate` function works (it'll work in the same way as the `DoubleStream.iterate` value,
    covered in the previous example). We will have a look at the rest.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream Builder` interface makes it really easy to create an instance of
    Stream with ease. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5845a533-33b5-4825-9357-accd2a26e701.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Stream.builder()` method returns an instance of `Streams.Builder`. Then,
    we used the `Builder.add` function; the `add` function accepts an item for the
    `stream` value to be built, and returns the same instance of `Stream.Builder`.
    The `build` function then created the `stream` instance with the items provided
    to the builder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating empty Streams – Stream.empty()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating empty Streams is really easy with the `Streams.empty()` factory method.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we created an `emptyStream` value with `Stream.empty()`,
    we then used the `findAny()` function to get hold of any element randomly selected
    from that Stream. The `findAny()` method returns an `Optional` value with a randomly
    selected item from the Stream, or an empty `Optional`, if the Stream is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fdd9fe5-4c3e-423f-adc3-e9771bf2701b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Stream by passing elements – Stream.of()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also get an instance of Stream by providing its elements to the `of`
    function. The `of` function works in a similar way to the `Observable.just` method
    from RxJava/RxKotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65744259-056b-4ad5-8524-3dd958898399.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Straightforward and easy, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Generating Streams – Stream.generate()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also create a Stream by using the `Stream.generate()` factory method.
    It accepts a lambda/supplier instance as a parameter, and will use it to generate
    the item for each time the item is demanded. This method also creates an infinite
    Stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/209892c9-f76a-4891-8697-07b88b05c32d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, the Stream API called the lambda to get each of the elements of the Stream—awesome.
  prefs: []
  type: TYPE_NORMAL
- en: So, now as we are quite familiar with how to use Streams and we know about primitive
    Streams, let's move forward and see how to work with `Collectors`.
  prefs: []
  type: TYPE_NORMAL
- en: Collector and Stream.collect – collecting Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can perform numerous operations with Stream, but we may come into a situation
    where we need to repack the elements from the Stream into a data structure. The
    `Stream.collect()` method helps us achieve the same. It's one of the terminal
    methods of the Streams API. It allows you to perform mutable `fold` operations
    (repackaging elements to some data structures and applying some additional logic,
    concatenating them, and many more) on data elements held in a Stream instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `collect()` method takes a `Collector` interface implementation as a parameter,
    for the strategy (whether to repackage them to a data structure, concatenate them,
    or anything else) of collecting.
  prefs: []
  type: TYPE_NORMAL
- en: So, do we need to write our own implementation of the `Collector` interface
    for repackaging the Stream into a `List`/`Set` values? Of course not, the Streams
    API provides you with some of the predefined `Collector` implementations for some
    of the most common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Collectors` class holds the predefined `Collector` implementations. All
    of them can be imported with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following list contains the predefined `Collector` implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collectors.toList()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collectors.toSet()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collectors.toMap()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collectors.toCollection()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collectors.joining()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collectors.groupingBy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's have a brief look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The Collectors.toList(), Collectors.toSet(), and Collectors.toCollection() methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen the implementations of `Collectors.toList()`. The `Collectors.toList()`
    method helps collect the elements of a Stream into a `List`. The important thing
    to note here is that you can't specify which `List` implementation to use; instead,
    it'll always use the default one.
  prefs: []
  type: TYPE_NORMAL
- en: '`Collectors.toSet()` is similar to the `Collectors.toList()` method, just instead
    of `List,` it repackages the elements into a set. Again, with `Collectors.toSet(),`
    you won''t be able to specify which set implementation to use.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Collectors.toCollection()` method is a complementing version of the `toList()`
    and `toSet()`; it lets you provide a custom Collection to accumulate the list
    into.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example to explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/703b52ce-d51e-4885-90c5-df8ebe17827f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Collecting into Map – Collectors.toMap()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Collectors.toMap()` function helps us repackage the Stream into `Map` implementation.
    This function offers a lot of customizations. The simplest version accepts two
    lambdas; the first one is to determine the key of Map Entry, and the second lambda
    is to determine the value of Map Entry. Please note, each element in the Stream
    will be represented in an entry in the `Map`.
  prefs: []
  type: TYPE_NORMAL
- en: Those two lambdas will get each element of the Stream in separate iterations
    and are expected to generate a key/value based on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this program, we have used the simplest version of the `Collectors.toMap()`
    function. We passed two lambdas to it, the first one, determining the key for
    the entry will return the same value passed to it, the second one, on the other
    hand, computing and returning the square of the value passed. The important thing
    to note here is that both the lambdas will have the same parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3689bcd5-aafe-4565-b7d2-1cb5d9932bf7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Joining Stream of strings – Collectors.joining()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Collectors.joining()` function helps you join elements of a Stream, containing
    strings. It has three optional parameters, namely—`delimiter`, `prefix`, and `postfix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/618b5cbc-e614-41a3-b846-a98955c87cc7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Grouping elements of Stream – Collectors.groupingBy()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This function lets us collect the elements of a Stream into a `Map` function
    while grouping them. The basic difference of this function with `Collectors.toMap`
    is that this function lets you create a `Map<K,List<T>>` function, that is, it
    lets you create a `Map` function that will hold a `List` value as its value for
    each of the groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9845b5e-654c-4512-9e5d-362cafc3a4aa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, in this chapter, we learned about Streams. We learned how to create Streams,
    learned how to work with Streams, and how to repackage a Stream into Collections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will get started with the Arrow library, which makes
    it easy to implement functional programming in Kotlin. So, don't just wait, turn
    the page and get started with Arrow.
  prefs: []
  type: TYPE_NORMAL
