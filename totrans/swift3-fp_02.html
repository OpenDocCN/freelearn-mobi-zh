<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Functions and Closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Functions and Closures</h1></div></div></div><p>In the previous chapter, we had an overview of functional programming and the Swift programming language. It introduced some of the key concepts about functions. As functions are the fundamental building blocks in functional programming, this chapter dives deeper into it and explains all the aspects related to the definition and usage of functions in functional Swift, together with coding examples.</p><p>This chapter starts with a definition of functions, continues with other related topics such as function types and tuples, and finally concludes with more advanced topics such as first-class functions, higher-order functions, function composition, closures, currying, recursion, and memoization.</p><p>This chapter will cover the following topics with coding examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The general syntax of functions</li><li class="listitem" style="list-style-type: disc">Defining and using function parameters</li><li class="listitem" style="list-style-type: disc">Setting internal and external parameters</li><li class="listitem" style="list-style-type: disc">Setting default parameter values</li><li class="listitem" style="list-style-type: disc">Defining and using variadic functions</li><li class="listitem" style="list-style-type: disc">Returning values from functions</li><li class="listitem" style="list-style-type: disc">Defining and using nested functions</li><li class="listitem" style="list-style-type: disc">Function types</li><li class="listitem" style="list-style-type: disc">Pure functions</li><li class="listitem" style="list-style-type: disc">First-class functions</li><li class="listitem" style="list-style-type: disc">Higher-order functions</li><li class="listitem" style="list-style-type: disc">Function composition</li><li class="listitem" style="list-style-type: disc">The definition of a custom operator</li><li class="listitem" style="list-style-type: disc">Defining and using closures</li><li class="listitem" style="list-style-type: disc">Function currying</li><li class="listitem" style="list-style-type: disc">Recursion</li><li class="listitem" style="list-style-type: disc">Memoization</li></ul></div><div class="section" title="What is a function?"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec11"/>What is a function?</h1></div></div></div><p>
<span class="strong"><strong>Object-oriented programming</strong></span> (<span class="strong"><strong>OOP</strong></span>) looks very natural to most developers as it simulates a real-life situation of classes or, in other words, blueprints and their instances, but it brought a lot of complexities and problems such as instance and memory management, complex multithreading, and concurrency programming.</p><p>Before OOP became mainstream, we were used to developing in procedural languages. In the C programming language, we did not have objects and classes; we would use structs and function pointers. So now we are talking about functional programming that relies mostly on functions just as procedural languages relied on procedures. We are able to develop very powerful programs in C without classes; in fact, most operating systems are developed in C. There are other multipurpose programming languages such as Go by Google that is not object-oriented and is getting very popular because of its performance and simplicity.</p><p>So, are we going to be able to write very complex applications without classes in Swift? We might wonder why we should do this. Generally, we should not, but attempting it will introduce us to the capabilities of functional programming. This is why we will have a whole chapter about functions before talking about other building blocks such as <code class="literal">classes</code>, <code class="literal">structs</code>, and <code class="literal">enums</code>.</p><p>A function is a block of code that executes a specific task, can be stored, can persist data, and can be passed around. We define them in standalone Swift files as global functions or inside other building blocks such as <code class="literal">classes</code>, <code class="literal">structs</code>, <code class="literal">enums</code>, and <code class="literal">protocols</code> as methods.</p><p>They are called methods if they are defined in classes but, in terms of definition, there is no difference between a function and method in Swift.</p><p>Defining them in other building blocks enables methods to use the scope of the parent or to be able to change it. They can access the scope of their parent and they have their own scope. Any variable that is defined inside a function is not accessible outside of it. The variables defined inside them and the corresponding allocated memory go away when the function terminates.</p><p>Functions are very powerful in Swift. We can compose a program with only functions as functions can receive and return functions, capture variables that exist in the context they were declared, and can persist data inside themselves. To understand the functional programming paradigms, we need to understand the capability of functions in detail. We need to think if we can avoid classes and only use functions, so we will cover all the details related to functions in upcoming sections of this chapter.</p></div></div>
<div class="section" title="The general syntax of functions and methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec12"/>The general syntax of functions and methods</h1></div></div></div><p>We can define functions or methods as follows:</p><pre class="programlisting">accessControl func functionName(parameter: ParameterType) throws&#13;
  -&gt; ReturnType { }</pre><p>As we know already, when functions are defined in objects, they become methods.</p><p>The first step to define a method is to tell the compiler from where it can be accessed. This concept is called access control in Swift and there are three levels of access control. We are going to explain them for methods as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Public access</strong></span>: Any entity can access a method that is defined as public if it is in the same module. If an entity is not in the same module, we will need to import the module to be able to call the method. We need to mark our methods and objects as <code class="literal">public</code> when we develop frameworks in order to enable other modules to use them.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Internal access</strong></span>: Any method that is defined as <code class="literal">internal</code> can be accessed from other entities in a module but cannot be accessed from other modules.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Private access</strong></span>: Any method that is defined as <code class="literal">private</code> can be accessed only from the same source file.</li></ul></div><p>By default, if we do not provide the access modifier, a variable or function becomes internal.</p><p>Using these access modifiers, we can structure our code properly; for instance, we can hide details from other modules if we define an entity as internal. We can even hide the details of a method from other files if we define them as private.</p><p>Before Swift 2.0, we had to define everything as public or add all source files to the testing target. Swift 2.0 introduced the <code class="literal">@testable import</code> syntax that enables us to define internal or private methods that can be accessed from testing modules.</p><p>Methods can generally be in three forms:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Instance methods</strong></span>: We need to obtain an instance of an object (in this book we will refer to <code class="literal">classes</code>, <code class="literal">structs</code>, and <code class="literal">enums</code> as objects) in order to be able to call the method defined in it, and then we will be able to access the scope and data of the object.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Static methods</strong></span>: Swift names them type methods also. They do not need any instances of objects and they cannot access the instance data. They are called by putting a dot after the name of the object type (for example, <code class="literal">Person.sayHi()</code>). The <code class="literal">static</code> methods cannot be overridden by the subclasses of the object that they reside in.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Class methods</strong></span>: Class methods are like the <code class="literal">static</code> methods but they can be overridden by subclasses.</li></ul></div><p>We have covered the keywords that are required for method definitions; now we will concentrate on the syntax that is shared among functions and methods. There are other concepts related to methods that are out of scope of this book as we will concentrate on functional programming in Swift.</p><p>Continuing to cover the function definition, now comes the <code class="literal">func</code> keyword that is mandatory and is used to tell the compiler that it is going to deal with a function.</p><p>Then comes the function name that is mandatory and is recommended to be camel-cased with the first letter as lowercase. The function name should be stating what the function does and is recommended to be in the form of a verb when we define our methods in objects.</p><p>Basically, our classes will be named nouns and methods will be verbs that are in the form of orders to the class. In pure functional programming, as the function does not reside in other objects, they can be named by their functionalities.</p><p>Parameters follow the <code class="literal">func</code> name. They will be defined in parentheses to pass arguments to the function. Parentheses are mandatory even if we do not have any parameters. We will cover all aspects of parameters in <span class="emphasis"><em>Defining and using function parameters</em></span> section of this chapter.</p><p>Then comes <code class="literal">throws</code>, which is not mandatory. A function or method that is marked with the <code class="literal">throws</code> keyword may or may not throw errors. We will cover error handling mechanisms in upcoming chapters. At this point, it is enough to know what they are when we see them in a function or method signature.</p><p>The next entity in a function type declaration is the return type. If a function is not void, the return type will come after the <code class="literal">-&gt;</code> sign. The return type indicates the type of entity that is going to be returned from a function.</p><p>We will cover return types in detail in <span class="emphasis"><em>Returning values from functions</em></span> section of this chapter, so now we can move on to the last piece of function that is present in most programming languages, our beloved <code class="literal">{ }</code>. We defined functions as blocks of functionality and <code class="literal">{ }</code> defines the borders of the block so that the function body is declared and execution happens in there. We will write the functionality inside <code class="literal">{ }</code>.</p><div class="section" title="Best practices in function definition"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec9"/>Best practices in function definition</h2></div></div></div><p>There are proven best practices for function and method definition provided by amazing software engineering resources, such as <span class="emphasis"><em>Clean Code: A Handbook of Agile Software Craftsmanship</em></span>, by <span class="emphasis"><em>Robert C. Martin</em></span>, <span class="emphasis"><em>Code Complete: A Practical Handbook of Software Construction, Second Edition</em></span>, by <span class="emphasis"><em>Steve McConnell</em></span>, and Coding Horror (<a class="ulink" href="https://blog.codinghorror.com/code-smells/">https://blog.codinghorror.com/code-smells/</a>), that we can summarize as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Try not to exceed 8-10 lines of code in each function as shorter functions or methods are easier to read, understand, and maintain.</li><li class="listitem" style="list-style-type: disc">Keep the number of parameters minimal because the more parameters a function has, the more complex it is.</li><li class="listitem" style="list-style-type: disc">Functions should have at least one parameter and one return value.</li><li class="listitem" style="list-style-type: disc">Avoid using type names in function names as it is going to be redundant.</li><li class="listitem" style="list-style-type: disc">Aim for one and only one functionality in a function.</li><li class="listitem" style="list-style-type: disc">Name a function or method in a way that describes its functionality properly and is easy to understand.</li><li class="listitem" style="list-style-type: disc">Name functions and methods consistently. If we have a connect function, we can have a disconnect one.</li><li class="listitem" style="list-style-type: disc">Write functions to solve the current problem and generalize it when needed. Try to avoid what-if scenarios as probably <span class="strong"><strong>you aren't gonna need it</strong></span> (<span class="strong"><strong>YAGNI</strong></span>).</li></ul></div></div><div class="section" title="Calling functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Calling functions</h2></div></div></div><p>We have covered a general syntax to define a function and method if it resides in an object. Now it is time to talk about how we call our defined functions and methods. To call a function, we will use its name and provide its required parameters. There are complexities with providing parameters that we will cover in upcoming section. For now, we are going to cover the most basic type of parameter, as follows:</p><pre class="programlisting">funcName(firstParam: "some String", secondParam: "some String")&#13;
</pre><p>This type of function calling should be familiar to Objective-C developers as the first parameter name is not named and the rest are named.</p><p>To call a method, we need to use the dot notation provided by Swift. The following examples are for class instance methods and static class methods:</p><pre class="programlisting">let someClassInstance = SomeClass()&#13;
let paramName = "parameter name"&#13;
let secondParamName = "second Parameter"&#13;
someClassInstance.funcName(firstParam: paramName, secondParam:&#13;
  secondParamName)&#13;
</pre></div></div>
<div class="section" title="Defining and using function parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Defining and using function parameters</h1></div></div></div><p>In function definition, parameters follow the function name and they are constants by default so we will not able to alter them inside the function body if we do not mark them with <code class="literal">var</code>. In functional programming, we avoid mutability; therefore, we would never use mutable parameters in functions.</p><p>Parameters should be inside parentheses. If we do not have any parameters, we simply put open and close parentheses without any characters between them:</p><pre class="programlisting">func functionName() { } &#13;
</pre><p>In functional programming, it is important to have functions that have at least one parameter. We will explain why it is important in upcoming sections.</p><p>We can have multiple parameters separated by commas. In Swift, parameters are named so we need to provide the parameter name and type after putting a colon, as shown in the following example:</p><pre class="programlisting">func functionName(firstParameter: ParameterType, secondParameter:&#13;
    ParameterType) {&#13;
    // function body&#13;
}&#13;
&#13;
// To call:&#13;
functionName(firstParameter: paramName, secondParameter: secondParamName)&#13;
</pre><p>
<code class="literal">ParameterType</code> can also be an optional type so the function becomes the following if our parameters need to be optionals:</p><pre class="programlisting">func functionName(parameter: ParameterType?, secondParameter: &#13;
  ParameterType?) { }</pre><p>Swift enables us to provide external parameter names that will be used when functions are called. The following example presents the syntax:</p><pre class="programlisting">Func functionName(externalParamName localParamName: ParameterType) &#13;
// To call: &#13;
functionName(externalParamName: parameter) &#13;
</pre><p>Only the local parameter name is usable in the function body.</p><p>It is possible to omit parameter names with the <code class="literal">_</code> syntax; for instance, if we do not want to provide any parameter name when the function is called, we can use <code class="literal">_</code> as <code class="literal">externalParamName</code> for the second or subsequent parameters.</p><p>If we want to have a parameter name for the first parameter name in function calls, we can basically provide the local parameter name as external also. In this book, we are going to use the default function parameter definition.</p><p>Parameters can have default values as follows:</p><pre class="programlisting">func functionName(parameter: Int = 3) {&#13;
    print("\(parameter) is provided.")&#13;
}&#13;
&#13;
functionName(parameter: 5) // prints "5 is provided."&#13;
functionName() // prints "3 is provided."&#13;
</pre><p>Parameters can be defined as <code class="literal">inout</code> to enable function callers obtaining parameters that are going to be changed in the body of a function. As we can use tuples for function returns, it is not recommended to use <code class="literal">inout</code> parameters unless we really need them.</p><p>We can define function parameters as tuples. For instance, the following example function accepts a tuple of the <code class="literal">(Int, Int)</code> type:</p><pre class="programlisting">func functionWithTupleParam(tupleParam: (Int, Int)) {} &#13;
</pre><p>As, under the hood, variables are represented by tuples in Swift, the parameters to a function can also be tuples. For instance, let's have a simple <code class="literal">convert</code> function that takes an array of <code class="literal">Int</code> and a multiplier and converts it to a different structure. Let's not worry about the implementation of this function for now; we will have <a class="link" href="ch06.html" title="Chapter 6. Map, Filter, and Reduce">Chapter 6</a>, <span class="emphasis"><em>Map, Filter, and Reduce</em></span> that will cover the map function:</p><pre class="programlisting">let numbers = [3, 5, 9, 10]&#13;
&#13;
func convert(numbers: [Int], multiplier: Int) -&gt; [String] {&#13;
    let convertedValues = numbers.enumerated().map { (index, element) in&#13;
        return "\(index): \(element * multiplier)"&#13;
    }&#13;
    return convertedValues&#13;
}&#13;
</pre><p>If we use this function as <code class="literal">let resultOfConversion = convert(numbers: numbers, multiplier: 3)</code>, the result is going to be <code class="literal">["0: 9", "1: 15", "2: 27", "3: 30"]</code>.</p><p>We can call our function with a tuple. Let's create a tuple and pass it to our function:</p><pre class="programlisting">let parameters = (numbers: numbers, multiplier: 3)&#13;
convert(parameters)&#13;
</pre><p>The result is identical to our previous function call. However, passing tuples in function calls is removed from Swift 3.0, so it is not recommended to use them.</p><p>We can define higher-order functions that can receive functions as parameters. In the following example, we define <code class="literal">funcParam</code> as a function type of <code class="literal">(Int, Int) -&gt; Int</code>:</p><pre class="programlisting">func functionWithFunctionParam(funcParam: (Int, Int)-&gt; Int) &#13;
</pre><p>In Swift, parameters can be of a generic type. The following example presents a function that has two generic parameters. In this syntax, any type (for example, <code class="literal">T</code> or <code class="literal">V</code>) that we put inside <code class="literal">&lt;&gt;</code> should be used in parameter definition:</p><pre class="programlisting">func functionWithGenerics&lt;T, V&gt;(firstParam: T, secondParam) &#13;
</pre><p>We will cover generics in <a class="link" href="ch05.html" title="Chapter 5. Generics and Associated Type Protocols">Chapter 5</a>, <span class="emphasis"><em>Generics and Associated Type Protocols</em></span>; at this point, knowing the syntax should be enough.</p></div>
<div class="section" title="Defining and using variadic functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Defining and using variadic functions</h1></div></div></div><p>Swift enables us to define functions with variadic parameters. A variadic parameter accepts zero or more values of a specified type. Variadic parameters are similar to array parameters but they are more readable and can only be used as the last parameter in multiparameter functions.</p><p>As variadic parameters can accept zero values, we will need to check whether they are empty.</p><p>The following example presents a function with variadic parameters of the <code class="literal">String</code> type:</p><pre class="programlisting">func greet(names: String...) {&#13;
    for name in names {&#13;
        print("Greetings, \(name)")&#13;
    }&#13;
}&#13;
&#13;
// To call this function&#13;
greet(names: "Steve", "Craig") // prints twice&#13;
greet(names: "Steve", "Craig", "Johny") // prints three times&#13;
</pre></div>
<div class="section" title="Returning values from functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Returning values from functions</h1></div></div></div><p>If we need our function to return a value, tuple, or another function, we can specify it by providing <code class="literal">ReturnType</code> after <code class="literal">-&gt;</code>. For instance, the following example returns <code class="literal">String</code>:</p><pre class="programlisting">func functionName() -&gt; String { } &#13;
</pre><p>Any function that has <code class="literal">ReturnType</code> in its definition should have a <code class="literal">return</code> keyword with the matching type in its body.</p><p>Return types can be optionals in Swift so the function becomes as follows if the return needs to be optional:</p><pre class="programlisting">func functionName() -&gt; String? { } &#13;
</pre><p>Tuples can be used to provide multiple return values. For instance, the following function returns a tuple of the <code class="literal">(Int, String)</code> type:</p><pre class="programlisting">func functionName() -&gt; (code: Int, status: String) { } &#13;
</pre><p>As we are using parentheses for tuples, we should avoid using parentheses for single return value functions.</p><p>Tuple return types can be optional too so the syntax becomes as follows:</p><pre class="programlisting">func functionName() -&gt; (code: Int, status: String)? { } &#13;
</pre><p>This syntax makes the entire tuple optional; if we want to make only <code class="literal">status</code> optional, we can define the function as follows:</p><pre class="programlisting">func functionName() -&gt; (code: Int, status: String?) { } &#13;
</pre><p>In Swift, functions can return functions. The following example presents a function with the return type of a function that takes two <code class="literal">Int</code> values and returns an <code class="literal">Int</code> value:</p><pre class="programlisting">func funcName() -&gt; (Int, Int)-&gt; Int {} &#13;
</pre><p>If we do not expect a function to return any value, tuple, or function, we simply do not provide <code class="literal">ReturnType</code>:</p><pre class="programlisting">func functionName() { } &#13;
</pre><p>We could also explicitly declare it with the <code class="literal">Void</code> keyword:</p><pre class="programlisting">func functionName() -&gt; Void { } &#13;
</pre><p>In functional programming, it is important to have return types in functions. In other words, it is a good practice to avoid functions that have <code class="literal">Void</code> as return type. A function with the <code class="literal">Void</code> return type typically is a function that changes another entity in the code; otherwise, why would we need to have a function? OK, we might have wanted to log an expression to the console/log file or write data to a database or a file to a filesystem. In these cases, it is also preferable to have a return or feedback related to the success of the operation. As we try to avoid mutability and stateful programming in functional programming, we can assume that our functions will have returns in different forms.</p><p>This requirement is in line with mathematical underlying bases of functional programming. In mathematics, a simple function is defined as follows:</p><pre class="programlisting">y = f(x) or f(x) -&gt; y &#13;
</pre><p>Here, <code class="literal">f</code> is a function that takes <code class="literal">x</code> and returns <code class="literal">y</code>. Therefore, a function receives at least one parameter and returns at least a value. In functional programming, following the same paradigm makes reasoning easier, function composition possible, and code more readable.</p></div>
<div class="section" title="Pure functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Pure functions</h1></div></div></div><p>Pure functions are functions that do not possess any side effects; in other words, they do not change or alter any data or state outside of themselves. Additionally, they do not access any data or state except their provided parameters. Pure functions are like mathematical functions that are pure by nature.</p><p>Pure functions return a value that is only determined by its parameter values. Pure functions are easy to test as they rely only on their parameters and do not change or access any data or state outside of themselves. Pure functions are suitable for concurrency as they do not access and change global data or states.</p><p>The following list presents examples of pure and not pure functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Printing a String literal to a console is not pure as it modifies an external state.</li><li class="listitem" style="list-style-type: disc">Reading a file is not pure as it depends on the external state at different times.</li><li class="listitem" style="list-style-type: disc">Length of a String is pure as it does not rely on a state. It only takes a String as input and returns the length as output.</li><li class="listitem" style="list-style-type: disc">Getting the current date is not pure as it returns different values when called at different dates.</li><li class="listitem" style="list-style-type: disc">Getting a random number is not pure as it returns different values each time it is called.</li></ul></div><p>Using pure functions may sound very restrictive and impossible to utilize in real-world scenarios, but there are other tools that can provide the same functionality, which we will discuss later in this book.</p><p>We will see the benefits of pure functions in more detail in the next chapter.</p></div>
<div class="section" title="Function types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Function types</h1></div></div></div><p>A function parameter type along with its return type defines the type of the function. For instance, the function type for the following coding example is <code class="literal">(Int, Double) -&gt; String</code>:</p><pre class="programlisting">func functionName(firstParam: Int, secondParam: Double) -&gt; String &#13;
</pre><p>We will be able to use function types in the way we use other types. The following code example presents a function type:</p><pre class="programlisting">var simpleMathOperator: (Double, Double) -&gt; Double &#13;
</pre><p>Here, <code class="literal">simpleMathOperator</code> is a variable of a function of the <code class="literal">(Double, Double) -&gt; Double</code> type.</p><p>We could define <code class="literal">typealias</code> for the function type as follows:</p><pre class="programlisting">typealias SimpleOperator = (Double, Double) -&gt; Double &#13;
</pre><p>We can use this <code class="literal">typealias</code> in the <code class="literal">simpleMathOperator</code> definition as follows:</p><pre class="programlisting">var simpleMathOperator: SimpleOperator &#13;
</pre><p>We can define functions with the same type and assign them to our <code class="literal">simpleMathOperator</code>. The type of functions in the following code snippet is <code class="literal">(Double, Double) -&gt; Double</code>, which is in fact <code class="literal">SimpleOperator</code>:</p><pre class="programlisting">func addTwoNumbers(a: Double, b: Double) -&gt; Double { return a + b } &#13;
 &#13;
func subtractTwoNumbers(a: Double, b: Double) -&gt; Double { return a - b } &#13;
 &#13;
func divideTwoNumbers(a: Double, b: Double) -&gt; Double { return a / b } &#13;
 &#13;
func multiplyTwoNumbers(a: Double, b: Double) -&gt; Double { return a * b } &#13;
</pre><p>Therefore, we are able to assign these functions to <code class="literal">simpleMathOperator</code> as follows:</p><pre class="programlisting">simpleMathOperator = multiplyTwoNumbers &#13;
</pre><p>This means that <code class="literal">simpleMathOperator</code> refers to the <code class="literal">multiplyTwoNumbers</code> function:</p><pre class="programlisting">let result = simpleMathOperator(3.0, 4.0) // result is 12&#13;
</pre><p>As the other three functions also have the same function type, we will be able to assign them to the same variable:</p><pre class="programlisting">simpleMathOperator = addTwoNumbers &#13;
let result = simpleMathOperator(3.5, 5.5) // result is 9 &#13;
</pre><p>We can use <code class="literal">SimpleOperator</code> as a parameter type of other functions:</p><pre class="programlisting">func calculateResult(mathOperator: SimpleOperator, a: Double, b: Double)&#13;
  -&gt; Double {&#13;
    return mathOperator(a, b)&#13;
}&#13;
&#13;
print("The result is \(calculateResult(mathOperator: simpleMathOperator,&#13;
  a: 3.5, b: 5.5))") // prints "The result is 9.0"</pre><p>Here, the <code class="literal">calculateResult</code> function has three parameters. The <code class="literal">mathOperator</code> parameter is a type of function type. The <code class="literal">a</code> and <code class="literal">b</code> parameters are <code class="literal">Double</code>. When we call this function, we pass a <code class="literal">simpleMathOperator</code> function and two <code class="literal">Double</code> values for <code class="literal">a</code> and <code class="literal">b</code>.</p><p>It is important to know that we pass only a reference to <code class="literal">simpleMathOperator</code> and this is not going to execute it. In the function body, we use this function and call it with <code class="literal">a</code> and <code class="literal">b</code>.</p><p>We can use <code class="literal">SimpleOperator</code> as a return type of a function:</p><pre class="programlisting">func choosePlusMinus(isPlus: Bool) -&gt; SimpleOperator {&#13;
    return isPlus ? addTwoNumbers : subtractTwoNumbers&#13;
}&#13;
&#13;
let chosenOperator = choosePlusMinus(isPlus: true)&#13;
print("The result is \(chosenOperator(3.5, 5.5))") // prints "The result&#13;
  is 9.0"</pre><p>Here, the <code class="literal">choosePlusMinus</code> function has a <code class="literal">Bool</code> parameter; in its body, it checks for this parameter and returns <code class="literal">addTwoNumbers</code> or <code class="literal">subtractTwoNumbers</code> that have the same type, <code class="literal">SimpleOperator</code>.</p><p>It is important to understand that calling <code class="literal">choosePlusMinus(true)</code> does not execute the returned function and in fact only returns the reference to <code class="literal">addTwoNumbers</code>. We save this reference in <code class="literal">chosenOperator</code>. The <code class="literal">chosenOperator</code> variable becomes the following:</p><pre class="programlisting">func addTwoNumbers(a: Double, b: Double) -&gt; Double { return a + b } &#13;
</pre><p>When we call <code class="literal">chosenOperator(3.5, 5.5)</code>, we pass these two numbers to the <code class="literal">addTwoNumbers</code> function and execute it.</p><p>The capability to define function types makes functions first-class citizens in Swift. Function types are used for first-class and higher-order functions. These capabilities empower us to apply functional programming paradigms in Swift.</p></div>
<div class="section" title="Defining and using nested functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Defining and using nested functions</h1></div></div></div><p>In Swift, it is possible to define functions inside other functions. In other words, we can nest functions inside other functions. Nested functions are only accessible inside their enclosing functions and are hidden from the outside world by default. The enclosing function can return the nested function in order to allow the nested function to be used in other scopes. The following example presents a function that contains two nested functions and returns one of them according to the value of its <code class="literal">isPlus</code> parameter:</p><pre class="programlisting">func choosePlusMinus(isPlus: Bool) -&gt; (Int, Int) -&gt; Int {&#13;
    func plus(a: Int, b: Int) -&gt; Int {&#13;
        return a + b&#13;
    }&#13;
    func minus(a: Int, b: Int) -&gt; Int {&#13;
        return a - b&#13;
    }&#13;
    return isPlus ? plus : minus&#13;
}&#13;
</pre></div>
<div class="section" title="First-class functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>First-class functions</h1></div></div></div><p>In the <span class="emphasis"><em>Function types</em></span> section of this chapter, we have seen that we can define function types and store and pass functions around. In practice, this means that Swift treats functions as values. To explain this, we will need to examine a couple of examples:</p><pre class="programlisting">let name: String = "Your name"&#13;
</pre><p>In this code example, we create a constant of the <code class="literal">String</code> type and <code class="literal">name</code> and store a value (<code class="literal">"Your name"</code>) in it.</p><p>When we define a function, we need to specify the type of parameters:</p><pre class="programlisting">func sayHello(name: String)&#13;
</pre><p>In this example, our <code class="literal">name</code> parameter is of the <code class="literal">String</code> type. This parameter could be any other value type or reference type. Simply, it could be <code class="literal">Int</code>, <code class="literal">Double</code>, <code class="literal">Dictionary</code>, <code class="literal">Array</code>, <code class="literal">Set</code>, or it could be an object type such as an instance of <code class="literal">class</code>, <code class="literal">struct</code>, or <code class="literal">enum</code>.</p><p>Now, let's call this function:</p><pre class="programlisting">sayHello(name: "Your name") // or&#13;
sayHello(name: name)&#13;
</pre><p>Here, we pass a value for this parameter. In other words, we pass one of the previously mentioned types with their respective values.</p><p>Swift treats functions like the other aforementioned types so we can store a function in a variable as we were able to with other types:</p><pre class="programlisting">var sayHelloFunc = sayHello&#13;
</pre><p>In this example, we saved the <code class="literal">sayHello</code> function in a variable that can be used later on and passed around as a value.</p><p>In pure OOP, we do not have functions; instead, we have methods. In other words, functions can only reside in objects and then they are called methods. In OOP, classes are first-class citizens and methods are not. Methods are not solely reachable and cannot be stored or passed around. In OOP, methods access the object's data that they are defined in.</p><p>In functional programming, functions are first-class citizens. Just like other types, they can be stored and passed around. In contrast to OOP, that method could only access their parent object's data and change it; in functional programming, they can be stored and passed to other objects.</p><p>This notion enables us to compose our applications with functions as they are just another type that can be used. We will talk about this in more detail; for now, it is important to understand why we call functions as first-class citizens in Swift.</p></div>
<div class="section" title="Higher-order functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Higher-order functions</h1></div></div></div><p>As we have seen in the <span class="emphasis"><em>Defining and using function parameters</em></span> and <span class="emphasis"><em>Function types</em></span> sections of this chapter, functions can accept functions as parameters in Swift. Functions that can accept other functions as parameters are called higher-order functions. This concept along with first-class functions empower functional programming and function decomposition.</p><p>As this topic is essential in functional programming, we will go through another simple example.</p><p>Suppose that we need to develop two functions that add and subtract two <code class="literal">Int</code> values as follows:</p><pre class="programlisting">func subtractTwoValues(a: Int, b: Int) -&gt; Int {&#13;
    return a - b&#13;
}&#13;
&#13;
func addTwoValues(a: Int, b: Int) -&gt; Int {&#13;
    return a + b&#13;
}&#13;
</pre><p>Also, we need to develop functions to calculate the square and triple of two <code class="literal">Int</code> values as follows:</p><pre class="programlisting">func square(a: Int) -&gt; Int {&#13;
    return a * a&#13;
}&#13;
&#13;
func triple(a: Int) -&gt; Int {&#13;
    return a * a * a // or return squareAValue(a) * a&#13;
}&#13;
</pre><p>Suppose we need another function that subtracts the squared two values:</p><pre class="programlisting">func subtractTwoSquaredValues(a: Int, b: Int) -&gt; Int {&#13;
    return (a * a) - (b * b)&#13;
}&#13;
</pre><p>Suppose we need to add two squared values:</p><pre class="programlisting">func addTwoSquaredValues(a: Int, b: Int) -&gt; Int {&#13;
    return (a * a) + (b * b)&#13;
}&#13;
</pre><p>Let's say that we need another function that triples a value and adds it to another tripled value:</p><pre class="programlisting">func multiplyTwoTripledValues(a: Int, b: Int) -&gt; Int {&#13;
    return (a * a * a) * (b * b * b)&#13;
}&#13;
</pre><p>This way, we had to write a lot of redundant and inflexible functions. Using higher-order functions, we could write a flexible function as follows:</p><pre class="programlisting">typealias AddSubtractOperator = (Int, Int) -&gt; Int&#13;
typealias SquareTripleOperator = (Int) -&gt; Int&#13;
func calcualte(a: Int, b: Int, funcA: AddSubtractOperator, funcB:&#13;
  SquareTripleOperator) -&gt; Int {&#13;
    return funcA(funcB(a), funcB(b))&#13;
}&#13;
</pre><p>This higher-order function takes two other functions as parameters and uses them. We can call it for different scenarios as follows:</p><pre class="programlisting">print("The result of adding two squared values is: \(calcualte(a: 2, b: 2,&#13;
  funcA: addTwoValues, funcB: square))") // prints "The result of adding&#13;
  two squared value is: 8"&#13;
&#13;
print("The result of subtracting two tripled value is: \(calcualte(a: 3,&#13;
  b: 2, funcA: subtractTwoValues, funcB: triple))") // prints "The result&#13;
  of adding two tripled value is: 19"</pre><p>This simple example presents the utility of higher-order functions in function composition and subsequently in program modularity.</p></div>
<div class="section" title="Function composition"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Function composition</h1></div></div></div><p>In the previous section, we have seen an example of higher-order functions that could accept two different functions and execute them in a predefined order. This function was not so flexible in the sense that it would break if we wanted to combine two accepted functions differently. Function composition can solve this issue and make it even more flexible. To present this concept, we will examine an example of non-functional composition first, and then we will be introduced to functional composition.</p><p>Suppose that, in our application, we need to interact with a backend RESTful API and receive a <code class="literal">String</code> value that contains a list of prices in order. The backend RESTful API is being developed by a third-party and is not designed properly. Unfortunately, it returns a <code class="literal">String</code> with numbers in it separated by commas:</p><pre class="programlisting">"10,20,40,30,80,60" &#13;
</pre><p>We need to format the content that we are receiving before using it. We will extract elements from <code class="literal">String</code> and create an array, and then we will append <code class="literal">$</code> as currency to each item to use it in a tableview. The following code example presents an approach to this problem:</p><pre class="programlisting">let content = "10,20,40,30,80,60"&#13;
&#13;
func extractElements(_ content: String) -&gt; [String] {&#13;
    return content.characters.split(separator: ",").map { String($0) }&#13;
}&#13;
&#13;
let elements = extractElements(content)&#13;
&#13;
func formatWithCurrency(content: [String]) -&gt; [String] {&#13;
    return content.map {"\($0)$"}&#13;
}&#13;
&#13;
let formattedElements = formatWithCurrency(content: elements)&#13;
</pre><p>In this code example, we treated each function individually. We could use the result of the first function as an input parameter for the second function. Either approach is verbose and not functional. Additionally, we use the <code class="literal">map</code> function, which is a higher-order function, but our approach is still not functional.</p><p>Let's approach this problem in a functional way.</p><p>The first step will be to identify function types for each function:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">extractElements</code>: <code class="literal">String -&gt; [String]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">formatWithCurrency</code>: <code class="literal">[String] -&gt; [String]</code></li></ul></div><p>If we pipe these functions, we will get the following:</p><pre class="programlisting">extractElements: String -&gt; [String] | formatWithCurrency: [String] &#13;
  -&gt; [String]</pre><p>We can combine these functions with a functional composition and the composed function will be of the <code class="literal">String -&gt; [String]</code> type. The following example shows the composition:</p><pre class="programlisting">let composedFunction = { data in&#13;
    formatWithCurrency(content: extractElements(data))&#13;
}&#13;
&#13;
composedFunction(content)&#13;
</pre><p>In this example, we define <code class="literal">composedFunction</code>, which is composed of two other functions. We are able to compose functions like this as each function has at least one parameter and return value. This composition is like the mathematical composition of functions. Suppose that we have a function <code class="literal">f(x)</code> that returns <code class="literal">y</code> and a <code class="literal">g(y)</code> function that returns <code class="literal">z</code>. We can compose the <code class="literal">g</code> function as <code class="literal">g(f(x)) -&gt; z</code>. This composition makes our <code class="literal">g</code> function take <code class="literal">x</code> as a parameter and return <code class="literal">z</code> as a result. This is exactly what we have done in our <code class="literal">composedFunction</code>.</p><div class="section" title="Custom operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Custom operators</h2></div></div></div><p>Although <code class="literal">composedFunction</code> is less verbose than the non-functional version, it does not look great. Also, it is not easy to read as we need to read it inside out. Let's make this function simpler and more readable. One solution will be to define a custom operator that will be used instead of our composed function. In the following sections, we will examine what are the standard operators that are allowed to define a custom operator. We will also explore the custom operator definition technique. It is important to learn this concept as we will be using it in the rest of the book.</p><div class="section" title="Allowed operators"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec46"/>Allowed operators</h3></div></div></div><p>The Swift standard library provides a number of operators that can be used to define custom operators. Custom operators can begin with one of the ASCII characters—<code class="literal">/</code>, <code class="literal">=</code>, <code class="literal">-</code>, <code class="literal">+</code>, <code class="literal">!</code>, <code class="literal">*</code>, <code class="literal">%</code>, <code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">^</code>, <code class="literal">?</code>, or <code class="literal">~</code> or one of the Unicode characters. After the first character, combining Unicode characters is allowed.</p><p>We can also define custom operators that begin with a dot. If an operator does not start with a dot, it cannot contain a dot elsewhere. Although we can define custom operators that contain a question mark <code class="literal">?</code>, they cannot consist of a single question mark character only. Additionally, although operators can contain an exclamation point <code class="literal">!</code>, postfix operators cannot begin with either a question mark or exclamation point.</p></div><div class="section" title="Custom operator definition"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec47"/>Custom operator definition</h3></div></div></div><p>We can define custom operators using the following syntax:</p><pre class="programlisting">operatorType operator operatorName { } &#13;
</pre><p>Here, <code class="literal">operatorType</code> can be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">prefix</li><li class="listitem" style="list-style-type: disc">infix</li><li class="listitem" style="list-style-type: disc">postfix</li></ul></div><p>Custom infix operators can also specify a precedence and an associativity:</p><pre class="programlisting">infix operator operatorName { associativity left/right/none &#13;
  precedence}</pre><p>The possible values for associativity are <code class="literal">left</code>, <code class="literal">right</code>, and <code class="literal">none</code>. Left-associative operators associate to the left if written next to other left-associative operators of the same precedence. Similarly, right-associative operators associate to the right if written next to other right-associative operators of the same precedence. Non-associative operators cannot be written next to other operators with the same precedence.</p><p>The associativity value defaults to <code class="literal">none</code> if it is not specified. The precedence value defaults to <code class="literal">100</code> if it is not specified.</p><p>Any custom operator defined with the preceding syntax will not have an existing meaning in Swift; therefore, a function with <code class="literal">operatorName</code> as its name should be defined and implemented. In the following section, we will examine an example of custom operator definition with its respective function definition.</p></div></div><div class="section" title="A composed function with a custom operator"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec12"/>A composed function with a custom operator</h2></div></div></div><p>Let's define a new custom operator to use instead of our composed function:</p><pre class="programlisting">infix operator |&gt; { associativity left }&#13;
func |&gt; &lt;T, V&gt;(f: T -&gt; V, g: V -&gt; V ) -&gt; T -&gt; V {&#13;
    return { x in g(f(x)) }&#13;
}&#13;
&#13;
let composedWithCustomOperator = extractElements |&gt; formatWithCurrency&#13;
composedWithCustomOperator("10,20,40,30,80,60")&#13;
</pre><p>In this example, we have defined a new operator, <code class="literal">|&gt;</code>, that takes two generic functions and combines them, returning a function that has the first function's input as the parameter and the second function's return as the return type.</p><p>As this new operator is going to combine two functions and is binary, we defined it as infix. Then we need to use the operator keyword. The next step will be to choose the notation for our new custom operator. As we will group functions to the left, we need to specify it as <span class="strong"><strong>associativity left</strong></span>.</p><p>To be able to use this operator, we need to define a corresponding function. Our function takes two functions as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">f</code>: This function takes a generic type of <code class="literal">T</code> and returns a generic type of <code class="literal">V</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">g</code>: This function takes a generic type of <code class="literal">V</code> and returns a generic type of <code class="literal">V</code></li></ul></div><p>In our example, we had the following functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">extractElements</code>: <code class="literal">String -&gt; [String]</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">formatWithCurrency</code>: <code class="literal">[String] -&gt; [String]</code></li></ul></div><p>So <code class="literal">T</code> becomes <code class="literal">String</code> and <code class="literal">V</code> becomes <code class="literal">[String]</code>.</p><p>Our <code class="literal">|&gt;</code> function returns a function that takes a generic type of <code class="literal">T</code> and returns a generic type of <code class="literal">V</code>. We need to receive <code class="literal">String -&gt; [String]</code> from the composed function so, again, <code class="literal">T</code> becomes <code class="literal">String</code> and <code class="literal">V</code> becomes <code class="literal">[String]</code>.</p><p>Using our <code class="literal">|&gt;</code> custom operator makes our code more readable and less verbose.</p></div></div>
<div class="section" title="Closures"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Closures</h1></div></div></div><p>Closures are functions without the <code class="literal">func</code> keyword. Closures are self-contained blocks of code that provide a specific functionality and can be stored, passed around, and used in the code like functions. Closures capture the constant and variables of the context in which they are defined. Although closures are equivalent of blocks in Objective-C, they have a simpler syntax in Swift compared to the C and Objective-C block syntax. Nested functions, which we have covered in a previous section, are special cases of closures. Closures are reference types that can be stored as variables, constants, and type aliases. They can be passed to and returned from functions.</p><div class="section" title="Closure syntax"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Closure syntax</h2></div></div></div><p>A general closure syntax is as follows:</p><pre class="programlisting">{ (parameters) -&gt; ReturnType in&#13;
    // body of closure&#13;
}&#13;
</pre><p>A closure definition starts with <code class="literal">{</code>, then we define the closure type, and finally we use the <code class="literal">in</code> keyword to separate the closure definition from its implementation.</p><p>After the <code class="literal">in</code> keyword, we write the body of the closure and finish our closure by closing <code class="literal">}</code>.</p><p>Closures can be used to define variables. The following closure defines a variable of a type closure that accepts <code class="literal">Int</code> and returns <code class="literal">Int</code>:</p><pre class="programlisting">let closureName: (Int) -&gt; (Int) = {/* */ }&#13;
</pre><p>Closures can be stored as optional variables. The following closure defines a variable of a type closure that accepts <code class="literal">Int</code> and returns <code class="literal">Optional Int</code>:</p><pre class="programlisting">var closureName: (Int) -&gt; (Int)?&#13;
</pre><p>Closures can be defined as <code class="literal">typealiases</code>. The following example presents <code class="literal">typealias</code> of a closure that has two <code class="literal">Int</code> parameters and returns<code class="literal">Int</code>:</p><pre class="programlisting">typealias closureType = (Int, Int) -&gt; (Int)&#13;
</pre><p>The same <code class="literal">typealias</code> could be used for a function type definition as functions are named closures in Swift.</p><p>Closures can be used as an argument to a function call. For instance, the following example presents a function that is called with a closure that receives <code class="literal">Int</code> and returns <code class="literal">Int</code>:</p><pre class="programlisting">func aFunc(closure: (Int) -&gt; Int) -&gt; Int {&#13;
    // Statements, for example:&#13;
    return closure(5)&#13;
}&#13;
&#13;
let result = aFunc(closure: { number in&#13;
    // Statements, for example:&#13;
    return number * 3&#13;
})&#13;
&#13;
print(result)&#13;
</pre><p>Closures can be used as function parameters. The following example shows an array sort method that receives a closure:</p><pre class="programlisting">var anArray = [1, 2, 5, 3, 6, 4]&#13;
&#13;
anArray.sort(isOrderedBefore: { (param1: Int, param2: Int) -&gt; Bool in&#13;
    return param1 &lt; param2&#13;
})&#13;
</pre><p>This syntax can be simplified with implied types as the Swift compiler has the ability to infer the types for parameters from the context:</p><pre class="programlisting">anArray.sort(isOrderedBefore: { (param1, param2) -&gt; Bool in&#13;
    return param1 &lt; param2&#13;
})&#13;
</pre><p>The syntax can be further simplified with implied return types using the Swift type inference:</p><pre class="programlisting">anArray.sort(isOrderedBefore: { (param1, param2) in&#13;
    return param1 &lt; param2&#13;
})&#13;
</pre><p>Swift enables us to eliminate the open and close parentheses if we need to pass the closure as the last parameter of a function, in other words, if our closure is a trailing closure:</p><pre class="programlisting">anArray.sort { (param1, param2) in&#13;
    return param1 &lt; param2&#13;
}&#13;
</pre><p>Also, Swift provides a shorthand argument notation that can be used instead of using arguments:</p><pre class="programlisting">anArray.sort {&#13;
    return $0 &lt; $1&#13;
}&#13;
</pre><p>We can simplify this syntax even further by eliminating the <code class="literal">return</code> keyword as we have only one line of expression as follows:</p><pre class="programlisting">anArray.sort {  0 &lt; $1 }&#13;
</pre><p>Using the Swift type inference, we were able to simplify the closure syntax drastically.</p></div><div class="section" title="Capturing values"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Capturing values</h2></div></div></div><p>Closures can capture variables and constants from the surrounding context in which they are created. Closures can refer to these variables and modify them within their body, even if the original scope that defined variables no longer exists.</p><p>A closure is said to escape a function when the closure is passed as an argument to the function but is called after the function returns. One way that a closure can escape is by being stored in a variable that is defined outside the function.</p><p>The following is an example of escaping closures, in other words, completion handlers:</p><pre class="programlisting">func sendRequest(responseType: String.Type, completion:&#13;
  (responseData:String, error:NSError?) -&gt; Void) {&#13;
    // execute some time consuming operation, if successful {&#13;
        completion(responseData: "Response", error: nil)&#13;
    //}&#13;
}&#13;
&#13;
sendRequest(String.self) {&#13;
    (response: String?, error: NSError?) in&#13;
    if let result = response {&#13;
        print(result)&#13;
    } else if let serverError = error {&#13;
        // Error&#13;
    }&#13;
}&#13;
</pre><p>We have a function named <code class="literal">sendRequest</code> that have two parameters—<code class="literal">responseType</code> of the <code class="literal">String.Type</code> type and <code class="literal">completion</code> which is type of closure that takes a <code class="literal">String</code>, and an optional <code class="literal">NSError</code> parameters and does not return any value.</p><p>Suppose that we execute some asynchronous time-consuming operations in the body of the function, such as reading from a file, reading from a database, or calling a web service.</p><p>To call this function, we provide <code class="literal">String.self</code> and a closure as arguments. Our closure has two variables in it—a variable named <code class="literal">response</code> of the <code class="literal">Optional String</code> type and an error variable of the <code class="literal">NSError</code> optional type. As our function does not have any return type, it does not return any value to its caller. Here comes the concept of escaping a function.</p><p>Our passed closure escapes our function as it will be called after our time-consuming asynchronous operation finishes with success and the following call happens:</p><pre class="programlisting">completion(responseData: "Response", error: nil)&#13;
</pre><p>In this call, we pass the <code class="literal">responseData</code> and error and call back the completion closure. Then the body of closure in the caller function is executed with passed variables. This concept is a very powerful concept that eases all asynchronous operations. It is very readable and easy to follow compared with mechanisms such as delegation and notification.</p></div></div>
<div class="section" title="Function currying"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Function currying</h1></div></div></div><p>Function currying translates a single function with multiple arguments into a series of functions each with one argument. Let's examine an example. Suppose that we have a function that combines <code class="literal">firstName</code> and <code class="literal">lastName</code> to return the full name:</p><pre class="programlisting">func extractFullUserName(firstName: String, lastName: String) -&gt; String {&#13;
    return "\(firstName) \(lastName)"&#13;
}&#13;
</pre><p>This function can be translated into a curried function as follows:</p><pre class="programlisting">func curriedExtractFullUserName(firstName: String)(lastName:&#13;
  String) -&gt; String {&#13;
    return "\(firstName) \(lastName)"&#13;
}&#13;
</pre><p>As seen from this example, we replace the comma with <code class="literal">) (</code> parentheses.</p><p>So now we can use this function as follows:</p><pre class="programlisting">let fnIncludingFirstName = curriedExtractFullUserName("John")&#13;
let extractedFullName = fnIncludingFirstName(lastName: "Doe")&#13;
</pre><p>Here, <code class="literal">fnIncludingFirstName</code> will have <code class="literal">firstName</code> in it so that, when we use it, we can provide <code class="literal">lastName</code> and extract the full name. We will use this technique in upcoming chapters.</p><p>Starting with Swift 2.2, Apple has deprecated function currying and removed it from Swift 3.0. It is proposed to convert the function currying to returning a closure explicitly:</p><pre class="programlisting">// Before:&#13;
func curried(x: Int)(y: String) -&gt; Float {&#13;
    return Float(x) + Float(y)!&#13;
}&#13;
&#13;
// Swift 3.0 syntax:&#13;
func curried(x: Int) -&gt; (String) -&gt; Float {&#13;
    return {(y: String) -&gt; Float in&#13;
        return Float(x) + Float(y)!&#13;
    }&#13;
}&#13;
</pre><p>Let's convert our curried function to return the closure version explicitly:</p><pre class="programlisting">func explicityRetunClosure(firstName: String) -&gt; (String) -&gt; String {&#13;
    return { (lastName: String) -&gt; String in&#13;
        return "\(firstName) \(lastName)"&#13;
    }&#13;
}&#13;
</pre><p>We can use this function as follows and the result is going to be identical:</p><pre class="programlisting">let fnIncludingFirstName = explicityRetunClosure(firstName: "John")&#13;
let extractedFullName = fnIncludingFirstName("Doe")</pre></div>
<div class="section" title="Recursion"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Recursion</h1></div></div></div><p>Recursion is the process of calling a function inside itself. The function that calls itself is a recursive function.</p><p>Recursion is best used for problems where a large problem can be broken down into a repetitive subproblem. As a recursive function calls itself to solve these subproblems, eventually the function will come across a subproblem that it can handle without calling itself. This is known as a base case, and it is needed to prevent the function from calling itself over and over again without stopping.</p><p>In the base case, the function does not call itself. However, when a function does have to call itself in order to deal with its subproblem, then this is known as a recursive case. So, there are two types of cases when using a recursive algorithm: base cases and recursive cases. It is important to remember that when using recursion and when we are trying to solve a problem, we should ask ourselves: <span class="emphasis"><em>what is my base case and what is my recursive case?</em></span>
</p><p>To apply this simple process, let's start with an example of recursion: the factorial function. In mathematics, an exclamation mark after a number (<span class="emphasis"><em>n!</em></span>) presents the factorial of the number. A factorial of a number <code class="literal">n</code> is the product of all integers between <code class="literal">1</code> and <code class="literal">n</code>. So, if <code class="literal">n</code> is equal to <code class="literal">3</code>, then the factorial of <code class="literal">n</code> would be <span class="emphasis"><em>3 * 2 * 1</em></span>, which equals <code class="literal">6</code>. We could also say that the factorial of <code class="literal">3</code> is equal to <code class="literal">3</code> multiplied by the factorial of <code class="literal">2</code>, which would be <span class="emphasis"><em>3 * 2!</em></span> or <span class="emphasis"><em>3 * 2 * 1</em></span>. So, the factorial of any number <code class="literal">n</code> could also be defined as follows:</p><pre class="programlisting">n! = n * (n - 1)!&#13;
</pre><p>We also need to know the following:</p><pre class="programlisting">0! = 1! = 1&#13;
</pre><p>Note how we defined the factorial of a number as that number multiplied by the factorial of the integer that is <code class="literal">1</code> less than the number <span class="emphasis"><em>(n * (n - 1)!)</em></span>. So, what we have done is essentially broken the problem into a subproblem and, in order to find the factorial of a number, we keep finding the factorials of the integers below that number and multiplying. So, the factorial of <code class="literal">3</code> is equal to <code class="literal">3</code> multiplied by the factorial of <code class="literal">2</code> and the factorial of <code class="literal">2</code> is equal to <code class="literal">2</code> multiplied by the factorial of <code class="literal">1</code>. So, if we have a function to find the factorial of a given number, then our code for the recursive case would look something like this:</p><pre class="programlisting">func factorial(n: Int) -&gt; Int {&#13;
    return n * factorial(n: n - 1)&#13;
}&#13;
</pre><p>Here, we want to find <code class="literal">n</code> number's factorial.</p><p>In this example, we divided the problem into a subproblem. There is still one problem that we need to solve. We need to check for the base case in order to be able to stop the function from calling itself infinitely.</p><p>Therefore, we can modify our factorial example as follows:</p><pre class="programlisting">func factorial(n: Int) -&gt; Int {&#13;
    return n == 0 || n == 1 ? 1 : n * factorial(n: n - 1)&#13;
}&#13;
&#13;
print(factorial(n: 3))&#13;
</pre><p>As seen in this example, we check for <code class="literal">n</code>; if it is 0 or <code class="literal">1</code>, we return <code class="literal">1</code> and stop the recursion.</p><p>Another example of a simple recursive function is as follows:</p><pre class="programlisting">func powerOfTwo(n: Int) -&gt; Int {&#13;
    return n == 0 ? 1 : 2 * powerOfTwo(n: n - 1)&#13;
}&#13;
&#13;
let fnResult = powerOfTwo(n: 3)&#13;
</pre><p>The non-recursive version of this example is as follows:</p><pre class="programlisting">func power2(n: Int) -&gt; Int {&#13;
    var y = 1&#13;
    for _ in 0...n - 1 {&#13;
        y *= 2&#13;
    }&#13;
    return y&#13;
}&#13;
&#13;
let result = power2(n: 4)&#13;
</pre><p>As we can see from this example, the recursive version is more expressive and shorter.</p><p>The following example presents a function that repeats a given string for a desired time:</p><pre class="programlisting">func repateString(str: String, n: Int) -&gt; String {&#13;
    return n == 0 ? "" : str + repateString(str: str , n: n - 1)&#13;
}&#13;
&#13;
print(repateString(str: "Hello", n: 4))&#13;
</pre><p>The following code snippet presents the same functionality without using recursion, in other words, in the imperative programming style:</p><pre class="programlisting">func repeatString(str: String, n: Int) -&gt; String {&#13;
    var ourString = ""&#13;
    for _ in 1...n {&#13;
        ourString += str&#13;
    }&#13;
    return ourString&#13;
}&#13;
&#13;
print(repeatString(str: "Hello", n: 4))&#13;
</pre><p>The non-recursive, imperative version is slightly longer and we need to use a <code class="literal">for</code> loop and variable to be able to achieve the same result. Some functional programming languages such as Haskell do not have <code class="literal">for</code> loop mechanisms and we have to use recursion; in Swift, we have <code class="literal">for</code> loops but as we have seen here, it is better to use recursive functions whenever we can.</p><div class="section" title="Tail recursion"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Tail recursion</h2></div></div></div><p>Tail recursion is a special case of recursion where the calling function does no more execution after making a recursive call to itself. In other words, a function is named tail recursive if its final expression is a recursive call. The previous recursion examples that we have been introduced to were not tail recursive functions.</p><p>To be able to understand tail recursion, we will develop the <code class="literal">factorial</code> function that we have developed before with the tail recursion technique. Then we will talk about the differences:</p><pre class="programlisting">func factorial(n: Int, currentFactorial: Int = 1) -&gt; Int {&#13;
    return n == 0 ? currentFactorial : factorial(n: n - 1,&#13;
      currentFactorial: currentFactorial * n)&#13;
}&#13;
&#13;
print(factorial(n: 3))&#13;
</pre><p>Note that we provide a default argument of <code class="literal">1</code> for <code class="literal">currentFactorial</code>, but this only applies to the very first call of the function. When the factorial function is called recursively, the default argument is overridden with whatever value is passed by the recursive call. We need to have that second argument there because it will hold the current factorial value that we intend on passing to the function.</p><p>Let's try to understand how it works and how it is different from the other factorial function:</p><pre class="programlisting">factorial(n: 3, currentFactorial: 1)&#13;
return factorial(n: 2, currentFactorial: 1 * 3) // n = 3&#13;
return factorial(n: 1, currentFactorial: 3 * 2) // n = 2&#13;
return 6 // n = 1&#13;
</pre><p>In this function, each time the factorial function is called, a new value for <code class="literal">currentFactorial</code> is passed to the function. The function basically updates <code class="literal">currentFactorial</code> with each call to itself. We are able to save the current factorial value as it accepts <code class="literal">currentFactorial</code> as a parameter.</p><p>All of the recursive calls to the factorial such as <code class="literal">factorial(2, 1 * 3)</code> do not actually need to return in order to get the final value. We can see that we actually arrive at the value of <code class="literal">6</code> before any of the recursive calls actually return.</p><p>Therefore, a function is tail recursive if the final result of the recursive call—in this example, <code class="literal">6</code>—is also the final result of the function itself. The non-tail recursive function is not in its final state in the last function call because all of the recursive calls leading up to the last function call must also return in order to actually come up with the final result.</p></div></div>
<div class="section" title="Memoization"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Memoization</h1></div></div></div><p>Memoization is the process of storing the result of functions, given their input, in order to improve the performance of our programs. We can memoize pure functions as pure functions do not rely on external data and do not change anything outside themselves. Pure functions provide the same result for a given input every time. Therefore, we can save or cache the results—in other words, memoize the results—given their inputs and use them in the future without going through the calculation process.</p><p>To be able to understand the concept, let's look at the following example in which we will manually memoize the <code class="literal">power2</code> function:</p><pre class="programlisting">var memo = Dictionary&lt;Int, Int&gt;()&#13;
&#13;
func memoizedPower2(n: Int) -&gt; Int {&#13;
    if let memoizedResult = memo[n] {&#13;
        return memoizedResult&#13;
    }&#13;
    var y = 1&#13;
    for _ in 0...n-1 {&#13;
        y *= 2&#13;
    }&#13;
    memo[n] = y&#13;
    return y&#13;
}&#13;
print(memoizedPower2(n: 2))&#13;
print(memoizedPower2(n: 3))&#13;
print(memoizedPower2(n: 4))&#13;
print(memo) // result: [2: 4, 3: 8, 4: 16]&#13;
</pre><p>As we can see from the example, we define a dictionary of the <code class="literal">[Int, Int]</code> type. We save the result of the function given its input to this dictionary.</p><p>This approach works properly but we need to manually modify and maintain a collection outside of the function to be able to memoize the results of the function. Also, it adds a lot of boilerplate code to each function that we need memoization for.</p><p>The advanced Swift session presented in <span class="strong"><strong>Worldwide Developers Conference</strong></span> (<span class="strong"><strong>WWDC</strong></span>) 2014 (
<a class="ulink" href="https://developer.apple.com/videos/play/wwdc2014-404/">https://developer.apple.com/videos/play/wwdc2014-404/</a>) provides a very convenient function for memoization that can be used with any pure function.</p><p>Watching the video is highly recommended. Let's see if we could automatize this functionality and reuse it using the <code class="literal">memoize</code> function from that session:</p><pre class="programlisting">func memoize&lt;T: Hashable, U&gt;(fn: ((T) -&gt; U, T) -&gt; U) -&gt; (T) -&gt; U {&#13;
    var memo = Dictionary&lt;T, U&gt;()&#13;
    var result: ((T) -&gt; U)!&#13;
    result = { x in&#13;
        if let q = memo[x] { return q }&#13;
        let r = fn(result, x)&#13;
        memo[x] = r&#13;
        return r&#13;
    }&#13;
    return result&#13;
}&#13;
</pre><p>The function looks complex but don't worry, we will go through it in detail.</p><p>First of all, it is a generic function. Do not worry about generics—we will cover generics in detail in <a class="link" href="ch05.html" title="Chapter 5. Generics and Associated Type Protocols">Chapter 5</a>, <span class="emphasis"><em>Generics and Associated Type Protocols</em></span>—and <code class="literal">Hashable</code> is used because we need to store <code class="literal">T</code> as a key in a dictionary.</p><p>If we look at the signature of the function, we see that the <code class="literal">memoize</code> function takes a function (<code class="literal">fn</code>) with two parameters and a return type. So the signature of <code class="literal">fn</code>, which is a function, is as follows:</p><pre class="programlisting">((T) -&gt; U, T) -&gt; U&#13;
</pre><p>The first parameter of <code class="literal">fn</code> is a function of the <code class="literal">(T) -&gt; U</code> type and the second parameter is of the <code class="literal">T</code> type and finally <code class="literal">fn</code> returns <code class="literal">U</code>.</p><p>OK, the <code class="literal">memoize</code> function received <code class="literal">fn</code>, which is described in the preceding code snippet.</p><p>At the end, the <code class="literal">memoize</code> function returns a function of the <code class="literal">(T) -&gt; U</code> type.
Now let's look at the body of the <code class="literal">memoize</code> function. First, we need to have a dictionary to cache the results. Second, we need to define the result type, which is a closure. In the closure body, we check whether we already have the key in our dictionary. If we do, we return it, otherwise, we call the function and save the result in our memo dictionary.</p><p>Now we can use this function to memoize the results of different function calls and improve the performance of our programs.</p><p>The following example presents the memoized version of the factorial function:</p><pre class="programlisting">let factorial = memoize { factorial, x in&#13;
    x == 0 ? 1 : x * factorial(x - 1)&#13;
}&#13;
&#13;
print(factorial(5))&#13;
</pre><p>The <code class="literal">memoize</code> function expects a closure as input, therefore, we can use the trailing closure syntax. In the preceding example, we provided the factorial function and <code class="literal">x</code> parameters as input to the closure and the line after the <code class="literal">in</code> keyword is the body of the closure. In the previous example, we used memoize for a recursive function and it works properly. Let's look at another example:</p><pre class="programlisting">let powerOf2 = memoize { pow2, x in&#13;
    x == 0 ? 1 : 2 * pow2(x - 1)&#13;
}&#13;
&#13;
print(powerOf2(5))&#13;
</pre><p>In this example, we use the <code class="literal">memoize</code> function to have a memoized version of the <code class="literal">powerOf2</code> function.</p><p>Writing the memoize function once, we will be able to use it for any pure functions to cache the data and improve the performance of our programs.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec26"/>Summary</h1></div></div></div><p>This chapter started by explaining function definition and usage in detail by giving examples for parameter and return types. Then it continued to cover functional programming-related concepts such as pure, first-class, higher-order, and nested functions. Finally, it covered function compositions, closures, currying, and memoization. At this point, we should be familiar with different types of functions and closures and their usages.</p><p>In the following chapter, we will cover types and explore the concept of value types versus reference types. Also, we will look at value type characteristics in detail and cover type equality, identity, and casting.</p></div></body></html>