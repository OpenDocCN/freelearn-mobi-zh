- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Your App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is a very important aspect of developing apps. It helps us identify
    and fix bugs in our code. It is a very important skill to have as a developer.
    It also helps us avoid bugs in the future. Many tools can help us debug our code.
    In this chapter, we will be looking at some of the tools that can help us debug
    our code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn debugging tips and tricks, how to detect leaks
    using LeakCanary, how to inspect network requests/responses fired by our app using
    Chucker, and how to inspect our Room database, network requests, and background
    tasks using App Inspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: General debugging tips and tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting leaks with LeakCanary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting network requests with Chucker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using App Inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterten).
  prefs: []
  type: TYPE_NORMAL
- en: General debugging tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Studio provides us with a variety of features that help us debug our
    code. Some of the features are listed in the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logcat**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stack Traces**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Breakpoints**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us look at each of these closely.
  prefs: []
  type: TYPE_NORMAL
- en: Logcat
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logcat in Android Studio displays log messages in real-time from our apps.
    Each log message has a priority level attached to it. We add log messages in our
    app using the `Log` class. This class offers different priority levels that we
    can use to log messages. The different priority levels are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**V**: Verbose (lowest priority)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D**: Debug'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I**: Info'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**W**: Warning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**E**: Error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**F**: Fatal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S**: Silent (highest priority)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the preceding letters to specify the log level. For example, if we want
    to log a message with the debug level, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is the tag. The tag is used to identify the source of a
    log message. The second parameter is the message that we want to log. Each time
    we run our app, Logcat shows up at the bottom of the Android Studio window, as
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Logcat](img/B19779_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Logcat
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding figure, we can see at the top that the Logcat window shows
    the device we are running our app on. In this case, we are running our app on
    a **Pixel 6 Pro API 33** emulator; yours can be different depending on the emulator
    you have installed. Next to the device, we can see the **package** of the app
    we are running. This has a search bar that allows us to search for specific logs
    with their tags. Below the search are the actual logs. We can see that each log
    has a tag, the priority level, the package name of the app, the time the log was
    created, and the message. We can also see that the logs are color-coded. To see
    all the color settings for our Logcat, we go to **Settings** | **Editor** | **Color
    Scheme** | **Android Logcat**, which shows the color settings as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Logcat color settings](img/B19779_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Logcat color settings
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can set a color scheme for our Logcat. In the preceding figure,
    the color scheme has been set to **Classic Light**. There is a list that shows
    the colors for each log level, and you can change the color for each log level.
    We can also change the font style and size for our Logcat.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, let us see how to create our first Logcat message. Let us head over
    to the `MainActivity.kt` file and add a log message in the `onCreate()` method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the app and add `First Log` as a search query in the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Logcat search](img/B19779_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Logcat search
  prefs: []
  type: TYPE_NORMAL
- en: This only shows the log message that has the tag **First Log**. This is particularly
    useful when we have a lot of logs, and we want to search for a specific log.
  prefs: []
  type: TYPE_NORMAL
- en: Stack traces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **stack trace** is a list of method calls from the point where the app was
    started to the point where the exception was thrown. It is extremely useful in
    helping us identify the cause of an exception. Stack traces are normally displayed
    in Logcat.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to see our first stack trace, let us head over to the `MainActivity.kt`
    file and add the following code in the `onCreate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will cause the app to crash when you run it. The app crashes
    immediately after executing the preceding code, and by checking our Logcat, we
    should be able to see the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Crash stack trace](img/B19779_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Crash stack trace
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, the stack trace shows the exception or reason
    for the crash. Additionally, it shows the class and method where the exception
    was thrown. It also shows the line number where the exception was thrown. This
    is particularly useful in helping us identify the cause of the exception. We can
    click on the line number directly and it will take us to the line of code where
    the exception was thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The stack trace is a crucial tool in helping us debug our code and quickly detect
    crashes and the cause of crashes. Before moving on, remember to remove the code
    that throws the exception so that we can continue with the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio allows us to copy and paste stack traces from a different source
    and see them in our Logcat. Copy the following stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you are done copying the stack trace, head over to the **Code** tab at
    the top of Android Studio and select **Analyze Stack Trace or Thread Dump**, paste
    the stack trace, and you will see the following dialog with the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Analyze stack trace](img/B19779_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Analyze stack trace
  prefs: []
  type: TYPE_NORMAL
- en: This shows the preview of the stack trace we just pasted. Clicking on **OK**
    takes us to Logcat and shows us the stack trace as in *Figure 10**.4*
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use **breakpoints** to debug code for our apps. A breakpoint is a point
    in our code where we want the debugger to pause the execution of our code. This
    is useful when we are trying to find bugs that only appear under certain conditions.
    Android Studio allows us to add breakpoints to our code. We can add breakpoints
    to our code by clicking on the left side of the line number as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Breakpoint](img/B19779_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 10**.6*, a red circle is displayed when we add a breakpoint.
    To be able to see how the breakpoint works, we need to run the app in **debug
    mode**. We can do this by clicking on the **Debug** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Debug app](img/B19779_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Debug app
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the breakpoint is on the `onCreate()` method, the debugger will pause
    the execution of our code at the breakpoint. Android Studio will highlight the
    line where the breakpoint is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Line breakpoint](img/B19779_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Line breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'It also shows a **Debug** window at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Debug window](img/B19779_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Debug window
  prefs: []
  type: TYPE_NORMAL
- en: The **Debug** window shows us the variables that are in the scope of the breakpoint.
    We can also see the call stack, which shows us the methods that have been called
    before the breakpoint. We can also see the threads that are running in our app.
    We can also see the breakpoints that we have added to our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Debug** window has some buttons at the top that are immensely helpful
    in debugging our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Debug window buttons](img/B19779_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Debug window buttons
  prefs: []
  type: TYPE_NORMAL
- en: 'The buttons are as highlighted in *Figure 10**.10*. Starting from the left
    to right, the buttons are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Show execution point**: This button shows the line of code where the debugger
    is paused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Over**: This button allows us to execute the current line of code and
    move to the next line of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Into**: This button allows us to step into a method call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step Out**: This button allows us to step out of a method call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run to Cursor**: This button allows us to run the code until the cursor reaches
    the line of code where the cursor is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the left of the **Debug** window, we can also see the **Play** and **Stop**
    buttons. The **Play** button allows us to resume the execution of our code and
    continue the debugging session until the next breakpoint or until the program
    completes execution. To learn more about breakpoints, visit the official documentation
    at [https://developer.android.com/studio/debug](https://developer.android.com/studio/debug).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the different debugging options available
    in Android Studio. We learned about Logcat, stack traces, and breakpoints. We
    have also learned how to use these tools to debug our code. In the next section,
    we will learn about a different debugging tool, LeakCanary, and how to use it
    to detect memory leaks in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting memory leaks with LeakCanary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LeakCanary** is an open-source library developed by Square that helps us
    detect memory leaks in our apps. The library has knowledge of the internals of
    the Android Framework that allows it to narrow down the cause of the memory leak.
    It helps reduce the **Application Not Responding** (**ANR**) errors and **out-of-memory
    crashes** in our apps. Here are some of the most common causes of memory leaks:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing instances of **Activity** as **Context** filed in an object that survives
    activity recreation due to configuration changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forgetting to unregister broadcast receivers, listeners, callbacks, or RxJava
    subscriptions when they are no longer needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing references to **Context** in a background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LeakCanary is quite easy to set up and no code implementation is needed to
    use it. We just need to add the `leakcanary-android` dependency in our `libs.version.toml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Tap the `build.gradle.kts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added the dependency using the `debugImplementation` configuration
    so that it is only added to debug builds. This is because LeakCanary is only used
    for debugging purposes. We can now run our app and see how LeakCanary works. A
    separate app will be installed on our device or emulator as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Leaks app](img/B19779_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Leaks app
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the app brings up the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – LeakCanary screen](img/B19779_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – LeakCanary screen
  prefs: []
  type: TYPE_NORMAL
- en: The screen shows the **Leaks**, **Heap Dumps**, and **About** tabs. The **Leaks**
    tab shows us the memory leaks that have been detected in our app. The **Heap Dumps**
    tab shows us the heap dumps that have been taken. The **About** tab shows us the
    version of LeakCanary we are using as well as general information. For now, there
    is no memory leak detected. When a memory leak is detected, LeakCanary will generate
    a notification or log output with detailed information about the memory leak.
    This information helps us identify the cause of the memory leak and fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now create a memory leak in our app and see how LeakCanary works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the **com.packt.chapterten** package and call it **LeakCanaryTest.kt**.
    Add the following code to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we have created a class called `LeakCanaryTest` and another
    class called `LeakTestUtils`, with a companion object that stores the `LeakCanaryTest`
    singleton in a static field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us now head over to the **MainActivity.kt** file and add the following
    code in the **onCreate()** code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we are telling LeakCanary that the singleton instance
    of `LeakCanaryTest` will be garbage collected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let us run the app. We can see that LeakCanary has detected a memory leak and
    shows a notification as seen in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Memory leak notification](img/B19779_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Memory leak notification
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the notification and it will take us to the LeakCanary app where we
    can see the details of the memory leak:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Memory leak details](img/B19779_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Memory leak details
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, LeakCanary shows the location of the memory
    leak and underlines the objects causing the leak. In this case, it is the `leakCanaryTest`
    object that is causing the memory leak. Every time we get a memory leak, we will
    receive such detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to remove the code that causes the memory leak in the `MainActivity`
    `onCreate()` method so that we can continue with the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about LeakCanary and how to use it to detect memory leaks in
    our apps. You can learn more about LeakCanary at [https://square.github.io/leakcanary/](https://square.github.io/leakcanary/).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about Chucker, another debugging tool that
    helps us inspect network requests in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting network requests with Chucker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is from the Chucker GitHub ([https://github.com/ChuckerTeam/chucker](https://github.com/ChuckerTeam/chucker))
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: Chucker simplifies the inspection of HTTP(S) requests/responses fired by our
    Android apps. Chucker works as an OkHttp Interceptor persisting all those events
    inside our application, and providing a UI for inspecting and sharing their content.
    Chucker displays a notification showing a summary of the ongoing network request.
  prefs: []
  type: TYPE_NORMAL
- en: Tapping the Chucker notification mentioned previously launches the Chucker UI.
    Chucker UI shows a list of all the network requests that have been made by our
    app. We can tap on a request to see the details of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Chucker, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the **chucker** dependency in the **libs.versions.toml** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we have added two dependencies: the first one is the
    Chucker library, and the second one is a no-op library variant to isolate Chucker
    from release builds since we only want to see the requests on debug builds.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tap the **Sync Now** button at the top to sync the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to add the dependency in our app’s **build.gradle.kts** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tap **Sync Now** at the top. This will add the Chucker dependency in debug builds
    only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to create a new **OkHttp** client and add the Chucker interceptor
    to it. Let us head over to the **Modules.kt** file and add the following module
    to the **appModules** module block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following explains the preceding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have created a `OkHttpClient` instance to make network requests.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us modify our **Retrofit** instance to use the **OkHttpClient** instance
    we just created. Still in the **Modules.kt** file, modify the Retrofit instance
    as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We have added the `client` parameter and passed it in the `OkHttpClient` instance
    we created previously using Koin’s `get()` call.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, our Chucker setup is now complete.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build and run the app. We can see that Chucker has detected the network request
    and shows a notification, as seen in the following figure:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Chucker notification](img/B19779_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Chucker notification
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding figure, we can see that Chucker has detected the network
    request and shows the status code, the method, and the URL of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can tap on the notification and it will take us to the Chucker UI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Chucker list of requests](img/B19779_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Chucker list of requests
  prefs: []
  type: TYPE_NORMAL
- en: This shows the list of the network requests that have been made by our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tap on a request to see the details of the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Chucker overview tab](img/B19779_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Chucker overview tab
  prefs: []
  type: TYPE_NORMAL
- en: 'The details screen has three tabs as shown in the preceding figure. The first
    tab is the **Overview** tab, which is shown in *Figure 10**.17*. The **Overview**
    tab shows the overview of the request. It shows the request details such as URL,
    method, response, duration, response size, and so on. The second tab is the **Request**
    tab, which shows the request headers and body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – Chucker request tab](img/B19779_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – Chucker request tab
  prefs: []
  type: TYPE_NORMAL
- en: 'For this request, the body is empty since it was a get request. The third tab
    is the **Response** tab, which shows the response headers and body:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Chucker response tab](img/B19779_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.19 – Chucker response tab
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding figure, we can see the response headers and body in JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: The toolbar of the details screen has **Search**, **Share**, and **Save** buttons.
    The **Search** button allows us to search in either the request or the response.
    The **Share** button allows us to share the request or response details in JSON
    format. The **Save** button allows us to save the request or response details
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Chucker is very helpful in debugging network requests in our apps. When non-technical
    teams test the debuggable version of our app, we can always tell them to share
    these requests, especially when they’re facing issues with their network requests.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for Chucker. Every time our app makes a network request, Chucker will
    show a notification and we can tap on the notification to see the details of the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about Chucker and how to use it to inspect network requests
    in our apps. In the next section, we will learn how to use App Inspection to inspect
    our app’s room database and explore the features App Inspection offers.
  prefs: []
  type: TYPE_NORMAL
- en: Using App Inspection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**App Inspection** allows us to debug our database, inspect network traffic,
    and debug our background tasks. It is a very important tool in helping us debug
    our apps. To use App Inspection, let us run our app and then navigate to **View**
    | **Tool Windows** | **App Inspection** in Android Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – App Inspection](img/B19779_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.20 – App Inspection
  prefs: []
  type: TYPE_NORMAL
- en: 'App Inspection automatically connects to our app. The first tab is **Database
    Inspector**. On the left, we can see the different databases created by our app.
    We have the WorkManager, Chucker, LeakCanary, and Cat databases that we created
    earlier on. Let us click on the **Cat** database, and we can see the columns of
    the table that we created in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.21 – Cat database](img/B19779_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.21 – Cat database
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows the columns and the values that have been saved in the database.
    We can also run queries in the database. The query option is highlighted in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.22 – Execute query button](img/B19779_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.22 – Execute query button
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to run a query that shows the cats with a specific `id`. We can do
    this by running the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a different `id` per the data you have. The query results will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Query results](img/B19779_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.23 – Query results
  prefs: []
  type: TYPE_NORMAL
- en: The data has all the cats that have the ID we specified. One thing to note is
    to ensure that you execute the queries on the correct database, as shown in *Figure
    10**.23*. The database inspector helps us debug and write queries to our database
    and is very useful when working on apps that use a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now head over to the **Network Inspector** tab. This tab shows us the
    network requests that have been made by our app. We can see the request method,
    the URL, the status code, and the duration of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Network Inspector](img/B19779_10_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Network Inspector
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding figure, we can see that the requests are for loading the
    cute cat images and all the details of the request. Similar to Chucker, it also
    has the request and response tabs that provide more information on the request.
    However, unlike Chucker, **Network Inspector** captures the network requests made
    by the app without any additional setup in the code. The **Network Inspector**
    tab is very useful in helping us debug network requests in our apps, especially
    when working on apps that make a lot of network requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let us head over to the **Background Task Inspector** tab. This tab
    shows us the background task requests that have been made by our app. Our app
    should show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.25 – Background Task Inspector](img/B19779_10_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – Background Task Inspector
  prefs: []
  type: TYPE_NORMAL
- en: The Background Task Inspector shows us the details of our background tasks.
    It has information for WorkManager `PetsSyncWorker` worker has succeeded. On the
    right are more details of the worker, as shown in *Figure 10**.25*. The details
    show the UUID, constraints, state, and results of the worker, such as the output
    data, number of retries, and the time it started. This information is very helpful
    to check whether our background tasks are running as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some debugging tips and tricks, how to detect leaks
    using LeakCanary, how to inspect network requests/responses fired by our app using
    Chucker, and how to use App Inspection to debug our database, inspect our network
    requests, and inspect background tasks, too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn Kotlin style and the best practices for writing
    Kotlin code. We will also learn how to use plugins such as Ktlint and Detekt to
    format, lint, and detect the code smells early.
  prefs: []
  type: TYPE_NORMAL
