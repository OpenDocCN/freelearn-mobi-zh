- en: Polishing Your Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application polish is one of the more subtle areas of the user experience. The
    mix of colors, fonts, and animations are generally not something that users register
    on a conscious level, but this doesn't mean they're not important. While the choice
    of colors doesn't directly affect the application's functionality, it does affect
    the usability of the application. These choices can also be the difference between
    a user completing a sale through your application, or the same user uninstalling
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android has a massive array of tools that you can use to polish your application.
    Applying branding, colors, and extensive theming to your application can be done
    in ways that allow you to maintain a distinct look and feel, while still following
    Material Design guidelines and without building any custom widgets. In fact, most
    graphical effects for widgets on Android can be achieved purely through styling.
    In this chapter, we''ll explore the given topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to choose and apply colors to an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and when to generate color palettes dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and applying animations, and when to do so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and using custom styles for widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing colors and theming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Colors are one of the least understood and most important aspects of your user
    interface design. Text colors must stand out from the background colors to keep
    text legible, but not too much either. Color choices should follow a palette throughout
    the application and should reflect the application's branding, but should also
    help convey meaning to the user. Choosing the right mix of colors will maximize
    the usability of your application, while helping reduce the user's cognitive load.
    The wrong color combinations will make text more difficult to read, cause eye
    strain, and increase the user's levels of cognitive fatigue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you apply custom colors to your application, it''s important to ensure
    that you don''t have too many colors, and that they are applied consistently within
    the application. Color conveys meaning; it can be used to tell the user that the
    *new* button is the opposite of the *delete* button. These styles should be defined
    as resources and applied consistently throughout your application. Consistent
    styling helps the user understand each screen in the application more quickly,
    by telling them what they are looking at. Typically, style information is defined
    in the `res/values/styles.xml` file of your project. This is an excellent starting
    point in our exploration of colors and in polishing your application. If you open
    the `res/values/styles.xml` file of the travel claim example app, you''ll see
    something like this near the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines a style named `AppTheme`, which is applied to your entire application
    from the `AndroidManifest.xml` file. The style declares that its parent is the
    `Theme.AppCompat.Light.DarkActionBar` style, which is imported from the `app-compat`
    library (in your `build.gradle` dependencies). The parent of the style is a bit
    like the parent of a class; it defines all the defaults, and you can override
    them in the child style. In the default `AppTheme` style, there are three colors
    that are overridden with references to color resources: primary, primary-dark,
    and accent. These colors are used all over the `AppTheme` for the backgrounds
    of the `Toolbar` objects, buttons, floating action buttons, and so on. Primary
    is used for the background of a `Toolbar` and `FloatingActionButton` by default,
    primary-dark is used for the status bar background, and accent is used for the
    foreground of `FloatingActionButton` and the labels above the `TextInputLayout`
    widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: Producing an application palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do when applying colors to your application is to decide
    on your application color scheme, or palette. A **palette** is a small group of
    colors that form the basis of your theme, and can be adjusted (typically by making
    them brighter or darker) to produce a wide range of colors that will all look
    similar enough to be seen as part of the same theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s best to use a good color designing or palette construction tool. An excellent
    one is **Paletton**, which is available at [http://paletton.com](http://paletton.com)
    for free (another good tool is [https://www.materialpalette.com/](https://www.materialpalette.com/)).
    For this section, we''ll use Paletton to define a basic color palette for the
    travel claims application example; let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [http://paletton.com](http://paletton.com) in your web browser of
    choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two major parts to the Paletton application; on the left is a color-wheel
    with draggable handles that allow you to select a primary color (the secondary
    colors are derived automatically using various available algorithms). On the right
    of the application is the palette sample for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b03c436e-1179-4ad0-900d-fc3266da5c06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Use the **Scheme Type** selector to choose the second type of color scheme:
    Adjacent colors (3-colors).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the right of the Scheme Type selector, use the small toggle button to turn
    on add complementary. This will add a complimentary color to your palette. A complementary
    color will be on the opposite side of the color-wheel to your main color, and
    will serve as *accent* color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adjust the base color and shades until the palette preview on the right is
    a combination you are happy with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68b3551e-2b20-4aba-ad28-2c111f4b3128.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By clicking on any of the boxes in the palette preview and then their hex codes,
    you can copy the RGB hex code to the clipboard and paste it into Android Studio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c73fd892-7a74-49f8-884e-8612b571ec9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Ensure that you use colors from the top-left box for your primary and primaryDark
    colors, while you use a color from the bottom-right box for the accent color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Android Studio, use Tools | Android | Theme Editor to open the Android Theme
    Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Theme panel on the right-hand side, you''ll find a list of colors that
    define your theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fde5ec77-f9fd-41bd-b1bc-1218e3a69c74.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the color buttons in the Theme Editor to open a color editor. Copy
    the colors from Paletton into the theme editor for primary, primary-dark, and
    accent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the travel claim example application now, you'll see that the entire
    application has a completely new theme. The floating action button will be the
    same color as the underline on the `EditText` widget. This will be your accent
    color, while the background of your `Toolbar` will be your primary color.
  prefs: []
  type: TYPE_NORMAL
- en: It' generally best to use your primary color's complementary color as your accent
    color. This is the color that is on the opposite side of color wheel, and will
    normally have an excellent contrast against your primary color. The contrast will
    help readability and reduce eye strain. It's important to ensure legibility for
    everyone, and Paletton includes a Vision simulation option below the palette preview
    that can be used to test your palette for various types of colorblindness.
  prefs: []
  type: TYPE_NORMAL
- en: Generating palettes dynamically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when you're not sure what your palette should be ahead of time.
    There are also times that you would like the color scheme to match some user content,
    such as a photo or the album art for the music they're listening to. In cases
    like these, it's nice to be able to grab the key colors from an image and produce
    a palette that will match them. The problem is that the palette still needs to
    not be too jarring, and your text still needs to be legible against the background
    color. These are pretty hard problems to solve in pure code, but Android support
    libraries have an excellent little tool that does exactly this--the `Palette`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very useful way of using generated palettes is to colorize cards with different
    icons according to the colors in the icon. Let''s write a `CardView` implementation
    that can colorize its contents according to a generated palette:'
  prefs: []
  type: TYPE_NORMAL
- en: You'll first need to add the `Palette` API to your project. In the travel claim
    app, open the app module's `build.gradle` file in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `dependencies` at the bottom of the file, include the `Palette` API
    by declaring this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Click on the Sync Now link that appears at the top of the editor panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the widget's package and select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `ColorizedCardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Superclass` to `android.support.v7.widget.CardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `android.support.v7.graphics.Palette.PaletteAsyncListener` to the Interface(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the required `View` constructors so that the class can be used from XML
    files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ColorizedCardView` doesn''t just change its own background, it needs to
    change the color of any text as well so that the text remains legible to the user.
    This means that the `ColorizedCardView` needs to find all the `TextView` instances
    that don''t have their background `Drawable` set (a `Button` is just a `TextView`
    with a specialized background, and we want to leave that as is). This method will
    traverse (depth-first) into the `ColorizedCardView`, and add any `TextView` objects
    it finds to a `Collection`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Each `Palette` is actually a list of `Swatch` objects, each one containing
    a base color and colors suitable for heading text and body text. The `ColorizedCardView`
    allows you to specify a `Swatch` directly to colorize the background and all the
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When a `Palette` is generated, it can have any number of `Swatch` objects.
    There are a selection of *standard* swatches that are normally generated when
    you create a `Palette` from a `Bitmap`, but any number of them may remain unpopulated
    (`null`). When you colorize the card by a `Palette` object, you''ll need to look
    for an available `Swatch`; in the `ColorizedCardView` implementation. We''ll favor
    *light* swatches over *dark* swatches, and *muted* swatches over *vibrant*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You may need to adjust the ordering of this method in your application, depending
    on the colors chosen for the rest of the application. Typically, muted colors
    cause less eye strain for your users, but you may want to colorize action buttons
    using vibrant colors to draw attention to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a way to specify a `Bitmap` to colorize the entire `ColorizedCardView`
    with. The `Palette` uses a `Builder` object to generate its swatches, and has
    its own built-in `AsyncTask` to handle generating the `Palette` on a background
    thread (which can take a few seconds on larger images or slower devices). The
    `setColorizeBitmap` method is defined so that it''s easy to invoke from a data-bound
    layout XML file. The `Palette.Builder` needs a callback to handle the generated
    `Palette`, which will be the `ColorizedCardView` instance (remember that you''ve
    implemented the `PaletteAsyncListener` interface):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need a way to colorize the `ColorizedCardView` based on a `Drawable`
    object, which will offer better interoperability with application `Resources`.
    The following `renderDrawable` method has a shortcut if the `Drawable` object
    is a `BitmapDrawable` (which simply wraps a `Bitmap`); otherwise, it''ll try and
    render the `Drawable` to a `Bitmap` object. As a `Drawable` has bounds that include
    its position (and not just its size), you''ll need to translate the `Canvas` that
    it''s going to draw on so that it renders in the top-left corner of the `Bitmap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To use the `ColorizedCardView` in the travel claim application, you can find
    and download colored icons for all the categories and change the `ItemPresenter`
    to use them, instead of the standard black icons we imported from the Material
    Icons set. An excellent resource for finding icons and sets of icons is Iconfinder--[https://www.iconfinder.com/](https://www.iconfinder.com/).
    Iconfinder allows you to search for and filter icon sets according to your criteria,
    and purchase or download the icons you need for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the overview screen to use your favorite colorful icons, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Place your new icons in the `res/drawable` directory of your application; ensure
    that you download PNG icons so that they can be read by Android.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `card_claim_item` layout resource in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the declaration of the `CardView` to a `ColorizedCardView`, and use
    the `app:colorizeDrawable` data binding attribute to invoke `setColorizeDrawable`
    with the same `Drawable` that will be rendered as the icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Open the `ItemPresenter` Java source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the icons returned by the `getCategoryIcon` method to return your new
    icons, instead of those used by the category selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The icon names used earlier are just an example; you'll need to use the names
    of the icon files you downloaded and placed in the `drawable` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorizedCardView` is a very useful and generic implementation of colorization
    using the `Palette` class. Using the bold background colors on each card makes
    them quickly recognizable to the user, and allows the user to more quickly find
    what they are looking for in a long scrolling list of items. As it can be automatically
    colorized using data binding, the `ColorizedCardView` can be populated with virtually
    any content.
  prefs: []
  type: TYPE_NORMAL
- en: Adding animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animations may appear to just be a nice bit of polishing on top of your user
    interface, but they can also serve an important purpose. In any design, whether
    it's a building, an API, or a user interface, it's good to try and follow a principle
    of *least surprise*. Try and offer your user things that make sense without them
    having to try and understand the details of how it works. A good example of violating
    this principle is when a button is wired incorrectly. If you were to press the
    *copy* button on a printer, and instead of making a copy it printed a test page,
    this would be a surprise. You expected the machine to do one thing because of
    the label, but it did something unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: It's always important to consider what your user will expect to happen when
    they look at or use your application's user interface. Using well-known names
    and icons for the elements of a user interface help make it instantly understood
    by your user, but sometimes your application will change what is on the screen
    without being entirely obvious as to *what has changed*. In cases like this, animations
    become essential to tell users what has happened. A good example of using animation
    to express a change is the automatic animations you added to the `RecyclerView`
    using the `DiffUtil` class. When the user adds a new claim item, it appears in
    the list at the correct position, but an animation will draw the user's attention
    to where it has appeared and let them know that it's the new item.
  prefs: []
  type: TYPE_NORMAL
- en: Animations have to strike a careful balance. However, if everything is animated,
    then the user can become frustrated by the extra time being taken by the animations.
    This leads to another important factor--animations should be quick. The Android
    platform defines a *short* animation as just *200 milliseconds*, just one-fifth
    of a second.
  prefs: []
  type: TYPE_NORMAL
- en: You've already added implicit animations to the travel claim application using
    the `RecyclerView` and `DiffUtil`. **Implicit animations** are all over in the
    Android platform and cover a wide range of everyday cases, such as the changes
    in the `RecyclerView` contents. There are also ways to add your own animations
    to layouts and widgets, and there are several widgets that are specifically designed
    to render animations and transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Within layout animations, there are four basic actions that an animation can
    perform on a widget or group of widgets that are being animated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A widget can be translated, which involves moving it left or right, up or down
    (or any combination of those), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e38a3010-0b55-4013-a1fa-795839b533d4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An animation can also scale a widget. This involves changing its size to make
    it appear larger or smaller. Scaling, like translation, can be applied on either
    the horizontal (x) axis, or the vertical (y) axis, or both of them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/677c2a6b-0de2-4107-9d22-82dbfa5fc502.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also have an animation rotate the widget. Rotation is not a natural
    change for a user interface widget, as typically, all widgets are layouts out
    of a box-like grid. Rotation can be very useful, and can produce a pleasing effect
    when applied to widgets that appear to be round (such as a `FloatingActionButton`
    or a circular avatar):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc54fe9b-5e44-42dd-ad28-70ee671ad406.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While all the first three transformations are concerned with the physical structure
    of the widget being animated, the fourth one changes how opaque it is. The alpha
    transformation allows you to produce animations where widgets appear to fade-in
    or fade-out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11c9b8a9-cbf7-4e62-920c-d0fd3d27305b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These four animation actions can be combined into what Android calls a **set**.
    A *set* is a group of animation actions that will all appear to happen at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android animations are in fact resource files, much like an icon or a layout.
    The animations that apply to layouts and widgets are XML files that define the
    various transformations and are placed in the `res/anim` directory. Android provides
    a small selection of simple animations that you can use in your application, without
    needing to build your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.R.anim.fade_in` - `@android:anim/fade_in`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.R.anim.fade_out` - `@android:anim/fade_out`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.R.anim.slide_in_left` - `@android:anim/slide_in_left`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.R.anim.slide_out_right` - `@android:anim/slide_out_right`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These four animations cover two different types of transition: fading out and
    in, or sliding the widgets from left to right. Nothing stops you from mixing them
    together, for example, fading the widget out and then sliding a new one in from
    the left.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do these sorts of transitions, there are a family of Android widgets that
    will manage the animation for you. These can either focus on animating the content
    (that is, text or an image), or they transition through a list of child widgets.
    The base of these classes is `android.widget.ViewAnimator`, and the best-known
    implementations are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TextSwitcher`: Behaves like an animated `TextView`; each time its text is
    changed, it animates between the old text and the new text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageSwitcher`: Just like `TextSwitcher`, but for images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewFlipper`: It is used like a `FrameLayout`, but only one of its children
    is shown at a time, and you can have it animate between them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create two new animation sets to animate some text, and change the category
    label in the `CategoryPickerFragment` to use a `TextSwitcher`:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the res directory in the travel claim example app and select
    New | Android resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `slide_in_top`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the Resource type to Animation (not Animator):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63c504aa-d97f-49d2-82ca-4005d9a06fd3.png)'
  prefs: []
  type: TYPE_IMG
- en: An `Animator` allows the direct manipulation of any property in any Java Object;
    while this is a very powerful system to use, it does not work with classes such
    as `TextSwitcher`. `Animation` refers to the *view animation* system, which is
    designed specifically for animating widgets, and has various performance enhancements
    in the layout system to avoid the user interface stuttering during animations.
  prefs: []
  type: TYPE_NORMAL
- en: Click OK to create the new animation XML resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the `<set>` element, we need to define how long the animation will take,
    and the interpolator. The **interpolator** defines the relative motion of the
    animation. Does it happen with linear smoothness (which often appears artificial,
    but is the easiest), or does the animation appear to *bounce*, or something else
    entirely? In this case, we will use the standard `anticipate_overshoot_interpolator`,
    which includes a small *bounce* effect at the end of the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This animation will consist of two parts. The first part is a translation from
    offscreen, downward to where the text should normally appear. The second part
    is a fade in from fully transparent to opaque. Each action taken by a view animation
    is defined in terms of what the value should be when the animation starts, and
    what the value should be when it stops (from and to). The values in between are
    defined by the time of each frame, and the interpolator. Inside the `<set>` element,
    add a `translation` to bring the view along the y-axis from above where it ends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the fade-in using an `alpha` action. A zero alpha value indicates
    that the widget should be invisible, while a one indicates that it should be fully
    opaque. The alpha is a floating-point number, so you can define any value between
    zero and one for partial transparency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While a single animation is nice, you need two animations running together to
    create a *transition*. Right-click on the new `res/anim` directory and select
    New| Animation resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new animation `slide_out_bottom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This animation works the same way as `slide_in_top`, but pushes the view downward
    and makes it transparent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll need to change the `CategoryPickerFragment` to use a `TextSwitcher`
    instead of a `TextView`. Start by opening the `fragment_category_picker` layout
    resource file and change to the Text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the `TextView` at the bottom of the file, and change it to be a `TextSwitcher`.
    A `TextSwitcher` needs two `TextView` child elements to animate between. Each
    time you change the text on the `TextSwitcher`, it puts the new text on the invisible
    `TextView` and then animates between the visible `TextView` and the invisible
    one (that is, it switches them around and hence its name). You''ll need to tell
    the `TextSwitcher` to use the animation resources you just created as its *in*
    and *out* animations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `CategoryPickerFragment` source file and change the references to
    the `TextView` to a `TextSwitcher`. There will be one as a field, and the other
    should be in the `onCreateView` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `IconPickerWrapper` source file. This currently wraps a `TextView`,
    but will now need to wrap a `TextSwitcher`. Like the `CategoryPickerFragment`,
    change the references from `TextView` to `TextSwitcher`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all you need to do in this case; the `CaptureClaimActivity` will now
    have a very pleasing animation on the text in the category chooser, which indicates
    that the icons are used to change the category. While a `TextSwitcher` doesn''t
    subclass `TextView`, it does expose the same critical method for these cases--`setText(CharSequence)`.
    Unfortunately, this means that you can''t substitute the classes directly one
    for the other. Instead, you''ll need to treat each as a separate type (as earlier).
    You can, however, create `abstract` `wrapper` class to wrap these two and allow
    your layout to define whether there should be animations or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This class can be used to wrap references to widgets that can be either `TextView`
    or `TextSwitcher`, depending on the context. This allows you to reuse more of
    your Java code when dealing with cases where some screens require a simple layout,
    while others require animations. It's generally a useful pattern to remember,
    because it reduces the coupling between your user interface and your code when
    you can't use the class inheritance, and want to avoid casting.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding can also be used to solve this problem. By having the `CategoryPickerFragment`,
    use a data-bound layout; the `TextSwitcher` will automatically animate when the
    model was changed by the user clicking on the `RadioButton` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Activating more animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are some other small ways in which Android can provide your application
    with animations that let the user know what is going on. For example, you can
    tell any `ViewGroup` implementation (any of the `Layout` classes: `FrameLayout`,
    `LinearLayout`, or `ConstraintLayout`) to animate the changes to the layout. You
    do this by simply turning on `animateLayoutChanges` in your layout resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is especially useful when you offer the ability to *unfold* a card to
    expose more functionality or more information. Coupling the `animateLayoutChanges`
    attribute with the `ViewGroup` class is a very powerful combination. `ViewStub`
    is a special type of widget that can be used like an `<include>`, that only loads
    when you tell it to. When it''s loaded, it doesn''t act as a container, but *replaces
    itself* with the layout it has loaded. Using `animateLayoutChanges` inflating
    a `ViewStub` can automatically trigger a nice animation to reveal the new content
    to the user. The following code snippet is a `CardView` that will animate the
    inflation of a menu that can be made to appear at the bottom of the card:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When you inflate the preceding `ViewStub`, it will replace itself with the
    contents of the `card_menu` layout resource, and the `ConstraintLayout` will animate
    the change, making the `card_menu` appear to unfold. You can use the following
    code snippet to inflate the `ViewStub` when the `CardView` is tapped on by the
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a single-use `OnClickListener` that removes itself when
    it's been triggered. This is important because once a `ViewStub` has been inflated,
    it no longer exists in the layout. After the preceding listener is triggered,
    `findViewById(R.id.menu)` will return the root element of the `card_menu` layout
    resource, not the `ViewStub`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When polishing your application, you'll find that certain styling requirements
    become common over the entire application, but in specific places. For example,
    the *positive* / *go* buttons should have a specific background color that highlights
    them from the other buttons in the application, or that the *negative* / *delete*
    buttons should have a color that highlights them as destructive for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android offers you the ability to define your own styles apart from those defined
    by the system. The theming system in Android is built entirely on top of the styling
    system. Styles have some very simple attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Styles can be named
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A style can change any attribute exposed in the layout XML file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A style can inherit from another style and override its attributes (a bit like
    classes extending each other)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles are defined as value resources (a bit like dimensions, strings, and colors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s jump right in and create a new style for the travel claim application
    for the amount-input; we want to create a style that can be reused whenever the
    user needs to type a monetary amount into the application:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `styles.xml` resource file in the res/values project folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll note in this file that you already have several styles defined by the
    Android Studio templates. These are mostly theme-related styles, and will apply
    to the entire application. We want to define a new style that can be applied to
    specific widgets. Declare a new style element named `AmountInput`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we want this style to do is to align the text to the right
    of the input box. This is normally done by changing the `android:gravity` attribute
    on the `EditText` box. In the `style` element, you need to declare this as an
    `item` you wish to override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You also want to change the focus behavior so that when the user taps to edit
    the amount, the existing value is selected. This allows them to more easily enter
    a new number, which is more common than wanting to edit an existing number. The
    `TextView` class defines an attribute named `selectAllOnFocus` that is perfect
    for this purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To apply the style to the amount input, open the `fragment_claim_capture_details.xml`
    layout resource in Text mode (this is from the Try it Yourself section of [Chapter
    4](1799a69f-adfc-4439-883c-f2db5e4ad199.xhtml), *Composing User Interfaces*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `EditText` entry for the amount, and apply the style. It''s important
    to note that the style attribute is not in the android XML namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the application or change to the Design view, you''ll find that
    the amount field is now right aligned, and if you tap on it, the entire content
    will be selected. This style can now be applied to any number of fields in your
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e2c39fb-ce32-40d0-abe7-66c1f8b19350.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Styles themselves can be overridden at each layer. When you inherit from another
    style, the child can override any of its parent items. When a widget has a style
    applied, any attributes specified on the widget''s XML element take precedence
    over the style being applied. For example, if you wanted to create an `AmountInput`
    styled widget that left aligned its text content (instead of the style''s right
    alignment), you might use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although it's not commonly done, you can also use styles to apply attributes,
    such as labels and hints, to widgets. This allows for two screens to easily replicate
    a widget exactly, without requiring an `include`. Any time you find that your
    layout code appears to repeat itself, consider using a style if an include doesn't
    look suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When choosing a color scheme, it's important that the accent color has which
    of these features?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is the same hue as the primary color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is complementary to the primary color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not black and not white
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically generating a palette should meet which of these conditions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be used in preference to defining the color scheme up front
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be done on a background thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should only be used in media applications
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Which of these is to be kept in mind while animating layouts in your application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They should not block or distract the user from achieving their goals
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They should be done whenever the user interface changes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They should be kept as simple as possible to conserve battery
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom styles can be used to define which of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Common groups of attributes for widgets based on their class
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Common groups of attributes to be applied through the `style` attribute
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values for any attribute in a layout resource file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polishing an application (much like optimizing an application) shouldn't be
    taken on too early in its development, as it can distract getting the application
    working and making the user experience smooth. It is, however, a vital part of
    an application's development, and the careful application of colors, fonts, and
    animations can sometimes be the difference between success and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Using color tools such as Paletton make the selection of a color-scheme much
    easier. It's important to also consider how color-blind people will see your application,
    and to ensure that the application is still usable by this sizeable portion of
    the population. If you know someone who has any form of color blindness, ask them
    to help test your choice in colors. Alternatively, use the color blindness simulations
    that palette design tools such as Paletton provide.
  prefs: []
  type: TYPE_NORMAL
- en: When adding animations to the application, it's a good idea to leverage the
    default animation systems provided by the platform. Avoid adding animations to
    widgets that don't already provide some form of animation capability. If you find
    yourself animating things by hand, there is probably something wrong. Try and
    stick to using the animations built into classes like `RecyclerView` and `ViewPager`,
    while using animating widgets such as `TextSwitcher` where appropriate. It's also
    important to keep animations short. While you might think your animation looks
    lovely, your users will become frustrated if they slow down the use of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways in which your application can be
    styled to fit a color-scheme, and polished with animations and styles for certain
    components. In the next chapter, we'll look at how to create your own completely
    customized widget classes and how to repurpose the existing widget classes for
    new or specialized use cases.
  prefs: []
  type: TYPE_NORMAL
