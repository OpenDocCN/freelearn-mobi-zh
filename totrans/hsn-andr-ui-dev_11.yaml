- en: Polishing Your Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精炼你的设计
- en: Application polish is one of the more subtle areas of the user experience. The
    mix of colors, fonts, and animations are generally not something that users register
    on a conscious level, but this doesn't mean they're not important. While the choice
    of colors doesn't directly affect the application's functionality, it does affect
    the usability of the application. These choices can also be the difference between
    a user completing a sale through your application, or the same user uninstalling
    it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的精炼是用户体验中较为微妙的一个领域。颜色、字体和动画的混合通常不是用户在意识层面上注意到的事情，但这并不意味着它们不重要。虽然颜色的选择不会直接影响应用程序的功能，但它确实会影响应用程序的可用性。这些选择也可能是用户通过你的应用程序完成交易，或者卸载它的区别。
- en: 'Android has a massive array of tools that you can use to polish your application.
    Applying branding, colors, and extensive theming to your application can be done
    in ways that allow you to maintain a distinct look and feel, while still following
    Material Design guidelines and without building any custom widgets. In fact, most
    graphical effects for widgets on Android can be achieved purely through styling.
    In this chapter, we''ll explore the given topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了一整套工具，你可以使用这些工具来完善你的应用程序。将品牌、颜色和广泛的主题应用到你的应用程序中，可以以允许你保持独特的外观和感觉的方式完成，同时仍然遵循Material
    Design指南，而不需要构建任何自定义小部件。实际上，Android上大多数小部件的图形效果都可以通过样式来实现。在本章中，我们将探讨以下主题：
- en: How to choose and apply colors to an application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何选择和应用颜色到应用程序中
- en: How and when to generate color palettes dynamically
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何和何时动态生成调色板
- en: Creating and applying animations, and when to do so
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和应用动画，以及何时应用
- en: Defining and using custom styles for widgets
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和使用小部件的自定义样式
- en: Choosing colors and theming
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择颜色和主题
- en: Colors are one of the least understood and most important aspects of your user
    interface design. Text colors must stand out from the background colors to keep
    text legible, but not too much either. Color choices should follow a palette throughout
    the application and should reflect the application's branding, but should also
    help convey meaning to the user. Choosing the right mix of colors will maximize
    the usability of your application, while helping reduce the user's cognitive load.
    The wrong color combinations will make text more difficult to read, cause eye
    strain, and increase the user's levels of cognitive fatigue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色是用户界面设计中最不被理解但最重要的方面之一。文本颜色必须从背景颜色中脱颖而出，以便保持文本可读性，但又不过分突出。颜色选择应贯穿整个应用程序的调色板，并反映应用程序的品牌，但同时也应帮助向用户传达意义。选择正确的颜色组合将最大化应用程序的可用性，同时帮助减少用户的认知负荷。错误的颜色组合会使文本更难阅读，导致眼睛疲劳，并增加用户的认知疲劳程度。
- en: 'When you apply custom colors to your application, it''s important to ensure
    that you don''t have too many colors, and that they are applied consistently within
    the application. Color conveys meaning; it can be used to tell the user that the
    *new* button is the opposite of the *delete* button. These styles should be defined
    as resources and applied consistently throughout your application. Consistent
    styling helps the user understand each screen in the application more quickly,
    by telling them what they are looking at. Typically, style information is defined
    in the `res/values/styles.xml` file of your project. This is an excellent starting
    point in our exploration of colors and in polishing your application. If you open
    the `res/values/styles.xml` file of the travel claim example app, you''ll see
    something like this near the top of the file:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为你的应用程序应用自定义颜色时，确保你不会使用太多颜色，并且它们在应用程序中应用是一致的。颜色传达意义；它可以用来告诉用户*新*按钮与*删除*按钮是相反的。这些样式应该定义为资源，并在整个应用程序中一致应用。一致的样式有助于用户更快地理解应用程序中的每个屏幕，通过告诉他们他们在看什么。通常，样式信息定义在你的项目`res/values/styles.xml`文件中。这是我们探索颜色并完善应用程序的一个很好的起点。如果你打开旅行索赔示例应用程序的`res/values/styles.xml`文件，你会在文件顶部附近看到类似以下内容：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This defines a style named `AppTheme`, which is applied to your entire application
    from the `AndroidManifest.xml` file. The style declares that its parent is the
    `Theme.AppCompat.Light.DarkActionBar` style, which is imported from the `app-compat`
    library (in your `build.gradle` dependencies). The parent of the style is a bit
    like the parent of a class; it defines all the defaults, and you can override
    them in the child style. In the default `AppTheme` style, there are three colors
    that are overridden with references to color resources: primary, primary-dark,
    and accent. These colors are used all over the `AppTheme` for the backgrounds
    of the `Toolbar` objects, buttons, floating action buttons, and so on. Primary
    is used for the background of a `Toolbar` and `FloatingActionButton` by default,
    primary-dark is used for the status bar background, and accent is used for the
    foreground of `FloatingActionButton` and the labels above the `TextInputLayout`
    widgets.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个名为 `AppTheme` 的样式，该样式从 `AndroidManifest.xml` 文件应用到你的整个应用程序。该样式声明其父样式为
    `Theme.AppCompat.Light.DarkActionBar`，该样式是从 `app-compat` 库（在你的 `build.gradle`
    依赖项中）导入的。样式的父级有点像类的父级；它定义了所有默认值，你可以在子样式中覆盖它们。在默认的 `AppTheme` 样式中，有三个颜色通过颜色资源引用进行了覆盖：主色、主深色和强调色。这些颜色被用于
    `AppTheme` 的 `Toolbar` 对象的背景、按钮、浮动操作按钮等。默认情况下，主色用于 `Toolbar` 和 `FloatingActionButton`
    的背景，主深色用于状态栏背景，强调色用于 `FloatingActionButton` 的前景和 `TextInputLayout` 小部件上方的标签。
- en: Producing an application palette
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成应用程序调色板
- en: The first thing to do when applying colors to your application is to decide
    on your application color scheme, or palette. A **palette** is a small group of
    colors that form the basis of your theme, and can be adjusted (typically by making
    them brighter or darker) to produce a wide range of colors that will all look
    similar enough to be seen as part of the same theme.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在将颜色应用到你的应用程序时，首先要做的是决定你的应用程序颜色方案或调色板。**调色板**是一组小的颜色，构成了你主题的基础，并且可以通过调整（通常是通过使它们更亮或更暗）来产生一系列看起来足够相似的颜色，这些颜色可以被视为同一主题的一部分。
- en: 'It''s best to use a good color designing or palette construction tool. An excellent
    one is **Paletton**, which is available at [http://paletton.com](http://paletton.com)
    for free (another good tool is [https://www.materialpalette.com/](https://www.materialpalette.com/)).
    For this section, we''ll use Paletton to define a basic color palette for the
    travel claims application example; let''s get started:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用一个好的颜色设计或调色板构建工具。一个出色的工具是 **Paletton**，它可以在 [http://paletton.com](http://paletton.com)
    上免费使用（另一个好工具是 [https://www.materialpalette.com/](https://www.materialpalette.com/)）。对于本节，我们将使用
    Paletton 为旅行索赔应用程序示例定义一个基本的调色板；让我们开始吧：
- en: Navigate to [http://paletton.com](http://paletton.com) in your web browser of
    choice.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你选择的网页浏览器中导航到 [http://paletton.com](http://paletton.com)。
- en: 'There are two major parts to the Paletton application; on the left is a color-wheel
    with draggable handles that allow you to select a primary color (the secondary
    colors are derived automatically using various available algorithms). On the right
    of the application is the palette sample for the application:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Paletton 应用程序有两个主要部分；在左侧是一个带有可拖动手柄的颜色轮，允许你选择主色（辅助色会自动使用各种可用的算法推导出来）。在应用程序的右侧是应用程序的调色板样本：
- en: '![](img/b03c436e-1179-4ad0-900d-fc3266da5c06.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b03c436e-1179-4ad0-900d-fc3266da5c06.png)'
- en: 'Use the **Scheme Type** selector to choose the second type of color scheme:
    Adjacent colors (3-colors).'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **方案类型** 选择器选择第二种颜色方案：相邻颜色（3种颜色）。
- en: To the right of the Scheme Type selector, use the small toggle button to turn
    on add complementary. This will add a complimentary color to your palette. A complementary
    color will be on the opposite side of the color-wheel to your main color, and
    will serve as *accent* color.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方案类型选择器的右侧，使用小切换按钮打开添加互补色。这将向你的调色板添加一个互补色。互补色将位于颜色轮上与主色相对的位置，并作为 *强调色*。
- en: 'Adjust the base color and shades until the palette preview on the right is
    a combination you are happy with:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整基础颜色和阴影，直到右侧的调色板预览是你满意的一组组合：
- en: '![](img/68b3551e-2b20-4aba-ad28-2c111f4b3128.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/68b3551e-2b20-4aba-ad28-2c111f4b3128.png)'
- en: 'By clicking on any of the boxes in the palette preview and then their hex codes,
    you can copy the RGB hex code to the clipboard and paste it into Android Studio:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击调色板预览中的任何方框及其十六进制代码，你可以将 RGB 十六进制代码复制到剪贴板，并将其粘贴到 Android Studio 中：
- en: '![](img/c73fd892-7a74-49f8-884e-8612b571ec9e.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c73fd892-7a74-49f8-884e-8612b571ec9e.png)'
- en: Ensure that you use colors from the top-left box for your primary and primaryDark
    colors, while you use a color from the bottom-right box for the accent color.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你使用左上角的框中的颜色作为主色和主色深，同时使用右下角的框中的颜色作为强调色。
- en: In Android Studio, use Tools | Android | Theme Editor to open the Android Theme
    Editor.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，使用“工具 | Android | 主题编辑器”打开Android主题编辑器。
- en: 'In the Theme panel on the right-hand side, you''ll find a list of colors that
    define your theme:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的主题面板中，你可以找到一个定义你主题的颜色列表：
- en: '![](img/fde5ec77-f9fd-41bd-b1bc-1218e3a69c74.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fde5ec77-f9fd-41bd-b1bc-1218e3a69c74.png)'
- en: Click on the color buttons in the Theme Editor to open a color editor. Copy
    the colors from Paletton into the theme editor for primary, primary-dark, and
    accent.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击主题编辑器中的颜色按钮以打开颜色编辑器。将Paletton中的颜色复制到主题编辑器中的主色、主色深和强调色。
- en: If you run the travel claim example application now, you'll see that the entire
    application has a completely new theme. The floating action button will be the
    same color as the underline on the `EditText` widget. This will be your accent
    color, while the background of your `Toolbar` will be your primary color.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行旅行报销示例应用程序，你会看到整个应用程序都有一个全新的主题。浮动操作按钮将与`EditText`小部件下划线的颜色相同。这将是你强调色，而你的`Toolbar`的背景将是你的主色。
- en: It' generally best to use your primary color's complementary color as your accent
    color. This is the color that is on the opposite side of color wheel, and will
    normally have an excellent contrast against your primary color. The contrast will
    help readability and reduce eye strain. It's important to ensure legibility for
    everyone, and Paletton includes a Vision simulation option below the palette preview
    that can be used to test your palette for various types of colorblindness.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好使用你主色的互补色作为你的强调色。这是位于色轮另一侧的颜色，通常与你的主色形成极佳的对比。这种对比有助于提高可读性并减少眼睛疲劳。确保每个人都能看清楚是很重要的，Paletton在调色板预览下方包含一个视觉模拟选项，可以用来测试你的调色板以适应各种类型的色盲。
- en: Generating palettes dynamically
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态生成调色板
- en: There are times when you're not sure what your palette should be ahead of time.
    There are also times that you would like the color scheme to match some user content,
    such as a photo or the album art for the music they're listening to. In cases
    like these, it's nice to be able to grab the key colors from an image and produce
    a palette that will match them. The problem is that the palette still needs to
    not be too jarring, and your text still needs to be legible against the background
    color. These are pretty hard problems to solve in pure code, but Android support
    libraries have an excellent little tool that does exactly this--the `Palette`
    API.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不确定你的调色板应该是什么样子。也有时候你希望配色方案与某些用户内容相匹配，比如他们正在看的照片或他们正在听的音乐的专辑封面。在这些情况下，能够从图像中抓取关键颜色并生成一个与之匹配的调色板是非常有用的。问题是调色板仍然不能太刺眼，你的文本仍然需要与背景颜色保持可读性。这些是在纯代码中很难解决的问题，但Android支持库有一个非常棒的工具可以做到这一点——`Palette`
    API。
- en: 'A very useful way of using generated palettes is to colorize cards with different
    icons according to the colors in the icon. Let''s write a `CardView` implementation
    that can colorize its contents according to a generated palette:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的调色板的一个非常有用方法是，根据图标中的颜色用不同的颜色来着色卡片。让我们编写一个可以根据生成的调色板着色其内容的`CardView`实现：
- en: You'll first need to add the `Palette` API to your project. In the travel claim
    app, open the app module's `build.gradle` file in Android Studio.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先需要将`Palette` API添加到你的项目中。在旅行报销应用中，在Android Studio中打开应用模块的`build.gradle`文件。
- en: 'In the `dependencies` at the bottom of the file, include the `Palette` API
    by declaring this:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件底部的`dependencies`中，通过声明以下内容来包含`Palette` API：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Click on the Sync Now link that appears at the top of the editor panel.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击编辑面板顶部的“立即同步”链接。
- en: Right-click on the widget's package and select New| Java Class.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击小部件的包，然后选择“新建| Java类”。
- en: Name the new class `ColorizedCardView`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`ColorizedCardView`。
- en: Change the `Superclass` to `android.support.v7.widget.CardView`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Superclass`更改为`android.support.v7.widget.CardView`。
- en: Add `android.support.v7.graphics.Palette.PaletteAsyncListener` to the Interface(s).
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`android.support.v7.graphics.Palette.PaletteAsyncListener`添加到接口（s）中。
- en: Click OK to create the new class.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新类。
- en: 'Add the required `View` constructors so that the class can be used from XML
    files:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的`View`构造函数，以便可以从XML文件中使用该类：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ColorizedCardView` doesn''t just change its own background, it needs to
    change the color of any text as well so that the text remains legible to the user.
    This means that the `ColorizedCardView` needs to find all the `TextView` instances
    that don''t have their background `Drawable` set (a `Button` is just a `TextView`
    with a specialized background, and we want to leave that as is). This method will
    traverse (depth-first) into the `ColorizedCardView`, and add any `TextView` objects
    it finds to a `Collection`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ColorizedCardView`不仅改变自己的背景，还需要改变任何文本的颜色，以确保用户能够清晰地阅读文本。这意味着`ColorizedCardView`需要找到所有没有设置背景`Drawable`的`TextView`实例（一个`Button`只是一个具有特定背景的`TextView`，我们希望保持原样）。此方法将遍历（深度优先）`ColorizedCardView`，并将找到的任何`TextView`对象添加到`Collection`中：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each `Palette` is actually a list of `Swatch` objects, each one containing
    a base color and colors suitable for heading text and body text. The `ColorizedCardView`
    allows you to specify a `Swatch` directly to colorize the background and all the
    text:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个`Palette`实际上是一个`Swatch`对象的列表，每个`Swatch`都包含一个基础颜色以及适合标题文本和正文文本的颜色。`ColorizedCardView`允许你直接指定`Swatch`来着色背景和所有文本：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When a `Palette` is generated, it can have any number of `Swatch` objects.
    There are a selection of *standard* swatches that are normally generated when
    you create a `Palette` from a `Bitmap`, but any number of them may remain unpopulated
    (`null`). When you colorize the card by a `Palette` object, you''ll need to look
    for an available `Swatch`; in the `ColorizedCardView` implementation. We''ll favor
    *light* swatches over *dark* swatches, and *muted* swatches over *vibrant*:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当生成`Palette`时，它可以包含任意数量的`Swatch`对象。有一系列*标准*的`Swatch`，通常在从`Bitmap`创建`Palette`时生成，但其中任意数量的`Swatch`可能未被填充（`null`）。当你通过`Palette`对象着色卡片时，你需要在`ColorizedCardView`实现中查找一个可用的`Swatch`；我们将优先选择*浅色*的`Swatch`而不是*深色*的`Swatch`，以及*柔和*的`Swatch`而不是*鲜艳*的`Swatch`：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You may need to adjust the ordering of this method in your application, depending
    on the colors chosen for the rest of the application. Typically, muted colors
    cause less eye strain for your users, but you may want to colorize action buttons
    using vibrant colors to draw attention to them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要根据应用程序中选择的颜色调整此方法的顺序。通常，柔和的颜色对用户的眼睛压力较小，但你可能希望使用鲜艳的颜色来着色操作按钮，以吸引人们的注意。
- en: 'Now, we need a way to specify a `Bitmap` to colorize the entire `ColorizedCardView`
    with. The `Palette` uses a `Builder` object to generate its swatches, and has
    its own built-in `AsyncTask` to handle generating the `Palette` on a background
    thread (which can take a few seconds on larger images or slower devices). The
    `setColorizeBitmap` method is defined so that it''s easy to invoke from a data-bound
    layout XML file. The `Palette.Builder` needs a callback to handle the generated
    `Palette`, which will be the `ColorizedCardView` instance (remember that you''ve
    implemented the `PaletteAsyncListener` interface):'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方法来指定一个`Bitmap`以着色整个`ColorizedCardView`。`Palette`使用一个`Builder`对象来生成其`Swatch`，并且有一个内置的`AsyncTask`来处理在后台线程上生成`Palette`（在较大的图像或较慢的设备上可能需要几秒钟）。`setColorizeBitmap`方法被定义为从数据绑定布局XML文件中调用它很容易。`Palette.Builder`需要一个回调来处理生成的`Palette`，这将是一个`ColorizedCardView`实例（记住你已经实现了`PaletteAsyncListener`接口）：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You''ll also need a way to colorize the `ColorizedCardView` based on a `Drawable`
    object, which will offer better interoperability with application `Resources`.
    The following `renderDrawable` method has a shortcut if the `Drawable` object
    is a `BitmapDrawable` (which simply wraps a `Bitmap`); otherwise, it''ll try and
    render the `Drawable` to a `Bitmap` object. As a `Drawable` has bounds that include
    its position (and not just its size), you''ll need to translate the `Canvas` that
    it''s going to draw on so that it renders in the top-left corner of the `Bitmap`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要一种方法来根据`Drawable`对象对`ColorizedCardView`进行着色，这将提供与应用程序`Resources`更好的互操作性。以下`renderDrawable`方法如果`Drawable`对象是`BitmapDrawable`（它只是包装了一个`Bitmap`）的话，有一个快捷方式；否则，它将尝试将`Drawable`渲染到`Bitmap`对象。由于`Drawable`的边界包括其位置（而不仅仅是大小），你需要将要在其上绘制的`Canvas`进行平移，以便它在`Bitmap`的左上角渲染：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To use the `ColorizedCardView` in the travel claim application, you can find
    and download colored icons for all the categories and change the `ItemPresenter`
    to use them, instead of the standard black icons we imported from the Material
    Icons set. An excellent resource for finding icons and sets of icons is Iconfinder--[https://www.iconfinder.com/](https://www.iconfinder.com/).
    Iconfinder allows you to search for and filter icon sets according to your criteria,
    and purchase or download the icons you need for your application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在旅行索赔应用程序中使用`ColorizedCardView`，您可以找到并下载所有类别的彩色图标，并将`ItemPresenter`更改为使用它们，而不是我们从Material
    Icons集合中导入的标准黑色图标。寻找图标和图标集合的优秀资源是Iconfinder--[https://www.iconfinder.com/](https://www.iconfinder.com/)。Iconfinder允许您根据您的标准搜索和筛选图标集合，并购买或下载您应用程序所需的图标。
- en: 'To change the overview screen to use your favorite colorful icons, follow these
    steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要将概览屏幕更改为使用您喜欢的彩色图标，请按照以下步骤操作：
- en: Place your new icons in the `res/drawable` directory of your application; ensure
    that you download PNG icons so that they can be read by Android.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的新图标放置在应用程序的`res/drawable`目录中；确保您下载PNG图标，以便Android能够读取。
- en: Open the `card_claim_item` layout resource in Android Studio.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中打开`card_claim_item`布局资源。
- en: Change to the Text editor.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到文本编辑器。
- en: 'Change the declaration of the `CardView` to a `ColorizedCardView`, and use
    the `app:colorizeDrawable` data binding attribute to invoke `setColorizeDrawable`
    with the same `Drawable` that will be rendered as the icon:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CardView`的声明更改为`ColorizedCardView`，并使用`app:colorizeDrawable`数据绑定属性调用`setColorizeDrawable`，使用与将作为图标渲染的相同`Drawable`：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Open the `ItemPresenter` Java source file.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ItemPresenter` Java源文件。
- en: 'Change the icons returned by the `getCategoryIcon` method to return your new
    icons, instead of those used by the category selector:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`getCategoryIcon`方法返回的图标更改为返回您的新图标，而不是类别选择器使用的图标：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The icon names used earlier are just an example; you'll need to use the names
    of the icon files you downloaded and placed in the `drawable` directory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的图标名称只是一个示例；您需要使用您下载并放置在`drawable`目录中的图标文件名称。
- en: The `ColorizedCardView` is a very useful and generic implementation of colorization
    using the `Palette` class. Using the bold background colors on each card makes
    them quickly recognizable to the user, and allows the user to more quickly find
    what they are looking for in a long scrolling list of items. As it can be automatically
    colorized using data binding, the `ColorizedCardView` can be populated with virtually
    any content.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorizedCardView`是使用`Palette`类进行着色的一个非常有用且通用的实现。使用每张卡片上的粗体背景颜色，可以让用户快速识别，并使用户能够更快地在长滚动列表中找到他们想要的内容。由于它可以自动使用数据绑定进行着色，因此`ColorizedCardView`可以填充几乎任何内容。'
- en: Adding animations
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动画
- en: Animations may appear to just be a nice bit of polishing on top of your user
    interface, but they can also serve an important purpose. In any design, whether
    it's a building, an API, or a user interface, it's good to try and follow a principle
    of *least surprise*. Try and offer your user things that make sense without them
    having to try and understand the details of how it works. A good example of violating
    this principle is when a button is wired incorrectly. If you were to press the
    *copy* button on a printer, and instead of making a copy it printed a test page,
    this would be a surprise. You expected the machine to do one thing because of
    the label, but it did something unexpected.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 动画可能看起来只是对用户界面进行的一些美化，但它们也可以发挥重要作用。在任何设计中，无论是建筑、API还是用户界面，遵循最小惊讶原则都是好的。尽量提供用户理解起来有意义的东西，而无需他们尝试理解其工作细节。违反这一原则的一个好例子是按钮连接错误。如果您按下打印机上的*复制*按钮，而不是打印副本，而是打印了测试页，这将会令人惊讶。您期望机器根据标签执行一项操作，但它做了出乎意料的事情。
- en: It's always important to consider what your user will expect to happen when
    they look at or use your application's user interface. Using well-known names
    and icons for the elements of a user interface help make it instantly understood
    by your user, but sometimes your application will change what is on the screen
    without being entirely obvious as to *what has changed*. In cases like this, animations
    become essential to tell users what has happened. A good example of using animation
    to express a change is the automatic animations you added to the `RecyclerView`
    using the `DiffUtil` class. When the user adds a new claim item, it appears in
    the list at the correct position, but an animation will draw the user's attention
    to where it has appeared and let them know that it's the new item.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 总是考虑用户在查看或使用您应用程序的用户界面时预期会发生什么，这始终很重要。使用众所周知的名称和图标来表示用户界面的元素有助于让用户立即理解，但有时您的应用程序会改变屏幕上的内容，而不会完全明显地表明*发生了什么变化*。在这种情况下，动画变得至关重要，可以告诉用户发生了什么。使用动画来表达变化的良好例子是您使用`DiffUtil`类添加到`RecyclerView`中的自动动画。当用户添加一个新的索赔项目时，它会在列表中出现在正确的位置，但动画会将用户的注意力吸引到它出现的位置，并让他们知道这是一项新项目。
- en: Animations have to strike a careful balance. However, if everything is animated,
    then the user can become frustrated by the extra time being taken by the animations.
    This leads to another important factor--animations should be quick. The Android
    platform defines a *short* animation as just *200 milliseconds*, just one-fifth
    of a second.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 动画必须保持谨慎的平衡。然而，如果一切都被动画化，用户可能会因为动画所消耗的额外时间而感到沮丧。这导致另一个重要因素——动画应该快速。Android平台定义的*短*动画仅为*200毫秒*，仅仅是一秒的五分之一。
- en: You've already added implicit animations to the travel claim application using
    the `RecyclerView` and `DiffUtil`. **Implicit animations** are all over in the
    Android platform and cover a wide range of everyday cases, such as the changes
    in the `RecyclerView` contents. There are also ways to add your own animations
    to layouts and widgets, and there are several widgets that are specifically designed
    to render animations and transitions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经使用`RecyclerView`和`DiffUtil`向旅行索赔应用程序添加了隐式动画。**隐式动画**在Android平台中无处不在，涵盖了广泛的日常情况，例如`RecyclerView`内容的变化。还有方法可以向布局和小部件添加自己的动画，并且有几个小部件是专门设计用来渲染动画和转场的。
- en: Within layout animations, there are four basic actions that an animation can
    perform on a widget or group of widgets that are being animated.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局动画中，动画可以对正在动画化的小部件或小部件组执行四种基本操作。
- en: 'A widget can be translated, which involves moving it left or right, up or down
    (or any combination of those), as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件可以被平移，这涉及到将其向左或向右、向上或向下移动（或这些移动的组合），如下所示：
- en: '![](img/e38a3010-0b55-4013-a1fa-795839b533d4.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e38a3010-0b55-4013-a1fa-795839b533d4.jpg)'
- en: 'An animation can also scale a widget. This involves changing its size to make
    it appear larger or smaller. Scaling, like translation, can be applied on either
    the horizontal (x) axis, or the vertical (y) axis, or both of them together:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 动画还可以缩放小部件。这涉及到改变其大小，使其看起来更大或更小。与平移一样，缩放可以应用于水平（x）轴、垂直（y）轴，或同时应用于两者：
- en: '![](img/677c2a6b-0de2-4107-9d22-82dbfa5fc502.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/677c2a6b-0de2-4107-9d22-82dbfa5fc502.jpg)'
- en: 'You can also have an animation rotate the widget. Rotation is not a natural
    change for a user interface widget, as typically, all widgets are layouts out
    of a box-like grid. Rotation can be very useful, and can produce a pleasing effect
    when applied to widgets that appear to be round (such as a `FloatingActionButton`
    or a circular avatar):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以让动画旋转小部件。旋转对于用户界面小部件来说不是一种自然的变化，因为通常，所有小部件都是在一个类似框的网格中布局的。旋转可以非常实用，并且当应用于看起来是圆形的小部件（如`FloatingActionButton`或圆形头像）时，可以产生令人愉悦的效果：
- en: '![](img/fc54fe9b-5e44-42dd-ad28-70ee671ad406.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc54fe9b-5e44-42dd-ad28-70ee671ad406.jpg)'
- en: 'While all the first three transformations are concerned with the physical structure
    of the widget being animated, the fourth one changes how opaque it is. The alpha
    transformation allows you to produce animations where widgets appear to fade-in
    or fade-out:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前三个变换都涉及到正在动画化的小部件的物理结构，但第四个变换则改变了它的不透明度。alpha变换允许您产生小部件似乎淡入或淡出的动画：
- en: '![](img/11c9b8a9-cbf7-4e62-920c-d0fd3d27305b.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11c9b8a9-cbf7-4e62-920c-d0fd3d27305b.jpg)'
- en: These four animation actions can be combined into what Android calls a **set**.
    A *set* is a group of animation actions that will all appear to happen at the
    same time.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个动画动作可以组合成 Android 所称的 **set**。一个 *set* 是一组动画动作，它们将同时出现。
- en: Creating custom animations
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义动画
- en: 'Android animations are in fact resource files, much like an icon or a layout.
    The animations that apply to layouts and widgets are XML files that define the
    various transformations and are placed in the `res/anim` directory. Android provides
    a small selection of simple animations that you can use in your application, without
    needing to build your own:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Android 动画实际上是资源文件，就像图标或布局一样。应用于布局和小部件的动画是 XML 文件，定义了各种转换，并放置在 `res/anim` 目录中。Android
    提供了一组简单的动画，您可以在应用程序中使用，而无需自己构建：
- en: '`android.R.anim.fade_in` - `@android:anim/fade_in`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.R.anim.fade_in` - `@android:anim/fade_in`'
- en: '`android.R.anim.fade_out` - `@android:anim/fade_out`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.R.anim.fade_out` - `@android:anim/fade_out`'
- en: '`android.R.anim.slide_in_left` - `@android:anim/slide_in_left`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.R.anim.slide_in_left` - `@android:anim/slide_in_left`'
- en: '`android.R.anim.slide_out_right` - `@android:anim/slide_out_right`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.R.anim.slide_out_right` - `@android:anim/slide_out_right`'
- en: 'These four animations cover two different types of transition: fading out and
    in, or sliding the widgets from left to right. Nothing stops you from mixing them
    together, for example, fading the widget out and then sliding a new one in from
    the left.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个动画涵盖了两种不同的过渡类型：淡入淡出，或者从左到右滑动小部件。没有任何东西阻止你将它们混合在一起，例如，先淡出小部件，然后从左侧滑入一个新的小部件。
- en: 'To do these sorts of transitions, there are a family of Android widgets that
    will manage the animation for you. These can either focus on animating the content
    (that is, text or an image), or they transition through a list of child widgets.
    The base of these classes is `android.widget.ViewAnimator`, and the best-known
    implementations are these:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行这些类型的转换，有一系列 Android 小部件可以为您管理动画。这些小部件可以专注于动画内容（即文本或图像），或者通过子小部件列表进行过渡。这些类的基础是
    `android.widget.ViewAnimator`，最著名的实现包括这些：
- en: '`TextSwitcher`: Behaves like an animated `TextView`; each time its text is
    changed, it animates between the old text and the new text'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextSwitcher`：表现得像动画 `TextView`；每次其文本更改时，它都会在旧文本和新文本之间进行动画转换'
- en: '`ImageSwitcher`: Just like `TextSwitcher`, but for images'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageSwitcher`：就像 `TextSwitcher` 一样，但用于图像'
- en: '`ViewFlipper`: It is used like a `FrameLayout`, but only one of its children
    is shown at a time, and you can have it animate between them'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewFlipper`：它像 `FrameLayout` 一样使用，但一次只显示其子项中的一个，并且您可以使其在它们之间进行动画转换'
- en: 'Let''s create two new animation sets to animate some text, and change the category
    label in the `CategoryPickerFragment` to use a `TextSwitcher`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个新的动画集来动画化一些文本，并将 `CategoryPickerFragment` 中的类别标签更改为使用 `TextSwitcher`：
- en: Right-click on the res directory in the travel claim example app and select
    New | Android resource file.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旅行索赔示例应用的 res 目录上右键单击，然后选择“新建 | Android 资源文件”。
- en: Name the new file `slide_in_top`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为 `slide_in_top`。
- en: 'Change the Resource type to Animation (not Animator):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将资源类型更改为动画（不是动画器）：
- en: '![](img/63c504aa-d97f-49d2-82ca-4005d9a06fd3.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63c504aa-d97f-49d2-82ca-4005d9a06fd3.png)'
- en: An `Animator` allows the direct manipulation of any property in any Java Object;
    while this is a very powerful system to use, it does not work with classes such
    as `TextSwitcher`. `Animation` refers to the *view animation* system, which is
    designed specifically for animating widgets, and has various performance enhancements
    in the layout system to avoid the user interface stuttering during animations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Animator` 允许直接操作任何 Java 对象中的任何属性；虽然这是一个非常强大的系统，但它不适用于 `TextSwitcher` 类等。`Animation`
    指的是 *视图动画* 系统，它专门设计用于动画化小部件，并在布局系统中进行了各种性能优化，以避免在动画过程中出现用户界面卡顿。'
- en: Click OK to create the new animation XML resource.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的动画 XML 资源。
- en: 'On the `<set>` element, we need to define how long the animation will take,
    and the interpolator. The **interpolator** defines the relative motion of the
    animation. Does it happen with linear smoothness (which often appears artificial,
    but is the easiest), or does the animation appear to *bounce*, or something else
    entirely? In this case, we will use the standard `anticipate_overshoot_interpolator`,
    which includes a small *bounce* effect at the end of the animation:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<set>` 元素上，我们需要定义动画将持续多长时间，以及插值器。**插值器**定义了动画的相对运动。它是以线性平滑的方式发生（这通常看起来很假，但最容易），还是动画看起来像
    *弹跳*，或者完全是其他的东西？在这种情况下，我们将使用标准的 `anticipate_overshoot_interpolator`，它包括动画结束时的轻微
    *弹跳* 效果：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This animation will consist of two parts. The first part is a translation from
    offscreen, downward to where the text should normally appear. The second part
    is a fade in from fully transparent to opaque. Each action taken by a view animation
    is defined in terms of what the value should be when the animation starts, and
    what the value should be when it stops (from and to). The values in between are
    defined by the time of each frame, and the interpolator. Inside the `<set>` element,
    add a `translation` to bring the view along the y-axis from above where it ends:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个动画将包含两个部分。第一部分是从屏幕外向下移动到文本应该正常出现的位置。第二部分是从完全透明到不透明的淡入。每个视图动画的动作都是根据动画开始时和结束时应该有的值来定义的（从和到）。中间的值由每帧的时间以及插值器定义。在
    `<set>` 元素内部，添加一个 `translation` 来将视图沿着 y 轴从上方移动到结束位置：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, add the fade-in using an `alpha` action. A zero alpha value indicates
    that the widget should be invisible, while a one indicates that it should be fully
    opaque. The alpha is a floating-point number, so you can define any value between
    zero and one for partial transparency:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加使用 `alpha` 动作的淡入。零 alpha 值表示小部件应该是不可见的，而一表示它应该是完全不透明的。alpha 是一个浮点数，因此你可以定义介于零和一之间的任何值来实现部分透明度：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While a single animation is nice, you need two animations running together to
    create a *transition*. Right-click on the new `res/anim` directory and select
    New| Animation resource file.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然单个动画很棒，但你需要两个动画同时运行来创建一个 *过渡效果*。在新的 `res/anim` 目录上右键单击，并选择“新建|动画资源文件”。
- en: Name the new animation `slide_out_bottom`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的动画命名为 `slide_out_bottom`。
- en: Click OK to create the new resource file.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的资源文件。
- en: 'This animation works the same way as `slide_in_top`, but pushes the view downward
    and makes it transparent:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个动画与 `slide_in_top` 的工作方式相同，但它将视图向下推并使其透明：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, you'll need to change the `CategoryPickerFragment` to use a `TextSwitcher`
    instead of a `TextView`. Start by opening the `fragment_category_picker` layout
    resource file and change to the Text editor.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要将 `CategoryPickerFragment` 改为使用 `TextSwitcher` 而不是 `TextView`。首先打开 `fragment_category_picker`
    布局资源文件，并切换到文本编辑器。
- en: 'Locate the `TextView` at the bottom of the file, and change it to be a `TextSwitcher`.
    A `TextSwitcher` needs two `TextView` child elements to animate between. Each
    time you change the text on the `TextSwitcher`, it puts the new text on the invisible
    `TextView` and then animates between the visible `TextView` and the invisible
    one (that is, it switches them around and hence its name). You''ll need to tell
    the `TextSwitcher` to use the animation resources you just created as its *in*
    and *out* animations:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到文件底部的 `TextView`，并将其更改为 `TextSwitcher`。`TextSwitcher` 需要两个 `TextView` 子元素来在它们之间进行动画。每次你在
    `TextSwitcher` 上更改文本时，它都会将新文本放在不可见的 `TextView` 上，然后在这两个可见的 `TextView` 和不可见的 `TextView`
    之间进行动画（即切换它们，因此得名）。你需要告诉 `TextSwitcher` 使用你刚刚创建的动画资源作为其 *进入* 和 *退出* 动画：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Open the `CategoryPickerFragment` source file and change the references to
    the `TextView` to a `TextSwitcher`. There will be one as a field, and the other
    should be in the `onCreateView` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `CategoryPickerFragment` 源文件，并将对 `TextView` 的引用更改为 `TextSwitcher`。其中一个将作为字段，另一个应该在
    `onCreateView` 方法中：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Open the `IconPickerWrapper` source file. This currently wraps a `TextView`,
    but will now need to wrap a `TextSwitcher`. Like the `CategoryPickerFragment`,
    change the references from `TextView` to `TextSwitcher`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `IconPickerWrapper` 源文件。目前它包装了一个 `TextView`，但现在需要包装一个 `TextSwitcher`。像 `CategoryPickerFragment`
    一样，将 `TextView` 的引用更改为 `TextSwitcher`：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s all you need to do in this case; the `CaptureClaimActivity` will now
    have a very pleasing animation on the text in the category chooser, which indicates
    that the icons are used to change the category. While a `TextSwitcher` doesn''t
    subclass `TextView`, it does expose the same critical method for these cases--`setText(CharSequence)`.
    Unfortunately, this means that you can''t substitute the classes directly one
    for the other. Instead, you''ll need to treat each as a separate type (as earlier).
    You can, however, create `abstract` `wrapper` class to wrap these two and allow
    your layout to define whether there should be animations or not:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你只需要做这些；现在 `CaptureClaimActivity` 将在类别选择器中的文本上有一个非常令人愉悦的动画，这表明图标被用来更改类别。虽然
    `TextSwitcher` 不继承自 `TextView`，但它确实暴露了这些情况下的相同关键方法--`setText(CharSequence)`。不幸的是，这意味着你不能直接替换这些类。相反，你需要将每个都视为一个单独的类型（如之前所述）。然而，你可以创建一个
    `abstract` `wrapper` 类来包装这两个类，并允许你的布局定义是否应该有动画：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class can be used to wrap references to widgets that can be either `TextView`
    or `TextSwitcher`, depending on the context. This allows you to reuse more of
    your Java code when dealing with cases where some screens require a simple layout,
    while others require animations. It's generally a useful pattern to remember,
    because it reduces the coupling between your user interface and your code when
    you can't use the class inheritance, and want to avoid casting.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类可以用来包装可以既是 `TextView` 又是 `TextSwitcher` 的控件引用，这取决于上下文。这允许你在处理某些屏幕需要简单布局，而其他屏幕需要动画的情况时重用更多的
    Java 代码。这通常是一个有用的模式，因为它在不能使用类继承且想避免强制类型转换时，减少了用户界面和代码之间的耦合。
- en: Data binding can also be used to solve this problem. By having the `CategoryPickerFragment`,
    use a data-bound layout; the `TextSwitcher` will automatically animate when the
    model was changed by the user clicking on the `RadioButton` widgets.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定也可以用来解决这个问题。通过让 `CategoryPickerFragment` 使用数据绑定的布局；当用户通过点击 `RadioButton`
    控件更改模型时，`TextSwitcher` 将会自动动画。
- en: Activating more animations
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活更多动画
- en: 'There are some other small ways in which Android can provide your application
    with animations that let the user know what is going on. For example, you can
    tell any `ViewGroup` implementation (any of the `Layout` classes: `FrameLayout`,
    `LinearLayout`, or `ConstraintLayout`) to animate the changes to the layout. You
    do this by simply turning on `animateLayoutChanges` in your layout resource:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Android 还有一些其他小方法可以提供动画，让用户知道正在发生什么。例如，你可以告诉任何 `ViewGroup` 实现（任何 `Layout` 类：`FrameLayout`、`LinearLayout`
    或 `ConstraintLayout`）动画布局的变化。你只需在布局资源中简单地打开 `animateLayoutChanges` 即可完成此操作：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is especially useful when you offer the ability to *unfold* a card to
    expose more functionality or more information. Coupling the `animateLayoutChanges`
    attribute with the `ViewGroup` class is a very powerful combination. `ViewStub`
    is a special type of widget that can be used like an `<include>`, that only loads
    when you tell it to. When it''s loaded, it doesn''t act as a container, but *replaces
    itself* with the layout it has loaded. Using `animateLayoutChanges` inflating
    a `ViewStub` can automatically trigger a nice animation to reveal the new content
    to the user. The following code snippet is a `CardView` that will animate the
    inflation of a menu that can be made to appear at the bottom of the card:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这在你提供展开卡片以显示更多功能或更多信息的能力时特别有用。将 `animateLayoutChanges` 属性与 `ViewGroup` 类结合使用是一个非常强大的组合。`ViewStub`
    是一种特殊的控件，可以像 `<include>` 一样使用，只有当你告诉它时才会加载。当它加载时，它不会作为容器，而是用它加载的布局来*替换自己*。使用 `animateLayoutChanges`
    来膨胀 `ViewStub` 可以自动触发一个漂亮的动画，向用户展示新内容。以下代码片段是一个 `CardView`，它将动画菜单的膨胀，该菜单可以被设置为出现在卡片的底部：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you inflate the preceding `ViewStub`, it will replace itself with the
    contents of the `card_menu` layout resource, and the `ConstraintLayout` will animate
    the change, making the `card_menu` appear to unfold. You can use the following
    code snippet to inflate the `ViewStub` when the `CardView` is tapped on by the
    user:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你膨胀前面的 `ViewStub` 时，它将用 `card_menu` 布局资源的内容来替换自己，`ConstraintLayout` 将动画变化，使
    `card_menu` 看起来像是在展开。你可以使用以下代码片段在用户点击 `CardView` 时膨胀 `ViewStub`：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code is a single-use `OnClickListener` that removes itself when
    it's been triggered. This is important because once a `ViewStub` has been inflated,
    it no longer exists in the layout. After the preceding listener is triggered,
    `findViewById(R.id.menu)` will return the root element of the `card_menu` layout
    resource, not the `ViewStub`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个一次性使用的 `OnClickListener`，在触发后会移除自己。这很重要，因为一旦 `ViewStub` 被膨胀，它就不再存在于布局中。在上述监听器被触发后，`findViewById(R.id.menu)`
    将返回 `card_menu` 布局资源的根元素，而不是 `ViewStub`。
- en: Creating custom styles
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义样式
- en: When polishing your application, you'll find that certain styling requirements
    become common over the entire application, but in specific places. For example,
    the *positive* / *go* buttons should have a specific background color that highlights
    them from the other buttons in the application, or that the *negative* / *delete*
    buttons should have a color that highlights them as destructive for the user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在润色应用程序时，你会发现某些样式要求在整个应用程序中变得很常见，但在特定的地方。例如，*正* / *前进* 按钮应该有特定的背景颜色，使其从应用程序中的其他按钮中突出出来，或者*负*
    / *删除* 按钮应该有颜色，使其对用户来说显得具有破坏性。
- en: 'Android offers you the ability to define your own styles apart from those defined
    by the system. The theming system in Android is built entirely on top of the styling
    system. Styles have some very simple attributes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Android 允许你定义自己的样式，而不仅仅是系统定义的样式。Android 的主题系统完全建立在样式系统之上。样式有一些非常简单的属性：
- en: Styles can be named
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以被命名
- en: A style can change any attribute exposed in the layout XML file
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以改变在布局 XML 文件中暴露的任何属性
- en: A style can inherit from another style and override its attributes (a bit like
    classes extending each other)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以继承自另一个样式并覆盖其属性（有点像类相互扩展）
- en: Styles are defined as value resources (a bit like dimensions, strings, and colors)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式被定义为值资源（有点像尺寸、字符串和颜色）
- en: 'Let''s jump right in and create a new style for the travel claim application
    for the amount-input; we want to create a style that can be reused whenever the
    user needs to type a monetary amount into the application:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始为旅行索赔应用程序的金额输入创建一个新的样式；我们想要创建一个样式，当用户需要在应用程序中输入货币金额时可以重复使用：
- en: Open the `styles.xml` resource file in the res/values project folder.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `res/values` 项目文件夹中的 `styles.xml` 资源文件。
- en: 'You''ll note in this file that you already have several styles defined by the
    Android Studio templates. These are mostly theme-related styles, and will apply
    to the entire application. We want to define a new style that can be applied to
    specific widgets. Declare a new style element named `AmountInput`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会注意到在这个文件中，你已经通过 Android Studio 模板定义了几个样式。这些样式大多是主题相关的，并且将应用于整个应用程序。我们想要定义一个新的样式，该样式可以应用于特定的控件。声明一个新的样式元素，命名为
    `AmountInput`：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first thing we want this style to do is to align the text to the right
    of the input box. This is normally done by changing the `android:gravity` attribute
    on the `EditText` box. In the `style` element, you need to declare this as an
    `item` you wish to override:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先想要这个样式做的第一件事是将文本对齐到输入框的右侧。这通常是通过更改 `EditText` 框上的 `android:gravity` 属性来完成的。在
    `style` 元素中，你需要声明这是一个你希望覆盖的 `item`：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You also want to change the focus behavior so that when the user taps to edit
    the amount, the existing value is selected. This allows them to more easily enter
    a new number, which is more common than wanting to edit an existing number. The
    `TextView` class defines an attribute named `selectAllOnFocus` that is perfect
    for this purpose:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还想要改变焦点行为，以便当用户点击编辑金额时，现有的值会被选中。这允许他们更容易地输入一个新的数字，这比编辑现有数字更为常见。`TextView` 类定义了一个名为
    `selectAllOnFocus` 的属性，非常适合这个目的：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To apply the style to the amount input, open the `fragment_claim_capture_details.xml`
    layout resource in Text mode (this is from the Try it Yourself section of [Chapter
    4](1799a69f-adfc-4439-883c-f2db5e4ad199.xhtml), *Composing User Interfaces*).
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将样式应用于金额输入，请以文本模式打开 `fragment_claim_capture_details.xml` 布局资源（这来自第 4 章的“自己尝试”部分，*构建用户界面*）。
- en: 'Find the `EditText` entry for the amount, and apply the style. It''s important
    to note that the style attribute is not in the android XML namespace:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到金额的 `EditText` 条目，并应用该样式。重要的是要注意，样式属性不在 android XML 命名空间中：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you run the application or change to the Design view, you''ll find that
    the amount field is now right aligned, and if you tap on it, the entire content
    will be selected. This style can now be applied to any number of fields in your
    application:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序或切换到设计视图时，你会发现金额字段现在已右对齐，如果你点击它，整个内容将被选中。现在，这种样式可以应用于应用程序中的任意多个字段：
- en: '![](img/1e2c39fb-ce32-40d0-abe7-66c1f8b19350.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e2c39fb-ce32-40d0-abe7-66c1f8b19350.png)'
- en: 'Styles themselves can be overridden at each layer. When you inherit from another
    style, the child can override any of its parent items. When a widget has a style
    applied, any attributes specified on the widget''s XML element take precedence
    over the style being applied. For example, if you wanted to create an `AmountInput`
    styled widget that left aligned its text content (instead of the style''s right
    alignment), you might use the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 样式本身可以在每一层被覆盖。当你从另一个样式继承时，子样式可以覆盖其父项中的任何项。当一个小部件应用了样式时，小部件XML元素上指定的任何属性都将优先于正在应用的样式。例如，如果您想创建一个左对齐文本内容（而不是样式的右对齐）的`AmountInput`样式小部件，您可能使用以下代码：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although it's not commonly done, you can also use styles to apply attributes,
    such as labels and hints, to widgets. This allows for two screens to easily replicate
    a widget exactly, without requiring an `include`. Any time you find that your
    layout code appears to repeat itself, consider using a style if an include doesn't
    look suitable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，但你也可以使用样式将属性（如标签和提示）应用于小部件。这允许两个屏幕轻松地精确复制小部件，而无需使用`include`。每次你发现你的布局代码似乎在重复时，考虑使用样式，如果`include`看起来不合适的话。
- en: Test your knowledge
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: When choosing a color scheme, it's important that the accent color has which
    of these features?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择颜色方案时，强调色应具备以下哪些特征？
- en: It is the same hue as the primary color
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与原色具有相同的色调
- en: It is complementary to the primary color
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与原色形成互补
- en: It is not black and not white
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它既不是黑色也不是白色
- en: Dynamically generating a palette should meet which of these conditions?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态生成调色板应满足以下哪些条件？
- en: It should be used in preference to defining the color scheme up front
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应优先使用它来定义颜色方案，而不是一开始就定义
- en: It should be done on a background thread
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在后台线程上执行
- en: It should only be used in media applications
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应仅用于媒体应用
- en: Which of these is to be kept in mind while animating layouts in your application?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序中动画布局时，应牢记以下哪一项？
- en: They should not block or distract the user from achieving their goals
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不应阻碍或分散用户实现目标
- en: They should be done whenever the user interface changes
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在用户界面更改时进行
- en: They should be kept as simple as possible to conserve battery
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应尽可能简单，以节省电池
- en: Custom styles can be used to define which of these?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用自定义样式来定义以下哪一项？
- en: Common groups of attributes for widgets based on their class
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于它们类别的常见属性组
- en: Common groups of attributes to be applied through the `style` attribute
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`style`属性应用的一些常见属性组
- en: Default values for any attribute in a layout resource file
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局资源文件中任何属性的默认值
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Polishing an application (much like optimizing an application) shouldn't be
    taken on too early in its development, as it can distract getting the application
    working and making the user experience smooth. It is, however, a vital part of
    an application's development, and the careful application of colors, fonts, and
    animations can sometimes be the difference between success and failure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 磨练应用程序（与优化应用程序类似）不应在开发初期就着手进行，因为这可能会分散将应用程序工作正常和使用户体验流畅的注意力。然而，它是应用程序开发的一个关键部分，并且对颜色、字体和动画的谨慎应用有时可能是成功与失败之间的区别。
- en: Using color tools such as Paletton make the selection of a color-scheme much
    easier. It's important to also consider how color-blind people will see your application,
    and to ensure that the application is still usable by this sizeable portion of
    the population. If you know someone who has any form of color blindness, ask them
    to help test your choice in colors. Alternatively, use the color blindness simulations
    that palette design tools such as Paletton provide.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Paletton等颜色工具可以使选择颜色方案变得容易得多。同时，考虑色盲人士如何看到您的应用程序也很重要，并确保应用程序对这部分人口仍然可用。如果您认识任何形式的色盲的人，请他们帮助测试您的颜色选择。或者，使用Paletton等调色板设计工具提供的色盲模拟。
- en: When adding animations to the application, it's a good idea to leverage the
    default animation systems provided by the platform. Avoid adding animations to
    widgets that don't already provide some form of animation capability. If you find
    yourself animating things by hand, there is probably something wrong. Try and
    stick to using the animations built into classes like `RecyclerView` and `ViewPager`,
    while using animating widgets such as `TextSwitcher` where appropriate. It's also
    important to keep animations short. While you might think your animation looks
    lovely, your users will become frustrated if they slow down the use of the application.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当向应用程序添加动画时，利用平台提供的默认动画系统是一个好主意。避免向那些已经不提供某种形式的动画能力的部件添加动画。如果你发现自己正在手动进行动画处理，可能存在某些问题。尽量坚持使用内置于类如`RecyclerView`和`ViewPager`中的动画，并在适当的地方使用如`TextSwitcher`之类的动画部件。同时，保持动画的简短也很重要。虽然你可能认为你的动画看起来很漂亮，但如果动画减慢了应用程序的使用速度，用户可能会感到沮丧。
- en: In this chapter, we looked at various ways in which your application can be
    styled to fit a color-scheme, and polished with animations and styles for certain
    components. In the next chapter, we'll look at how to create your own completely
    customized widget classes and how to repurpose the existing widget classes for
    new or specialized use cases.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了各种方法来调整你的应用程序以适应配色方案，并通过动画和样式来润色某些组件。在下一章中，我们将探讨如何创建你自己的完全定制的部件类，以及如何将现有的部件类重新用于新的或特殊的使用场景。
