<html><head></head><body>
  <div><h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-189" class="chapterTitle">Protocols and Protocol Extensions</h1>
    <p class="normal">While watching the presentations from WWDC 2015 about protocol extensions and <strong class="keyword">protocol-oriented programming</strong> (<strong class="keyword">POP</strong>), I will admit<a id="_idIndexMarker423"/> that I was very skeptical. I have worked with <strong class="keyword">object-oriented programming</strong> (<strong class="keyword">OOP</strong>) for so<a id="_idIndexMarker424"/> long that I was unsure whether this new programming paradigm would solve all of the problems that Apple was claiming it would. Since I am not one who lets my skepticism get in the way of trying something new, I set up a new project that mirrored the one I was currently working on, but wrote the code using Apple's recommendations for POP. I also used protocol extensions extensively in the code. I can honestly say that I was amazed by how much cleaner the new project was compared to the original one. I believe that protocol extensions are going to be one of those defining features that set one programming language apart from the rest.</p>
    <p class="normal">In this chapter, you will learn about the following topics:</p>
    <ul>
      <li class="bullet">How are protocols used as a type?</li>
      <li class="bullet">How do we implement polymorphism in Swift using protocols?</li>
      <li class="bullet">How do we use protocol extensions?</li>
      <li class="bullet">Why we would want to use protocol extensions?</li>
    </ul>
    <p class="normal">While protocol extensions are basically syntactic sugar, they are, in my opinion, one of the most important additions to the Swift programming language. With protocol extensions, we are able to provide method and property implementations to any type that conforms to a protocol. To really understand how useful protocols and protocol extensions are, let's get a better understanding of protocols.</p>
    <p class="normal">While classes, structures, and enumerations can all conform to protocols in Swift, for this chapter, we will be focusing on classes and structures. Enumerations are used when we need to represent a finite number of cases, and while there are valid use cases where we would have an enumeration conform to a protocol, they are rare in my experience. Just remember that anywhere we refer to a class or structure, we can also use an enumeration.</p>
    <p class="normal">Let's begin exploring protocols by seeing how they are full-fledged types in Swift.</p>
    <h1 id="_idParaDest-190" class="title">Protocols as types</h1>
    <p class="normal">Even though no<a id="_idIndexMarker425"/> functionality is implemented in a protocol, they are still considered a full-fledged type in the Swift programming language and can be used like any other type. This means that we can use protocols as a parameter type or as a return type in a function.</p>
    <p class="normal">We can also use them as the type for variables, constants, and collections. Let's take a look at some examples. For these few examples, we will use the following <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code">protocol PersonProtocol {
    var firstName: String { get set } 
    var lastName: String { get set } 
    var birthDate: Date { get set } 
    var profession: String { get }
init(firstName: String,lastName: String, birthDate: Date)
}
</code></pre>
    <p class="normal">In this first example, a protocol is used as a parameter type and a return type for a function:</p>
    <pre class="programlisting code"><code class="hljs-code">func updatePerson(person: PersonProtocol) -&gt; PersonProtocol {
    // Code to update person goes here 
return person
}
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">updatePerson()</code> function accepts one parameter of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol type and returns a value of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol type. This next example shows how to use a protocol as a type for constants, variables, or properties:</p>
    <pre class="programlisting code"><code class="hljs-code">var myPerson: PersonProtocol
</code></pre>
    <p class="normal">In this example, we create a variable of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol type that is named <code class="Code-In-Text--PACKT-">myPerson</code>. Protocols can also be used as the item type for storing a collection, such as arrays, dictionaries, or sets:</p>
    <pre class="programlisting code"><code class="hljs-code">var people: [PersonProtocol] = []
</code></pre>
    <p class="normal">In this final example, we created an array of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol type. Even though the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol does not implement any functionality, we can still use protocols when we need to specify a type. However, a protocol cannot be instantiated in the same way as a class or a structure. This is because no functionality is implemented in a protocol. As an example, when trying to create an instance of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol, as shown in the following example, we would receive a compile-time error:</p>
    <pre class="programlisting code"><code class="hljs-code">var test = PersonProtocol(firstName: "Jon", lastName: "Hoffman", birthDate:bDateProgrammer)
</code></pre>
    <p class="normal">We can use the instance of any type that conforms to our protocol wherever the protocol type is required. As an example, if we've defined a variable to be of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol<a id="_idIndexMarker426"/> type, we can then populate that variable with any class or structure that conforms to this protocol. For this example, let's assume that we have two types, named <code class="Code-In-Text--PACKT-">SwiftProgrammer</code> and <code class="Code-In-Text--PACKT-">FootballPlayer</code>, that conform to the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code">var myPerson: PersonProtocol
myPerson = SwiftProgrammer(firstName: "Jon", lastName: "Hoffman", birthDate: bDateProgrammer)
print("\(myPerson.firstName) \(myPerson.lastName)")
myPerson = FootballPlayer(firstName: "Dan", lastName: "Marino", birthDate:bDatePlayer)
print("\(myPerson.firstName) \(myPerson.lastName)")
</code></pre>
    <p class="normal">In this example, we start off by creating the <code class="Code-In-Text--PACKT-">myPerson</code> variable of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol type. We then set the variable with an instance of the <code class="Code-In-Text--PACKT-">SwiftProgrammer</code> type and print out the first and last names. Next, we set the <code class="Code-In-Text--PACKT-">myPerson</code> variable to an instance of the <code class="Code-In-Text--PACKT-">FootballPlayer</code> type and print out the first and last names again. One thing to note is that Swift does not care whether the instance is a class or structure. The only thing that matters is that the type conforms to the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol type.</p>
    <p class="normal">We can use the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol as the type for an array, which means that we can populate the<a id="_idIndexMarker427"/> array with instances of any type that conforms to the protocol. Once again, it does not matter whether the type is a class or a structure, as long as it conforms to the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol.</p>
    <h1 id="_idParaDest-191" class="title">Polymorphism with protocols</h1>
    <p class="normal">What we saw in<a id="_idIndexMarker428"/> the previous examples is a form of polymorphism. The <a id="_idIndexMarker429"/>word <strong class="keyword">polymorphism</strong> comes from the Greek roots <strong class="keyword">poly</strong>, meaning many, and <strong class="keyword">morphe</strong>, meaning form. In programming languages, polymorphism is a single interface to multiple types (many forms). In the previous example, the single interface was the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol and the multiple types were any type that conforms to that protocol.</p>
    <p class="normal">Polymorphism gives us the ability to interact with multiple types in a uniform manner. To illustrate this, we can extend the previous example where we created an array of the <code class="Code-In-Text--PACKT-">PersonProtocol</code> types and looped through the array. We can then access each item in the array using the properties and methods defined in the <code class="Code-In-Text--PACKT-">PersonProtocol</code> protocol, regardless of the actual type. Let's see an example of this:</p>
    <pre class="programlisting code"><code class="hljs-code">for person in people { 
    print("\(person.firstName)\(person.lastName):\(person.profession)")
}
</code></pre>
    <p class="normal">When we define the type of a variable, constant, collection type, and so on to be a protocol type, we can use the instance of any type that conforms to that protocol. This is a very important concept to understand and is one of the many things that make protocols and protocol extensions so powerful.</p>
    <p class="normal">When we use a protocol to access instances, as shown in the previous example, we are limited to using only properties and methods that are defined in the protocol itself. If we want to use properties or methods that are specific to the individual types, we need to cast the instance to that type.</p>
    <h1 id="_idParaDest-192" class="title">Typecasting with protocols</h1>
    <p class="normal">Typecasting is a<a id="_idIndexMarker430"/> way to check the type of the instance and/or to treat<a id="_idIndexMarker431"/> the instance as a specified type. In Swift, we use the <code class="Code-In-Text--PACKT-">is</code> keyword to check whether an instance is a specific type, and the <code class="Code-In-Text--PACKT-">as</code> keyword to treat the instance as a specific type.</p>
    <p class="normal">To start, let's see how we would check the instance type using the <code class="Code-In-Text--PACKT-">is</code> keyword. The following example shows how this is done:</p>
    <pre class="programlisting code"><code class="hljs-code">for person in people {
    if let p = person as? SwiftProgrammer { 
        print("\(person.firstName) is a Swift Programmer")
    }
}
</code></pre>
    <p class="normal">In this example, we use the <code class="Code-In-Text--PACKT-">if</code> conditional statement to check whether each element in the <code class="Code-In-Text--PACKT-">people</code> array is an instance of the <code class="Code-In-Text--PACKT-">SwiftProgrammer</code> type and, if so, we print that the person is a Swift programmer to the console. While this is a good method to check whether we have an instance of a specific class or structure, it is not very efficient if we want to check for <a id="_idIndexMarker432"/>multiple types. It would be more efficient to use <a id="_idIndexMarker433"/>a <code class="Code-In-Text--PACKT-">switch</code> statement, as shown in the next example:</p>
    <pre class="programlisting code"><code class="hljs-code">for person in people {
    switch person {
        case is SwiftProgrammer:
            print("\(person.firstName) is a Swift Programmer") 
        case is FootballPlayer:
            print("\(person.firstName) is a Football Player") 
        default:
            print("\(person.firstName) is an unknown type")
    }
}
</code></pre>
    <p class="normal">In the previous example, we showed how to use the <code class="Code-In-Text--PACKT-">switch</code> statement to check the instance type for each element of the array. To do this check, we use the <code class="Code-In-Text--PACKT-">is</code> keyword in each of the <code class="Code-In-Text--PACKT-">case</code> statements in an attempt to match the instance type.</p>
    <p class="normal">In <em class="chapterRef">Chapter 6</em>, <em class="italic">Control Flow</em>, we saw how to filter conditional statements with the <code class="Code-In-Text--PACKT-">where</code> statement. We can also use the <code class="Code-In-Text--PACKT-">where</code> statement with the <code class="Code-In-Text--PACKT-">is</code> keyword to filter the array, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">for person in people where person is SwiftProgrammer { 
    print("\(person.firstName) is a Swift Programmer")
}
</code></pre>
    <p class="normal">Now let's look at how we can cast an instance of a class or structure to a specific type. To do this, we would use the <code class="Code-In-Text--PACKT-">as</code> keyword. Since the cast can fail if the instance is not of the specified type, the <code class="Code-In-Text--PACKT-">as</code> keyword comes in two forms: <code class="Code-In-Text--PACKT-">as?</code> and <code class="Code-In-Text--PACKT-">as!</code>. With the <code class="Code-In-Text--PACKT-">as?</code> form, if the casting fails, it returns <code class="Code-In-Text--PACKT-">nil</code>, and with the <code class="Code-In-Text--PACKT-">as!</code> form, if the casting fails, we get a runtime error. Therefore, it is recommended to use the <code class="Code-In-Text--PACKT-">as?</code> form unless we are absolutely sure of the instance type or we perform a check of the instance type prior to doing the cast.</p>
    <div><p class="Information-Box--PACKT-">While we do show examples of typecasting with <code class="Code-In-Text--PACKT-">as!</code> in this book, so you are aware that it is there, we highly recommend that you do not use it in your projects because it can cause a runtime error.</p>
    </div>
    <p class="normal">Let's look at how <a id="_idIndexMarker434"/>we would use the <code class="Code-In-Text--PACKT-">as?</code> keyword to cast an instance of a<a id="_idIndexMarker435"/> class or structure to a specified type:</p>
    <pre class="programlisting code"><code class="hljs-code">for person in people {
    if let p = person as? SwiftProgrammer { 
        print("\(person.firstName) is a Swift Programmer")
    }
}
</code></pre>
    <p class="normal">Since the <code class="Code-In-Text--PACKT-">as?</code> keyword returns an optional, we use optional binding to perform the cast, as shown in this example.</p>
    <p class="normal">Now that we have covered the basics of protocols, let's dive into one of the most exciting features of Swift: protocol extensions.</p>
    <h1 id="_idParaDest-193" class="title">Protocol extensions</h1>
    <p class="normal">Protocol extensions<a id="_idIndexMarker436"/> allow us to extend a protocol to provide method and property implementations to conforming types. They also allow us to provide common implementations to all the conforming types, eliminating the need to provide an implementation in each individual type or the need to create a class hierarchy. While protocol extensions may not seem too exciting, once you see how powerful they really are, they will transform the way you think about and write code.</p>
    <p class="normal">Let's begin by looking at how we would use protocol extensions within a very simplistic example. We will start by defining a protocol named <code class="Code-In-Text--PACKT-">Dog</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">protocol Dog {
    var name: String { get set } 
    var color: String { get set }
}
</code></pre>
    <p class="normal">With this protocol, we state that any type that conforms to the <code class="Code-In-Text--PACKT-">Dog</code> protocol must have the two properties of the <code class="Code-In-Text--PACKT-">String</code> type, named <code class="Code-In-Text--PACKT-">name</code> and <code class="Code-In-Text--PACKT-">color</code>. Next, let's define the three types that conform to this <code class="Code-In-Text--PACKT-">Dog</code> protocol. We will name these types <code class="Code-In-Text--PACKT-">JackRussel</code>, <code class="Code-In-Text--PACKT-">WhiteLab</code>, and <code class="Code-In-Text--PACKT-">Mutt</code>. The<a id="_idIndexMarker437"/> following code shows how we would define these types:</p>
    <pre class="programlisting code"><code class="hljs-code">struct JackRussel: Dog{ 
    var name: String
    var color: String
}
class WhiteLab: Dog{
    var name: String
    var color: String
    init(name: String, color: String) {
        self.name = name
        self.color = color
    }
}
struct Mutt: Dog{ 
    var name: String 
    var color: String
}
</code></pre>
    <p class="normal">We purposely created the <code class="Code-In-Text--PACKT-">JackRussel</code> and <code class="Code-In-Text--PACKT-">Mutt</code> types as structures and the <code class="Code-In-Text--PACKT-">WhiteLab</code> type as a class to show the differences between how the two types are set up, and to illustrate how they are treated the same when it comes to protocols and protocol extensions.</p>
    <p class="normal">The biggest difference we can see in this example is that structure types provide a default initiator, but in the class we must provide the initiator to populate the properties.</p>
    <p class="normal">Now let's say that we want to provide a method named <code class="Code-In-Text--PACKT-">speak</code> to each type that conforms to the protocol. Prior to protocol extensions, we would have started off by adding the method definition to the protocol, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">protocol Dog{
    var name: String { get set } 
    var color: String { get set } 
    func speak() -&gt; String
}
</code></pre>
    <p class="normal">Once the method is defined in the protocol, we would then need to provide an implementation of the method in every type that conforms to the protocol. Depending on the number of types that conformed to this protocol, this could take a bit of time to implement and it could affect a lot of code. The following code sample shows how we might implement<a id="_idIndexMarker438"/> this method:</p>
    <pre class="programlisting code"><code class="hljs-code">struct JackRussel: Dog{ 
    var name: String
    var color: String
    func speak() -&gt; String { 
        return "Woof"
    }
}
class WhiteLab: Dog{ 
    var name: String 
    var color: String
    init(name: String, color: String) { 
        self.name = nameself.color = color}
    func speak() -&gt; String { 
        return "Woof"
    }
}
struct Mutt: Dog{ 
    var name: String 
    var color: String
    func speak() -&gt; String { 
        return "Woof Woof"
    }
}
</code></pre>
    <p class="normal">While this method works, it is not very efficient because any time we update the protocol, we need to update all the types that conform to it, and therefore duplicate a lot of code, as shown in this example. If we need to change the default behavior of the <code class="Code-In-Text--PACKT-">speak()</code> method, we would have to go into each implementation and change the method. This is where protocol extensions come in.</p>
    <p class="normal">With protocol extensions, we could take the <code class="Code-In-Text--PACKT-">speak()</code> method definition out of the protocol itself and define it with the default behavior in the protocol extension.</p>
    <div><p class="Information-Box--PACKT-">If we are implementing a method in a protocol extension, we are not required to define it in the protocol. </p>
    </div>
    <p class="normal">The following code shows how we would define the protocol and the protocol extension:</p>
    <pre class="programlisting code"><code class="hljs-code">protocol Dog{
    var name: String { get set } 
    var color: String { get set }
}
extension Dog{
    func speak() -&gt; String { 
      return "Woof Woof"
    }
  }
</code></pre>
    <p class="normal">We begin by <a id="_idIndexMarker439"/>defining the <code class="Code-In-Text--PACKT-">Dog</code> protocol with the original two properties. We then create a protocol extension that extends it and contains the default implementation of the <code class="Code-In-Text--PACKT-">speak()</code> method. With this code, there is no need to provide an implementation of the <code class="Code-In-Text--PACKT-">speak()</code> method in all of the types that conform to the <code class="Code-In-Text--PACKT-">Dog</code> protocol because they automatically receive the implementation as part of the protocol.</p>
    <p class="normal">Let's see how this works by setting the three types that conform to the <code class="Code-In-Text--PACKT-">Dog</code> protocol back to their original implementations; then they should receive the <code class="Code-In-Text--PACKT-">speak()</code> method from the protocol extension:</p>
    <pre class="programlisting code"><code class="hljs-code">struct JackRussel: Dog{
    var name: String
    var color: String
}
class WhiteLab: Dog{
    var name: String
    var color: String
    init(name: String, color: String) {
        self.name = name
        self.color = color
    }
}
struct Mutt: Dog{ 
    var name: String 
    var color: String
}
</code></pre>
    <p class="normal">We can now use each of the types, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">let dash = JackRussel(name: "Dash", color: "Brown and White")
let lily = WhiteLab(name: "Lily", color: "White")
let maple = Mutt(name: "Buddy", color: "Brown")
let dSpeak = dash.speak() // returns "woof woof" 
let lSpeak = lily.speak() // returns "woof woof" 
let bSpeak = maple.speak() // returns "woof woof"
</code></pre>
    <p class="normal">As we can see in this <a id="_idIndexMarker440"/>example, by adding the <code class="Code-In-Text--PACKT-">speak()</code> method to the <code class="Code-In-Text--PACKT-">Dog</code> protocol extension, we are automatically adding that method to all the types that conform to the protocol. The <code class="Code-In-Text--PACKT-">speak()</code> method in the protocol extension can be considered a default implementation of the method because we are able to override it in the type implementations. As an example, we could override the <code class="Code-In-Text--PACKT-">speak()</code> method in the <code class="Code-In-Text--PACKT-">Mutt</code> structure, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Mutt: Dog{ 
    var name: String 
    var color: String
    func speak() -&gt; String {
        return "I am hungry"
    }
}
</code></pre>
    <p class="normal">When we call the <code class="Code-In-Text--PACKT-">speak()</code> method for an instance of the <code class="Code-In-Text--PACKT-">Mutt</code> type, it will return the <code class="Code-In-Text--PACKT-">I am hungry</code> string.</p>
    <div><p class="Information-Box--PACKT-">In this chapter, we named our protocols with the protocol suffix. This was done to make it very clear that this was a protocol. This is not how we would normally name our types. The following example gives a better example of how we would properly name protocols. You can read additional information about Swift's naming conventions in the Swift API design guidelines: <a href="https://swift.org/documentation/api-design-guidelines/#general-conventions">https://swift.org/documentation/api-design-guidelines/#general-conventions</a>.</p>
    </div>
    <p class="normal">Now that we have seen how to use protocols and protocol extensions, let's look at a more real-world<a id="_idIndexMarker441"/> example. </p>
    <h2 id="_idParaDest-194" class="title">A real-world example</h2>
    <p class="normal">In numerous apps<a id="_idIndexMarker442"/> across multiple platforms (iOS, Android, and Windows), I have needed to validate user input as it is entered. This validation can be done very easily with regular expressions; however, we do not want various regular expressions littered throughout our code. It is very easy to solve this problem by creating different classes or structures that contain the validation code. However, we would have to organize these types to make them easy to use and maintain. Prior to protocol extensions in Swift, I would use a protocol to define the validation requirements and then create structures that would conform to the protocol for each validation that I needed. Let's look at this pre-protocol extension method.</p>
    <div><p class="Information-Box--PACKT-">A regular expression is a sequence of characters that defines a particular pattern. This pattern can then be used to search a string to see whether the string matches the pattern or contains a match of the pattern. Most major programming languages contain a regular expression parser, and if you are not familiar with regular expressions, it may be worthwhile to learn more about them.</p>
    </div>
    <p class="normal">The following code shows the <code class="Code-In-Text--PACKT-">TextValidating</code> protocol that defines the requirements for any type that we want to use for text validation:</p>
    <pre class="programlisting code"><code class="hljs-code">protocol TextValidating {
    var regExMatchingString: String { get } 
    var regExFindMatchString: String { get } 
    var validationMessage: String { get }
    func validateString(str: String) -&gt; Bool
    func getMatchingString(str: String) -&gt; String?
}
</code></pre>
    <p class="normal">The Swift API<a id="_idIndexMarker443"/> design guidelines (<a href="https://swift.org/documentation/api-design-guidelines/">https://swift.org/documentation/api-design-guidelines/</a> ) state that protocols that describe what something is should be named as a noun, while protocols that describe a capability should be named with a suffix of -able, - ible, or -ing. With this in mind, we named the text validation protocol <code class="Code-In-Text--PACKT-">TextValidating</code>.</p>
    <p class="normal">In this protocol, we define three properties and two methods that any type that conforms to a protocol must implement. The three properties are as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">regExMatchingString</code>: This is a regular expression string used to verify that the input string contains only valid characters.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">regExFindMatchString</code>: This is a regular expression string used to retrieve a new string from the input string that contains only valid characters. This regular expression is generally used when we need to validate the input in real time as the user enters information, because it will find the longest matching prefix of the input string.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">validationMessage</code>: This is the error message that's displayed if the input string contains non-valid characters.</li>
    </ul>
    <p class="normal">The two methods for<a id="_idIndexMarker444"/> this protocol are as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">validateString</code>: This method will return <code class="Code-In-Text--PACKT-">true</code> if the input string contains only valid characters. The <code class="Code-In-Text--PACKT-">regExMatchingString</code> property will be used in this method to perform the match.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">getMatchingString</code>: This method will return a new string that contains only valid characters. This method is generally used when we need to validate the input in real time as the user enters information because it will find the longest matching prefix of the input string. We will use the <code class="Code-In-Text--PACKT-">regExFindMatchString</code> property in this method to retrieve the new string.</li>
    </ul>
    <p class="normal">Now let's see how we can create a structure that conforms to this protocol. The following structure would be used to verify that the input string contains only alpha characters:</p>
    <pre class="programlisting code"><code class="hljs-code">struct AlphaValidation1: TextValidating {
    static let sharedInstance = AlphaValidation1()
    private init(){}
    let regExFindMatchString = "^[a-zA-Z]{0,10}"
    let validationMessage = "Can only contain Alpha characters" 
    var regExMatchingString: String {
        get {
            return regExFindMatchString + "$"
        }
    }
    func validateString(str: String) -&gt; Bool {
        if let _ = str.range(of: regExMatchingString, options:                   .regularExpression) {
        return true
    } else {
        return false
        }
    }
    func getMatchingString(str: String) -&gt; String? {
        if let newMatch = str.range(of: regExFindMatchString,
                          options:.regularExpression) {
        return String(str[newMatch])
    } else {
        return nil
        }
    }
}
</code></pre>
    <p class="normal">In this <a id="_idIndexMarker445"/>implementation, the <code class="Code-In-Text--PACKT-">regExFindMatchString</code> and <code class="Code-In-Text--PACKT-">validationMessage</code> properties are stored properties, and the <code class="Code-In-Text--PACKT-">regExMatchingString</code> property is a computed property.</p>
    <p class="normal">We also implement the <code class="Code-In-Text--PACKT-">validateString()</code> and <code class="Code-In-Text--PACKT-">getMatchingString()</code> methods within the structure.</p>
    <p class="normal">Normally, we would have several different types that conform to the protocol, where each one would validate a different type of input. As we can see from the <code class="Code-In-Text--PACKT-">AlphaValidation1</code> structure, there is a bit of code involved with each validation type. A lot of the code would also be duplicated in each type. The code for both methods and the <code class="Code-In-Text--PACKT-">regExMatchingString</code> property would probably be duplicated in every validation class. This is not ideal, but if we want to avoid creating a class hierarchy with a superclass that contains the duplicate code (it is recommended that we prefer value types over reference types), prior to protocol extensions, we had no other choice. Now let's see how we would implement this using protocol extensions.</p>
    <p class="normal">With protocol extensions, we need to think about the code a little differently. The big difference is that we neither need nor want to define everything in the protocol. With standard protocols, all the methods and properties that you would want to access using a protocol interface would have to be defined within the protocol.</p>
    <p class="normal">With protocol extensions, it is preferable for us not to define a property or method in the protocol if we are going to be defining it within the protocol extension. Therefore, when we rewrite our text validation types with protocol extensions, <code class="Code-In-Text--PACKT-">TextValidating</code> would be greatly simplified to look like this:</p>
    <pre class="programlisting code"><code class="hljs-code">protocol TextValidating {
    var regExFindMatchString: String { get } 
    var validationMessage: String { get }
}
</code></pre>
    <p class="normal">In the original <code class="Code-In-Text--PACKT-">TextValidating</code> protocol, we defined three properties and two methods. As we can see in this new protocol, we are only defining two properties. Now that we have our <code class="Code-In-Text--PACKT-">TextValidating</code> protocol <a id="_idIndexMarker446"/>defined, let's create the protocol extension for it:</p>
    <pre class="programlisting code"><code class="hljs-code">extension TextValidating {
    var regExMatchingString: String { 
        get {
            return regExFindMatchString + "$"
        }
    }
    func validateString(str: String) -&gt; Bool {
        if let _ = str.range(of:regExMatchingString,                   options:.regularExpression){
        return true
    } else {
        return false
        }
    }
    func getMatchingString(str: String) -&gt; String? {
        if let newMatch = str.range(of:regExFindMatchString,                          options:.regularExpression) {
        return str.substring(with: newMatch)
    } else {
        return nil
        }
    }
}
</code></pre>
    <p class="normal">In the <code class="Code-In-Text--PACKT-">TextValidating</code> protocol extension, we define the two methods and the property that were defined in the original <code class="Code-In-Text--PACKT-">TextValidating</code> protocol but were not defined in the new one. Now that we have created the protocol and protocol extension, we are able to define our new text validation types. In the following code, we define three structures that we will use to validate text as a user types it in:</p>
    <pre class="programlisting code"><code class="hljs-code">struct AlphaValidation: TextValidating {
    static let sharedInstance = AlphaValidation()
    private init(){}
    let regExFindMatchString = "^[a-zA-Z]{0,10}"
    let validationMessage = "Can only contain Alpha characters"
}
struct AlphaNumericValidation: TextValidating {
    static let sharedInstance = AlphaNumericValidation() 
    private init(){}
    let regExFindMatchString = "^[a-zA-Z0-9]{0,15}"
    let validationMessage = "Can only contain Alpha Numeric characters"
}
struct DisplayNameValidation: TextValidating {
    static let sharedInstance = DisplayNameValidation() 
    private init(){}
    let regExFindMatchString = "^[\\s?[a-zA-Z0-9\\-_\\s]]{0,15}"
    let validationMessage = "Can only contain Alphanumeric Characters"
}
</code></pre>
    <p class="normal">In each of the <a id="_idIndexMarker447"/>text-validation structures, we create a static constant and a private initializer so that we can use the structure as a singleton. For more information on the singleton pattern, please see <em class="italic">The singleton design pattern</em> section of <em class="chapterRef">Chapter 20</em>, <em class="italic">Adopting Design Patterns in Swift</em>.</p>
    <p class="normal">After we define the singleton pattern, all we do in each type is set the values for the <code class="Code-In-Text--PACKT-">regExFindMatchString</code> and <code class="Code-In-Text--PACKT-">validationMessage</code> properties. Now we have virtually no duplicate code. The only code that is duplicated is the code for the singleton pattern, and that is not something we would want to put in the protocol extension because we would not want to force the singleton pattern on all the conforming types.</p>
    <p class="normal">We can now use the text validation types, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">var testString = "abc123"
var alpha = AlphaValidation.sharedInstance alpha.getMatchingString(str:testString) 
alpha.validateString(str: testString)
</code>
AlphaValidation</code> type. Then <code class="Code-In-Text--PACKT-">getMatchingString()</code> is used to retrieve the longest matching prefix of the test string, which will be <code class="Code-In-Text--PACKT-">abc</code>. Then, the <code class="Code-In-Text--PACKT-">validateString()</code> method is used to validate the test string, but since the test string contains<a id="_idIndexMarker448"/> numbers, the method will return <code class="Code-In-Text--PACKT-">false</code>.</pre>
    <p class="normal">Now the question is, do we really need to use protocols?</p>
    <h1 id="_idParaDest-195" class="title">Do I need to use protocols?</h1>
    <p class="normal">Do you need to use <a id="_idIndexMarker449"/>protocols and protocol extensions when you already know OOP? The short answer is no; however, it is highly recommended. In <em class="chapterRef">Chapter 10</em>, <em class="italic">Protocol-Oriented Design</em>, we look at what makes protocol-oriented design so powerful to show you why you should prefer protocols with POP over OOP. By understanding protocols and protocol-oriented design, you will understand the Swift standard library better.</p>
    <h1 id="_idParaDest-196" class="title">Adopting protocols using a synthesized implementation</h1>
    <p class="normal">Swift can <a id="_idIndexMarker450"/>automatically provide protocol<a id="_idIndexMarker451"/> conformance for the <code class="Code-In-Text--PACKT-">Equatable</code>, <code class="Code-In-Text--PACKT-">Hashable</code>, and <code class="Code-In-Text--PACKT-">Comparable</code> protocols in specific cases. What this means is we do not need to write the boilerplate code to implement these protocols, and instead we can use the synthesized implementations. This only works if the structures or enumerations (not classes) contain only stored properties (for structures) or associated values (for enumerations) that conform to the <code class="Code-In-Text--PACKT-">Equatable</code>, <code class="Code-In-Text--PACKT-">Hashable</code>, and <code class="Code-In-Text--PACKT-">Comparable</code> protocols.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Equatable</code>, <code class="Code-In-Text--PACKT-">Hashable</code>, and <code class="Code-In-Text--PACKT-">Comparable</code> protocols are provided by the Swift standard library. Any type that conforms to the <code class="Code-In-Text--PACKT-">Equatable</code> protocols can use the equals operator (==) to compare two instances of the type. Any type that uses the <code class="Code-In-Text--PACKT-">Comparable</code> protocol can use comparative operators to compare two instances of the type. Finally, any type that conforms to the <code class="Code-In-Text--PACKT-">Hashable</code> protocol can be hashed into a <code class="Code-In-Text--PACKT-">Hasher</code> instance to produce an integer hash.</p>
    <p class="normal">Let's look at one example of this. We will start off by creating a simple structure that will store names:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Name {
    var firstName = ""
    var lastName = ""
}
</code></pre>
    <p class="normal">We can now create three instances of the <code class="Code-In-Text--PACKT-">Name</code> structure, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">let name1 = Name(firstName: "Jon", lastName: "Hoffman")
let name2 = Name(firstName: "John", lastName: "Hoffman")
let name3 = Name(firstName: "Jon", lastName: "Hoffman")
</code></pre>
    <p class="normal">If we tried to compare the instances of the <code class="Code-In-Text--PACKT-">Name</code> structure, as shown in the following code, we could receive a compile-time error because the <code class="Code-In-Text--PACKT-">Name</code> structure does not conform<a id="_idIndexMarker452"/> to <a id="_idIndexMarker453"/>the <code class="Code-In-Text--PACKT-">Equatable</code> protocol:</p>
    <pre class="programlisting code"><code class="hljs-code">name1 == name2
name1 == name3
</code></pre>
    <p class="normal">In order to have the ability to compare instances of the <code class="Code-In-Text--PACKT-">Name</code> structure, all that is needed is to state that the structure conforms to the <code class="Code-In-Text--PACKT-">Equatable</code> protocol, and the boilerplate code to do the comparison will be automatically added at compile time. The following code shows us how this is done:</p>
    <pre class="programlisting code"><code class="hljs-code">struct Name: Equatable {
    var firstName = ""
    var lastName = ""
}
</code></pre>
    <p class="normal">Notice that the only thing we changed was to add the <code class="Code-In-Text--PACKT-">Equatable</code> protocol to the structure definition. We are now able to successfully compare instances of the <code class="Code-In-Text--PACKT-">Name</code> structure.</p>
    <h1 id="_idParaDest-197" class="title">Swift's standard library</h1>
    <p class="normal">The Swift standard<a id="_idIndexMarker454"/> library defines a base layer of functionality for writing Swift applications. Everything we have used so far in this book is from the Swift standard library. The library defines the fundamental data types, such as the <code class="Code-In-Text--PACKT-">String</code>, <code class="Code-In-Text--PACKT-">Int</code>, and <code class="Code-In-Text--PACKT-">Double</code> types. It also defines collections, optionals, global functions, and all the protocols that these types conform to.</p>
    <p class="normal">One of the best sites to see everything <a id="_idIndexMarker455"/>that makes up the standard library is <a href="http://swiftdoc.org">http://swiftdoc.org</a>. This site lists all the types, protocols, operators, and globals that make up the standard library and contains documentation for all of it.</p>
    <p class="normal">Let's look at how protocols are used in the standard library by looking at the documentation. When you first visit the home page, you will be greeted with a searchable list of everything that makes up the standard library. There is also a complete list of all Swift types that you can select from. Let's look at the Swift <code class="Code-In-Text--PACKT-">Array</code> type by clicking on the <strong class="screenText">Array</strong> link. This will take you to the documentation page for the <code class="Code-In-Text--PACKT-">Array</code> type.</p>
    <p class="normal">These documentation pages are extremely useful and contain a lot of information about the various types that make up the standard library, including samples of how to use them. For our <a id="_idIndexMarker456"/>discussion, we are interested in the section labeled <strong class="keyword">Inheritance</strong>:</p>
    <figure class="mediaobject"><img src="img/B16683_09_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 9.1: Documentation on Inheritance</p>
    <p class="normal">From the inheritance section, we can see that the Array conforms to 7 protocols. If you click on some of the protocols, such as the <code class="Code-In-Text--PACKT-">MutableCollection</code> protocol, you will notice that they conform to other protocols. This may not make a lot of sense at this point but in the next chapter, <em class="chapterRef">Chapter 10</em>, <em class="italic">Protocol-Oriented Design</em>, we will look at how to design our applications and frameworks using a protocol-oriented approach, and then we will have a better understanding of how the Swift standard library is written.</p>
    <h1 id="_idParaDest-198" class="title">Summary</h1>
    <p class="normal">In this chapter, we saw that protocols are treated as full-fledged types by Swift. We also saw how polymorphism can be implemented in Swift with protocols. We concluded this chapter with an in-depth look at protocol extensions and saw how we would use them in Swift. Protocols and protocol extensions are the backbone of Apple's new POP paradigm. This new model for programming has the potential to change the way we write and think about code. While we did not specifically cover POP in this chapter, getting to grips with the topics in this chapter gives us the solid understanding of protocols and protocol extensions needed to learn about this new programming model. In the next chapter, we will look at how to use protocols and protocol extensions when we are designing our application.</p>
  </div>
</body></html>