<html><head></head><body>
		<div id="_idContainer193">
			<h1 id="_idParaDest-173" class="chapter number"><a id="_idTextAnchor582"/>11</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor583"/>Android Architecture Components</h1>
			<p><a id="_idTextAnchor584"/>In this chapter, you will learn about the key components of the Android Jetpack libraries and what benefits they bring to the standard Android framework. You will also learn how to structure your code and give different responsibilities to your classes with the help of Jetpack components. Finally, you’ll improve the test coverage of <span class="No-Break">your code.</span></p>
			<p>By the end of this chapter, you’ll be able to create applications that handle the lifecycles of activities and fragments with ease. You’ll also know more about how to persist data on an Android device using Room and how to use ViewModels to separate your logic from <span class="No-Break">your Views.</span></p>
			<p><a id="_idTextAnchor585"/>In the previous chapters, you learned how to write unit tests. The question is: what can you unit-test? Can you unit-test activities and fragments? It is hard to unit-test activities and fragments on your machine because of the way they are built. Testing would be easier if you could move the code away from activities <span class="No-Break">and fragments.</span></p>
			<p>Also, consider the situation where you are building an application that supports different orientations, such as landscape and portrait, and supports multiple languages. What tends to happen in these scenarios by default is that when the user rotates the screen, the activities and fragments are recreated for the new <span class="No-Break">display orientation.</span></p>
			<p>Now, imagine that happens while your application is in the middle of processing data. You have to keep track of the data you are processing, keep track of what the user was doing to interact with your screens, and avoid causing a <span class="No-Break">context leak.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">A <strong class="bold">context leak</strong> occurs when<a id="_idIndexMarker926"/> your destroyed activity cannot be garbage-collected because it is referenced in a component with a longer lifecycle – such as a thread that is currently processing <span class="No-Break">your data.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">ViewModel</span></li>
				<li><span class="No-Break">Data streams</span></li>
				<li><span class="No-Break">Room</span></li>
			</ul>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor586"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/89BCi"><span class="No-Break">https://packt.link/89BCi</span></a></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor587"/>Android components background</h1>
			<p>In many situations, you<a id="_idIndexMarker927"/> have to use <strong class="source inline">onSaveInstanceState</strong> to save the current state of your activity/fragment, and then in <strong class="source inline">onCreate</strong> or <strong class="source inline">onRestoreInstanceState</strong>, you need to restore the state of your activity/fragment. This adds extra complexity to your code and makes it repetitive, especially if the processing code is part of your activity <span class="No-Break">or fragment.</span></p>
			<p>These scenarios are where <strong class="source inline">ViewModel</strong> and <strong class="source inline">LiveData</strong> come in. <strong class="source inline">ViewModels</strong> are components built with the express goal of holding data in case of lifecycle changes. They also separate the logic from the Views, which makes them very easy to unit-test. <strong class="source inline">LiveData</strong> is a component used to hold data and notify observers when changes occur while taking their lifecycle <span class="No-Break">into account.</span></p>
			<p>In simpler terms, the fragment only deals with the Views, <strong class="source inline">ViewModel</strong> does the heavy lifting, and <strong class="source inline">LiveData</strong> deals with delivering the results to the fragment, but only when the fragment is there <span class="No-Break">and ready.</span></p>
			<p>If you’ve ever used WhatsApp or a similar messaging app and you’ve turned off the internet, you’ll have noticed that you are still able to use the application. The reason for this is that the messages are stored locally on your device. This is achieved with a database file called <strong class="source inline">SQLite</strong> in <span class="No-Break">most cases.</span></p>
			<p>The Android Framework already allows you to use this feature for your application. However, this requires a lot of boilerplate code to read and write data. Every time you want to interact with the local storage, you must write a SQL query. When you read the SQLite data, you must convert it into a <span class="No-Break">Java/Kotlin object.</span></p>
			<p>All of this requires a lot of code, time, and unit testing. What if someone else were to handle the SQLite connection, and all you had to do was focus on the code part? This is where <strong class="bold">Room</strong> comes in. This is a library that is a wrapper over SQLite. All you need to do is define how your data should be saved and let the library take care of <span class="No-Break">the rest.</span></p>
			<p>Let’s say you want your activity to know when there is an internet connection and when the internet drops. You can use something called <strong class="source inline">BroadcastReceiver</strong> for this. A slight problem with this is that every time you register <strong class="source inline">BroadcastReceiver</strong> in an activity, you must unregister it when the activity <span class="No-Break">is destroyed.</span></p>
			<p>You can use <strong class="source inline">Lifecycle</strong> to observe the state of your activity, thereby allowing your receiver to be registered in the desired state and unregistered in the complementary one (for example, <strong class="source inline">RESUMED-PAUSED</strong>, <strong class="source inline">STARTED-STOPPED</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source inline">CREATED-DESTROYED</strong></span><span class="No-Break">).</span></p>
			<p><strong class="source inline">ViewModels</strong>, <strong class="source inline">LiveData</strong>, and <strong class="source inline">Room</strong> are all part of the Android architecture components, which are part of the Android Jetpack libraries. The architecture components are designed to help developers structure their code, write testable components, and help reduce <span class="No-Break">boilerplate code.</span></p>
			<p>Other architecture <a id="_idIndexMarker928"/>components include <strong class="source inline">Databinding</strong> (which binds views with models or <strong class="source inline">ViewModels</strong>, allowing the data to be directly set in the Views), <strong class="source inline">WorkManager</strong> (which allows developers to handle background work with ease), <strong class="source inline">Navigation</strong> (which allows developers to create visual navigation graphs and specify relationships between activities and fragments), and <strong class="source inline">Paging</strong> (which allows developers to load paginated data, which helps in situations where infinite scrolling <span class="No-Break">is required<a id="_idTextAnchor588"/><a id="_idTextAnchor589"/><a id="_idTextAnchor590"/>).</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor591"/>ViewModel</h1>
			<p>The <strong class="source inline">ViewModel</strong> component is responsible <a id="_idIndexMarker929"/>for holding and processing data<a id="_idIndexMarker930"/> required by the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). It has the benefit of surviving configuration changes that destroy and recreate fragments and activities, which allows it to retain the data that can then be used to re-populate <span class="No-Break">the UI.</span></p>
			<p>It will eventually be<a id="_idIndexMarker931"/> destroyed when the activity or fragment is destroyed without being recreated or when the application process is terminated. This allows <strong class="source inline">ViewModel</strong> to serve its responsibility and to have garbage collected when it is no longer necessary. The only method <strong class="source inline">ViewModel</strong> has is the <strong class="source inline">onCleared()</strong> method, which is called when <strong class="source inline">ViewModel</strong> terminates. You can overwrite this method to terminate ongoing tasks and deallocate resources that will no longer <span class="No-Break">be required.</span></p>
			<p>Migrating data processing from the activities into <strong class="source inline">ViewModel</strong> helps create better and faster unit tests. Testing an activity requires an Android test to be executed on a device. Activities also have states, which means that your test should get the activity into the proper state for the assertions to work. <strong class="source inline">ViewModel</strong> can be unit-tested locally on your development machine and can be stateless, meaning that your data processing logic can be <span class="No-Break">tested individually.</span></p>
			<p>One of the most important features of <strong class="source inline">ViewModel</strong> is that it allows communication between fragments. To communicate between fragments without <strong class="source inline">ViewModel</strong>, you must make your fragment communicate with the activity, which will then call the fragment you wish to<a id="_idIndexMarker932"/> <span class="No-Break">communicate with.</span></p>
			<p>To achieve this with <strong class="source inline">ViewModel</strong>, you can just attach it to the parent activity and use the same <strong class="source inline">ViewModel</strong> in the fragment you wish to communicate with. This will reduce the boilerplate code that was <span class="No-Break">required previously.</span></p>
			<p>In the following diagram, you <a id="_idIndexMarker933"/>can see that <strong class="source inline">ViewModel</strong> can be created at any point in an activity’s lifecycle (in practice, they are normally initialized in <strong class="source inline">onCreate</strong> for Activities and <strong class="source inline">onCreateView</strong> or <strong class="source inline">onViewCreated</strong> for Fragments because these represent the points where the views are created and ready to be updated), and that once created, it will live as long as the <span class="No-Break">activity<a id="_idTextAnchor592"/> does:</span></p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B19411_11_01.jpg" alt="Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle</p>
			<p>In the preceding diagram, we can see how the lifecycle of <strong class="source inline">Activity</strong> compares to that of <strong class="source inline">ViewModel</strong>. The red lines indicate what happens when the <strong class="source inline">Activity</strong> is recreated, starting from the <strong class="source inline">onPause</strong> method, ending in <strong class="source inline">onDestroy,</strong> and then going from <strong class="source inline">onCreate</strong> to <strong class="source inline">onResume</strong> in a new instance <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">Activity</strong></span><span class="No-Break">.</span></p>
			<p>The following diagram shows how <strong class="source inline">ViewModel</strong> connects to <span class="No-Break">a frag<a id="_idTextAnchor593"/>ment:</span></p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B19411_11_02.jpg" alt="Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle</p>
			<p>In the preceding diagram, we<a id="_idIndexMarker934"/> can see how the lifecycle of <strong class="source inline">Fragment</strong> compares<a id="_idIndexMarker935"/> to that of <strong class="source inline">ViewModel</strong>. The red lines indicate what happens when <strong class="source inline">Fragment</strong> is recreated, starting from the <strong class="source inline">onPause</strong> method, ending in <strong class="source inline">onDetach</strong>, and then going from <strong class="source inline">onAttach</strong> to <strong class="source inline">onResume</strong> in a new instance <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">Fragment</strong></span><span class="No-Break">.</span></p>
			<p>In this section, we learned what a ViewModel is and the benefits it provides with regard to testing and performing logic, which survives the recreation of the activity <span class="No-Break">and fr<a id="_idTextAnchor594"/>agment.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor595"/>Exercise 11.01 – shared ViewModel</h2>
			<p>You have been tasked with building an app with one screen split vertically into two when in portrait mode and horizontally when in landscape mode. The first half contains some text, and below it is<a id="_idIndexMarker936"/> <span class="No-Break">a button.</span></p>
			<p>The second half contains only text. When the screen is opened, the text in both halves displays <strong class="bold">Total: 0</strong>. When the button is clicked, the text will change to <strong class="bold">Total: 1</strong>. When clicked again, the text will change to <strong class="bold">Total: 2</strong>, and so on. When the device is rotated, the last total will be displayed in the <span class="No-Break">new orientation.</span></p>
			<p>To solve this task, we will define <span class="No-Break">the following:</span></p>
			<ul>
				<li>An activity that will hold two fragments – one layout for portrait and another <span class="No-Break">for landscape</span></li>
				<li>One fragment with one layout containing <strong class="source inline">TextView</strong> and <span class="No-Break">a button</span></li>
				<li>One fragment with one layout <span class="No-Break">containing </span><span class="No-Break"><strong class="source inline">TextView</strong></span></li>
				<li>One <strong class="source inline">ViewModel</strong> that will be shared between the <span class="No-Break">two fragments</span></li>
			</ul>
			<p>Let’s begin by setting up <span class="No-Break">our configurations:</span></p>
			<ol>
				<li>Create a new project in Android Studio and add an empty activity <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">SplitActivity</strong></span><span class="No-Break">.</span></li>
				<li>Let’s add the <strong class="source inline">ViewModel</strong> library <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
    implementation "androidx.lifecycle:
    lifecycle-viewmodel-ktx:2.5.1"</pre></li>
				<li>Add the following strings <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">values/strings.xml</strong></span><span class="No-Break">:</span><pre class="source code">
    &lt;string name="press_me"&gt;Press Me&lt;/string&gt;
    &lt;string name="total"&gt;Total %d&lt;/string&gt;</pre></li>
				<li>Create and <span class="No-Break">define </span><span class="No-Break"><strong class="source inline">SplitFragmentOne</strong></span><span class="No-Break">:</span><pre class="source code">
class SplitFragmentOne : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(
        R.layout.fragment_split_one, container, false)
    }
    override fun onViewCreated(view: View,
        savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.findViewById&lt;TextView&gt;
            (R.id.fragment_split_one_text_view)
                .text = getString(R.string.total, 0)
    }
}</pre></li>
				<li>Add the <strong class="source inline">fragment_split_one.xml</strong> file to<a id="_idIndexMarker937"/> the <span class="No-Break"><strong class="source inline">res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android=
    "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/fragment_split_one_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
    &lt;Button
        android:id="@+id/fragment_split_one_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/press_me" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Now, let’s <a id="_idIndexMarker938"/>create and <span class="No-Break">define </span><span class="No-Break"><strong class="source inline">SplitFragmentTwo</strong></span><span class="No-Break">:</span><pre class="source code">
class SplitFragmentTwo : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        Return inflater.inflate(
        R.layout.fragment_split_two, container, false)
    }
    override fun onViewCreated(view: View,
        savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.findViewById&lt;TextView&gt; (
        R.id.fragment_split_two_text_view).text =
        getString(R.string.total, 0)
    }
}</pre></li>
				<li>Add the <strong class="source inline">fragment_split_two.xml</strong> file to<a id="_idIndexMarker939"/> the <span class="No-Break"><strong class="source inline">res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android =
    "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/fragment_split_two_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li><span class="No-Break">Define </span><span class="No-Break"><strong class="source inline">SplitActivity</strong></span><span class="No-Break">:</span><pre class="source code">
class SplitActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_split)
    }
}</pre></li>
				<li>Create the <strong class="source inline">activity_split.xml</strong> file in the <span class="No-Break"><strong class="source inline">res/layout</strong></span><span class="No-Break"> folder:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_1"
        <strong class="bold">android:name="{package.path}.SplitFragmentOne"</strong>
        android:layout_width="match_parent"
        /&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_2"
        <strong class="bold">android:name="{package.path}.SplitFragmentTwo"</strong>
        android:layout_width="match_parent"
        /&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>The complete code for this <a id="_idIndexMarker940"/>step can be found <span class="No-Break">at </span><a href="https://packt.link/HPy9p"><span class="No-Break">https://packt.link/HPy9p</span></a><span class="No-Break">.</span></p>
			<p>Replace <strong class="source inline">{package.path}</strong> with the name of the package in which your Fragments <span class="No-Break">are located.</span></p>
			<ol>
				<li value="10">Next, let’s create a <strong class="source inline">layout-land</strong> folder in the <strong class="source inline">res</strong> folder. Then, in the <strong class="source inline">layout-land</strong> folder, we’ll create an <strong class="source inline">activity_split.xml</strong> file with the <span class="No-Break">following layout:</span><pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_1"
        <strong class="bold">android:name="{package.path}.SplitFragmentOne"</strong>
        /&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_2"
        <strong class="bold">android:name="{package.path}.SplitFragmentTwo"</strong>
        /&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/1zRQa"><span class="No-Break">https://packt.link/1zRQa</span></a><span class="No-Break">.</span></p>
			<p>Replace <strong class="source inline">{package.path}</strong> with the name of the package in which your Fragments are located. Notice the <a id="_idIndexMarker941"/>same <strong class="source inline">android:id</strong> attribute in both the <strong class="source inline">activity_split.xml</strong> files. This allows the operating system to correctly save and restore the fragment’s state <span class="No-Break">during rotation.</span></p>
			<ol>
				<li value="11">In the <strong class="source inline">main/java</strong> folder in the root package, create a <strong class="source inline">TotalsViewModel</strong> that looks <span class="No-Break">like this:</span><pre class="source code">
class TotalsViewModel : ViewModel() {
    var total = 0
    fun increaseTotal(): Int {
        total++
        return total
    }
}</pre></li>
			</ol>
			<p>Notice that we extended from the <strong class="source inline">ViewModel</strong> class, which is part of the lifecycle library. In the <strong class="source inline">ViewModel</strong> class, we defined one method that increases the total value and returns the <span class="No-Break">updated value.</span></p>
			<ol>
				<li value="12">Now, add the <strong class="source inline">updateText</strong> and <strong class="source inline">prepareViewModel</strong> methods to the <span class="No-Break"><strong class="source inline">SplitFragment1</strong></span><span class="No-Break"> fragment:</span><pre class="source code">
class SplitFragmentOne : Fragment() {
    …
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        …
        <strong class="bold">prepareViewModel()</strong>
    }
<strong class="bold">    private fun prepareViewModel() {</strong>
<strong class="bold">}</strong>
<strong class="bold">    private fun updateText(total: Int) {</strong>
<strong class="bold">        view?.findViewById&lt;TextView&gt;</strong>
<strong class="bold">        (R.id.fragment_split_one_text_view)?.text =</strong>
<strong class="bold">        getString(R.string.total, total)</strong>
<strong class="bold">    }</strong>
}</pre></li>
				<li>In the <strong class="source inline">prepareViewModel()</strong> function, let’s <a id="_idIndexMarker942"/>start adding <span class="No-Break">our </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
private fun prepareViewModel() {
    <strong class="bold">val totalsViewModel = ViewModelProvider(this)</strong>
<strong class="bold">        .get(TotalsViewModel::class.java)</strong>
}</pre></li>
			</ol>
			<p>This is how the <strong class="source inline">ViewModel</strong> instance is accessed. <strong class="source inline">ViewModelProvider(this)</strong> will bind <strong class="source inline">TotalsViewModel</strong> to the lifecycle of the fragment. <strong class="source inline">.get(TotalsViewModel::class.java)</strong> will retrieve the <strong class="source inline">TotalsViewModel</strong> instance that we <span class="No-Break">defined previously.</span></p>
			<p>If the fragment is being created for the first time, it will produce a new instance, while if the fragment is recreated after a rotation, it will provide the previously created instance. We pass <a id="_idIndexMarker943"/>the class as an argument because a fragment or activity can have multiple ViewModels, and the class serves as an identifier for the type of <strong class="source inline">ViewModel</strong> <span class="No-Break">we want.</span></p>
			<ol>
				<li value="14">Now, set the last known value on <span class="No-Break">the view:</span><pre class="source code">
private fun prepareViewModel() {
    val totalsViewModel = ViewModelProvider(this)
        .get(TotalsViewModel::class.java)
<strong class="bold">    updateText(totalsViewModel.total)</strong>
}</pre></li>
			</ol>
			<p>The second line will help during device rotation. It will set the last total that was computed. If we remove this line and rebuild, then we will see <strong class="bold">Total 0</strong> every time we rotate, and after every click, we will see the previously computed total <span class="No-Break">plus </span><span class="No-Break"><strong class="source inline">1</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="15">Update the View when the <strong class="source inline">fragment_split_one_button</strong> button <span class="No-Break">is clicked:</span><pre class="source code">
private fun prepareViewModel() {
    val totalsViewModel =
        ViewModelProvider(this)
            .get(TotalsViewModel::class.java)
    updateText(totalsViewModel.total)
<strong class="bold">    view?.findViewById&lt;Button&gt;</strong>
<strong class="bold">    (R.id.fragment_split_one_button)</strong>
<strong class="bold">    ?.setOnClickListener {</strong>
<strong class="bold">        updateText(totalsViewModel.increaseTotal())</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>The last few lines indicate that when a click is performed on the button, we tell <strong class="source inline">ViewModel</strong> to recompute the total <a id="_idIndexMarker944"/>and set the <span class="No-Break">new value.</span></p>
			<ol>
				<li value="16">Add the same <strong class="source inline">ViewModel</strong> we used previously to <span class="No-Break">our </span><span class="No-Break"><strong class="source inline">SplitFragmentTwo</strong></span><span class="No-Break">:</span><pre class="source code">
class SplitFragmentTwo : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(
        R.layout.fragment_split_two, container, false)
    }
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val totalsViewModel = ViewModelProvider(this)
            .get(TotalsViewModel::class.java)
<strong class="bold">        updateText(totalsViewModel.total)</strong>
<strong class="bold">    }</strong>
<strong class="bold">    private fun updateText(total: Int) {</strong>
<strong class="bold">        view?.findViewById&lt;TextView&gt; (</strong>
<strong class="bold">        R.id.</strong> <strong class="bold">fragment_split_two_text_view)?.text =</strong>
<strong class="bold">        getString(R.string.total, total)</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>If we run the app now, we’ll see that nothing has changed. The first fragment works as before, but the second<a id="_idIndexMarker945"/> fragment doesn’t get any updates. This is because even though we defined one <strong class="source inline">ViewModel</strong>, we have two instances of that <strong class="source inline">ViewModel</strong> for each of <span class="No-Break">our fragments.</span></p>
			<p>We will need to limit the number of instances to one per fragment. We can achieve this by attaching our <strong class="source inline">ViewModel</strong> to the <strong class="source inline">SplitActivity</strong> lifecycle using a method <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">requireActiviy</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="17">Let’s modify our fragments. In both fragments, we need to find and change the <span class="No-Break">following code:</span><pre class="source code">
val totalsViewModel = ViewModelProvider(this).get(TotalsViewModel::class.java)</pre></li>
			</ol>
			<p>We will change it to <span class="No-Break">the following:</span></p>
			<pre class="source code">
val totalsViewModel = ViewModelProvider(requireActivity()) .get(TotalsViewModel::class.java)</pre>
			<p class="callout heading">Note</p>
			<p class="callout">Using ViewModels to communicate between fragments will only work when the fragments are placed in the <span class="No-Break">same activity.</span></p>
			<p>If we run the application, we <a id="_idIndexMarker946"/>should see <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B19411_11_03.jpg" alt="Figure 11.3 – Output of ﻿Exercise 11.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Output of Exercise 11.01</p>
			<p>When the button is clicked, the total updates are on the top half of the screen but not on the bottom half. If we rotate the screen, the last value <strong class="source inline">ViewModel</strong> had will be set on the second screen as well. This means that our application doesn’t react properly to the changes <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">.</span></p>
			<p>This means that we will need a publisher-subscriber approach to monitor changes that occur in our data. In the next section, we will look at some common data streams that ViewModels can use to notify when the data <span class="No-Break">is changed.</span></p>
			<p>In this exercise, we implemented a ViewModel, which was responsible for incrementing an integer value that will be displayed on the screen. In the section that follows, we will connect data streams to react to changes when the number <span class="No-Break">is incremented.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor596"/>Data streams</h1>
			<p>When it comes to data observability, we<a id="_idIndexMarker947"/> have multiple approaches for implementation, whether manually built mechanisms, components from the Java language, third-party components, or finally to solutions developed particularly for Android. When it comes to Android, some of the most common solutions are <strong class="source inline">LiveData</strong>, Flows from the Coroutines components, <span class="No-Break">and RxJava.</span></p>
			<p>The first one we will look at is <strong class="source inline">LiveData</strong>, as it is part of the Android Architecture Components, which means that it is tailored specially to Android. We will then look at how we can use other types of data streams, which we will cover in more depth in<a id="_idTextAnchor597"/> <span class="No-Break">future chapters.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor598"/>LiveData</h2>
			<p><strong class="source inline">LiveData</strong> is a lifecycle-aware component that permits updates to your UI, but only if the UI is in an active state (for<a id="_idIndexMarker948"/> example, if the activity or fragment is in one of the <strong class="source inline">STARTED</strong> or <strong class="source inline">RESUMED</strong> states). To monitor changes on <strong class="source inline">LiveData</strong>, you need an observer combined with a <strong class="source inline">LifecycleOwner</strong>. When the activity is set to an active state, the observers will be notified when <span class="No-Break">changes occur.</span></p>
			<p>If the activity is recreated, then the observer will be destroyed, and a new one will be reattached. Once this happens, the last value of <strong class="source inline">LiveData</strong> will be emitted to allow us to restore the state. Activities and <a id="_idIndexMarker949"/>fragments are <strong class="source inline">LifecycleOwners</strong>, but fragments have a separate <strong class="source inline">LifecycleOwner</strong> for the View states. Fragments have this particular <strong class="source inline">LifecycleOwner</strong> due to their behavior in the <span class="No-Break"><strong class="source inline">BackStack</strong></span><span class="No-Break"> fragment.</span></p>
			<p>When fragments are replaced within the back stack, they are not fully destroyed; only their Views are. Some of the common callbacks that developers use to trigger processing logic are <strong class="source inline">onViewCreated()</strong>, <strong class="source inline">onActivityResumed()</strong>, and <strong class="source inline">onCreateView()</strong>. If we were to register observers for <strong class="source inline">LiveData</strong> in these methods, we might end up with scenarios where multiple observers will be created every time our fragment pops back onto <span class="No-Break">the screen.</span></p>
			<p>When updating a <strong class="source inline">LiveData</strong> model, we are presented with two options: <strong class="source inline">setValue()</strong> and <strong class="source inline">postValue()</strong>. <strong class="source inline">setValue()</strong> will deliver the result immediately and is meant to be called only on the UI thread. On the other hand, <strong class="source inline">postValue()</strong> can be called on any thread. When <strong class="source inline">postValue()</strong> is called, <strong class="source inline">LiveData</strong> will schedule an update of the value on the UI thread and update the value when the UI thread <span class="No-Break">becomes free.</span></p>
			<p>In the <strong class="source inline">LiveData</strong> class, these methods are protected, which means that there are subclasses that allow us to change the data. <strong class="source inline">MutableLiveData</strong> makes the methods public, which gives us a simple solution for observing data in most cases. <strong class="source inline">MediatorLiveData</strong> is a specialized implementation of <strong class="source inline">LiveData</strong> that allows us to merge multiple <strong class="source inline">LiveData</strong> objects into one (this is useful in situations where our data is kept in different repositories and we want to show a <span class="No-Break">combined result).</span></p>
			<p><strong class="source inline">TransformLiveData</strong> is another<a id="_idIndexMarker950"/> specialized implementation that allows us to convert one object into another (this helps us in situations where we grab <a id="_idIndexMarker951"/>data from one repository and we want to request data from another repository that depends on the previous data, as well as in situations where we want to apply extra logic to a result from <span class="No-Break">a repository).</span></p>
			<p><strong class="source inline">Custom LiveData</strong> allows us to create our own <strong class="source inline">LiveData</strong> implementations (usually when we periodically receive updates, such as the odds in a sports betting app, stock market updates, and Facebook and <span class="No-Break">Twitter feeds).</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">It is a common practice to use <strong class="source inline">LiveData</strong> in <strong class="source inline">ViewModel</strong>. Holding <strong class="source inline">LiveData</strong> in a fragment or activity will cause losses in data when configuration <span class="No-Break">changes occur.</span></p>
			<p>The following diagram shows how <strong class="source inline">LiveData</strong> is connected to the lifecy<a id="_idTextAnchor599"/>cle <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">LifecycleOwner</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B19411_11_04.jpg" alt="Figure 11.4 – The relationship between LiveData and lifecycle observers with LifecycleOwner﻿"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – The relationship between LiveData and lifecycle observers with LifecycleOwner</p>
			<p class="callout heading">Note</p>
			<p class="callout">We can register multiple observers for <strong class="source inline">LiveData</strong>, and each observer can be registered for a different <strong class="source inline">LifecycleOwner</strong>. In this situation, <strong class="source inline">LiveData</strong> will become inactive, but only when all the observers <span class="No-Break">are inactive.</span></p>
			<p>In this section, we<a id="_idIndexMarker952"/> looked at how the <strong class="source inline">LiveData</strong> component works and<a id="_idIndexMarker953"/> the benefits it provides for observing data from activities and fragments with regard to their lifecycles. In the following section, we will look at an exer<a id="_idTextAnchor600"/><a id="_idTextAnchor601"/>cise t<a id="_idTextAnchor602"/>hat <span class="No-Break">uses </span><span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break">.</span></p>
			<h3>Exercise 11.02 – observing with LiveData</h3>
			<p>Modify <em class="italic">Exercise 11.01 – shared ViewModel</em> so that when the button is clicked, both fragments will be updated with<a id="_idIndexMarker954"/> the total number <span class="No-Break">of clicks.</span></p>
			<p>Perform the following steps to <span class="No-Break">achieve this:</span></p>
			<ol>
				<li>Add the <strong class="source inline">LiveData</strong> library to the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
implementation "androidx.lifecycle:
lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li><strong class="source inline">TotalsViewModel</strong> should be modified so that it <span class="No-Break">supports </span><span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break">:</span><pre class="source code">
class TotalsViewModel : ViewModel() {
    private val _total = MutableLiveData&lt;Int&gt;()
    val total: LiveData&lt;Int&gt; = _total
    init {
        _total.postValue(0)
    }
    fun increaseTotal() {
        _total.postValue((_total.value ?: 0) + 1)
    }
}</pre></li>
			</ol>
			<p>Here, we created <strong class="source inline">MutableLiveData</strong>, a subclass of <strong class="source inline">LiveData</strong> that allows us to change the value of the data. When <strong class="source inline">ViewModel</strong> is created, we set the default value of <strong class="source inline">0</strong>, and then<a id="_idIndexMarker955"/> when we increase the total, we post the previous value <span class="No-Break">plus </span><span class="No-Break"><strong class="source inline">1</strong></span><span class="No-Break">.</span></p>
			<p>The reason we have duplicated representations for the total is that we wanted to keep the mutable component private to the class while exposing the non-mutable total to be observed by <span class="No-Break">other objects.</span></p>
			<ol>
				<li value="3">Now, we need to modify our fragments so that they adjust to the new <strong class="source inline">ViewModel</strong>. For <strong class="source inline">SplitFragmentOne</strong>, we do <span class="No-Break">the following:</span><pre class="source code">
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
            val totalsViewModel =
             ViewModelProvider(requireActivity())
                 .get(TotalsViewModel::class.java)
        totalsViewModel.total.observe(
        viewLifecycleOwner, {
            updateText(it)
        })
        view.findViewById&lt;Button&gt;(
        R.id.fragment_split_one_button)
        .setOnClickListener {
            totalsViewModel.increaseTotal()
        }
    }</pre></li>
				<li>For <strong class="source inline">SplitFragmentTwo</strong>, we do<a id="_idIndexMarker956"/> <span class="No-Break">the following:</span><pre class="source code">
    override fun onViewCreated(view: View,
        savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val totalsViewModel =
            ViewModelProvider(requireActivity())
                .get(TotalsViewModel::class.java)
        totalsViewModel.total.observe(
        viewLifecycleOwner, {
            updateText(it)
        })
    }</pre></li>
			</ol>
			<p>If we look at the following <span class="No-Break">line:</span><span class="No-Break"><strong class="source inline"> totalsViewModel.getTotal().observe(view</strong></span><strong class="source inline">
LifecycleOwner, { updateText(it)})</strong>, the <strong class="source inline">LifecycleOwner</strong> parameter for the <strong class="source inline">observe</strong> method is called <strong class="source inline">viewLifecycleOwner</strong>. This is inherited from the <strong class="source inline">fragment</strong> class, and it helps when we observe data while the View that the fragment manages is being rendered. In our example, swapping <strong class="source inline">viewLifecycleOwner</strong> with <strong class="source inline">this</strong> would not have caused <span class="No-Break">an impact.</span></p>
			<p>But if our fragment had been<a id="_idIndexMarker957"/> part of a back stack feature, then there would have been the risk of creating multiple observers, which would have led to being notified multiple times for the <span class="No-Break">same dataset.</span></p>
			<ol>
				<li value="5">Now, let’s write a test for our new <strong class="source inline">ViewModel</strong>. We will name it <strong class="source inline">TotalsViewModelTest</strong> and place it in the <strong class="source inline">test</strong> package, not <strong class="source inline">androidTest</strong>. This is because we want this test to execute on our workstation, not <span class="No-Break">the device:</span><pre class="source code">
class TotalsViewModelTest {
    private lateinit var totalsViewModel:
        TotalsViewModel
    @Before
    fun setUp() {
        totalsViewModel = TotalsViewModel()
        assertEquals(0, totalsViewModel.total.value)
    }
    @Test
    fun increaseTotal() {
        val total = 5
        for (i in 0 until total) {
            totalsViewModel.increaseTotal()
        }
        assertEquals(4, totalsViewModel.total.value)
    }
}</pre></li>
				<li>In the preceding test, before testing begins, we assert that the initial value of <strong class="source inline">LiveData</strong> is set to <strong class="source inline">0</strong>. Then, we write a small test in which we increase the total five times, and we assert that the final value is <strong class="source inline">5</strong>. Let’s run the test and see <span class="No-Break">what happens:</span><pre class="source code">
java.lang.RuntimeException: Method getMainLooper in
android.os.Looper not mocked.</pre></li>
				<li>A message similar to the preceding one will appear. This is because of how <strong class="source inline">LiveData</strong> is implemented. Internally, it uses Handlers and Loopers, part of the Android framework, thus <a id="_idIndexMarker958"/>preventing us from executing the test. Luckily, there is a way around this. We will need the following configuration in our Gradle file for <span class="No-Break">our test:</span><pre class="source code">
testImplementation "androidx.arch.core:
core-testing:2.1.0"</pre></li>
				<li>This adds a testing library to our testing code, not our application code. Now, let’s add the following line to our code above the instantiation of the <span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break"> class:</span><pre class="source code">
class TotalsViewModelTest {
    @get:Rule
    val rule = InstantTaskExecutorRule()
    private val totalsViewModel = TotalsViewModel()</pre></li>
			</ol>
			<p>We have added a <strong class="source inline">TestRule</strong> that says every time <strong class="source inline">LiveData</strong> has its value changed, it will make the change instantly and will avoid using the Android <span class="No-Break">Framework components.</span></p>
			<p>Every test we write in this class will be impacted by this rule, thus giving us the freedom to play with the <strong class="source inline">LiveData</strong> class for each new test method. If we run the test again, we will<a id="_idIndexMarker959"/> see <span class="No-Break">the following:</span></p>
			<pre class="source code">
java.lang.RuntimeException: Method getMainLooper in
android.os.Looper not mocked</pre>
			<ol>
				<li value="9">Does this mean that our new rule didn’t work? Not exactly. If you look in your <strong class="source inline">TotalsViewModels</strong> class, you’ll <span class="No-Break">see this:</span><pre class="source code">
init {
         total.postValue(0)
}</pre></li>
				<li>This means that because we created the <strong class="source inline">ViewModel</strong> class outside of the rule’s scope, the rule will not apply. We can do two things to avoid this scenario: we can change our code to handle a null value that will be sent when we first subscribe to the <strong class="source inline">LiveData</strong> class, or we can adjust our test so that we put the <strong class="source inline">ViewModel</strong> class in the scope of the rule. Let’s go with the second approach and change how we create our <strong class="source inline">ViewModel</strong> class in the test. It should look something <span class="No-Break">like this:</span><pre class="source code">
@get:Rule
val rule = InstantTaskExecutorRule()
private lateinit var totalsViewModel: TotalsViewModel
@Before
fun setUp() {
    totalsViewModel = TotalsViewModel()
    assertEquals(0, totalsViewModel.total.value)
}</pre></li>
				<li>Let’s run the test again and see <span class="No-Break">what happens:</span><pre class="source code">
java.lang.AssertionError:
Expected :4
Actual :5</pre></li>
			</ol>
			<p>See whether you can <a id="_idIndexMarker960"/>spot where the error in the test <a id="_idTextAnchor603"/>is, fix it, and then <span class="No-Break">rerun it:</span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B19411_11_05.jpg" alt="Figure 11.5 – Output of ﻿Exercise 11.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Output of Exercise 11.02</p>
			<p>The same output in landsca<a id="_idTextAnchor604"/>pe mode will look <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B19411_11_06.jpg" alt="Figure 11.6 – Output of ﻿Exercise 11.02 in landscape mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Output of Exercise 11.02 in landscape mode</p>
			<p>By looking at the preceding example, we can see how using a combination of the <strong class="source inline">LiveData</strong> and <strong class="source inline">ViewModel</strong> approaches <a id="_idIndexMarker961"/>helped us solve our problem while considering the particularities of the Android <span class="No-Break">operating system:</span></p>
			<ul>
				<li><strong class="source inline">ViewModel</strong>: This helped us hold the data across device orientation changes, and it solved the issue of communicating <span class="No-Break">between fragments</span></li>
				<li><strong class="source inline">LiveData</strong>: This helped us retrieve the most up-to-date information that we’ve processed while considering the <span class="No-Break">fragment’s lifecycle</span></li>
				<li>The combination of the two helped us efficiently delegate our processing logic, allowing us to u<a id="_idTextAnchor605"/><a id="_idTextAnchor606"/>nit test this <span class="No-Break">processing logic</span></li>
			</ul>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor607"/>Additional data streams</h2>
			<p>One type of data stream that has<a id="_idIndexMarker962"/> gained popularity recently is the usage of Coroutines and Flows, mainly for their approach to asynchronous operations in Android. An example of Flows emitting data in a <strong class="source inline">ViewModel</strong> would be <span class="No-Break">as follows:</span></p>
			<pre class="source code">
class TotalsViewModel : ViewModel() {
    private val _total = MutableStateFlow(0)
    val total: StateFlow&lt;Int&gt; = _total
    fun increaseTotal() {
        _total.value = _total.value + 1
    }
}</pre>
			<p>In the preceding snippet, we have the two total declarations for public and private usage. Instead of <strong class="source inline">LiveData</strong>, we use <strong class="source inline">StateFlow</strong>, which will emit the current value and all subsequent new values when we subscribe to it. Because it emits the last value, we must always set an initial<a id="_idIndexMarker963"/> value when we initialize it. If we want to subscribe to changes in the total value, we can use <span class="No-Break">the following:</span></p>
			<pre class="source code">
        val totalsViewModel =
            ViewModelProvider(requireActivity())
                .get(TotalsViewModel::class.java)
        viewLifecycleOwner.lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.CREATED) {
                totalsViewModel.total.collect {
                    updateText(it)
                }
            }
        }</pre>
			<p>The preceding snippet will subscribe to <strong class="source inline">StateFlow</strong> every time <strong class="source inline">viewLifecycleOwner</strong> enters the <strong class="source inline">CREATED</strong> stage. This will connect <strong class="source inline">StateFlow</strong> with the lifecycle of <strong class="source inline">Fragment</strong> to prevent any possible leaks. We will explore the mechanics of Flows and Coroutines in <span class="No-Break">future chapters.</span></p>
			<p>Another example of a data stream is the RxJava library, which represents another mechanism for emitting data. The library is best used for performing asynchronous work and transformations, and because it’s based on Java and not the Android operating system, it lacks any lifecycle awareness. For example, using RxJava in combination with ViewModels would look like <span class="No-Break">the following:</span></p>
			<pre class="source code">
class TotalsViewModel : ViewModel() {
    private val _total = BehaviorSubject.createDefault(0)
    val total: Observable&lt;Int&gt; = _total
    fun increaseTotal() {
        _total.onNext(_total.blockingLast())
    }
}</pre>
			<p>Here, we are using <strong class="source inline">BehaviorSubject</strong> to replace <strong class="source inline">StateFlow</strong>. <strong class="source inline">BehaviorSubject</strong> has the same properties as state flow. It will keep the latest value and emit it when a component subscribes and all the new values after the subscription. Subscribing to the <a id="_idIndexMarker964"/>object looks like <span class="No-Break">the following:</span></p>
			<pre class="source code">
    private var disposable: Disposable? = null
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val totalsViewModel =
            ViewModelProvider(requireActivity())
                .get(TotalsViewModel::class.java)
        disposable = totalsViewModel.total.subscribe {
            updateText(it)
        }
    }
    override fun onDestroyView() {
        disposable?.dispose()
        super.onDestroyView()
    }</pre>
			<p>Here, we are using Disposable to hold the subscription in <strong class="source inline">onViewCreated</strong>. In <strong class="source inline">onDestroyView</strong>, we are disposing of the subscription to prevent any context leaks. This is an alternative to using lifecycle-aware components such as <strong class="source inline">LiveData</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">StateFlow</strong></span><span class="No-Break">.</span></p>
			<p>In this section, we looked at other types of streams of data that might be present in Android applications such as<a id="_idIndexMarker965"/> Kotlin Flows and RxJava, and analyzed their particularities. In the section that follows, we will look at how we can persist da<a id="_idTextAnchor608"/>ta us<a id="_idTextAnchor609"/>ing the <span class="No-Break">Room library.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor610"/>Room</h1>
			<p>The Room persistence library<a id="_idIndexMarker966"/> acts as a wrapper between your application code and the SQLite storage. You can think of SQLite as a database that runs without its own <a id="_idIndexMarker967"/>server and saves all the application data in an internal file that’s only accessible to your application (if the device is <span class="No-Break">not rooted).</span></p>
			<p>Room sits between the application code and the SQLite Android Framework, and handles the<a id="_idIndexMarker968"/> necessary <strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, and <strong class="bold">delete</strong> (<strong class="bold">CRUD</strong>) operations while exposing an abstraction that your application can use to define the data and how you want the data to be handled. This abstraction comes in the form of the <span class="No-Break">following objects:</span></p>
			<ul>
				<li><strong class="bold">Entities</strong>: You can specify how you want your data to be stored and the relationships between <span class="No-Break">your data</span></li>
				<li><strong class="bold">Data access object</strong> (<strong class="bold">DAO</strong>): The operations<a id="_idIndexMarker969"/> that can be done on <span class="No-Break">your data</span></li>
				<li><strong class="bold">Database</strong>: You can specify the configurations that your database should have (the name of the database and <span class="No-Break">migration scenarios)</span></li>
			</ul>
			<p>These <a id="_idTextAnchor611"/>can be seen in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B19411_11_07.jpg" alt="Figure 11.7 – The relationship between your application and the Room components"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – The relationship between your application and the Room components</p>
			<p>In the preceding diagram, we can see how the Room components interact with each other. It’s easier to visualize this <a id="_idIndexMarker970"/>with an example. Let’s assume you want to make a messaging app and store each message in your local storage. In this case, <strong class="source inline">Entity</strong> would be a <strong class="source inline">Message</strong> object, which will have an ID and will contain the contents of the message, the sender, the time, status, and <span class="No-Break">so on.</span></p>
			<p>In order to access messages from the local storage, you will need <strong class="source inline">MessageDao</strong>, which will contain methods such as <strong class="source inline">insertMessage()</strong>, <strong class="source inline">getMessagesFromUser()</strong>, <strong class="source inline">deleteMessage()</strong>, and <strong class="source inline">updateMessage()</strong>. In addition, since it’s a messaging application, you will need a <strong class="source inline">Contact</strong> entity to hold information about the senders and receivers of <span class="No-Break">a message.</span></p>
			<p>The <strong class="source inline">Contact</strong> entity will contain information such as a name, last time online, phone number, email, and so on. In order to access the contact information, you will need a <strong class="source inline">ContactDao</strong> interface, which will contain <strong class="source inline">createUser()</strong>, <strong class="source inline">updateUser()</strong>, <strong class="source inline">deleteUser()</strong>, and <strong class="source inline">getAllUsers()</strong>. Both entities will create a matching table in SQLite, which contains the fields we defined inside the entity classes as columns. In order to achieve this, we’ll have to create <strong class="source inline">MessagingDatabase</strong> in which we will reference <span class="No-Break">both entities.</span></p>
			<p>In a world without Room or similar DAO libraries, we would need to use the Android Framework’s SQLite components. This typically involves code when setting up our database, such as a query to create a table and applying similar queries for every table we would have. Every time we queried a table for data, we would need to convert the resulting object into a Java or <span class="No-Break">Kotlin one.</span></p>
			<p>By default, Room does not allow any operations on the UI thread to enforce the Android standards related to input-output operations. To make asynchronous calls to access data, Room is compatible with a number of libraries and frameworks, such as Kotlin coroutines, RxJava, and <strong class="source inline">LiveData</strong>, on top of its <span class="No-Break">default definitions.</span></p>
			<p>We should now <a id="_idIndexMarker971"/>have an overview of how Room works and its main components. We will now look over each of these components and ho<a id="_idTextAnchor612"/><a id="_idTextAnchor613"/>w we can <a id="_idTextAnchor614"/>use them for <span class="No-Break">data persistence.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor615"/>Entities</h2>
			<p>Entities serve two purposes: to define the structure of tables and to hold the data from a table row. Let’s use our scenario <a id="_idIndexMarker972"/>of the messaging app and define two entities: one for the<a id="_idIndexMarker973"/> user and one for <span class="No-Break">the message.</span></p>
			<p>The <strong class="source inline">User</strong> entity will contain information about who sent the messages, while the <strong class="source inline">Message</strong> entity will contain information about the contents of a message, the time it was sent, and a reference to the sender of the message. The following code snippet provides an example of how entities are defined <span class="No-Break">with Room:</span></p>
			<pre class="source code">
<strong class="bold">@Entity</strong>(tableName = "messages")
data class Message(
    <strong class="bold">@PrimaryKey</strong>(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    <strong class="bold">@ColumnInfo</strong>(name = "text", defaultValue = "") val text:
        String,
    <strong class="bold">@ColumnInfo</strong>(name = "time") val time: Long,
    <strong class="bold">@ColumnInfo</strong>(name = "user") val userId: Long,
)
<strong class="bold">@Entity</strong>(tableName = "users")
data class User(
    <strong class="bold">@PrimaryKey @ColumnInfo</strong>(name = "user_id") val id: Long,
    <strong class="bold">@ColumnInfo</strong>(name = "first_name") val firstName: String,
    <strong class="bold">@ColumnInfo</strong>(name = "last_name") val lastName: String,
    <strong class="bold">@ColumnInfo</strong>(name = "last_online") val lastOnline: Long
)</pre>
			<p>As you can see, entities are just <em class="italic">data classes</em> with annotations, which will tell Room how the tables should be built in<a id="_idIndexMarker974"/> SQLite. The annotations we used are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The <strong class="source inline">@Entity</strong> annotation defines the table. By default, the table name will be the name of the class. We can change the name of the table through the <strong class="source inline">tableName</strong> method in the <strong class="source inline">Entity</strong> annotation. This is useful in situations where we want our<a id="_idIndexMarker975"/> code obfuscated but wish to keep the consistency of the <span class="No-Break">SQLite structure.</span></li>
				<li><strong class="source inline">@ColumnInfo</strong> defines configurations for a certain column. The most common one is the name of the column. We can also specify a default value, the SQLite type of the field, and whether the field should <span class="No-Break">be indexed.</span></li>
				<li><strong class="source inline">@PrimaryKey</strong> indicates what in our entity will make it unique. Every entity should have at least one primary key. If your primary key is an integer or a long, then we can add the <strong class="source inline">autogenerate</strong> field. This means that every entity that gets inserted into the <strong class="source inline">Primary Key</strong> field is automatically generated <span class="No-Break">by SQLite.</span></li>
			</ul>
			<p>Usually, this is done by incrementing the previous ID. If you wish to define multiple fields as primary keys, then you can adjust the <strong class="source inline">@Entity</strong> annotation to accommodate this, such as <span class="No-Break">the following:</span></p>
			<pre class="source code">
@Entity(tableName = "messages", primaryKeys = ["id",
"time"])</pre>
			<p>Let’s assume that our messaging application wants to send locations. Locations have a latitude, longitude, and name. We can add them to the <strong class="source inline">Message</strong> class, but that would increase the complexity of the class. What we can do is create another entity and reference the ID in <span class="No-Break">our class.</span></p>
			<p>The problem with this approach is that we would then query the <strong class="source inline">Location</strong> entity every time we queried the <strong class="source inline">Message</strong> entity. Room <a id="_idIndexMarker976"/>has a third approach through the <strong class="source inline">@Embedded</strong> annotation. Now, let’s look at the updated <span class="No-Break"><strong class="source inline">Message</strong></span><span class="No-Break"> entity:</span></p>
			<pre class="source code">
@Entity(tableName = "messages")
data class Message(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    @ColumnInfo(name = "text", defaultValue = "") val text:
        String,
    @ColumnInfo(name = "time") val time: Long,
    @ColumnInfo(name = "user") val userId: Long,
    <strong class="bold">@Embedded</strong> val location: Location?
)
data class Location(
    @ColumnInfo(name = "lat") val lat: Double,
    @ColumnInfo(name = "long") val log: Double,
    @ColumnInfo(name = "location_name") val name: String
)</pre>
			<p>This code adds three<a id="_idIndexMarker977"/> columns (<strong class="source inline">lat</strong>, <strong class="source inline">long</strong>, and <strong class="source inline">location_name</strong>) to the messages table. This allows us to avoid having objects with a large number of fields while keeping the consistency of <span class="No-Break">our tables.</span></p>
			<p>If we look at our entities, we’ll see that they exist independently. The <strong class="source inline">Message</strong> entity has a <strong class="source inline">userId</strong> field, but nothing is preventing us from adding messages from invalid users. This may lead to situations where we collect data without any purpose. If we want to delete a particular user, along with their messages, we must do so manually. Room provides us with a way to define this relationship using <span class="No-Break">a </span><span class="No-Break"><strong class="source inline">ForeignKey</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
@Entity(
    tableName = "messages",
    <strong class="bold">foreignKeys = [ForeignKey(</strong>
<strong class="bold">        entity = User::class,</strong>
<strong class="bold">        parentColumns = ["user_id"],</strong>
<strong class="bold">        childColumns = ["user"],</strong>
<strong class="bold">        onDelete = ForeignKey.CASCADE</strong>
<strong class="bold">    )]</strong>
)
data class Message(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    @ColumnInfo(name = "text", defaultValue = "") val text:
        String,
    @ColumnInfo(name = "time") val time: Long,
    @ColumnInfo(name = "user") val userId: Long,
    @Embedded val location: Location?
)</pre>
			<p>In the preceding example, we added the <strong class="source inline">foreignKeys</strong> field and created a new <strong class="source inline">ForeignKey</strong> to the <strong class="source inline">User</strong> entity, while for the parent column, we defined the <strong class="source inline">user_id</strong> field in the <strong class="source inline">User</strong> class, and<a id="_idIndexMarker978"/> for the child column, the <strong class="source inline">user</strong> field in the <span class="No-Break"><strong class="source inline">Message</strong></span><span class="No-Break"> class.</span></p>
			<p>Every time we add a <a id="_idIndexMarker979"/>message to the table, there needs to be a <strong class="source inline">User</strong> entry in the <strong class="source inline">users</strong> table. If we try to delete a user and any messages from that user still exist, then, by default, this will not work because of the dependencies. However, we can tell Room to do a cascade delete, which w<a id="_idTextAnchor616"/><a id="_idTextAnchor617"/>ill erase<a id="_idTextAnchor618"/> the user and the <span class="No-Break">associated messages.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor619"/>DAO</h2>
			<p>If entities specify how we define and hold our data, then DAOs specify what to do with that data. A DAO class is a <a id="_idIndexMarker980"/>place where we define our CRUD operations. Ideally, each entity <a id="_idIndexMarker981"/>should have a corresponding DAO, but there are situations where crossovers occur (usually, this happens when we have to deal with JOINs between <span class="No-Break">two tables).</span></p>
			<p>Continuing with our previous example, let’s build some corresponding DAOs for <span class="No-Break">our entity:</span></p>
			<pre class="source code">
<strong class="bold">@Dao</strong>
interface MessageDao {
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertMessages(vararg messages: Message)
    <strong class="bold">@Update</strong>
    fun updateMessages(vararg messages: Message)
    <strong class="bold">@Delete</strong>
    fun deleteMessages(vararg messages: Message)
    <strong class="bold">@Query</strong>("SELECT * FROM messages")
    fun loadAllMessages(): List&lt;Message&gt;
    <strong class="bold">@Query</strong>("SELECT * FROM messages WHERE user=:userId AND
        time&gt;=:time")
    fun loadMessagesFromUserAfterTime(userId: String, time:
        Long): List&lt;Message&gt;
}
<strong class="bold">@Dao</strong>
interface UserDao {
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(user: User)
    <strong class="bold">@Update</strong>
    fun updateUser(user: User)
    <strong class="bold">@Delete</strong>
    fun deleteUser(user: User)
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): List&lt;User&gt;
}</pre>
			<p>In the case of our messages, we have defined the following functions: insert one or more messages, update one or more messages, delete one or more messages, and retrieve all the messages from a <a id="_idIndexMarker982"/>certain user that are older than a particular time. For our users, we can insert one user, update one user, delete one user, and retrieve all <span class="No-Break">the users.</span></p>
			<p>If you look at our <strong class="source inline">Insert</strong> methods, you’ll see<a id="_idIndexMarker983"/> we have defined that in the case of a conflict (when we try to insert something with an ID that already exists), it will replace the existing entry. The <strong class="source inline">Update</strong> field has a similar configuration, but in our case, we have chosen the default. This means that nothing will happen if the update <span class="No-Break">cannot occur.</span></p>
			<p>The <strong class="source inline">@Query</strong> annotation stands out from all the others. This is where we use SQLite code to define how our read operations work. <strong class="source inline">SELECT *</strong> means we want to read all the data for every row in the table, which will populate all our entities’ fields. The <strong class="source inline">WHERE</strong> clause indicates a restriction that we want to apply to our query. We can also define a method <span class="No-Break">like this:</span></p>
			<pre class="source code">
@Query("SELECT * FROM messages WHERE user IN (:userIds) AND time&gt;=:time")
fun loadMessagesFromUserAfterTime(userIds: List&lt;String&gt;, time: Long): List&lt;Message&gt;</pre>
			<p>This allows us to filter messages from multiple users. We can define a new class <span class="No-Break">like this:</span></p>
			<pre class="source code">
data class TextWithTime(
    @ColumnInfo(name = "text") val text: String,
    @ColumnInfo(name = "time") val time: Long
)</pre>
			<p>Now, we can define the <span class="No-Break">following query:</span></p>
			<pre class="source code">
@Query("SELECT text,time FROM messages")
fun loadTextsAndTimes(): List&lt;TextWithTime&gt;</pre>
			<p>This will allow us to extract information from certain columns at a time, not the <span class="No-Break">entire row.</span></p>
			<p>Now, let’s say that you want to <a id="_idIndexMarker984"/>add the user information of the sender to every message. Here, we’ll need to use a similar approach to the one we <span class="No-Break">used previously:</span></p>
			<pre class="source code">
data class MessageWithUser(
    @Embedded val message: Message,
    @Embedded val user: User
)</pre>
			<p>By using the new data class, we can define <span class="No-Break">this query:</span></p>
			<pre class="source code">
@Query("SELECT * FROM messages INNER JOIN users on users.user_id=messages.user")
fun loadMessagesAndUsers(): List&lt;MessageWithUser&gt;</pre>
			<p>We now have the user information<a id="_idIndexMarker985"/> for every message we want to display. This will come in handy in scenarios such as group chats, where we sh<a id="_idTextAnchor620"/>ould display the name of the sender of <span class="No-Break">every message.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor621"/>Setting up the database</h2>
			<p>What we have<a id="_idIndexMarker986"/> learned about so far is a bunch of DAOs and entities. Now, it’s time to put them together. First, let’s define <span class="No-Break">our database:</span></p>
			<pre class="source code">
<strong class="bold">@Database(entities = [User::class, Message::class],</strong>
<strong class="bold">version = 1)</strong>
abstract class ChatDatabase : RoomDatabase() {
    companion object {
        private lateinit var chatDatabase: ChatDatabase
        fun getDatabase(applicationContext: Context):
        ChatDatabase {
            if (!(::chatDatabase.isInitialized)) {
                chatDatabase =
                    Room.databaseBuilder(applicationContext
                    , chatDatabase::class.java, "chat-db")
                    .build()
            }
            return chatDatabase
        }
    }
    <strong class="bold">abstract fun userDao(): UserDao</strong>
    <strong class="bold">abstract fun messageDao(): MessageDao</strong>
}</pre>
			<p>In the <strong class="source inline">@Database</strong> annotation, we specify what entities go in our database and our version. Then, for every DAO, we define an abstract method in <strong class="source inline">RoomDatabase</strong>. This allows the build system to build a<a id="_idIndexMarker987"/> subclass of our class in which it provides the implementations for these methods. The build system will also create the tables related to <span class="No-Break">our entities.</span></p>
			<p>The <strong class="source inline">getDatabase</strong> method in the companion object illustrates how we create an instance of the <strong class="source inline">ChatDatabase</strong> class. Ideally, there should be one instance of the database for our application due to the complexity involved in building a new database object. However, this can be better achieved through a dependency <span class="No-Break">injection framework.</span></p>
			<p>Let’s assume you’ve released your chat application. Your database is currently version one, but your users are complaining that the message status feature is missing. You decide to add this feature in the next release. This involves changing the database structure, which can impact databases that have already built <span class="No-Break">their structures.</span></p>
			<p>Luckily, Room offers something called a migration. In the migration, we can define how our database changed<a id="_idIndexMarker988"/> between versions 1 and 2. So, let’s look at <span class="No-Break">our example:</span></p>
			<pre class="source code">
data class Message(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    @ColumnInfo(name = "text", defaultValue = "") val text:
        String,
    @ColumnInfo(name = "time") val time: Long,
    @ColumnInfo(name = "user") val userId: Long,
    <strong class="bold">@ColumnInfo(name = "status") val status: Int,</strong>
    @Embedded val location: Location?
)</pre>
			<p>Here, we added the status<a id="_idIndexMarker989"/> flag to the <strong class="source inline">Message</strong> entity. Now, let’s look <span class="No-Break">at </span><span class="No-Break"><strong class="source inline">ChatDatabase</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
Database(entities = [User::class, Message::class],
<strong class="bold">version = 2</strong>)
abstract class ChatDatabase : RoomDatabase() {
    companion object {
        private lateinit var chatDatabase: ChatDatabase
        <strong class="bold">private val MIGRATION_1_2 = object : Migration(1,</strong>
<strong class="bold">        2) {</strong>
<strong class="bold">            override fun migrate(database:</strong>
<strong class="bold">            SupportSQLiteDatabase) {</strong>
<strong class="bold">                database.execSQL("ALTER TABLE messages ADD</strong>
<strong class="bold">                    COLUMN status INTEGER")</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
        fun getDatabase(applicationContext: Context):
        ChatDatabase {
            if (!(::chatDatabase.isInitialized)) {
                chatDatabase =
                   Room.databaseBuilder(applicationContext,
                   chatDatabase::class.java, "chat-db")
                   <strong class="bold">.addMigrations(MIGRATION_1_2)</strong>
                   .build()
            }
            return chatDatabase
        }
    }
    abstract fun userDao(): UserDao
    abstract fun messageDao(): MessageDao
}</pre>
			<p>In our database, we’ve increased the version to <strong class="source inline">2</strong> and added a migration between versions <strong class="source inline">1</strong> and <strong class="source inline">2</strong>. Here, we added the <strong class="source inline">status</strong> column to the table. We’ll add this migration when we build <span class="No-Break">the database.</span></p>
			<p>Once we’ve released the<a id="_idIndexMarker990"/> new code, when the updated app is opened and the code to build the database is executed, it will compare the version of the stored data with the one specified in our class and notice a difference. Then, it will execute the specified migrations until it reaches the latest version. This allows us to maintain an application for years without impacting the <span class="No-Break">user’s experience.</span></p>
			<p>If you look at our <strong class="source inline">Message</strong> class, you may have noticed that we defined the time as <strong class="source inline">Long</strong>. In Java and Kotlin, we have the <strong class="source inline">Date</strong> object, which may be more useful than the timestamp of the message. Luckily, Room has a solution for this in the form <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">TypeConverter</strong></span><span class="No-Break">.</span></p>
			<p>The following table shows what data types we can use in our code and the SQLite equivalent. Complex data types need<a id="_idTextAnchor622"/> to be brought down to these levels <span class="No-Break">using TypeConverters:</span></p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B19411_11_08.jpg" alt="Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite data types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite data types</p>
			<p>Here, we’ve <a id="_idIndexMarker991"/>modified the <strong class="source inline">lastOnline</strong> field so that it’s of the <span class="No-Break"><strong class="source inline">Date</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source code">
data class User(
    @PrimaryKey @ColumnInfo(name = "user_id") val id: Long,
    @ColumnInfo(name = "first_name") val firstName: String,
    @ColumnInfo(name = "last_name") val lastName: String,
    <strong class="bold">@ColumnInfo(name = "last_online") val lastOnline: Date</strong>
)</pre>
			<p>Here, we’ve defined a couple of methods that convert a <strong class="source inline">Date</strong> object into <strong class="source inline">Long</strong> and vice versa. The <strong class="source inline">@TypeConverter</strong> annotation helps Room identify where the conversion <span class="No-Break">takes place:</span></p>
			<pre class="source code">
class DateConverter {
    <strong class="bold">@TypeConverter</strong>
    fun from(value: Long?): Date? {
        return value?.let { Date(it) }
    }
    <strong class="bold">@TypeConverter</strong>
    fun to(date: Date?): Long? {
        return date?.time
    }
}</pre>
			<p>Finally, we’ll add our converter to Room using the <strong class="source inline">@</strong><span class="No-Break"><strong class="source inline">TypeConverters</strong></span><span class="No-Break"> annotation:</span></p>
			<pre class="source code">
@Database(entities = [User::class, Message::class],
version = 2)
<strong class="bold">@TypeConverters(DateConverter::class)</strong>
abstract class ChatDatabase : RoomDatabase() {</pre>
			<p>In the <a id="_idTextAnchor623"/><a id="_idTextAnchor624"/>next section, we will look<a id="_idIndexMarker992"/> at some <span class="No-Break">third-party frameworks.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor625"/>Third-party frameworks</h2>
			<p>Room works well with third-party <a id="_idIndexMarker993"/>frameworks such as <strong class="source inline">LiveData</strong>, RxJava, and coroutines. This solves two issues: multi-threading and observing <span class="No-Break">data changes.</span></p>
			<p><strong class="source inline">LiveData</strong> will make the <strong class="source inline">@Query</strong> annotated methods in your DAOs reactive, which means that if new data is added, <strong class="source inline">LiveData</strong> will notify the observers <span class="No-Break">of this:</span></p>
			<pre class="source code">
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): LiveData&lt;List&lt;User&gt;&gt;</pre>
			<p>Kotlin coroutines complement <strong class="source inline">LiveData</strong> by making the <strong class="source inline">@Insert</strong>, <strong class="source inline">@Delete</strong>, and <strong class="source inline">@Update</strong> <span class="No-Break">methods asynchronous:</span></p>
			<pre class="source code">
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: User)
    <strong class="bold">@Update</strong>
    suspend fun updateUser(user: User)
    <strong class="bold">@Delete</strong>
    suspend fun deleteUser(user: User)</pre>
			<p><strong class="bold">RxJava</strong> solves both<a id="_idIndexMarker994"/> issues: making the <strong class="source inline">@Query</strong> methods reactive through components such as <strong class="source inline">Publisher</strong>, <strong class="source inline">Observable</strong>, or <strong class="source inline">Flowable</strong> and making the rest of the methods asynchronous <a id="_idIndexMarker995"/>through <strong class="source inline">Completable</strong>, <strong class="source inline">Single</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source inline">Maybe</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(user: User) : Completable
    <strong class="bold">@Update</strong>
    fun updateUser(user: User) : Completable
    <strong class="bold">@Delete</strong>
    fun deleteUser(user: User) : Completable
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): Flowable&lt;List&lt;User&gt;&gt;</pre>
			<p><strong class="bold">Executors and threads</strong> come with the Java framework and can be a useful solution for solving threading issues with Room if <a id="_idIndexMarker996"/>none of the aforementioned third-party integrations are part of <span class="No-Break">your project.</span></p>
			<p>Your DAO classes will not suffer from any modifications; however, you will need the components that access your DAOs to adjust and use either an executor or <span class="No-Break">a thread:</span></p>
			<pre class="source code">
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): List&lt;User&gt;
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(user: User)
    <strong class="bold">@Update</strong>
    fun updateUser(user: User)
    <strong class="bold">@Delete</strong>
    fun deleteUser(user: User)</pre>
			<p>An example of accessing the DAO is <span class="No-Break">as follows:</span></p>
			<pre class="source code">
    fun getUsers(usersCallback:()-&gt;List&lt;User&gt;){
        Thread(Runnable {
            usersCallback.invoke(userDao.loadUsers())
        }).start()
    }</pre>
			<p>The preceding example will create a new thread and start it every time we want to retrieve the list of users. There are <a id="_idIndexMarker997"/>two major issues with <span class="No-Break">this code:</span></p>
			<ul>
				<li>Thread creation is an <span class="No-Break">expensive operation</span></li>
				<li>The code is hard <span class="No-Break">to test</span></li>
			</ul>
			<p>The solution to the first is to use <strong class="source inline">ThreadPools</strong> and <strong class="source inline">Executors</strong>. The Java framework offers a robust set of options when it comes to <strong class="source inline">ThreadPools</strong>. A thread pool is a component responsible for thread <a id="_idIndexMarker998"/>creation and destruction and allows the developer to specify the number of threads in the pool. Multiple threads in a thread pool will ensure multiple tasks can be <span class="No-Break">executed concurrently.</span></p>
			<p>We can rewrite the preceding code <span class="No-Break">as follows:</span></p>
			<pre class="source code">
    private val executor:Executor =
        Executors.newSingleThreadExecutor()
    fun getUsers(usersCallback:(List&lt;User&gt;)-&gt;Unit){
        executor.execute {
            usersCallback.invoke(userDao.loadUsers())
        }
    }</pre>
			<p>In the preceding example, we defined an executor that will use a pool of one thread. When we want to access the list of users, we move the query inside the executor, <a id="_idTextAnchor626"/><a id="_idTextAnchor627"/>and when the data is loaded, our callback lambda will <span class="No-Break">be invoked.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor628"/>Exercise 11.03 – making a little room</h2>
			<p>You have been hired by a news <a id="_idIndexMarker999"/>agency to build a news application. The application will display a list of articles written by journalists. An article can be written by one or more journalists, and each journalist can write one or more articles. The data information for each article includes the article’s title, content, <span class="No-Break">and date.</span></p>
			<p>The journalist’s information includes their first name, last name, and job title. You will need to build a Room database that holds this information so it can be tested. Before we start, let’s look at the relationship between the entities. In the chat application example, we defined the rule that one user can send one or <span class="No-Break">multiple messages.</span></p>
			<p>This relationship is known as a<a id="_idIndexMarker1000"/> one-to-many relationship. That relationship is implemented as a reference between one entity to another (the user was defined in the message table in order to be connected to <span class="No-Break">the sender).</span></p>
			<p>In this case, we have a many-to-many relationship. To implement a many-to-many relationship, we need to create an entity that holds references that will link the other two entities. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new Android Project with <span class="No-Break">No Activity.</span></li>
				<li>Let’s start by adding the annotation processing plugin to <strong class="source inline">app/build.gradle</strong>. This will read the annotations used by Room and generate the code necessary for interacting with <span class="No-Break">the database:</span><pre class="source code">
plugins {
    …
    id 'kotlin-kapt'
}</pre></li>
				<li>Next, let’s add the Room libraries <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break">:</span><pre class="source code">
def room_version = "2.2.5"
implementation "androidx.room:
    room-runtime:$room_version"
kapt "androidx.room:room-compiler:$room_version"</pre></li>
			</ol>
			<p>The first line defines the library version, the second line brings in the Room library for Java and Kotlin, and the last line is for the Kotlin annotation processor. This allows the build system to generate boilerplate code from the Room annotations. After these changes to your Gradle files, you should get a prompt to sync your project, which you <span class="No-Break">should click.</span></p>
			<ol>
				<li value="4">Let’s define our entities<a id="_idIndexMarker1001"/> in the <strong class="source inline">main/java</strong> folder and the <span class="No-Break">root package:</span><pre class="source code">
@Entity(tableName = "article")
data class Article(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(
        name = "id") val id: Long = 0,
    @ColumnInfo(name = "title") val title: String,
    @ColumnInfo(name = "content") val content: String,
    @ColumnInfo(name = "time") val time: Long
)
@Entity(tableName = "journalist")
data class Journalist(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name
        = "id") val id: Long = 0,
    @ColumnInfo(name = "first_name") val firstName:
        String,
    @ColumnInfo(name = "last_name") val lastName:
        String,
    @ColumnInfo(name = "job_title") val jobTitle:
        String
)</pre></li>
				<li>Now, define the entity that connects the journalist to the article and the appropriate constraints<a id="_idIndexMarker1002"/> in the <strong class="source inline">main/java</strong> folder and the <span class="No-Break">root package:</span><pre class="source code">
@Entity(
    tableName = "joined_article_journalist",
    primaryKeys = ["article_id", "journalist_id"],
    foreignKeys = [ForeignKey(
        entity = Article::class,
        parentColumns = arrayOf("id"),
        childColumns = arrayOf("article_id"),
        onDelete = ForeignKey.CASCADE
    ), ForeignKey(
        entity = Journalist::class,
        parentColumns = arrayOf("id"),
        childColumns = arrayOf("journalist_id"),
        onDelete = ForeignKey.CASCADE
    )]
)
data class JoinedArticleJournalist(
    @ColumnInfo(name = "article_id") val articleId:
        Long,
    @ColumnInfo(name = "journalist_id") val
        journalistId: Long
)</pre></li>
			</ol>
			<p>In the preceding code, we defined our connecting entity. As you can see, we haven’t defined an ID for uniqueness, but both the article and the journalist will be unique when used<a id="_idIndexMarker1003"/> together. We also defined foreign keys for each of the other entities referred to by <span class="No-Break">our entity.</span></p>
			<ol>
				<li value="6">Create the <strong class="source inline">ArticleDao</strong> DAO in the <strong class="source inline">main/java</strong> folder and the <span class="No-Break">root package:</span><pre class="source code">
@Dao
interface ArticleDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertArticle(article: Article)
    @Update
    fun updateArticle(article: Article)
    @Delete
    fun deleteArticle(article: Article)
    @Query("SELECT * FROM article")
    fun loadAllArticles(): List&lt;Article&gt;
    @Query("SELECT * FROM article INNER JOIN
            joined_article_journalist ON
            article.id=joined_article_journalist
            .article_id WHERE
            joined_article_journalist.journalist_id=
            :journalistId")
    fun loadArticlesForAuthor(journalistId: Long):
        List&lt;Article&gt;
}</pre></li>
				<li>Now, create the <strong class="source inline">JournalistDao</strong> data access object in the <strong class="source inline">main/java</strong> folder and the <span class="No-Break">root package:</span><pre class="source code">
@Dao
interface JournalistDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertJournalist(journalist: Journalist)
    @Update
    fun updateJournalist(journalist: Journalist)
    @Delete
    fun deleteJournalist(journalist: Journalist)
    @Query("SELECT * FROM journalist")
    fun loadAllJournalists(): List&lt;Journalist&gt;
    @Query("SELECT * FROM journalist INNER JOIN
            joined_article_journalist ON
            journalist.id=joined_article_journalist
            .journalist_id WHERE
            joined_article_journalist.article_id=
            :articleId")
    fun getAuthorsForArticle(articleId: Long):
        List&lt;Journalist&gt;
}</pre></li>
				<li>Create<a id="_idIndexMarker1004"/> the <strong class="source inline">JoinedArticleJournalistDao</strong> DAO in the <strong class="source inline">main/java</strong> folder and the <span class="No-Break">root package:</span><pre class="source code">
@Dao
interface JoinedArticleJournalistDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertArticleJournalist(
      joinedArticleJournalist: JoinedArticleJournalist
    )
    @Delete
    Fun deleteArticleJournalist(
      joinedArticleJournalist: JoinedArticleJournalist
    )
}</pre></li>
			</ol>
			<p>Let’s analyze our code a little bit. For the articles and journalists, we can add, insert, delete, and update queries. For articles, we can extract all of the articles but also extract articles from a <span class="No-Break">certain author.</span></p>
			<p>We also have the option to extract all the journalists that wrote an article. This is done through a JOIN<a id="_idIndexMarker1005"/> with our intermediary entity. For that entity, we define the options to insert (which will link an article to a journalist) and delete (which will remove <span class="No-Break">that link).</span></p>
			<ol>
				<li value="9">Finally, let’s define our <strong class="source inline">Database</strong> class in the <strong class="source inline">main/java</strong> folder and the <span class="No-Break">root package:</span><pre class="source code">
@Database(
    entities = [Article::class, Journalist::class,
        JoinedArticleJournalist::class],
    version = 1
)
abstract class NewsDatabase : RoomDatabase() {
    abstract fun articleDao(): ArticleDao
    abstract fun journalistDao(): JournalistDao
    abstract fun joinedArticleJournalistDao():
        JoinedArticleJournalistDao
}</pre></li>
			</ol>
			<p>We avoided defining the <strong class="source inline">getInstance</strong> method here because we won’t be calling the database anywhere. But if we don’t do that, how will we know whether it works? The answer to this is that we’ll test it. This won’t be a test that will run on your machine but one that will run on the device. This means that we will create it in the <span class="No-Break"><strong class="source inline">androidTest</strong></span><span class="No-Break"> folder.</span></p>
			<ol>
				<li value="10">Let’s start by setting <a id="_idIndexMarker1006"/>up the test data. Here, we will add some articles and journalists to the database then test retrieving, updating, and deleting <span class="No-Break">the entries:</span><pre class="source code">
@RunWith(AndroidJUnit4::class)
class NewsDatabaseTest {
    @Test
    fun updateArticle() {
        val article = articleDao.loadAllArticles()[0]
        articleDao.updateArticle(article.copy(title = 
            "new title"))
        assertEquals("new title", articleDao.
            loadAllArticles()[0].title)
    }
    @Test
    fun updateJournalist() {
        val journalist = journalistDao.
            loadAllJournalists()[0] journalistDao.
            updateJournalist(journalist.copy(jobTitle = 
            "new job title"))
        assertEquals("new job title", journalistDao.
            loadAllJournalists()[0].jobTitle)
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found <span class="No-Break">at </span><a href="https://packt.link/6H8X2"><span class="No-Break">https://packt.link/6H8X2</span></a><span class="No-Break">.</span></p>
			<p>Here, we have defined a few examples of how to test a Room database. What’s interesting is how we build the database. Our database is an in-memory database. This means that all the data will be kept as long as the test is run and <span class="No-Break">discarded afterward.</span></p>
			<p>This allows us to start with<a id="_idIndexMarker1007"/> a clean slate for each new state and avoids the consequences of each of our testing sessions affecting each other. In our test, we’ve set up 5 articles and 10 journalists. The first article was written by the top two journalists, while the second article was written by the <span class="No-Break">first journalist.</span></p>
			<p>The rest of the articles have no authors. By doing this, we can test our update and delete methods. For the delete method, we can test our foreign key relationship as well. In the test, we can see that if we delete article <strong class="source inline">1</strong>, it will delete the relationship between the article and the journalists that <span class="No-Break">wrote it.</span></p>
			<p>When testing your database, you should add the scenarios that your app will use. Feel free to add other testing scenarios and improve the preceding tests in your own database. Note that if you are using the <strong class="source inline">androidTest</strong> folder, then this will be an inst<a id="_idTextAnchor629"/><a id="_idTextAnchor630"/><a id="_idTextAnchor631"/><a id="_idTextAnchor632"/>r<a id="_idTextAnchor633"/><a id="_idTextAnchor634"/>umented test, meaning that you will need an emulator or a device <span class="No-Break">to test.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor635"/>Activity 11.01 – a shopping notes app</h2>
			<p>You want to keep track of your shopping items, so you decide to build an app to save the items you wish to<a id="_idIndexMarker1008"/> buy during your next trip to the store. The requirements for this are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The UI will be split into two: top/bottom in portrait mode and left/right in landscape mode. The UI will look similar to what is shown in the <span class="No-Break">following screenshot.</span></li>
				<li>The first half will display the number of notes, a text field, and a button. Every time the button is pressed, a note will be added with the text placed in the <span class="No-Break">text field.</span></li>
				<li>The second half will display the list <span class="No-Break">of notes.</span></li>
				<li>For each half, you will have a View model that will hold the <span class="No-Break">relevant data.</span></li>
				<li>You should define a repository that will be used on top of the Room database to access <span class="No-Break">your data.</span></li>
				<li>You should also <a id="_idIndexMarker1009"/>define a Room database that will hol<a id="_idTextAnchor636"/>d <span class="No-Break">your notes.</span></li>
				<li>The note entity will have the following attributes: <strong class="source inline">id</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">text</strong></span><span class="No-Break">:</span></li>
			</ul>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B19411_11_09.jpg" alt="Figure 11.9 – Example of a possible output for activity 11.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Example of a possible output for activity 11.01</p>
			<p>Perform the following steps to complete <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Start with Room integration by creating the <strong class="source inline">Entity</strong>, <strong class="source inline">Dao</strong>, and <strong class="source inline">Database</strong> methods. For <strong class="source inline">Dao</strong>, the <strong class="source inline">@Query</strong> annotated methods can directly return a <strong class="source inline">LiveData</strong> object so that the observers can be directly notified if the <span class="No-Break">data changes.</span></li>
				<li>Define a template of our repository in the form of <span class="No-Break">an interface.</span></li>
				<li>Implement the repository. The repository will have one reference to the <strong class="source inline">Dao</strong> object we defined previously. The code for inserting the data must be moved to a <span class="No-Break">separate thread.</span></li>
				<li>Create the <strong class="source inline">NotesApplication</strong> class to provide one instance of the repository that will be used across the application. Make sure to update the <strong class="source inline">&lt;application&gt;</strong> tag in the <strong class="source inline">AndroidManifest.xml</strong> file to add your new <span class="No-Break">application class.</span></li>
				<li>Unit-test the<a id="_idIndexMarker1010"/> repository and define <strong class="source inline">ViewModels</strong>, <span class="No-Break">as follows:</span><ol><li>Define <strong class="source inline">NoteListViewModel</strong> and the associated test. This will have a reference to the repository and return the list <span class="No-Break">of notes.</span></li><li>Define <strong class="source inline">CountNotesViewModel</strong> and the associated test. <strong class="source inline">CountViewModel</strong> will have a reference to the repository and return the total number of notes as <strong class="source inline">LiveData</strong>. It will also be responsible for inserting <span class="No-Break">new notes.</span></li><li>Define <strong class="source inline">CountNotesFragment</strong> and the associated <strong class="source inline">fragment_count_notes.xml</strong> layout. In the layout, define a <strong class="source inline">TextView</strong>, which will display the total number, an <strong class="source inline">EditText</strong> for the name of the new notes, and a button, which will insert the note that was introduced <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">EditText</strong></span><span class="No-Break">.</span></li><li>Define an adapter for the list of notes called <strong class="source inline">NoteListAdapter</strong> and an associated layout file for the rows <span class="No-Break">called </span><span class="No-Break"><strong class="source inline">view_note_item.xml</strong></span><span class="No-Break">.</span></li><li>Define the associated layout file, called <strong class="source inline">fragment_note_list.xml</strong>, which will contain <strong class="source inline">RecyclerView</strong>. The layout will be used by <strong class="source inline">NoteListFragment</strong>, which will connect <strong class="source inline">NoteListAdapter</strong> to <strong class="source inline">RecyclerView</strong>. It will also observe the data from <strong class="source inline">NoteListViewModel</strong> and update <span class="No-Break">the adapter.</span></li><li>Define <strong class="source inline">NotesActivity</strong> with an associated layout for landscape mode and <span class="No-Break">portrait mode.</span></li></ol></li>
				<li>Make sure you have <a id="_idIndexMarker1011"/>all the necessary data <span class="No-Break">in </span><span class="No-Break"><strong class="source inline">strings.xml</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/ZhnDx"><span class="No-Break">https://packt.link/ZhnDx</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor637"/>Summary</h1>
			<p>In this chapter, we analyzed the building blocks required to build a maintainable application. We also looked into one of the most common issues that developers come across when using the Android Framework, which is maintaining the states of objects during <span class="No-Break">lifecycle changes.</span></p>
			<p>We started by analyzing <strong class="source inline">ViewModels</strong> and how they solve the issue of holding data during orientation changes. We added <strong class="source inline">LiveData</strong> to <strong class="source inline">ViewModels</strong> to show how the two complement each other and looked at how we can use other data streams with <strong class="source inline">ViewModels</strong> and compare those <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break">.</span></p>
			<p>We then moved on to Room to show how we can persist data with minimal effort and without much SQLite boilerplate code. We also explored one-to-many and many-to-many relationships, as well as how to migrate data and break down complex objects into primitives <span class="No-Break">for storage.</span></p>
			<p>The activity we completed in this chapter serves as an example of what direction Android apps are heading in. However, this was not a complete example due to the numerous frameworks and libraries that you will discover, which give developers the flexibility to go in <span class="No-Break">different directions.</span></p>
			<p>The information you’ve learned in this chapter will serve you well for the next one, which will expand on the concept of repositories. This will allow you to save data that’s been obtained from a server into a <span class="No-Break">Room database.</span></p>
			<p>The concept of persisting data will also be expanded as you will explore other ways to persist data, such as through <strong class="source inline">SharedPreferences</strong>, <strong class="source inline">DataStore</strong>, and files. Our focus will be on certain types of files: media files obtained from the camera of <span class="No-Break">the device.</span></p>
		</div>
	</body></html>