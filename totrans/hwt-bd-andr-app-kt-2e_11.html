<html><head></head><body>
		<div><h1 id="_idParaDest-173" class="chapter number"><a id="_idTextAnchor582"/>11</h1>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor583"/>Android Architecture Components</h1>
			<p><a id="_idTextAnchor584"/>In this chapter, you will learn about the key components of the Android Jetpack libraries and what benefits they bring to the standard Android framework. You will also learn how to structure your code and give different responsibilities to your classes with the help of Jetpack components. Finally, you’ll improve the test coverage of your code.</p>
			<p>By the end of this chapter, you’ll be able to create applications that handle the lifecycles of activities and fragments with ease. You’ll also know more about how to persist data on an Android device using Room and how to use ViewModels to separate your logic from your Views.</p>
			<p><a id="_idTextAnchor585"/>In the previous chapters, you learned how to write unit tests. The question is: what can you unit-test? Can you unit-test activities and fragments? It is hard to unit-test activities and fragments on your machine because of the way they are built. Testing would be easier if you could move the code away from activities and fragments.</p>
			<p>Also, consider the situation where you are building an application that supports different orientations, such as landscape and portrait, and supports multiple languages. What tends to happen in these scenarios by default is that when the user rotates the screen, the activities and fragments are recreated for the new display orientation.</p>
			<p>Now, imagine that happens while your application is in the middle of processing data. You have to keep track of the data you are processing, keep track of what the user was doing to interact with your screens, and avoid causing a context leak.</p>
			<p class="callout heading">Note</p>
			<p class="callout">A <strong class="bold">context leak</strong> occurs when<a id="_idIndexMarker926"/> your destroyed activity cannot be garbage-collected because it is referenced in a component with a longer lifecycle – such as a thread that is currently processing your data.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>ViewModel</li>
				<li>Data streams</li>
				<li>Room</li>
			</ul>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor586"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/89BCi">https://packt.link/89BCi</a></p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor587"/>Android components background</h1>
			<p>In many situations, you<a id="_idIndexMarker927"/> have to use <code>onSaveInstanceState</code> to save the current state of your activity/fragment, and then in <code>onCreate</code> or <code>onRestoreInstanceState</code>, you need to restore the state of your activity/fragment. This adds extra complexity to your code and makes it repetitive, especially if the processing code is part of your activity or fragment.</p>
			<p>These scenarios are where <code>ViewModel</code> and <code>LiveData</code> come in. <code>ViewModels</code> are components built with the express goal of holding data in case of lifecycle changes. They also separate the logic from the Views, which makes them very easy to unit-test. <code>LiveData</code> is a component used to hold data and notify observers when changes occur while taking their lifecycle into account.</p>
			<p>In simpler terms, the fragment only deals with the Views, <code>ViewModel</code> does the heavy lifting, and <code>LiveData</code> deals with delivering the results to the fragment, but only when the fragment is there and ready.</p>
			<p>If you’ve ever used WhatsApp or a similar messaging app and you’ve turned off the internet, you’ll have noticed that you are still able to use the application. The reason for this is that the messages are stored locally on your device. This is achieved with a database file called <code>SQLite</code> in most cases.</p>
			<p>The Android Framework already allows you to use this feature for your application. However, this requires a lot of boilerplate code to read and write data. Every time you want to interact with the local storage, you must write a SQL query. When you read the SQLite data, you must convert it into a Java/Kotlin object.</p>
			<p>All of this requires a lot of code, time, and unit testing. What if someone else were to handle the SQLite connection, and all you had to do was focus on the code part? This is where <strong class="bold">Room</strong> comes in. This is a library that is a wrapper over SQLite. All you need to do is define how your data should be saved and let the library take care of the rest.</p>
			<p>Let’s say you want your activity to know when there is an internet connection and when the internet drops. You can use something called <code>BroadcastReceiver</code> for this. A slight problem with this is that every time you register <code>BroadcastReceiver</code> in an activity, you must unregister it when the activity is destroyed.</p>
			<p>You can use <code>Lifecycle</code> to observe the state of your activity, thereby allowing your receiver to be registered in the desired state and unregistered in the complementary one (for example, <code>RESUMED-PAUSED</code>, <code>STARTED-STOPPED</code>, or <code>CREATED-DESTROYED</code>).</p>
			<p><code>ViewModels</code>, <code>LiveData</code>, and <code>Room</code> are all part of the Android architecture components, which are part of the Android Jetpack libraries. The architecture components are designed to help developers structure their code, write testable components, and help reduce boilerplate code.</p>
			<p>Other architecture <a id="_idIndexMarker928"/>components include <code>Databinding</code> (which binds views with models or <code>ViewModels</code>, allowing the data to be directly set in the Views), <code>WorkManager</code> (which allows developers to handle background work with ease), <code>Navigation</code> (which allows developers to create visual navigation graphs and specify relationships between activities and fragments), and <code>Paging</code> (which allows developers to load paginated data, which helps in situations where infinite scrolling is required<a id="_idTextAnchor588"/><a id="_idTextAnchor589"/><a id="_idTextAnchor590"/>).</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor591"/>ViewModel</h1>
			<p>The <code>ViewModel</code> component is responsible <a id="_idIndexMarker929"/>for holding and processing data<a id="_idIndexMarker930"/> required by the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). It has the benefit of surviving configuration changes that destroy and recreate fragments and activities, which allows it to retain the data that can then be used to re-populate the UI.</p>
			<p>It will eventually be<a id="_idIndexMarker931"/> destroyed when the activity or fragment is destroyed without being recreated or when the application process is terminated. This allows <code>ViewModel</code> to serve its responsibility and to have garbage collected when it is no longer necessary. The only method <code>ViewModel</code> has is the <code>onCleared()</code> method, which is called when <code>ViewModel</code> terminates. You can overwrite this method to terminate ongoing tasks and deallocate resources that will no longer be required.</p>
			<p>Migrating data processing from the activities into <code>ViewModel</code> helps create better and faster unit tests. Testing an activity requires an Android test to be executed on a device. Activities also have states, which means that your test should get the activity into the proper state for the assertions to work. <code>ViewModel</code> can be unit-tested locally on your development machine and can be stateless, meaning that your data processing logic can be tested individually.</p>
			<p>One of the most important features of <code>ViewModel</code> is that it allows communication between fragments. To communicate between fragments without <code>ViewModel</code>, you must make your fragment communicate with the activity, which will then call the fragment you wish to<a id="_idIndexMarker932"/> communicate with.</p>
			<p>To achieve this with <code>ViewModel</code>, you can just attach it to the parent activity and use the same <code>ViewModel</code> in the fragment you wish to communicate with. This will reduce the boilerplate code that was required previously.</p>
			<p>In the following diagram, you <a id="_idIndexMarker933"/>can see that <code>ViewModel</code> can be created at any point in an activity’s lifecycle (in practice, they are normally initialized in <code>onCreate</code> for Activities and <code>onCreateView</code> or <code>onViewCreated</code> for Fragments because these represent the points where the views are created and ready to be updated), and that once created, it will live as long as the activity<a id="_idTextAnchor592"/> does:</p>
			<div><div><img src="img/B19411_11_01.jpg" alt="Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The lifecycle of an activity compared to the ViewModel lifecycle</p>
			<p>In the preceding diagram, we can see how the lifecycle of <code>Activity</code> compares to that of <code>ViewModel</code>. The red lines indicate what happens when the <code>Activity</code> is recreated, starting from the <code>onPause</code> method, ending in <code>onDestroy,</code> and then going from <code>onCreate</code> to <code>onResume</code> in a new instance of <code>Activity</code>.</p>
			<p>The following diagram shows how <code>ViewModel</code> connects to a frag<a id="_idTextAnchor593"/>ment:</p>
			<div><div><img src="img/B19411_11_02.jpg" alt="Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The lifecycle of a fragment compared to the ViewModel lifecycle</p>
			<p>In the preceding diagram, we<a id="_idIndexMarker934"/> can see how the lifecycle of <code>Fragment</code> compares<a id="_idIndexMarker935"/> to that of <code>ViewModel</code>. The red lines indicate what happens when <code>Fragment</code> is recreated, starting from the <code>onPause</code> method, ending in <code>onDetach</code>, and then going from <code>onAttach</code> to <code>onResume</code> in a new instance of <code>Fragment</code>.</p>
			<p>In this section, we learned what a ViewModel is and the benefits it provides with regard to testing and performing logic, which survives the recreation of the activity and fr<a id="_idTextAnchor594"/>agment.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor595"/>Exercise 11.01 – shared ViewModel</h2>
			<p>You have been tasked with building an app with one screen split vertically into two when in portrait mode and horizontally when in landscape mode. The first half contains some text, and below it is<a id="_idIndexMarker936"/> a button.</p>
			<p>The second half contains only text. When the screen is opened, the text in both halves displays <strong class="bold">Total: 0</strong>. When the button is clicked, the text will change to <strong class="bold">Total: 1</strong>. When clicked again, the text will change to <strong class="bold">Total: 2</strong>, and so on. When the device is rotated, the last total will be displayed in the new orientation.</p>
			<p>To solve this task, we will define the following:</p>
			<ul>
				<li>An activity that will hold two fragments – one layout for portrait and another for landscape</li>
				<li>One fragment with one layout containing <code>TextView</code> and a button</li>
				<li>One fragment with one layout containing <code>TextView</code></li>
				<li>One <code>ViewModel</code> that will be shared between the two fragments</li>
			</ul>
			<p>Let’s begin by setting up our configurations:</p>
			<ol>
				<li>Create a new project in Android Studio and add an empty activity called <code>SplitActivity</code>.</li>
				<li>Let’s add the <code>ViewModel</code> library to <code>app/build.gradle</code>:<pre class="source code">
    implementation "androidx.lifecycle:
    lifecycle-viewmodel-ktx:2.5.1"</pre></li>
				<li>Add the following strings to <code>values/strings.xml</code>:<pre class="source code">
    &lt;string name="press_me"&gt;Press Me&lt;/string&gt;
    &lt;string name="total"&gt;Total %d&lt;/string&gt;</pre></li>
				<li>Create and define <code>SplitFragmentOne</code>:<pre class="source code">
class SplitFragmentOne : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(
        R.layout.fragment_split_one, container, false)
    }
    override fun onViewCreated(view: View,
        savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.findViewById&lt;TextView&gt;
            (R.id.fragment_split_one_text_view)
                .text = getString(R.string.total, 0)
    }
}</pre></li>
				<li>Add the <code>fragment_split_one.xml</code> file to<a id="_idIndexMarker937"/> the <code>res/layout</code> folder:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android=
    "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/fragment_split_one_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
    &lt;Button
        android:id="@+id/fragment_split_one_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/press_me" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Now, let’s <a id="_idIndexMarker938"/>create and define <code>SplitFragmentTwo</code>:<pre class="source code">
class SplitFragmentTwo : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        Return inflater.inflate(
        R.layout.fragment_split_two, container, false)
    }
    override fun onViewCreated(view: View,
        savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        view.findViewById&lt;TextView&gt; (
        R.id.fragment_split_two_text_view).text =
        getString(R.string.total, 0)
    }
}</pre></li>
				<li>Add the <code>fragment_split_two.xml</code> file to<a id="_idIndexMarker939"/> the <code>res/layout</code> folder:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android =
    "http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical"&gt;
    &lt;TextView
        android:id="@+id/fragment_split_two_text_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" /&gt;
&lt;/LinearLayout&gt;</pre></li>
				<li>Define <code>SplitActivity</code>:<pre class="source code">
class SplitActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?)
    {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_split)
    }
}</pre></li>
				<li>Create the <code>activity_split.xml</code> file in the <code>res/layout</code> folder:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_1"
        <strong class="bold">android:name="{package.path}.SplitFragmentOne"</strong>
        android:layout_width="match_parent"
        /&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_2"
        <strong class="bold">android:name="{package.path}.SplitFragmentTwo"</strong>
        android:layout_width="match_parent"
        /&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>The complete code for this <a id="_idIndexMarker940"/>step can be found at <a href="https://packt.link/HPy9p">https://packt.link/HPy9p</a>.</p>
			<p>Replace <code>{package.path}</code> with the name of the package in which your Fragments are located.</p>
			<ol>
				<li value="10">Next, let’s create a <code>layout-land</code> folder in the <code>res</code> folder. Then, in the <code>layout-land</code> folder, we’ll create an <code>activity_split.xml</code> file with the following layout:<pre class="source code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_1"
        <strong class="bold">android:name="{package.path}.SplitFragmentOne"</strong>
        /&gt;
    &lt;androidx.fragment.app.FragmentContainerView
        android:id="@+id/activity_fragment_split_2"
        <strong class="bold">android:name="{package.path}.SplitFragmentTwo"</strong>
        /&gt;
&lt;/LinearLayout&gt;</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/1zRQa">https://packt.link/1zRQa</a>.</p>
			<p>Replace <code>{package.path}</code> with the name of the package in which your Fragments are located. Notice the <a id="_idIndexMarker941"/>same <code>android:id</code> attribute in both the <code>activity_split.xml</code> files. This allows the operating system to correctly save and restore the fragment’s state during rotation.</p>
			<ol>
				<li value="11">In the <code>main/java</code> folder in the root package, create a <code>TotalsViewModel</code> that looks like this:<pre class="source code">
class TotalsViewModel : ViewModel() {
    var total = 0
    fun increaseTotal(): Int {
        total++
        return total
    }
}</pre></li>
			</ol>
			<p>Notice that we extended from the <code>ViewModel</code> class, which is part of the lifecycle library. In the <code>ViewModel</code> class, we defined one method that increases the total value and returns the updated value.</p>
			<ol>
				<li value="12">Now, add the <code>updateText</code> and <code>prepareViewModel</code> methods to the <code>SplitFragment1</code> fragment:<pre class="source code">
class SplitFragmentOne : Fragment() {
    …
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        …
        <strong class="bold">prepareViewModel()</strong>
    }
<strong class="bold">    private fun prepareViewModel() {</strong>
<strong class="bold">}</strong>
<strong class="bold">    private fun updateText(total: Int) {</strong>
<strong class="bold">        view?.findViewById&lt;TextView&gt;</strong>
<strong class="bold">        (R.id.fragment_split_one_text_view)?.text =</strong>
<strong class="bold">        getString(R.string.total, total)</strong>
<strong class="bold">    }</strong>
}</pre></li>
				<li>In the <code>prepareViewModel()</code> function, let’s <a id="_idIndexMarker942"/>start adding our <code>ViewModel</code>:<pre class="source code">
private fun prepareViewModel() {
    <strong class="bold">val totalsViewModel = ViewModelProvider(this)</strong>
<strong class="bold">        .get(TotalsViewModel::class.java)</strong>
}</pre></li>
			</ol>
			<p>This is how the <code>ViewModel</code> instance is accessed. <code>ViewModelProvider(this)</code> will bind <code>TotalsViewModel</code> to the lifecycle of the fragment. <code>.get(TotalsViewModel::class.java)</code> will retrieve the <code>TotalsViewModel</code> instance that we defined previously.</p>
			<p>If the fragment is being created for the first time, it will produce a new instance, while if the fragment is recreated after a rotation, it will provide the previously created instance. We pass <a id="_idIndexMarker943"/>the class as an argument because a fragment or activity can have multiple ViewModels, and the class serves as an identifier for the type of <code>ViewModel</code> we want.</p>
			<ol>
				<li value="14">Now, set the last known value on the view:<pre class="source code">
private fun prepareViewModel() {
    val totalsViewModel = ViewModelProvider(this)
        .get(TotalsViewModel::class.java)
<strong class="bold">    updateText(totalsViewModel.total)</strong>
}</pre></li>
			</ol>
			<p>The second line will help during device rotation. It will set the last total that was computed. If we remove this line and rebuild, then we will see <code>1</code>.</p>
			<ol>
				<li value="15">Update the View when the <code>fragment_split_one_button</code> button is clicked:<pre class="source code">
private fun prepareViewModel() {
    val totalsViewModel =
        ViewModelProvider(this)
            .get(TotalsViewModel::class.java)
    updateText(totalsViewModel.total)
<strong class="bold">    view?.findViewById&lt;Button&gt;</strong>
<strong class="bold">    (R.id.fragment_split_one_button)</strong>
<strong class="bold">    ?.setOnClickListener {</strong>
<strong class="bold">        updateText(totalsViewModel.increaseTotal())</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>The last few lines indicate that when a click is performed on the button, we tell <code>ViewModel</code> to recompute the total <a id="_idIndexMarker944"/>and set the new value.</p>
			<ol>
				<li value="16">Add the same <code>ViewModel</code> we used previously to our <code>SplitFragmentTwo</code>:<pre class="source code">
class SplitFragmentTwo : Fragment() {
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        return inflater.inflate(
        R.layout.fragment_split_two, container, false)
    }
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val totalsViewModel = ViewModelProvider(this)
            .get(TotalsViewModel::class.java)
<strong class="bold">        updateText(totalsViewModel.total)</strong>
<strong class="bold">    }</strong>
<strong class="bold">    private fun updateText(total: Int) {</strong>
<strong class="bold">        view?.findViewById&lt;TextView&gt; (</strong>
<strong class="bold">        R.id.</strong> <strong class="bold">fragment_split_two_text_view)?.text =</strong>
<strong class="bold">        getString(R.string.total, total)</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>If we run the app now, we’ll see that nothing has changed. The first fragment works as before, but the second<a id="_idIndexMarker945"/> fragment doesn’t get any updates. This is because even though we defined one <code>ViewModel</code>, we have two instances of that <code>ViewModel</code> for each of our fragments.</p>
			<p>We will need to limit the number of instances to one per fragment. We can achieve this by attaching our <code>ViewModel</code> to the <code>SplitActivity</code> lifecycle using a method called <code>requireActiviy</code>.</p>
			<ol>
				<li value="17">Let’s modify our fragments. In both fragments, we need to find and change the following code:<pre class="source code">
val totalsViewModel = ViewModelProvider(this).get(TotalsViewModel::class.java)</pre></li>
			</ol>
			<p>We will change it to the following:</p>
			<pre class="source code">
val totalsViewModel = ViewModelProvider(requireActivity()) .get(TotalsViewModel::class.java)</pre>
			<p class="callout heading">Note</p>
			<p class="callout">Using ViewModels to communicate between fragments will only work when the fragments are placed in the same activity.</p>
			<p>If we run the application, we <a id="_idIndexMarker946"/>should see the following:</p>
			<div><div><img src="img/B19411_11_03.jpg" alt="Figure 11.3 – Output of ﻿Exercise 11.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Output of Exercise 11.01</p>
			<p>When the button is clicked, the total updates are on the top half of the screen but not on the bottom half. If we rotate the screen, the last value <code>ViewModel</code> had will be set on the second screen as well. This means that our application doesn’t react properly to the changes in <code>ViewModel</code>.</p>
			<p>This means that we will need a publisher-subscriber approach to monitor changes that occur in our data. In the next section, we will look at some common data streams that ViewModels can use to notify when the data is changed.</p>
			<p>In this exercise, we implemented a ViewModel, which was responsible for incrementing an integer value that will be displayed on the screen. In the section that follows, we will connect data streams to react to changes when the number is incremented.</p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor596"/>Data streams</h1>
			<p>When it comes to data observability, we<a id="_idIndexMarker947"/> have multiple approaches for implementation, whether manually built mechanisms, components from the Java language, third-party components, or finally to solutions developed particularly for Android. When it comes to Android, some of the most common solutions are <code>LiveData</code>, Flows from the Coroutines components, and RxJava.</p>
			<p>The first one we will look at is <code>LiveData</code>, as it is part of the Android Architecture Components, which means that it is tailored specially to Android. We will then look at how we can use other types of data streams, which we will cover in more depth in<a id="_idTextAnchor597"/> future chapters.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor598"/>LiveData</h2>
			<p><code>LiveData</code> is a lifecycle-aware component that permits updates to your UI, but only if the UI is in an active state (for<a id="_idIndexMarker948"/> example, if the activity or fragment is in one of the <code>STARTED</code> or <code>RESUMED</code> states). To monitor changes on <code>LiveData</code>, you need an observer combined with a <code>LifecycleOwner</code>. When the activity is set to an active state, the observers will be notified when changes occur.</p>
			<p>If the activity is recreated, then the observer will be destroyed, and a new one will be reattached. Once this happens, the last value of <code>LiveData</code> will be emitted to allow us to restore the state. Activities and <a id="_idIndexMarker949"/>fragments are <code>LifecycleOwners</code>, but fragments have a separate <code>LifecycleOwner</code> for the View states. Fragments have this particular <code>LifecycleOwner</code> due to their behavior in the <code>BackStack</code> fragment.</p>
			<p>When fragments are replaced within the back stack, they are not fully destroyed; only their Views are. Some of the common callbacks that developers use to trigger processing logic are <code>onViewCreated()</code>, <code>onActivityResumed()</code>, and <code>onCreateView()</code>. If we were to register observers for <code>LiveData</code> in these methods, we might end up with scenarios where multiple observers will be created every time our fragment pops back onto the screen.</p>
			<p>When updating a <code>LiveData</code> model, we are presented with two options: <code>setValue()</code> and <code>postValue()</code>. <code>setValue()</code> will deliver the result immediately and is meant to be called only on the UI thread. On the other hand, <code>postValue()</code> can be called on any thread. When <code>postValue()</code> is called, <code>LiveData</code> will schedule an update of the value on the UI thread and update the value when the UI thread becomes free.</p>
			<p>In the <code>LiveData</code> class, these methods are protected, which means that there are subclasses that allow us to change the data. <code>MutableLiveData</code> makes the methods public, which gives us a simple solution for observing data in most cases. <code>MediatorLiveData</code> is a specialized implementation of <code>LiveData</code> that allows us to merge multiple <code>LiveData</code> objects into one (this is useful in situations where our data is kept in different repositories and we want to show a combined result).</p>
			<p><code>TransformLiveData</code> is another<a id="_idIndexMarker950"/> specialized implementation that allows us to convert one object into another (this helps us in situations where we grab <a id="_idIndexMarker951"/>data from one repository and we want to request data from another repository that depends on the previous data, as well as in situations where we want to apply extra logic to a result from a repository).</p>
			<p><code>Custom LiveData</code> allows us to create our own <code>LiveData</code> implementations (usually when we periodically receive updates, such as the odds in a sports betting app, stock market updates, and Facebook and Twitter feeds).</p>
			<p class="callout heading">Note</p>
			<p class="callout">It is a common practice to use <code>LiveData</code> in <code>ViewModel</code>. Holding <code>LiveData</code> in a fragment or activity will cause losses in data when configuration changes occur.</p>
			<p>The following diagram shows how <code>LiveData</code> is connected to the lifecy<a id="_idTextAnchor599"/>cle of <code>LifecycleOwner</code>:</p>
			<div><div><img src="img/B19411_11_04.jpg" alt="Figure 11.4 – The relationship between LiveData and lifecycle observers with LifecycleOwner﻿"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – The relationship between LiveData and lifecycle observers with LifecycleOwner</p>
			<p class="callout heading">Note</p>
			<p class="callout">We can register multiple observers for <code>LiveData</code>, and each observer can be registered for a different <code>LifecycleOwner</code>. In this situation, <code>LiveData</code> will become inactive, but only when all the observers are inactive.</p>
			<p>In this section, we<a id="_idIndexMarker952"/> looked at how the <code>LiveData</code> component works and<a id="_idIndexMarker953"/> the benefits it provides for observing data from activities and fragments with regard to their lifecycles. In the following section, we will look at an exer<a id="_idTextAnchor600"/><a id="_idTextAnchor601"/>cise t<a id="_idTextAnchor602"/>hat uses <code>LiveData</code>.</p>
			<h3>Exercise 11.02 – observing with LiveData</h3>
			<p>Modify <em class="italic">Exercise 11.01 – shared ViewModel</em> so that when the button is clicked, both fragments will be updated with<a id="_idIndexMarker954"/> the total number of clicks.</p>
			<p>Perform the following steps to achieve this:</p>
			<ol>
				<li>Add the <code>LiveData</code> library to the <code>app/build.gradle</code> file:<pre class="source code">
implementation "androidx.lifecycle:
lifecycle-livedata-ktx:2.5.1"</pre></li>
				<li><code>TotalsViewModel</code> should be modified so that it supports <code>LiveData</code>:<pre class="source code">
class TotalsViewModel : ViewModel() {
    private val _total = MutableLiveData&lt;Int&gt;()
    val total: LiveData&lt;Int&gt; = _total
    init {
        _total.postValue(0)
    }
    fun increaseTotal() {
        _total.postValue((_total.value ?: 0) + 1)
    }
}</pre></li>
			</ol>
			<p>Here, we created <code>MutableLiveData</code>, a subclass of <code>LiveData</code> that allows us to change the value of the data. When <code>ViewModel</code> is created, we set the default value of <code>0</code>, and then<a id="_idIndexMarker955"/> when we increase the total, we post the previous value plus <code>1</code>.</p>
			<p>The reason we have duplicated representations for the total is that we wanted to keep the mutable component private to the class while exposing the non-mutable total to be observed by other objects.</p>
			<ol>
				<li value="3">Now, we need to modify our fragments so that they adjust to the new <code>ViewModel</code>. For <code>SplitFragmentOne</code>, we do the following:<pre class="source code">
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
            val totalsViewModel =
             ViewModelProvider(requireActivity())
                 .get(TotalsViewModel::class.java)
        totalsViewModel.total.observe(
        viewLifecycleOwner, {
            updateText(it)
        })
        view.findViewById&lt;Button&gt;(
        R.id.fragment_split_one_button)
        .setOnClickListener {
            totalsViewModel.increaseTotal()
        }
    }</pre></li>
				<li>For <code>SplitFragmentTwo</code>, we do<a id="_idIndexMarker956"/> the following:<pre class="source code">
    override fun onViewCreated(view: View,
        savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val totalsViewModel =
            ViewModelProvider(requireActivity())
                .get(TotalsViewModel::class.java)
        totalsViewModel.total.observe(
        viewLifecycleOwner, {
            updateText(it)
        })
    }</pre></li>
			</ol>
			<p>If we look at the following line:<code> totalsViewModel.getTotal().observe(view</code><strong class="source inline">
LifecycleOwner, { updateText(it)})</strong>, the <code>LifecycleOwner</code> parameter for the <code>observe</code> method is called <code>viewLifecycleOwner</code>. This is inherited from the <code>fragment</code> class, and it helps when we observe data while the View that the fragment manages is being rendered. In our example, swapping <code>viewLifecycleOwner</code> with <code>this</code> would not have caused an impact.</p>
			<p>But if our fragment had been<a id="_idIndexMarker957"/> part of a back stack feature, then there would have been the risk of creating multiple observers, which would have led to being notified multiple times for the same dataset.</p>
			<ol>
				<li value="5">Now, let’s write a test for our new <code>ViewModel</code>. We will name it <code>TotalsViewModelTest</code> and place it in the <code>test</code> package, not <code>androidTest</code>. This is because we want this test to execute on our workstation, not the device:<pre class="source code">
class TotalsViewModelTest {
    private lateinit var totalsViewModel:
        TotalsViewModel
    @Before
    fun setUp() {
        totalsViewModel = TotalsViewModel()
        assertEquals(0, totalsViewModel.total.value)
    }
    @Test
    fun increaseTotal() {
        val total = 5
        for (i in 0 until total) {
            totalsViewModel.increaseTotal()
        }
        assertEquals(4, totalsViewModel.total.value)
    }
}</pre></li>
				<li>In the preceding test, before testing begins, we assert that the initial value of <code>LiveData</code> is set to <code>0</code>. Then, we write a small test in which we increase the total five times, and we assert that the final value is <code>5</code>. Let’s run the test and see what happens:<pre class="source code">
java.lang.RuntimeException: Method getMainLooper in
android.os.Looper not mocked.</pre></li>
				<li>A message similar to the preceding one will appear. This is because of how <code>LiveData</code> is implemented. Internally, it uses Handlers and Loopers, part of the Android framework, thus <a id="_idIndexMarker958"/>preventing us from executing the test. Luckily, there is a way around this. We will need the following configuration in our Gradle file for our test:<pre class="source code">
testImplementation "androidx.arch.core:
core-testing:2.1.0"</pre></li>
				<li>This adds a testing library to our testing code, not our application code. Now, let’s add the following line to our code above the instantiation of the <code>ViewModel</code> class:<pre class="source code">
class TotalsViewModelTest {
    @get:Rule
    val rule = InstantTaskExecutorRule()
    private val totalsViewModel = TotalsViewModel()</pre></li>
			</ol>
			<p>We have added a <code>TestRule</code> that says every time <code>LiveData</code> has its value changed, it will make the change instantly and will avoid using the Android Framework components.</p>
			<p>Every test we write in this class will be impacted by this rule, thus giving us the freedom to play with the <code>LiveData</code> class for each new test method. If we run the test again, we will<a id="_idIndexMarker959"/> see the following:</p>
			<pre class="source code">
java.lang.RuntimeException: Method getMainLooper in
android.os.Looper not mocked</pre>
			<ol>
				<li value="9">Does this mean that our new rule didn’t work? Not exactly. If you look in your <code>TotalsViewModels</code> class, you’ll see this:<pre class="source code">
init {
         total.postValue(0)
}</pre></li>
				<li>This means that because we created the <code>ViewModel</code> class outside of the rule’s scope, the rule will not apply. We can do two things to avoid this scenario: we can change our code to handle a null value that will be sent when we first subscribe to the <code>LiveData</code> class, or we can adjust our test so that we put the <code>ViewModel</code> class in the scope of the rule. Let’s go with the second approach and change how we create our <code>ViewModel</code> class in the test. It should look something like this:<pre class="source code">
@get:Rule
val rule = InstantTaskExecutorRule()
private lateinit var totalsViewModel: TotalsViewModel
@Before
fun setUp() {
    totalsViewModel = TotalsViewModel()
    assertEquals(0, totalsViewModel.total.value)
}</pre></li>
				<li>Let’s run the test again and see what happens:<pre class="source code">
java.lang.AssertionError:
Expected :4
Actual :5</pre></li>
			</ol>
			<p>See whether you can <a id="_idIndexMarker960"/>spot where the error in the test <a id="_idTextAnchor603"/>is, fix it, and then rerun it:</p>
			<div><div><img src="img/B19411_11_05.jpg" alt="Figure 11.5 – Output of ﻿Exercise 11.02"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Output of Exercise 11.02</p>
			<p>The same output in landsca<a id="_idTextAnchor604"/>pe mode will look as follows:</p>
			<div><div><img src="img/B19411_11_06.jpg" alt="Figure 11.6 – Output of ﻿Exercise 11.02 in landscape mode"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Output of Exercise 11.02 in landscape mode</p>
			<p>By looking at the preceding example, we can see how using a combination of the <code>LiveData</code> and <code>ViewModel</code> approaches <a id="_idIndexMarker961"/>helped us solve our problem while considering the particularities of the Android operating system:</p>
			<ul>
				<li><code>ViewModel</code>: This helped us hold the data across device orientation changes, and it solved the issue of communicating between fragments</li>
				<li><code>LiveData</code>: This helped us retrieve the most up-to-date information that we’ve processed while considering the fragment’s lifecycle</li>
				<li>The combination of the two helped us efficiently delegate our processing logic, allowing us to u<a id="_idTextAnchor605"/><a id="_idTextAnchor606"/>nit test this processing logic</li>
			</ul>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor607"/>Additional data streams</h2>
			<p>One type of data stream that has<a id="_idIndexMarker962"/> gained popularity recently is the usage of Coroutines and Flows, mainly for their approach to asynchronous operations in Android. An example of Flows emitting data in a <code>ViewModel</code> would be as follows:</p>
			<pre class="source code">
class TotalsViewModel : ViewModel() {
    private val _total = MutableStateFlow(0)
    val total: StateFlow&lt;Int&gt; = _total
    fun increaseTotal() {
        _total.value = _total.value + 1
    }
}</pre>
			<p>In the preceding snippet, we have the two total declarations for public and private usage. Instead of <code>LiveData</code>, we use <code>StateFlow</code>, which will emit the current value and all subsequent new values when we subscribe to it. Because it emits the last value, we must always set an initial<a id="_idIndexMarker963"/> value when we initialize it. If we want to subscribe to changes in the total value, we can use the following:</p>
			<pre class="source code">
        val totalsViewModel =
            ViewModelProvider(requireActivity())
                .get(TotalsViewModel::class.java)
        viewLifecycleOwner.lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.CREATED) {
                totalsViewModel.total.collect {
                    updateText(it)
                }
            }
        }</pre>
			<p>The preceding snippet will subscribe to <code>StateFlow</code> every time <code>viewLifecycleOwner</code> enters the <code>CREATED</code> stage. This will connect <code>StateFlow</code> with the lifecycle of <code>Fragment</code> to prevent any possible leaks. We will explore the mechanics of Flows and Coroutines in future chapters.</p>
			<p>Another example of a data stream is the RxJava library, which represents another mechanism for emitting data. The library is best used for performing asynchronous work and transformations, and because it’s based on Java and not the Android operating system, it lacks any lifecycle awareness. For example, using RxJava in combination with ViewModels would look like the following:</p>
			<pre class="source code">
class TotalsViewModel : ViewModel() {
    private val _total = BehaviorSubject.createDefault(0)
    val total: Observable&lt;Int&gt; = _total
    fun increaseTotal() {
        _total.onNext(_total.blockingLast())
    }
}</pre>
			<p>Here, we are using <code>BehaviorSubject</code> to replace <code>StateFlow</code>. <code>BehaviorSubject</code> has the same properties as state flow. It will keep the latest value and emit it when a component subscribes and all the new values after the subscription. Subscribing to the <a id="_idIndexMarker964"/>object looks like the following:</p>
			<pre class="source code">
    private var disposable: Disposable? = null
    override fun onViewCreated(view: View,
    savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        val totalsViewModel =
            ViewModelProvider(requireActivity())
                .get(TotalsViewModel::class.java)
        disposable = totalsViewModel.total.subscribe {
            updateText(it)
        }
    }
    override fun onDestroyView() {
        disposable?.dispose()
        super.onDestroyView()
    }</pre>
			<p>Here, we are using Disposable to hold the subscription in <code>onViewCreated</code>. In <code>onDestroyView</code>, we are disposing of the subscription to prevent any context leaks. This is an alternative to using lifecycle-aware components such as <code>LiveData</code> and <code>StateFlow</code>.</p>
			<p>In this section, we looked at other types of streams of data that might be present in Android applications such as<a id="_idIndexMarker965"/> Kotlin Flows and RxJava, and analyzed their particularities. In the section that follows, we will look at how we can persist da<a id="_idTextAnchor608"/>ta us<a id="_idTextAnchor609"/>ing the Room library.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor610"/>Room</h1>
			<p>The Room persistence library<a id="_idIndexMarker966"/> acts as a wrapper between your application code and the SQLite storage. You can think of SQLite as a database that runs without its own <a id="_idIndexMarker967"/>server and saves all the application data in an internal file that’s only accessible to your application (if the device is not rooted).</p>
			<p>Room sits between the application code and the SQLite Android Framework, and handles the<a id="_idIndexMarker968"/> necessary <strong class="bold">create</strong>, <strong class="bold">read</strong>, <strong class="bold">update</strong>, and <strong class="bold">delete</strong> (<strong class="bold">CRUD</strong>) operations while exposing an abstraction that your application can use to define the data and how you want the data to be handled. This abstraction comes in the form of the following objects:</p>
			<ul>
				<li><strong class="bold">Entities</strong>: You can specify how you want your data to be stored and the relationships between your data</li>
				<li><strong class="bold">Data access object</strong> (<strong class="bold">DAO</strong>): The operations<a id="_idIndexMarker969"/> that can be done on your data</li>
				<li><strong class="bold">Database</strong>: You can specify the configurations that your database should have (the name of the database and migration scenarios)</li>
			</ul>
			<p>These <a id="_idTextAnchor611"/>can be seen in the following diagram:</p>
			<div><div><img src="img/B19411_11_07.jpg" alt="Figure 11.7 – The relationship between your application and the Room components"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – The relationship between your application and the Room components</p>
			<p>In the preceding diagram, we can see how the Room components interact with each other. It’s easier to visualize this <a id="_idIndexMarker970"/>with an example. Let’s assume you want to make a messaging app and store each message in your local storage. In this case, <code>Entity</code> would be a <code>Message</code> object, which will have an ID and will contain the contents of the message, the sender, the time, status, and so on.</p>
			<p>In order to access messages from the local storage, you will need <code>MessageDao</code>, which will contain methods such as <code>insertMessage()</code>, <code>getMessagesFromUser()</code>, <code>deleteMessage()</code>, and <code>updateMessage()</code>. In addition, since it’s a messaging application, you will need a <code>Contact</code> entity to hold information about the senders and receivers of a message.</p>
			<p>The <code>Contact</code> entity will contain information such as a name, last time online, phone number, email, and so on. In order to access the contact information, you will need a <code>ContactDao</code> interface, which will contain <code>createUser()</code>, <code>updateUser()</code>, <code>deleteUser()</code>, and <code>getAllUsers()</code>. Both entities will create a matching table in SQLite, which contains the fields we defined inside the entity classes as columns. In order to achieve this, we’ll have to create <code>MessagingDatabase</code> in which we will reference both entities.</p>
			<p>In a world without Room or similar DAO libraries, we would need to use the Android Framework’s SQLite components. This typically involves code when setting up our database, such as a query to create a table and applying similar queries for every table we would have. Every time we queried a table for data, we would need to convert the resulting object into a Java or Kotlin one.</p>
			<p>By default, Room does not allow any operations on the UI thread to enforce the Android standards related to input-output operations. To make asynchronous calls to access data, Room is compatible with a number of libraries and frameworks, such as Kotlin coroutines, RxJava, and <code>LiveData</code>, on top of its default definitions.</p>
			<p>We should now <a id="_idIndexMarker971"/>have an overview of how Room works and its main components. We will now look over each of these components and ho<a id="_idTextAnchor612"/><a id="_idTextAnchor613"/>w we can <a id="_idTextAnchor614"/>use them for data persistence.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor615"/>Entities</h2>
			<p>Entities serve two purposes: to define the structure of tables and to hold the data from a table row. Let’s use our scenario <a id="_idIndexMarker972"/>of the messaging app and define two entities: one for the<a id="_idIndexMarker973"/> user and one for the message.</p>
			<p>The <code>User</code> entity will contain information about who sent the messages, while the <code>Message</code> entity will contain information about the contents of a message, the time it was sent, and a reference to the sender of the message. The following code snippet provides an example of how entities are defined with Room:</p>
			<pre class="source code">
<strong class="bold">@Entity</strong>(tableName = "messages")
data class Message(
    <strong class="bold">@PrimaryKey</strong>(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    <strong class="bold">@ColumnInfo</strong>(name = "text", defaultValue = "") val text:
        String,
    <strong class="bold">@ColumnInfo</strong>(name = "time") val time: Long,
    <strong class="bold">@ColumnInfo</strong>(name = "user") val userId: Long,
)
<strong class="bold">@Entity</strong>(tableName = "users")
data class User(
    <strong class="bold">@PrimaryKey @ColumnInfo</strong>(name = "user_id") val id: Long,
    <strong class="bold">@ColumnInfo</strong>(name = "first_name") val firstName: String,
    <strong class="bold">@ColumnInfo</strong>(name = "last_name") val lastName: String,
    <strong class="bold">@ColumnInfo</strong>(name = "last_online") val lastOnline: Long
)</pre>
			<p>As you can see, entities are just <em class="italic">data classes</em> with annotations, which will tell Room how the tables should be built in<a id="_idIndexMarker974"/> SQLite. The annotations we used are as follows:</p>
			<ul>
				<li>The <code>@Entity</code> annotation defines the table. By default, the table name will be the name of the class. We can change the name of the table through the <code>tableName</code> method in the <code>Entity</code> annotation. This is useful in situations where we want our<a id="_idIndexMarker975"/> code obfuscated but wish to keep the consistency of the SQLite structure.</li>
				<li><code>@ColumnInfo</code> defines configurations for a certain column. The most common one is the name of the column. We can also specify a default value, the SQLite type of the field, and whether the field should be indexed.</li>
				<li><code>@PrimaryKey</code> indicates what in our entity will make it unique. Every entity should have at least one primary key. If your primary key is an integer or a long, then we can add the <code>autogenerate</code> field. This means that every entity that gets inserted into the <code>Primary Key</code> field is automatically generated by SQLite.</li>
			</ul>
			<p>Usually, this is done by incrementing the previous ID. If you wish to define multiple fields as primary keys, then you can adjust the <code>@Entity</code> annotation to accommodate this, such as the following:</p>
			<pre class="source code">
@Entity(tableName = "messages", primaryKeys = ["id",
"time"])</pre>
			<p>Let’s assume that our messaging application wants to send locations. Locations have a latitude, longitude, and name. We can add them to the <code>Message</code> class, but that would increase the complexity of the class. What we can do is create another entity and reference the ID in our class.</p>
			<p>The problem with this approach is that we would then query the <code>Location</code> entity every time we queried the <code>Message</code> entity. Room <a id="_idIndexMarker976"/>has a third approach through the <code>@Embedded</code> annotation. Now, let’s look at the updated <code>Message</code> entity:</p>
			<pre class="source code">
@Entity(tableName = "messages")
data class Message(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    @ColumnInfo(name = "text", defaultValue = "") val text:
        String,
    @ColumnInfo(name = "time") val time: Long,
    @ColumnInfo(name = "user") val userId: Long,
    <strong class="bold">@Embedded</strong> val location: Location?
)
data class Location(
    @ColumnInfo(name = "lat") val lat: Double,
    @ColumnInfo(name = "long") val log: Double,
    @ColumnInfo(name = "location_name") val name: String
)</pre>
			<p>This code adds three<a id="_idIndexMarker977"/> columns (<code>lat</code>, <code>long</code>, and <code>location_name</code>) to the messages table. This allows us to avoid having objects with a large number of fields while keeping the consistency of our tables.</p>
			<p>If we look at our entities, we’ll see that they exist independently. The <code>Message</code> entity has a <code>userId</code> field, but nothing is preventing us from adding messages from invalid users. This may lead to situations where we collect data without any purpose. If we want to delete a particular user, along with their messages, we must do so manually. Room provides us with a way to define this relationship using a <code>ForeignKey</code>:</p>
			<pre class="source code">
@Entity(
    tableName = "messages",
    <strong class="bold">foreignKeys = [ForeignKey(</strong>
<strong class="bold">        entity = User::class,</strong>
<strong class="bold">        parentColumns = ["user_id"],</strong>
<strong class="bold">        childColumns = ["user"],</strong>
<strong class="bold">        onDelete = ForeignKey.CASCADE</strong>
<strong class="bold">    )]</strong>
)
data class Message(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    @ColumnInfo(name = "text", defaultValue = "") val text:
        String,
    @ColumnInfo(name = "time") val time: Long,
    @ColumnInfo(name = "user") val userId: Long,
    @Embedded val location: Location?
)</pre>
			<p>In the preceding example, we added the <code>foreignKeys</code> field and created a new <code>ForeignKey</code> to the <code>User</code> entity, while for the parent column, we defined the <code>user_id</code> field in the <code>User</code> class, and<a id="_idIndexMarker978"/> for the child column, the <code>user</code> field in the <code>Message</code> class.</p>
			<p>Every time we add a <a id="_idIndexMarker979"/>message to the table, there needs to be a <code>User</code> entry in the <code>users</code> table. If we try to delete a user and any messages from that user still exist, then, by default, this will not work because of the dependencies. However, we can tell Room to do a cascade delete, which w<a id="_idTextAnchor616"/><a id="_idTextAnchor617"/>ill erase<a id="_idTextAnchor618"/> the user and the associated messages.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor619"/>DAO</h2>
			<p>If entities specify how we define and hold our data, then DAOs specify what to do with that data. A DAO class is a <a id="_idIndexMarker980"/>place where we define our CRUD operations. Ideally, each entity <a id="_idIndexMarker981"/>should have a corresponding DAO, but there are situations where crossovers occur (usually, this happens when we have to deal with JOINs between two tables).</p>
			<p>Continuing with our previous example, let’s build some corresponding DAOs for our entity:</p>
			<pre class="source code">
<strong class="bold">@Dao</strong>
interface MessageDao {
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertMessages(vararg messages: Message)
    <strong class="bold">@Update</strong>
    fun updateMessages(vararg messages: Message)
    <strong class="bold">@Delete</strong>
    fun deleteMessages(vararg messages: Message)
    <strong class="bold">@Query</strong>("SELECT * FROM messages")
    fun loadAllMessages(): List&lt;Message&gt;
    <strong class="bold">@Query</strong>("SELECT * FROM messages WHERE user=:userId AND
        time&gt;=:time")
    fun loadMessagesFromUserAfterTime(userId: String, time:
        Long): List&lt;Message&gt;
}
<strong class="bold">@Dao</strong>
interface UserDao {
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(user: User)
    <strong class="bold">@Update</strong>
    fun updateUser(user: User)
    <strong class="bold">@Delete</strong>
    fun deleteUser(user: User)
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): List&lt;User&gt;
}</pre>
			<p>In the case of our messages, we have defined the following functions: insert one or more messages, update one or more messages, delete one or more messages, and retrieve all the messages from a <a id="_idIndexMarker982"/>certain user that are older than a particular time. For our users, we can insert one user, update one user, delete one user, and retrieve all the users.</p>
			<p>If you look at our <code>Insert</code> methods, you’ll see<a id="_idIndexMarker983"/> we have defined that in the case of a conflict (when we try to insert something with an ID that already exists), it will replace the existing entry. The <code>Update</code> field has a similar configuration, but in our case, we have chosen the default. This means that nothing will happen if the update cannot occur.</p>
			<p>The <code>@Query</code> annotation stands out from all the others. This is where we use SQLite code to define how our read operations work. <code>SELECT *</code> means we want to read all the data for every row in the table, which will populate all our entities’ fields. The <code>WHERE</code> clause indicates a restriction that we want to apply to our query. We can also define a method like this:</p>
			<pre class="source code">
@Query("SELECT * FROM messages WHERE user IN (:userIds) AND time&gt;=:time")
fun loadMessagesFromUserAfterTime(userIds: List&lt;String&gt;, time: Long): List&lt;Message&gt;</pre>
			<p>This allows us to filter messages from multiple users. We can define a new class like this:</p>
			<pre class="source code">
data class TextWithTime(
    @ColumnInfo(name = "text") val text: String,
    @ColumnInfo(name = "time") val time: Long
)</pre>
			<p>Now, we can define the following query:</p>
			<pre class="source code">
@Query("SELECT text,time FROM messages")
fun loadTextsAndTimes(): List&lt;TextWithTime&gt;</pre>
			<p>This will allow us to extract information from certain columns at a time, not the entire row.</p>
			<p>Now, let’s say that you want to <a id="_idIndexMarker984"/>add the user information of the sender to every message. Here, we’ll need to use a similar approach to the one we used previously:</p>
			<pre class="source code">
data class MessageWithUser(
    @Embedded val message: Message,
    @Embedded val user: User
)</pre>
			<p>By using the new data class, we can define this query:</p>
			<pre class="source code">
@Query("SELECT * FROM messages INNER JOIN users on users.user_id=messages.user")
fun loadMessagesAndUsers(): List&lt;MessageWithUser&gt;</pre>
			<p>We now have the user information<a id="_idIndexMarker985"/> for every message we want to display. This will come in handy in scenarios such as group chats, where we sh<a id="_idTextAnchor620"/>ould display the name of the sender of every message.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor621"/>Setting up the database</h2>
			<p>What we have<a id="_idIndexMarker986"/> learned about so far is a bunch of DAOs and entities. Now, it’s time to put them together. First, let’s define our database:</p>
			<pre class="source code">
<strong class="bold">@Database(entities = [User::class, Message::class],</strong>
<strong class="bold">version = 1)</strong>
abstract class ChatDatabase : RoomDatabase() {
    companion object {
        private lateinit var chatDatabase: ChatDatabase
        fun getDatabase(applicationContext: Context):
        ChatDatabase {
            if (!(::chatDatabase.isInitialized)) {
                chatDatabase =
                    Room.databaseBuilder(applicationContext
                    , chatDatabase::class.java, "chat-db")
                    .build()
            }
            return chatDatabase
        }
    }
    <strong class="bold">abstract fun userDao(): UserDao</strong>
    <strong class="bold">abstract fun messageDao(): MessageDao</strong>
}</pre>
			<p>In the <code>@Database</code> annotation, we specify what entities go in our database and our version. Then, for every DAO, we define an abstract method in <code>RoomDatabase</code>. This allows the build system to build a<a id="_idIndexMarker987"/> subclass of our class in which it provides the implementations for these methods. The build system will also create the tables related to our entities.</p>
			<p>The <code>getDatabase</code> method in the companion object illustrates how we create an instance of the <code>ChatDatabase</code> class. Ideally, there should be one instance of the database for our application due to the complexity involved in building a new database object. However, this can be better achieved through a dependency injection framework.</p>
			<p>Let’s assume you’ve released your chat application. Your database is currently version one, but your users are complaining that the message status feature is missing. You decide to add this feature in the next release. This involves changing the database structure, which can impact databases that have already built their structures.</p>
			<p>Luckily, Room offers something called a migration. In the migration, we can define how our database changed<a id="_idIndexMarker988"/> between versions 1 and 2. So, let’s look at our example:</p>
			<pre class="source code">
data class Message(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name =
        "message_id") val id: Long,
    @ColumnInfo(name = "text", defaultValue = "") val text:
        String,
    @ColumnInfo(name = "time") val time: Long,
    @ColumnInfo(name = "user") val userId: Long,
    <strong class="bold">@ColumnInfo(name = "status") val status: Int,</strong>
    @Embedded val location: Location?
)</pre>
			<p>Here, we added the status<a id="_idIndexMarker989"/> flag to the <code>Message</code> entity. Now, let’s look at <code>ChatDatabase</code>:</p>
			<pre class="source code">
Database(entities = [User::class, Message::class],
<strong class="bold">version = 2</strong>)
abstract class ChatDatabase : RoomDatabase() {
    companion object {
        private lateinit var chatDatabase: ChatDatabase
        <strong class="bold">private val MIGRATION_1_2 = object : Migration(1,</strong>
<strong class="bold">        2) {</strong>
<strong class="bold">            override fun migrate(database:</strong>
<strong class="bold">            SupportSQLiteDatabase) {</strong>
<strong class="bold">                database.execSQL("ALTER TABLE messages ADD</strong>
<strong class="bold">                    COLUMN status INTEGER")</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
        fun getDatabase(applicationContext: Context):
        ChatDatabase {
            if (!(::chatDatabase.isInitialized)) {
                chatDatabase =
                   Room.databaseBuilder(applicationContext,
                   chatDatabase::class.java, "chat-db")
                   <strong class="bold">.addMigrations(MIGRATION_1_2)</strong>
                   .build()
            }
            return chatDatabase
        }
    }
    abstract fun userDao(): UserDao
    abstract fun messageDao(): MessageDao
}</pre>
			<p>In our database, we’ve increased the version to <code>2</code> and added a migration between versions <code>1</code> and <code>2</code>. Here, we added the <code>status</code> column to the table. We’ll add this migration when we build the database.</p>
			<p>Once we’ve released the<a id="_idIndexMarker990"/> new code, when the updated app is opened and the code to build the database is executed, it will compare the version of the stored data with the one specified in our class and notice a difference. Then, it will execute the specified migrations until it reaches the latest version. This allows us to maintain an application for years without impacting the user’s experience.</p>
			<p>If you look at our <code>Message</code> class, you may have noticed that we defined the time as <code>Long</code>. In Java and Kotlin, we have the <code>Date</code> object, which may be more useful than the timestamp of the message. Luckily, Room has a solution for this in the form of <code>TypeConverter</code>.</p>
			<p>The following table shows what data types we can use in our code and the SQLite equivalent. Complex data types need<a id="_idTextAnchor622"/> to be brought down to these levels using TypeConverters:</p>
			<div><div><img src="img/B19411_11_08.jpg" alt="Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite data types"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – The relationship between Kotlin/Java data types and the SQLite data types</p>
			<p>Here, we’ve <a id="_idIndexMarker991"/>modified the <code>lastOnline</code> field so that it’s of the <code>Date</code> type:</p>
			<pre class="source code">
data class User(
    @PrimaryKey @ColumnInfo(name = "user_id") val id: Long,
    @ColumnInfo(name = "first_name") val firstName: String,
    @ColumnInfo(name = "last_name") val lastName: String,
    <strong class="bold">@ColumnInfo(name = "last_online") val lastOnline: Date</strong>
)</pre>
			<p>Here, we’ve defined a couple of methods that convert a <code>Date</code> object into <code>Long</code> and vice versa. The <code>@TypeConverter</code> annotation helps Room identify where the conversion takes place:</p>
			<pre class="source code">
class DateConverter {
    <strong class="bold">@TypeConverter</strong>
    fun from(value: Long?): Date? {
        return value?.let { Date(it) }
    }
    <strong class="bold">@TypeConverter</strong>
    fun to(date: Date?): Long? {
        return date?.time
    }
}</pre>
			<p>Finally, we’ll add our converter to Room using the <code>@</code><code>TypeConverters</code> annotation:</p>
			<pre class="source code">
@Database(entities = [User::class, Message::class],
version = 2)
<strong class="bold">@TypeConverters(DateConverter::class)</strong>
abstract class ChatDatabase : RoomDatabase() {</pre>
			<p>In the <a id="_idTextAnchor623"/><a id="_idTextAnchor624"/>next section, we will look<a id="_idIndexMarker992"/> at some third-party frameworks.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor625"/>Third-party frameworks</h2>
			<p>Room works well with third-party <a id="_idIndexMarker993"/>frameworks such as <code>LiveData</code>, RxJava, and coroutines. This solves two issues: multi-threading and observing data changes.</p>
			<p><code>LiveData</code> will make the <code>@Query</code> annotated methods in your DAOs reactive, which means that if new data is added, <code>LiveData</code> will notify the observers of this:</p>
			<pre class="source code">
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): LiveData&lt;List&lt;User&gt;&gt;</pre>
			<p>Kotlin coroutines complement <code>LiveData</code> by making the <code>@Insert</code>, <code>@Delete</code>, and <code>@Update</code> methods asynchronous:</p>
			<pre class="source code">
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertUser(user: User)
    <strong class="bold">@Update</strong>
    suspend fun updateUser(user: User)
    <strong class="bold">@Delete</strong>
    suspend fun deleteUser(user: User)</pre>
			<p><code>@Query</code> methods reactive through components such as <code>Publisher</code>, <code>Observable</code>, or <code>Flowable</code> and making the rest of the methods asynchronous <a id="_idIndexMarker995"/>through <code>Completable</code>, <code>Single</code>, or <code>Maybe</code>:</p>
			<pre class="source code">
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(user: User) : Completable
    <strong class="bold">@Update</strong>
    fun updateUser(user: User) : Completable
    <strong class="bold">@Delete</strong>
    fun deleteUser(user: User) : Completable
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): Flowable&lt;List&lt;User&gt;&gt;</pre>
			<p><strong class="bold">Executors and threads</strong> come with the Java framework and can be a useful solution for solving threading issues with Room if <a id="_idIndexMarker996"/>none of the aforementioned third-party integrations are part of your project.</p>
			<p>Your DAO classes will not suffer from any modifications; however, you will need the components that access your DAOs to adjust and use either an executor or a thread:</p>
			<pre class="source code">
    <strong class="bold">@Query</strong>("SELECT * FROM users")
    fun loadAllUsers(): List&lt;User&gt;
    <strong class="bold">@Insert</strong>(onConflict = OnConflictStrategy.REPLACE)
    fun insertUser(user: User)
    <strong class="bold">@Update</strong>
    fun updateUser(user: User)
    <strong class="bold">@Delete</strong>
    fun deleteUser(user: User)</pre>
			<p>An example of accessing the DAO is as follows:</p>
			<pre class="source code">
    fun getUsers(usersCallback:()-&gt;List&lt;User&gt;){
        Thread(Runnable {
            usersCallback.invoke(userDao.loadUsers())
        }).start()
    }</pre>
			<p>The preceding example will create a new thread and start it every time we want to retrieve the list of users. There are <a id="_idIndexMarker997"/>two major issues with this code:</p>
			<ul>
				<li>Thread creation is an expensive operation</li>
				<li>The code is hard to test</li>
			</ul>
			<p>The solution to the first is to use <code>ThreadPools</code> and <code>Executors</code>. The Java framework offers a robust set of options when it comes to <code>ThreadPools</code>. A thread pool is a component responsible for thread <a id="_idIndexMarker998"/>creation and destruction and allows the developer to specify the number of threads in the pool. Multiple threads in a thread pool will ensure multiple tasks can be executed concurrently.</p>
			<p>We can rewrite the preceding code as follows:</p>
			<pre class="source code">
    private val executor:Executor =
        Executors.newSingleThreadExecutor()
    fun getUsers(usersCallback:(List&lt;User&gt;)-&gt;Unit){
        executor.execute {
            usersCallback.invoke(userDao.loadUsers())
        }
    }</pre>
			<p>In the preceding example, we defined an executor that will use a pool of one thread. When we want to access the list of users, we move the query inside the executor, <a id="_idTextAnchor626"/><a id="_idTextAnchor627"/>and when the data is loaded, our callback lambda will be invoked.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor628"/>Exercise 11.03 – making a little room</h2>
			<p>You have been hired by a news <a id="_idIndexMarker999"/>agency to build a news application. The application will display a list of articles written by journalists. An article can be written by one or more journalists, and each journalist can write one or more articles. The data information for each article includes the article’s title, content, and date.</p>
			<p>The journalist’s information includes their first name, last name, and job title. You will need to build a Room database that holds this information so it can be tested. Before we start, let’s look at the relationship between the entities. In the chat application example, we defined the rule that one user can send one or multiple messages.</p>
			<p>This relationship is known as a<a id="_idIndexMarker1000"/> one-to-many relationship. That relationship is implemented as a reference between one entity to another (the user was defined in the message table in order to be connected to the sender).</p>
			<p>In this case, we have a many-to-many relationship. To implement a many-to-many relationship, we need to create an entity that holds references that will link the other two entities. Let’s get started:</p>
			<ol>
				<li>Create a new Android Project with No Activity.</li>
				<li>Let’s start by adding the annotation processing plugin to <code>app/build.gradle</code>. This will read the annotations used by Room and generate the code necessary for interacting with the database:<pre class="source code">
plugins {
    …
    id 'kotlin-kapt'
}</pre></li>
				<li>Next, let’s add the Room libraries in <code>app/build.gradle</code>:<pre class="source code">
def room_version = "2.2.5"
implementation "androidx.room:
    room-runtime:$room_version"
kapt "androidx.room:room-compiler:$room_version"</pre></li>
			</ol>
			<p>The first line defines the library version, the second line brings in the Room library for Java and Kotlin, and the last line is for the Kotlin annotation processor. This allows the build system to generate boilerplate code from the Room annotations. After these changes to your Gradle files, you should get a prompt to sync your project, which you should click.</p>
			<ol>
				<li value="4">Let’s define our entities<a id="_idIndexMarker1001"/> in the <code>main/java</code> folder and the root package:<pre class="source code">
@Entity(tableName = "article")
data class Article(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(
        name = "id") val id: Long = 0,
    @ColumnInfo(name = "title") val title: String,
    @ColumnInfo(name = "content") val content: String,
    @ColumnInfo(name = "time") val time: Long
)
@Entity(tableName = "journalist")
data class Journalist(
    @PrimaryKey(autoGenerate = true) @ColumnInfo(name
        = "id") val id: Long = 0,
    @ColumnInfo(name = "first_name") val firstName:
        String,
    @ColumnInfo(name = "last_name") val lastName:
        String,
    @ColumnInfo(name = "job_title") val jobTitle:
        String
)</pre></li>
				<li>Now, define the entity that connects the journalist to the article and the appropriate constraints<a id="_idIndexMarker1002"/> in the <code>main/java</code> folder and the root package:<pre class="source code">
@Entity(
    tableName = "joined_article_journalist",
    primaryKeys = ["article_id", "journalist_id"],
    foreignKeys = [ForeignKey(
        entity = Article::class,
        parentColumns = arrayOf("id"),
        childColumns = arrayOf("article_id"),
        onDelete = ForeignKey.CASCADE
    ), ForeignKey(
        entity = Journalist::class,
        parentColumns = arrayOf("id"),
        childColumns = arrayOf("journalist_id"),
        onDelete = ForeignKey.CASCADE
    )]
)
data class JoinedArticleJournalist(
    @ColumnInfo(name = "article_id") val articleId:
        Long,
    @ColumnInfo(name = "journalist_id") val
        journalistId: Long
)</pre></li>
			</ol>
			<p>In the preceding code, we defined our connecting entity. As you can see, we haven’t defined an ID for uniqueness, but both the article and the journalist will be unique when used<a id="_idIndexMarker1003"/> together. We also defined foreign keys for each of the other entities referred to by our entity.</p>
			<ol>
				<li value="6">Create the <code>ArticleDao</code> DAO in the <code>main/java</code> folder and the root package:<pre class="source code">
@Dao
interface ArticleDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertArticle(article: Article)
    @Update
    fun updateArticle(article: Article)
    @Delete
    fun deleteArticle(article: Article)
    @Query("SELECT * FROM article")
    fun loadAllArticles(): List&lt;Article&gt;
    @Query("SELECT * FROM article INNER JOIN
            joined_article_journalist ON
            article.id=joined_article_journalist
            .article_id WHERE
            joined_article_journalist.journalist_id=
            :journalistId")
    fun loadArticlesForAuthor(journalistId: Long):
        List&lt;Article&gt;
}</pre></li>
				<li>Now, create the <code>JournalistDao</code> data access object in the <code>main/java</code> folder and the root package:<pre class="source code">
@Dao
interface JournalistDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertJournalist(journalist: Journalist)
    @Update
    fun updateJournalist(journalist: Journalist)
    @Delete
    fun deleteJournalist(journalist: Journalist)
    @Query("SELECT * FROM journalist")
    fun loadAllJournalists(): List&lt;Journalist&gt;
    @Query("SELECT * FROM journalist INNER JOIN
            joined_article_journalist ON
            journalist.id=joined_article_journalist
            .journalist_id WHERE
            joined_article_journalist.article_id=
            :articleId")
    fun getAuthorsForArticle(articleId: Long):
        List&lt;Journalist&gt;
}</pre></li>
				<li>Create<a id="_idIndexMarker1004"/> the <code>JoinedArticleJournalistDao</code> DAO in the <code>main/java</code> folder and the root package:<pre class="source code">
@Dao
interface JoinedArticleJournalistDao {
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    fun insertArticleJournalist(
      joinedArticleJournalist: JoinedArticleJournalist
    )
    @Delete
    Fun deleteArticleJournalist(
      joinedArticleJournalist: JoinedArticleJournalist
    )
}</pre></li>
			</ol>
			<p>Let’s analyze our code a little bit. For the articles and journalists, we can add, insert, delete, and update queries. For articles, we can extract all of the articles but also extract articles from a certain author.</p>
			<p>We also have the option to extract all the journalists that wrote an article. This is done through a JOIN<a id="_idIndexMarker1005"/> with our intermediary entity. For that entity, we define the options to insert (which will link an article to a journalist) and delete (which will remove that link).</p>
			<ol>
				<li value="9">Finally, let’s define our <code>Database</code> class in the <code>main/java</code> folder and the root package:<pre class="source code">
@Database(
    entities = [Article::class, Journalist::class,
        JoinedArticleJournalist::class],
    version = 1
)
abstract class NewsDatabase : RoomDatabase() {
    abstract fun articleDao(): ArticleDao
    abstract fun journalistDao(): JournalistDao
    abstract fun joinedArticleJournalistDao():
        JoinedArticleJournalistDao
}</pre></li>
			</ol>
			<p>We avoided defining the <code>getInstance</code> method here because we won’t be calling the database anywhere. But if we don’t do that, how will we know whether it works? The answer to this is that we’ll test it. This won’t be a test that will run on your machine but one that will run on the device. This means that we will create it in the <code>androidTest</code> folder.</p>
			<ol>
				<li value="10">Let’s start by setting <a id="_idIndexMarker1006"/>up the test data. Here, we will add some articles and journalists to the database then test retrieving, updating, and deleting the entries:<pre class="source code">
@RunWith(AndroidJUnit4::class)
class NewsDatabaseTest {
    @Test
    fun updateArticle() {
        val article = articleDao.loadAllArticles()[0]
        articleDao.updateArticle(article.copy(title = 
            "new title"))
        assertEquals("new title", articleDao.
            loadAllArticles()[0].title)
    }
    @Test
    fun updateJournalist() {
        val journalist = journalistDao.
            loadAllJournalists()[0] journalistDao.
            updateJournalist(journalist.copy(jobTitle = 
            "new job title"))
        assertEquals("new job title", journalistDao.
            loadAllJournalists()[0].jobTitle)
    }
}</pre></li>
			</ol>
			<p>The complete code for this step can be found at <a href="https://packt.link/6H8X2">https://packt.link/6H8X2</a>.</p>
			<p>Here, we have defined a few examples of how to test a Room database. What’s interesting is how we build the database. Our database is an in-memory database. This means that all the data will be kept as long as the test is run and discarded afterward.</p>
			<p>This allows us to start with<a id="_idIndexMarker1007"/> a clean slate for each new state and avoids the consequences of each of our testing sessions affecting each other. In our test, we’ve set up 5 articles and 10 journalists. The first article was written by the top two journalists, while the second article was written by the first journalist.</p>
			<p>The rest of the articles have no authors. By doing this, we can test our update and delete methods. For the delete method, we can test our foreign key relationship as well. In the test, we can see that if we delete article <code>1</code>, it will delete the relationship between the article and the journalists that wrote it.</p>
			<p>When testing your database, you should add the scenarios that your app will use. Feel free to add other testing scenarios and improve the preceding tests in your own database. Note that if you are using the <code>androidTest</code> folder, then this will be an inst<a id="_idTextAnchor629"/><a id="_idTextAnchor630"/><a id="_idTextAnchor631"/><a id="_idTextAnchor632"/>r<a id="_idTextAnchor633"/><a id="_idTextAnchor634"/>umented test, meaning that you will need an emulator or a device to test.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor635"/>Activity 11.01 – a shopping notes app</h2>
			<p>You want to keep track of your shopping items, so you decide to build an app to save the items you wish to<a id="_idIndexMarker1008"/> buy during your next trip to the store. The requirements for this are as follows:</p>
			<ul>
				<li>The UI will be split into two: top/bottom in portrait mode and left/right in landscape mode. The UI will look similar to what is shown in the following screenshot.</li>
				<li>The first half will display the number of notes, a text field, and a button. Every time the button is pressed, a note will be added with the text placed in the text field.</li>
				<li>The second half will display the list of notes.</li>
				<li>For each half, you will have a View model that will hold the relevant data.</li>
				<li>You should define a repository that will be used on top of the Room database to access your data.</li>
				<li>You should also <a id="_idIndexMarker1009"/>define a Room database that will hol<a id="_idTextAnchor636"/>d your notes.</li>
				<li>The note entity will have the following attributes: <code>id</code> and <code>text</code>:</li>
			</ul>
			<div><div><img src="img/B19411_11_09.jpg" alt="Figure 11.9 – Example of a possible output for activity 11.01"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Example of a possible output for activity 11.01</p>
			<p>Perform the following steps to complete this activity:</p>
			<ol>
				<li>Start with Room integration by creating the <code>Entity</code>, <code>Dao</code>, and <code>Database</code> methods. For <code>Dao</code>, the <code>@Query</code> annotated methods can directly return a <code>LiveData</code> object so that the observers can be directly notified if the data changes.</li>
				<li>Define a template of our repository in the form of an interface.</li>
				<li>Implement the repository. The repository will have one reference to the <code>Dao</code> object we defined previously. The code for inserting the data must be moved to a separate thread.</li>
				<li>Create the <code>NotesApplication</code> class to provide one instance of the repository that will be used across the application. Make sure to update the <code>&lt;application&gt;</code> tag in the <code>AndroidManifest.xml</code> file to add your new application class.</li>
				<li>Unit-test the<a id="_idIndexMarker1010"/> repository and define <code>ViewModels</code>, as follows:<ol><li>Define <code>NoteListViewModel</code> and the associated test. This will have a reference to the repository and return the list of notes.</li><li>Define <code>CountNotesViewModel</code> and the associated test. <code>CountViewModel</code> will have a reference to the repository and return the total number of notes as <code>LiveData</code>. It will also be responsible for inserting new notes.</li><li>Define <code>CountNotesFragment</code> and the associated <code>fragment_count_notes.xml</code> layout. In the layout, define a <code>TextView</code>, which will display the total number, an <code>EditText</code> for the name of the new notes, and a button, which will insert the note that was introduced in <code>EditText</code>.</li><li>Define an adapter for the list of notes called <code>NoteListAdapter</code> and an associated layout file for the rows called <code>view_note_item.xml</code>.</li><li>Define the associated layout file, called <code>fragment_note_list.xml</code>, which will contain <code>RecyclerView</code>. The layout will be used by <code>NoteListFragment</code>, which will connect <code>NoteListAdapter</code> to <code>RecyclerView</code>. It will also observe the data from <code>NoteListViewModel</code> and update the adapter.</li><li>Define <code>NotesActivity</code> with an associated layout for landscape mode and portrait mode.</li></ol></li>
				<li>Make sure you have <a id="_idIndexMarker1011"/>all the necessary data in <code>strings.xml</code>.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="https://packt.link/ZhnDx">https://packt.link/ZhnDx</a>.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor637"/>Summary</h1>
			<p>In this chapter, we analyzed the building blocks required to build a maintainable application. We also looked into one of the most common issues that developers come across when using the Android Framework, which is maintaining the states of objects during lifecycle changes.</p>
			<p>We started by analyzing <code>ViewModels</code> and how they solve the issue of holding data during orientation changes. We added <code>LiveData</code> to <code>ViewModels</code> to show how the two complement each other and looked at how we can use other data streams with <code>ViewModels</code> and compare those with <code>LiveData</code>.</p>
			<p>We then moved on to Room to show how we can persist data with minimal effort and without much SQLite boilerplate code. We also explored one-to-many and many-to-many relationships, as well as how to migrate data and break down complex objects into primitives for storage.</p>
			<p>The activity we completed in this chapter serves as an example of what direction Android apps are heading in. However, this was not a complete example due to the numerous frameworks and libraries that you will discover, which give developers the flexibility to go in different directions.</p>
			<p>The information you’ve learned in this chapter will serve you well for the next one, which will expand on the concept of repositories. This will allow you to save data that’s been obtained from a server into a Room database.</p>
			<p>The concept of persisting data will also be expanded as you will explore other ways to persist data, such as through <code>SharedPreferences</code>, <code>DataStore</code>, and files. Our focus will be on certain types of files: media files obtained from the camera of the device.</p>
		</div>
	</body></html>