- en: Chapter 5. Function and Operator Changes – New Ways to Get Things Done
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to write useful code in Swift, or in any programming language, you
    have to, at the very least, create functions and use operators. In this chapter,
    we will examine what's changed in function declaration and usage and how those
    changes translate into better Swift code. We will also explain operator changes
    and highlight several that have been removed from the language.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the theme from the last chapter, I will provide you the Swift Evolution
    proposal numbers. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Function declaration changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift provides a very flexible set of rules for defining functions. You can
    create functions with no parameters, with parameters, or even with argument labels.
    Every Swift function has a type, parameters (or no parameters), and a return type.
    For Swift 3, the language has been tweaked to make things more consistent and
    less complex.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent parameter labeling [SE-0046]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Parameter labels are used for naming each argument in the function definition.
    In Swift 2.2 and earlier, function parameters could be defined with a local and
    an external label. The local argument label is required as this label is used
    to refer to the parameter in the body of the function. The external argument label,
    when provided, was used in the actual function call. You can think of the external
    label as your *shiny descriptive name at the call site* to provide good insight
    into what the argument represents. The internal label is, as the name implies,
    the name your function uses in the implementation of your logic. Since no one
    sees that local parameter, you could make it shorter to save some keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: Here's where things get interesting. By default, Swift 2.2 drops your external
    name when your function is called. Further adding to the confusion, Swift uses
    your local name as the external name for any remaining parameters, when external
    names are not present. The truly odd thing is that Swift only does this for functions.
    When you create a class, structure, or enumeration initializer (a special type
    of function to set initial values), Swift will create an external name for every
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift Enumerations can be defined using a raw-value type. When you create a
    Swift enum using a raw-value, you will either get an initialized enum or nil.
    You can read more about Swift enums at [https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145](https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145)
  prefs: []
  type: TYPE_NORMAL
- en: The main reason for dropping the first argument name seems to be for historical
    correctness with Objective-C. Objective-C developers were instructed to incorporate
    the first parameter name into the function name. This same behavior was adopted
    by Swift and may have been a side effect of the initial translation of Objective-C
    libraries to Swift via the migrator.
  prefs: []
  type: TYPE_NORMAL
- en: Swift is an evolving language and is getting better with each new version. To
    stay consistent with the new API naming guidelines, Swift 3 now defaults to using
    the local names as the external names for all arguments including the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Last thought — if you prefer to not use argument labels in your function calls,
    you can suppress them using an underscore as the external name. This works for
    any of the argument positions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md](https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md)
  prefs: []
  type: TYPE_NORMAL
- en: Removing currying func syntax in declaration [SE0002]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Swift 2, you had the ability to create curried functions; which were rather
    confusing and seem to have little value in Swift. Much of the developer confusion
    in using them centers on whether the curried arguments are part of the main argument
    list or if the curried arguments signify the beginning of the argument list for
    a new function. Let''s consider the following example that uses curried arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s extremely confusing to tell if the `(siny: Int)-> Float` is part of the
    argument. The Swift team ultimately decided that we just don''t need this in the
    language. Therefore, Swift 3 removes this syntax and suggests that you re-write
    your function to return a closure instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In our revised example, we define our function to return a closure. We then
    assign the result of this initial call to a variable named `intermediateFunctionReturn`.
    Last, we call the `intermediateFunctionReturn` closure, passing our Int argument,
    to get our final result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md](https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md)
  prefs: []
  type: TYPE_NORMAL
- en: Warning on Unused Results by Default [SE-0047]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attributes are special constructs that you apply to a declaration or type. You
    specify an attribute using the `@` symbol followed by a name and optionally any
    attribute arguments in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In Swift 2, the `@warn_unused_result` attribute is applied to a function or
    method to let the compiler know that it should provide a warning to the user if
    the attributed method or function is called without using the result. The `@warn_unused_result`
    attribute also allows you to provide either a message or `mutable_variant` attribute
    argument. The `mutable_variant` option is used when you want to let the developer
    know the name of the mutating method that accomplishes the same thing. The intent
    of using the attribute is to give guidance to the developer using your method,
    that the returned value is important and should be used.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Swift 2 provides a `sort()` method and a `sortInPlace()` method
    (mutating) on the Foundation collection classes. If you were to call `sort()`(non-mutating)
    on an array but not use the result, then the compiler would warn you that you
    might really need the `sortInPlace()` method, which mutates the array and doesn't
    return anything. You can see an example usage of the `@warn_unused_result` below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The main issue that developers have with `@warn_unused_result` is that it is
    only helpful if you apply the attribute to all of the relevant places (i.e. it
    is a proactive strategy on your part). If you forget to add the attribute, then
    no warnings will be sent. In Swift 3, the logic is reversed and you now get a
    warning on unused results by default. If you want to explicitly let the compiler
    know that the return value can safely be ignored, you can use the `@discardableResult`
    attribute. Here is an example that demonstrates its usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Swift 3, the mutating method `sortInPlace()` became `sort()` and the non-mutating
    version changed from `sort()` to `sorted()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md](https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md)
  prefs: []
  type: TYPE_NORMAL
- en: Removing var from function parameter lists [SE-0003]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using var in a function parameter list was valid in Swift 2\. Since parameter
    types are immutable by default, developers attempted to use var in the parameter
    list to pass a mutable parameter to their function implementation. While you could
    do this in Swift, it actually proved to be a fairly useless tactic. Let me explain.
    Yes, you can use the var keyword to pass a mutable variant to your function body.
    However, any changes you make to the variable are not propagated back to the original
    type. Therefore, you are using a mutable copy that is scoped to the function''s
    body. Let''s examine how this works in practice with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You could have, just as easily, accomplished the same objective by assigning
    the passed in parameter to a local copy within the function body. See below for
    the equivalent function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, many developers were confusing var parameters with those marked as
    inout. Either version will give a mutable local copy but only the inout variant
    will propagate changes back to function caller. Given the overall confusion, var
    as a parameter modifier has been removed in Swift 3\. In the following example,
    the `howManyTimes` variable is updated with its value propagated back to the function
    caller because it is marked as an inout parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md](https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md)
  prefs: []
  type: TYPE_NORMAL
- en: Removing ++ and -- operators [SE-0004]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The increment (`++`) and decrement (`--`) operators were added to Swift because
    they existed in C. In addition, many developers coming to Swift are used to seeing
    them in the other languages. Let's examine how these operators work and then we
    can cover the gotchas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Disadvantages /Gotchas:'
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to get the pre and post part of the increment/decrement operator wrong,
    which gives you an incorrect output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The syntax is shorthand for `+=` or `-=`, which doesn't save you that many keystrokes
    over `+= 1` or `-= 1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operators are largely used in C style `for…loops`, where the return value
    is ignored. Since we have `for…loops` loops, ranges, maps, and enumerate/iterate
    functions, we don't need these operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can only use these operators with a small set of types (such as integers
    and floating point scalars)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are learning your first programming language, these operators increase
    the amount of stuff you have to learn without providing meaningful value you couldn't
    get through other features that Swift offers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essentially, the Swift team felt the disadvantages of keeping these operators
    outweighed the advantages and opted to remove them in Swift 3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can read the proposal here: [https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md](https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md)'
  prefs: []
  type: TYPE_NORMAL
- en: Removing C-style for loops [SE-0007]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the increment and decrement operators we just discussed, the C-style
    `for…in` loop also seems to have been added to Swift for its C language ancestry.
    Swift offers several *Swifty* conventions for iterating and looping that are better
    options than the C-style loop. In fact, C-style loops really aren't used all that
    much. Once a developer starts to master Swift concepts, the developer generally
    chooses not to use C-style loops. When considering the iteration of a collection,
    `for…in` loops are considerably harder to implement than `for…in` statements.
    Finally, if C-style `for` loops did not already exist in Swift; no one would miss
    them or beg for their inclusion into the language. With Swift 3, C-style for loops
    are officially eliminated from the language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md)
  prefs: []
  type: TYPE_NORMAL
- en: Removing implicit tuple splat from functions [SE-0029]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous versions of Swift, function calls allowed developers to pass an
    argument list in the form of a tuple, commonly referred to as a *tuple splat*.
    A *tuple splat* could be defined in one place and then passed to a function as
    one object, removing the need to pass individual arguments to a function. Let's
    take a look at an example to make this concept clearer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we create the `fooTastic()` function to accept two String array
    arguments. We then created a tuple that encapsulates the arguments we want to
    pass to our function. Last, we call `fooTastic()` passing in our foo tuple. This
    works, but here are some disadvantages to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `foo` tuple has to mirror the way the arguments are represented in the
    function: meaning we have to drop the members parameter label. We must include
    the instruments label in our tuple or the compiler will complain when we pass
    the tuple as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing just a tuple to the function makes our method appear to have overloads,
    which is confusing to anyone tasked with maintaining this code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current implement of tuple splats is inconsistent and buggy in terms of
    implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All things considered, we just don't need this added complexity in the language
    and hence this feature has been removed from Swift 3.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md](https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md)
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting inout declarations for type decoration [SE-0031]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a minor change for Swift 3\. The *inout* keyword has been moved to the
    right of the colon (:) and next to the type in function definitions. Nothing has
    changed about how `inout` variables behave in code. You are still giving the parameter
    decorated with `inout `the ability to mutate the value within the body of the
    function. The change is meant to move the decoration name closer to the type it
    is actually modifying. Since we are modifying the type and not the label, it makes
    more sense for the keyword to be next to the type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md](https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md)
  prefs: []
  type: TYPE_NORMAL
- en: Replacing equal signs with colons for attribute arguments [SE-0040]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we discussed in *[SE-0047]*, attributes are special constructs that you
    apply to a declaration or type. You specify an attribute using the `@` symbol
    followed by a name and optionally any attribute arguments in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unlike regular functions and parameter labels, you use `=` instead of a colon
    to separate the argument name from its value. This is inconsistent with our standard
    mode of operation in the rest of Swift. Therefore, in Swift 3, attribute arguments
    will receive the same treatment as other Swift arguments, using the colon over
    and equal sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md](https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md)
  prefs: []
  type: TYPE_NORMAL
- en: Standardizing function type argument syntax to require parentheses [SE-0066]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functions are defined in Swift to use parentheses to enclose their argument
    lists. The purpose is to make it clear where the function declaration begins and
    ends. However, Swift 2 allowed you to call a function, under certain conditions,
    without using the parentheses. Let''s look at an example to make this concept
    clearer. In the following example, we define functions using parentheses and their
    equivalents by dropping the parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be written without parentheses as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Granted, the second form is a bit shorter since it omits the parentheses. However,
    the trade-off introduces code that is not consistent with the way the function
    types are defined in the rest of the language. Frankly, you don't get any real
    value or expressive components by omitting the parentheses. Crafting function
    types this way is only syntactic sugar with no substance. In Swift 3, you will
    no longer be able to use this shortcut form when defining function types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md](https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md)
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing the order of defaulted parameters [SE-0060]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Order matters when you call a function in Swift, but there is one exception
    to this rule for functions that contain parameters with default arguments. Under
    this edge case, you can call this type of function using only a portion of the
    argument names. Let's look at some examples of how you can call a function that
    contains default parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first way to call the `shifty()` function is to use all of the default
    parameters, meaning we don''t pass anything at the call site. This is valid in
    Swift 2 and is generally expected behavior. See below for an example using just
    the function with all default parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to call the `shifty()` would be to omit the arguments we don''t
    care about and only pass in the ones we do. We could pass in just one argument
    such as arg2 or arg3 and our function would continue to work. In the following
    example, we demonstrate calling our shifty function while omitting some of the
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we could call the function with multiple arguments. See below for
    example usage of the shifty function with multiple arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Allowing this behavior is actually a bit confusing to developers and goes against
    the strict ordering that is enforced throughout the rest of the language. Swift
    3 removes this behavior and forces you to maintain the parameter ordering when
    using default parameters. Let's see how our `shifty()` function works now in Swift
    3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no change to how we call a function using all defaulted arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When we call a function with just one argument, we have to use the argument
    label for our parameter. The other difference is that we can not just call the
    arguments in any order we choose. We can omit defaulted parameters but we can
    not call them in any order we choose. Let's examine some of the ways we can call
    our `shifty()` function in Swift 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you think about this for a while, I bet you could see why the Swift team
    made this change. We sacrifice a shorter syntax for enhanced readability.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md](https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md)
  prefs: []
  type: TYPE_NORMAL
- en: Making optional requirements Objective-C only [SE-0070]
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objective-C protocols have a feature that allows the developer to mark some
    of the behavior as optional. While this makes sense for Objective-C, it would
    not make sense as a Swift feature. In Swift, the protocol author could provide
    a default implementation using protocol extensions and protocol inheritance. Similarly,
    with protocol inheritance, the author could add the optional methods to a separate
    protocol that a developer could adopt if the optional behavior is of interest
    and not make it a requirement for all users of the protocol. The main takeaway
    is that you have better options in Swift for tackling optional protocol requirements
    and, therefore, adding Objective-C optional features on protocols to Swift is
    not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know why the Swift team opted not to include this as a Swift feature,
    let's discuss how to handle Objective-C optional in Swift 3\. Basically, we use
    the `@objc` attribute to decorate the parts of the protocol we want to distinguish
    as an Objective-C only requirement. We also add the optional keyword to each of
    the function signatures. For the most part, you won't have to change anything
    on your end in Swift. You also don't have to modify your Objective-C code. The
    migrator handles all of the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Our code snippets above show the Objective-C protocol (with optional methods)
    and the Swift version once it is passed through the migrator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md](https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered how functions are created and called. We touched
    on several features that weren't very *Swifty* and have been removed in Swift
    3\. We also explored attributes and attribute arguments, focusing on syntax changes,
    and new additions and subtractions from the language. In the next chapter, we
    will do a deep dive into closures and collections.
  prefs: []
  type: TYPE_NORMAL
