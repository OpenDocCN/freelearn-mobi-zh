<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Animating Sprites, Controls, and SceneKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Animating Sprites, Controls, and SceneKit</h1></div></div></div><p>In the previous chapter, we learned about physics engine in detail. We discussed <code class="literal">SKPhysicsBody</code>, that is, edge-based and volume-based physics bodies. We also got to know about the various initialization methods and physics properties, which helped us in integrating physics into our <span class="emphasis"><em>Platformer</em></span> game. Now we have a much clear idea about how to simulate physics in a Sprite Kit game.</p><p>It is always good to have nice animated features in our game to enhance the user experience; this Sprite Kit has the <code class="literal">SKAction</code> class, which helps us to apply actions on nodes such as moving of nodes, rotating of nodes, scaling of nodes, and so on. For example, using animations during player movement or depicting collisions using animations, and so on. It's time for us to discuss about the <code class="literal">SKAction</code> class and also about implementing animations in our <span class="emphasis"><em>Platformer</em></span> game.</p><p>Along with animation, we are also going to discuss about how we can provide controls in our game, such as having a reaction when the user taps on the screen or using the accelerometer to respond to directions in a game. We will also implement controls in our <span class="emphasis"><em>Platformer</em></span> game and add a jump button to make the player jump over the blocks.</p><p>Scene Kit is a 3D graphics framework provided by Apple, we can use SceneKit's 3D elements in our Sprite Kit game to further enhance the gaming experience and have a better gameplay if required. We are going to discuss about how we can integrate SceneKit in a Sprite Kit game.</p><div class="section" title="Animating nodes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Animating nodes</h1></div></div></div><p>Animated pictures give a very dynamic and polished feel during a gameplay; it is always preferred to have<a id="id290" class="indexterm"/> animations in our game. To add animations in Sprite Nodes, we can use the <a id="id291" class="indexterm"/>
<code class="literal">SKAction</code> class properties and methods, which add the animations to the Sprite Kit nodes. Let's discuss about the <code class="literal">SKAction</code> class in detail.</p><div class="section" title="SKAction"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec51"/>SKAction</h2></div></div></div><p>Properties and methods <a id="id292" class="indexterm"/>of the <code class="literal">SKAction</code> class help in providing the actions to the nodes in a scene. Actions are used to change the arrangement and appearance of the node to which they are attached. Actions in a node are executed when the scene runs its nodes.</p><p>To assign an action we can call the particular <code class="literal">SKAction</code> class method as required. Then, we can configure the properties of the actions. In the end, for the execution of the action, we call the node object's <code class="literal">runAction()</code> method and pass the action's object.</p></div><div class="section" title="Adding a single action to a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec52"/>Adding a single action to a node</h2></div></div></div><p>There are two steps<a id="id293" class="indexterm"/> to add a single action to the node:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Creating an action</strong></span>: First of all, we create<a id="id294" class="indexterm"/> an action which can perform <a id="id295" class="indexterm"/>a particular activity such as rotating, scaling, moving, and so on, on the Sprite Kit node.</li><li class="listitem"><span class="strong"><strong>Executing an action</strong></span>: Finally, we run the<a id="id296" class="indexterm"/> action on the node by calling the <code class="literal">runAction()</code> method on that node.</li></ol></div></div><div class="section" title="Adding multiple actions to a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec53"/>Adding multiple actions to a node</h2></div></div></div><p>There are three steps<a id="id297" class="indexterm"/> involved in the process of adding multiple actions to the node:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Creating actions</strong></span>: Here, instead<a id="id298" class="indexterm"/> of creating a single action, we <a id="id299" class="indexterm"/>can create multiple actions to perform different behaviors on the Sprite Kit node.</li><li class="listitem"><span class="strong"><strong>Creating action sequence</strong></span>: Here, we are going to create the order of execution in which the actions<a id="id300" class="indexterm"/> should behave in the Sprite Kit node.</li><li class="listitem"><span class="strong"><strong>Executing the action</strong></span>: Finally, we <a id="id301" class="indexterm"/>are going to run the action by specifying the action sequence in the <code class="literal">runAction()</code> method on the node.</li></ol></div></div></div></div>
<div class="section" title="Creating actions"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Creating actions</h1></div></div></div><p>There are various types<a id="id302" class="indexterm"/> of actions which can be applied on a node to make it behave differently, now we are going to study about most of them in detail.</p><div class="section" title="Moving nodes using actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec54"/>Moving nodes using actions</h2></div></div></div><p>The <code class="literal">SKAction</code> class <a id="id303" class="indexterm"/>provides various action methods for moving nodes on a scene. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func moveByX( x: CGFloat, y : CGFloat, duration sec: NSTimeInterval)</code>: This will move the node to its new position. Here, Delta of <code class="literal">x</code>, Delta of <code class="literal">y</code>, and duration in<a id="id304" class="indexterm"/> seconds are passed as <a id="id305" class="indexterm"/>parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func moveBy( delta: CGVector, duration sec: NSTimeInterval)</code>: This will move the<a id="id306" class="indexterm"/> node relative to its current position. Here, Delta vector pointing to a new position and duration in seconds are passed as parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">moveTo(location: CGPoint, duration sec: NSTimeInterval)</code>: This will move the node to<a id="id307" class="indexterm"/> a new position. Location of the new position and duration in seconds are passed as parameters. Here location is a <code class="literal">CGpoint</code> value whose default value is <code class="literal">(0,0)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func moveToX( x: CGFloat, duration sec: NSTimeInterval)</code>: This will move the node <a id="id308" class="indexterm"/>horizontally. In this, the <code class="literal">x</code> value and the duration of the action are passed as parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func moveToY(y: CGFloat, duration sec: NSTimeInterval)</code>: This will move the node vertically along a relative path. In this, the <code class="literal">y</code> value and the duration of the action in<a id="id309" class="indexterm"/> seconds are passed as parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func followPath( path: CGPath, duration sec: NSTimeInterval)</code>: This will <a id="id310" class="indexterm"/>move the node along a relative path. <code class="literal">path</code> and <code class="literal">sec</code> are taken as parameters, in which path is a <code class="literal">CGpath</code> value which is relative to the current position of the node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func followPath( path: CGPath, speed: CGFloat)</code>: This will move the node along a <a id="id311" class="indexterm"/>relative path at a specified speed. The unit of speed<a id="id312" class="indexterm"/> is points per second.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, duration : NSTimeInterval )</code>: This function will move the node along the<a id="id313" class="indexterm"/> path. In this function, we pass four parameters: one is the <code class="literal">path</code> on<a id="id314" class="indexterm"/> which the node will move; the second is the <code class="literal">offset</code> parameter, which is either <code class="literal">true</code> or <code class="literal">false</code>. <code class="literal">true</code> represents that the points in the path are relative offsets to the initial position of the node, and on the other hand <code class="literal">false</code> represents that the points are absolute in nature. <code class="literal">orientToPath</code> will be a Boolean property if the true node can follow the path along the <code class="literal">z</code> axis.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, speed : CGFloat)</code>: This function will move the node along the path at a specified speed.</li></ul></div></div><div class="section" title="Rotating nodes using actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec55"/>Rotating nodes using actions</h2></div></div></div><p>The <code class="literal">SKAction</code> class provides <a id="id315" class="indexterm"/>various action methods for rotating nodes<a id="id316" class="indexterm"/> on a scene. They are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func rotateByAngle( radians: CGFloat, duration sec: NSTimeInterval)</code>: This functions helps in rotating the node at a specified angle. It takes two parameters: one is the amount in which the node is to be rotated in <code class="literal">radians</code>, and the<a id="id317" class="indexterm"/> other is the duration of the<a id="id318" class="indexterm"/> rotation in <code class="literal">seconds</code>. This rotation is relative to the node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func rotateToAngle( radians: CGFloat, duration sec: NSTimeInterval)</code>: This<a id="id319" class="indexterm"/> function helps in rotating the node to an absolute angle, in the counterclockwise<a id="id320" class="indexterm"/> direction. It also takes two parameters: one is the angle to rotate the node, which is measured in <code class="literal">radians</code>, and the other is the duration of the animation in seconds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func rotateToAngle(radians: CGFloat, duration sec: NSTimeInterval, shortestUnitArc shortestUnitArc: Bool)</code>: This function helps in<a id="id321" class="indexterm"/> rotating the node to an absolute angle. It takes three parameters: one is the angle to which the node is to<a id="id322" class="indexterm"/> be rotated, the second is the duration in seconds, and the third is a Boolean value to assign whether we want the smallest rotation path or not. If <code class="literal">true,</code> then the rotation will be in the shortest direction, otherwise the rotation will be interpolated within the discrete points.</li></ul></div></div><div class="section" title="Changing the animation speed of a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec56"/>Changing the animation speed of a node</h2></div></div></div><p>The <code class="literal">SKAction</code> class provides <a id="id323" class="indexterm"/>various action methods for changing a node's animation speed. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func speedBy(speed: CGFloat, duration sec: NSTimeInterval)</code>: With this function, we can <a id="id324" class="indexterm"/>control the speed of a node's actions. It takes two parameters: one is the amount of <code class="literal">speed</code> to<a id="id325" class="indexterm"/> be added in the node, and the other is the <code class="literal">duration</code> of the animation in seconds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func speedTo(speed: CGFloat, duration sec: NSTimeInterval)</code>: With this function too, we <a id="id326" class="indexterm"/>can control the speed of the node's actions. But instead of passing the parameter that adds its value to the previous speed, this function changes the <code class="literal">speed</code> to the set value. The other parameter passed is the <code class="literal">duration</code> of animation in seconds.</li></ul></div></div><div class="section" title="Changing the scale position of a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec57"/>Changing the scale position of a node</h2></div></div></div><p>The <code class="literal">SKAction</code> class provides <a id="id327" class="indexterm"/>various action methods for scaling a node. They are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func scaleBy( scale: CGFloat, duration sec: NSTimeInterval)</code>: With this function, you<a id="id328" class="indexterm"/> can change the <code class="literal">xScale</code> and <code class="literal">yScale</code> values of a node. This function takes two parameters: one is the amount to be<a id="id329" class="indexterm"/> added in the <code class="literal">x</code> and <code class="literal">y</code> values of the node, and the other is the duration of the animation. This scaling applies to the current size.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func scaleTo( scale: CGFloat, duration sec: NSTimeInterval)</code>: With this function too, you <a id="id330" class="indexterm"/>can change the <code class="literal">x</code> and <code class="literal">y</code> values of a node. It takes two parameters: one is the new value of the node's <code class="literal">x</code> and <code class="literal">y</code> values, and the other is the duration of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func scaleXBy ( xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)</code>: With this function, you can change the <code class="literal">x</code> and <code class="literal">y</code> values of the node. Three parameters are passed in this function: first is the amount to be<a id="id331" class="indexterm"/> added in the node's <code class="literal">x</code> value, second is the amount to be added in the node's <code class="literal">y</code> value, and the third is the duration of the animation. This function is used when you have to scale the <code class="literal">x</code> and <code class="literal">y</code> of a node with different values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func scaleXTo( xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)</code>: With this function too, you can change the <code class="literal">x</code> and <code class="literal">y</code> values of the node<a id="id332" class="indexterm"/> differently. But instead of passing the value<a id="id333" class="indexterm"/> to add in the <code class="literal">x</code> and <code class="literal">y</code>, you can set the <code class="literal">x</code> and <code class="literal">y</code> scale to new values by passing the respective parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func scaleXTo( scale: CGFloat, duration sec: NSTimeInterval)</code>: With this<a id="id334" class="indexterm"/> function, you can only change the <code class="literal">x</code> value of a node to a new<a id="id335" class="indexterm"/> value. It takes two parameters: one is the node's <code class="literal">x</code> value and the other is the <code class="literal">duration</code> of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func scaleYTo( scale: CGFloat, duration sec: NSTimeInterval)</code>: With this function, you can only change the <code class="literal">y</code> value of a node to a new value. It takes<a id="id336" class="indexterm"/> two parameters: one is the node's <code class="literal">y</code> value and the other is the <code class="literal">duration</code> of the animation.</li></ul></div></div><div class="section" title="Showing or hiding a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec58"/>Showing or hiding a node</h2></div></div></div><p>The <code class="literal">SKAction</code> class <a id="id337" class="indexterm"/>provides various action methods for hiding or showing a node on a scene. Let's have <a id="id338" class="indexterm"/>a look at both of these functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func unhide()</code>: With this function, you <a id="id339" class="indexterm"/>can create an action to <a id="id340" class="indexterm"/>make a node visible. This function<a id="id341" class="indexterm"/> was introduced in iOS 8.0.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func hide()</code>: With this<a id="id342" class="indexterm"/> function, you can create an action to make a node hidden. This function was introduced in iOS 8.0 as well.</li></ul></div></div><div class="section" title="Changing the transparency of a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Changing the transparency of a node</h2></div></div></div><p>With the help of <code class="literal">SKAction</code>, you can also change the transparency of a node. The following functions help you<a id="id343" class="indexterm"/> achieve this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func fadeInWithDuration( sec: NSTimeInterval)</code>: You can change the alpha value of a node<a id="id344" class="indexterm"/> to <code class="literal">1.0</code> with this function. Only one parameter is passed with this function, which<a id="id345" class="indexterm"/> is the duration of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func fadeOutWithDuration( sec: NSTimeInterval)</code>: You can change the alpha value of a<a id="id346" class="indexterm"/> node to <code class="literal">0.0</code> with this<a id="id347" class="indexterm"/> function. Only one parameter is passed with this function, which is the duration of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func fadeAlphaBy( factor: CGFloat, duration sec: NSTimeInterval)</code>: With this function, you can control the amount of alpha value to be added to the node. You <a id="id348" class="indexterm"/>pass two parameters in this function: one is the amount to be added to the alpha value of the node, and the other is the <code class="literal">duration</code> of the<a id="id349" class="indexterm"/> node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func fadeAlphaTo(alpha: CGFloat, duration sec: NSTimeInterval)</code>: With this function, you can set a new alpha value for the node. Two parameters are <a id="id350" class="indexterm"/>passed in this function: one is the node's new alpha value and the other is the <code class="literal">duration</code> of the node.</li></ul></div></div><div class="section" title="Changing the content of a sprite node"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Changing the content of a sprite node</h2></div></div></div><p>With some <code class="literal">SKAction</code> functions, you can<a id="id351" class="indexterm"/> create actions to change the content of a sprite node. Let's have a look at them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func resizeByWidth( width: CGFloat, height: CGFloat, duration: NSTimeInterval)</code>: This function<a id="id352" class="indexterm"/> creates an action which adjusts the size of a sprite node. This<a id="id353" class="indexterm"/> function takes three parameters: the first is the amount to be added to the sprite's <code class="literal">width</code>, the second is the amount to be added to the sprite's <code class="literal">height</code>, and the third is the <code class="literal">duration</code> of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func resizeToHeight( height: CGFloat, duration: NSTimeInterval)</code>: This function<a id="id354" class="indexterm"/> creates an action that changes the <code class="literal">height</code> of a sprite to a new value. One parameter passed is the new <code class="literal">height</code> of the sprite, and the second parameter is the <code class="literal">duration</code> of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func resizeToWidth(width: CGFloat, duration: NSTimeInterval)</code>: This function creates an action that changes the <code class="literal">width</code> of a sprite to a new value. One parameter <a id="id355" class="indexterm"/>passed is the new <code class="literal">width</code> of the sprite, and the second parameter is the <code class="literal">duration</code> of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func resizeToWidth( width: CGFloat, height: CGFloat, duration: NSTimeInterval)</code>: This function creates an action that changes the <code class="literal">width</code> and <code class="literal">height</code> of a sprite node to a new value. You can specify the new <code class="literal">height</code> and <code class="literal">width</code> separately in this function. It takes three parameters: one is the new <code class="literal">width</code> of the sprite, the second is the new <code class="literal">height</code> of the sprite, and the third is the <code class="literal">duration</code><a id="id356" class="indexterm"/> of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func setTexture(texture: SKTexture)</code>: This function helps in creating an action that changes the <a id="id357" class="indexterm"/>sprite's texture. Only one parameter is passed in this function, which is the sprite's new <code class="literal">texture</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func setTexture( texture: SKTexture,  resize: Bool)</code>: This function helps in creating an action that changes the sprite's texture. Along with this, you can also control whether the sprite should be resized to match the new texture or not. The two parameters passed are the new <code class="literal">texture</code> to use on the sprite and the<a id="id358" class="indexterm"/> Boolean to control the resizing.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func animateWithTextures(textures: [AnyObject], timePerFrame sec: NSTimeInterval)</code>: This function creates an action that animates <a id="id359" class="indexterm"/>changes in a sprite's texture. When the action executes, the <code class="literal">texture</code> property animates the array of the <code class="literal">texture</code>, which is<a id="id360" class="indexterm"/> passed as a parameter. The action continues until all the textures in the array have finished animating. Two parameters are passed in this function: one is the array of <code class="literal">textures</code>, and the other is the time in which each texture in the array will be displayed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func animateWithTextures( textures: [AnyObject], timePerFrame sec: NSTimeInterval, resize: Bool, restore: Bool)</code>: This function creates an <a id="id361" class="indexterm"/>action which animates changes to the sprite's texture and can also resize the sprite to the new texture, if required. It takes four parameters: one is the array of <code class="literal">textures</code> that are used when animating the sprite, the second is the time in which each texture will be displayed, the third is a Boolean value to control the resizing of the sprite to match the new texture, and the fourth is the restoring of the size of the sprite to the original texture size.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func colorizeWithColor(color: UIColor, colorBlendFactor: CGFloat, duration sec: NSTimeInterval)</code>: This function creates an animation that animates a<a id="id362" class="indexterm"/> sprite's color and blend factor. Three parameters are passed in this function: one is <code class="literal">color</code> for the new sprite, the second is the new blend factor, and the third is the <code class="literal">duration</code> of the animation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func colorizeWithColorBlendFactor( colorBlendFactor: CGFloat, duration sec: NSTimeInterval)</code>: This function will create an animation that<a id="id363" class="indexterm"/> animates the sprite's blend factor. It takes two parameters: one is the new blend<a id="id364" class="indexterm"/> factor and the other is the <code class="literal">duration</code> of the animation.</li></ul></div></div><div class="section" title="Some other important actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Some other important actions</h2></div></div></div><p>By now, we have discussed most of the important functions that are used to create actions on a node. Now, we are going to have a look at some other important functions used in creating actions on a node in<a id="id365" class="indexterm"/> Sprite Kit:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func runAction( action: SKAction, onChildWithName name: String)</code>: This function will create an <code class="literal">action</code> that will, in turn, run an <code class="literal">action</code> on a node's child. You<a id="id366" class="indexterm"/> pass the <code class="literal">action</code> to execute and take the <code class="literal">name</code> of the child object as parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func group( actions: [AnyObject])</code>: You can run a collection of <code class="literal">actions</code> in parallel, using<a id="id367" class="indexterm"/> this function's action. It takes an array of <code class="literal">SKAction</code> objects as a parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func sequence( actions: [AnyObject])</code>: You can run a collection of actions sequentially, using this function's action. It takes an array of <code class="literal">SKAction</code> objects as a <a id="id368" class="indexterm"/>parameter. The order of actions is the same as the order of actions passed in the array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func repeatAction( action: SKAction, count count: Int)</code>: You can create an action to<a id="id369" class="indexterm"/> repeat an action that is specified to repeat a number of times. The <code class="literal">action</code> to repeat and the <code class="literal">count</code> of repetitions are passed as parameters.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func repeatActionForever( action: SKAction)</code>: It creates an action that, in turn, repeats<a id="id370" class="indexterm"/> another action forever. It takes the <code class="literal">action</code> to repeat as a parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func reversedAction()</code>: With<a id="id371" class="indexterm"/> this action, you can reverse the behavior of another action.</li></ul></div></div></div>
<div class="section" title="Adding controls in Sprite Kit"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Adding controls in Sprite Kit</h1></div></div></div><p>Adding controls in<a id="id372" class="indexterm"/> a Sprite Kit doesn't need any external predefined framework; we can implement the<a id="id373" class="indexterm"/> controls in Sprite Kit using the following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Tapping</li><li class="listitem" style="list-style-type: disc">Gesture recognitions (swiping in any direction, pinching, rotating)</li><li class="listitem" style="list-style-type: disc">Moving sprites using the accelerometer</li></ul></div><p>Let's discuss each of the preceding controls in detail and also how we can implement them in our <a id="id374" class="indexterm"/>game.</p><div class="section" title="Node tapping and clicking"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Node tapping and clicking</h2></div></div></div><p>We have four override methods for handling touch events with a <code class="literal">UIResponder</code> class, which is part of <code class="literal">UIKit</code> provided by<a id="id375" class="indexterm"/> Apple. Let's learn about them:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func touchesBegan(touches:Set&lt;NSObject&gt;, withEvent event:UIEvent)</code>: This <a id="id376" class="indexterm"/>method is called whenever a user touches the view/window</li><li class="listitem" style="list-style-type: disc"><code class="literal">func touchesMoved(touches:Set&lt;NSObject&gt;, withEvent event:UIEvent)</code>: This method is <a id="id377" class="indexterm"/>called whenever a user moves his finger on the view/window</li><li class="listitem" style="list-style-type: disc"><code class="literal">func touchesEnded(touches:Set&lt;NSObject&gt;, withEvent event:UIEvent)</code>: This method is <a id="id378" class="indexterm"/>called whenever a user removes the finger from view/window</li><li class="listitem" style="list-style-type: disc"><code class="literal">func touchesCancelled(touches:Set&lt;NSObject&gt;!, withEvent event:UIEvent!)</code>: This<a id="id379" class="indexterm"/> method is called whenever system events, such as low memory warnings and so on, happen</li></ul></div><p>To implement an <a id="id380" class="indexterm"/>action when someone taps on a node on the scene, we will first get the tapped location on the scene, and if the tapped location is within the node's co-ordinate axis points, then we can define the actions for that tap. This will be implemented in the <code class="literal">touchesBegan()</code> method.</p><p>Sprite Kit includes a category in <code class="literal">UITouch</code>; this is one of its best features. <code class="literal">UITouch</code> comes with two methods, namely, <code class="literal">locationInNode()</code> and <code class="literal">previousLocationInNode()</code>. These methods find the coordinates of a touch within an <code class="literal">SKNode</code> object's coordinate system.</p><p>In our game, we will use it to find out where the touch happened within the scene's coordinate system.</p></div><div class="section" title="Gesture recognitions (swiping in any direction, pinching, or rotating)"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Gesture recognitions (swiping in any direction, pinching, or rotating)</h2></div></div></div><p>If you need to detect gestures in your game, such as taps, pinches, pans, or rotations, it's extremely easy with Swift and the built-in <code class="literal">UIGestureRecognizer</code> classes.</p><p>Following is a code<a id="id381" class="indexterm"/> snippet for gesture recognitions in Swift; it will implement swiping left, right, top, and bottom.</p><p>First, we set up four functions, one for each direction, to handle whatever we want to do when the user swipes the screen in those directions. Then, in the <code class="literal">didMoveToView</code> statement, we create the <code class="literal">UISwipeGestureRecognizer</code> variables for each direction and add them to the view. Notice the <code class="literal">action</code>: <code class="literal">selector</code> part of each, calls their respective functions in the following code:</p><div class="informalexample"><pre class="programlisting">func swipedRight(sender:UISwipeGestureRecognizer){
  println("swiped right")
}

func swipedLeft(sender:UISwipeGestureRecognizer){
  println("swiped left")
}

func swipedUp(sender:UISwipeGestureRecognizer){
  println("swiped up")
}

func swipedDown(sender:UISwipeGestureRecognizer){
  println("swiped down")
}

override func didMoveToView(view: SKView) {

  /* Setup your scene here */

  let swipeRight:UISwipeGestureRecognizer = UISwipeGestureRecognizer(target: self, action: Selector("swipedRight:"))
  swipeRight.direction = .Right
  swipeRight.numberOfTouchesRequired = 1
  view.addGestureRecognizer(swipeRight)

  let swipeLeft:UISwipeGestureRecognizer = UISwipeGestureRecognizer(target: self, action: Selector("swipedLeft:"))
  swipeLeft.direction = .Left
  swipeRight.numberOfTouchesRequired = 1
  view.addGestureRecognizer(swipeLeft)

  let swipeUp:UISwipeGestureRecognizer = UISwipeGestureRecognizer(target: self, action: Selector("swipedUp:"))
  swipeUp.direction = .Up
  swipeRight.numberOfTouchesRequired = 1
  view.addGestureRecognizer(swipeUp)

  let swipeDown:UISwipeGestureRecognizer = UISwipeGestureRecognizer(target: self, action: Selector("swipedDown:"))
  swipeDown.direction = .Down
  swipeRight.numberOfTouchesRequired = 1
  view.addGestureRecognizer(swipeDown)</pre></div><p>Using the preceding code block, you can implement swipe control in a Sprite Kit game. When the user swipes in a particular direction, the <code class="literal">UISwipeGestureRecognizer</code> will recognize the direction of the user's swipe and the swipe gesture object will be added to the gesture through the <code class="literal">addGestureRecognizer()</code> method. So, the particular object will be sent for the <a id="id382" class="indexterm"/>function and the appropriate method will be called, and after that, the respective actions will be executed as desired.</p></div><div class="section" title="Moving sprites with an accelerometer"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Moving sprites with an accelerometer</h2></div></div></div><p>An accelerometer is a sensor that measures proper acceleration ("g-force"). Proper acceleration is not the <a id="id383" class="indexterm"/>same as coordinate acceleration (rate of change of velocity). A lot of games use an accelerometer as a controller. We can also<a id="id384" class="indexterm"/> use it in our Sprite Kit game.</p><p>Let's have a look at how we can implement an accelerometer in a Sprite Kit game. We will not be using an accelerometer in our <span class="emphasis"><em>Platformer</em></span> game, but it would be good to have knowledge of the same.</p><p>As a primary point, we need to read values from the accelerometer, so we need to import the <code class="literal">CoreMotion</code> framework. Add the following line right after the <code class="literal">import SpriteKit</code> line:</p><div class="informalexample"><pre class="programlisting">import CoreMotion

add the following properties.

var airplane = SKSpriteNode()
var motionManager = CMMotionManager()
var destX:CGFloat = 0.0</pre></div><p>The <code class="literal">CMMotionManager</code> object is the gateway to the motion services provided by iOS. In the <code class="literal">didMoveToView</code> method, the <a id="id385" class="indexterm"/>custom code is<a id="id386" class="indexterm"/> executed. Let's have a look at it:</p><div class="informalexample"><pre class="programlisting">override func didMoveToView(view: SKView) {
    /* Setup your scene here */
   // 1
    airplane = SKSpriteNode(imageNamed: "Airplane")
    airplane.position = CGPointMake(frame.size.width/2, frame.size.height/2)
    self.addChild(airplane)
      if motionManager.accelerometerAvailable == true
{

      // 2motionManager.startAccelerometerUpdatesToQueue
(NSOperationQueue.currentQueue(), withHandler:{
        data, error in
          var currentX = self.airplane.position.x

        // 3
        if data.acceleration.x &lt; 0 {
        self.destX = currentX + CGFloat(data.acceleration.x * 100)
        }
        else if data.acceleration.x &gt; 0 {
        self.destX = currentX + CGFloat(data.acceleration.x * 100)
        }
      })
      }
  }</pre></div><p>Please refer the comments in the preceding code to the following points:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The image will be loaded and centered in the main view.</li><li class="listitem">The <code class="literal">startAccelerometerUpdatesQueue</code> method reads input from the accelerometer and constantly gets new updates.</li><li class="listitem">If the acceleration<a id="id387" class="indexterm"/> value is negative, the value is subtracted from the <code class="literal">x</code> position, hence the airplane will move left. If the acceleration value is positive, the value will be added to the <code class="literal">x</code> position.<p>The actual movement will be done on the update method, which will be called at each frame.</p><div class="informalexample"><pre class="programlisting">override func update(currentTime: CFTimeInterval) {
    /* Called before each frame is rendered */
    var action = SKAction.moveToX(destX, duration: 1)
    self.airplane.runAction(action)
}</pre></div></li></ol></div><p>A <code class="literal">moveToX</code> action is<a id="id388" class="indexterm"/> assigned to the airplane. This code will be a helpful reference if you want to implement accelerometer for controlling a game. Now, let's read about SceneKit.</p></div></div>
<div class="section" title="An introduction to SceneKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>An introduction to SceneKit</h1></div></div></div><p>SceneKit is a framework<a id="id389" class="indexterm"/> that can be used to implement the features of 3D graphic components into our iOS games. SceneKit provides a facility for integrating a high performance rendering engine at a greater level. It also offers a facility for importing, manipulating, and rendering 3D graphic assets.</p><p>It is fairly easy in iOS 8, to integrate SceneKit elements in a Sprite Kit game. First of all, you just have to import the SceneKit framework in the required Sprite Kit class. Then, you are all set to access all the methods and properties of SceneKit.</p></div>
<div class="section" title="Adding animations and controls in our Platformer game"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Adding animations and controls in our Platformer game</h1></div></div></div><p>After discussing<a id="id390" class="indexterm"/> about the <code class="literal">SKAction</code> class and various methods to<a id="id391" class="indexterm"/> add controls in our game, it's time to revisit our <span class="emphasis"><em>Platformer</em></span> game and implement some of them.</p><div class="section" title="Adding actions"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Adding actions</h2></div></div></div><p>Now, it's time to add actions in our game. Let's start with adding animation to the player and block collision. Until the last chapter, there was no collision effect between the player and the blocks.</p><p>Here we will add collision<a id="id392" class="indexterm"/> between the block and the player. Along with this, we can make the player die in an animated way. We can denote the animation after the player and block collision as a player death animation.</p><p>First of all, we will update the maximum size of the X-axis for the blocks, because currently, the blocks are being destroyed before the end of the running bar. Hence, we will replace the respective code with an updated one.</p><p>Replace <code class="literal">self.blockMaxX = 0 - self.block1.size.width / 2</code> with <code class="literal">self.blockMaxX = 0 - self.runningBar.size.width</code> in the <code class="literal">addBlocks()</code> method, in the <code class="literal">GameScene.swift</code> file.</p><p>Now, we will work on the part where the block and the player collides. For this, we will use a library method function, <code class="literal">didBeginContact()</code>, which is called when the collision happens, as we have already set all the required physics properties such as, <code class="literal">contactTestBitMask</code>, <code class="literal">categoryBitMask</code>, and <code class="literal">collisionBitMask</code> for the blocks and the player in the <code class="literal">addBlocks()</code> method, in the <code class="literal">GameScene.swift</code> file.</p><p>Include the <code class="literal">didBeginContact()</code> method and add the following code, in which we are defining actions when the player and the block collide:</p><div class="informalexample"><pre class="programlisting">func didBeginContact(contact: SKPhysicsContact)
    {


        var inOutActionWhenPlayerDied = SKAction.scaleBy(0.5, duration: 0.5)
        var upActionWhenPlayerDied = SKAction.moveToY(self.player.size.height * 4, duration: 2)
        var removeFromParent = SKAction.self.removeFromParent()


self.player.runAction(SKAction.sequence(
[inOutActionWhenPlayerDied,
inOutActionWhenPlayerDied.reversedAction(),
upActionWhenPlayerDied,removeFromParent]),
gotoMenuScreen)


    }</pre></div><p>In the preceding function, we used <code class="literal">inOutWhenPlayerDied</code> for scaling a player by multiplying a float value of <code class="literal">0.5</code> and also specifying the <code class="literal">duration</code> as <code class="literal">0.5</code> seconds. In <code class="literal">upActionWhenPlayerDied</code>, we moved the player along the y-axis by multiplying the player's <code class="literal">height</code> with a float value <code class="literal">4</code>, with the duration of animation as <code class="literal">2</code> seconds.</p><p>After these animations, we should also remove the player from the scene, and also from the node tree. This is taken care of by <code class="literal">removeFromParent</code>.</p><p>Next, we call the action in the desired sequence.</p><p>If you notice in the <a id="id393" class="indexterm"/>preceding function that we just added in our <span class="emphasis"><em>Platformer</em></span> game, when calling the sequence, we have also reversed an action by using <code class="literal">reversedAction()</code>. We also call the <code class="literal">gotoMenuScreen</code> function in our sequence. Let's discuss about the same:</p><p>This is how our game will look after adding this action sequence:</p><div class="mediaobject"><img src="graphics/4201_06_01.jpg" alt="Adding actions"/><div class="caption"><p>The animation for when the player collides with a block.</p></div></div></div><div class="section" title="Transiting from GameScene to MenuScene"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Transiting from GameScene to MenuScene</h2></div></div></div><p>After the player's death, it is time to call the <code class="literal">gotoMenuScreen()</code> method for transiting to the <code class="literal">MenuScreen</code>. Add the<a id="id394" class="indexterm"/> following function in the <code class="literal">GameScene</code> class to do the same:</p><div class="informalexample"><pre class="programlisting">func gotoMenuScreen()
    {
        self.player.removeFromParent()

        let transitionEffect = SKTransition.doorsCloseHorizontalWithDuration(1.5)
        menuSceneInstance = MenuScene(size: self.size , playbutton: "Play", background: "BG")
        menuSceneInstance!.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        self.view?.presentScene(menuSceneInstance , transition:transitionEffect)

    }</pre></div><p>A slight glimpse of the transition:</p><div class="mediaobject"><img src="graphics/4201_06_02.jpg" alt="Transiting from GameScene to MenuScene"/><div class="caption"><p>The door close transition after the player's death.</p></div></div></div><div class="section" title="Adding controls in our game"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Adding controls in our game</h2></div></div></div><p>For controlling the player, we can make him jump over the blocks and save him from dying. Currently, this is<a id="id395" class="indexterm"/> being done by tapping on the player, but it is better to have a button for this action.</p><p>To implement the <span class="strong"><strong>JUMP</strong></span> button in our game, first we need to create a sprite node for the <span class="strong"><strong>JUMP</strong></span> button in the <code class="literal">GameScene.swift</code> file. Create a sprite node with the name, <code class="literal">btnjump</code>, and then assign the node with an image for the button; we can call the image <code class="literal">jump</code>. Add the following code for this feature:</p><div class="informalexample"><pre class="programlisting">var btnJump:SKNode = SKSpriteNode(imageNamed: "jump")</pre></div><p>Now, we need to position our button on the <code class="literal">GameScene</code>. For this, we can add the following code before the <code class="literal">addBackground()</code> function call in the <code class="literal">didMoveToView()</code> method.</p><div class="informalexample"><pre class="programlisting">self.btnJump.position = CGPointMake(-(self.size.width/2.2),
-(self.size.height/4))
        self.addChild(btnJump)</pre></div><p>And now your <code class="literal">didMoveToView()</code> function should look like the following:</p><div class="informalexample"><pre class="programlisting">   override func didMoveToView(view: SKView)
    {
        self.physicsWorld.contactDelegate = self

        // JUMP BUTTON POSITION SETTING AND ADDING ONTO THE SCREEN
        self.btnJump.position = CGPointMake
        (-(self.size.width/2.2), -(self.size.height/4))
        self.addChild(btnJump)

        addBackGround()
        addRunningBar()
        addPlayer()
        addBlocks()
        //addSpriteWithoutTexture()
    }</pre></div><p>Till now, we have just added the <span class="strong"><strong>JUMP</strong></span> button on scene but we didn't define the action of when the button will be clicked. So, let's write a block of code for performing this action:</p><div class="informalexample"><pre class="programlisting">if self.btnJump.containsPoint(location)
     {
         println("tapped!")
         if self.onGround
         {
           self.velocityY = -18.0
           self.onGround = false
         }
     }</pre></div><p>Add the preceding block of code in the <code class="literal">touchesBegan</code> method of <code class="literal">GameScene.swift</code>. Now your <code class="literal">touchesBegan()</code> method function<a id="id396" class="indexterm"/> should look like the following:</p><div class="informalexample"><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches
        {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == player.name
            {
                currentno++
                //changeSpriteFromTextureAtlas()

                if self.onGround
                {
                       self.velocityY = -18.0
                       self.onGround = false
                 }
            }

            // JUMP BUTTON ACTION
            if self.btnJump.containsPoint(location)
            {
                println("tapped!")
                if self.onGround
                {

                    self.velocityY = -18.0
                    self.onGround = false
                }
            }

        }
    }</pre></div><p>Following is how the <code class="literal">GameScene</code> will look after adding the <span class="strong"><strong>JUMP</strong></span> button:</p><div class="mediaobject"><img src="graphics/4201_06_03.jpg" alt="Adding controls in our game"/><div class="caption"><p>The JUMP button now appears on the screen</p></div></div><p>Now, if you run<a id="id397" class="indexterm"/> the game, there will be two major changes: one is the animation of the player's death during collision with the blocks, and the other is the <span class="strong"><strong>JUMP</strong></span> button to make the player jump over the blocks.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, we learned about the <code class="literal">SKAction</code> class in detail; this class is responsible for creating actions for nodes. We also discussed about various types of controls by which a Sprite Kit game can be played (such as, tapping, gesture recognition, and accelerometer). We also read about SceneKit and how we can integrate SceneKit in a Sprite Kit game. Now, our <span class="emphasis"><em>Platformer</em></span> game has two new features. One is the player's death animation and the other is the <span class="strong"><strong>JUMP</strong></span> button to control the player's jump.</p><p>In the next chapter, we will learn about the particle system and shaders. Along with this, we will also add particle effects in our <span class="emphasis"><em>Platformer</em></span> game, to enhance gameplay experience.</p></div></body></html>