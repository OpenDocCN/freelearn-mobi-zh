- en: Designing and Implementing the Messenger Backend with Spring Boot 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last couple of chapters, we gained a firm grasp of the fundamentals of
    the Kotlin programming language by implementing the classic game, *Tetris*. In
    [Chapter 3](kt-prog-ex_ch03.html), *Implementing Tetris Logic and Functionality*,
    we finished the development of the game by implementing its application logic.
    We created programmatic models for blocks, shapes, frames, and the application
    as a whole, via an app model class. In addition, we learned how to create custom
    views by implementing Tetris view—a view that the user of the application interacted
    with to play the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will hone our Kotlin development skills further by developing a simple messenger
    application for the Android platform. In the process of implementing the Android
    application, we will first develop a RESTful API that will provide web content
    to the application behind the scenes. The application programming interface will
    be built with Spring Boot 2.0\. After developing the application programming interface,
    we will deploy it to a remote server. Over the course of this chapter, you will
    learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic system design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling system behavior with state diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database design fundamentals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling a database with entity relationship (E-R) diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building backend microservices with Spring Boot 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency management with Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Web Services (AWS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without further ado, let's dive into this chapter by designing the messenger
    application programming interface.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the messenger API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To design a fully functional RESTful application programming interface for our
    messenger android application, we must fully understand the concept of application
    programming interfaces, **Representational State Transfer** (**REST**) and RESTful
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Application programming interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application programming interface is a collection of functions, routines,
    procedures, protocols, and resources that can be used for building software. In
    other words, an application programming interface—API for short—is a collection
    of well-defined and appropriately structured methods or channels of communication
    between software components.
  prefs: []
  type: TYPE_NORMAL
- en: Application programming interfaces can be developed for use with various application
    domains. Some common application domains that APIs are developed for include the
    development of web-based systems, operating systems, and computer hardware, as
    well as interaction with embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Restful state transfer is a way of facilitating functional operation and interactions
    between two or more distinct systems (or subsystems) via the internet. Web services
    that adhere to REST allow interacting systems to access web content; they also
    perform authorized operations on web content that they have access to. These inter-system
    communications are done using a well-defined set of stateless operations. A RESTful
    web service adheres to REST and provides web content to communicating systems
    via predetermined stateless operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the present day, numerous systems that communicate with web services utilize
    REST. Systems that may utilize REST are based on the client-server architecture.
    The API we will be developing is based on REST, and, as such, will make use of
    representational state transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the messenger API system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will attempt to concisely design the messenger API system.
    You may be wondering at this point what exactly system design is and what it entails.
    Fear not, we will explain these in the next few paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: System design is the process of defining the architecture, modules, interfaces,
    and data for a system to satisfy specified requirements that are from a pre-performed
    system analysis phase. System design consists of numerous processes and the utilization
    of different design orientations. In addition, the in-depth designing of systems
    requires the understanding of numerous topics, such as coupling and cohesion,
    which are far beyond the scope of this book. With this in mind, we shall attempt
    to give basic definitions of the interactions and data utilized in our system.
    We shall achieve this by designing the system incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Incremental development is an approach that can be used for the development
    of systems. Incremental development utilizes the incremental build model. The
    incremental build model is a method of developing software in which a product
    is designed, implemented, and tested incrementally. We will be developing the 
    messenger API incrementally. We will in no way attempt to specify everything needed
    by the messenger API before we start coding. We will determine a set of specifications
    to get us going with the development and then create some functionality, after
    which we will repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: To comfortably utilize the incremental development methodology, we must utilize
    software that does not penalize us for making changes over the development process,
    such as a case where we need to change the type of data catered for by the system.
    Spring Boot is a perfect candidate for developing systems incrementally as it
    enables quick and easy changes to systems.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have referred to Spring Boot a couple of times but have
    neither discussed what it is nor what it is used for. Let's use this opportunity
    to quickly do that.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot is a web application framework that was designed and developed for
    the purpose of the boot strapping and development of Spring applications. Spring
    is a web application framework that facilitates the development of web applications
    for the Java platform. Spring Boot makes creating industrial-strength production-grade
    spring-based applications easy.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore how to create web applications with Spring Boot over the course
    of this chapter, but now is not the time for that. Before we start developing
    the application, we must specify what the application actually does (we cannot
    build something when we don't know how it works, after all).
  prefs: []
  type: TYPE_NORMAL
- en: What the messenger system does
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we will determine the initial requirements of the messenger system and
    what activities can occur within the system. We will identify high-level use cases
    of the messenger application.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A use case is a statement about how an entity uses a system. Entity here refers
    to a type of user or a component interacting with the system. In use case definitions,
    entities can also be referred to as actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by identifying the actors in the messenger system. A glaringly
    obvious actor is the user of the application (the person that uses the application
    to satisfy their messaging needs). Another actor that ideally should be considered
    is the admin. For the purpose of this simple messenger application though, we
    will cater for the single user actor. The use cases of the user are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user uses the messenger platform to send and receive messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user uses the messenger platform to view other users on the messenger app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user uses the messenger platform to set and update his status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can sign up to the messenger platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can log in to the messenger platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding use cases are enough to get us going. If, at any point during
    the course of system development, we come across a new use case, we can easily
    add that to the system. Now that we have identified the use cases of the system,
    we must properly describe the behavior of the system in catering for these use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: System behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We define system behavior to have an accurate idea of what the system does,
    as well as to clearly describe the interactions between components of the system.
    As this is a very simple application, we can clearly describe application behavior
    with the aid of a diagram. We will make use of a state diagram to properly describe
    this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**State diagrams**: A state diagram is used to describe the behavior of systems.
    A state diagram describes a system utilizing different possible states. In a state
    diagram, there exists a finite number of possible states that a system can be
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the state diagram for our system, taking into consideration
    the defined use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b6275fc-b0c1-466e-8aa3-c6bb22f78c6a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each circle in the preceding diagram represents a state of execution of the
    system at a point in time. Each arrow represents an action a user can request
    to be carried out by the system. Upon initial start, the API waits for requests
    from client applications.  This behavior is shown in the **Waiting for action**
    state. When an action request is received by the API from the client application,
    the system goes out of the **Waiting for action** state and services the request
    sent with an appropriate process.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a user requests a status update from the Android application,
    the server leaves the **Waiting for action** state and executes the  **Attempt
    status update** process, after which it goes back to the **Waiting for action** state.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to have an idea of the type of data needed before implementing
    a system. We can easily identify this data from the use case definitions we gave
    earlier. From our use case specifications, we can determine that two basic types
    of data are required. These are the user data and the message data. As the names
    imply, the user data is the data required of every user, and message data is the
    data pertaining to a message sent. We are not concerned with things such as schemas,
    entities, or entity relationship diagrams yet. We just require an idea of the
    data to be required by the system.
  prefs: []
  type: TYPE_NORMAL
- en: As this is a messenger app, the user we will require a username, phone number,
    password, and a status message. It will also be useful to keep track of the status
    of their account to know whether the account of a particular user is activated
    or has been deactivated for some reason. Not much is required as of now pertaining
    the messages sent. We need to keep track of the sender of a message and the intended
    recipient of the message.
  prefs: []
  type: TYPE_NORMAL
- en: That is all for now with respect to the data needed. We will identify more data
    required as the development of the application progresses, but, for now, let's
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the messenger backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have some sense of direction pertaining to the use cases of the
    messenger system as a whole, the data required within the system, and the behavior
    of the system, we can get started with developing the backend of the system. As
    we have said earlier, we will be utilizing Spring Boot to develop the messenger
    API because it is a perfect candidate for incremental development. In addition
    to this, Kotlin and Spring Boot function very well together.
  prefs: []
  type: TYPE_NORMAL
- en: As we will be handling data within the messenger API, we will need a suitable
    database to store the data needed by the messenger system. We will making use
    of PostgreSQL as our database. Let’s take a brief look at PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PostgreSQL is an object-relational database management system that puts particular
    emphasis on extensibility and standards compliance. PostgreSQL is known as Postgres.
    It is commonly utilized as a database server. When utilized in this way, its primary
    functions are to securely store data and return the data stored upon request by
    software applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous advantages to using PostgreSQL as a datastore. Some of these
    advantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extensibility**: The features of PostgreSQL can be easily and readily extended
    by its users. This is because its source code is available to all for free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: PostgreSQL is available for all major platforms. Versions
    of PostgreSQL are available for almost every UNIX brand. Windows compatibility
    is also made possible via they Cygwin framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: Ready availability of GUI-based tools that facilitate easy interactions
    with PostgreSQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation of PostgreSQL is straightforward on all platforms. This section
    highlights its installation process on Windows, macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Windows installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install PostgreSQL on Windows, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and run an appropriate version of the Windows PostgreSQL interactive
    installer. This can be downloaded from [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install PostgreSQL as a Windows service. Make sure you take note of the PostgreSQL
    Windows service account name and password. You will need these details later in
    the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the PL/pgsql procedural language to be installed when prompted by the
    installer to do so.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may choose to install pgAdmin when directed to the Installation options
    screen. If you install pgAdmin, enable the Adminpack contrib module when prompted
    by the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you follow the previous steps properly, PostgreSQL will be successfully installed
    on your system.
  prefs: []
  type: TYPE_NORMAL
- en: macOS installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL can be easily installed on macOS with Homebrew. If you do not already
    have Homebrew installed on your system, consult [Chapter 1](kt-prog-ex_ch01.html), *The
    Fundamentals* for its installation instructions. Once you have determined that
    Homebrew is installed on your system, open your terminal and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Follow the installation instructions when prompted in the Terminal. Along the
    course of the installation, you may be asked for the admin password of your system.
    Input the password and wait for the installation to finish. You will be prompted
    once the installation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Linux installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PostgreSQL can easily be installed on Linux with the use of the PostgreSQL
    Linux installer:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the PostgreSQL installer download web page at [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the PostgreSQL version you want to install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select an appropriate Linux installer for PostgreSQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the download button to download the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer once it has been downloaded and follow all installation instructions
    appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have provided the information needed by the installer, PostgreSQL will
    be installed on your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have set up PostgreSQL on our system, we can commence with the creation
    of the messenger API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The initial creation on a Spring Boot application is easy with the utilization
    of IntelliJ IDE and the Spring initializer. Open IntelliJ IDE and create a new
    project with the Spring Initializer. This can be done by clicking on Create New
    Project and selecting Spring Initializer on the left side bar of the New Project screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfcdb014-9701-4b9c-8fa1-4c318745d573.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After selecting the Spring Initializer, progress to the next screen by clicking
    the Next button. Upon clicking next, before the next screen is displayed, Spring
    Initializer will be retrieved by the IDE. This will only take a few moments to
    do.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring plugin is only available in the Ultimate edition of IntelliJ IDEA,
    which comes with a paid subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Spring Initializer is retrieved, you will be asked to provide the
    appropriate details for the project to be created. Fill in the necessary details.
    You may choose to use the details used for the development of the application
    in this book or decide to input your own. However, in the instance that you want
    to use our details, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Input `com.example` as the group ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `messenger-api` as the artifact ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Maven Project as the project type if it is not already selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the packaging option and the Java version the way they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Kotlin as the language. This is important, as we are learning the Kotlin
    language, after all.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the SNAPSHOT value as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a description of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input `com.example.messenger.api` as the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After filling in the required project information, proceed to the next screen
    by clicking Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64b45967-3681-4f5f-a436-03c427b640d8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the next screen, you will be asked to select the project dependencies. For
    starters, we will need to select the Security, Web, JPA, and PostgreSQL dependencies.
    Security can be found under the Core category, Web can be found under the Web category,
    and JPA and PostgreSQL can be found under the SQL category. In addition, in the
    Spring Boot Version selection drop-down menu at the top of the screen, select
    2.0.0 M5 as the version.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the selection of the necessary dependencies, the content should look
    similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/702ff1e7-f2a8-428a-8d53-b9176ee7ffbc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After selecting the appropriate dependencies, click Next to continue to the
    final setup screen. You will be asked to provide a project name and a project
    location. Fill in `messenger-api` as the project name and select the location
    where want the project to be saved on your computer. Select Finish and wait for
    the project to be set up. You will be taken to a new IDE window containing the
    initial project files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting familiar with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the structure of the initial program files for this Spring
    Boot application. The following is the screenshot of the structure of your Spring
    Boot application files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f299d4c-2156-4a9f-bf11-cfc1a514fe12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All source files are contained in the `src` directory. This directory contains
    the core application program files as well as the test programs that are written
    for the application. Core application program files should be put in the `src/main`
    directory and test programs are located in `src/test`. The main directory contains
    two subdirectories. These are the `kotlin` directory and the `resources` directory.
    All packages and main source files will be placed in this directory over the course
    of this chapter. More specifically, our program files and packages will be placed
    within the `com.example.messenger.api` package. Let''s have a quick look at the
    `MessengerApiAplication.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ef928f-315b-420f-a251-8046c82bf1de.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `MessengerApplication.kt` file contains the main function. This is the entry
    point of every Spring Boot application. This function is called when the application
    starts. Once it is called, the function runs the Spring application by calling
    the `SpringApplication.run()` function. This function takes two arguments. The
    first argument is a class reference and the second is the arguments to be passed
    to the application upon start.
  prefs: []
  type: TYPE_NORMAL
- en: In the same file, there's a `MessengerApiApplication` class. This class is annotated
    with the `@SpringBootApplication` annotation. The use of this annotation is equivalent
    to the combined use of the `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan` annotations.
    Classes annotated with `@Configuration` are sources of bean definitions.
  prefs: []
  type: TYPE_NORMAL
- en: A bean is an object that is instantiated and assembled by a Spring IoC container.
  prefs: []
  type: TYPE_NORMAL
- en: The `@EnableAutoConfiguration` attribute tells the Spring Boot that you want
    your Spring application to be automatically configured based on the jar dependencies
    that you have provided. The `@ComponentScan` annotation configures component scanning
    directories for use with the `@Configuration` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of developing Spring Boot applications, it will be necessary
    to use several annotations for varying reasons. Using these annotations may be
    overwhelming at first, but with time they will become second nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides `MessengerApplication.kt`, another important file is the `application.properties` file,
    located in `src/main/resources`. This file is used for configuring Spring Boot
    applications properties. Upon opening this file, you will discover that it has
    no content. This is because we have not yet defined any application configurations
    or properties. Let''s go ahead and add a couple of configurations. Input the following
    into the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `spring.jpa.generate-ddl` property specifies whether the database schema
    should be generated upon startup of the application. When this property is set
    to `true`, the schema is generated on application startup, otherwise the schema
    is not generated. The `spring.jpa.hibernate.ddl-auto` property is used to specify
    the DDL mode. We use `create-drop` because we want the schema to be created upon
    application startup and destroyed upon the termination of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have utilized properties to define the schema of our database but have yet
    to create an actual database for the `messenger-api`. If you installed pgAdmin
    along with PostgreSQL, you can easily create a database with the software. If
    you didn''t install pgAdmin, fear not, we can still easily create a database for
    our application by using PostgreSQL''s `createdb` command. Navigate to your terminal
    and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `-h` flag is used to specify the host name of the machine on which the database
    server is running. The `--username` flag specifies the username to connect to
    the server with. The `--password` flag forces a prompt for the specification of
    a password. The `messenger-api` is the name we are giving to the database being
    created. Substitute `<username>` with your server username. After you've input
    the command, click the enter key to run the command. Input a desired password
    when prompted to do so. A database named `messenger-api` will be created in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have out database set up, we need to connect the Spring Boot application
    to the database. We can do this with the use of the `spring.datasource.url`, `spring.datasource.username`,
    and `spring.datasource.password` properties. Add the following configurations
    to the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `spring.datasource.url` property specifies the JDBC URL via which Spring
    Boot will connect to the database. The  `spring.datasource.username` and `spring.datasource.password` are
    the properties used to specify the server username and the password correlating
    with the specified username. Replace `<username>` and `<password>` with your username
    and password.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have these properties set up, you are ready to start the Spring Boot
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have these properties set up, you are ready to start the Spring Boot
    application. You can run the `messenger-api` application by clicking on the Kotlin
    logo next to the main function in `MessengerApiApplication.kt` and selecting the
    Run option, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb7fda59-faa5-44b7-9925-888a83b16608.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wait for a moment for the project to build. Once the project build process is
    complete, the application will be started on a Tomcat server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue exploring our project files. Locate a `pom.xml` file in the
    root directory of the project. **POM** stands for **Project Object Model**. On
    the Apache Maven site, the following is said about the POM: *A Project Object
    Model or POM is the fundamental unit of work in Maven.* It is an XML file that
    contains information about the project and configuration details used by Maven
    to build the project. Once you have located this file, open it. Straightforward,
    right? That’s all fine and dandy, but, for the sake of clarity, here''s a brief
    description of Maven.'
  prefs: []
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache Maven is a software project management and comprehension tool that is
    based on the concept of the POM. Maven can be used for several purposes, such
    as project build management and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Having understood the project files to an extent, we will continue development
    by implementing some models to cater to the data we identified earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we are going to model the data we have identified into suitable entity
    classes that can be introspected by Spring Boot to build a suitable database schema.
    The first model we will concern ourselves with is the user model. Create a package
    named `models` under the `com.example.messenger.api` package. Create a `User.kt`
    file within the package and input the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We made use of a lot of annotations in the preceding code block. We will take
    a look at what each of them does in the order in which they appear. First up,
    we have the `@Entity` annotation, which indicates that the class is a **Java Persistence
    API** (**JPA**) entity. The use of the `@Table` annotation specifies a table name
    for the entity being represented by the class. This is useful during schema generation.
    In the case that an `@Table` annotation is not used, the name of the table generated
    will be the class name. A database table will be created in PostgreSQL with the
    name `user`.  `@EntityListener`, as the name implies, specifies an entity listener
    for the entity class. We have not yet created a `UserListener` class, but don't
    worry, we will do that in a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the properties of the `User` class. We added seven
    class properties in total. The first five are `username`, `password`, `phoneNumber`,
    `accountStatus`, and `status`; each property represents a type of data we need
    for a user, as we earlier identified in the *Identifying data* section of this
    chapter. We have now created our user entity and are ready to proceed. But wait,
    there''s a problem. We need a way to uniquely identify each user that is created.
    In addition, it is important for future reference to keep track of when new users
    are added to the messenger platform. After careful consideration, we realize that
    it is important to have `id` and `createdAt` properties in our entity. You may
    be wondering—why are we adding `id` and `createdAt` properties to the user entity?
    After all, we did not specify we needed them earlier on. This is true. But, as
    we are developing this backend incrementally, we are allowed to make changes and
    additions when the need arises. Let''s go ahead and add these two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Perfect. Now we need to understand what each annotation does. `@Column` is used
    to specify a property representing a table column. In practice, all properties
    of entities represent a column in the table. We make use of `@Column(unique =
    true)` in our code specifically to place a uniqueness constraint on properties.
    This is useful when we do not want more than one record to have a particular attribute
    value. `@Size`, as you might have guessed, is used to specify the size of an attribute
    present in a table. `@Pattern` specifies a pattern that a table attribute must
    match for it to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: '`@Id` specifies a property that uniquely identifies the entity (the `id` property,
    in this case). `@GeneratedValue(strategy = GenerationType.AUTO)` specifies that
    we want the `id` value to be generated automatically. `@DateTimeFormat`  places
    a timestamp constraint on values to be stored in the `created_at` column of the
    user table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to create a `UserListener` class. Create a new package named `listeners`.
    Add the following `UserListener` class to the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: User passwords should never be saved as plain text in a database. For security
    reasons, they must always be appropriately hashed before being stored. The `hashPassword()` function
    performs this hashing procedure by replacing the string value held by the password
    property of a user object with its hashed equivalent using `BCrypt`. `@PrePersist`
    and `@PreUpdate` specifies that this function should be called before the persistence
    or update of a user record in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create an entity for messages. Go ahead and add a `Message` class
    in the `models` package and add the following code to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We made use of some familiar annotations as well as two new ones. As we discussed
    earlier, every message has a sender as well as a recipient. Both message senders
    and message recipients are users on the messenger platform, hence the message
    entity has both sender and recipient properties of the `User` type. A user can
    be a sender of many messages as well as a recipient of many messages. These are
    relationships that need to be implemented. We make use of the `@ManyToOne` annotation
    to do this. The many-to-one relationships are not optional, thus we use `@ManyToOne(optional
    = false)`.  `@JoinColumn` specifies a column for joining an entity association
    or element collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code snippet adds a `user_id` attribute that references the `id` of a user
    to the `message` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon close inspection, you will notice that a conversation property was used
    in the `Message` class. This is because messages sent between users happen in
    conversation threads. Simply put, every message belongs to a thread. We need to
    add a `Conversation` class to our `models` package, representing the conversation
    entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Numerous messages belong to a conversation, so we have a `messages`  collection
    in the body of the `Conversation` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost done with the creation of entity models. The only thing left
    to do is to add appropriate collections for  a user''s sent and received messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We are done creating entities. To help you to understand the entities
    we have made as well as their relationships, here''s an entity relationship diagram
    (E-R diagram). It shows the entities that we have made and their relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cff0845e-3539-462d-843e-a32ceecb929c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: According to the E-R diagram, a user has many messages, a message belongs to
    a user, a message belongs to a conversation, and a conversation has many messages.
    In addition, a user has many conversations.
  prefs: []
  type: TYPE_NORMAL
- en: Having created the necessary models, there's only one problem. We have no way
    to access the data stored by these entities. We need to create repositories to
    do this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Spring Data JPA** has is the ability to create repository implementations
    automatically, at runtime, from a repository interface. We will see how this works
    by creating a repository to access the `User` entities. Create a `repositories` package
    and include `UserRepository.kt` in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`UserRepository` extends the `CrudRepository` interface. The `entity` type
    and `id` type it works with are specified in the generic parameters of `CrudRepository`.
    By extending `CrudRepository`, `UserRepository` inherits methods for working with
    `User` persistence, such as methods for saving, finding, and deleting `User` entities.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Spring JPA allows the declaration of other query functions by the
    use of method signatures. We exploited this capability to create `findByUsername()`
    and `findByPhoneNumber()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we currently have three entities, we need to have three repositories to
    query them. Create a `MessageRepository` interface in `repositories`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the preceding method signature specifies `List<Message>` as its return
    type. Spring JPA automatically recognizes this and returns a list of `Message` elements
    when `findByConversationId()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, implement a `ConversationRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we now have our entities set and the necessary repositories to query these
    entities, we can start work on implementing the business logic of the messenger
    backend. This will require us to learn about services and service implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Services and service implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service implementation is a spring bean that is annotated by `@Service`. Business
    logic for spring applications is most commonly put in a service implementation.
    A *service*, on the other hand, is an interface with function signatures for application
    behavior that must be implemented by implementing classes. A simple way to recall
    the differentiation between the two is to keep in mind that a service is an interface
    and a service implementation is a class that implements a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to create some services and service implementations. Create a `service`
    package. We will add both services and service implementations in here. Create
    a `UserService` interface as with the following codes within the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding `UserService` interface, we have defined functions that must
    be declared by classes that implement `UserService`. That''s it! `UserService` is
    ready to be implemented. Now to create an implementation of the service. Add a
    `UserServiceImpl` class to the services package. We are going to implement `UserService`
    and as such we need overriding functions for `attemptRegistration()`, `listUsers()`,
    `retrieveUserData()`, and `usernameExists()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the primary constructor definition of `UserServiceImpl`, an instance of `UserRepository`
    was specified as a required argument. You don't need to worry about passing such
    an argument yourself. Spring recognizes that `UserServiceImpl` needs a `UserRepository`
    instance and provides the class with one via dependency injection. In addition
    to the functions implemented, we declared an `obscurePassword()` function that
    simply hashed passwords within a `User` entity with `XXX XXXX XXX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the spirit of service and service implementation creation, let''s
    go ahead and add some for messages and conversations. Add a `MessageService` interface
    to the `service`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a single method signature for `sendMessage()` that must be overriden
    by `MessageServiceImpl`. The following is the message service implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation of `sendMessage()` first checks whether the message
    content is empty. If not, then the function checks whether there exists an active
    conversation between the sender and the recipient. If there is one, it is retrieved
    and stored in `conversation`, otherwise a new `Conversation` is created between
    the two users and stored in `conversation`. The conversation is then saved and
    the message is created and saved.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConversationService` and `ConversationServiceImpl` can now be implemented.
    Create a `ConversationService` interface in `services` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We have added six function signatures for now. They are `createConversation()`,
    `conversationExists()`, `getConversation()` , `retrieveThread()`, `listUserConversations()`,
    and `nameSecondParty()`. Now we shall add `ConversationServiceImpl` to `services` and
    implement the first three methods `createConversation()`, `conversationExists()`
    and `getConversation()`. This implementation is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Having added the first three methods, go ahead and include the remaining three
    methods, `retrieveThread()`, `listUserConversations()`, and `nameSecondParty()`,
    below to `ConversationServiceImpl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that we threw exceptions of different types several times
    within service implementation classes. As we have not yet created these exceptions,
    we will need to do so. In addition, we need to create an `ExceptionHandler` for
    each of these exceptions. These exception handlers will send appropriate error
    responses to clients in scenarios in which exceptions are thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `exceptions` package and add an `AppExceptions.kt` file to it. Include
    the following code into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each exception  extends `RuntimeException` as they occur during the server runtime.
    All exceptions also possess a `message` property. As the name implies, this is
    the exception message. Now that our exceptions have been added, we need to create
    controller advice classes. `ControllerAdvice` classes are used to handle errors
    that occur within a Spring application. They are created using the `@ControllerAdvice`
    annotation. In addition, a controller advice is a type of Spring component. Let's
    create a controller advice class to handle some of the preceding exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at `UsernameUnavailableException`, `InvalidUserIdException`, and `UserStatusEmptyException`,
    we notice that these three exceptions are all pertaining to a user. As such, let''s
    name the controller advice that caters to all these exceptions `UserControllerAdvice`.
    Create a `components` package and add a the following `UserControllerAdvice` class
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We've just defined functions to cater to each of the three exceptions that can
    occur and annotated each of the functions with an `@ExceptionHanlder()` annotation.
    `@ExceptionHanlder()` takes a class reference to the exception that is being handled
    by the function. Each function takes a single argument that is an instance of
    the exception thrown. In addition, all the defined functions return a `ResponseEntity<ErrorResponse>`
    instance. A response entity represents the entire HTTP response sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '`ErrorResponse` has not yet been created. Create a `constants` package and
    add the following `ErrorResponse` class to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`ErrorResponse` is a simple class with two properties: `errorCode` and `errorMessage`.
    Before we continue, go ahead and add the following `ResponseConstants` enum class
    to the `constants` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create three more controller advice classes. These classes are `MessageControllerAdvice`,
    `ConversationControllerAdvice`, and `RestControllerAdvice`. `RestControllerAdvice` will
    define exception handlers for errors that can happen anywhere within the server
    over the course of runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `MessageControllerAdvice` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the `ConversationControllerAdvice` class, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `RestControllerAdvice` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have implemented our business logic and we are almost ready to facilitate
    HTTP request entries via REST endpoints into our API. Before we do that, we must
    secure our API.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting API access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From a security standpoint, it is a huge taboo to permit just anyone to have
    access to RESTful API resources. We must devise a way to restrict access to our
    server to only registered and logged-in users. We will do this using **Spring
    Security** and **JSON Web Tokens** (**JWTs**).
  prefs: []
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Security is a highly customizable access-control framework for Spring
    applications. It is the accepted standard for securing applications built with
    Spring. As it is selected to add the Security dependency at the start of this
    project's creation, we do not need to add the Spring Security dependency to `pom.xml`
    as it has already been added.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the JWT website ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)),
    *JSON Web Tokens are an open, industry standard method for representing claims
    securely between two parties*. JWT allows you to decode, verify, and generate
    JWT. JWTs can be used easily with Spring Boot to implement authentication in applications.
    The following sections will demonstrate how to use a JWT and Spring Security combination
    to secure the messenger backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that must be done in order for you to get started with JWTs
    in a Spring application is add its dependency to the project `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon including a new maven dependency in `pom.xml`, IntelliJ will ask you to
    import the new dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18791763-36e8-494a-88f0-2d207944906e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Import Changes once the prompt shows up, and the JWT dependency will
    be imported into the project.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring web security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a custom web security configuration.
    Create a `config` package in `com.example.messenger.api`. Add a `WebSecurityConfig`
    class to the package and input the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s `Filter` the /login requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s filter other requests to check the presence of JWT in header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`WebSecurityConfig` is annotated with `@EnableWebSecurity`. This enables Spring
    Security''s web security support. In addition, `WebSecurityConfig` extends `WebSecurityConfigurerAdapter`
    and overrides some of its `configure()` methods to add some customization to the
    web security config.'
  prefs: []
  type: TYPE_NORMAL
- en: The `configure(HttpSecurity)` method configures which URL paths are to be secured
    and which shouldn't be. In `WebSecurityConfig`, we permitted all `POST` requests
    to the `/users/registrations` and `/login` paths. These two endpoints don't need
    to be secured, as a user cannot be authenticated prior to login or his registration
    on the platform. In addition, we added filters for requests. Requests to `/login` 
    will be filtered by `JWTLoginFilter` (we have yet to implement this); all requests
    that are unauthenticated and unpermitted will be filtered by `JWTAuthenticationFilter` (we
    have yet to implement this, too).
  prefs: []
  type: TYPE_NORMAL
- en: '`configure(AuthenticationManagerBuilder)` sets up the `UserDetailsService` and
    specifies a password encoder to be used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of classes that we made use of that we have not implemented
    yet. We will start by implementing `JWTLoginFilter` . Create a new package named
    `filters` and add the following `JWTLoginFilter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`JWTLoginFilter` takes a string URL and an `AuthenticationManager` instance
    as arguments to its primary constructor. You can also see it extends `AbstractAuthenticationProcessingFilter`.
    This filter intercepts incoming HTTP requests to the server and attempts to authenticate
    them. `attemptAuthentication()`  performs the actual authentication process. It
    uses an `ObjectMapper()` instance to read the credentials present in the `via` HTTP
    request, after which `authenticationManager` is used to authenticate the request.
    `AccountCredentials` is another class that we have yet to implement. Create a
    new package, called `security`, and add an `AccountCredentials.kt` file to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have variables for a `username` and `password` because these are what will
    be used to authenticate the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SuccessfulAuthentication()` method is called upon successful authentication
    of a user. The only task done in the function is the addition of authentication
    tokens to the `Authorization` header of the HTTP response. The actual addition
    of this header is done by `TokenAuthenticationService.addAuthentication()`. Let''s
    add this service to our `services` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s parse the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As the names imply, `addAuthentication()` adds an authentication token to the
    `Authorization` header of the HTTP response and `getAuthentication()` authenticates
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add `JWTAuthenticationFilter` to the `filters` package. Add the
    following `JWTAuthenticationFilter` class to the `filters` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `doFilter()` function of the `JWTAuthenticationFilter` is called by the
    container each time a request/response pair is passed through the filter chain
    as a result of a client request for a resource. The `FilterChain` instance passed
    in to `doFilter()` allows the filter to pass the request and response on to the
    next entity in the filter chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to implement the `AppUserDetailsService` class as usual, we
    will put this in the `services` package of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`loadUsername(String)` attempts to load the `UserDetails` of a user matching
    the `username` passed to the function. If the user matching the provided username
    cannot be found, a `UsernameNotFoundException` is thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: And, just like that, we have successfully configured Spring Security. We are
    now ready to expose some API functionality via RESTful endpoints with the use
    of controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing server resources via RESTful endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have created models, components, services, and service implementations,
    as well as integrated Spring Security into the messenger application. One thing
    we have not done is actually created any means by which external clients can communicate
    with the messenger API. We are going to do this by creating controller classes
    that handles requests from different HTTP request paths. As always, the first
    thing we must do is create a package to contain the controllers we are about to
    create. Create a `controllers` package now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first controller we will implement is the `UserController`. This controller
    maps HTTP requests pertaining to a user resource to in-class actions that handle
    and respond to the HTTP request. First and foremost, we need an endpoint to facilitate
    the registration of new users. We will call the action that handles such a registration
    request `create`. The following is the `UserController` code with the `create`
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The controller class is annotated with `@RestController` and `@RequestMapping`.
    The `@RestController` annotation specifies that a class is a REST controller.
    `@RequestMapping`, as it is used with the `UserController` class earlier, maps
    all requests with paths starting with `/users` to `UserController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create` function is annotated with `@PostMapping` and `@RequestMapping("/registrations")`.
    The combination of these two annotations maps all POST requests with the `/users/registrations` path
    to the create function. A `User` instance annotated with `@Validated` and `@RequestBody`
    is passed to `create`.  `@RequestBody` binds the JSON values sent in the body
    of the POST request to `userDetails`. `@Validated` ensures that the JSON parameters
    are validated. Now that we have an endpoint up and running, let''s test it out.
    Start the application and navigate to your terminal window. Send a request to
    the messenger API using CURL, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will create the user and send you a response similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That's all fine and good, but we can see there are a number of unwanted values
    in the HTTP response, such as the `password` and `accountStatus` response parameters.
    In addition to this, we'd like for `createdAt` to contain a human-readable date.
    We are going to do all these things using an assembler and a value object.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make the value object. The value object we are creating is going
    to contain the data of the user that we want to be sent to the client in its appropriate
    form and nothing more. Create a `helpers.objects` package with a `ValueObjects.kt`
    file in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `UserVO` is a data class that models the information we want
    to be sent to the user and nothing more. While we are at it, let''s add value
    objects for some other responses we will cater for later, to avoid coming back
    to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the required value objects set, let''s create an assembler
    for `UserVO`. An assembler is simply a component that `assembles` a required object
    value. We will call the assembler we are creating `UserAssembler`. As it''s a
    component, it belongs in the `components` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The assembler has a single `toUserVO()` function that takes a `User` as its
    argument and returns a corresponding `UserVO`.  `toUserListVO()` takes a list
    of `User` instances and returns a corresponding `UserListVO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s edit the create endpoint to make use of `UserAssembler` and `UserVO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the server and send a new request to register a `User`. We will get
    a response that is much more appropriate from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap up our endpoint creation process by creating all the necessary
    endpoints for the messenger Android application. Firstly, let''s add endpoints
    to show the details of a `User`, list all users, get the details of the current
    user, and update the status of a `User` to `UserController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to create controllers to handle message resources and conversation
    resources. These will be `MessageController` and `ConversationController`, respectively.
    Before creating the controllers, let''s assemblers that will be used to assemble
    value objects from JPA entities. The following is the `MessageAssembler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s create the `ConversationAssembler`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'All is in place for `MessageController` and `ConversationController`. For our
    simple messenger app, we only need to have a message creation action for `MessageController`.
    The following is `MessageController` with the message creation action, `create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we must create `ConversationController`. We need only two endpoints:
    one to list all the active conversations of a user and the other to get the messages
    existing in a conversation thread. These endpoints will be catered to by the `list()`
    and `show()` actions, respectively. The following is the `ConversationController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'All is looking great! There''s only one tiny problem. Remember, a user has
    an account status and it is possible for the account to be deactivated, right?
    In such a scenario, we, as API creators, will not want a deactivated user to be
    able to use our platform. As such, we have to come up with a way to prevent such
    a user from interacting with our API. There are a number of ways this can be done,
    but for this example we are going to use an interceptor. An interceptor intercepts
    an HTTP request and performs one or more operations on it before it continues
    down the request chain. Similar to assemblers, an interceptor is a component.
    We will call our interceptor that checks the validity of an account `AccountValidityInterceptor`.
    The following is the interceptor class (remember, it belongs in the `components`
    package):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AccountValidityInterceptor` class overrides the `preHandle()` function
    of its super class. This function will be called to carry out some operations
    prior to the routing of the request to its necessary controller action. After
    the creation of an interceptor, the interceptor must be registered with the Spring
    application. This configuration can be done using a `WebMvcConfigurer`. Add an
    `AppConfig` file to the `config` package in the project. Input the following code
    within the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`AppConfig` is a subclass of `WebMvcConfigurer` and overrides the `addInterceptor(InterceptorRegistry)`
    function in its superclass. `accountValidityInterceptor` is added to the interceptor
    registry with `registry.addInterceptor()`.'
  prefs: []
  type: TYPE_NORMAL
- en: We are now done with all the code required to provide web resources to the messenger
    Android application. We must now deploy this code to a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the messenger API to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a Spring Boot app to **Amazon Web Services** (**AWS**) is a straightforward
    and enjoyable process. The deployment procedure can be done well within 10 minutes.
    In this section, you will learn how to deploy applications based on Spring to
    AWS. Before application deployment, we must set up a PostgreSQL database on AWS
    that the application will connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PostgreSQL on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing you must do is create an AWS account. Go ahead and create one
    now by following this link: [https://portal.aws.amazon.com/billing/signup#/start](https://portal.aws.amazon.com/billing/signup#/start)
    . Once you have signed up, login into the AWS console and head over to the Amazon
    **Relational Database Service** (**RDS**) (from the navigation bar, click Services
    | Database | RDS). Once taken to the RDS dashboard, click on Get Started Now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07c9cbae-a86f-4647-9688-8659918739c3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be navigated to the Launch DB instance web page. Here you will need
    to make some selections pertaining to the DB setup. Select PostgreSQL as the DB
    engine to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1b8c82a-b79b-468c-bcdc-1451777734c9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Ensure to check the Only enable options eligible for RDS Free Usage Tier checkbox.
    Navigate to the next set of setup procedures by clicking Next. On the next page,
    leave the instance specifications as is and input the necessary DB settings. Input
    a DB instance name, master username, and master password. We used `messenger-api`
    as our DB instance name, you may choose to use another name of your choice. Regardless
    your choice, ensure that you take note of all inputs you make. Once you are done
    entering the necessary, continue to the next screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be navigated to the Configure advanced settings screen. In the Network
    & Security section, ensure to enable public accessibility and select the Create
    new VPC security group option under VPC Security Groups.  Scroll down to the Database
    options section of the screen and enter a DB name. Once again, we used `MessengerDB`
    as the DB name. Leave the remaining options as they are and click Launch DB instance at
    the end of the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a5dbaed-b509-40a6-924b-1b3a19ed767b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your DB instance will be created by AWS. The creation process may take up to
    10 minutes so it may be a good idea to take a coffee break at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting a little while, click View DB instance details. This will take
    you to a page where you can see detailed information on your just deployed DB
    instance. Scroll to the Connect section of the page to view the connection details
    of the DB instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55fcbcde-cc98-414f-b8f0-8e26e151101d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need these details to successfully connect to the `MessengerDB` on this
    PostgreSQL DB instance. To enable `messenger-api` to connect to `MessengerDB`,
    you must edit the `spring.datasource.url`, `spring.datasource.username`, and `spring.datasource.password` properties
    in the `application.properties` file. After doing this, `application.properties`
    should look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The final thing we will do is deploy the messenger API to an Amazon EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the messenger API to Amazon Elastic Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deploying an application to AWS is simple as well. Navigate to the AWS console
    and select Services | Compute | Elastic Beanstalk**. **Once in the Elastic Beanstalk
    Management Console, click on Create New Application. Once taken to the Create
    Application page, you will be asked to provide a name and description for the
    new application to be created. Name the app `messenger-api` and proceed to the
    next screen. You will be taken to a screen in which you are prompted to create
    a new environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1729dc3e-dd05-4dd6-9714-0cb63e172c40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a web server environment on this screen. Next up, you will need to configure
    the environment type. Select the Tomcat predefined configuration and change the
    environment type to Single instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8c7749c-2754-4aaf-8ba5-20d7883ee28f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Continue to the next screen when you are ready. On the next screen, you will
    need to select a source for your application. Choose Upload your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5656426d-6bf5-4700-9f15-7dd5ec47190c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we need to create a suitable project jar to be uploaded. We can package
    the messenger API into a jar with the help of Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3186ca6c-7136-4038-a045-1d2fb3a795f5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click the Maven Projects button to the right of your project IDE screen and
    select messenger-api | Lifecycle | package. A project jar will be packaged and
    stored in the target directory of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Now go back to AWS and choose this jar file as the source file to be uploaded.
    Leave other properties as they are and click Next.  You may have to wait for a
    few minutes while the packaged jar is uploaded. Once the upload is done, you will
    be taken to a new screen where your environment information is presented to you.
    Proceed through the next few screens by clicking Next until you are presented
    with a Configuration Details screen. Change the instance type to `t2.micro`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed through the next screens until you reach the Review Information section.
    Scroll through this page until you reach the Environment Info section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf72acae-808a-46c9-89a5-5f403f33e0d9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Your environment URL will differ. Take note of this information as you will
    need it later on. Scroll to the bottom of the web page and click Launch. Elastic
    Beanstalk will launch your new environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once the launch finishes, you are good to go. You have successfully deployed
    the `messenger-api` to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to utilize Kotlin to build a Spring Boot REST
    application programming interface. In the process of doing so, we learned the
    basics of designing systems. We expressed the behavior of the messenger API system
    with a state diagram, and learned how to properly interpret the information represented
    in a state diagram. We went one step further by creating an E-R diagram to give
    a detailed diagrammatic representation of system entities and their relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we learned how to set up PostgreSQL on a local machine and create
    a new PostgreSQL database. We also explored how to build a microservice with Spring
    Boot 2.0, connect the microservice to a database, and interact with data existing
    in a database with Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: Besides all this, we learned how to properly secure a RESTful Spring Boot web
    application with Spring Security and **JSON Web Tokens** (**JWTs**). We created
    custom Spring Security configurations to facilitate user authentication with the
    help of JWTs and created custom filters for the authentication process. Lastly,
    we learned how to deploy a Spring Boot application to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore Kotlin further in the Android domain by
    building the Android messenger application.
  prefs: []
  type: TYPE_NORMAL
