- en: Designing and Implementing the Messenger Backend with Spring Boot 2.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 2.0 设计和实现消息后端
- en: In the last couple of chapters, we gained a firm grasp of the fundamentals of
    the Kotlin programming language by implementing the classic game, *Tetris*. In
    [Chapter 3](kt-prog-ex_ch03.html), *Implementing Tetris Logic and Functionality*,
    we finished the development of the game by implementing its application logic.
    We created programmatic models for blocks, shapes, frames, and the application
    as a whole, via an app model class. In addition, we learned how to create custom
    views by implementing Tetris view—a view that the user of the application interacted
    with to play the game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们通过实现经典的俄罗斯方块游戏，对 Kotlin 编程语言的基础知识有了牢固的掌握。在[第 3 章](kt-prog-ex_ch03.html)，*实现俄罗斯方块逻辑和功能*中，我们通过实现应用程序逻辑完成了游戏开发。我们通过应用程序模型类创建了方块、形状、框架以及整个应用程序的程序模型。此外，我们还学习了如何通过实现俄罗斯方块视图——用户与应用程序交互以玩游戏的一个视图——来创建自定义视图。
- en: 'We will hone our Kotlin development skills further by developing a simple messenger
    application for the Android platform. In the process of implementing the Android
    application, we will first develop a RESTful API that will provide web content
    to the application behind the scenes. The application programming interface will
    be built with Spring Boot 2.0\. After developing the application programming interface,
    we will deploy it to a remote server. Over the course of this chapter, you will
    learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为 Android 平台开发一个简单的消息应用来进一步磨练我们的 Kotlin 开发技能。在实现 Android 应用程序的过程中，我们首先将开发一个
    RESTful API，该 API 将为后台的应用程序提供网络内容。应用程序编程接口将使用 Spring Boot 2.0 构建。在开发应用程序编程接口之后，我们将将其部署到远程服务器。在本章的整个过程中，你将学习以下主题：
- en: Basic system design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本系统设计
- en: Modeling system behavior with state diagrams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态图建模系统行为
- en: Database design fundamentals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库设计基础
- en: Modeling a database with entity relationship (E-R) diagrams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用实体关系（E-R）图建模数据库
- en: Building backend microservices with Spring Boot 2.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 2.0 构建 backend 微服务
- en: Working with PostgreSQL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL
- en: Dependency management with Maven
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Maven 进行依赖管理
- en: Amazon Web Services (AWS)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊网络服务 (AWS)
- en: Without further ado, let's dive into this chapter by designing the messenger
    application programming interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不再赘述，让我们通过设计消息应用程序编程接口来深入本章内容。
- en: Designing the messenger API
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计消息 API
- en: To design a fully functional RESTful application programming interface for our
    messenger android application, we must fully understand the concept of application
    programming interfaces, **Representational State Transfer** (**REST**) and RESTful
    services.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的消息 Android 应用程序设计一个完全功能性的 RESTful 应用程序编程接口，我们必须完全理解应用程序编程接口的概念，**表示状态转移**（**REST**）以及
    RESTful 服务。
- en: Application programming interfaces
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序编程接口
- en: An application programming interface is a collection of functions, routines,
    procedures, protocols, and resources that can be used for building software. In
    other words, an application programming interface—API for short—is a collection
    of well-defined and appropriately structured methods or channels of communication
    between software components.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口是一组可用于构建软件的函数、例程、过程、协议和资源。换句话说，应用程序编程接口——简称 API——是一组定义良好且结构适当的软件组件之间的方法或通信渠道集合。
- en: Application programming interfaces can be developed for use with various application
    domains. Some common application domains that APIs are developed for include the
    development of web-based systems, operating systems, and computer hardware, as
    well as interaction with embedded systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口可以用于各种应用程序领域。API 开发的一些常见应用程序领域包括基于 Web 的系统、操作系统和计算机硬件的开发，以及与嵌入式系统的交互。
- en: REST
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: Restful state transfer is a way of facilitating functional operation and interactions
    between two or more distinct systems (or subsystems) via the internet. Web services
    that adhere to REST allow interacting systems to access web content; they also
    perform authorized operations on web content that they have access to. These inter-system
    communications are done using a well-defined set of stateless operations. A RESTful
    web service adheres to REST and provides web content to communicating systems
    via predetermined stateless operations.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful状态转移是一种通过互联网促进两个或更多不同系统（或子系统）之间功能操作和交互的方式。遵循REST的Web服务允许交互系统访问Web内容；它们还对其可访问的Web内容执行授权操作。这些跨系统通信是通过一组定义良好的无状态操作完成的。RESTful
    Web服务遵循REST，并通过预定的无状态操作向通信系统提供Web内容。
- en: In the present day, numerous systems that communicate with web services utilize
    REST. Systems that may utilize REST are based on the client-server architecture.
    The API we will be developing is based on REST, and, as such, will make use of
    representational state transfer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今，许多与Web服务通信的系统都使用REST。可能使用REST的系统基于客户端-服务器架构。我们将开发的API基于REST，因此将利用表示状态转移。
- en: Designing the messenger API system
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计信使API系统
- en: In this section, we will attempt to concisely design the messenger API system.
    You may be wondering at this point what exactly system design is and what it entails.
    Fear not, we will explain these in the next few paragraphs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试简要地设计信使API系统。你可能此时会想知道系统设计究竟是什么，以及它包含哪些内容。不用担心，我们将在接下来的几段中解释这些。
- en: System design is the process of defining the architecture, modules, interfaces,
    and data for a system to satisfy specified requirements that are from a pre-performed
    system analysis phase. System design consists of numerous processes and the utilization
    of different design orientations. In addition, the in-depth designing of systems
    requires the understanding of numerous topics, such as coupling and cohesion,
    which are far beyond the scope of this book. With this in mind, we shall attempt
    to give basic definitions of the interactions and data utilized in our system.
    We shall achieve this by designing the system incrementally.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统设计是定义系统架构、模块、接口和数据的流程，以满足来自预执行系统分析阶段的特定要求。系统设计包括多个流程和不同设计方向的利用。此外，深入设计系统需要理解许多主题，如耦合和内聚，这些主题远远超出了本书的范围。考虑到这一点，我们将尝试给出我们系统中交互和数据的基本定义。我们将通过逐步设计系统来实现这一点。
- en: Incremental development
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增量开发
- en: Incremental development is an approach that can be used for the development
    of systems. Incremental development utilizes the incremental build model. The
    incremental build model is a method of developing software in which a product
    is designed, implemented, and tested incrementally. We will be developing the 
    messenger API incrementally. We will in no way attempt to specify everything needed
    by the messenger API before we start coding. We will determine a set of specifications
    to get us going with the development and then create some functionality, after
    which we will repeat the process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 增量开发是一种可以用于系统开发的方法。增量开发利用增量构建模型。增量构建模型是一种软件开发方法，其中产品是逐步设计、实现和测试的。我们将逐步开发信使API。我们不会在开始编码之前试图指定信使API所需的所有内容。我们将确定一组规格来启动开发，然后创建一些功能，之后我们将重复这个过程。
- en: To comfortably utilize the incremental development methodology, we must utilize
    software that does not penalize us for making changes over the development process,
    such as a case where we need to change the type of data catered for by the system.
    Spring Boot is a perfect candidate for developing systems incrementally as it
    enables quick and easy changes to systems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了舒适地利用增量开发方法，我们必须使用不会因我们在开发过程中进行更改而惩罚我们的软件，例如我们需要更改系统提供的数据类型的情况。Spring Boot是开发增量系统的完美候选者，因为它允许快速轻松地对系统进行更改。
- en: Up to this point, we have referred to Spring Boot a couple of times but have
    neither discussed what it is nor what it is used for. Let's use this opportunity
    to quickly do that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经提到了Spring Boot几次，但既没有讨论它是什么，也没有讨论它的用途。让我们利用这个机会快速地了解一下。
- en: Spring Boot
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot
- en: Spring Boot is a web application framework that was designed and developed for
    the purpose of the boot strapping and development of Spring applications. Spring
    is a web application framework that facilitates the development of web applications
    for the Java platform. Spring Boot makes creating industrial-strength production-grade
    spring-based applications easy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是一个为启动和开发Spring应用程序而设计和开发的Web应用程序框架。Spring是一个用于Java平台的Web应用程序框架，它简化了Web应用程序的开发。Spring
    Boot使得创建工业级的生产级基于Spring的应用程序变得容易。
- en: We will explore how to create web applications with Spring Boot over the course
    of this chapter, but now is not the time for that. Before we start developing
    the application, we must specify what the application actually does (we cannot
    build something when we don't know how it works, after all).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中探讨如何使用Spring Boot创建Web应用程序，但现在还不是时候。在我们开始开发应用程序之前，我们必须明确应用程序实际上要做什么（毕竟，如果我们不知道它的工作原理，就无法构建任何东西）。
- en: What the messenger system does
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信使系统做什么
- en: Here, we will determine the initial requirements of the messenger system and
    what activities can occur within the system. We will identify high-level use cases
    of the messenger application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将确定信使系统的初始需求以及系统内可以发生哪些活动。我们将确定信使应用程序的高级用例。
- en: Use cases
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: A use case is a statement about how an entity uses a system. Entity here refers
    to a type of user or a component interacting with the system. In use case definitions,
    entities can also be referred to as actors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用例是一个关于实体如何使用系统的陈述。这里的实体指的是与系统交互的用户类型或组件。在用例定义中，实体也可以被称为参与者。
- en: 'We start off by identifying the actors in the messenger system. A glaringly
    obvious actor is the user of the application (the person that uses the application
    to satisfy their messaging needs). Another actor that ideally should be considered
    is the admin. For the purpose of this simple messenger application though, we
    will cater for the single user actor. The use cases of the user are as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先识别信使系统中的参与者。一个显而易见的参与者是应用程序的用户（使用应用程序来满足他们的消息需求的人）。另一个理想情况下应该考虑的参与者是管理员。然而，为了这个简单的信使应用程序，我们将为单个用户参与者提供服务。用户的用例如下：
- en: The user uses the messenger platform to send and receive messages
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用信使平台发送和接收消息
- en: The user uses the messenger platform to view other users on the messenger app
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用信使平台查看信使应用上的其他用户
- en: The user uses the messenger platform to set and update his status
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用信使平台设置和更新其状态
- en: The user can sign up to the messenger platform
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以注册到信使平台
- en: The user can log in to the messenger platform
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以登录到信使平台
- en: The preceding use cases are enough to get us going. If, at any point during
    the course of system development, we come across a new use case, we can easily
    add that to the system. Now that we have identified the use cases of the system,
    we must properly describe the behavior of the system in catering for these use
    cases.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述用例足以让我们开始。如果在系统开发的任何阶段遇到新的用例，我们都可以轻松地将它添加到系统中。现在我们已经确定了系统的用例，我们必须适当地描述系统为满足这些用例而表现出的行为。
- en: System behavior
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统行为
- en: We define system behavior to have an accurate idea of what the system does,
    as well as to clearly describe the interactions between components of the system.
    As this is a very simple application, we can clearly describe application behavior
    with the aid of a diagram. We will make use of a state diagram to properly describe
    this behavior.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义系统行为是为了准确了解系统做什么，以及清楚地描述系统组件之间的交互。由于这是一个非常简单的应用程序，我们可以借助图表清楚地描述应用程序的行为。我们将使用状态图来正确描述这种行为。
- en: '**State diagrams**: A state diagram is used to describe the behavior of systems.
    A state diagram describes a system utilizing different possible states. In a state
    diagram, there exists a finite number of possible states that a system can be
    in.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态图**：状态图用于描述系统的行为。状态图描述了一个系统利用不同的可能状态。在状态图中，存在有限数量的可能状态，系统可以处于这些状态之一。'
- en: 'The following is the state diagram for our system, taking into consideration
    the defined use cases:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们系统的状态图，考虑到定义的用例：
- en: '![](img/0b6275fc-b0c1-466e-8aa3-c6bb22f78c6a.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b6275fc-b0c1-466e-8aa3-c6bb22f78c6a.jpg)'
- en: Each circle in the preceding diagram represents a state of execution of the
    system at a point in time. Each arrow represents an action a user can request
    to be carried out by the system. Upon initial start, the API waits for requests
    from client applications.  This behavior is shown in the **Waiting for action**
    state. When an action request is received by the API from the client application,
    the system goes out of the **Waiting for action** state and services the request
    sent with an appropriate process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图中每个圆圈代表系统在某一时间点的执行状态。每条箭头代表用户可以请求系统执行的操作。在初始启动时，API等待来自客户端应用程序的请求。这种行为在**等待操作**状态中显示。当API从客户端应用程序接收到操作请求时，系统就会离开**等待操作**状态，并使用适当的过程处理发送的请求。
- en: For example, when a user requests a status update from the Android application,
    the server leaves the **Waiting for action** state and executes the  **Attempt
    status update** process, after which it goes back to the **Waiting for action** state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户从Android应用程序请求状态更新时，服务器会从**等待操作**状态变为执行**尝试状态更新**过程，之后又回到**等待操作**状态。
- en: Identifying data
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定数据
- en: It is important to have an idea of the type of data needed before implementing
    a system. We can easily identify this data from the use case definitions we gave
    earlier. From our use case specifications, we can determine that two basic types
    of data are required. These are the user data and the message data. As the names
    imply, the user data is the data required of every user, and message data is the
    data pertaining to a message sent. We are not concerned with things such as schemas,
    entities, or entity relationship diagrams yet. We just require an idea of the
    data to be required by the system.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施系统之前，了解所需数据的类型是很重要的。我们可以很容易地从我们之前给出的用例定义中识别这些数据。从我们的用例规范中，我们可以确定需要两种基本类型的数据。这些是用户数据和消息数据。正如名称所暗示的，用户数据是每个用户所需的数据，而消息数据是与发送的消息相关的数据。我们目前还不关心诸如模式、实体或实体关系图之类的事情。我们只需要了解系统所需的数据。
- en: As this is a messenger app, the user we will require a username, phone number,
    password, and a status message. It will also be useful to keep track of the status
    of their account to know whether the account of a particular user is activated
    or has been deactivated for some reason. Not much is required as of now pertaining
    the messages sent. We need to keep track of the sender of a message and the intended
    recipient of the message.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个消息传递应用，我们将需要用户名、电话号码、密码和状态消息。跟踪他们的账户状态也很有用，以便知道特定用户的账户是否已激活或因某些原因被停用。目前关于发送的消息不需要太多。我们需要跟踪消息的发送者和消息的预期接收者。
- en: That is all for now with respect to the data needed. We will identify more data
    required as the development of the application progresses, but, for now, let's
    code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 关于所需数据的讨论就到这里。随着应用程序的开发进展，我们将识别更多所需的数据，但就目前而言，让我们开始编码。
- en: Implementing the messenger backend
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现消息传递后端
- en: Now that we have some sense of direction pertaining to the use cases of the
    messenger system as a whole, the data required within the system, and the behavior
    of the system, we can get started with developing the backend of the system. As
    we have said earlier, we will be utilizing Spring Boot to develop the messenger
    API because it is a perfect candidate for incremental development. In addition
    to this, Kotlin and Spring Boot function very well together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对整个消息传递系统的用例、系统内部所需的数据以及系统的行为有了大致的方向，我们可以开始开发系统的后端。正如我们之前所说的，我们将利用Spring
    Boot来开发消息传递API，因为它非常适合增量开发。此外，Kotlin和Spring Boot配合得非常好。
- en: As we will be handling data within the messenger API, we will need a suitable
    database to store the data needed by the messenger system. We will making use
    of PostgreSQL as our database. Let’s take a brief look at PostgreSQL.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在消息传递API中处理数据，我们需要一个合适的数据库来存储消息传递系统所需的数据。我们将使用PostgreSQL作为我们的数据库。让我们简要了解一下PostgreSQL。
- en: PostgreSQL
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL is an object-relational database management system that puts particular
    emphasis on extensibility and standards compliance. PostgreSQL is known as Postgres.
    It is commonly utilized as a database server. When utilized in this way, its primary
    functions are to securely store data and return the data stored upon request by
    software applications.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 是一种特别强调可扩展性和标准兼容性的对象关系型数据库管理系统。PostgreSQL 也被称为 Postgres。它通常用作数据库服务器。当以这种方式使用时，其主要功能是安全存储数据，并按照软件应用程序的请求返回存储的数据。
- en: 'There are numerous advantages to using PostgreSQL as a datastore. Some of these
    advantages are:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL 作为数据存储有许多优点。其中一些优点包括：
- en: '**Extensibility**: The features of PostgreSQL can be easily and readily extended
    by its users. This is because its source code is available to all for free.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：PostgreSQL 的功能可以很容易地由其用户扩展。这是因为其源代码对所有用户免费提供。'
- en: '**Portability**: PostgreSQL is available for all major platforms. Versions
    of PostgreSQL are available for almost every UNIX brand. Windows compatibility
    is also made possible via they Cygwin framework.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：PostgreSQL 可用于所有主要平台。几乎每个 UNIX 品牌都有 PostgreSQL 的版本。通过 Cygwin 框架，Windows
    兼容性也成为可能。'
- en: '**Integrity**: Ready availability of GUI-based tools that facilitate easy interactions
    with PostgreSQL.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：基于 GUI 的工具随时可用，便于轻松与 PostgreSQL 交互。'
- en: Installing PostgreSQL
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 PostgreSQL
- en: The installation of PostgreSQL is straightforward on all platforms. This section
    highlights its installation process on Windows, macOS, and Linux.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有平台上安装 PostgreSQL 都很简单。本节重点介绍了 Windows、macOS 和 Linux 上的安装过程。
- en: Windows installation
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 安装
- en: 'To install PostgreSQL on Windows, perform the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上安装 PostgreSQL，请执行以下步骤：
- en: Download and run an appropriate version of the Windows PostgreSQL interactive
    installer. This can be downloaded from [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并运行适合的 Windows PostgreSQL 交互式安装程序。您可以从 [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows)
    下载。
- en: Install PostgreSQL as a Windows service. Make sure you take note of the PostgreSQL
    Windows service account name and password. You will need these details later in
    the installation process.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 PostgreSQL 安装为 Windows 服务。确保您记下 PostgreSQL Windows 服务账户名称和密码。您在安装过程中需要这些详细信息。
- en: Select the PL/pgsql procedural language to be installed when prompted by the
    installer to do so.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当安装程序提示时，选择要安装的 PL/pgsql 过程性语言。
- en: You may choose to install pgAdmin when directed to the Installation options
    screen. If you install pgAdmin, enable the Adminpack contrib module when prompted
    by the installer.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您被引导到安装选项屏幕时，您可以选择安装 pgAdmin。如果您安装了 pgAdmin，当安装程序提示时，请启用 Adminpack contrib
    模块。
- en: If you follow the previous steps properly, PostgreSQL will be successfully installed
    on your system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正确遵循了前面的步骤，PostgreSQL 将会成功安装在您的系统上。
- en: macOS installation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: macOS 安装
- en: 'PostgreSQL can be easily installed on macOS with Homebrew. If you do not already
    have Homebrew installed on your system, consult [Chapter 1](kt-prog-ex_ch01.html), *The
    Fundamentals* for its installation instructions. Once you have determined that
    Homebrew is installed on your system, open your terminal and run the following
    command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Homebrew 可以轻松地在 macOS 上安装 PostgreSQL。如果您系统上尚未安装 Homebrew，请参阅第 1 章 *基础* 的安装说明。一旦确定
    Homebrew 已安装在您的系统上，打开您的终端并运行以下命令：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Follow the installation instructions when prompted in the Terminal. Along the
    course of the installation, you may be asked for the admin password of your system.
    Input the password and wait for the installation to finish. You will be prompted
    once the installation is complete.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当在终端中提示时，请遵循安装说明。在安装过程中，您可能需要输入系统管理员密码。输入密码并等待安装完成。安装完成后，您将收到提示。
- en: Linux installation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 安装
- en: 'PostgreSQL can easily be installed on Linux with the use of the PostgreSQL
    Linux installer:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PostgreSQL Linux 安装程序，可以轻松地在 Linux 上安装 PostgreSQL：
- en: Go to the PostgreSQL installer download web page at [https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 PostgreSQL 安装程序下载网页：[https://www.enterprisedb.com/downloads/postgres-postgresql-downloads](https://www.enterprisedb.com/downloads/postgres-postgresql-downloads)。
- en: Select the PostgreSQL version you want to install.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要安装的 PostgreSQL 版本。
- en: Select an appropriate Linux installer for PostgreSQL.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合PostgreSQL的适当Linux安装程序。
- en: Click the download button to download the installer.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下载按钮下载安装程序。
- en: Run the installer once it has been downloaded and follow all installation instructions
    appropriately.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载安装程序后，按照所有安装说明进行操作。
- en: Once you have provided the information needed by the installer, PostgreSQL will
    be installed on your system.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦提供了安装程序所需的信息，PostgreSQL将安装到你的系统上。
- en: Now that we have set up PostgreSQL on our system, we can commence with the creation
    of the messenger API.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在系统上设置了PostgreSQL，我们可以开始创建messenger API。
- en: Creating a new Spring Boot application
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的Spring Boot应用程序
- en: 'The initial creation on a Spring Boot application is easy with the utilization
    of IntelliJ IDE and the Spring initializer. Open IntelliJ IDE and create a new
    project with the Spring Initializer. This can be done by clicking on Create New
    Project and selecting Spring Initializer on the left side bar of the New Project screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 利用IntelliJ IDE和Spring Initializer，在Spring Boot应用程序上的初始创建很容易。打开IntelliJ IDE，并使用Spring
    Initializer创建一个新项目。这可以通过在“新建项目”屏幕的左侧栏中点击“创建新项目”并选择“Spring Initializer”来完成：
- en: '![](img/cfcdb014-9701-4b9c-8fa1-4c318745d573.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cfcdb014-9701-4b9c-8fa1-4c318745d573.jpg)'
- en: After selecting the Spring Initializer, progress to the next screen by clicking
    the Next button. Upon clicking next, before the next screen is displayed, Spring
    Initializer will be retrieved by the IDE. This will only take a few moments to
    do.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择Spring Initializer后，通过点击“下一步”按钮进入下一屏幕。在显示下一屏幕之前，IDE将检索Spring Initializer。这只需要几分钟。
- en: The Spring plugin is only available in the Ultimate edition of IntelliJ IDEA,
    which comes with a paid subscription.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Spring插件仅在IntelliJ IDEA的Ultimate版本中可用，该版本包含付费订阅。
- en: 'Once the Spring Initializer is retrieved, you will be asked to provide the
    appropriate details for the project to be created. Fill in the necessary details.
    You may choose to use the details used for the development of the application
    in this book or decide to input your own. However, in the instance that you want
    to use our details, do the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了Spring Initializer，你将被要求提供创建项目的适当详细信息。填写必要的详细信息。你可以选择使用本书中应用程序开发所使用的详细信息，或者决定输入你自己的信息。然而，如果你想要使用我们的详细信息，请按照以下步骤操作：
- en: Input `com.example` as the group ID.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`com.example`作为组ID输入。
- en: Enter `messenger-api` as the artifact ID.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`messenger-api`作为工件ID输入。
- en: Select Maven Project as the project type if it is not already selected.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未选择，请选择Maven项目作为项目类型。
- en: Leave the packaging option and the Java version the way they are.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持包装选项和Java版本不变。
- en: Select Kotlin as the language. This is important, as we are learning the Kotlin
    language, after all.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Kotlin作为语言。这很重要，因为毕竟我们是在学习Kotlin语言。
- en: Leave the SNAPSHOT value as it is.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持SNAPSHOT值不变。
- en: Enter a description of your choice.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你选择的描述。
- en: Input `com.example.messenger.api` as the package name.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`com.example.messenger.api`作为包名输入。
- en: 'After filling in the required project information, proceed to the next screen
    by clicking Next:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写所需的项目信息后，通过点击“下一步”按钮进入下一屏幕：
- en: '![](img/64b45967-3681-4f5f-a436-03c427b640d8.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64b45967-3681-4f5f-a436-03c427b640d8.jpg)'
- en: In the next screen, you will be asked to select the project dependencies. For
    starters, we will need to select the Security, Web, JPA, and PostgreSQL dependencies.
    Security can be found under the Core category, Web can be found under the Web category,
    and JPA and PostgreSQL can be found under the SQL category. In addition, in the
    Spring Boot Version selection drop-down menu at the top of the screen, select
    2.0.0 M5 as the version.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一屏幕，你将被要求选择项目依赖项。一开始，我们需要选择Security、Web、JPA和PostgreSQL依赖项。Security可以在“核心”类别下找到，Web可以在“Web”类别下找到，而JPA和PostgreSQL可以在“SQL”类别下找到。此外，在屏幕顶部的Spring
    Boot版本选择下拉菜单中，选择2.0.0 M5作为版本。
- en: 'After the selection of the necessary dependencies, the content should look
    similar to the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择必要的依赖项后，内容应类似于以下截图：
- en: '![](img/702ff1e7-f2a8-428a-8d53-b9176ee7ffbc.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/702ff1e7-f2a8-428a-8d53-b9176ee7ffbc.jpg)'
- en: After selecting the appropriate dependencies, click Next to continue to the
    final setup screen. You will be asked to provide a project name and a project
    location. Fill in `messenger-api` as the project name and select the location
    where want the project to be saved on your computer. Select Finish and wait for
    the project to be set up. You will be taken to a new IDE window containing the
    initial project files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择适当的依赖项后，点击“下一步”继续到最后一个设置屏幕。你将被要求提供项目名称和项目位置。将项目名称填写为 `messenger-api` 并选择你希望在计算机上保存项目的位置。选择“完成”并等待项目设置完成。你将被带到一个新的
    IDE 窗口，其中包含初始项目文件。
- en: Getting familiar with Spring Boot
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉 Spring Boot
- en: 'Let''s take a look at the structure of the initial program files for this Spring
    Boot application. The following is the screenshot of the structure of your Spring
    Boot application files:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个 Spring Boot 应用程序的初始程序文件的结构。以下是你 Spring Boot 应用程序文件结构的截图：
- en: '![](img/8f299d4c-2156-4a9f-bf11-cfc1a514fe12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f299d4c-2156-4a9f-bf11-cfc1a514fe12.jpg)'
- en: 'All source files are contained in the `src` directory. This directory contains
    the core application program files as well as the test programs that are written
    for the application. Core application program files should be put in the `src/main`
    directory and test programs are located in `src/test`. The main directory contains
    two subdirectories. These are the `kotlin` directory and the `resources` directory.
    All packages and main source files will be placed in this directory over the course
    of this chapter. More specifically, our program files and packages will be placed
    within the `com.example.messenger.api` package. Let''s have a quick look at the
    `MessengerApiAplication.kt` file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有源文件都包含在 `src` 目录中。该目录包含核心应用程序程序文件以及为应用程序编写的测试程序。核心应用程序程序文件应放在 `src/main` 目录中，测试程序位于
    `src/test`。主目录包含两个子目录。这些是 `kotlin` 目录和 `resources` 目录。在本章的整个过程中，所有包和主源文件都将放置在这个目录中。更具体地说，我们的程序文件和包将放置在
    `com.example.messenger.api` 包内。让我们快速看一下 `MessengerApiApplication.kt` 文件：
- en: '![](img/51ef928f-315b-420f-a251-8046c82bf1de.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51ef928f-315b-420f-a251-8046c82bf1de.jpg)'
- en: The `MessengerApplication.kt` file contains the main function. This is the entry
    point of every Spring Boot application. This function is called when the application
    starts. Once it is called, the function runs the Spring application by calling
    the `SpringApplication.run()` function. This function takes two arguments. The
    first argument is a class reference and the second is the arguments to be passed
    to the application upon start.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessengerApplication.kt` 文件包含主函数。这是每个 Spring Boot 应用程序的入口点。当应用程序启动时，会调用此函数。一旦调用，该函数通过调用
    `SpringApplication.run()` 函数来运行 Spring 应用程序。此函数接受两个参数。第一个参数是一个类引用，第二个参数是在应用程序启动时传递给应用程序的参数。'
- en: In the same file, there's a `MessengerApiApplication` class. This class is annotated
    with the `@SpringBootApplication` annotation. The use of this annotation is equivalent
    to the combined use of the `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan` annotations.
    Classes annotated with `@Configuration` are sources of bean definitions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文件中，有一个 `MessengerApiApplication` 类。这个类被 `@SpringBootApplication` 注解所标注。使用此注解相当于同时使用
    `@Configuration`、`@EnableAutoConfiguration` 和 `@ComponentScan` 注解。被 `@Configuration`
    注解的类是 bean 定义源。
- en: A bean is an object that is instantiated and assembled by a Spring IoC container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Bean 是由 Spring IoC 容器实例化和组装的对象。
- en: The `@EnableAutoConfiguration` attribute tells the Spring Boot that you want
    your Spring application to be automatically configured based on the jar dependencies
    that you have provided. The `@ComponentScan` annotation configures component scanning
    directories for use with the `@Configuration` classes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnableAutoConfiguration` 属性告诉 Spring Boot，你希望你的 Spring 应用程序根据你提供的 jar 依赖项自动配置。`@ComponentScan`
    注解配置了用于与 `@Configuration` 类一起使用的组件扫描目录。'
- en: Over the course of developing Spring Boot applications, it will be necessary
    to use several annotations for varying reasons. Using these annotations may be
    overwhelming at first, but with time they will become second nature.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Spring Boot 应用程序的过程中，出于各种原因，将需要使用多个注解。一开始使用这些注解可能会感到有些令人不知所措，但随着时间的推移，它们将变得习以为常。
- en: 'Besides `MessengerApplication.kt`, another important file is the `application.properties` file,
    located in `src/main/resources`. This file is used for configuring Spring Boot
    applications properties. Upon opening this file, you will discover that it has
    no content. This is because we have not yet defined any application configurations
    or properties. Let''s go ahead and add a couple of configurations. Input the following
    into the `application.properties` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`MessengerApplication.kt`之外，另一个重要的文件是位于`src/main/resources`的`application.properties`文件。该文件用于配置Spring
    Boot应用程序的属性。打开此文件时，你会发现它没有任何内容。这是因为我们尚未定义任何应用程序配置或属性。让我们继续添加一些配置。将以下内容输入到`application.properties`文件中：
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `spring.jpa.generate-ddl` property specifies whether the database schema
    should be generated upon startup of the application. When this property is set
    to `true`, the schema is generated on application startup, otherwise the schema
    is not generated. The `spring.jpa.hibernate.ddl-auto` property is used to specify
    the DDL mode. We use `create-drop` because we want the schema to be created upon
    application startup and destroyed upon the termination of the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring.jpa.generate-ddl`属性指定是否在应用程序启动时生成数据库模式。当此属性设置为`true`时，模式将在应用程序启动时生成，否则模式不会生成。`spring.jpa.hibernate.ddl-auto`属性用于指定DDL模式。我们使用`create-drop`是因为我们希望在应用程序启动时创建模式，并在应用程序终止时销毁模式。'
- en: 'We have utilized properties to define the schema of our database but have yet
    to create an actual database for the `messenger-api`. If you installed pgAdmin
    along with PostgreSQL, you can easily create a database with the software. If
    you didn''t install pgAdmin, fear not, we can still easily create a database for
    our application by using PostgreSQL''s `createdb` command. Navigate to your terminal
    and enter the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经利用属性定义了数据库的模式，但尚未为`messenger-api`创建实际的数据库。如果你与PostgreSQL一起安装了pgAdmin，你可以使用该软件轻松创建数据库。如果你没有安装pgAdmin，不要担心，我们仍然可以通过使用PostgreSQL的`createdb`命令轻松为我们的应用程序创建数据库。导航到你的终端，并输入以下命令：
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `-h` flag is used to specify the host name of the machine on which the database
    server is running. The `--username` flag specifies the username to connect to
    the server with. The `--password` flag forces a prompt for the specification of
    a password. The `messenger-api` is the name we are giving to the database being
    created. Substitute `<username>` with your server username. After you've input
    the command, click the enter key to run the command. Input a desired password
    when prompted to do so. A database named `messenger-api` will be created in PostgreSQL.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h`标志用于指定数据库服务器正在运行的机器的主机名。`--username`标志指定用于连接服务器的用户名。`--password`标志强制提示输入密码。`messenger-api`是我们为正在创建的数据库所取的名字。用`<username>`替换你的服务器用户名。输入命令后，按回车键运行命令。当提示时输入一个想要的密码。将在PostgreSQL中创建一个名为`messenger-api`的数据库。'
- en: 'Now that we have out database set up, we need to connect the Spring Boot application
    to the database. We can do this with the use of the `spring.datasource.url`, `spring.datasource.username`,
    and `spring.datasource.password` properties. Add the following configurations
    to the `application.properties` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了数据库，我们需要将Spring Boot应用程序连接到数据库。我们可以通过使用`spring.datasource.url`、`spring.datasource.username`和`spring.datasource.password`属性来实现这一点。将以下配置添加到`application.properties`文件中：
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `spring.datasource.url` property specifies the JDBC URL via which Spring
    Boot will connect to the database. The  `spring.datasource.username` and `spring.datasource.password` are
    the properties used to specify the server username and the password correlating
    with the specified username. Replace `<username>` and `<password>` with your username
    and password.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring.datasource.url`属性指定Spring Boot将通过该JDBC URL连接到数据库。`spring.datasource.username`和`spring.datasource.password`是用于指定与指定用户名相关联的服务器用户名和密码的属性。用`<username>`和`<password>`替换你的用户名和密码。'
- en: Once you have these properties set up, you are ready to start the Spring Boot
    application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了这些属性，你就可以开始启动Spring Boot应用程序了。
- en: 'Once you have these properties set up, you are ready to start the Spring Boot
    application. You can run the `messenger-api` application by clicking on the Kotlin
    logo next to the main function in `MessengerApiApplication.kt` and selecting the
    Run option, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你设置了这些属性，你就可以开始启动Spring Boot应用程序。你可以通过点击`MessengerApiApplication.kt`中主函数旁边的Kotlin标志并选择运行选项来运行`messenger-api`应用程序，如下面的截图所示：
- en: '![](img/bb7fda59-faa5-44b7-9925-888a83b16608.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb7fda59-faa5-44b7-9925-888a83b16608.jpg)'
- en: Wait for a moment for the project to build. Once the project build process is
    complete, the application will be started on a Tomcat server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请稍等片刻，等待项目构建完成。一旦项目构建过程完成，应用程序将在Tomcat服务器上启动。
- en: 'Let''s continue exploring our project files. Locate a `pom.xml` file in the
    root directory of the project. **POM** stands for **Project Object Model**. On
    the Apache Maven site, the following is said about the POM: *A Project Object
    Model or POM is the fundamental unit of work in Maven.* It is an XML file that
    contains information about the project and configuration details used by Maven
    to build the project. Once you have located this file, open it. Straightforward,
    right? That’s all fine and dandy, but, for the sake of clarity, here''s a brief
    description of Maven.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探索我们的项目文件。在项目的根目录下找到`pom.xml`文件。**POM**代表**项目对象模型**。在Apache Maven网站上，关于POM有这样的描述：*项目对象模型或POM是Maven中的基本工作单元。*
    它是一个包含有关项目和Maven构建项目时使用的配置细节的XML文件。一旦找到这个文件，就打开它。简单直接，对吧？一切都很好，但是为了清晰起见，这里简要介绍一下Maven。
- en: Maven
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven
- en: Apache Maven is a software project management and comprehension tool that is
    based on the concept of the POM. Maven can be used for several purposes, such
    as project build management and documentation.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Maven是一个基于POM概念的项目管理和理解工具。Maven可用于多个目的，例如项目构建管理和文档。
- en: Having understood the project files to an extent, we will continue development
    by implementing some models to cater to the data we identified earlier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上理解了项目文件后，我们将通过实现一些模型来继续开发，以满足我们之前确定的数据。
- en: Creating models
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Here, we are going to model the data we have identified into suitable entity
    classes that can be introspected by Spring Boot to build a suitable database schema.
    The first model we will concern ourselves with is the user model. Create a package
    named `models` under the `com.example.messenger.api` package. Create a `User.kt`
    file within the package and input the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把已经确定的数据建模成适合的实体类，这样Spring Boot就可以通过它们构建合适的数据库模式。我们将首先关注的是用户模型。在`com.example.messenger.api`包下创建一个名为`models`的包。在包内创建一个`User.kt`文件，并输入以下代码：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We made use of a lot of annotations in the preceding code block. We will take
    a look at what each of them does in the order in which they appear. First up,
    we have the `@Entity` annotation, which indicates that the class is a **Java Persistence
    API** (**JPA**) entity. The use of the `@Table` annotation specifies a table name
    for the entity being represented by the class. This is useful during schema generation.
    In the case that an `@Table` annotation is not used, the name of the table generated
    will be the class name. A database table will be created in PostgreSQL with the
    name `user`.  `@EntityListener`, as the name implies, specifies an entity listener
    for the entity class. We have not yet created a `UserListener` class, but don't
    worry, we will do that in a little bit.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们使用了大量的注解。我们将按照它们出现的顺序查看每个注解的作用。首先是`@Entity`注解，它表示该类是一个**Java持久化API**（**JPA**）实体。使用`@Table`注解指定了由该类表示的实体的表名。这在模式生成期间很有用。如果没有使用`@Table`注解，生成的表名将是类名。将在PostgreSQL中创建一个名为`user`的数据库表。`@EntityListener`，正如其名所示，指定了实体类的实体监听器。我们尚未创建`UserListener`类，但不用担心，我们稍后会做这件事。
- en: 'Now let''s take a look at the properties of the `User` class. We added seven
    class properties in total. The first five are `username`, `password`, `phoneNumber`,
    `accountStatus`, and `status`; each property represents a type of data we need
    for a user, as we earlier identified in the *Identifying data* section of this
    chapter. We have now created our user entity and are ready to proceed. But wait,
    there''s a problem. We need a way to uniquely identify each user that is created.
    In addition, it is important for future reference to keep track of when new users
    are added to the messenger platform. After careful consideration, we realize that
    it is important to have `id` and `createdAt` properties in our entity. You may
    be wondering—why are we adding `id` and `createdAt` properties to the user entity?
    After all, we did not specify we needed them earlier on. This is true. But, as
    we are developing this backend incrementally, we are allowed to make changes and
    additions when the need arises. Let''s go ahead and add these two properties:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`User`类的属性。我们总共添加了七个类属性。前五个是`username`、`password`、`phoneNumber`、`accountStatus`和`status`；每个属性代表我们为用户所需的一种数据类型，正如我们在本章的*识别数据*部分中早期所确定的。我们现在已经创建了用户实体，并准备继续前进。但是等等，有一个问题。我们需要一种方法来唯一标识创建的每个用户。此外，为了未来的参考，跟踪新用户何时被添加到消息平台也很重要。经过仔细考虑，我们意识到在我们的实体中拥有`id`和`createdAt`属性是很重要的。你可能想知道——为什么我们要在用户实体中添加`id`和`createdAt`属性？毕竟，我们之前并没有指定我们需要它们。这是真的。但是，由于我们正在增量开发这个后端，当需要时，我们可以进行更改和添加。让我们继续添加这两个属性：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Perfect. Now we need to understand what each annotation does. `@Column` is used
    to specify a property representing a table column. In practice, all properties
    of entities represent a column in the table. We make use of `@Column(unique =
    true)` in our code specifically to place a uniqueness constraint on properties.
    This is useful when we do not want more than one record to have a particular attribute
    value. `@Size`, as you might have guessed, is used to specify the size of an attribute
    present in a table. `@Pattern` specifies a pattern that a table attribute must
    match for it to be valid.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。现在我们需要了解每个注解的作用。`@Column`用于指定表示表列的属性。在实践中，实体的所有属性都代表表中的一列。我们在代码中特别使用`@Column(unique
    = true)`来对属性施加唯一性约束。当我们不希望多条记录具有特定的属性值时，这很有用。`@Size`，正如你可能猜到的，用于指定表中存在的属性的尺寸。`@Pattern`指定了一个表属性必须匹配的模式，才能被认为是有效的。
- en: '`@Id` specifies a property that uniquely identifies the entity (the `id` property,
    in this case). `@GeneratedValue(strategy = GenerationType.AUTO)` specifies that
    we want the `id` value to be generated automatically. `@DateTimeFormat`  places
    a timestamp constraint on values to be stored in the `created_at` column of the
    user table.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`指定了一个唯一标识实体的属性（在这个例子中是`id`属性）。`@GeneratedValue(strategy = GenerationType.AUTO)`指定我们希望`id`值自动生成。`@DateTimeFormat`将时间戳约束应用于要存储在用户表`created_at`列中的值。'
- en: 'It is time to create a `UserListener` class. Create a new package named `listeners`.
    Add the following `UserListener` class to the package:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个`UserListener`类了。创建一个新的包名为`listeners`。将以下`UserListener`类添加到该包中：
- en: '[PRE6]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: User passwords should never be saved as plain text in a database. For security
    reasons, they must always be appropriately hashed before being stored. The `hashPassword()` function
    performs this hashing procedure by replacing the string value held by the password
    property of a user object with its hashed equivalent using `BCrypt`. `@PrePersist`
    and `@PreUpdate` specifies that this function should be called before the persistence
    or update of a user record in the database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 用户密码永远不应该以纯文本形式存储在数据库中。出于安全原因，在存储之前必须适当地对它们进行散列。`hashPassword()`函数通过使用`BCrypt`将用户对象的密码属性的字符串值替换为其散列等价物来执行此散列过程。`@PrePersist`和`@PreUpdate`指定在数据库中持久化或更新用户记录之前应该调用此函数。
- en: 'Now let''s create an entity for messages. Go ahead and add a `Message` class
    in the `models` package and add the following code to the class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为消息创建一个实体。请继续在`models`包中添加一个`Message`类，并将以下代码添加到该类中：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We made use of some familiar annotations as well as two new ones. As we discussed
    earlier, every message has a sender as well as a recipient. Both message senders
    and message recipients are users on the messenger platform, hence the message
    entity has both sender and recipient properties of the `User` type. A user can
    be a sender of many messages as well as a recipient of many messages. These are
    relationships that need to be implemented. We make use of the `@ManyToOne` annotation
    to do this. The many-to-one relationships are not optional, thus we use `@ManyToOne(optional
    = false)`.  `@JoinColumn` specifies a column for joining an entity association
    or element collection:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些熟悉的注解以及两个新的注解。正如我们之前讨论的，每条消息都有一个发送者和一个接收者。消息的发送者和接收者都是信使平台上的用户，因此消息实体既有发送者的
    `User` 类型属性，也有接收者的 `User` 类型属性。一个用户可以是许多消息的发送者，也可以是许多消息的接收者。这些都是需要实现的关系。我们使用 `@ManyToOne`
    注解来完成这个任务。多对一关系不是可选的，因此我们使用 `@ManyToOne(optional = false)`。`@JoinColumn` 指定了一个用于连接实体关联或元素集合的列：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code snippet adds a `user_id` attribute that references the `id` of a user
    to the `message` table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 代码片段向 `message` 表中添加了一个 `user_id` 属性，该属性引用了用户的 `id`。
- en: 'Upon close inspection, you will notice that a conversation property was used
    in the `Message` class. This is because messages sent between users happen in
    conversation threads. Simply put, every message belongs to a thread. We need to
    add a `Conversation` class to our `models` package, representing the conversation
    entity:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查后，你会注意到在 `Message` 类中使用了会话属性。这是因为用户之间发送的消息发生在会话线程中。简单来说，每条消息都属于一个线程。我们需要在我们的
    `models` 包中添加一个 `Conversation` 类，代表会话实体：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Numerous messages belong to a conversation, so we have a `messages`  collection
    in the body of the `Conversation` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 许多消息属于一个会话，因此我们在 `Conversation` 类的体中有一个 `messages` 集合。
- en: 'We are almost done with the creation of entity models. The only thing left
    to do is to add appropriate collections for  a user''s sent and received messages:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了实体模型的创建。剩下要做的就是为用户的发送和接收消息添加适当的集合：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'That''s it! We are done creating entities. To help you to understand the entities
    we have made as well as their relationships, here''s an entity relationship diagram
    (E-R diagram). It shows the entities that we have made and their relationships:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们已经完成了实体的创建。为了帮助您理解我们所创建的实体及其关系，这里有一个实体关系图（E-R图）。它显示了我们所创建的实体及其关系：
- en: '![](img/cff0845e-3539-462d-843e-a32ceecb929c.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cff0845e-3539-462d-843e-a32ceecb929c.jpg)'
- en: According to the E-R diagram, a user has many messages, a message belongs to
    a user, a message belongs to a conversation, and a conversation has many messages.
    In addition, a user has many conversations.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 根据E-R图，一个用户有多个消息，一个消息属于一个用户，一个消息属于一个会话，一个会话有多个消息。此外，一个用户有多个会话。
- en: Having created the necessary models, there's only one problem. We have no way
    to access the data stored by these entities. We need to create repositories to
    do this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了必要的模型之后，只有一个问题。我们没有方法访问这些实体存储的数据。我们需要创建仓库来完成这个任务。
- en: Creating repositories
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建仓库
- en: '**Spring Data JPA** has is the ability to create repository implementations
    automatically, at runtime, from a repository interface. We will see how this works
    by creating a repository to access the `User` entities. Create a `repositories` package
    and include `UserRepository.kt` in it:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spring Data JPA** 具有从仓库接口自动创建仓库实现的能力，在运行时进行。我们将通过创建一个访问 `User` 实体的仓库来了解这是如何工作的。创建一个
    `repositories` 包，并将 `UserRepository.kt` 包含在内：'
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`UserRepository` extends the `CrudRepository` interface. The `entity` type
    and `id` type it works with are specified in the generic parameters of `CrudRepository`.
    By extending `CrudRepository`, `UserRepository` inherits methods for working with
    `User` persistence, such as methods for saving, finding, and deleting `User` entities.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserRepository` 扩展了 `CrudRepository` 接口。它所处理的 `entity` 类型以及 `id` 类型在 `CrudRepository`
    的泛型参数中指定。通过扩展 `CrudRepository`，`UserRepository` 继承了处理 `User` 持久化的方法，例如保存、查找和删除
    `User` 实体的方法。'
- en: In addition, Spring JPA allows the declaration of other query functions by the
    use of method signatures. We exploited this capability to create `findByUsername()`
    and `findByPhoneNumber()` functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Spring JPA 允许通过方法签名声明其他查询函数。我们利用这一功能创建了 `findByUsername()` 和 `findByPhoneNumber()`
    函数。
- en: 'As we currently have three entities, we need to have three repositories to
    query them. Create a `MessageRepository` interface in `repositories`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们目前有三个实体，我们需要三个存储库来查询它们。在`repositories`中创建一个`MessageRepository`接口：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice the preceding method signature specifies `List<Message>` as its return
    type. Spring JPA automatically recognizes this and returns a list of `Message` elements
    when `findByConversationId()` is called.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到前面的方法签名指定了`List<Message>`作为其返回类型。Spring JPA会自动识别这一点，并在调用`findByConversationId()`时返回一个`Message`元素的列表。
- en: 'Lastly, implement a `ConversationRepository` interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实现一个`ConversationRepository`接口：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we now have our entities set and the necessary repositories to query these
    entities, we can start work on implementing the business logic of the messenger
    backend. This will require us to learn about services and service implementations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置了实体和查询这些实体的必要存储库，我们就可以开始实现信使后端的业务逻辑了。这需要我们了解服务和服务的实现。
- en: Services and service implementations
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务和服务的实现
- en: A service implementation is a spring bean that is annotated by `@Service`. Business
    logic for spring applications is most commonly put in a service implementation.
    A *service*, on the other hand, is an interface with function signatures for application
    behavior that must be implemented by implementing classes. A simple way to recall
    the differentiation between the two is to keep in mind that a service is an interface
    and a service implementation is a class that implements a service.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实现是一个被`@Service`注解的Spring bean。Spring应用程序的业务逻辑通常放在服务实现中。另一方面，*服务*是一个具有应用行为函数签名的接口，这些函数必须由实现类实现。回忆这两个概念之间的区别的一个简单方法是记住服务是一个接口，而服务实现是一个实现服务的类。
- en: 'Now to create some services and service implementations. Create a `service`
    package. We will add both services and service implementations in here. Create
    a `UserService` interface as with the following codes within the package:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要创建一些服务和服务的实现。创建一个`service`包。我们将在其中添加服务和服务的实现。在包中创建一个`UserService`接口，如下所示：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding `UserService` interface, we have defined functions that must
    be declared by classes that implement `UserService`. That''s it! `UserService` is
    ready to be implemented. Now to create an implementation of the service. Add a
    `UserServiceImpl` class to the services package. We are going to implement `UserService`
    and as such we need overriding functions for `attemptRegistration()`, `listUsers()`,
    `retrieveUserData()`, and `usernameExists()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`UserService`接口中，我们定义了必须由实现`UserService`的类声明的函数。就这样！`UserService`已经准备好实现。现在要创建服务的实现。在服务包中添加一个`UserServiceImpl`类。我们将实现`UserService`，因此我们需要为`attemptRegistration()`、`listUsers()`、`retrieveUserData()`和`usernameExists()`重写函数：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the primary constructor definition of `UserServiceImpl`, an instance of `UserRepository`
    was specified as a required argument. You don't need to worry about passing such
    an argument yourself. Spring recognizes that `UserServiceImpl` needs a `UserRepository`
    instance and provides the class with one via dependency injection. In addition
    to the functions implemented, we declared an `obscurePassword()` function that
    simply hashed passwords within a `User` entity with `XXX XXXX XXX`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UserServiceImpl`的主要构造函数定义中，指定了一个`UserRepository`实例作为必需的参数。你不需要担心自己传递这样的参数。Spring认识到`UserServiceImpl`需要一个`UserRepository`实例，并通过依赖注入为该类提供一个实例。除了实现的函数外，我们还声明了一个`obscurePassword()`函数，该函数只是使用`XXX
    XXXX XXX`在`User`实体中对密码进行散列。
- en: 'Still in the spirit of service and service implementation creation, let''s
    go ahead and add some for messages and conversations. Add a `MessageService` interface
    to the `service`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在创建服务和服务的实现的精神下，让我们继续添加一些用于消息和会话的。在`service`包中添加一个`MessageService`接口：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We added a single method signature for `sendMessage()` that must be overriden
    by `MessageServiceImpl`. The following is the message service implementation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`sendMessage()`添加了一个必须由`MessageServiceImpl`覆盖的方法签名。以下是对消息服务的实现：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding implementation of `sendMessage()` first checks whether the message
    content is empty. If not, then the function checks whether there exists an active
    conversation between the sender and the recipient. If there is one, it is retrieved
    and stored in `conversation`, otherwise a new `Conversation` is created between
    the two users and stored in `conversation`. The conversation is then saved and
    the message is created and saved.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前 `sendMessage()` 的实现首先检查消息内容是否为空。如果不为空，则函数检查发送者和接收者之间是否存在一个活跃的对话。如果存在，则检索并存储在
    `conversation` 中，否则在两个用户之间创建一个新的 `Conversation` 并存储在 `conversation` 中。然后保存对话，并创建并保存消息。
- en: '`ConversationService` and `ConversationServiceImpl` can now be implemented.
    Create a `ConversationService` interface in `services` and add the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以实现对 `ConversationService` 和 `ConversationServiceImpl` 的实现。在 `services` 包中创建一个
    `ConversationService` 接口，并添加以下代码：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We have added six function signatures for now. They are `createConversation()`,
    `conversationExists()`, `getConversation()` , `retrieveThread()`, `listUserConversations()`,
    and `nameSecondParty()`. Now we shall add `ConversationServiceImpl` to `services` and
    implement the first three methods `createConversation()`, `conversationExists()`
    and `getConversation()`. This implementation is shown in the following code snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们已经添加了六个函数签名。它们是 `createConversation()`、`conversationExists()`、`getConversation()`、`retrieveThread()`、`listUserConversations()`
    和 `nameSecondParty()`。现在我们将在 `services` 包中添加 `ConversationServiceImpl` 并实现前三个方法
    `createConversation()`、`conversationExists()` 和 `getConversation()`。以下代码片段展示了这种实现：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Having added the first three methods, go ahead and include the remaining three
    methods, `retrieveThread()`, `listUserConversations()`, and `nameSecondParty()`,
    below to `ConversationServiceImpl`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前三个方法之后，继续将剩余的三个方法 `retrieveThread()`、`listUserConversations()` 和 `nameSecondParty()`
    添加到 `ConversationServiceImpl` 中：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You might have noticed that we threw exceptions of different types several times
    within service implementation classes. As we have not yet created these exceptions,
    we will need to do so. In addition, we need to create an `ExceptionHandler` for
    each of these exceptions. These exception handlers will send appropriate error
    responses to clients in scenarios in which exceptions are thrown.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在服务实现类中多次抛出了不同类型的异常。由于我们尚未创建这些异常，我们需要这样做。此外，我们还需要为这些异常中的每一个创建一个 `ExceptionHandler`。这些异常处理器将在抛出异常的情况下向客户端发送适当的错误响应。
- en: 'Create an `exceptions` package and add an `AppExceptions.kt` file to it. Include
    the following code into the file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `exceptions` 包，并向其中添加一个 `AppExceptions.kt` 文件。将以下代码包含到该文件中：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each exception  extends `RuntimeException` as they occur during the server runtime.
    All exceptions also possess a `message` property. As the name implies, this is
    the exception message. Now that our exceptions have been added, we need to create
    controller advice classes. `ControllerAdvice` classes are used to handle errors
    that occur within a Spring application. They are created using the `@ControllerAdvice`
    annotation. In addition, a controller advice is a type of Spring component. Let's
    create a controller advice class to handle some of the preceding exceptions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些异常发生在服务器运行时，因此每个异常都扩展了 `RuntimeException`。所有异常也都有一个 `message` 属性。正如其名所示，这是异常消息。现在我们已经添加了这些异常，我们需要创建控制器建议类。`ControllerAdvice`
    类用于处理在 Spring 应用程序中发生的错误。它们使用 `@ControllerAdvice` 注解创建。此外，控制器建议是一种 Spring 组件。让我们创建一个控制器建议类来处理一些前面的异常。
- en: 'Looking at `UsernameUnavailableException`, `InvalidUserIdException`, and `UserStatusEmptyException`,
    we notice that these three exceptions are all pertaining to a user. As such, let''s
    name the controller advice that caters to all these exceptions `UserControllerAdvice`.
    Create a `components` package and add a the following `UserControllerAdvice` class
    to it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下异常：`UsernameUnavailableException`、`InvalidUserIdException` 和 `UserStatusEmptyException`，我们会发现这三个异常都与用户相关。因此，我们可以将处理所有这些异常的控制器建议命名为
    `UserControllerAdvice`。创建一个 `components` 包，并将以下 `UserControllerAdvice` 类添加到其中：
- en: '[PRE22]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've just defined functions to cater to each of the three exceptions that can
    occur and annotated each of the functions with an `@ExceptionHanlder()` annotation.
    `@ExceptionHanlder()` takes a class reference to the exception that is being handled
    by the function. Each function takes a single argument that is an instance of
    the exception thrown. In addition, all the defined functions return a `ResponseEntity<ErrorResponse>`
    instance. A response entity represents the entire HTTP response sent to the client.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了函数来处理可能发生的三个异常，并为每个函数添加了 `@ExceptionHanlder()` 注解。`@ExceptionHanlder()`
    接收一个类引用，该类引用是函数正在处理的异常。每个函数接收一个参数，该参数是抛出的异常实例。此外，所有定义的函数都返回一个 `ResponseEntity<ErrorResponse>`
    实例。响应实体表示发送给客户端的整个 HTTP 响应。
- en: '`ErrorResponse` has not yet been created. Create a `constants` package and
    add the following `ErrorResponse` class to it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorResponse` 类尚未创建。创建一个 `constants` 包，并将以下 `ErrorResponse` 类添加到其中：'
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`ErrorResponse` is a simple class with two properties: `errorCode` and `errorMessage`.
    Before we continue, go ahead and add the following `ResponseConstants` enum class
    to the `constants` package:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ErrorResponse` 是一个具有两个属性 `errorCode` 和 `errorMessage` 的简单类。在我们继续之前，请将以下 `ResponseConstants`
    枚举类添加到 `constants` 包中：'
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, let's create three more controller advice classes. These classes are `MessageControllerAdvice`,
    `ConversationControllerAdvice`, and `RestControllerAdvice`. `RestControllerAdvice` will
    define exception handlers for errors that can happen anywhere within the server
    over the course of runtime.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建另外三个控制器建议类。这些类是 `MessageControllerAdvice`、`ConversationControllerAdvice`
    和 `RestControllerAdvice`。`RestControllerAdvice` 将定义在服务器运行过程中可能发生的错误异常处理器。
- en: 'The following is the `MessageControllerAdvice` class:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `MessageControllerAdvice` 类：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, add the `ConversationControllerAdvice` class, which is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加 `ConversationControllerAdvice` 类，如下所示：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, add the `RestControllerAdvice` class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加 `RestControllerAdvice` 类：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have implemented our business logic and we are almost ready to facilitate
    HTTP request entries via REST endpoints into our API. Before we do that, we must
    secure our API.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了业务逻辑，我们几乎准备好通过 REST 端点将 HTTP 请求条目传递到我们的 API。在我们这样做之前，我们必须保护我们的 API。
- en: Restricting API access
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制 API 访问
- en: From a security standpoint, it is a huge taboo to permit just anyone to have
    access to RESTful API resources. We must devise a way to restrict access to our
    server to only registered and logged-in users. We will do this using **Spring
    Security** and **JSON Web Tokens** (**JWTs**).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，允许任何人访问 RESTful API 资源是一个巨大的禁忌。我们必须想出一个方法来限制对服务器的访问，只允许注册和登录的用户。我们将使用
    **Spring Security** 和 **JSON Web Tokens** (**JWTs**) 来做到这一点。
- en: Spring Security
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security
- en: Spring Security is a highly customizable access-control framework for Spring
    applications. It is the accepted standard for securing applications built with
    Spring. As it is selected to add the Security dependency at the start of this
    project's creation, we do not need to add the Spring Security dependency to `pom.xml`
    as it has already been added.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security 是一个高度可定制的访问控制框架，用于 Spring 应用程序。它是使用 Spring 构建的应用程序的接受标准。由于我们在创建项目之初就选择了添加安全依赖项，因此我们不需要将
    Spring Security 依赖项添加到 `pom.xml` 中，因为它已经添加了。
- en: JSON Web Tokens
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: According to the JWT website ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519)),
    *JSON Web Tokens are an open, industry standard method for representing claims
    securely between two parties*. JWT allows you to decode, verify, and generate
    JWT. JWTs can be used easily with Spring Boot to implement authentication in applications.
    The following sections will demonstrate how to use a JWT and Spring Security combination
    to secure the messenger backend.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 JWT 网站 ([https://tools.ietf.org/html/rfc7519](https://tools.ietf.org/html/rfc7519))，*JSON
    Web Tokens 是一种开放、行业标准的表示安全声明的方法，用于在双方之间进行安全通信*。JWT 允许您解码、验证和生成 JWT。JWT 可以轻松地与
    Spring Boot 结合使用，以在应用程序中实现身份验证。以下部分将演示如何使用 JWT 和 Spring Security 组合来保护消息后端。
- en: 'The first thing that must be done in order for you to get started with JWTs
    in a Spring application is add its dependency to the project `pom.xml` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Spring 应用程序中开始使用 JWT，您必须首先将其依赖项添加到项目的 `pom.xml` 文件中：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Upon including a new maven dependency in `pom.xml`, IntelliJ will ask you to
    import the new dependencies:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pom.xml` 中包含新的 Maven 依赖项后，IntelliJ 将提示您导入新的依赖项：
- en: '![](img/18791763-36e8-494a-88f0-2d207944906e.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/18791763-36e8-494a-88f0-2d207944906e.jpg)'
- en: Click on Import Changes once the prompt shows up, and the JWT dependency will
    be imported into the project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现提示时，点击导入更改，JWT 依赖项将被导入到项目中。
- en: Configuring web security
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置网络安全性
- en: 'The first thing we need to do is create a custom web security configuration.
    Create a `config` package in `com.example.messenger.api`. Add a `WebSecurityConfig`
    class to the package and input the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个自定义的网络安全性配置。在 `com.example.messenger.api` 中创建一个 `config` 包。向该包中添加一个
    `WebSecurityConfig` 类，并输入以下代码：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s `Filter` the /login requests:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们 `Filter` `/login` 请求：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s filter other requests to check the presence of JWT in header:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们过滤其他请求以检查头部中 JWT 的存在：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`WebSecurityConfig` is annotated with `@EnableWebSecurity`. This enables Spring
    Security''s web security support. In addition, `WebSecurityConfig` extends `WebSecurityConfigurerAdapter`
    and overrides some of its `configure()` methods to add some customization to the
    web security config.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebSecurityConfig` 使用 `@EnableWebSecurity` 注解。这启用了 Spring Security 的网络安全性支持。此外，`WebSecurityConfig`
    扩展了 `WebSecurityConfigurerAdapter` 并覆盖了一些其 `configure()` 方法以添加一些对网络安全性配置的定制。'
- en: The `configure(HttpSecurity)` method configures which URL paths are to be secured
    and which shouldn't be. In `WebSecurityConfig`, we permitted all `POST` requests
    to the `/users/registrations` and `/login` paths. These two endpoints don't need
    to be secured, as a user cannot be authenticated prior to login or his registration
    on the platform. In addition, we added filters for requests. Requests to `/login` 
    will be filtered by `JWTLoginFilter` (we have yet to implement this); all requests
    that are unauthenticated and unpermitted will be filtered by `JWTAuthenticationFilter` (we
    have yet to implement this, too).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure(HttpSecurity)` 方法配置了哪些 URL 路径需要被保护以及哪些不需要。在 `WebSecurityConfig`
    中，我们允许所有对 `/users/registrations` 和 `/login` 路径的 `POST` 请求。这两个端点不需要被保护，因为用户在登录或在其平台上注册之前无法进行身份验证。此外，我们还添加了对请求的过滤器。对
    `/login` 的请求将通过 `JWTLoginFilter`（我们尚未实现）进行过滤；所有未认证和未经授权的请求将通过 `JWTAuthenticationFilter`（我们尚未实现）进行过滤。'
- en: '`configure(AuthenticationManagerBuilder)` sets up the `UserDetailsService` and
    specifies a password encoder to be used.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure(AuthenticationManagerBuilder)` 设置 `UserDetailsService` 并指定要使用的密码编码器。'
- en: 'There are a number of classes that we made use of that we have not implemented
    yet. We will start by implementing `JWTLoginFilter` . Create a new package named
    `filters` and add the following `JWTLoginFilter` class:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一些尚未实现的类。我们将首先实现 `JWTLoginFilter`。创建一个新的包，命名为 `filters`，并向其中添加以下 `JWTLoginFilter`
    类：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`JWTLoginFilter` takes a string URL and an `AuthenticationManager` instance
    as arguments to its primary constructor. You can also see it extends `AbstractAuthenticationProcessingFilter`.
    This filter intercepts incoming HTTP requests to the server and attempts to authenticate
    them. `attemptAuthentication()`  performs the actual authentication process. It
    uses an `ObjectMapper()` instance to read the credentials present in the `via` HTTP
    request, after which `authenticationManager` is used to authenticate the request.
    `AccountCredentials` is another class that we have yet to implement. Create a
    new package, called `security`, and add an `AccountCredentials.kt` file to it:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTLoginFilter` 以字符串 URL 和 `AuthenticationManager` 实例作为其主构造函数的参数。您还可以看到它扩展了
    `AbstractAuthenticationProcessingFilter`。此过滤器拦截对服务器的传入 HTTP 请求并尝试对其进行认证。`attemptAuthentication()`
    执行实际的认证过程。它使用 `ObjectMapper()` 实例读取 `via` HTTP 请求中存在的凭证，之后使用 `authenticationManager`
    对请求进行认证。`AccountCredentials` 是我们尚未实现的另一个类。创建一个新的包，命名为 `security`，并向其中添加一个 `AccountCredentials.kt`
    文件：'
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have variables for a `username` and `password` because these are what will
    be used to authenticate the user.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `username` 和 `password` 的变量，因为这些是我们将用于用户认证的。
- en: 'The `SuccessfulAuthentication()` method is called upon successful authentication
    of a user. The only task done in the function is the addition of authentication
    tokens to the `Authorization` header of the HTTP response. The actual addition
    of this header is done by `TokenAuthenticationService.addAuthentication()`. Let''s
    add this service to our `services` package:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户成功认证时，会调用 `SuccessfulAuthentication()` 方法。该函数中唯一执行的任务是将认证令牌添加到 HTTP 响应的 `Authorization`
    头部。实际添加此头部是由 `TokenAuthenticationService.addAuthentication()` 完成的。让我们将此服务添加到我们的
    `services` 包中：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s parse the token:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析令牌：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As the names imply, `addAuthentication()` adds an authentication token to the
    `Authorization` header of the HTTP response and `getAuthentication()` authenticates
    the user.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，`addAuthentication()`向HTTP响应的`Authorization`头中添加一个认证令牌，而`getAuthentication()`则验证用户。
- en: 'Now let''s add `JWTAuthenticationFilter` to the `filters` package. Add the
    following `JWTAuthenticationFilter` class to the `filters` package:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`JWTAuthenticationFilter`添加到`filters`包中。将以下`JWTAuthenticationFilter`类添加到`filters`包中：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `doFilter()` function of the `JWTAuthenticationFilter` is called by the
    container each time a request/response pair is passed through the filter chain
    as a result of a client request for a resource. The `FilterChain` instance passed
    in to `doFilter()` allows the filter to pass the request and response on to the
    next entity in the filter chain.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`JWTAuthenticationFilter`的`doFilter()`函数在容器每次将请求/响应对通过过滤器链传递给客户端请求的资源时被调用。传递给`doFilter()`的`FilterChain`实例允许过滤器将请求和响应传递给过滤器链中的下一个实体。'
- en: 'Finally, we need to implement the `AppUserDetailsService` class as usual, we
    will put this in the `services` package of the project:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要像往常一样实现`AppUserDetailsService`类，我们将把这个类放在项目的`services`包中：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`loadUsername(String)` attempts to load the `UserDetails` of a user matching
    the `username` passed to the function. If the user matching the provided username
    cannot be found, a `UsernameNotFoundException` is thrown.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadUsername(String)`尝试加载与函数传递的`username`匹配的用户的`UserDetails`。如果找不到与提供的用户名匹配的用户，将抛出`UsernameNotFoundException`。'
- en: And, just like that, we have successfully configured Spring Security. We are
    now ready to expose some API functionality via RESTful endpoints with the use
    of controllers.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们已经成功配置了Spring Security。我们现在可以使用控制器通过RESTful端点公开一些API功能。
- en: Accessing server resources via RESTful endpoints
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过RESTful端点访问服务器资源
- en: So far, we have created models, components, services, and service implementations,
    as well as integrated Spring Security into the messenger application. One thing
    we have not done is actually created any means by which external clients can communicate
    with the messenger API. We are going to do this by creating controller classes
    that handles requests from different HTTP request paths. As always, the first
    thing we must do is create a package to contain the controllers we are about to
    create. Create a `controllers` package now.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了模型、组件、服务以及服务实现，并将Spring Security集成到信使应用程序中。我们还没有做的事情是实际上创建任何外部客户端可以与信使API通信的手段。我们将通过创建处理不同HTTP请求路径的控制器类来实现这一点。一如既往，我们必须做的第一件事是创建一个包来包含我们即将创建的控制器。现在创建一个`controllers`包。
- en: 'The first controller we will implement is the `UserController`. This controller
    maps HTTP requests pertaining to a user resource to in-class actions that handle
    and respond to the HTTP request. First and foremost, we need an endpoint to facilitate
    the registration of new users. We will call the action that handles such a registration
    request `create`. The following is the `UserController` code with the `create`
    action:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一个控制器是`UserController`。这个控制器将用户资源的HTTP请求映射到类内的操作，这些操作处理并响应HTTP请求。首先，我们需要一个端点来方便新用户的注册。我们将处理此类注册请求的操作称为`create`。以下带有`create`操作的`UserController`代码：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The controller class is annotated with `@RestController` and `@RequestMapping`.
    The `@RestController` annotation specifies that a class is a REST controller.
    `@RequestMapping`, as it is used with the `UserController` class earlier, maps
    all requests with paths starting with `/users` to `UserController`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器类被注解为`@RestController`和`@RequestMapping`。`@RestController`注解指定了一个类是一个REST控制器。`@RequestMapping`，正如之前与`UserController`类一起使用的那样，将所有以`/users`开头的请求映射到`UserController`。
- en: 'The `create` function is annotated with `@PostMapping` and `@RequestMapping("/registrations")`.
    The combination of these two annotations maps all POST requests with the `/users/registrations` path
    to the create function. A `User` instance annotated with `@Validated` and `@RequestBody`
    is passed to `create`.  `@RequestBody` binds the JSON values sent in the body
    of the POST request to `userDetails`. `@Validated` ensures that the JSON parameters
    are validated. Now that we have an endpoint up and running, let''s test it out.
    Start the application and navigate to your terminal window. Send a request to
    the messenger API using CURL, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`函数被`@PostMapping`和`@RequestMapping("/registrations")`注解。这两个注解的组合将所有带有`/users/registrations`路径的POST请求映射到创建函数。一个被`@Validated`和`@RequestBody`注解的`User`实例传递给`create`。`@RequestBody`将POST请求体中发送的JSON值绑定到`userDetails`。`@Validated`确保JSON参数得到验证。现在我们有一个正在运行的端点，让我们测试一下。启动应用程序并导航到您的终端窗口。使用以下方式向信使API发送请求：'
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The server will create the user and send you a response similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将创建用户并发送一个类似于以下内容的响应：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's all fine and good, but we can see there are a number of unwanted values
    in the HTTP response, such as the `password` and `accountStatus` response parameters.
    In addition to this, we'd like for `createdAt` to contain a human-readable date.
    We are going to do all these things using an assembler and a value object.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但我们可以看到HTTP响应中有许多不希望出现的值，例如`password`和`accountStatus`响应参数。此外，我们希望`createdAt`包含一个可读的日期。我们将使用汇编器和值对象来完成所有这些事情。
- en: 'First, let''s make the value object. The value object we are creating is going
    to contain the data of the user that we want to be sent to the client in its appropriate
    form and nothing more. Create a `helpers.objects` package with a `ValueObjects.kt`
    file in it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建值对象。我们正在创建的值对象将包含我们想要以适当形式发送给客户端的用户数据，没有更多。创建一个包含`ValueObjects.kt`文件的`helpers.objects`包：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, `UserVO` is a data class that models the information we want
    to be sent to the user and nothing more. While we are at it, let''s add value
    objects for some other responses we will cater for later, to avoid coming back
    to this file:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`UserVO`是一个数据类，它模拟了我们想要发送给用户的信息，没有更多。在此期间，让我们添加一些其他响应的价值对象，以避免返回此文件：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now that we have the required value objects set, let''s create an assembler
    for `UserVO`. An assembler is simply a component that `assembles` a required object
    value. We will call the assembler we are creating `UserAssembler`. As it''s a
    component, it belongs in the `components` package:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所需的价值对象，让我们为`UserVO`创建一个汇编器。汇编器简单来说就是一个`assembles`所需对象值的组件。我们将我们创建的汇编器命名为`UserAssembler`。由于它是一个组件，它属于`components`包：
- en: '[PRE43]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The assembler has a single `toUserVO()` function that takes a `User` as its
    argument and returns a corresponding `UserVO`.  `toUserListVO()` takes a list
    of `User` instances and returns a corresponding `UserListVO`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该汇编器有一个单一的`toUserVO()`函数，它接受一个`User`作为其参数并返回相应的`UserVO`。`toUserListVO()`接受一个`User`实例列表并返回相应的`UserListVO`。
- en: 'Now let''s edit the create endpoint to make use of `UserAssembler` and `UserVO`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编辑创建端点以使用`UserAssembler`和`UserVO`：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Restart the server and send a new request to register a `User`. We will get
    a response that is much more appropriate from the API:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器并发送一个新的请求来注册一个`User`。我们将从API获得一个更加合适的响应：
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s wrap up our endpoint creation process by creating all the necessary
    endpoints for the messenger Android application. Firstly, let''s add endpoints
    to show the details of a `User`, list all users, get the details of the current
    user, and update the status of a `User` to `UserController`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为信使Android应用程序创建所有必要的端点来总结我们的端点创建过程。首先，让我们向`UserController`添加显示用户详情、列出所有用户、获取当前用户详情以及更新用户`User`状态到`UserController`的端点：
- en: '[PRE46]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now we are going to create controllers to handle message resources and conversation
    resources. These will be `MessageController` and `ConversationController`, respectively.
    Before creating the controllers, let''s assemblers that will be used to assemble
    value objects from JPA entities. The following is the `MessageAssembler`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建控制器来处理消息资源和会话资源。这些将是`MessageController`和`ConversationController`，分别。在创建控制器之前，让我们创建用于从JPA实体组装值对象的汇编器。以下是`MessageAssembler`：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And now, let''s create the `ConversationAssembler`, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`ConversationAssembler`，如下所示：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'All is in place for `MessageController` and `ConversationController`. For our
    simple messenger app, we only need to have a message creation action for `MessageController`.
    The following is `MessageController` with the message creation action, `create`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageController` 和 `ConversationController` 的所有准备工作都已就绪。对于我们的简单消息传递应用，我们只需要为
    `MessageController` 提供一个消息创建操作。以下带有消息创建操作 `create` 的 `MessageController`：'
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Lastly, we must create `ConversationController`. We need only two endpoints:
    one to list all the active conversations of a user and the other to get the messages
    existing in a conversation thread. These endpoints will be catered to by the `list()`
    and `show()` actions, respectively. The following is the `ConversationController`
    class:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须创建 `ConversationController`。我们只需要两个端点：一个用于列出用户的全部活跃对话，另一个用于获取对话线程中存在的消息。这些端点将由
    `list()` 和 `show()` 操作分别处理。以下是 `ConversationController` 类：
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'All is looking great! There''s only one tiny problem. Remember, a user has
    an account status and it is possible for the account to be deactivated, right?
    In such a scenario, we, as API creators, will not want a deactivated user to be
    able to use our platform. As such, we have to come up with a way to prevent such
    a user from interacting with our API. There are a number of ways this can be done,
    but for this example we are going to use an interceptor. An interceptor intercepts
    an HTTP request and performs one or more operations on it before it continues
    down the request chain. Similar to assemblers, an interceptor is a component.
    We will call our interceptor that checks the validity of an account `AccountValidityInterceptor`.
    The following is the interceptor class (remember, it belongs in the `components`
    package):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很完美！只有一个小问题。记住，用户有一个账户状态，账户可能被停用，对吧？在这种情况下，作为 API 创建者，我们不想让停用的用户能够使用我们的平台。因此，我们必须想出一个方法来防止此类用户与我们的
    API 交互。有几种方法可以实现这一点，但在这个例子中，我们将使用拦截器。拦截器拦截 HTTP 请求，并在它继续沿着请求链之前对其进行一个或多个操作。类似于装配器，拦截器是一个组件。我们将称我们的检查账户有效性的拦截器为
    `AccountValidityInterceptor`。以下是该拦截器类（记住，它属于 `components` 包）：
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `AccountValidityInterceptor` class overrides the `preHandle()` function
    of its super class. This function will be called to carry out some operations
    prior to the routing of the request to its necessary controller action. After
    the creation of an interceptor, the interceptor must be registered with the Spring
    application. This configuration can be done using a `WebMvcConfigurer`. Add an
    `AppConfig` file to the `config` package in the project. Input the following code
    within the file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`AccountValidityInterceptor` 类重写了其超类的 `preHandle()` 函数。这个函数将在请求被路由到其必要的控制器操作之前被调用，以执行一些操作。创建拦截器后，拦截器必须注册到
    Spring 应用程序中。此配置可以使用 `WebMvcConfigurer` 来完成。将 `AppConfig` 文件添加到项目的 `config` 包中。在文件中输入以下代码：'
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`AppConfig` is a subclass of `WebMvcConfigurer` and overrides the `addInterceptor(InterceptorRegistry)`
    function in its superclass. `accountValidityInterceptor` is added to the interceptor
    registry with `registry.addInterceptor()`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppConfig` 是 `WebMvcConfigurer` 的子类，并重写了其超类中的 `addInterceptor(InterceptorRegistry)`
    函数。使用 `registry.addInterceptor()` 将 `accountValidityInterceptor` 添加到拦截器注册表中。'
- en: We are now done with all the code required to provide web resources to the messenger
    Android application. We must now deploy this code to a remote server.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了为消息传递 Android 应用提供网络资源所需的所有代码。现在我们必须将此代码部署到远程服务器。
- en: Deploying the messenger API to AWS
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 上部署消息传递 API
- en: Deploying a Spring Boot app to **Amazon Web Services** (**AWS**) is a straightforward
    and enjoyable process. The deployment procedure can be done well within 10 minutes.
    In this section, you will learn how to deploy applications based on Spring to
    AWS. Before application deployment, we must set up a PostgreSQL database on AWS
    that the application will connect to.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Spring Boot 应用部署到 **Amazon Web Services**（**AWS**）是一个简单且愉快的过程。部署过程可以在 10 分钟内完成。在本节中，你将学习如何将基于
    Spring 的应用程序部署到 AWS。在应用部署之前，我们必须在 AWS 上设置一个 PostgreSQL 数据库，该数据库将是应用程序连接到的数据库。
- en: Setting up PostgreSQL on AWS
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 上设置 PostgreSQL
- en: 'The first thing you must do is create an AWS account. Go ahead and create one
    now by following this link: [https://portal.aws.amazon.com/billing/signup#/start](https://portal.aws.amazon.com/billing/signup#/start)
    . Once you have signed up, login into the AWS console and head over to the Amazon
    **Relational Database Service** (**RDS**) (from the navigation bar, click Services
    | Database | RDS). Once taken to the RDS dashboard, click on Get Started Now:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须做的第一件事是创建一个AWS账户。现在请通过以下链接创建一个账户：[https://portal.aws.amazon.com/billing/signup#/start](https://portal.aws.amazon.com/billing/signup#/start)
    。注册后，登录AWS控制台，并转到Amazon **关系数据库服务**（**RDS**）（从导航栏，点击服务 | 数据库 | RDS）。一旦进入RDS仪表板，点击立即开始：
- en: '![](img/07c9cbae-a86f-4647-9688-8659918739c3.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/07c9cbae-a86f-4647-9688-8659918739c3.jpg)'
- en: 'You will be navigated to the Launch DB instance web page. Here you will need
    to make some selections pertaining to the DB setup. Select PostgreSQL as the DB
    engine to be used:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被导航到启动DB实例的网页。在这里，您需要做出一些与DB设置相关的选择。选择作为DB引擎使用的PostgreSQL：
- en: '![](img/f1b8c82a-b79b-468c-bcdc-1451777734c9.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f1b8c82a-b79b-468c-bcdc-1451777734c9.jpg)'
- en: Ensure to check the Only enable options eligible for RDS Free Usage Tier checkbox.
    Navigate to the next set of setup procedures by clicking Next. On the next page,
    leave the instance specifications as is and input the necessary DB settings. Input
    a DB instance name, master username, and master password. We used `messenger-api`
    as our DB instance name, you may choose to use another name of your choice. Regardless
    your choice, ensure that you take note of all inputs you make. Once you are done
    entering the necessary, continue to the next screen.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 确保勾选“仅启用适用于RDS免费使用层的选项”复选框。通过点击下一步，导航到下一组设置步骤。在下一页，保留实例规格不变，并输入必要的DB设置。输入DB实例名称、主用户名和主密码。我们使用了`messenger-api`作为我们的DB实例名称，您也可以选择使用您喜欢的另一个名称。无论您的选择如何，请确保记录下您所做的所有输入。完成输入后，继续到下一屏幕。
- en: 'You will be navigated to the Configure advanced settings screen. In the Network
    & Security section, ensure to enable public accessibility and select the Create
    new VPC security group option under VPC Security Groups.  Scroll down to the Database
    options section of the screen and enter a DB name. Once again, we used `MessengerDB`
    as the DB name. Leave the remaining options as they are and click Launch DB instance at
    the end of the web page:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被导航到配置高级设置屏幕。在网络与安全部分，确保启用公共可访问性，并在VPC安全组下选择创建新的VPC安全组选项。滚动到屏幕的数据库选项部分，并输入一个DB名称。再次，我们使用了`MessengerDB`作为DB名称。保留剩余选项不变，并在网页底部点击启动DB实例：
- en: '![](img/7a5dbaed-b509-40a6-924b-1b3a19ed767b.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a5dbaed-b509-40a6-924b-1b3a19ed767b.jpg)'
- en: Your DB instance will be created by AWS. The creation process may take up to
    10 minutes so it may be a good idea to take a coffee break at this point.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您的DB实例将由AWS创建。创建过程可能需要长达10分钟，因此在这个时候喝杯咖啡可能是个好主意。
- en: 'After waiting a little while, click View DB instance details. This will take
    you to a page where you can see detailed information on your just deployed DB
    instance. Scroll to the Connect section of the page to view the connection details
    of the DB instance:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 稍等片刻后，点击查看DB实例详情。这将带您到一个页面，您可以查看刚刚部署的DB实例的详细信息。滚动到页面的连接部分，以查看DB实例的连接详情：
- en: '![](img/55fcbcde-cc98-414f-b8f0-8e26e151101d.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/55fcbcde-cc98-414f-b8f0-8e26e151101d.jpg)'
- en: 'We need these details to successfully connect to the `MessengerDB` on this
    PostgreSQL DB instance. To enable `messenger-api` to connect to `MessengerDB`,
    you must edit the `spring.datasource.url`, `spring.datasource.username`, and `spring.datasource.password` properties
    in the `application.properties` file. After doing this, `application.properties`
    should look similar to the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些详细信息才能成功连接到这个PostgreSQL DB实例上的`MessengerDB`。为了使`messenger-api`能够连接到`MessengerDB`，您必须编辑`application.properties`文件中的`spring.datasource.url`、`spring.datasource.username`和`spring.datasource.password`属性。完成此操作后，`application.properties`应类似于以下内容：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The final thing we will do is deploy the messenger API to an Amazon EC2 instance.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要做的最后一件事是将messenger API部署到Amazon EC2实例。
- en: Deploying the messenger API to Amazon Elastic Beanstalk
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将messenger API部署到Amazon Elastic Beanstalk
- en: 'Deploying an application to AWS is simple as well. Navigate to the AWS console
    and select Services | Compute | Elastic Beanstalk**. **Once in the Elastic Beanstalk
    Management Console, click on Create New Application. Once taken to the Create
    Application page, you will be asked to provide a name and description for the
    new application to be created. Name the app `messenger-api` and proceed to the
    next screen. You will be taken to a screen in which you are prompted to create
    a new environment:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到 AWS 也很简单。导航到 AWS 控制台，选择“服务”|“计算”| Elastic Beanstalk**。**进入 Elastic
    Beanstalk 管理控制台后，点击“创建新应用程序”。一旦进入“创建应用程序”页面，你将被要求为新创建的应用程序提供名称和描述。将应用命名为 `messenger-api`
    并进入下一屏幕。你将进入一个屏幕，其中会提示你创建一个新的环境：
- en: '![](img/1729dc3e-dd05-4dd6-9714-0cb63e172c40.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1729dc3e-dd05-4dd6-9714-0cb63e172c40.jpg)'
- en: 'Create a web server environment on this screen. Next up, you will need to configure
    the environment type. Select the Tomcat predefined configuration and change the
    environment type to Single instance:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上创建一个网络服务器环境。接下来，你需要配置环境类型。选择 Tomcat 预定义配置，并将环境类型更改为单实例：
- en: '![](img/b8c7749c-2754-4aaf-8ba5-20d7883ee28f.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8c7749c-2754-4aaf-8ba5-20d7883ee28f.jpg)'
- en: 'Continue to the next screen when you are ready. On the next screen, you will
    need to select a source for your application. Choose Upload your own:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，继续到下一屏幕。在下一屏幕中，你需要选择应用程序的源。选择“上传自己的”：
- en: '![](img/5656426d-6bf5-4700-9f15-7dd5ec47190c.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5656426d-6bf5-4700-9f15-7dd5ec47190c.jpg)'
- en: 'Now we need to create a suitable project jar to be uploaded. We can package
    the messenger API into a jar with the help of Maven:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个适合上传的项目 jar。我们可以使用 Maven 将 messenger API 打包成一个 jar：
- en: '![](img/3186ca6c-7136-4038-a045-1d2fb3a795f5.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3186ca6c-7136-4038-a045-1d2fb3a795f5.jpg)'
- en: Click the Maven Projects button to the right of your project IDE screen and
    select messenger-api | Lifecycle | package. A project jar will be packaged and
    stored in the target directory of the project.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 点击项目 IDE 屏幕右侧的 Maven Projects 按钮，选择 messenger-api | 生命周期 | package。项目 jar 将被打包并存储在项目的目标目录中。
- en: Now go back to AWS and choose this jar file as the source file to be uploaded.
    Leave other properties as they are and click Next.  You may have to wait for a
    few minutes while the packaged jar is uploaded. Once the upload is done, you will
    be taken to a new screen where your environment information is presented to you.
    Proceed through the next few screens by clicking Next until you are presented
    with a Configuration Details screen. Change the instance type to `t2.micro`.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 AWS 并选择这个 jar 文件作为要上传的源文件。保留其他属性不变，然后点击“下一步”。在打包的 jar 文件上传过程中，你可能需要等待几分钟。上传完成后，你将被带到一个新的屏幕，其中将展示你的环境信息。通过点击“下一步”继续浏览接下来的几页，直到你看到“配置详情”屏幕。将实例类型更改为
    `t2.micro`。
- en: 'Proceed through the next screens until you reach the Review Information section.
    Scroll through this page until you reach the Environment Info section:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 继续浏览下一屏幕，直到到达“审查信息”部分。滚动到页面底部，直到到达“环境信息”部分：
- en: '![](img/bf72acae-808a-46c9-89a5-5f403f33e0d9.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf72acae-808a-46c9-89a5-5f403f33e0d9.jpg)'
- en: Your environment URL will differ. Take note of this information as you will
    need it later on. Scroll to the bottom of the web page and click Launch. Elastic
    Beanstalk will launch your new environment.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你的环境 URL 将不同。注意此信息，因为你稍后需要用到它。滚动到网页底部并点击“启动”。Elastic Beanstalk 将启动你的新环境。
- en: Once the launch finishes, you are good to go. You have successfully deployed
    the `messenger-api` to AWS.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动完成，你就可以开始了。你已经成功将 `messenger-api` 部署到 AWS。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored how to utilize Kotlin to build a Spring Boot REST
    application programming interface. In the process of doing so, we learned the
    basics of designing systems. We expressed the behavior of the messenger API system
    with a state diagram, and learned how to properly interpret the information represented
    in a state diagram. We went one step further by creating an E-R diagram to give
    a detailed diagrammatic representation of system entities and their relationships.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何利用 Kotlin 构建 Spring Boot REST 应用程序编程接口。在这个过程中，我们学习了设计系统的基础知识。我们使用状态图来表示
    messenger API 系统的行为，并学习了如何正确解释状态图中表示的信息。我们进一步通过创建 E-R 图来详细表示系统实体及其关系。
- en: In addition, we learned how to set up PostgreSQL on a local machine and create
    a new PostgreSQL database. We also explored how to build a microservice with Spring
    Boot 2.0, connect the microservice to a database, and interact with data existing
    in a database with Spring Data.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们学习了如何在本地机器上设置 PostgreSQL 并创建一个新的 PostgreSQL 数据库。我们还探讨了如何使用 Spring Boot
    2.0 构建微服务，将微服务连接到数据库，并使用 Spring Data 与数据库中现有的数据进行交互。
- en: Besides all this, we learned how to properly secure a RESTful Spring Boot web
    application with Spring Security and **JSON Web Tokens** (**JWTs**). We created
    custom Spring Security configurations to facilitate user authentication with the
    help of JWTs and created custom filters for the authentication process. Lastly,
    we learned how to deploy a Spring Boot application to AWS.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还学习了如何使用 Spring Security 和 **JSON Web Tokens**（**JWTs**）正确地保护 RESTful
    Spring Boot 网络应用。我们创建了自定义的 Spring Security 配置，以帮助使用 JWTs 进行用户认证，并创建了自定义过滤器以简化认证过程。最后，我们学习了如何将
    Spring Boot 应用部署到 AWS。
- en: In the next chapter, you will explore Kotlin further in the Android domain by
    building the Android messenger application.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将通过构建 Android 消息应用来进一步探索 Kotlin 在 Android 领域的应用。
