<html><head></head><body>
        

                            
                    <h1 class="header-title">Onboarding and Registration</h1>
                
            
            
                
<p>In this chapter, we will focus on the onboarding and registration part of your app. It starts with the people that have downloaded the app from the Play Store or App Store. That is an important conversion already. Now they need to be converted into regular users of the app. That is not as easy as it sounds. Studies show that on average 20% of apps are used only once. There are many competing apps in Google Play Store or the App Store. A perfect onboarding strategy for your app is therefore a must have and it could heavily contribute to a good conversion. The first impression your users get of your app should be a good one. To make the conversion as smooth as possible, it is important to show what is in it for them. You should ask yourself why they should have to continue to use the app. From the very start, you have to help them to understand the added value of your app.</p>
<p>There are many reasons why we want a user to sign-up. One of them is that a known user is more valuable than an anonymous one, but registration may be a barrier. This is the case, in particular, when users need to sign-up right away on one of the first screens of the app they see. Since they have no clue yet what the app is all about, you could already lose a part of your audience there. The more you ask, the more difficult the process will be. This is something you can avoid by using various techniques. In this chapter, we will see how to lower the barrier for the onboarding process and how a social sign-in process can contribute to it. Another thing we will look at is sign-up and verification through SMS.</p>
<p>To demonstrate this and other functionalities, we will create an app that uses the SDKs of Fabric and Firebase. We also will learn what we could do to improve app awareness and how a continuous onboarding flow could help you to get the best of both worlds. Such a flow will lower the barrier and it also will result in a rich user profile, as we will see later in this chapter.</p>
<p>In short, in this chapter, we will cover the following topics:</p>
<ul>
<li>See what user onboarding is all about and how we can improve conversions by lowering the barrier</li>
<li>Learn about social sign-in using Facebook or Twitter</li>
<li>See what the alternatives are, such as phone number sign-up, similar to what WhatsApp is doing</li>
<li>Find out how we can get the best of both worlds (a low barrier and rich data) using continuous onboarding</li>
<li>Investigate an app that demonstrates onboarding, including late onboarding</li>
<li>Learn how sharing and friend finding can help to improve app awareness and help in the onboarding process</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">What is user onboarding all about?</h1>
                
            
            
                
<p>Onboarding begins where a potential user, who has just downloaded your app, starts your app for the first time. You will have to convince that user and make sure that he instantly will notice the app's benefits. You want to convert your potential user into an engaged and active user, and this process starts with the first view that your app displays. To accomplish this, the first impression of your app should be interesting from a visual perspective and it should explain why the user should use this app. One of the ways of doing this is to create an introduction view with one or multiple slides. Remember that on a mobile device there is limited space, so you need to keep it short and simple. It should clearly explain the why and the what of the app. How things exactly work is something for later.</p>
<p>Show your users the benefits (the why) of your app before talking about its features (the what).</p>
<p>Show a maximum of three or four benefits. For example, they could explain how the user can integrate the app into his life and what values are provided by the app. Present one benefit at a time using a page slider or other technique. Be clear in your communication and try not to confuse the user. Use a consistent style, vocabulary, and approach to explain concepts. At a first view, the onboarding flow may look pretty obvious, but it apparently is not. Many apps, even the well-known ones, require you to sign-up on the first page with little to no explanation what the app is about. That may work well for the Facebook app with which almost everybody is familiar. It probably is not going to work for your app.</p>
<p>A typical flow goes like this: After the user has downloaded an app, he sees what it is about in a short introduction and then he is required to sign-up. At that time, it is often not clear why one should enter his username, type in a password, confirm it, and enter a couple of required fields. In this phase, a number of potential users will be lost:</p>
<div><img class=" image-border" height="64" src="img/61897122-b1d9-4fe2-9739-cce9b440edfd.png" width="541"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Why does it matter?</h1>
                
            
            
                
<p>A great introduction story should point out what the core values of your app are and what is in it for the user. Onboarding matters because it has everything to do with successful conversion. With every step you will lose customers, which is something that cannot completely be avoided, but the number of losses can be limited if you have a great onboarding flow for your app. As an example, let's consider a scenario in which each day a 100 users download your app, of which 60 sign-up and the other 40 decide to do this later or maybe never. Of these 60 users, only 30 are still using the app the next month. Of these 30 users, only 15 invite a friend, share the content of the app, or make an in-app purchase. That is still a very optimistic story.</p>
<p>At this last point, we could consider to see the user as a customer, as he brings us revenue in some way (money or awareness). However, in the conversion from potential user to customer, we have lost 85 people. There must be some way to increase the conversion. To do so, we have to make some smart moves and we need to gather feedback on the process.</p>
<p>Onboarding is about the conversion, which is summarized as follows:</p>
<ul>
<li>From someone that becomes aware of the app in the App Store or Google Play Store to a potential user by downloading the app</li>
<li>From a potential user that has downloaded the app to an actual user by signing up</li>
<li>From a user that has signed up to a user that is regularly using the app</li>
<li>From a regular user to an ambassador that is promoting the app by sharing it or by inviting a friend to it</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Pirate metrics (AARRR)</h1>
                
            
            
                
<p>We can make improvements only if we have insight into the optimization process. If we want to learn from the process, we need to measure it. The conversion is something that we are going to measure in another chapter. There we will take a closer look at actionable metrics that we can apply to mobile app development.</p>
<p>These so-called pirate metrics (AARRR, apparently that is what pirates say) perfectly describe why the onboarding flow is so important and what each phase represents in the conversion funnel. In short it goes like this:</p>
<ul>
<li>A for <strong>Acquisition</strong> or <strong>Awareness</strong><strong>,</strong> so they find your app in the store and download it.</li>
<li>A for <strong>Activation</strong>, when users sign-up.</li>
<li>R for <strong>Retention</strong>, meaning that a user is using the app on a regular basis. How many of the users that have downloaded the app are still doing so 1 week, 1 month, or 1 year later?</li>
<li>R for <strong>Revenue</strong>, as people make in-app purchases or other ways of monetization that we will review in another chapter.</li>
<li>R for <strong>Referral</strong>, where users inform other users about your app by sharing content or by inviting friends. Can your app go viral via word of mouth or sharing?</li>
</ul>
<div><img class=" image-border" height="64" src="img/1c07d6b7-f9d4-4dc7-959e-0bc73c6a67a9.png" width="560"/></div>
<p>Actionable metrics could help you to identify the friction points in the onboarding process. You will read more about this in <a href="a62b3753-12c5-4170-808a-e0e1446e6b97.xhtml" rel="noopener noreferrer" target="_blank">Chapter 13</a>, <em>Play Store and App Store Hacks</em> (Split testing) and <a href="d9145149-0f4e-47b6-bc9d-ff46e5e63304.xhtml" rel="noopener noreferrer" target="_blank">Chapter 15</a>, <em>Growing Traction and Improving Retention</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Higher conversion</h1>
                
            
            
                
<p>In general mobile apps do not focus very much on the onboarding flow. At least, that is the impression you could get if you review many of the apps in the App Store. You can make a difference for your app. If your onboarding story is more appealing and if the barrier for signing up is lower, your conversion from acquisition to activation will be better. If, in addition, you show your user how the app works and he becomes confident in the way things work, then you will increase your users retention rate. He will keep using your app on a frequent basis.</p>
<p>To get a head start, we need to think of a way to lower the barrier for the user. There are multiple known onboarding patterns that you can choose from and there is no reason why you cannot combine them. Some of these patterns are as follows:</p>
<ul>
<li>Introduction</li>
<li>Tutorial (or tour)</li>
<li>Joy ride</li>
<li>Social sign-up</li>
<li>Continuous onboarding</li>
</ul>
<p>The <strong>introduction</strong> approach shows a couple of slides and often requires the user to sign-up, but some apps choose to show the content of the app right away. A tutorial or tour shows the real app, pointing out some example cases.</p>
<p>A <strong>joy ride</strong> approach is a little bit different as it lets the user use the app right away and highlights features, from time to time, that are new to the user. It is a great way of showing what the app is all about. But be careful. If your app is complex, this option may prove to be a little bit overwhelming for the user.</p>
<p>A <strong>social sign-up</strong> allows the user to perform a quick sign-up using his Twitter or Facebook account, for example. This may be required in order for the user to be able to continue using the app, but it will lower the barrier if you first show what the app is about and only ask to sign-up when needed to proceed.</p>
<p>Finally there is a <strong>continuous onboarding</strong> concept, which can be very powerful because it comes with benefits such as lowering the barrier and obtaining rich user profiles, by encouraging the user at a later stage to complete his profile.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to lower the barrier?</h1>
                
            
            
                
<p>Probably the best onboarding flow does not require a sign-up or login at all. Is it really needed to do so before your app can be used? On the other hand, it is also true that a known user is more valuable than an anonymous one. Known users can be converted into customers, which will result in a profitable app. An unknown user is nothing but a visitor. We have not much data available about such visitor and conversion probably will be tough:</p>
<div><img class=" image-border" height="46" src="img/a128af4b-3889-4f53-bebb-6f309352ac32.png" width="272"/></div>
<p>To lower the barrier, you better make the sign-up process as smooth as possible. I have seen apps that require the user to fill in multiple fields on multiple pages at the registration process. That is not a fun thing to do on a mobile device and we can be sure the conversion loss will be huge. A typical old school onboarding and registration flow goes like this:</p>
<div><img class=" image-border" src="img/d59714af-1085-4804-b030-c242299a0850.png"/></div>
<p>We can do better than that. So create a great and exciting introduction story and make sure the user can immediately see the app core values. A very clear call to action (think of a highlighted button with an explanation text) and a simplified sign-up form can help you with this. Describe the benefits that the user will have once signed up, or use gamification elements such as digital incentives to persuade the user.</p>
<p>A social sign-in option is a great solution to increase conversion and still get to know the user. It requires fewer steps, so the user is more likely to sign-up if the only thing he needs to do is to click on a Twitter or Facebook sign-up button.</p>
<p>To see some onboarding case studies, you should check <a href="http://www.useronboard.com">http://www.useronboard.com</a>. It has many onboarding flows of various well-known apps, including comments and suggestions for improvement. You can find onboarding flows for WhatsApp, Yo, Twitter, Foursquare, Snapchat, and many other apps here.<br/>
<br/>
You probably also want to visit <a href="http://uxarchive.com">http://uxarchive.com</a> to see more examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Single sign on using a social network like Twitter or Facebook</h1>
                
            
            
                
<p>A social sign-up has multiple benefits, not just for the user but also for developers. Avoid a lengthy registration process with many fields. The likeliness that the user will sign-up increases and, with the appropriate permissions, you instantly access a range of information on that user, for example, an avatar and a name of the user, which is great for personalization options.</p>
<p>Offering a social login could be responsible for 50% more sign-ups compared to a form-based sign-up. Other information could be available as well, such as a contact list that you can use to invite friends to the app later. Depending on the nature of your app, you can allow your user to sign in with Twitter, Facebook, Pinterest, LinkedIn, or any other trusted social network. It may also depend on the nature of your user if your app is offering access to a platform (multi-sided market). For example, for an e-learning solution, there is a LinkedIn sign-up feature for teachers and professionals, but a Facebook sign-up flow for students:</p>
<div><img class=" image-border" height="87" src="img/547b72fc-a70e-47fd-82c2-abc73e263c5f.png" width="743"/></div>
<p>The benefits of using a social login are as follows:</p>
<ul>
<li>Faster registration, thus higher conversion rates</li>
<li>Instantly validated email addresses</li>
<li>Increased chances that the obtained data is real</li>
<li>Personalization, resulting in more loyal followers</li>
<li>High engagement</li>
<li>Less support (such as a reset password service) needed</li>
<li>Increased number of repeated users</li>
<li>Increased chance for referrals because of invites and sharing</li>
</ul>
<p>There is no one solution that fits all. You need to decide which social networks you will support, and perhaps you choose to support multiple ones. This is of particular interest if you have international ambitions for your app. Facebook or LinkedIn sign-up features make perfect sense in the US and in large parts of Europe, but in other parts of the world (China or Russia for example) these networks may be less popular (or not accessible at all) and you may want to offer an alternative onboarding option for these particular regions. This could be another social network or you can provide a fall-back mechanism. You can still offer an onboarding flow in your app, based on forms. You can use that for the cases in which the user cannot or does not want to use a social sign-up. It is up to you if you decide to support it. You gain a little extra audience with it, but at a cost (development and conversion). For this reason, there are apps that choose only to support one or multiple social sign-up options.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Show us what you have got</h1>
                
            
            
                
<p>An alternative approach is instantly showing the content of the app (if the nature of the app allows you to do so) and only asking for a social sign-up when needed.</p>
<p>This way no or little introduction is needed. Just as is the case with many e-commerce solutions (think of web shops), signing up is requested only when it matters. In the case of a web shop, this is required for check out. For a mobile app, it may be applicable, for example, when the user no longer just consumes but also wants to contribute to a stream. You can think of a news app that allows users to comment about the messages that appear:</p>
<div><img class=" image-border" height="84" src="img/994dd144-3b58-4cd3-b811-3c59db03b870.png" width="633"/></div>
<p>This lowers the barrier even more; however, the downside can be that a large number of users will never sign-up and for that reason will be less valuable to you. For example, anonymous users are not likely to share a lot on social media from your app and inviting their friends is impossible since we do not know who they are.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Phone number sign-up - a great alternative</h1>
                
            
            
                
<p>WhatsApp and a couple of other apps are using the phone number of the device to identify a user for the registration. This is done through an SMS verification code. The user enters his phone number and receives an SMS with a verification code, which he needs to type into the app. This will ensure that the phone number is correct. There are even some implementations that intercept the receiving of the SMS verification code and then fill in the code automatically. This will take away another step from the onboarding flow:</p>
<div><img class=" image-border" height="83" src="img/2d22748b-72ad-42ae-9988-e82245c6e67a.png" width="646"/></div>
<p>You have to make it clear to the user that his phone number is used for verification purposes only and that it will not be publicly available in the app. Using a phone number will also lead to more valuable contributions of the user. The reason for this is simple. He is aware that his phone number is attached to all the actions he performs in the app. There are services that will take away most of the hassle that comes with the implementation. In our sample app, which we will discuss later in this chapter, Fabric and Firebase will be used because it is the easiest solution to implement and because it is free to use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuous onboarding - complete the user profile later</h1>
                
            
            
                
<p>Obtaining the most minimal information from your user to get him on board is a smart way to keep the barrier low. Later you can encourage your user to add more details to his profile or by the user make particular choices from which your app can learn. The concept of continuous onboarding is exactly about that. The profile of the user will be enriched by the actions that the user will take. This will allow the app to offer a better and customized app experience that will become more dedicated over time.</p>
<p>LinkedIn is the perfect example, as everybody will recognize the reminders that LinkedIn displays. It asks you to complete your profile, to endorse connections (enriching the profiles of others), or to connect to people. You will often be reminded about that but it never will be mandatory to do these things.</p>
<p>The incentive here is not even that strong, but it works well. Who does not want have an All-Star profile? You can use this idea for your mobile app, as we will soon see in the sample app:</p>
<div><img class=" image-border" height="126" src="img/3634f81e-2710-427a-b6fa-cae171a05d70.png" width="235"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Tell a story - an example onboarding app</h1>
                
            
            
                
<p>To demonstrate the various ideas related to onboarding, we will create an Android app that is using Fabric for Twitter authentication and Firebase SDK for phone authentication. You can use Firebase as well for Twitter authentication, but the one that Fabric is offering is more convenient to use.</p>
<p>We will name this app, Tell a Story. Using this app, users can write a story together. Anyone can read the stories that people create, but, if the user wants to contribute to the story, he needs to sign-up using Twitter or his phone number. Let's start simple with a couple of wire frames that will explain the exact flow of the app:</p>
<div><img class=" image-border" height="363" src="img/dcc665ae-1604-4913-9215-a0a62ffb771d.png" width="681"/></div>
<p>The user lands on the introduction view when he opens the app for the first time. This view contains a clear explanation of why he should want to use the app and what it is about. There are two very clear call to actions shown. One of them is the Sign up with phone number button, the other one is the Sign up with Twitter button.</p>
<p>After the sign-up, a list of existing team stories is shown. The user can browse through the list, and, if he clicks on any of the stories, the full story will be revealed in a detailed view. The user can also decide to start a story by himself. Here is another clear call to action, visualized as the Start a story button.</p>
<p>The detail view shows all lines for the story, including the names of the authors. The user can now read the full story or he can contribute to it by clicking on the Contribute to story button. Doing so will lead him to the Contribute to... view, where he can enter a new line of code. If the user chooses to start a new story by clicking on the Start a story button he will see the same view. In this case, the user will also be asked for a story title. Clicking on the Add new line to story button will add the new line to the story or will create a new story:</p>
<div><img class=" image-border" height="387" src="img/94525d8b-eb39-44a6-bdc1-b769b241881c.png" width="728"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Onboarding sign-up when needed</h1>
                
            
            
                
<p>We will also need to add a late onboarding option to the app. For this purpose, we will add a Skip for now button to the Introduction view. In <a href="a62b3753-12c5-4170-808a-e0e1446e6b97.xhtml" rel="noopener noreferrer" target="_blank">Chapter 13</a>, <em>Play Store and App Store Hacks</em>, about split testing, we will see how we can learn what approach will work best. We need to know which implementation will lead to the highest conversion. Based on this feedback, we can remove the Skip for now button, the sign-up buttons on the introduction view, or make the decision to keep all the three options in the introduction view.</p>
<p>Note that, although this button is highlighted next to demonstrate the late onboarding flow, this button should not be the primary call to action and therefore should not be marked as such. We want to lower the barrier, but we still want to encourage the user to sign-up early:</p>
<div><img class=" image-border" height="346" src="img/20765388-0169-4dd3-a74f-e84fc0ffbde3.png" width="719"/></div>
<p>If the user chooses to click on the Skip for now button as he apparently is not quite convinced about the benefits of the app yet, he will see the story list right away. Only if he wants to start a new story, or if he wants to contribute to an existing one, he will be asked to sign-up via either Twitter or phone/SMS. For our app, we want to support both types of flow. Let's start with the implementation of what we just saw.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementation</h1>
                
            
            
                
<p>You can find the sample project for this chapter here: <a href="https://github.com/mikerworks/packt-lean-onboarding">https://github.com/mikerworks/packt-lean-onboarding</a>.</p>
<p>The code sample has been updated, so it will use the latest and greatest (at the time of writing). Digits, the Fabric phone authentication service, has been replaced by the Firebase phone authentication service. The code sample is now using this service and, while I was busy anyway, I have converted the Android Java example to Kotlin.</p>
<p>You can have a look at the app first, or if you want to configure it for your own use you need to configure Fabric and Firebase first.</p>
<p>Visit <a href="https://fabric.io">https://fabric.io</a> and create an account. Once you have done that and have confirmed it, you can proceed. Enter a team name (for example <kbd>packt-demo</kbd>) and choose a platform (Android). After that, a new page in the wizard will show a number of options. Pick the Twitter option first. The first piece of information tells you how to configure your Android project. Use the wizard (or do it manually) to create the first app in the Fabric environment and name it <kbd>onboarding</kbd>. You need to do this to obtain keys and IDs that allow you to use the Fabric SDK in your own app.</p>
<p>Next, we need to do a few things for the phone number authentication. The Digit service of the Fabric is doing exactly that but it has been replaced by FireBase phone authentication. So you need to set up a few things at Firebase as well. Go to <a href="https://console.firebase.google.com">https://console.firebase.google.com</a> and create a new project, or if you have not signed up for Firebase yet, you need to do so first.</p>
<p>Follow the setup instructions at Firebase. In the authentication section, you can select which sign-up methods you wish to use for your application. If you click on the phone sign-up option and enable it, you can continue with the sample app.</p>
<p>Let's have a walk through the app. On the fly, you can modify the API key and the secret to match your own setup. Once opened in Android Studio, you should expand the app folder. Locate the build.gradle file in this folder and open it.</p>
<p>You will see that the file contains a couple of dependencies on Fabric and Firebase. We will use that later so we can login with Twitter or Firebase phone authentication. In addition, we can share stories on Twitter using the <kbd>TweetComposer</kbd> class. Note that you may need to update the version numbers to the latest versions. They appear as suffixes of the definitions of the various package names:</p>
<pre>... 
apply plugin: 'io.fabric' 
 
repositories { 
   maven { url 'https://maven.fabric.io/public' } 
   maven { 
       url 'https://maven.google.com' 
   } 
   mavenCentral() 
} 
 
dependencies { 
  ... 
   compile('com.twitter.sdk.android:twitter:1.13.3@aar') { 
       transitive = true; 
   } 
 
   compile('com.twitter.sdk.android:tweet-composer:1.0.3@aar') { 
       transitive = true; 
   } 
 
   ... 
   implementation 'com.google.firebase:firebase-auth:11.4.2' 
   implementation 'com.google.firebase:firebase-database:10.2.4' 
} 
 
apply plugin: 'com.google.gms.google-services' </pre>
<p>Now, open the <kbd>AndroidManifest.xml</kbd> file in the <kbd>app/src/main/</kbd> folder. The metadata section contains the value for <kbd>ApiKey</kbd>. Modify it so it will have the value that corresponds with your own configuration at <kbd>Fabric.io</kbd>:</p>
<pre>&lt;meta-data 
    android:name="io.fabric.ApiKey" 
    android:value="fill in your api key" /&gt; </pre>
<p>The layout associated with the onboarding activity displays a short introduction that explains to the user why they should want to use the app and how easy it is to get started. Both the phone number and the Twitter sign up button are clear calls to actions here:</p>
<div><img class=" image-border" height="268" src="img/db4e1ca4-6ab0-48b0-9bf2-0d49e7ccc18c.png" width="151"/></div>
<p>There is one additional button, which has been intentionally made smaller and less colorful. It is here to allow the user to skip the sign-up process for the time being, in case he wants to only see what the app is about.</p>
<p>Open the <kbd>strings.xml</kbd> value and update <kbd>twitter_key</kbd> and <kbd>twitter_secret</kbd>. Replace them with your own values. You will find them on the Fabric website:</p>
<pre>&lt;resources&gt; 
   &lt;string name="twitter_key"&gt;fill with your own Twitter key&lt;/string&gt; 
   &lt;string name="twitter_secret"&gt;fill your own Twitter secret&lt;/string&gt; </pre>
<p>Open the <kbd>OnboardingActivity</kbd> class. In the <kbd>onCreate</kbd> method, the <kbd>initFabric</kbd> method is called. This is where Fabric is initialized for Twitter authentication and sharing:</p>
<pre>private fun initFabric(){ 
   val authConfig = TwitterAuthConfig(getString(R.string.twitter_key), getString(R.string.twitter_secret)) 
   Fabric.with(this, Twitter(authConfig)) 
   Fabric.with(this, TwitterCore(authConfig), TweetComposer()) 
} </pre>
<p>The click listener for the Skip button makes the app jump to the list immediately. If clicked on, the Twitter login button will display a Twitter dialog asking for permission. If this permission is given, the success method of the callback will be triggered. We will then store the <kbd>TwitterSession</kbd> object and show the list of stories to the user by calling the <kbd>onShowList</kbd> method:</p>
<p>For the sake of simplicity, <kbd>AuthenticationHelper</kbd> is not persisting the sessions other than during the lifetime of the application. In a production app, it would be more convenient to persist them as long as they are valid.</p>
<p>You can find the implementation of what we just saw in the <kbd>setupTwitterLoginButton</kbd> and the <kbd>signinWithTwitterAuthCredential</kbd> methods as follows:</p>
<pre>private fun setupTwitterLoginButton(){ 
  twitter_login_button.setCallback(object : Callback&lt;TwitterSession&gt;() { 
       override fun success(result: Result&lt;TwitterSession&gt;) { 
           mTwitterSession = result.data 
           Log.i(javaClass.simpleName, "Twitter login @" + result.data.getUserName() + ")") 
           val credential = TwitterAuthProvider.getCredential( 
                   result.data.getAuthToken().token, 
                   result.data.getAuthToken().secret) 
           signinWithTwitterAuthCredential(credential) 
       } 
 
       override fun failure(exception: TwitterException) { 
           Log.d(javaClass.simpleName, "Login with Twitter failure", exception) 
       } 
   }) 
} </pre>
<p>The <kbd>signInWithPhoneAuthCredential</kbd> method registers the user with his Twitter name as a Firebase user. We will use this phone number later to identify the contributions of the user.</p>
<pre>private fun signinWithTwitterAuthCredential (credential: AuthCredential){ 
   mAuth.signInWithCredential(credential) 
       .addOnCompleteListener(this, OnCompleteListener&lt;AuthResult&gt; { 
           if (it.isSuccessful) { 
               AuthenticationHelper.user = it.result.user 
               Log.i(javaClass.simpleName, 
                 "User logged in or registered with twitter name ${AuthenticationHelper.user?.displayName}") 
               continueFlow() 
           } else { 
               if (it.exception is FirebaseAuthInvalidCredentialsException) { 
                   onboarding_code_feedback_text.text = "Invalid code." 
               } 
           } 
       }) 
} </pre>
<p>To sign-up with a phone number, we need to tell Firebase to send a code by SMS to the user. We will do that in the <kbd>sendPhone</kbd> method:</p>
<pre>private fun sendPhone(){ 
   val number = onboarding_phone.text.toString() 
    PhoneAuthProvider.getInstance().verifyPhoneNumber( 
           number, 60, TimeUnit.SECONDS,  this, getCallback()); 
} </pre>
<p>The callback implemention is in the <kbd>getCallback</kbd> method. The <kbd>onCodeSent</kbd> is the most interesting event. If the code has been sent, we will store the returned verification ID. We will need it later to authenticate the user with the code:</p>
<pre>private fun getCallback(): PhoneAuthProvider.OnVerificationStateChangedCallbacks { 
   val callbacks = object : PhoneAuthProvider.OnVerificationStateChangedCallbacks() { 
     ... 
       override fun onCodeSent(verificationId: String?, token: PhoneAuthProvider.ForceResendingToken?) { 
           mVerificationId = verificationId; 
           mResendToken = token; 
           ... 
       } 
   } 
   return callbacks 
} </pre>
<p>After sending the code to the user, he has to enter the code to ensure the provided phone number is indeed his phone number. This is done in the <kbd>sendCode</kbd> method:</p>
<pre>private fun sendCode(){ 
   val verification = mVerificationId 
   if (verification != null) { 
       val code = onboarding_code.text.toString() 
       val credential = PhoneAuthProvider.getCredential(verification, code) 
       signInWithPhoneAuthCredential(credential) 
   } 
} </pre>
<p>The <kbd>signInWithPhoneAuthCredential</kbd> method registers the user with his phone number as a Firebase user. We will use this phone number later to identify the contributions of the user:</p>
<pre>private fun signInWithPhoneAuthCredential(credential: PhoneAuthCredential) { 
   mAuth.signInWithCredential(credential) 
       .addOnCompleteListener(this, OnCompleteListener&lt;AuthResult&gt; { 
           if (it.isSuccessful) { 
               AuthenticationHelper.user = it.result.user 
               Log.i(javaClass.simpleName, 
                  "User logged in or registered with phone no ${AuthenticationHelper.user?.phoneNumber}") 
               continueFlow() </pre>
<p>Here is an example of both the users. The first one is registered using Twitter, while the other one has used his phone number to sign-up:</p>
<div><img class=" image-border" height="170" src="img/76bc825c-bef7-4da8-9a58-66173d448f66.png" width="662"/></div>
<p>Now, open MainActivity. In the <kbd>onCreate</kbd> method, you will see that one of the first things that we do is call the <kbd>onList</kbd> method. The <kbd>onList</kbd> method creates a new <kbd>StoriesFragment</kbd>, and by calling the <kbd>showFragment</kbd> method a list of stories will be shown by default:</p>
<pre>fun onList() { 
   val fragment = StoriesFragment.newInstance() 
   showFragment(fragment) 
} 
 
fun onCreateStory() { 
   val newStory = Story() 
   newStory.lastUpdate = "today" 
   val fragment = StoryContributeFragment.newInstance(newStory) 
   showFragment(fragment) 
} 
 
fun onContribute(story: Story) { 
   val fragment = StoryContributeFragment.newInstance(story) 
   showFragment(fragment) 
} 
 
fun onReadStory(story: Story) { 
   val fragment = StoryDetailFragment.newInstance(story) 
   showFragment(fragment) 
} 
 
fun onLateOnboarding(story: Story) { 
   val intent = Intent(this, OnboardingActivity::class.java) 
   intent.putExtra(OnboardingActivity.ARG_LATE, true) 
   intent.putExtra(OnboardingActivity.ARG_STORY, story) 
   startActivityForResult(intent, REQUEST_LATE_ONBOARDING) 
} 
 
private fun showFragment(fragment: Fragment) { 
   val ft = fragmentManager.beginTransaction() 
   ft.replace(R.id.main_fragment_container, fragment, fragment.javaClass.toString()) 
   ft.commit() 
} </pre>
<p>The MainActivity is also responsible for showing other fragments, such as the <kbd>StoryDetailFragment</kbd>, which shows you the full story and the <kbd>StoryContributeFragment</kbd>. It also contains a call to the <kbd>OnboardingActivity</kbd> for late onboarding purposes. This will allow the user to sign-up if they have skipped the onboarding previously, but want to contribute to the app later. By adding content to a story or by creating a new story, they will be asked to sign-up once again:</p>
<pre>val repository: Repository get() = Repository(this) </pre>
<p>The <kbd>getRepository</kbd> method just returns a new instance of the <kbd>Repository</kbd> class that we are going to investigate next.</p>
<p>You will find the <kbd>Repository</kbd> class with the data package. As you can see, the <kbd>getDummyContent</kbd> method creates a list of dummy stories.</p>
<p>The <kbd>repository</kbd> class has already been prepared to be used with Firebase, but, since we do want to demonstrate the onboarding concept, the data is only persisting during the lifetime of the app. If you have read <a href="c61bb6d7-f392-40e8-8330-7cc2f681b0e6.xhtml" rel="noopener noreferrer" target="_blank">Chapter 9</a>, <em>Native, Hybrid, or Cross Platform</em>, it will be pretty easy to set up Firebase and modify this class in order to be able to store stories in the cloud as well.</p>
<p>The class looks like this:</p>
<pre>class Repository(private val context: Context) { 
 
   fun getStories(handler: OnRepositoryResult) { 
       val content = getDummyContent() 
       handler.onResult(content) 
   } 
 
   fun updateContributions(story: Story) { 
       if (story.id == null) { 
           addStory(story) 
       } 
 
       dummyContentList.forEach { 
           if (it.id.equals(story.id, ignoreCase = true)){ 
               it.contributions  = story.contributions 
           } 
       } 
   } 
 
   fun addStory(story: Story) { 
       if (story.id == null) { 
           story.id = UUID.randomUUID().toString() 
       } 
       dummyContentList.add(story) 
   } 
 
   companion object { 
       private var dummyContentList = mutableListOf&lt;Story&gt;() 
       private fun getDummyContent(): List&lt;Story&gt; { 
 
           if (dummyContentList.isEmpty()) { 
               val dummy = mutableListOf&lt;Story&gt;() 
               val s1 = Story("A first story", "MikeR", "Today") 
               s1.id = "1" 
               s1.contributions.add(Contribution("Once upon a time", "MikeR")) 
               s1.contributions.add(Contribution("a giant rabbit did exist", "Pete")) 
               s1.contributions.add(Contribution("in a galaxy far far away", "Floris")) 
 
               val s2 = Story("A second story", "MikeR", "Yesterday") 
             ... 
               dummy.add(s1) 
  ... 
               dummyContentList = dummy 
           } 
           return dummyContentList 
       } 
   } 
} </pre>
<p>The <kbd>getStories</kbd> method returns all stories and the data asynchronously. The <kbd>updateContributions</kbd> method adds a new contribution to an existing story, or creates a new story with a first contribution if the story does not yet exist by calling the <kbd>addStory</kbd> method. The <kbd>addStory</kbd> method eventually creates a unique ID for the story and adds the story to the list.</p>
<p>In the <kbd>models</kbd> package, you will find the <kbd>Story</kbd> and <kbd>Contribution</kbd> class. A <kbd>Story</kbd> has a title and multiple contributions, and each contribution has an author and some content. The <kbd>Parcelable</kbd> implementation makes it more convenient to pass data from one fragment (or activity) to another, as we will see later:</p>
<pre>class Story : Parcelable { 
   var id: String? = null 
   var title: String? = null 
   var initiator: String? = null 
   var lastUpdate: String? = null 
   var contributions = mutableListOf&lt;Contribution&gt;() 
...  
   fun getFullStory(includeAuthors: Boolean): String { ...  }    
 
val summary: String 
       get() { 
           val builder = StringBuilder() 
           if (contributions != null) { 
               var start = contributions.size - 3 
               if (start &lt;= 0) { start = 0 } 
               for (build in start..contributions.size - 1) { 
                   builder.append(contributions[build].paragraph.toString() + "\n") 
               } 
               return builder.toString() 
           } else { 
               return "This story has not started yet!" 
           } 
       } 
   ... </pre>
<p>The <kbd>getSummary</kbd> and the <kbd>getFullStory</kbd> methods make a <kbd>Story</kbd> object just a little bit smarter and it returns the last three lines or the full story, as text, respectively.</p>
<p>The <kbd>Contribution</kbd> class implements the <kbd>Parcelable</kbd> interface as well for the same reasons as for the <kbd>Story</kbd> class. Each <kbd>Contribution</kbd> instance has an author and a paragraph member.</p>
<p>The first thing a user will see, right after the onboarding view on see what the app is all about. For a more complex app it could be helpful to highlight specific features the first time the app is used. By showing them during the onboarding flow we can encourage the user to sign up for the app. For this app, things are pretty obvious:</p>
<div><img class=" image-border" height="319" src="img/b8c304b9-8a0d-4a5c-94df-286490307261.png" width="179"/></div>
<p>Everybody likes stories, so the first action probably will be that the user clicks on a story of which the summary looks appealing. (Again this is a hypothesis that needs to be proven.) If the user clicks on the floating action button (the one with the plus sign on it), he will create a new story:</p>
<pre>class StoriesFragment : Fragment(), OnCardViewClicked, OnRepositoryResult { 
   private var recyclerView: RecyclerView? = null 
   private var adapter: StoryAdapter? = null 
   private var viewModel = mutableListOf&lt;Story&gt;() 
... </pre>
<p>If you take a look inside <kbd>StoriesFragment</kbd>, you will see that a <kbd>RecyclerView</kbd> widget and a <kbd>StoryAdapter</kbd> will be used to display the data shown here. In the <kbd>onCreateView</kbd> method, the <kbd>loadData</kbd> method will be called, which in turn calls the <kbd>getStories</kbd> method of the <kbd>Repository</kbd> class, passing the fragment itself as the handler of the results:</p>
<pre>override fun onResult(result: List&lt;Story&gt;) { 
   viewModel = result.toMutableList() 
   adapter = StoryAdapter(viewModel) 
   adapter?.setOnCardViewClicked(this) 
   recyclerView?.adapter = adapter 
} </pre>
<p>When the results come in, an instance of the <kbd>StoryAdapter</kbd> class will be created and attached to the <kbd>RecyclerView</kbd> instance. The <kbd>StoryAdapter</kbd> binds the data for each story to a row in the list:</p>
<pre>override fun onCardClicked(view: View, position: Int) { 
   (activity as MainActivity).onReadStory(viewModel[position]) 
} </pre>
<p>If the user clicks on any of the rows the <kbd>OnCardViewClick</kbd> event will be triggered, which will call the <kbd>onReadStory</kbd> method from <kbd>MainActivity</kbd>, passing the selected story as the parameter. This will bring us to the <kbd>StoryDetailFragment</kbd> implementation.</p>
<p>This fragment displays the full story to the user, including the name of the contributors. Here, the user can contribute to the story by clicking on the CONTRIBUTE (as shown in the example image):</p>
<pre>class StoryDetailFragment : Fragment() { 
   private var mStory: Story? = null 
   override fun onCreate(savedInstanceState: Bundle?) { 
       super.onCreate(savedInstanceState) 
       mStory = getArguments().getParcelable(ARG_STORY) 
   } </pre>
<p>In the <kbd>onCreate</kbd> method, the selected story will receive through the bundle. It is here where the <kbd>Parcelable</kbd> implementation comes in handy. In the <kbd>onCreateView</kbd> method, the content of the story will be set as text for <kbd>textView</kbd> using the <kbd>getFullStory</kbd> method of the <kbd>story</kbd> object:</p>
<div><img class=" image-border" height="326" src="img/2fa3c4ae-5dbb-4eba-a760-55ef9ba94a46.png" width="184"/></div>
<p>In the <kbd>onClick</kbd> method, you will find the handling for the various button clicks, such as the CONTRIBUTE button. This will call the <kbd>onContribute</kbd> method, which in turn calls the <kbd>onContribute</kbd> method of the MainActivity, including the currently selected story. It will result in displaying the layout associated with the <kbd>StoryContributeFragment</kbd> class.</p>
<p>In the <kbd>onShare</kbd> method of the <kbd>StoryDetailFragment</kbd>, you will find the lines that are needed to compose and share a tweet:</p>
<pre>private fun onShare() { 
   val builder = TweetComposer.Builder(getActivity()) 
           .text(String.format(getString(R.string.sharing_text), mStory?.title)) 
   builder.show() 
} </pre>
<p>The <kbd>StoryContributeFragment</kbd> allows the users to contribute to a story or to start a new story. At that moment, the user changes from a passive to an active user. Also, the user will be converted to a known user as he is required to sign-up, which he may not have done yet. The fragment obtains the selected story as a bundle parameter. It may be an empty one, in case the user hit the plus button, as he wants to create a new story. If it is an existing story, a summary of the story (the last three contributions) will be shown.</p>
<p>If the user clicks on the Contribute button, the <kbd>onContribute</kbd> method will be called. Here a new <kbd>Contribution</kbd> object will be made and, optionally, a new story object will be made. The contribution will be added to the story and we will ask the <kbd>AuthenticationHelper</kbd> class whether the current user is already authenticated or not. If the user is authenticated, either by a Twitter sign-up or by a Firebase phone sign-up, we can proceed by filling in the contributor's name (Twitter name or phone number). Also, we call the <kbd>updateContributions</kbd> method of the <kbd>Repository</kbd> class, which will take care of storing stories:</p>
<div><img class=" image-border" height="307" src="img/cd0746c7-a767-487a-adaa-0d6d5674e2f8.png" width="172"/></div>
<p>If the user is not yet authenticated, we will call the <kbd>onLateOnboarding</kbd> method of the MainActivity instead. Here we will also pass the story (and with that the contributions) as a parameter:</p>
<pre>fun onLateOnboarding(story: Story) { 
   val intent = Intent(this, OnboardingActivity::class.java) 
   intent.putExtra(OnboardingActivity.ARG_LATE, true) 
   intent.putExtra(OnboardingActivity.ARG_STORY, story) 
   startActivityForResult(intent, REQUEST_LATE_ONBOARDING) 
} </pre>
<p>The <kbd>OnboardingActivity</kbd> will also handle the onboarding on the fly. Better late than never is the idea here. If you want to contribute to a story, or want to create a story yourself, you have to sign-up first. Now, the activity will display a message that indicates this, and again it gives the user the choice to sign-up using his Twitter account or using his phone number:</p>
<pre>private fun continueFlow(){ 
   if (mIsLateOnboarding){ 
       val returnIntent = Intent() 
       returnIntent.putExtra(OnboardingActivity.ARG_STORY, mStory) 
       setResult(Activity.RESULT_OK, returnIntent) 
       this.finish() 
... </pre>
<p>If the late onboarding succeeds, the result will be returned to MainActivity, which will take care of adding the contribution to the story:</p>
<pre>override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent) { 
   if (requestCode == REQUEST_LATE_ONBOARDING) { 
       if (resultCode == Activity.RESULT_OK) { 
           val story = data.getParcelableExtra&lt;Story&gt;(OnboardingActivity.ARG_STORY) 
           val lastContribution = story.contributions.last() 
           lastContribution.contributor = AuthenticationHelper.userName 
           repository.updateContributions(story) 
           onList() 
       } 
   } 
} </pre>
<p>After that the list of stories is shown again by calling the <kbd>onList</kbd> method of the <kbd>MainActivity</kbd> class. This time the list will include the contribution, or the story of the user that is no longer an unknown one. Signed up at last!</p>
<p>So far, for the app, we have seen some cool implementations for signing up and late onboarding. If you like the concept, then feel free to do some further experimentation with the app. Think, for example, of two other great features for the app that we could add: An invite a friend option (to write the story with you) and a share option (to share the cool story on Twitter or another social media network). This will increase the awareness of your app. That will help you to grow the user base of your app. We will see more about this in <a href="2ee66b42-cffe-42de-bbce-4fa54fa7fb61.xhtml" rel="noopener noreferrer" target="_blank">Chapter 14</a>, <em>A/B Testing Your App</em>, which is about traction and retention:</p>
<div><img class=" image-border" height="65" src="img/88b799c6-7332-4e4a-ae0e-d3b5ee4abb06.png" width="465"/></div>
<p>Growth hacking is, among other things, a continuous process that results in existing users inviting friends to join them and use the app as well. The reason that people start downloading your app is because they have become aware of it. You will see higher conversion numbers when implementing a friend referral flow.</p>
<p>Growth hacking:<br/>
<br/> Growth hacking (basically a modern word for marketing) is a topic that deserves some books on its own. You should consider building a growth engine before starting to build your app. Build an audience for the problem that you are going to solve with your app. It is a great way to test your app idea and to create awareness. The simplest way to do so is to create a regular blog about the topic.</p>
<div><img class=" image-border" height="70" src="img/995d89fa-0980-434c-9936-6c07a3dd44d6.png" width="609"/></div>
<p>The perfect conversion goes like this: Once the user has signed up and started a story or contributed to one (activation), and then decides to continue doing so (retention), he will become an ambassador of your app and he will start sharing stories or he will invite friends so they can write stories together (referrals).</p>
<p>Referrals are important, as word of mouth is one of the most effective types of marketing. More than 70% of potential app users download apps based on recommendations of friends, colleagues, or family. With that in mind, the goal should be to enable the app users to drive more awareness, which is exactly what the Team Stories app tries to do. Referrals are often the only way to promote an app. This is because of the fact that the cost of user acquisition (advertisements) for most mobile apps otherwise would be higher than the revenues.</p>
<p>Due to their nature, particular apps, such as social, or messaging ones, and of course game apps as well, are very suitable for inviting friends. Often they would not make much sense if collaboration in some way would not be possible. For a lot of other apps the reason for sharing or inviting might be less obvious. However, if you provide incentives, as, for example, Dropbox is doing by providing additional space for each new reference, you can still benefit from referrals.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have seen that there are various ways for onboarding a user and to encourage a user to sign-up. We have seen that is important to keep the barrier as low as possible, and that you need to make it very clear from the beginning what the benefits of your app are and why the user wants to use it. Alternatively, just to quote Simon Sinek, "Start with why".</p>
<p>We have seen that the implementation for social sign-up using the Firebase or the Fabric SDK is fairly easy to implement and we have learned how we can offer multiple options to our users, including the option to initially skip registration. Although it lowers the barrier, the latter is not necessarily a good thing. An anonymous user has less value than a known one. Also, a known user is easier to convert into a paying one (customer). You need to find out what works best for your app. Maybe you just want to grow a large user base to begin with. In the next chapter, we will see how important it is to have a scalable solution.</p>


            

            
        
    </body></html>