- en: <st c="0">15</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">15</st>
- en: <st c="3">Exploring Architectures for iOS</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">探索适用于 iOS 的架构</st>
- en: <st c="35">In the previous chapter, we discussed Swift Testing, an essential
    framework that helps us test our Swift code.</st> <st c="147">App testing is not
    only a technical topic – it is also a culture.</st> <st c="213">Part of this culture
    is looking at our project as a set of classes and a whole structure with a certain
    logic.</st> <st c="324">That’s why testing and architecture go hand in hand –
    they both look at our project as a well-designed system.</st> <st c="435">This
    holistic approach is essential to meet our product requirements</st> <st c="504">over
    time.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35">在前一章中，我们讨论了 Swift 测试，这是一个帮助我们测试 Swift 代码的必要框架。</st> <st c="147">应用测试不仅是一个技术话题——它也是一种文化。</st>
    <st c="213">这种文化的一部分是将我们的项目视为一组类和具有一定逻辑的整体结构。</st> <st c="324">这就是为什么测试和架构密不可分——它们都把我们的项目视为一个设计良好的系统。</st>
    <st c="435">这种整体方法对于满足我们的产品需求</st> <st c="504">至关重要。</st>
- en: <st c="514">In this chapter, we will cover the</st> <st c="550">following topics:</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="514">在本章中，我们将涵盖以下主题：</st> <st c="550">理解架构的重要性</st>
- en: <st c="567">Understanding the importance</st> <st c="597">of architecture</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="567">理解架构的重要性</st> <st c="597">。</st>
- en: <st c="612">Learning what exactly</st> <st c="635">architecture is</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="612">学习架构究竟是什么</st>
- en: <st c="650">Going over the different architectures, such as multi-layer, modular,</st>
    <st c="721">and hexagonal</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="650">了解不同的架构，如多层、模块化、和六边形</st>
- en: <st c="734">Comparing the different architectures by separations, testing,</st>
    <st c="798">and maintenance</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="734">通过分离、测试、和维护来比较不同的架构</st>
- en: <st c="813">First, let’s understand why architecture is</st> <st c="858">so
    important.</st>
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="813">首先，让我们了解为什么架构</st> <st c="858">如此重要。</st>
- en: <st c="871">Technical requirements</st>
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="871">技术要求</st>
- en: <st c="894">You must download Xcode version 16.0 or above from Apple’s App Store
    for</st> <st c="968">this chapter.</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="894">为了本章，您必须从 Apple 的 App Store 下载 Xcode 版本 16.0 或更高版本。</st>
- en: <st c="981">You’ll also need to run the latest version of macOS (Ventura or
    above).</st> <st c="1054">Search for Xcode in the App Store and select and download
    the latest version.</st> <st c="1132">Launch Xcode and follow any additional installation
    instructions that your system may prompt you with.</st> <st c="1235">Once Xcode
    has fully launched, you’re ready</st> <st c="1279">to go.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="981">您还需要运行最新版本的 macOS（Ventura 或更高版本）。</st> <st c="1054">在 App Store
    中搜索 Xcode，选择并下载最新版本。</st> <st c="1132">启动 Xcode 并遵循系统可能提示的任何附加安装说明。</st> <st c="1235">一旦
    Xcode 完全启动，您就准备好了</st> <st c="1279">出发。</st>
- en: <st c="1285">Understanding the importance of architecture</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1285">理解架构的重要性</st>
- en: <st c="1330">To understand</st> <st c="1345">the importance of architecture,
    let’s try to understand how the iOS development knowledge</st> <st c="1435">is
    built.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1330">为了理解</st> <st c="1345">架构的重要性，让我们尝试理解 iOS 开发知识</st> <st c="1435">是如何构建的。</st>
- en: <st c="1444">Many think that iOS development is centralized around Swift – if
    we know Swift, we know</st> <st c="1533">iOS development.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1444">许多人认为 iOS 开发是以 Swift 为中心的——如果我们知道 Swift，我们就知道</st> <st c="1533">iOS
    开发了。</st>
- en: <st c="1549">Nonetheless, iOS development contains many knowledge levels, and
    the Swift language is only one</st> <st c="1646">of them.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1549">尽管如此，iOS 开发包含许多知识层次，Swift 语言只是其中之一</st> <st c="1646">。</st>
- en: <st c="1654">Let’s try to</st> <st c="1668">structure the iOS development to</st>
    <st c="1701">different levels:</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1654">让我们尝试将 iOS 开发</st> <st c="1668">结构化到不同的层次：</st> <st c="1701">。</st>
- en: '**<st c="1718">IDE</st>**<st c="1722">: Familiarity with Xcode, its debugging
    tools, configuration, simulator, builder, and code signing</st> <st c="1822">is
    crucial.</st>'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="1718">IDE</st>**<st c="1722">：熟悉 Xcode，其调试工具、配置、模拟器、构建器和代码签名</st>
    <st c="1822">至关重要。</st>'
- en: '**<st c="1833">Language</st>**<st c="1842">: Whether it’s Swift, Objective
    C, or C++, language is a fundamental part of iOS development.</st> <st c="1937">It’s
    the basis for daily implementing our app’s logic and</st> <st c="1995">design
    pattern.</st>'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="1833">语言</st>**<st c="1842">：无论是 Swift、Objective C 还是 C++，语言是 iOS
    开发的根本部分。</st> <st c="1937">它是我们每天实现应用逻辑和</st> <st c="1995">设计模式的基础。</st>'
- en: '**<st c="2010">System</st>**<st c="2017">: Understanding iOS’s unique characteristics,
    strengths, and limitations is key.</st> <st c="2099">Ultimately, we are developing
    in a particular environment with its own rules</st> <st c="2176">and policies.</st>'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2010">系统</st>**<st c="2017">：理解 iOS 的独特特性、优势和局限性是关键。</st> <st c="2099">最终，我们是在一个具有自己规则</st>
    <st c="2176">和政策的环境中开发。</st>'
- en: '**<st c="2189">SDK</st>**<st c="2193">: The SDK provides the toolset to do
    whatever we want.</st> <st c="2249">SwiftUI, UIKit, Foundation, Core Animation,
    and many other frameworks are part of the SDK, and with them, we can create beautiful
    screens with user input components and</st> <st c="2418">persistent storage.</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2189">SDK</st>**<st c="2193">：SDK 提供了工具集，让我们能够做我们想要做的任何事情。</st> <st
    c="2249">SwiftUI、UIKit、Foundation、Core Animation 以及许多其他框架都是 SDK 的一部分，有了它们，我们可以创建带有用户输入组件和</st>
    <st c="2418">持久存储的美丽界面。</st>'
- en: '**<st c="2437">Design patterns</st>**<st c="2453">: These are solutions to
    common problems and tasks we</st> <st c="2508">encounter daily.</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2437">设计模式</st>**<st c="2453">：这些是解决我们日常遇到的常见问题和任务的解决方案。</st> <st
    c="2508">我们。</st>'
- en: '**<st c="2524">Architecture</st>**<st c="2537">: The high-level organization
    of our code and project is called</st> <st c="2602">its architecture.</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2524">架构</st>**<st c="2537">：我们代码和项目的整体组织结构被称为</st> <st c="2602">其架构。</st>'
- en: <st c="2619">We can continue with more knowledge levels – testing, databases,
    networking, security, and more.</st> <st c="2717">The knowledge spectrum has become
    huge over the years, with more and more capabilities and</st> <st c="2808">knowledge
    required.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2619">我们可以继续学习更多知识层面——测试、数据库、网络、安全等。</st> <st c="2717">随着时间推移，知识范围变得非常广泛，需要更多的能力和</st>
    <st c="2808">知识。</st>
- en: <st c="2827">Still, many iOS developers don’t focus on architecture when they
    build their apps, and there are some obvious reasons why.</st> <st c="2951">For
    example, developers prefer to see immediate results.</st> <st c="3008">Sometimes,
    it’s not only a matter of choice – there are deadlines to meet, and a lack of
    resources forces us to focus on releasing our features as quickly</st> <st c="3163">as
    possible.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2827">尽管如此，许多 iOS 开发者在构建应用时并没有关注架构，这有一些明显的理由。</st> <st c="2951">例如，开发者更喜欢看到即时的结果。</st>
    <st c="3008">有时，这不仅仅是一个选择的问题——有截止日期要遵守，资源不足迫使我们必须尽快</st> <st c="3163">发布我们的功能。</st>
- en: <st c="3175">However, ignoring good architectural planning is usually a result
    of a lack of experience and short-term focus, which gives a clue about how important</st>
    <st c="3327">architecture is.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3175">然而，忽视良好的架构规划通常是由于缺乏经验和短期关注，这为我们提供了关于架构重要性的线索。</st> <st c="3327">架构。</st>
- en: <st c="3343">Let’s list some of the influences</st> <st c="3377">of good architecture
    on</st> <st c="3402">our project:</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3343">让我们列出一些良好的架构对我们</st> <st c="3377">项目</st> <st c="3402">的影响：</st>
- en: '**<st c="3414">Maintainability</st>**<st c="3430">: Our projects can easily
    become more extensive and challenging to maintain.</st> <st c="3508">A good architecture
    makes our code base more straightforward to understand and read.</st> <st c="3593">It
    also makes it easier to modify</st> <st c="3627">and refactor.</st>'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3414">可维护性</st>**<st c="3430">：我们的项目可能会变得更大，维护起来更具挑战性。</st> <st c="3508">良好的架构使我们的代码库更容易理解和阅读。</st>
    <st c="3593">它还使修改</st> <st c="3627">和重构变得更加容易。</st>'
- en: '**<st c="3640">Scalability</st>**<st c="3652">: The ability to add more features
    while keeping our project simple and stable is a crucial key to app success.</st>
    <st c="3765">A bad architecture can require a significant overhaul whenever we
    want to add</st> <st c="3843">new features.</st>'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3640">可扩展性</st>**<st c="3652">：在保持我们的项目简单和稳定的同时添加更多功能是应用成功的关键。</st>
    <st c="3765">糟糕的架构可能需要在添加</st> <st c="3843">新功能时进行重大重构。</st>'
- en: '**<st c="3856">Flexibility</st>**<st c="3868">: A good architecture allows
    us to quickly change how our app works according to changes in requirements.</st>
    <st c="3975">It also helps us add new features or replace</st> <st c="4020">third-party
    frameworks.</st>'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3856">灵活性</st>**<st c="3868">：良好的架构使我们能够根据需求的变化快速更改应用的工作方式。</st> <st
    c="3975">它还帮助我们添加新功能或替换</st> <st c="4020">第三方框架。</st>'
- en: <st c="4043">These are some benefits of good architecture, but the picture is
    clear – we will mainly discuss</st> **<st c="4140">long-term influence</st>**<st
    c="4159">. Working</st> <st c="4169">hard to create more classes, layers, and
    protocols in the short term seems like a big hassle.</st> <st c="4263">Besides
    coding, good architecture requires upfront efforts such as good planning, tech
    design, and a good understanding of paradigms</st> <st c="4396">and patterns.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4043">这些都是良好建筑的一些好处，但图景很清晰——我们将主要讨论</st> **<st c="4140">长期影响</st>**<st
    c="4159">。短期内努力创建更多类、层和协议似乎是一个大麻烦。</st> <st c="4263">除了编码之外，良好的架构还需要前期努力，如良好的规划、技术设计和对范式和模式的良好理解</st>
    <st c="4396">。</st>
- en: <st c="4409">Before we discuss the different types of architecture, let’s define
    what architecture means and what defines</st> <st c="4519">good architecture.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4409">在我们讨论不同类型的建筑之前，让我们定义一下建筑的含义以及什么构成了</st> <st c="4519">好的建筑。</st>
- en: <st c="4537">Learning what exactly architecture</st> <st c="4572">is</st>
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="4537">了解建筑究竟是什么</st> <st c="4572">意味着</st>
- en: <st c="4575">Many developers</st> <st c="4592">are confused between architecture
    and what we call a “design patte</st><st c="4658">rn”.</st> <st c="4664">We previously
    touched on that when we discussed the different layers of knowledge (under the</st>
    *<st c="4757">Understanding the importance of architecture</st>* <st c="4801">section),
    and even though it sounds like a semantic difference, it’s crucial to understand
    the distinction.</st> <st c="4910">While architecture refers to the</st> *<st
    c="4943">high-level organization</st>* <st c="4966">of our app, such as layers,
    modules, and components, design patterns are</st> *<st c="5040">reusable solutions
    to</st>* *<st c="5062">common problems</st>*<st c="5077">.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4575">许多开发者</st> <st c="4592">在架构和我们所说的“设计模式”之间感到困惑。</st> <st c="4658">我们之前在讨论不同知识层次时（在</st>
    *<st c="4757">理解架构的重要性</st>* <st c="4801">部分）提到了这一点，尽管这听起来像是一个语义上的差异，但理解这种区别至关重要。</st>
    <st c="4910">虽然架构指的是我们应用的</st> *<st c="4943">高级组织</st>* <st c="4966">，例如层、模块和组件，但设计模式是</st>
    *<st c="5040">针对常见问题的可重用解决方案</st>* *<st c="5062">。</st>
- en: <st c="5078">To explain that better, let’s imagine a building.</st> <st c="5129">When
    planning a private house, we must decide its number of floors, entrance, roof,
    and garage In short, this is the</st> <st c="5246">house’s architecture.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5078">为了更好地解释这一点，让我们想象一座建筑。</st> <st c="5129">在规划私人住宅时，我们必须决定其楼层数、入口、屋顶和车库。简而言之，这就是</st>
    <st c="5246">房子的建筑。</st>
- en: <st c="5267">In contrast, each floor</st> <st c="5292">has its own goal and
    designation.</st> <st c="5326">For example, one floor can be the kitchen and living
    room, and the second would be the bedrooms.</st> <st c="5423">To accomplish that,
    we need to plan the internal design for each floor, deciding the sizes of the
    rooms, the door locations, and the different wires and water pipes.</st> <st c="5589">In
    most cases, there are no tricks here – there are standards to follow.</st> <st
    c="5662">These internal designs of the floors can be considered as design patterns
    – a reusable, specific solution to</st> <st c="5771">common problems.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，每一层楼都有自己的目标和指定用途。<st c="5292">例如，一层可以是厨房和客厅，而第二层则是卧室。</st> <st c="5326">为了实现这一点，我们需要为每一层楼规划内部设计，决定房间的尺寸、门的布局以及不同的电线和水管。</st>
    <st c="5423">在大多数情况下，这里没有技巧可言——需要遵循标准。</st> <st c="5589">这些楼层的内部设计可以被视为设计模式——针对常见问题的可重用、特定解决方案。</st>
- en: <st c="5787">Now, let’s go back to our mobile app.</st> <st c="5826">We should
    think of a mobile app’s structure as a private house.</st> <st c="5890">The data
    flows in different layers – data, business logic, and</st> **<st c="5953">User
    Interface</st>** <st c="5967">(</st>**<st c="5969">UI</st>**<st c="5971">).</st>
    <st c="5975">We</st> <st c="5978">can look at each layer as a different floor
    in our home.</st> <st c="6035">In each layer (or floor), we can use various design
    patterns to solve other problems.</st> <st c="6121">For example, we can use Singleton
    to manage shared resources or a coordinator to simplify complex</st> <st c="6219">navigation
    needs.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我们的移动应用。我们应该将移动应用的结构想象成一个私人住宅。数据在不同的层级中流动——数据、业务逻辑和**<st c="5953">用户界面</st>**（**<st
    c="5969">UI</st>**<st c="5971">）。我们可以将每一层看作是我们家里的不同楼层。在每一层（或楼层）中，我们可以使用各种设计模式来解决其他问题。例如，我们可以使用
    Singleton 来管理共享资源或协调器来简化复杂的导航需求。
- en: <st c="6236">The more design patterns we know, the more solutions</st> <st c="6290">we
    have.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道的更多设计模式，我们就有更多的解决方案。
- en: <st c="6298">Moreover, let’s continue with the house metaphor.</st> <st c="6349">In
    that case, we can come to another conclusion – our choice regarding architecture
    affects the different design patterns we use for our floors, including the floors’
    sizes and shapes, or even how they</st> <st c="6551">are connected.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，让我们继续使用房屋的隐喻。在这种情况下，我们可以得出另一个结论——我们关于架构的选择会影响我们用于楼层的设计模式，包括楼层的尺寸和形状，甚至它们是如何连接的。
- en: <st c="6565">So, what are the different types of architecture available, and
    how do we select an architecture that fits</st> <st c="6673">our needs?</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，有哪些不同的架构类型可供选择，我们如何选择一个适合我们需求的架构呢？
- en: <st c="6683">Going over the different architectures</st>
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述不同的架构
- en: <st c="6722">Developers make two common mistakes when choosing their project
    architecture.</st> <st c="6801">First, they often say, “</st>*<st c="6825">What
    architecture am I using for my app?</st> <st c="6867">MVVM,</st>* *<st c="6873">of
    course</st>*<st c="6882">!”</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者在选择项目架构时犯有两个常见的错误。首先，他们经常说，“</st>*<st c="6825">我正在使用什么架构来构建我的应用？</st> <st
    c="6867">MVVM，</st>* *<st c="6873">当然</st>*<st c="6882">！”
- en: <st c="6884">MVVM is not an architecture – it’s a design pattern that aims to
    solve state and logic management for a particular screen.</st> <st c="7008">Not
    only does it not handle the app structure but it also doesn’t even describe how
    we handle our screens in general.</st> <st c="7126">It only describes a particular
    screen, such as a login or a</st> <st c="7186">settings s</st><st c="7196">creen.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 不是一个架构——它是一个旨在解决特定屏幕状态和逻辑管理的模式。它不仅不处理应用结构，甚至也不描述我们通常如何处理我们的屏幕。它只描述了特定的屏幕，例如登录或设置屏幕。
- en: <st c="7203">The second mistake is the idea that we can only choose one of the
    most common and popular architectures from the list for our project.</st> <st
    c="7339">Most of the architectures you read about are, in fact, a set of principles
    that can help us decide how to structure</st> <st c="7455">our project.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个错误是认为我们只能从列表中选择最常见和最受欢迎的架构之一用于我们的项目。实际上，你读到的大多数架构实际上是一套原则，可以帮助我们决定如何构建项目。
- en: <st c="7467">Some principles provide flexibility and decoupling, and some may
    increase project overhead.</st> <st c="7560">We should always consider tradeoffs;
    these become even more important in</st> <st c="7633">architectural designs.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些原则提供了灵活性和解耦，而另一些可能会增加项目开销。我们应该始终考虑权衡；这些在架构设计中变得更加重要。
- en: '<st c="7655">Let’s start with the most fundamental architectural idea: the</st>
    <st c="7718">multi-layer architecture.</st>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的设计理念开始：多层架构。
- en: <st c="7743">Separating our project into layers</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将我们的项目分层
- en: <st c="7778">It’s</st> <st c="7784">worthwhile to</st> <st c="7798">take a moment
    and discuss two important terms I’m using here.</st> <st c="7860">The first is
    a</st> *<st c="7875">project</st>* <st c="7882">and not an</st> *<st c="7894">app</st>*<st
    c="7897">. The reason for that is that our architectural decisions are related
    to the whole project – pods, Swift packages, extensions, or even other apps.</st>
    <st c="8044">When we talk about structures, an app is only the expression of our
    product and how we</st> <st c="8131">deploy it.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7778">值得花点时间讨论一下我这里使用的两个重要术语。</st> <st c="7784">第一个是一个</st> *<st c="7875">项目</st>**
    <st c="7882">而不是一个</st> *<st c="7894">应用</st>**<st c="7897">。之所以这样，是因为我们的架构决策与整个项目相关——pods、Swift包、扩展，甚至是其他应用。</st>
    <st c="8044">当我们谈论结构时，应用只是我们产品的表达以及我们如何</st> <st c="8131">部署它。</st>
- en: <st c="8141">The second term is using</st> *<st c="8167">layers</st>* <st c="8173">instead
    of</st> *<st c="8185">tiers</st>* <st c="8190">– a typical mistake developers
    make.</st> <st c="8228">When discussing separating a system into tiers, we often
    refer to hardware separation – different computers, servers, routers, or other
    hardware components.</st> <st c="8385">We should use the term</st> *<st c="8408">layers</st>*
    <st c="8414">when discussing separating software such as an app</st> <st c="8466">or
    SDK.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8141">第二个术语是使用</st> *<st c="8167">层</st>** <st c="8173">而不是</st> *<st
    c="8185">层</st>** <st c="8190">——开发者常见的错误。</st> <st c="8228">当我们讨论将系统分层时，我们通常指的是硬件分离——不同的计算机、服务器、路由器或其他硬件组件。</st>
    <st c="8385">在讨论将软件如应用</st> <st c="8466">或SDK分层时，我们应该使用术语</st> *<st c="8408">层</st>**。</st>
- en: <st c="8473">Separating a project into layers, usually three, is a common architectural
    decision in many projects.</st> <st c="8576">The idea is that a basic project
    has at least three different levels of data and logic handling (</st>*<st c="8673">Figure
    15</st>**<st c="8683">.1</st>*<st c="8685">):</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目分层，通常分为三层，是许多项目中的常见架构决策。<st c="8576">这个想法是，一个基本项目至少有三个不同层次的数据和逻辑处理（</st>*<st
    c="8673">图15</st>**<st c="8683">.1</st>*<st c="8685">）：</st>
- en: '![Figure 15.1: The three-layer architecture](img/B21795_15_1.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1：三层架构](img/B21795_15_1.jpg)'
- en: '<st c="8745">Figure 15.1: The three-layer architecture</st>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8745">图15.1：三层架构</st>
- en: '*<st c="8786">Figure 15</st>**<st c="8796">.1</st>* <st c="8798">shows</st>
    <st c="8804">the three layers that we usually separate our</st> <st c="8851">app
    into.</st>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="8786">图15</st>**<st c="8796">.1</st>** <st c="8798">显示了</st> <st c="8804">我们通常将应用分为的三个层。</st>'
- en: <st c="8860">Let’s try to understand</st> <st c="8885">these layers:</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8860">让我们尝试理解</st> <st c="8885">这些层：</st>
- en: '**<st c="8898">Data</st>** <st c="8903">can</st> <st c="8908">sometimes be
    called</st> **<st c="8928">services</st>**<st c="8936">. The Data layer handles
    the data persistent store, the model entities, network handling, and primarily
    services that handle data at a low level regardless of the</st> <st c="9099">project
    logic.</st>'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8898">数据</st>** <st c="8903">有时也可以称为</st> **<st c="8928">服务</st>**<st
    c="8936">。数据层处理数据的持久存储、模型实体、网络处理以及主要处理低级别数据的各种服务，而不考虑</st> <st c="9099">项目的逻辑。</st>'
- en: '**<st c="9113">Business logic</st>** <st c="9128">can</st> <st c="9133">sometimes
    be called</st> **<st c="9153">domain</st>**<st c="9159">. The Business Logic layer
    handles the app’s main logic, including rules and</st> <st c="9236">data manipulations.</st>'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9113">业务逻辑</st>** <st c="9128">有时也可以称为</st> **<st c="9153">领域</st>**<st
    c="9159">。业务逻辑层处理应用的主要逻辑，包括规则和</st> <st c="9236">数据处理。</st>'
- en: '**<st c="9255">Presentation</st>** <st c="9268">handles</st> <st c="9277">the
    UI, user interaction,</st> <st c="9303">and navigation.</st>'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9255">表示层</st>** <st c="9268">处理</st> <st c="9277">UI、用户交互</st> <st
    c="9303">和导航。</st>'
- en: <st c="9318">There are patterns that have even more layers – for example, an</st>
    *<st c="9383">application</st>* <st c="9394">layer, which handles the different
    use cases and can be placed under the presentation layer, or an</st> *<st c="9494">infrastructure</st>*
    <st c="9508">layer that handles class extensions, utils,</st> <st c="9553">and
    more.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9318">有些模式甚至有更多层——例如，一个</st> *<st c="9383">应用</st>** <st c="9394">层，它处理不同的用例，可以放在表示层之下，或者一个</st>
    *<st c="9494">基础设施</st>** <st c="9508">层，它处理类扩展、工具</st> <st c="9553">等。</st>
- en: <st c="9562">If you are an experienced developer, the idea of separating a project
    should be obvious.</st> <st c="9652">Separating code creates a testable and maintainable
    structure that can be scaled over time.</st> <st c="9744">However, the idea of
    working with layers is not</st> <st c="9792">always evident.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9562">如果你是一位经验丰富的开发者，将项目分离的想法应该是显而易见的。</st> <st c="9652">分离代码创建了一个可测试和可维护的结构，随着时间的推移可以扩展。</st>
    <st c="9744">然而，使用层的想法并不</st> <st c="9792">总是显而易见。</st>
- en: <st c="9807">Ultimately, it comes down to how the data flows around</st> <st
    c="9863">the app.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9807">最终，这取决于数据在应用中的流动方式。</st>
- en: <st c="9871">Controlling the app data flow</st>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="9871">控制应用数据流</st>
- en: <st c="9901">Data flow is a</st> <st c="9916">central topic in any program.</st>
    <st c="9947">To clarify that term, we must examine how messages and data flow
    between the different app components.</st> <st c="10050">For example, when a user
    taps the</st> **<st c="10084">Save</st>** <st c="10088">button on one of their
    screens, we need to transform that tap into an actual logic</st> <st c="10171">decision
    and continue that to the persistent store, where we can save that information
    locally.</st> <st c="10268">The data flow doesn’t end here – at this point, we
    need to send a message back to the UI that a change has been made in the persistent
    store, and we should update what’s on</st> <st c="10441">the screen.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9901">数据流是</st> <st c="9916">任何程序的核心主题。</st> <st c="9947">为了阐明这个术语，我们必须检查不同应用组件之间消息和数据是如何流动的。</st>
    <st c="10050">例如，当用户在其屏幕上的一个按钮上点击</st> **<st c="10084">保存</st>** <st c="10088">按钮时，我们需要将这个点击转换成一个实际的逻辑</st>
    <st c="10171">决策，并将其继续到持久存储，在那里我们可以将信息本地保存。</st> <st c="10268">数据流不会在这里结束 – 在这一点上，我们需要向UI发送一个消息，表示持久存储中已经发生了变化，我们应该更新屏幕上的内容。</st>
- en: <st c="10452">This example demonstrates only a single use case.</st> <st c="10503">A
    standard mobile app may have hundreds of such cases, emphasizing the importance
    of considering how to divide</st> <st c="10614">our project.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10452">此示例仅演示了一个单一用例。</st> <st c="10503">标准移动应用可能有数百种此类情况，强调了考虑如何划分</st>
    <st c="10614">我们的项目的重要性。</st>
- en: <st c="10626">Now that we understand data flow, let’s discuss the</st> **<st
    c="10679">open</st>** <st c="10683">and</st> **<st c="10688">closed</st>** <st
    c="10694">layers.</st> <st c="10703">In a three-layer architecture, as described
    in</st> *<st c="10750">Figure 15</st>**<st c="10759">.1</st>*<st c="10761">, the
    presentation layer communicates with the business logic layer.</st> <st c="10830">However,
    does that mean that the presentation layer is also allowed to communicate with
    the</st> <st c="10922">data layer?</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10626">现在我们了解了数据流，让我们来讨论</st> **<st c="10679">开放</st>** <st c="10683">和</st>
    **<st c="10688">封闭</st>** <st c="10694">层。</st> <st c="10703">在三层架构中，如</st> *<st
    c="10750">图15</st>**<st c="10759">.1</st>*<st c="10761">所示，表示层与业务逻辑层进行通信。</st>
    <st c="10830">但是，这意味着表示层也可以与</st> <st c="10922">数据层</st>进行通信吗？
- en: <st c="10933">For example, the presentation may receive updates about data changes
    directly from the data layer.</st> <st c="11033">Working with business logic as
    middleware can be more complex and cumbersome in these cases.</st> <st c="11126">At
    that point, we must decide whether our layers are open</st> <st c="11184">or closed.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10933">例如，表示层可能直接从数据层接收数据变更的更新。</st> <st c="11033">在这些情况下，与业务逻辑作为中间件一起工作可能更加复杂和繁琐。</st>
    <st c="11126">在这种情况下，我们必须决定我们的层是开放的</st> <st c="11184">还是封闭的。</st>
- en: <st c="11194">An open layer allows</st> <st c="11216">direct interaction between
    the layer above and underneath.</st> <st c="11275">While open layers provide higher
    flexibility and simplicity, they can also increase coupling and reduce the separation</st>
    <st c="11394">of concerns.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11194">开放层允许</st> <st c="11216">上层和下层之间的直接交互。</st> <st c="11275">虽然开放层提供了更高的灵活性和简单性，但它们也可能增加耦合并减少关注点的分离。</st>
- en: <st c="11406">A</st> <st c="11408">closed layer enforces strict interaction,
    and each communication between its adjacent layers must go through the closed
    layer itself.</st> <st c="11543">A closed layer can increase the separation of
    concerns and loosen the coupling while decreasing flexibility and</st> <st c="11655">increasing
    complexity.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11406">一个</st> <st c="11408">封闭层强制执行严格的交互，并且其相邻层之间的每次通信都必须通过封闭层本身。</st>
    <st c="11543">封闭层可以增加关注点的分离并减少耦合，同时降低灵活性和</st> <st c="11655">增加复杂性。</st>
- en: <st c="11677">Discussing closed and opened layers might sound a little weird
    when working with three-layer architecture.</st> <st c="11785">The middle layer
    (business logic) is the only layer that can be either open or closed.</st> <st
    c="11872">However, we can decide whether the layer is strictly or</st> <st c="11928">selectively
    closed.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11677">在处理三层架构时，讨论封闭层和开放层可能听起来有些奇怪。</st> <st c="11785">中间层（业务逻辑）是唯一一个可以是开放或封闭的层。</st>
    <st c="11872">然而，我们可以决定层是严格封闭还是</st> <st c="11928">选择性封闭。</st>
- en: <st c="11947">Each layer is built</st> <st c="11967">from a set of components.</st>
    <st c="11994">For example, the presentation layer can be built from the different
    app screens or flows.</st> <st c="12084">The business logic layer can be built
    from the different logic parts of the app, and the data layer is built from the
    different services such as network, data,</st> <st c="12244">and security.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11947">每一层都是由一组组件构建的。</st> <st c="11967">例如，表示层可以由不同的应用程序屏幕或流程构建。</st>
    <st c="11994">业务逻辑层可以由应用程序的不同逻辑部分构建，而数据层是由不同的服务构建的，例如网络、数据</st> <st c="12244">和安全。</st>
- en: <st c="12257">In some situations, components from the presentation layer must
    communicate directly with the</st> <st c="12352">data layer.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12257">在某些情况下，表示层中的组件必须直接与</st> <st c="12352">数据层</st>进行通信。
- en: <st c="12363">Look at</st> *<st c="12372">Figure 15</st>**<st c="12381">.2</st>*<st
    c="12383">, which</st> <st c="12391">shows the basic three-layer architecture
    of a</st> <st c="12437">messaging app:</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12363">查看</st> *<st c="12372">图15</st>**<st c="12381">.2</st>*<st c="12383">，它</st>
    <st c="12391">展示了消息应用程序的基本三层架构：</st>
- en: '![Figure 15.2: Selective closed layer](img/B21795_15_2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2：选择封闭层](img/B21795_15_2.jpg)'
- en: '<st c="12593">Figure 15.2: Selective closed layer</st>'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12593">图15.2：选择封闭层</st>
- en: '*<st c="12628">Figure 15</st>**<st c="12638">.2</st>* <st c="12640">shows the
    same three layers we discussed earlier – presentation, business logic, and data.</st>
    <st c="12732">However, this time, we break the layer into different components.</st>
    <st c="12798">In addition, we display the various communication paths between
    the multiple components.</st> <st c="12887">For example, the login UI component
    communicates with the onboarding logic part of the app, and the messaging logic
    part communicates with the data and security components.</st> <st c="13060">Even
    though most communication goes through the business logic layer, we see some exceptions.</st>
    <st c="13154">For example, the following exceptions</st> <st c="13192">might apply:</st>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="12628">图15</st>**<st c="12638">.2</st>* <st c="12640">显示了之前讨论过的相同三层——表示层、业务逻辑层和数据层。</st>
    <st c="12732">然而，这次，我们将层分解为不同的组件。</st> <st c="12798">此外，我们展示了多个组件之间的各种通信路径。</st>
    <st c="12887">例如，登录UI组件与应用程序的入职逻辑部分通信，而消息逻辑部分与数据和安全组件通信。</st> <st c="13060">尽管大多数通信都通过业务逻辑层进行，但我们看到一些例外。</st>
    <st c="13154">例如，以下例外</st> <st c="13192">可能适用：</st>'
- en: <st c="13204">The Login UI component approaches the Security component directly,
    probably to understand the current</st> <st c="13307">authentication status</st>
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="13204">登录UI组件直接与安全组件通信，可能为了了解当前的</st> <st c="13307">认证状态</st>
- en: <st c="13328">The Thread UI component communicates with the Network components
    to present the network status in</st> <st c="13427">the UI</st>
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="13328">线程UI组件与网络组件通信，以在UI中展示网络状态</st> <st c="13427">的</st>
- en: <st c="13433">We can scratch</st> <st c="13448">our heads to find a way for
    these cases to go through the business logic layer; however, bypassing it and
    going directly to the data layer is perfectly acceptable in</st> <st c="13615">some
    cases.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13433">我们可以动脑筋想出一种方法让这些情况通过业务逻辑层；然而，在某些情况下，绕过它并直接访问数据层是完全可接受的。</st> <st
    c="13615">在某些情况下。</st>
- en: <st c="13626">The architecture we selected serves our project needs rather than
    vice versa.</st> <st c="13705">Yet we need to define a policy of bypassing the
    business logic layer since each exception, including those described in</st> *<st
    c="13825">Figure 15</st>**<st c="13834">.2</st>*<st c="13836">, creates another
    coupling in</st> <st c="13866">our structure.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13626">我们选择的架构服务于我们的项目需求，而不是相反。</st> <st c="13705">然而，我们需要定义一种绕过业务逻辑层的策略，因为每个例外，包括在</st>
    *<st c="13825">图15</st>**<st c="13834">.2</st>*<st c="13836">中描述的，都会在我们的结构中造成另一种耦合。</st>
- en: <st c="13880">We discussed the three layers of architecture, but is it always
    three?</st> <st c="13952">Do we have more layers?</st> <st c="13976">Let’s find
    out whether creating a more complex yet useful architecture</st> <st c="14047">is
    possible.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13880">我们讨论了架构的三个层级，但这是否总是三个层级？</st> <st c="13952">我们是否有更多的层级？</st> <st
    c="13976">让我们找出是否有可能创建一个更复杂但更有用的架构。</st> <st c="14047">是可能的。</st>
- en: <st c="14059">Adding more layers</st>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="14059">添加更多层级</st>
- en: <st c="14078">Working with</st> <st c="14091">three layers is the sweet spot
    between simplicity and good separations.</st> <st c="14164">However, sometimes,
    the principle of separation of concerns still needs to be fulfilled in big projects.</st>
    <st c="14269">Even though it looks very straightforward to have one layer for
    the presentation and another one for the business logic, there are some dilemmas
    that</st> <st c="14419">need clarification.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14078">与</st> <st c="14091">三层协同工作是在简单性和良好分离之间的最佳平衡点。</st> <st c="14164">然而，在大项目中，有时仍需要满足关注点分离的原则。</st>
    <st c="14269">尽管只有一个层用于展示和另一个层用于业务逻辑看起来非常直接，但仍然存在一些需要澄清的困境。</st> <st c="14419">需要澄清。</st>
- en: <st c="14438">Let’s take, for example, two different components we may have
    in an iOS app – a user service and a payment service.</st> <st c="14555">Both
    are part of the app’s business logic.</st> <st c="14598">When the user wants to
    make a purchase, we want to check their role using the user service and then go
    to the payment service to make the purchase.</st> <st c="14746">Right after the
    purchase, we want to navigate the user to a screen and show them that the payment
    was successful.</st> <st c="14860">So, we can see that we have a use case that
    involves incorporating different business logic services and coordinating different
    screens (</st>*<st c="14997">Figure 15</st>**<st c="15007">.3</st>*<st c="15009">):</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14438">以iOS应用程序中可能拥有的两个不同组件为例——用户服务和支付服务。</st> <st c="14555">两者都是应用程序业务逻辑的一部分。</st>
    <st c="14598">当用户想要进行购买时，我们想使用用户服务来检查他们的角色，然后转到支付服务进行购买。</st> <st c="14746">购买后，我们想将用户导航到屏幕并显示支付成功。</st>
    <st c="14860">因此，我们可以看到我们有一个涉及整合不同的业务逻辑服务和协调不同屏幕的用例（</st>*<st c="14997">图15</st>**<st
    c="15007">.3</st>*<st c="15009">）：</st>
- en: '![Figure 15.3: The payment use case, combining multiple components and layers](img/B21795_15_3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3：支付用例，结合多个组件和层](img/B21795_15_3.jpg)'
- en: '<st c="15109">Figure 15.3: The payment use case, combining multiple components
    and layers</st>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15109">图15.3：支付用例，结合多个组件和层</st>
- en: <st c="15184">Do we need</st> <st c="15196">to manage that use case in the presentation
    logic, in the business logic, or half here and half there?</st> <st c="15299">Well,
    chances are that this logic is spread across components or centralized in one
    of the screen view models.</st> <st c="15410">Remember that a view model handles
    UI states rather than app logic in</st> <st c="15480">most cases.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15184">我们需要</st> <st c="15196">在展示逻辑、业务逻辑，还是在这里和那里的一半来管理该用例吗？</st> <st
    c="15299">好吧，这种逻辑可能分布在组件中，或者集中在一个屏幕视图模型中。</st> <st c="15410">记住，在大多数情况下，视图模型处理的是UI状态而不是应用程序逻辑。</st>
- en: <st c="15491">The problem of handling use cases bundled with navigation is not
    new, and in apps that are more complex and require more flexibility, this needs
    to be taken into account when designing our</st> <st c="15681">app structure.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15491">处理与导航捆绑的用例的问题并不新鲜，在更复杂且需要更多灵活性的应用程序中，在设计我们的</st> <st c="15681">应用程序结构时需要考虑这一点。</st>
- en: <st c="15695">So, to separate our concerns, we can add another layer – the</st>
    **<st c="15757">Application</st>** <st c="15768">layer, which can handle a specific
    app use case (</st>*<st c="15818">Figure 15</st>**<st c="15828">.4</st>*<st c="15830">):</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15695">因此，为了分离我们的关注点，我们可以添加另一个层——</st> **<st c="15757">应用</st>** <st
    c="15768">层，它可以处理特定的应用程序用例（</st>*<st c="15818">图15</st>**<st c="15828">.4</st>*<st
    c="15830">）：</st>
- en: '![Figure 15.4: A four-layer architecture](img/B21795_15_4.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4：四层架构](img/B21795_15_4.jpg)'
- en: '<st c="16035">Figure 15.4: A four-layer architecture</st>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16035">图15.4：四层架构</st>
- en: '*<st c="16073">Figure 15</st>**<st c="16083">.4</st>* <st c="16085">shows an</st>
    <st c="16094">architecture design similar to</st> *<st c="16126">Figure 15</st>**<st
    c="16135">.2</st>*<st c="16137">, this time with the Application layer.</st> <st
    c="16177">The Application layer has four use cases: Sign In,</st> **<st c="16228">Create
    Contact</st>**<st c="16242">,</st> **<st c="16244">Delete Contact</st>**<st c="16258">,
    and</st> **<st c="16264">Create group chat</st>**<st c="16281">. These use cases
    handle everything from calling functions in other components to navigation.</st>
    <st c="16375">The Application layer makes the business and presentation layers
    cleaner from specific</st> <st c="16462">app logic.</st>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="16073">图15</st>**<st c="16083">.4</st>* <st c="16085">显示了与</st> *<st
    c="16126">图15</st>**<st c="16135">.2</st>*<st c="16137">相似的一种</st>架构设计，这次加入了应用层。</st>
    <st c="16177">应用层有四个用例：登录，**<st c="16228">创建联系人</st>**<st c="16242">，**<st c="16244">删除联系人</st>**<st
    c="16258">，以及</st> **<st c="16264">创建群聊</st>**<st c="16281">。这些用例处理从调用其他组件中的函数到导航的所有事情。</st>
    <st c="16375">应用层使业务层和表示层从特定的</st> <st c="16462">应用逻辑</st>中变得更加清晰。</st>'
- en: <st c="16472">Do we have more layers we</st> <st c="16499">can add?</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16472">我们还能添加更多层吗？</st>
- en: <st c="16507">The Application layer coordinates multiple components to create
    an app-specific logic.</st> <st c="16595">We can implement the same concept on
    the bottom side of the architecture, between the business logic and the</st> <st
    c="16704">data layer.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16507">应用层协调多个组件以创建特定于应用的逻辑。</st> <st c="16595">我们可以在架构的底部实现相同的概念，即在业务逻辑和数据层之间。</st>
- en: <st c="16715">For example, let’s discuss a data sync process.</st> <st c="16764">Retrieving
    data from the network and storing it in the persistent store is a complex process
    that involves error handling and handling various edge cases.</st> <st c="16919">Is
    it part of the business logic or the</st> <st c="16959">data layer?</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16715">例如，让我们讨论一个数据同步过程。</st> <st c="16764">从网络检索数据并将其存储在持久存储中是一个复杂的过程，涉及错误处理和处理各种边缘情况。</st>
    <st c="16919">这是业务逻辑的一部分还是</st> <st c="16959">数据层的一部分？</st>
- en: <st c="16970">Data manipulation</st> <st c="16988">and</st> **<st c="16993">Create,
    Read, Update, and Delete</st>** <st c="17025">(</st>**<st c="17027">CRUD</st>**<st
    c="17031">) operations are also tasks that are unclear on which layer</st> <st
    c="17092">handles them.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16970">数据操作</st> <st c="16988">和**<st c="16993">创建、读取、更新和删除</st>** <st
    c="17025">(**<st c="17027">CRUD</st>**<st c="17031">)操作也是不清楚在哪个层处理这些任务的。</st>
- en: <st c="17105">So, to handle tasks that are not business logic but focus on accessing
    and managing data from various sources, we can add</st> <st c="17228">another
    layer called the</st> **<st c="17253">Data Access layer</st>** <st c="17270">(</st>*<st
    c="17272">Figure 15</st>**<st c="17281">.5</st>*<st c="17283">):</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17105">因此，为了处理不是业务逻辑但专注于从各种来源访问和管理数据的任务，我们可以添加</st> <st c="17228">另一个称为</st>
    **<st c="17253">数据访问层</st>** <st c="17270">(</st>*<st c="17272">图15</st>**<st
    c="17281">.5</st>*<st c="17283">):</st>
- en: '![Figure 15.5: Data Access layer](img/B21795_15_5.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5：数据访问层](img/B21795_15_5.jpg)'
- en: '<st c="17529">Figure 15.5: Data Access layer</st>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17529">图15.5：数据访问层</st>
- en: '*<st c="17559">Figure 15</st>**<st c="17569">.5</st>* <st c="17571">shows our</st>
    <st c="17582">architecture from</st> *<st c="17600">Figure 15</st>**<st c="17609">.4</st>*<st
    c="17611">, now with an additional layer – the Data Access layer, which handles
    sync service, CRUD operations, and data mapping, transforming data model objects
    into business</st> <st c="17776">logic entities.</st>'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="17559">图15</st>**<st c="17569">.5</st>* <st c="17571">显示了我们的</st> <st
    c="17582">架构从</st> *<st c="17600">图15</st>**<st c="17609">.4</st>*<st c="17611">，现在增加了一个额外的层——数据访问层，该层处理同步服务、CRUD操作和数据映射，将数据模型对象转换为业务</st>
    <st c="17776">逻辑实体。</st>'
- en: <st c="17791">Having more than three layers may sound too complex and imply
    over-engineering.</st> <st c="17872">However, this strategy ensures excellent
    separation of concerns between the different layers.</st> <st c="17966">The business
    logic doesn’t involve data manipulation, and the presentation layer doesn’t handle
    complex use cases.</st> <st c="18081">In medium and large apps, separating our
    project into four or five layers can pay off when our app</st> <st c="18180">gets
    bigger.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17791">拥有超过三层可能会听起来过于复杂，并暗示过度设计。</st> <st c="17872">然而，这种策略确保了不同层之间关注点的优秀分离。</st>
    <st c="17966">业务逻辑不涉及数据操作，表示层不处理复杂用例。</st> <st c="18081">在中型和大型应用中，当我们的应用变得更大时，将我们的项目分为四到五层可能会带来回报。</st>
- en: <st c="18192">Separating into different layers is only one perspective we can
    consider in our project.</st> <st c="18282">I mentioned earlier that architectural
    patterns such as this act more like principles.</st> <st c="18369">The real power
    comes when we combine different patterns.</st> <st c="18426">Let’s explore the
    modular</st> <st c="18452">architectural pattern.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18192">将项目分层只是我们可以考虑的视角之一。</st> <st c="18282">我之前提到过，像这样的架构模式更像是一种原则。</st>
    <st c="18369">真正的力量在于我们结合不同的模式。</st> <st c="18426">让我们来探讨模块化架构模式。</st>
- en: <st c="18474">Separating our project into modules</st>
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="18474">将我们的项目划分为模块</st>
- en: <st c="18510">I mentioned that</st> <st c="18527">separating into layers is
    only one perspective we can look at in our project.</st> <st c="18606">However,
    what does</st> <st c="18625">it mean?</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18510">我提到过</st> <st c="18527">将项目分层只是我们可以从项目中观察到的视角之一。</st> <st c="18606">然而，这究竟意味着什么？</st>
- en: '<st c="18633">Let’s take our messaging app as an example.</st> <st c="18678">The
    different layers represent different concerns: presentation, business logic, and
    data.</st> <st c="18769">Our app data flows through the layers from the UI to
    the data</st> <st c="18831">and back.</st>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18633">以我们的即时通讯应用程序为例。</st> <st c="18678">不同的层代表不同的关注点：展示、业务逻辑和数据。</st>
    <st c="18769">我们的应用程序数据从UI层流向数据层，然后再返回。</st>
- en: <st c="18840">Another way to look at our app is through code units that encapsulate
    a set of functionalities or a</st> <st c="18941">specific business domain unit.</st>
    <st c="18972">We can call these code</st> <st c="18995">units</st> **<st c="19001">modules</st>**<st
    c="19008">.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18840">另一种看待我们的应用程序的方式是通过封装一组功能或特定业务领域单位的代码单元。</st> <st c="18941">我们可以将这些代码单元称为**<st
    c="19001">模块</st>**。</st>
- en: <st c="19009">Understanding the different considerations when working on modules</st>
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="19009">了解在模块开发中需要考虑的不同因素</st>
- en: <st c="19076">Separating our</st> <st c="19091">project into modules requires
    careful consideration, as this step is crucial for the app’s structure over time.</st>
    <st c="19204">In a messaging app, for example, the modules can be a user authentication
    module, user profile module, contacts module, and messaging module.</st> <st c="19346">These
    modules reflect the app’s different domains and the decision to divide our app
    is</st> <st c="19434">very flexible.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19076">将我们的项目划分为模块需要仔细考虑，因为这个步骤对于应用程序的结构随时间发展至关重要。</st> <st c="19091">例如，在即时通讯应用程序中，模块可以是用户认证模块、用户资料模块、联系人模块和消息模块。</st>
    <st c="19204">这些模块反映了应用程序的不同领域，并且将我们的应用程序划分为模块的决定非常灵活。</st>
- en: <st c="19448">However, some key factors can help</st> <st c="19484">us decide:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19448">然而，一些关键因素可以帮助我们决定：</st>
- en: '**<st c="19494">Functionality and business domain</st>**<st c="19528">: We
    already mentioned this in the previous paragraph.</st> <st c="19584">Breaking
    down the app into core features can be an excellent start to understanding our
    project’s different modules – logic, song player, reminders, onboarding,</st>
    <st c="19745">and more.</st>'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="19494">功能性和业务领域</st>**<st c="19528">：我们已经在上一段中提到过这一点。</st> <st c="19584">将应用程序分解为核心功能可以是我们理解项目不同模块——逻辑、歌曲播放器、提醒、入门等——的一个很好的开始。</st>'
- en: '**<st c="19754">Reusability</st>**<st c="19766">: Grouping functionalities
    we use across different parts of the app is another way of understanding how to
    create a module.</st> <st c="19891">For example, if our app performs different
    HTTP requests, we may create a network module to manage all the API calls.</st>
    <st c="20009">Another example can be shared components – if we use the same button
    on different screens, that can be a sign that it should be part of a UI module
    that contains different</st> <st c="20181">reusable components.</st>'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="19754">可重用性</st>**<st c="19766">：将我们在应用程序的不同部分使用的功能分组是理解如何创建模块的另一种方式。</st>
    <st c="19891">例如，如果我们的应用程序执行不同的HTTP请求，我们可能会创建一个网络模块来管理所有的API调用。</st> <st c="20009">另一个例子是共享组件——如果我们使用相同的按钮在不同的屏幕上，这可能是一个迹象，表明它应该是包含不同可重用组件的UI模块的一部分。</st>'
- en: '**<st c="20201">Decoupling</st>**<st c="20212">: Our module should be decoupled
    from the other modules as much as possible.</st> <st c="20290">The level of interdependence
    the module has can define whether it was an excellent call to create it as a module.</st>
    <st c="20404">In addition, if it’s possible to make a clear interface for the
    module, that’s another indication it can be a</st> <st c="20514">good module.</st>'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20201">解耦</st>**<st c="20212">：我们的模块应该尽可能地与其他模块解耦。</st> <st c="20290">模块之间的相互依赖程度可以定义是否将其创建为模块是一个优秀的决定。</st>
    <st c="20404">此外，如果可以为模块创建一个清晰的接口，这也是它可能是一个</st> <st c="20514">好模块的另一个迹象。</st>'
- en: '**<st c="20526">Collaboration</st>**<st c="20540">: Imagine that</st> <st c="20556">several
    teams are working on our project.</st> <st c="20598">The fact that they can work
    without stepping on each other’s toes signals good module separation.</st> <st
    c="20696">Note that the relevance of this rule remains the same, whether we are
    a team of one person or five teams with six developers each.</st> <st c="20827">The
    principle is</st> <st c="20844">what counts.</st>'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="20526">协作</st>**<st c="20540">：想象一下</st> <st c="20556">几个团队正在我们的项目上工作。</st>
    <st c="20598">他们可以不互相干扰地工作，这表明模块的分离做得很好。</st> <st c="20696">请注意，无论我们是一个人的团队还是由六个开发者组成的五个团队，这条规则的相关性都是一样的。</st>
    <st c="20827">原则是</st> <st c="20844">最重要的。</st>'
- en: '<st c="20856">We must ask ourselves: can we create another app and use some
    of our modules in the new app, like using Lego bricks?</st> <st c="20974">Can
    we test each module separately?</st> <st c="21010">These questions give some sense
    of whether our modules are indeed independent or have</st> <st c="21096">tight
    coupling.</st>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20856">我们必须问自己：我们能否创建另一个应用程序，并在新应用程序中使用我们的一些模块，就像使用乐高积木一样？</st> <st c="20974">我们能否单独测试每个模块？</st>
    <st c="21010">这些问题可以让我们对模块是否真正独立或存在</st> <st c="21096">紧密耦合有一定的认识。</st>
- en: <st c="21111">Organizing the code in our project</st>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="21111">组织我们项目中的代码</st>
- en: <st c="21146">A few words</st> <st c="21159">about organizing our code into
    modules – modules are an abstract definition, as there’s no official way of technically
    separating our code into modules.</st> <st c="21312">However, we can distinguish
    between two approaches –</st> **<st c="21365">physical</st>** <st c="21373">and</st>
    **<st c="21378">functional</st>**<st c="21388">:</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21146">关于将我们的代码组织成模块的几点说明</st> <st c="21159">——模块是一个抽象的定义，因为没有任何官方的技术方法可以将我们的代码正式地分成模块。</st>
    <st c="21312">然而，我们可以区分两种方法——</st> **<st c="21365">物理</st>** <st c="21373">和</st>
    **<st c="21378">功能</st>**<st c="21388">：</st>
- en: <st c="21390">In the physical approach, we create our modules using a dedicated
    tool.</st> <st c="21462">CocoaPods, Swift Packages, and XCFrameworks, for example,
    provide a way of physically encapsulating our code into</st> <st c="21576">code
    units.</st>
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="21390">在物理方法中，我们使用专用工具创建我们的模块。</st> <st c="21462">例如，CocoaPods、Swift
    Packages和XCFrameworks提供了一种将我们的代码物理封装成</st> <st c="21576">代码单元的方法。</st>
- en: <st c="21587">In the functional approach, we do not use any specific tool but
    instead organize the code into folders.</st> <st c="21692">This simple approach
    is great for small projects</st> <st c="21741">or teams.</st>
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="21587">在功能方法中，我们不使用任何特定工具，而是将代码组织成文件夹。</st> <st c="21692">这种简单的方法非常适合小型项目</st>
    <st c="21741">或团队。</st>
- en: '<st c="21750">The primary consideration here is obvious: reusability and independence
    in the physical approach versus simplicity and flexibility in the functional approach.</st>
    <st c="21910">However, let’s delve deeper and make this comparison more practical
    and relevant to our day-to-day work as</st> <st c="22017">iOS developers.</st>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21750">在这里的主要考虑因素很明显：物理方法中的可重用性和独立性，与功能方法中的简洁性和灵活性。</st> <st c="21910">然而，让我们更深入地探讨，使这种比较更加实用和与我们作为iOS开发者日常工作的相关性。</st>
    <st c="22017">iOS开发者。</st>
- en: <st c="22032">Creating a new project and understanding the different modules
    can be quite challenging.</st> <st c="22122">On the one hand, good planning is
    crucial for the success of our project development over time.</st> <st c="22218">On
    the other hand, it’s impossible to predict how our project will evolve over the
    years.</st> <st c="22308">So, what we need at the beginning is flexibility.</st>
    <st c="22358">Therefore, starting with a functional approach, which involves creating
    modules by folders, might be the right approach for</st> <st c="22482">most projects.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22032">创建一个新项目并理解不同的模块可能相当具有挑战性。</st> <st c="22122">一方面，良好的规划对于我们的项目开发在时间上的成功至关重要。</st>
    <st c="22218">另一方面，预测我们的项目在未来几年如何发展是不可能的。</st> <st c="22308">因此，我们在一开始需要的是灵活性。</st>
    <st c="22358">因此，从功能方法开始，即通过文件夹创建模块，可能是大多数项目的正确方法。</st>
- en: <st c="22496">As the project grows, the advantage of having flexibility in our
    modules can become its downfall.</st> <st c="22595">One of the great things about
    the physical approach is that we create clear boundaries</st> <st c="22682">between
    our modules by encapsulating our code into pods or packages.</st> <st c="22751">These
    boundaries prevent us from including external classes and types without handling
    the different dependencies correctly.</st> <st c="22876">They also force us to
    declare a clear interface for the module, as private and internal functions and
    classes are inaccessible from the outside.</st> <st c="23021">These restrictions
    are essential and valuable as the project evolves and the development team grows.</st>
    <st c="23122">The different pods or packages allow other teams to work on each
    module and build and test it separately.</st> <st c="23228">It even lets us share
    the same module between</st> <st c="23274">various projects.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22496">随着项目的增长，我们模块的灵活性可能成为其劣势。</st> <st c="22595">物理方法的一个优点是我们通过将代码封装到pod或包中，为我们的模块创建了清晰的边界。</st>
    <st c="22682">这些边界阻止我们在不正确处理不同依赖项的情况下包含外部类和类型。</st> <st c="22751">它们还迫使我们为模块声明一个清晰的接口，因为私有和内部函数和类从外部不可访问。</st>
    <st c="22876">随着项目的演变和开发团队的壮大，这些限制是基本且有价值的。</st> <st c="23021">不同的pod或包允许其他团队独立地对每个模块进行工作、构建和测试。</st>
    <st c="23122">它甚至允许我们在</st> <st c="23228">不同的项目中共享相同的模块。</st>
- en: <st c="23291">So, now that we are convinced that modules are important, how
    does the idea of layers fit in?</st> <st c="23386">Do we have to choose between
    layers and modules?</st> <st c="23435">Or is it the</st> <st c="23448">same thing?</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23291">既然我们已经确信模块很重要，那么层级的想法如何适应呢？</st> <st c="23386">我们必须在层级和模块之间做出选择吗？</st>
    <st c="23435">还是它们是</st> <st c="23448">同一件事？</st>
- en: <st c="23459">Let’s try to put things</st> <st c="23484">in order.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23459">让我们尝试将事物</st> <st c="23484">整理有序。</st>
- en: <st c="23493">Combining the multi-layer architecture with modules</st>
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23493">将多层架构与模块相结合</st>
- en: <st c="23545">We previously</st> <st c="23559">said that multi-layers and modules
    are more like architectural patterns or concepts.</st> <st c="23645">They are
    the guidelines for structuring our app and it is common practice to combine different
    concepts and patterns in our projects rather than stick with only</st> <st c="23806">one
    pattern.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23545">我们之前</st> <st c="23559">提到，多层和模块更像是架构模式或概念。</st> <st c="23645">它们是我们构建应用程序的指南，在我们的项目中结合不同的概念和模式是常见的做法，而不是仅仅</st>
    <st c="23806">坚持一种模式。</st>
- en: <st c="23818">Let’s take the app onboarding module, for example (</st>*<st c="23870">Figure
    15</st>**<st c="23880">.6</st>*<st c="23882">):</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23818">以应用入职模块为例（</st>*<st c="23870">图15</st>**<st c="23880">.6</st>*<st
    c="23882">）：</st>
- en: '![Figure 15.6: The onboarding module](img/B21795_15_6.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6：入职模块](img/B21795_15_6.jpg)'
- en: '<st c="24104">Figure 15.6: The onboarding module</st>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24104">图15.6：入职模块</st>
- en: '*<st c="24138">Figure 15</st>**<st c="24148">.6</st>* <st c="24150">shows the
    onboarding module structure divided into four different layers.</st> <st c="24225">One
    way to combine modular and multi-layer architectures is to create a matrix structure
    separating each module into different layers.</st> <st c="24360">In this case,
    the onboarding module has a presentation, coordinator, business logic,</st> <st
    c="24445">and data.</st>'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="24138">图15</st>**<st c="24148">.6</st>* <st c="24150">展示了分层的入职模块结构，分为四个不同的层级。</st>
    <st c="24225">将模块化和多层架构相结合的一种方法是将每个模块分离到不同的层级中创建一个矩阵结构。</st> <st c="24360">在这种情况下，入职模块包括展示、协调器、业务逻辑，</st>
    <st c="24445">和数据。</st>'
- en: <st c="24454">The other</st> <st c="24465">case involves layers built from several
    modules.</st> <st c="24514">In this case, each layer is a business unit built
    from</st> <st c="24569">several modules.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24454">另一种情况涉及由几个模块构建的层。</st> <st c="24465">在这种情况下，每一层都是由几个模块构建的业务单元。</st>
- en: <st c="24585">Let’s compare</st> <st c="24600">both architectures:</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24585">让我们比较</st> <st c="24600">这两个架构：</st>
- en: '![Figure 15.7: Comparing the two approaches of combining modules and layers](img/B21795_15_7.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7：比较模块和层的两种组合方法](img/B21795_15_7.jpg)'
- en: '<st c="24863">Figure 15.7: Comparing the two approaches of combining modules
    and layers</st>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24863">图15.7：比较模块和层的两种组合方法</st>
- en: '*<st c="24936">Figure 15</st>**<st c="24946">.7</st>* <st c="24948">shows the
    two approaches we discussed side by side.</st> <st c="25001">At first glance,
    these two approaches look similar, just from different points of view.</st> <st
    c="25089">However, they represent two different project requirements and dramatically
    influence scalability, independence,</st> <st c="25202">and coupling.</st>'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="24936">图15</st>**<st c="24946">.7</st>* <st c="24948">展示了我们讨论的两种方法并排展示。</st>
    <st c="25001">乍一看，这两种方法看起来很相似，只是从不同的角度来看。</st> <st c="25089">然而，它们代表了两个不同的项目需求，并且极大地影响了可扩展性、独立性和耦合性。</st>'
- en: <st c="25215">Let’s take, for example, the data modules.</st> <st c="25259">On
    the right side (</st>**<st c="25278">Modules comprising multiple layers</st>**<st
    c="25313">), we can see that each module has its data module.</st> <st c="25366">However,
    on the left side (</st>**<st c="25393">Layers built from multiple modules</st>**<st
    c="25428">), we have one data module that can serve various screens and business
    units.</st> <st c="25507">The same goes for more data layer modules such as analytics,
    network,</st> <st c="25577">and security.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25215">例如，让我们看看数据模块。</st> <st c="25259">在右侧（</st>**<st c="25278">包含多个层的模块</st>**<st
    c="25313">），我们可以看到每个模块都有自己的数据模块。</st> <st c="25366">然而，在左侧（</st>**<st c="25393">由多个模块构建的层</st>**<st
    c="25428">），我们有一个可以服务于各种屏幕和业务单元的数据模块。</st> <st c="25507">对于更多数据层模块，如分析、网络和安全性也是如此。</st>
- en: <st c="25590">When we consider it, for a module to be truly independent, it
    needs to contain all the layers and services.</st> <st c="25699">This also means
    that we’ll have to duplicate some of the code in</st> <st c="25764">some cases.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25590">当我们考虑时，为了使模块真正独立，它需要包含所有层和服务。</st> <st c="25699">这也意味着在某些情况下，我们可能需要复制一些代码在</st>
    <st c="25764">某些情况下。</st>
- en: <st c="25775">As always, we have a tradeoff between encapsulation and independence
    versus centralized logic and consistency.</st> <st c="25887">Therefore, in practice,
    we must balance that, create a hybrid approach, and combine elements of both methods
    (</st>*<st c="25997">Figure 15</st>**<st c="26007">.8</st>*<st c="26009">):</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25775">一如既往，我们在封装性和独立性以及集中逻辑和一致性之间有一个权衡。</st> <st c="25887">因此，在实践中，我们必须平衡这一点，创建一个混合方法，并结合两种方法（</st>*<st
    c="25997">图15</st>**<st c="26007">.8</st>*<st c="26009">）的元素：</st>
- en: '![Figure 15.8: Combining layers built from modules and modules comprising multiple
    layers](img/B21795_15_8.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8：由模块构建的层和包含多个层的模块的组合](img/B21795_15_8.jpg)'
- en: '<st c="26234">Figure 15.8: Combining layers built from modules and modules
    comprising multiple layers</st>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26234">图15.8：由模块构建的层和包含多个层的模块的组合</st>
- en: '*<st c="26321">Figure 15</st>**<st c="26331">.8</st>* <st c="26333">presents
    the hybrid approach we discussed.</st> <st c="26377">Notice that we have several
    modules –</st> **<st c="26415">User</st>**<st c="26419">,</st> **<st c="26421">Messages</st>**<st
    c="26429">, and</st> **<st c="26435">Notifications</st>** <st c="26448">– each
    containing screens and business logic.</st> <st c="26495">However, the data, network,
    and analytics services are shared across the</st> <st c="26568">different modules.</st>'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="26321">图15</st>**<st c="26331">.8</st>* <st c="26333">展示了我们讨论的混合方法。</st>
    <st c="26377">注意，我们有几个模块——</st> **<st c="26415">用户</st>**<st c="26419">、**<st
    c="26421">消息</st>**<st c="26429">和**<st c="26435">通知</st>** <st c="26448">——每个都包含屏幕和业务逻辑。</st>
    <st c="26495">然而，数据、网络和分析服务是在不同的模块之间共享的。</st>'
- en: <st c="26586">The hybrid</st> <st c="26598">approach means that the different
    modules are only partially independent.</st> <st c="26672">On the other hand,
    it expresses a nice balance between reusability</st> <st c="26739">and encapsulation.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26586">混合方法意味着不同的模块只有部分独立性。</st> <st c="26672">另一方面，它表达了重用性和封装性之间的一种很好的平衡。</st>
- en: <st c="26757">We can take it even further and share more logic, utilities, and</st>
    <st c="26823">UI components.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26757">我们可以更进一步，共享更多的逻辑、实用工具和</st> <st c="26823">UI组件。</st>
- en: <st c="26837">The multi-layer and module architectures are straightforward for
    most developers.</st> <st c="26920">They represent a logical way of examining
    apps and projects – either by levels of concerns, domains,</st> <st c="27021">or
    both.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26837">多层和模块架构对大多数开发者来说都很直观。</st> <st c="26920">它们代表了一种检查应用和项目的逻辑方式——无论是通过关注层、领域</st>
    <st c="27021">，还是两者结合。</st>
- en: <st c="27029">Can we take a different approach to architecture?</st> <st c="27080">Let’s
    try looking at our app differently – using</st> **<st c="27129">hexagonal architecture</st>**<st
    c="27151">.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27029">我们能否采用不同的架构方法？</st> <st c="27080">让我们尝试以不同的方式看待我们的应用——使用</st>
    **<st c="27129">六边形架构</st>**<st c="27151">。</st>
- en: <st c="27152">Building hexagonal architecture</st>
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27152">构建六边形架构</st>
- en: <st c="27184">Multi-layer</st> <st c="27197">architecture describes an app as
    data flowing through different layers of concerns.</st> <st c="27281">The module
    architecture describes the app as different modules communicating with</st> <st
    c="27363">each other.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27184">多层架构描述了应用作为数据通过不同关注层流动。</st> <st c="27281">模块架构描述了应用作为不同模块之间的通信。</st>
- en: <st c="27374">To go over an architecture with a different approach, we discuss
    the meaning of an app.</st> <st c="27463">What is an app?</st> <st c="27479">Is
    it the screens?</st> <st c="27498">Is it</st> <st c="27504">the logic?</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27374">为了探讨一种不同的架构方法，我们讨论一下应用的意义。</st> <st c="27463">什么是应用？</st> <st
    c="27479">它是屏幕吗？</st> <st c="27498">它是</st> <st c="27504">逻辑吗？</st>
- en: <st c="27514">In hexagonal architecture, we</st> <st c="27545">consider the
    business logic to be the heart and soul of the app.</st> <st c="27610">Let’s take
    our messaging app example.</st> <st c="27648">The app’s core is the messaging
    logic, the way we authenticate, and the different data models.</st> <st c="27743">We
    call that</st> <st c="27756">part of the business logic the</st> **<st c="27787">domain
    model</st>**<st c="27799">.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27514">在六边形架构中，我们</st> <st c="27545">认为业务逻辑是应用的核心和灵魂。</st> <st c="27610">以我们的消息应用为例。</st>
    <st c="27648">应用的核心是消息逻辑，包括我们的认证方式和不同的数据模型。</st> <st c="27743">我们将这部分业务逻辑称为</st>
    <st c="27756">**<st c="27787">领域模型</st>**</st> <st c="27799">。</st>
- en: <st c="27800">And what about the different screens, core data, and network layers?</st>
    <st c="27870">In the hexagonal architecture, these app parts are not at the core.</st>
    <st c="27938">The UI screens seem like the domain model’s clients, and the network
    and core data parts provide services to the</st> <st c="28051">domain layer.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27800">那么，关于不同的屏幕、核心数据和网络层呢？</st> <st c="27870">在六边形架构中，这些应用部分并不在核心位置。</st>
    <st c="27938">UI屏幕看起来像是领域模型的客户端，而网络和核心数据部分为</st> <st c="28051">领域层</st>提供服务。
- en: <st c="28064">Look at</st> *<st c="28073">Figure 15</st>**<st c="28082">.9</st>*<st
    c="28084">:</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28064">看看</st> *<st c="28073">图15</st>**<st c="28082">.9</st>*<st c="28084">：</st>
- en: '![Figure 15.9: The domain model and its clients and services](img/B21795_15_9.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图15.9：领域模型及其客户端和服务](img/B21795_15_9.jpg)'
- en: '<st c="28178">Figure 15.9: The domain model and its clients and services</st>'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28178">图15.9：领域模型及其客户端和服务</st>
- en: '*<st c="28236">Figure 15</st>**<st c="28246">.9</st>* <st c="28248">shows the
    domain model at the center while its clients and services</st> <st c="28317">surround
    it.</st>'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="28236">图15</st>**<st c="28246">.9</st>* <st c="28248">显示了领域模型位于中心，而其客户端和服务</st>
    <st c="28317">围绕其周围。</st>'
- en: <st c="28329">Our next concept related to the hexagonal architecture is how
    the different actors connect to the domain model.</st> <st c="28442">These actors
    connect using ports</st> <st c="28475">and adapters.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28329">与六边形架构相关的下一个概念是不同的参与者如何连接到领域模型。</st> <st c="28442">这些参与者通过端口</st>
    <st c="28475">和适配器</st>进行连接。
- en: <st c="28488">Learning the concept of ports and adapters</st>
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="28488">学习端口和适配器的概念</st>
- en: <st c="28531">Think of our</st> <st c="28545">app</st> <st c="28549">as a computer
    system.</st> <st c="28571">The computer has its motherboard, CPU, GPU, and memory.</st>
    <st c="28627">We can connect external input peripherals such as a keyboard, a
    mouse, or a trackpad.</st> <st c="28713">We can also connect output devices such
    as a display, a speaker, or</st> <st c="28781">a printer.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28531">将我们的</st> <st c="28545">应用</st> <st c="28549">视为一个计算机系统。</st>
    <st c="28571">计算机有它的主板、CPU、GPU和内存。</st> <st c="28627">我们可以连接外部输入设备，例如键盘、鼠标或触摸板。</st>
    <st c="28713">我们还可以连接输出设备，例如显示器、扬声器或</st> <st c="28781">打印机。</st>
- en: <st c="28791">We know</st> <st c="28800">how</st> <st c="28803">computers are
    built – if we need to point out what is considered to be the heart of the computer,
    it wouldn’t be the printer or the displayer, but rather its motherboard and CPU.</st>
    <st c="28983">However, can we connect any device we want to</st> <st c="29029">the
    computer?</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28791">我们知道</st> <st c="28800">计算机是如何构建的——如果我们需要指出被认为是计算机核心的东西，那不会是打印机或显示器，而是其主板和CPU。</st>
    <st c="28983">然而，我们能否将任何我们想要的设备连接到</st> <st c="29029">计算机上？</st>
- en: <st c="29042">To do that, we need</st> <st c="29063">two things:</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29042">要做到这一点，我们需要</st> <st c="29063">两样东西：</st>
- en: <st c="29074">A port on the computer that allows us to connect devices; for
    example, UBC</st> <st c="29150">or HDMI</st>
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="29074">计算机上的一个端口，允许我们连接设备；例如，USB</st> <st c="29150">或HDMI</st>
- en: <st c="29157">A driver installed on the device that knows how to work with the
    port and the interface the</st> <st c="29250">computer requires</st>
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="29157">安装在设备上且知道如何与计算机所需的端口和接口工作的驱动程序</st> <st c="29250">计算机需要</st>
- en: <st c="29267">Each keyboard, printer, or mouse has a plug that fits the computer
    port and a driver that implements some protocol that allows this device to communicate
    with the computer.</st> <st c="29441">In general, we can connect any device we
    want as long as it conforms to the protocol the</st> <st c="29530">computer demands.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29267">每个键盘、打印机或鼠标都有一个适合计算机端口的插头和一个实现某些协议的驱动程序，允许此设备与计算机通信。</st> <st
    c="29441">一般来说，只要它符合计算机要求的协议，我们就可以连接任何我们想要的设备。</st>
- en: <st c="29547">When we return to the hexagonal architecture, we can consider
    the domain model as the computer itself and the network or the UI as the printer
    and keyboard.</st> <st c="29705">In addition, we have two more terms – port</st>
    <st c="29748">and adapter:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29547">当我们回到六边形架构时，我们可以将领域模型视为计算机本身，将网络或UI视为打印机和键盘。</st> <st c="29705">此外，我们还有两个更多术语——端口</st>
    <st c="29748">和适配器：</st>
- en: '**<st c="29760">Port</st>**<st c="29765">: This is</st> <st c="29775">an entry
    or exit point to/from the domain.</st> <st c="29819">In Swift, we use protocols
    to describe</st> <st c="29858">a port.</st>'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29760">端口</st>**<st c="29765">：这是一个</st> <st c="29775">领域内外部的入口或出口点。</st>
    <st c="29819">在Swift中，我们使用协议来描述</st> <st c="29858">端口。</st>'
- en: '**<st c="29865">Adapter</st>**<st c="29873">: When</st> <st c="29880">a particular
    class wants to connect to a port, it needs to implement the</st> <st c="29954">port
    protocol.</st>'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29865">适配器</st>**<st c="29873">：当一个特定类别想要连接到端口时，它需要实现</st> <st c="29954">端口协议。</st>'
- en: <st c="29968">Most iOS developers are familiar with the concept of a port and
    adapter.</st> <st c="30042">Eventually, this will be another way to decouple two
    elements using a protocol.</st> <st c="30122">However, in hexagonal architecture,
    all the elements that want to communicate with the domain model must</st> <st
    c="30227">use protocols.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29968">大多数iOS开发者都熟悉端口和适配器的概念。</st> <st c="30042">最终，这将是通过协议解耦两个元素的另一种方式。</st>
    <st c="30122">然而，在六边形架构中，所有想要与领域模型通信的元素都必须</st> <st c="30227">使用协议。</st>
- en: <st c="30241">There are two types of adapters – driving and driven.</st> <st
    c="30296">The distinction between them is fundamental to understanding the concept
    of</st> <st c="30372">hexagonal architecture.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30241">有两种类型的适配器——驱动和被驱动。</st> <st c="30296">它们之间的区别对于理解六边形架构的概念至关重要。</st>
- en: <st c="30395">Understanding the driving adapters</st>
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="30395">理解驱动适配器</st>
- en: <st c="30430">The driving</st> <st c="30443">adapters act as the entry point
    for the</st> <st c="30483">external world and are responsible for initiating any
    interaction with the</st> <st c="30558">domain model.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30430">驱动适配器充当外部世界的入口点，并负责与领域模型进行任何交互的初始化。</st>
- en: <st c="30571">If we return to the computer example, adapters can be considered
    an external keyboard or mouse.</st> <st c="30668">We call them</st> *<st c="30681">driving</st>*
    <st c="30688">because they drive the app by invoking its</st> <st c="30732">use
    cases.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30571">如果我们回到计算机的例子，适配器可以被视为外部键盘或鼠标。</st> <st c="30668">我们称它们为</st> *<st
    c="30681">驱动</st> <st c="30688">，因为它们通过调用其</st> <st c="30732">用例来驱动应用程序。</st>
- en: <st c="30742">The most common example of driving adapters is the UI.</st> <st
    c="30798">A screen usually performs actions that drive our system to take meaningful
    action, such as logging in to the system, playing music, or fetching data from
    the network or the local</st> <st c="30977">persistent store.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30742">驱动适配器最常见的例子是UI。</st> <st c="30798">屏幕通常执行驱动我们系统采取有意义行动的操作，例如登录系统、播放音乐或从网络或本地</st>
    <st c="30977">持久存储中获取数据。</st>
- en: <st c="30994">However, driving adapters are not limited to UI screens.</st>
    <st c="31052">We can consider notification centers, app/scene delegates, location
    services, and universal links as</st> <st c="31153">driving adapters.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30994">然而，驱动适配器并不仅限于UI屏幕。</st> <st c="31052">我们可以将通知中心、应用/场景代理、位置服务和通用链接视为</st>
    <st c="31153">驱动适配器。</st>
- en: <st c="31170">The driving adapter depends on the domain model and communicates
    with it only with</st> <st c="31254">protocols (ports).</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31170">驱动适配器依赖于领域模型，并且仅通过</st> <st c="31254">协议（端口）与它通信。</st>
- en: <st c="31272">Now, let’s understand what the driven</st> <st c="31311">adapter
    is.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31272">现在，让我们了解被驱动</st> <st c="31311">适配器是什么。</st>
- en: <st c="31322">Understanding the driven adapter</st>
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="31322">理解被驱动适配器</st>
- en: <st c="31355">The</st> <st c="31359">domain</st> <st c="31367">model uses the
    driven adapters to communicate with external systems or services, such as the
    network, persistent storage, or</st> <st c="31492">third-party services.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31355">领域</st> <st c="31359">模型使用被驱动适配器与外部系统或服务通信，例如网络、持久存储或</st> <st
    c="31492">第三方服务。</st>
- en: <st c="31513">In the computer example, we can look at the driven adapter as
    an external display or</st> <st c="31599">a printer.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31513">在计算机的例子中，我们可以将驱动适配器视为外部显示器或</st> <st c="31599">打印机。</st>
- en: <st c="31609">We can consider the whole hexagonal architecture as an I/O system
    – the driving adapters are the input devices, and the driven adapters are the
    output devices, performing updates to the local storage or executing</st> <st
    c="31823">API calls.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31609">我们可以将整个六边形架构视为一个I/O系统——驱动适配器是输入设备，而被驱动适配器是输出设备，执行对本地存储的更新或执行</st>
    <st c="31823">API调用。</st>
- en: <st c="31833">Let’s look at our architecture now that we understand what ports,
    driving adapters, and driven adapters are (</st>*<st c="31943">Figure 15</st>**<st
    c="31953">.10</st>*<st c="31956">):</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31833">现在我们已经了解了端口、驱动适配器和被驱动适配器是什么（</st>*<st c="31943">图15</st>**<st
    c="31953">.10</st>*<st c="31956">）：</st>
- en: '![Figure 15.10: The complete hexagonal architecture](img/B21795_15_10.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图15.10：完整的六边形架构](img/B21795_15_10.jpg)'
- en: '<st c="32071">Figure 15.10: The complete hexagonal architecture</st>'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32071">图15.10：完整的六边形架构</st>
- en: '*<st c="32120">Figure 15</st>**<st c="32130">.10</st>* <st c="32133">shows</st>
    <st c="32140">the different adapters, divided into driving and driven.</st> <st
    c="32197">It also</st> <st c="32205">shows that we need a port to access the</st>
    <st c="32245">domain model.</st>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="32120">图15</st>**<st c="32130">.10</st>* <st c="32133">展示了</st> <st
    c="32140">不同的适配器，分为驱动和被驱动。</st> <st c="32197">它还</st> <st c="32205">显示我们需要一个端口来访问</st>
    <st c="32245">领域模型。</st>'
- en: <st c="32258">At this point, we have discussed the hexagonal architecture mostly
    in theory.</st> <st c="32337">Let’s examine some examples of how to implement
    this concept</st> <st c="32398">in practice.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32258">到目前为止，我们主要在理论上讨论了六边形架构。</st> <st c="32337">让我们考察一些如何在实践中实现这一概念的</st>
    <st c="32398">例子。</st>
- en: <st c="32410">Implementing the hexagonal architecture in practice</st>
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="32410">在实践中实现六边形架构</st>
- en: <st c="32462">Let’s demonstrate the</st> <st c="32485">hexagonal architecture
    using a simple flow such</st> <st c="32533">as login.</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32462">让我们通过一个简单的流程，比如登录，来演示</st> <st c="32485">六边形架构。</st>
- en: <st c="32542">Defining different ports</st>
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="32542">定义不同的端口</st>
- en: <st c="32567">We start by</st> <st c="32580">defining the different ports.</st>
    <st c="32610">The first port is the login use</st> <st c="32642">case itself:</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32567">我们首先</st> <st c="32580">定义不同的端口。</st> <st c="32610">第一个端口是登录用例本身：</st>
- en: '[PRE0]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="32788">The</st> `<st c="32793">LoginUseCaseProtocol</st>` <st c="32813">protocol
    defines how the driving adapter or app UI communicates</st> <st c="32877">with
    the app code, which is the</st> <st c="32910">domain model.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32788">现在，</st> `<st c="32793">LoginUseCaseProtocol</st>` <st c="32813">协议定义了驱动适配器或应用程序用户界面如何与应用程序代码（即领域模型）进行通信。</st>
- en: <st c="32923">Our second port is one that we use to connect to a driven adapter,
    such as the</st> <st c="33003">network service:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32923">我们的第二个端口是我们用来连接到驱动适配器的一个端口，例如</st> <st c="33003">网络服务：</st>
- en: '[PRE1]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="33223">The</st> `<st c="33228">NetworkServiceProtocol</st>` <st c="33250">protocol
    helps the domain model to communicate with external services such as</st> <st
    c="33329">network services.</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33223">现在，</st> `<st c="33228">NetworkServiceProtocol</st>` <st c="33250">协议帮助领域模型与外部服务（如网络服务）进行通信。</st>
- en: <st c="33346">Creating a login use case</st>
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="33346">创建登录用例</st>
- en: <st c="33372">Now that we</st> <st c="33385">have defined the different ports,
    we can create the login use case that sits at the heart of the</st> <st c="33482">domain
    model:</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33372">现在我们已经定义了不同的端口，我们可以创建位于领域模型核心的登录用例：</st>
- en: '[PRE2]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="33893">The</st> `<st c="33898">LoginUseCase</st>` <st c="33910">class</st>
    <st c="33916">implements the</st> `<st c="33932">LoginUseCaseProtocol</st>` <st
    c="33952">protocol, one of the ports we discussed earlier.</st> <st c="34002">It
    also uses the</st> `<st c="34019">NetworkServiceProtocol</st>` <st c="34041">protocol
    as a dependency.</st> <st c="34068">At this point, we have the login logic wrapped
    with a protocol and also communicate with the network service using a protocol.</st>
    <st c="34195">This means that the domain logic of our app is completely decoupled
    from the driving or driven adapter we may have, which is exactly what</st> <st
    c="34333">we wanted.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33893">现在，</st> `<st c="33898">LoginUseCase</st>` <st c="33910">类</st>
    <st c="33916">实现了</st> `<st c="33932">LoginUseCaseProtocol</st>` <st c="33952">协议，这是我们之前讨论过的端口之一。</st>
    <st c="34002">它还使用</st> `<st c="34019">NetworkServiceProtocol</st>` <st c="34041">协议作为依赖。</st>
    <st c="34068">此时，我们将登录逻辑封装在一个协议中，并使用协议与网络服务进行通信。</st> <st c="34195">这意味着我们的应用程序领域逻辑与可能存在的驱动或驱动适配器完全解耦，这正是</st>
    <st c="34333">我们想要的。</st>
- en: <st c="34343">Creating a network service</st>
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="34343">创建网络服务</st>
- en: <st c="34370">Now, let’s</st> <st c="34382">create a</st> <st c="34391">network
    service:</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34370">现在，让我们</st> <st c="34382">创建一个</st> <st c="34391">网络服务：</st>
- en: '[PRE3]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="34648">The</st> `<st c="34653">NetworkService</st>` <st c="34667">class
    implements the</st> `<st c="34689">NetworkServiceProtocol</st>` <st c="34711">protocol
    so</st> <st c="34723">that we can use it as a domain</st> <st c="34755">model
    dependency.</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34648">现在，</st> `<st c="34653">NetworkService</st>` <st c="34667">类实现了</st>
    `<st c="34689">NetworkServiceProtocol</st>` <st c="34711">协议，这样</st> <st c="34723">我们就可以将其用作领域模型依赖。</st>
- en: <st c="34772">Creating a login screen</st>
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="34772">创建登录界面</st>
- en: <st c="34796">Now, let’s</st> <st c="34808">turn to the driving adapter and
    create a</st> <st c="34849">login screen:</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34796">现在，让我们</st> <st c="34808">转向驱动适配器并创建一个</st> <st c="34849">登录界面：</st>
- en: '[PRE4]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="35241">In this</st> <st c="35249">example, we create a simple login screen
    (username and password) that uses its protocol to work with the login use case.</st>
    <st c="35371">If we need advanced state management, we can do that using a</st>
    <st c="35432">view model.</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35241">在这个</st> <st c="35249">例子中，我们创建了一个简单的登录界面（用户名和密码），它使用其协议与登录用例一起工作。</st>
    <st c="35371">如果我们需要高级状态管理，我们可以使用一个</st> <st c="35432">视图模型。</st>
- en: <st c="35443">Connecting everything together</st>
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="35443">将所有东西连接起来</st>
- en: <st c="35474">Now, all we need to do is to connect</st> <st c="35512">everything
    together:</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35474">现在，我们只需要将</st> <st c="35512">所有东西连接起来：</st>
- en: '[PRE5]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="35753">In the app initialization, we first create the driven adapters
    (the</st> `<st c="35822">NetworkService</st>` <st c="35836">class), inject them
    into the domain model (the login use case), and then inject the domain model int</st><st
    c="35937">o the driving adapter (the</st> `<st c="35965">LoginView</st>` <st c="35974">structure).</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35753">在应用程序初始化过程中，我们首先创建驱动适配器（</st> `<st c="35822">NetworkService</st>`
    <st c="35836">类），将它们注入到领域模型（登录用例）中，然后将领域模型注入到驱动适配器（</st> `<st c="35965">LoginView</st>`
    <st c="35974">结构）中。</st>
- en: <st c="35986">At first glance, it appeared we’d created too many protocols and
    used more dependency injection than usual.</st> <st c="36095">While it’s true
    that this is the cost of using architecture such as Hexagonal, let’s examine the</st>
    <st c="36192">benefits here:</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35986">乍一看，我们似乎创建了太多的协议，并且使用了比平时更多的依赖注入。</st> <st c="36095">虽然使用如六边形这样的架构确实有这种成本，但让我们来看看</st>
    <st c="36192">这里的收益：</st>
- en: <st c="36206">The different concerns are very clear.</st> <st c="36246">We understand
    exactly what the app’s core logic is, what the external services are, and what
    the client of these</st> <st c="36359">modules is.</st>
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="36206">不同的关注点非常清晰。</st> <st c="36246">我们确切地知道应用的核心逻辑是什么，外部服务是什么，以及这些模块的客户是什么。</st>
- en: <st c="36370">Maintaining each adapter or core logic case is extremely easy
    since they are decoupled from each other and communicate only with a protocol.</st>
    <st c="36512">When we say maintain, we mean testing, refactoring, and</st> <st
    c="36568">bug fixes.</st>
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="36370">由于它们彼此解耦并且只通过协议进行通信，因此维护每个适配器或核心逻辑案例变得极其容易。</st> <st c="36512">当我们说维护时，我们指的是测试、重构和</st>
    <st c="36568">错误修复。</st>
- en: <st c="36578">Replacing parts in our app, such as services or use cases, becomes
    very easy.</st> <st c="36657">Let’s try to remember apps or even systems that
    we have worked on.</st> <st c="36724">Imagine what it took to replace the network
    service, the persistent store, or even</st> <st c="36807">one screen.</st>
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="36578">在我们的应用中更换部分，如服务或用例，变得非常容易。</st> <st c="36657">让我们尝试回忆一下我们曾经工作过的应用或甚至系统。</st>
    <st c="36724">想象一下替换网络服务、持久存储或甚至</st> <st c="36807">一个屏幕需要付出多少努力。</st>
- en: <st c="36818">Adding more features and modules doesn’t require significant changes
    to our project.</st> <st c="36904">Reusing existing cod</st><st c="36924">e when
    adding new screens or use cases</st> <st c="36964">is easy.</st>
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="36818">添加更多功能和模块不需要对我们项目进行重大更改。</st> <st c="36904">在添加新屏幕或用例时重用现有代码</st><st
    c="36924">变得容易。</st> <st c="36964">重用现有代码</st>
- en: <st c="36972">Remember that, like the multi-layer and modular architectures,
    the hexagonal architecture provides a set of guidelines and principles for conducting
    a well-structured and maintainable</st> <st c="37157">project architecture.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36972">记住，就像多层和模块化架构一样，六边形架构提供了一套指导原则和原则，用于进行结构良好且易于维护的</st> <st c="37157">项目架构。</st>
- en: <st c="37178">So, how do these</st> <st c="37196">principles compare?</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37178">那么，这些</st> <st c="37196">原则是如何比较的呢？</st>
- en: <st c="37215">Comparing the different architectures</st>
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="37215">比较不同的架构
- en: <st c="37253">What is the</st> <st c="37266">best architecture we can use?</st>
    <st c="37296">Is there even right or wrong here?</st> <st c="37331">How do we
    digest all</st> <st c="37352">of that?</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37253">我们能使用的</st> <st c="37266">最佳架构是什么？</st> <st c="37296">这里甚至有对错之分吗？</st>
    <st c="37331">我们如何消化所有</st> <st c="37352">这些信息？</st>
- en: <st c="37360">So, we saw how to combine modular and multi-layer architecture
    and emphasize each architecture’s advantage.</st> <st c="37469">The same goes
    for the hexagonal architecture – let’s pull out the different principles</st>
    <st c="37556">we’ve learned:</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37360">因此，我们看到了如何结合模块化和多层架构，并强调每个架构的优势。</st> <st c="37469">六边形架构也是如此——让我们回顾一下我们学到的不同原则</st>
    <st c="37556">：</st>
- en: <st c="37570">Use protocols to decouple the communication with the</st> <st
    c="37624">external services</st>
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37570">使用协议来解耦与</st> <st c="37624">外部服务</st>的通信
- en: <st c="37641">Make the domain model the core of</st> <st c="37676">the app</st>
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="37641">将领域模型作为</st> <st c="37676">应用</st>的核心
- en: <st c="37683">These principles are relevant not only to hexagonal architecture
    but also to</st> <st c="37761">other architectures.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37683">这些原则不仅适用于六边形架构，也适用于</st> <st c="37761">其他架构。</st>
- en: <st c="37781">Let’s try to compare the different architectures using several</st>
    <st c="37845">important metrics.</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37781">让我们尝试使用几个</st> <st c="37845">重要指标来比较不同的架构。</st>
- en: <st c="37863">By separation of concerns</st>
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="37863">通过关注点分离</st>
- en: <st c="37889">Separation of concerns is</st> <st c="37916">an important principle
    in project structuring, and all three architectures implement</st> <st c="38001">it
    well.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37889">关注点分离</st>是项目结构化中的一个重要原则，并且所有三种架构都很好地实现了这一原则。
- en: <st c="38009">However, each separates the</st> <st c="38038">concerns in a slightly
    different way.</st> <st c="38076">For example, the</st> *<st c="38093">multi-layered
    architecture</st>* <st c="38119">separations are clear and straightforward, but
    they may lead to tight coupling if not</st> <st c="38206">carefully implemented.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38009">然而，每种方法都以略微不同的方式分离关注点。</st> <st c="38038">例如，</st> *<st c="38093">多层架构</st>*
    <st c="38119">的分离清晰且直接，但如果实施不当，可能会导致紧密耦合。</st>
- en: <st c="38228">On the other hand, in</st> *<st c="38251">modular architecture</st>*<st
    c="38271">, the separations are easy to maintain and scale because each module
    contains its own different layers and is self-contained.</st> <st c="38397">However,
    defining the distinct boundaries between the modules can</st> <st c="38463">be
    complex.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38228">另一方面，在</st> *<st c="38251">模块化架构</st>*<st c="38271">中，由于每个模块都包含其自己的不同层并且是自包含的，因此分离易于维护和扩展。</st>
    <st c="38397">然而，定义模块之间的明确边界可能很复杂。</st>
- en: <st c="38474">The</st> *<st c="38479">hexagonal architecture</st>* <st c="38501">focuses
    on separating the application core from external services.</st> <st c="38569">This
    approach is practical when adapting many external systems to the app.</st> <st
    c="38644">However, it requires a complex setup that can be overhead in</st> <st
    c="38705">small apps.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38474">这种</st> *<st c="38479">六角形架构</st>* <st c="38501">专注于将应用程序核心与外部服务分离。</st>
    <st c="38569">当将许多外部系统适配到应用程序时，这种方法是实用的。</st> <st c="38644">然而，它需要一个复杂的设置，在小应用程序中可能会造成负担。</st>
- en: <st c="38716">All these architectures have great separations of concerns because
    that’s one of the most important principles in designing an architecture.</st>
    <st c="38858">However, each does that using a different approach, and the decision
    of the prominent architecture depends on the</st> <st c="38972">project requirements.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38716">所有这些架构都有很好的关注点分离，因为这是设计架构最重要的原则之一。</st> <st c="38858">然而，每个架构都采用不同的方法来实现这一点，而主导架构的选择取决于项目需求。</st>
- en: <st c="38993">Let’s see how to compare the different architectures in terms</st>
    <st c="39056">of testing.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38993">让我们看看如何从测试的角度比较不同的架构。</st>
- en: <st c="39067">By testing</st>
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="39067">通过测试</st>
- en: <st c="39078">Testing and</st> <st c="39091">separation of concerns principles
    are related to each other.</st> <st c="39152">The separation of concerns principle
    encourages the isolation of different classes and modules, which makes it simpler
    to write unit tests for a specific part of our app.</st> <st c="39323">Separating
    our apps based on concerns also makes it easier to manage dependencies, a critical
    factor in testing.</st> <st c="39436">However, since each architecture performs
    the separation differently, it also influences</st> <st c="39525">the testing.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39078">测试和</st> <st c="39091">关注点分离原则相互关联。</st> <st c="39152">关注点分离原则鼓励隔离不同的类和模块，这使得为应用程序的特定部分编写单元测试变得更加简单。</st>
    <st c="39323">根据关注点分离我们的应用程序也使得管理依赖关系更加容易，这是测试中的一个关键因素。</st> <st c="39436">然而，由于每个架构执行分离的方式不同，它也影响了测试。</st>
- en: <st c="39537">For example, in a</st> *<st c="39556">multi-layer architecture</st>*<st
    c="39580">, it becomes easier to test each layer independently.</st> <st c="39634">We
    can perform core data or specific business logic testing in a simple way.</st>
    <st c="39711">However, if</st> <st c="39723">we want to write integration tests
    (tests that involve working with multiple components), the multi-layer architecture
    makes it much more complex because of the dependencies between</st> <st c="39905">the
    layers.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39537">例如，在</st> *<st c="39556">多层架构</st>*<st c="39580">中，独立测试每一层变得更加容易。</st>
    <st c="39634">我们可以以简单的方式执行核心数据或特定业务逻辑测试。</st> <st c="39711">然而，如果我们想编写集成测试（涉及与多个组件一起工作的测试），由于层之间的依赖关系，多层架构会使它变得更加复杂。</st>
- en: <st c="39916">However, writing integration tests is one advantage of</st> *<st
    c="39972">modular architecture</st>*<st c="39992">, as the different interfaces
    within the module are well-defined.</st> <st c="40058">On the other hand, trying
    to write a unit test for a specific app layer can become much more</st> <st c="40151">complex
    now.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39916">然而，编写集成测试是模块化架构的一个优点，因为模块内部的不同接口定义得很好。</st> <st c="39972">另一方面，尝试为特定应用程序层编写单元测试现在可能变得更加复杂。</st>
- en: <st c="40163">In the</st> *<st c="40171">hexagonal architecture</st>*<st c="40193">,
    we work with adapters and ports.</st> <st c="40228">This means loose coupling
    and many protocols with external services, which allows us to mock external services
    easily and easily test the</st> <st c="40366">application core.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40163">在</st> *<st c="40171">六边形架构</st>*<st c="40193">中，我们使用适配器和端口。</st>
    <st c="40228">这意味着与外部服务的松散耦合和许多协议，这使得我们能够轻松地模拟外部服务并轻松地测试</st> <st c="40366">应用程序核心。</st>
- en: <st c="40383">To summarize, testing is a big topic in development, and each
    of the architectures supports it very well.</st> <st c="40490">To understand how
    the choice of architecture affects testing, we need to ask ourselves what the
    core unit we want to test is – is it a module, a layer, or the application core?</st>
    <st c="40667">Also, are integration tests important to us?</st> <st c="40712">Answering
    these questions can help us understand which architecture fits our</st> <st c="40789">project
    better.</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40383">总的来说，测试是开发中的一个重要主题，每种架构都很好地支持了它。</st> <st c="40490">要了解架构选择如何影响测试，我们需要问自己我们想要测试的核心单元是什么——是模块、层还是应用程序核心？</st>
    <st c="40667">此外，集成测试对我们来说重要吗？</st> <st c="40712">回答这些问题可以帮助我们了解哪种架构更适合我们的</st>
    <st c="40789">项目。</st>
- en: <st c="40804">What about maintenance and scalability?</st> <st c="40845">Let’s</st>
    <st c="40851">see now.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40804">那么维护和可扩展性呢？</st> <st c="40845">现在让我们看看。</st>
- en: <st c="40859">By maintenance and scalability</st>
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40859">通过维护和可扩展性</st>
- en: <st c="40890">Before</st> <st c="40898">we see how each architecture stands
    out regarding maintenance and scalability, let’s understand exactly what it means.</st>
    <st c="41017">Maintenance is ongoing to keep our project aligned with the changing
    requirements.</st> <st c="41100">This involves fixing bugs, making new features
    and improvements, refactoring, and optimizing.</st> <st c="41194">Scalability
    describes our ability to increase the number of features without redesigning our
    project.</st> <st c="41296">In general, a well-maintained project is often considered
    to be scalable.</st> <st c="41370">However, like testing and separations, each
    architecture has a</st> <st c="41433">different approach.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40890">在我们看到每种架构在维护和可扩展性方面的突出之处之前，让我们确切地了解这意味着什么。</st> <st c="41017">维护是持续的，以保持我们的项目与不断变化的需求保持一致。</st>
    <st c="41100">这包括修复错误、创建新功能及改进、重构和优化。</st> <st c="41194">可扩展性描述了我们在不重新设计项目的情况下增加功能数量的能力。</st>
    <st c="41296">一般来说，维护良好的项目通常被认为是可扩展的。</st> <st c="41370">然而，就像测试和分离一样，每种架构都有不同的方法。</st>
- en: <st c="41452">The multi-layer architecture is great for medium-sized projects.</st>
    <st c="41518">Due to the tight coupling between the layers, maintaining a clear
    multi-layer architecture over time can be challenging in large projects.</st>
    <st c="41657">Modular architecture is considered to be highly scalable in big
    projects, as there are clear boundaries and independence between different business
    units.</st> <st c="41812">However, defining these units can be a challenge in
    the early stages.</st> <st c="41882">The hexagonal architecture is excellent for
    scaling – the clear domain separations help add more services to the project and
    test them over time.</st> <st c="42028">However, the maintenance can be overhead
    due to the many adapters we need</st> <st c="42102">to manage.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41452">多层架构非常适合中等规模的项目。</st> <st c="41518">由于层与层之间的紧密耦合，在大项目中保持清晰的分层架构随着时间的推移可能会具有挑战性。</st>
    <st c="41657">模块化架构被认为在大项目中具有高度的可扩展性，因为不同的业务单元之间有明确的边界和独立性。</st> <st c="41812">然而，在早期阶段定义这些单元可能是一个挑战。</st>
    <st c="41882">六边形架构在扩展方面非常出色——清晰的领域分离有助于向项目中添加更多服务，并在一段时间内对其进行测试。</st> <st c="42028">然而，由于我们需要管理许多适配器，维护可能会变得繁重。</st>
    <st c="42102">to manage.</st>
- en: <st c="42112">Each of the</st> <st c="42124">architectures is suitable for a
    different scale of project and requirements.</st> <st c="42202">Medium projects
    may work well with multi-layer architecture compared to modular, and hexagonal
    architecture can be great for large projects with one application core that can
    increase over</st> <st c="42391">the years.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42112">每种架构都适合不同规模的项目和需求。</st> <st c="42124">与模块化架构相比，中等规模的项目可能更适合多层架构，而六边形架构对于具有一个可以随时间增加的应用程序核心的大型项目来说可能非常出色。</st>
- en: <st c="42401">Let’s try to summarize by comparing the different architectures
    with</st> <st c="42471">different aspects:</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42401">让我们通过比较不同的架构与</st> <st c="42471">不同方面来尝试总结：</st>
- en: '| **<st c="42489">Aspect</st>** | **<st c="42496">Multi-layer</st>** | **<st
    c="42508">Modular</st>** | **<st c="42516">Hexagonal</st>** |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="42489">方面</st>** | **<st c="42496">多层</st>** | **<st c="42508">模块化</st>**
    | **<st c="42516">六边形</st>** |'
- en: '| **<st c="42526">Separation</st>** **<st c="42538">of concerns</st>** | <st
    c="42549">Clear, hierarchical layers (UI, logic, data); can become less flexible</st>
    <st c="42621">with dependencies</st> | <st c="42638">Independent, strong separation,</st>
    <st c="42671">flexible interfaces</st> | <st c="42690">Clear separation from external
    systems; core logic isolated via ports</st> <st c="42761">and adapters</st> |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="42526">关注点分离</st>** **<st c="42538">分离</st>** | 清晰的分层（UI、逻辑、数据）；随着依赖性增加可能变得不太灵活
    | 独立、强分离，灵活的接口 | 与外部系统有明确的分离；核心逻辑通过端口和适配器进行隔离 |'
- en: '| **<st c="42773">Testing</st>** | <st c="42781">Easy within the layers, complex</st>
    <st c="42814">between layers</st> | <st c="42828">Simple to test a single module,
    and the same goes for integration tests within</st> <st c="42908">the module</st>
    | <st c="42918">Core logic is very testable; easy to</st> <st c="42956">mock adapters</st>
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="42773">测试</st>** | 在层内容易，层间复杂 | 单个模块易于测试，模块内的集成测试也是如此 | 核心逻辑非常易于测试；易于模拟适配器
    |'
- en: '| **<st c="42969">Maintenance</st>** | <st c="42981">Can be challenging due
    to</st> <st c="43008">tight coupling</st> | <st c="43022">Easier due to modular;
    minimal impact</st> <st c="43061">across modules</st> | <st c="43075">Easy due
    to isolation from</st> <st c="43103">external changes</st> |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="42969">维护</st>** | 由于**紧密耦合**可能具有挑战性 | 由于模块化；对模块的影响最小 | 由于与外部变化的隔离而变得简单
    |'
- en: '| **<st c="43119">Scalability</st>** | <st c="43131">Limited by</st> <st c="43143">layer
    interactions</st> | <st c="43161">Highly scalable as modules can</st> <st c="43193">scale
    independently</st> | <st c="43212">Scales by adding new adapters; core</st> <st
    c="43249">remains stable</st> |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="43119">可扩展性</st>** | 受限于**层交互** | 模块可以独立扩展，因此具有高度可扩展性 | 通过添加新的适配器进行扩展；核心保持稳定
    |'
- en: <st c="43263">This table can give us a sense of the different architectures’
    performance in different aspects.</st> <st c="43361">There are no scores here!</st>
    <st c="43387">We need to choose and mix the architectural concepts based on</st>
    <st c="43449">our needs.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43263">此表可以让我们对不同架构在不同方面的性能有一个概念。</st> <st c="43361">这里没有分数！</st> <st
    c="43387">我们需要根据我们的需求选择和混合架构概念。</st> <st c="43449">。</st>
- en: <st c="43459">Summary</st>
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="43459">总结</st>
- en: <st c="43467">Focusing on the correct architecture is a strategic decision that
    influences our project over time.</st> <st c="43568">If you feel confused about
    what fits your app, that’s natural.</st> <st c="43631">Remember that the right
    thing to do is to look at the different architectures as different principles
    – we should combine the best from all worlds in a way that suits our</st> <st
    c="43802">project requirements.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43467">关注正确的架构是一个影响我们项目时间的战略决策。</st> <st c="43568">如果你对自己的应用程序适合什么感到困惑，这是很自然的。</st>
    <st c="43631">记住，正确的事情是将不同的架构视为不同的原则——我们应该以适合我们项目需求的方式结合所有世界的最佳之处。</st> <st c="43802">。</st>
- en: <st c="43823">In this chapter, we learned about the importance of architecture
    and what exactly it means.</st> <st c="43916">We also compared the different architectures
    – multi-layer, modular, and hexagonal.</st> <st c="44000">By now, you should be
    able to design your app’s different components to help you scale, maintain, and
    test it</st> <st c="44110">over time.</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43823">在本章中，我们学习了架构的重要性以及它究竟意味着什么。</st> <st c="43916">我们还比较了不同的架构——多层、模块化和六边形。</st>
    <st c="44000">到现在为止，你应该能够设计你应用程序的不同组件，以帮助你在时间上对其进行扩展、维护和测试。</st> <st c="44110">。</st>
- en: <st c="44120">It’s not a coincidence that the book’s last chapter discusses
    architecture.</st> <st c="44197">In a way, architecture ties together everything
    we’ve learned, providing a structure that allows all the elements to work together
    harmoniously.</st> <st c="44342">In addition, the app architecture is the infrastructure
    where we implement all the concepts we’ve learned throughout the book.</st> <st
    c="44469">Our journey ends; this is a good chance to start experiencing all the
    advanced iOS capabilities.</st> <st c="44566">Good luck!</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44120">这本书的最后一章讨论建筑并非巧合。</st> <st c="44197">从某种意义上说，建筑将我们所学的一切串联起来，提供了一个使所有元素能够和谐共存的框架。</st>
    <st c="44342">此外，应用架构是我们实现书中所学所有概念的基础设施。</st> <st c="44469">我们的旅程结束了；这是一个开始体验所有高级iOS功能的好机会。</st>
    <st c="44566">祝你好运！</st>
