- en: Chapter 12. Asynchronous Programing with RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have been using Android-based constructs such as `Loader`
    and `AsyncTask` to offload work from the main thread to low priority background
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Although these straightforward constructs are able to deliver results that require
    intensive IO operations or network data, they don't provide out-of-the-box solutions
    for exception handling, task composition, and asynchronous event processing.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond that, the popular `AsyncTask` construct is not able to deal with `Activity`
    or fragment configuration changes or cache results between configuration changes.
    Therefore, to cope with these kinds of problem, most of time the developer ends
    up creating a lot of extra code and complicated flows to handle the traits of
    these simple constructs.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the development of composable asynchronous work, we will introduce
    you to `RxJava`, a functional framework that allow us to observe, transform, filter,
    and react to streams of events (click, touch, network, I/O events, and so on)
    in order to compose complex lines of execution that are able to react to errors
    and chain asynchronous computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to RxJava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming Observables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing Asynchronous IO with Schedulers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing Tasks with RxJava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing UI events with RxJava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Tasks with RxJava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Subjects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RxJava` is an implementation of Reactive Extensions (`ReactiveX`) on JVM,
    which was developed by Netflix and is used to compose asynchronous event processing
    that reacts to an observable source of events.'
  prefs: []
  type: TYPE_NORMAL
- en: The framework extends the `Observer` pattern by allowing us to create a stream
    of events that could be intercepted by operator (input/output) functions that
    modify the original stream of events and deliver the result or an error to a final
    `Observer`. This framework abstracts away concerns about things such as low-level
    threading, synchronization, thread safety, concurrent data structures, and non-blocking
    I/O.
  prefs: []
  type: TYPE_NORMAL
- en: There are three main basic building blocks that interact with each other in
    `RxJava` processing, the `Observable`, the `Observer`, and the `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: An `Observable` is an entity that emits a sequence of events (zero or more events)
    of the generic type T (such as String or any Java type) at any point in time,
    or emits a `Throwable` when a failure occurs during the event processing. Beyond
    that, it provides methods to subscribe to its event stream and manage `Observer`
    subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: A `Single` is a special kind of Observable that can only emit either a single
    success event value or an error event.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `Observer`, after registering as a subscriber, consumes the events of type
    `T` generated by the `Observable<T>`. An Observer must implement `Observer<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Any `Observer` will receive a callback to `onNext` whenever a new event is emitted
    by the Observable it's subscribed to until it receives `onCompleted` or `onError`
    to close the event stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Subscriber` is a helper abstract class you can use as your Observer''s base
    if you want subscription support. The `Subscriber` class provides methods to cancel
    the Observable subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`unsubscribe` is the function used to cancel the `Observer` subscription. Therefore,
    once the `Observer` subscription is terminated, the Subscriber will no longer
    receive the events generated by the Observable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple graph displaying the common interactions between an `Observable`
    and a `Subscriber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to RxJava](img/Image_B05062_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `onNext(T)` Observer's callback is invoked when a new item is emitted by
    the Observable.
  prefs: []
  type: TYPE_NORMAL
- en: The `onError(Throwable)` Observer's callback is invoked to notify that an error
    condition was found and the stream will be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: The `onCompleted()` Observer's callback is invoked to indicate that the stream
    has completed successfully and all the events were delivered with success.
  prefs: []
  type: TYPE_NORMAL
- en: Cold versus Hot Observable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An Observable can be classified as hot or cold based on the time that it starts
    emitting events. A cold Observable only starts emitting events to the Observers
    when an Observer subscribes to it. In this case, it is expected that the Observer
    will receive the stream from the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: A hot Observable will begin emitting events as soon as it gets created, so the
    Observer will only receive the events emitted after the subscription is created.
    The events emitted before the subscription will not be received by the Observer.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move further, let''s add the required libraries to your project.
    If you''re using Android Studio, just add the following dependencies to the module
    `build.gradle` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`rxjava` is a library that implements the Reactive Extensions ([http://reactivex.io/](http://reactivex.io/))
    on Java , and `rxandroid` is a library that adds classes to help write reactive
    components with `RxJava` in Android applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create an `Observable`, we can either create an `Observable` from scratch
    using the `create` function and calling Observer methods explicitly, or we can
    use built-in `Observable` creation methods that convert common data types to `Observable`
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example and create an observable that emits a `String`
    using the creating `Observable.from` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable.from` static function creates `Observable` from an array that
    will synchronously emit `String` items to any Observer. The Observable created
    will be a cold Observable and will only start emitting events after an Observer
    subscribes to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a `Subscriber` that consumes the data and prints each `String`
    to the Android Log until `Observable` invokes the `onComplete` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, with `Observable` and the subscriber class just defined, once we subscribe
    our `Subscriber` class on `Observable`, the `onNext()` function will be called
    three times passing each `String` in the Array, defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequently, after all the `Strings` are consumed by the `Subscriber`, the
    `onCompleted` function is called to close the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Observable` instance is responsible for managing all subscriptions, notifying
    all its `Subscribers`, and it won't begin emitting items until we subscribe to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from using `Observable.from` or another creation operator, we can create
    Observables by calling the `create` method and implementing `Observable.OnSubscribe<T>`
    that explicitly calls `onNext`, `onError`, and `onCompleted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our own `Observable` that emits integer numbers using the `create`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Remember that a well-behaved `Observable` must attempt to call either the observer's
    `onCompleted` or `onError` exactly once after emitting all the items by calling
    the subscriber's `onNext` function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the previous Observable is also classified as a cold Observable
    because it will only start emitting when a Subscriber entity subscribes to it.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can subscribe to `Observable` using `Action` functions to
    handle the items dispatched in different separated functions. All that you need
    to do is pass an `Action1<T>` function for event processing, an `Action1<Throwable>`
    for the error emission, and `Action0` to receive the stream completion notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the required action functions that react to our `Observable<String>`
    emissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Beyond the `from` operator and the `create` operator functions there are other
    simple `Observable` functions that can be used to build `Observable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.just`: Creates an `Observable` from a short number of objects (Max
    10 Objects):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Observable.range`: Emits a range of numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Transforming Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the ability to widely implement the `Observable-Subscribe` software
    pattern, the `RxJava` framework allows us to transform, filter, convert, aggregate,
    manipulate, and work with the stream of items emitted by `Observable` by using
    `Observable` operators. These entities are able to completely transform the event
    stream before the events are delivered to the final `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: '`RxJava` comes with a handy collection of operators that are able to transform
    the event''s content and control the time that the event is delivered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe the most common operators available on `RxJava`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`map`: Applies a function to each item emitted and emits the result of the
    function as a new item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap`: Applies a function to each item emitted by the source `Observable`
    where the function returns an `Observable` that could emit a different number
    of items or a different type of event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter`: A transformation operator that uses a function that verifies if each
    item emitted by the source `Observable` satisfies a condition. If the condition
    passes the item, it is forwarded to the following `Subscriber`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first`: Emits only the first item emitted by the source `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Emits the number of items received from the original `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip`: Combines the emissions of two `Observables` using a function that receives
    the `N` item of each original `Observable` as an argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains`: Emits a `Boolean` event that indicates whether the source `Observable`
    has a specified `Object`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge`: Merges the events of multiple `Observers` into one event stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delay`: Delays the emission of an item by a specified amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more complete, detailed, and up-to-date list of operators supported by
    RxJava, check the `RxJava` Wiki on GitHub ([https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators](https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators)).
  prefs: []
  type: TYPE_NORMAL
- en: The `RxJava` operators generally process an `Observable` and return an `Observable`.
    This design feature allows us to chain the operators and create a composed sequence
    of operators that transform the event stream. The last operator is responsible
    for delivering the items to the `Subscriber`, or deliver an error when something
    goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create our first operator example that transforms a multiline text
    emitted by the source Observable and delivers a new deliver an Integer with the
    number of lines that contain the word `RxJava`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To start, we create an `Observable` from the original using the `Observable.just`
    creation operator passing the text source as the unique object.
  prefs: []
  type: TYPE_NORMAL
- en: Next, to split the original text in to lines, we use the `flatMap` operator,
    which receives the original text emitted by the first `Observable` and returns
    a new `Observable` created from the sliced lines array.
  prefs: []
  type: TYPE_NORMAL
- en: The new `Observable` coming from the `flatMap` operator will emit a single `String`
    for each line available on the original content, therefore, in order to count
    the lines with the word `RxJava`, we will discard the lines that don't have the
    word using the filter operator.
  prefs: []
  type: TYPE_NORMAL
- en: To finish, we will count the number of events emitted and publish the results
    to a Subscriber that is expecting an integer as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a graphical presentation of the previous functional pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transforming Observables](img/Image_B05062_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes. The extensive set of transformation operators allows us to create a complex
    functional processing chain that is able to transform the data on the way and
    deliver results to any `Subscriber` object in a readable and functional way.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an incorrect misconception and belief that `RxJava` processing is multithreaded
    by default. An `Observable` and the list of transformations applied by the specified
    operators occur on the same thread that the subscription is made.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, on Android, if the subscription is carried out on the main thread, the
    operators chain processing will run on the main thread, blocking the UI until
    the work is done.
  prefs: []
  type: TYPE_NORMAL
- en: While this behavior might work for lightweight processing tasks, when the operation
    requires IO interaction or CPU-intensive computing, the task execution might block
    the main `Thread` and crash the application with an ANR.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the asynchronous and concurrent executions, the `RxJava` framework
    allows us to define a `Scheduler` entity that defines the thread where a unit
    of work is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `subscribeOn(Scheduler)` operator allows us to set the Scheduler that defines
    the thread on which the subscription has been made and the Observable will start
    to operate.
  prefs: []
  type: TYPE_NORMAL
- en: When no Scheduler is specified, the Observable and operations will run on the
    thread that invoked the `subscribe` function.
  prefs: []
  type: TYPE_NORMAL
- en: On Android, a `subscribe` function is typically invoked from an Android Activity
    or Fragment that runs on the main Thread, then if any operation takes a substantial
    amount of time to finish it will block the UI Thread and degrade the UI responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: By controlling the thread where the subscription is made, we are controlling
    the thread where the Observable and its operators are going to execute and even
    the thread where the subscriber will receive the callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The `observeOn(Scheduler)` allows us to set the Scheduler that defines the thread
    in which the Observer callbacks (`onNext`, `onError`, `onCompleted`) are invoked.
  prefs: []
  type: TYPE_NORMAL
- en: During the Observable and operator chain, we can use `ObserveOn` several times
    to change the thread where the computation will run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify `Scheduler` use, the `RxJava` and the `RxAndroid` library compiled
    a list of predefined `Schedulers` ready to be used to create multithreaded asynchronous
    chains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Schedulers.immediate()`: Default `Scheduler` that returns a `Scheduler` that
    executes the work immediately in the current thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.trampoline()`: Returns a `Scheduler` that queues work in the current
    thread to be executed after the current work completes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.newThread()`: Returns a `Scheduler`, spawns a new thread, and executes
    the work on the new `Thread`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.computation()`: Returns a `Scheduler` intended for computational
    intensive work. This can be used for event loops, processing callbacks, and other
    computational work. Do not perform blocking IO work on this `Scheduler`. This
    Scheduler uses a fixed thread pool size where the size is dependent on the CPUs
    to optimize CPU usage and minimize CPU switching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedulers.io()`: Creates and returns a `Scheduler` that executes the work
    of a cached pool of threads that grows and shrinks as needed, reusing already
    created threads that are idle to execute the require work. This `Scheduler` is
    intended for asynchronously performing blocking IO tasks, such as network or file
    system read and write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scheduler.from(Executor)`: Creates a Scheduler that will execute the unit
    of work on the `java.util.concurrent.Executor` passed as argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AndroidSchedulers.mainThread()`: Creates a `Scheduler` that executes the required
    work on the Android application main thread. This Android `Scheduler`, provided
    by the `RxAndroid` library, is based on the `HandlerThread` that runs the unit
    of work serially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HandlerScheduler.from(Handler)`: Creates a Scheduler that executes work on
    a specified `Handler`. The `AndroidSchedulers.mainThread()` is of specialization
    of this `Scheduler` that runs on a `Handler` attached to the Android UI thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `Rxjava` uses `Schedulers.immediate()`, which subscribes to the
    Observer on the current thread and delivers the events in the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: RxJava allows us to define our own Scheduler, but for the scope of this book,
    we will only use the built-in Schedulers to cover our concurrency needs.
  prefs: []
  type: TYPE_NORMAL
- en: Performing IO operations with Schedulers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next example, we will use `Schedulers` to mirror the behavior of `AsyncTask`
    and retrieve text from the network on the background thread. Subsequently, the
    result will be published to a `Subscriber` that runs on the main `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will create a function that creates an `Observable` that emits
    the `String` retrieved from the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we specify the `Scheduler` used to run our asynchronous call, we need
    to state two assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: Since the code that runs on `Observable` performs a network operation we must
    run Observable on the background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To publish the result and update the UI, we must execute our Subscriber callbacks
    on the main `Thread`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s build up the asynchronous `RxJava` execution that retrieves the
    text and update the UI following the previous assumptions and using the `Scheduler`
    entities described earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`subscribeOn(Schedulers.io())` will make the `Observable` created by the `getTextFromNetwork`
    function run on the `Scheduler.io` thread pool intended for blocking IO operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we call the subscribe function, `downloadText` will be queued to run on
    a thread managed by the `Scheduler` created by `Schedulers.io()`, emitting the
    results as a `String` in the `onNext()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `observeOn(AndroidSchedulers.mainThread())` ensures that the Subscriber
    callbacks `onNext`, `onCompleted`, and `onError` will run on the Android main
    Thread. Therefore, if the network operation completes with success, `OnNext` is
    invoked updating EditText with the result obtained.
  prefs: []
  type: TYPE_NORMAL
- en: If any exception is thrown during the network execution, a `Throwable` object
    is delivered to the `Subscriber.onError` callback, which executes on the UI Thread,
    and a `Toast` that shows an error is displayed on the UI.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows how simple and concise an asynchronous `call` can be on `RxJava`.
    Moreover, it abstracts you from the thread management as `AsyncTask` does and
    provides you exception handling facilities to deal with exceptional errors.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling subscriptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an Activity or a Fragment gets destroyed, our chain could continue to run
    in the background, preventing the Activity from being disposed if the chain has
    references to the Activity or Fragment. When you no longer need the result of
    the chain, it could make sense to cancel the subscription and terminate the chain
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call the `Observable.subscribe()` function, it returns a Subscription
    object that can be used to terminate the chain immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the most appropriate Activity lifecycle method for this is `onPause`,
    which is guaranteed to be called before the Activity finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Composing Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we explained earlier, an `Observable` interface is defined in a way that
    allows us to chain and combine different `Observables` to create complex tasks
    in a functional and declarative way.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from our previous work, in our next example, we will make use of the
    `RxJava` composing feature and execute a second network call that depends on the
    previous `Observable` that will translate the text downloaded using a web service
    before we emit the translated text to the `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute the translation on the network on a logically separate unit, we
    will create a new `Observable` that receives the text to translate, executes the
    task on the network, and emits the translated text as a String to the following
    `Observable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are ready to chain the network executions and display the results
    on the UI using the same `Subscriber` used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The network IO operation defined on the `translateOnNetwork`, which depends
    on `getTextFromNetwork`, will only run if the previous operation finished with
    success, and takes the result from `getTextFromNetwork` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: After `translateOnNetwork Observable` receives the text content from the previous
    network operation, it will use it as input for its operation and will perform
    the translation of the previous content on the network, invoking the function
    `translateText(url, content)`.
  prefs: []
  type: TYPE_NORMAL
- en: Given that `translateText()` finishes with success, the translated content is
    delivered to the next Observable. Since the next Observable is the Subscriber,
    the result is delivered transparently on the main Thread to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, since we override the `Subscriber` is `onError` function, if something
    goes wrong during the execution of either network requests, the error is propagated
    to our callback to be handled properly. Hence, with a few lines of code, we are
    able to inform the user that an asynchronous task has failed and we were not able
    to deliver the expected data to them.
  prefs: []
  type: TYPE_NORMAL
- en: Great, with a few lines of code we created a complex task that performs a chain
    of asynchronous network operations in the background, delivering the results on
    the main thread, or delivering an error when something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the event stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although so far we have been using the `Observable` operators to manipulate
    stream events, there are operators that allow us to monitor the events without
    changing them. These operators, known sometimes as utility operators, are able
    to react to the events or errors emitted on the `Observable` chain created between
    the source `Observable` and the final `Subscriber` without creating any side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s enumerate them and explain the more common utility operators used to
    observe the event stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '`doOnSubscribe(Action0)`: Registers an `Action0` function to get called when
    a `Subscriber` subscribes to the `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnUnsubscribe(Action0)`: Registers an `Action0` function to get called when
    a `Subscriber` unsubscribes from the `Observable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnNext(Action1)`: Registers an `Action1` to be called when a new event is
    emitted from the source `Observable`. The Event `<T>` object is also passed as
    an argument to the `Action1` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnCompleted(Action0)`: Registers an `Action0` function to be called when
    the source `Observable` emits the `onComplete` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnError(Action1)`: Registers an `Action1` function to be called when an
    error is emitted from the source `Observable`. The `Throwable` emitted on the
    `OnError` is also passed to the `Action1.call` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`doOnTerminate(Action0)`: Registers an `Action0` function to be invoked when
    an error or `onComplete` is emitted by the source `Observable`. This callback
    function also means that the previous `Observable` will emit no more items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These multipurpose operators will allow us to observe and debug complex chains
    that usually involve several transformations, create progress dialogs to show
    progress, cache results, and even generate processing analytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our next example, we will make use of these operators to log the progress
    of our previous multi network operation in the Android Log, and to present a progress
    dialog on screen as long as the operation is progressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you know, to make changes in the Android UI, it is imperative to run your
    code on the main Thread. Hence, in order to receive `doOnNext` from the first
    `Observable` in the main thread, we invoke `subscribeOn()` with `AndroidSchedulers.mainThread()`
    forcing the first `Observable`, the one created with the `just` operator, to emit
    notifications to `doOnNext` in the main Thread.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as `doOnNext()` receives the notification with the String carrying the
    URL to retrieve the text, we display ProgressDialog in the UI and we log a message
    in the Android Log.
  prefs: []
  type: TYPE_NORMAL
- en: Next, since we want to perform network operations off the main thread, using
    the `observeOn` operator, we force following `Observables` to send notifications
    to the threads managed by the `IO Scheduler`. This means that the following operators
    and `Observables` will execute and emit events in the IO `Scheduler` threads.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, between each network operation, we intercept the start of the
    second network operation to print the message in Android with a `doOnNext` between
    `getTextFromNetwork` and `translateOnNetwork Observables`.
  prefs: []
  type: TYPE_NORMAL
- en: When the network operations finish, and before we update the UI with the results
    and we dismiss the progress dialog, we switch the execution to the main thread
    by again invoking the operator `observeOn()` with the main `Thread Scheduler`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we display the results on the screen, with the `doOnTerminate` operator
    we register an `Action` function to be called to dismiss the progress dialog previously
    started. As described before, the function will be invoked, whether the chain
    terminates with success or with an error.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, the `Subscriber` callbacks will be invoked to update the UI with
    the results returned or to show an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the network operation terminates with success you should see a similar logging
    stream in the Android Log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For debugging purposes, `[<Thread_Name>]` shows the name of the thread that
    logged the message.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous example, we used two `Observable` to create a simple sequence
    of network operations. The second asynchronous operation operated with the result
    of the first operation and the two operations that executed serially produced
    a String result that updates the UI.
  prefs: []
  type: TYPE_NORMAL
- en: In our next example, we will run two tasks in parallel and combine the results
    of both operations using a combining `RxJava` operator. Each operation will retrieve
    asynchronously a JSON Object from the network and combine both results in the
    JSON Object to produce the JSON `String` passed to the UI main `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we only want to emit one Event or an error from the operation, we are
    going to use, for the first time, a special kind of Observer, `Single`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While an `Observable` is able to invoke `onNext`, `onError`, and `onCompleted`
    Observer functions, a `Single` entity will only invoke either `onSuccess` or `onError`
    to a `SingleSubscriber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: After one of the callback functions is called, the `Single` finishes and the
    subscription to it ends. Like a regular `Observable`, the `Single` object emitted
    event can be processed with operators before it reaches the final `SingleSubscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the two `Single` operations that retrieve a single `JSONObject`
    from the network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Like we did for the previous `Observable`, we used the `Single.create` static
    function to build a custom `Single` entity that either explicitly calls the `SingleSubscriber.onSuccess`
    function when the network operation finishes with success, or calls the `SingleSubscriber.onError`
    function when an error is thrown on the `getJson` IO operation.
  prefs: []
  type: TYPE_NORMAL
- en: The `getJSON` function will basically retrieve a JSON Object by connecting to
    the HTTP URL provided as an argument and return a `JSONObject`.
  prefs: []
  type: TYPE_NORMAL
- en: By forcing the Single to `subscribeOn` the `newThread Sheduler`, we are allowing
    each custom `Single` entity to run their operation concurrently on a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: Since the two operations will run in parallel, we need to use the combining
    operator to combine the `Single` results together in a single `JSONObject` and
    emit the resulting JSON `String` to the final `SingleSubscriber`. The appropriate
    combining operator for our example is zip, because it is able to wait for the
    result of two or more `Single/Observable` and apply a function to each `Single`
    output object.
  prefs: []
  type: TYPE_NORMAL
- en: The function that receives the emitted objects as an argument can produce a
    result of the same type or of a different type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `zip` operator function definition for combining two Singles into
    a `Single<R>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In our example, `R` is a String, `T1` and `T2` are a `JSONObject`, and `zipFunction`
    receives the `JSONObjects` arguments to generate a `String` as the result.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to use the `zip` operator and combine the result of each independent
    asynchronous operation into a `String`. The resulting string will update a `Widget`,
    so the final `Subscriber` should be invoked in the main Thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the functional code that fetches the `JSONObject` parts and dispatches
    the resulting `String` to the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using the zip operator, we combined the result of the two operations, `postSingle`
    and `authorSingle`, that ran on a new thread created by the `newThread` Scheduler,
    on the `Func2` that received the two `JSONObjects` as arguments and produced a
    `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we subscribed the `Single` to work on its own Thread, the `zip` function
    will combine the result of both `Singles` on the thread built by the last defined
    Single (`authorSingle`) resulting in a log similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: After combining the objects, the `String` produced by `Func2` is delivered to
    the final `Subscriber` in the main `Thread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains is to implement the trivial `SingleSubscriber` that updates
    the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Observing UI Events with RxJava
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using `RxJava` to process and manipulate data streams,
    which simplified the development of asynchronous that require IO blocking operations
    that will hang the application for a while.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we want to explain how to use `RxJava` and reactive streams
    to simplify the handling of UI events generated from Android Widgets.
  prefs: []
  type: TYPE_NORMAL
- en: In our next example, we will present a list of Soccer Teams with an instant
    search result input field. As you type in the input field, the names available
    in the list will be filtered if the text that you typed matches the beginning
    of any soccer team on the list.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve the result required, we will create a custom `Observable` that attaches
    a `TextWatcher` to the searching input field, listens for `onTextChanged` events,
    and emits a String event when the text changes.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer will feed a reactive functional stream that will filter our list
    of teams in a Recycler View.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will write a Custom Observable that registers `TextWatcher` to `EditField`
    when an `Observer` subscribes, and deregisters `TextWatcher` when the subscription
    finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `TextChangeOnSubscribe` class, which implements the `OnSubscribe<String>`
    and receives a subscription callback, will set a `TextWatcher` in the received
    `EditField` once the subscription is performed by the `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: When `TextWatcher.onTextChanged` is invoked to notify a text change in `EditField`,
    a new String event with the new content should be emitted in the Subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: To unregister the `TextWatcher` in the `EditField`, we add a `MainThreadSubscription`
    anonymous class to the subscriber list that removes our `TextChangeListener` in
    the `EditField`.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the text change event from generating too many updates in the UI,
    we used the `debounce` operator to only emit a new search term if there's been
    a 400 millisecond delay since the last text change event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will use the search Events generated by our `Observable` to filter
    the teams available in the `ReciclerView` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To filter the soccer team list with the search term emitted by the `textChangeEvent`
    we applied the operator `combineLatest` to `textChangeObs` `Observable` and to
    the `Observable` created from the soccer team list with the operator just.
  prefs: []
  type: TYPE_NORMAL
- en: The `combineLatest` will combine the latest item emitted by each `Observable`
    using a specified function and emit items based on the results of this function
    invocation.
  prefs: []
  type: TYPE_NORMAL
- en: The function that combines both `Observables` will simply filter the soccer
    list with the last text content emitted by the `onTextChanged` and sort the resulting
    list.
  prefs: []
  type: TYPE_NORMAL
- en: To finalize, a new `RecyclerView.Adapter` is created with the resulting `List<String>`
    and the filtered list of teams will be displayed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that to update our `RecyclerView` with the resulting filtered list, we
    explicitly set the `Observer` to run on the main Thread by passing the Android
    main Thread `Scheduler` to the `observeOn` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to terminate the subscription before the Activity is destroyed
    by calling `subcription.unsubscribe();`
  prefs: []
  type: TYPE_NORMAL
- en: Although, for educational purposes, we built our own Observables from the Android
    EditField Widget text change events, there is an easy-to-use, open source library
    named RxBinding ([https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding))
    that is able to create Observables for most Android Widgets available on the Android
    SDK.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't want to implement your own Observables, or process UI events in
    a traditional way, you can make use of it to process Android UI events using a
    functional RxJava reactive paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been working with `Observables`, `Subscriber`, `Observer`,
    and `Scheduler` entities to create our `RxJava` functional processing lines. In
    this section, we will introduce the reader to a new kind of entity in the `RxJava`
    framework, the `Subject`. The `Subject` is a sort of adapter or bridge entity
    that acts as an `Observable` and `Observer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since it can act as a `Subscriber`, it can subscribe to one or more `Observables`
    that emit `Objects` of the generic type `T`, and since it acts as an `Observable`,
    it can emit events of the generic type `R` and receive subscriptions from other
    `Subscriber`. Hence, it can emit events of the same type as received or emit a
    different type of event.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `Subject<String, Integer>` will receive events of type `String`
    and emit events of the type `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Subject` could receive the events from the `Observable` and generate a
    new event stream with different timings, proxy the events, convert to a new kind
    of event, queue the events, transform the events, or even generate new events.
  prefs: []
  type: TYPE_NORMAL
- en: A `Subject` is always considered a hot `Observable` and will begin emitting
    events as soon as it is created. This is a very important `Subject` feature and
    you should consider it when you want to process the full event stream sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**RxJava** comes with some standard **Subject** classes designed to be used
    in distinctive use cases. The list below will enumerate the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncSubject`: Subjects that will only emit the last item emitted by the source
    `Observable` when the source `Observer` completes the stream by calling `onComplete()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublishSubject`: The Subject only delivers to the Observers the events emitted
    after their subscription'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ReplaySubject`: Emits all the events emitted by the source `Observable`, even
    those that were emitted before the subscription is made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BehaviorSubject`: Emits the last emitted item by the source `Observable` when
    the subscription is done, then continues to any other items emitted by the source
    observable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we will show you how to use `PublishSubject` and
    demonstrate how the events are propagated to a final `Observer` that subscribes
    and later unsubscribes to the `Subject`. Moreover, we will submit events to `Subject`
    before and after the subscription is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, we created the `PublishSubject` by calling the `PublishSubject.create`
    static function, and then we started delivering integers to it and calling the
    `onNext` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we subscribed to the `Subject` with an `Action1` function in
    order to consume the events.
  prefs: []
  type: TYPE_NORMAL
- en: To print the exact time when the subscription and unsubscription is made, we
    provided an `Action0` function to the `doOnUnsubscribe` and `doOnSubscribe` that
    prints a message to the Android Log.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the code above should output the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As described before, only the events dispatched while the final `Observer` is
    subscribed are emitted to the `Action` callback. Therefore, the events submitted
    before the subscriptions and after the unsubscription are not received by our
    Subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for comparison, let's try to compare the event stream emitted by a `ReplaySubject`,
    with the exact sequence of events submitted to the Subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the `ReplaySubject` class was built by calling the create static function,
    and as a result, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: On the [http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)
    website, there are diagrams to help you understand graphically the interactions
    between Subjects, Subscribers, and source Observables.
  prefs: []
  type: TYPE_NORMAL
- en: As expected, `ReplaySubject` will receive all the events submitted to the `Subject`,
    even the ones delivered before the subscription was made are received by the `Observer`.
    After the `Observer` unsubscribes, it stops receiving the events from the `Subject`.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can try to create the same for the `AsyncSubject` and `BehaviorSubject`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we learned how to use `RxJava`, an open source library
    that helps to process our Android application data or event streams using functional
    and reactive processing pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the first sections, we learned in detail some of `RxJava` basic building
    blocks—`Observable`, `Observer`, and `Subscriber`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduced some of `RxJava` most common operators that are able to
    manipulate, transform, and combine event streams generated by an `Observable`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform operations asynchronously and concurrently, we learned about
    the `Scheduler`, a magic `RxJava` entity that controls the concurrency, and is
    able to schedule `RxJava` units of work to run in background threads and feed
    the results back to the main Android Thread.
  prefs: []
  type: TYPE_NORMAL
- en: Next, using custom `Observables` and combining operators, we learned how to
    associate and compose interdependent complex blocking or long computing operations,
    such as REST API network operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we also learned how to react to a custom `Observable` that
    emits Android Widget UI events using a `RxJava` event functional pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about the `Subject` `RxJava` entity, an entity that can
    act as an `Observer` and `Observable` and can act as a proxy between our source
    `Observable` and the final `Observer`.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of this book, we've armed ourselves with a powerful array of
    tools for building responsive Android applications. We discovered that it is incredibly
    important to move as much work as possible off the main thread, and explored a
    number of constructs and asynchronous techniques to make the smoothest and most
    awesome experience for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that to keep your application responsive and avoid any UI lost frames,
    an Android callback (`Service`, `Activity`, and so on) that runs on the main UI
    Thread should terminate in under 16 ms.
  prefs: []
  type: TYPE_NORMAL
