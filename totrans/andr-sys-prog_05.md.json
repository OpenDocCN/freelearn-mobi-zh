["```kt\nenum class NativeBridgeState { \n  kNotSetup,               // Initial state. \n  kOpened,                 // After successful dlopen. \n  kPreInitialized,         // After successful pre-initialization. \n  kInitialized,            // After successful initialization. \n  kClosed                  // Closed or errors. \n}; \n\n```", "```kt\nbool Runtime::Init(const RuntimeOptions& raw_options, bool ignore_unrecognized) { \n  ATRACE_BEGIN(\"Runtime::Init\"); \n  CHECK_EQ(sysconf(_SC_PAGE_SIZE), kPageSize); \n  ... \n    std::string native_bridge_file_name = \n    runtime_options.ReleaseOrDefault(Opt::NativeBridge); \n    is_native_bridge_loaded_ = \n    LoadNativeBridge(native_bridge_file_name);  \n   ... \n} \n\n```", "```kt\nstatic android::NativeBridgeRuntimeCallbacks native_bridge_art_callbacks_ { \n  GetMethodShorty, GetNativeMethodCount, GetNativeMethods \n}; \n\nbool LoadNativeBridge(std::string& native_bridge_library_filename) { \n  VLOG(startup) << \"Runtime::Setup native bridge library: \" \n      << (native_bridge_library_filename.empty() ? \"(empty)\" : \n      native_bridge_library_filename); \n  return android::LoadNativeBridge(native_bridge_library_filename.c_str(), \n                                   &native_bridge_art_callbacks_); \n} \n\n```", "```kt\n// Runtime interfaces to native bridge. \nstruct NativeBridgeRuntimeCallbacks { \n  // Get shorty of a Java method. The shorty is supposed to be   \n  persistent in \n  // memory. \n  // \n  // Parameters: \n  //   env [IN] pointer to JNIenv. \n  //   mid [IN] Java methodID. \n  // Returns: \n  //   short descriptor for method. \n  const char* (*getMethodShorty)(JNIEnv* env, jmethodID mid); \n\n  // Get number of native methods for specified class. \n  // \n  // Parameters: \n  //   env [IN] pointer to JNIenv. \n  //   clazz [IN] Java class object. \n  // Returns: \n  //   number of native methods. \n  uint32_t (*getNativeMethodCount)(JNIEnv* env, jclass clazz); \n\n  // Get at most 'method_count' native methods for specified class \n  'clazz'. \n  // Results are outputed \n  // via 'methods' [OUT]. The signature pointer in JNINativeMethod is \n  reused \n  // as the method shorty. \n  // \n  // Parameters: \n  //   env [IN] pointer to JNIenv. \n  //   clazz [IN] Java class object. \n  //   methods [OUT] array of method with the name, shorty, and fnPtr. \n  //   method_count [IN] max number of elements in methods. \n  // Returns: \n  //   number of method it actually wrote to methods. \n  uint32_t (*getNativeMethods)(JNIEnv* env, jclass clazz, \n  JNINativeMethod* methods, uint32_t method_count); \n}; \n\n```", "```kt\nbool LoadNativeBridge(const char* nb_library_filename, \n          const NativeBridgeRuntimeCallbacks* runtime_cbs) { \n\n  if (state != NativeBridgeState::kNotSetup) { \n    // Setup has been called before. Ignore this call. \n    if (nb_library_filename != nullptr) { \n         ALOGW(\"Called LoadNativeBridge for an already set up native  \n           bridge. State is %s.\", GetNativeBridgeStateString(state)); \n    } \n    had_error = true; \n    return false; \n  } \n\n  if (nb_library_filename == nullptr || *nb_library_filename == 0) \n  { \n    CloseNativeBridge(false); \n    return false; \n  } else { \n    if (!NativeBridgeNameAcceptable(nb_library_filename)) { \n      CloseNativeBridge(true); \n    } else { \n      // Try to open the library. \n      void* handle = dlopen(nb_library_filename, RTLD_LAZY); \n      if (handle != nullptr) { \n        callbacks = \n            reinterpret_cast<NativeBridgeCallbacks*>(dlsym(handle, \n            kNativeBridgeInterfaceSymbol)); \n        if (callbacks != nullptr) { \n          if (VersionCheck(callbacks)) { \n            // Store the handle for later. \n            native_bridge_handle = handle; \n          } else { \n            callbacks = nullptr; \n            dlclose(handle); \n            ALOGW(\"Unsupported native bridge interface.\"); \n          } \n        } else { \n          dlclose(handle); \n        } \n      } \n\n      if (callbacks == nullptr) { \n        CloseNativeBridge(true); \n      } else { \n        runtime_callbacks = runtime_cbs; \n        state = NativeBridgeState::kOpened; \n      } \n    } \n    return state == NativeBridgeState::kOpened; \n  } \n} \n\n```", "```kt\nstd::string native_bridge_file_name = runtime_options.ReleaseOrDefault(Opt::NativeBridge); \n\n```", "```kt\nint AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote) \n{ \n... \n    // Native bridge library. \"0\" means that native bridge is disabled. \n    property_get(\"ro.dalvik.vm.native.bridge\", propBuf, \"\"); \n    if (propBuf[0] == '\\0') { \n        ALOGW(\"ro.dalvik.vm.native.bridge is not expected to be \n          empty\"); \n    } else if (strcmp(propBuf, \"0\") != 0) { \n        snprintf(nativeBridgeLibrary, sizeof(\"-XX:NativeBridge=\") + \n        PROPERTY_VALUE_MAX, \"-XX:NativeBridge=%s\", propBuf); \n        addOption(nativeBridgeLibrary); \n    } \n... \n} \n\n```", "```kt\nstruct NativeBridgeCallbacks { \n  uint32_t version; \n  bool (*initialize)(const NativeBridgeRuntimeCallbacks*   \n       runtime_cbs, const char* private_dir, const char*  \n       instruction_set); \n  void* (*loadLibrary)(const char* libpath, int flag); \n  void* (*getTrampoline)(void* handle, const char* name, const  \n        char* shorty, uint32_t len); \n  bool (*isSupported)(const char* libpath); \n  const struct NativeBridgeRuntimeValues* (*getAppEnv)(const char*  \n       instruction_set); \n  bool (*isCompatibleWith)(uint32_t bridge_version); \n  NativeBridgeSignalHandlerFn (*getSignalHandler)(int signal); \n}; \n\n```", "```kt\nstatic pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t \n    gid, jintArray javaGids, jint debug_flags, jobjectArray \n    javaRlimits, jlong permittedCapabilities, jlong \n    effectiveCapabilities, jint mount_external, jstring \n    java_se_info, jstring java_se_name, bool is_system_server,  \n    jintArray fdsToClose, jstring instructionSet, jstring dataDir) { \n      SetSigChldHandler(); \n\n#ifdef ENABLE_SCHED_BOOST \n  SetForkLoad(true); \n#endif \n... \n  pid_t pid = fork(); \n\n  if (pid == 0) { \n    // The child process. \n... \n    bool use_native_bridge = !is_system_server && (instructionSet != \n    NULL) && android::NativeBridgeAvailable(); \n    if (use_native_bridge) { \n      ScopedUtfChars isa_string(env, instructionSet); \n      use_native_bridge = \n      android::NeedsNativeBridge(isa_string.c_str()); \n    } \n    if (use_native_bridge && dataDir == NULL) { \n      use_native_bridge = false; \n      ALOGW(\"Native bridge will not be used because dataDir == NULL.\"); \n    } \n\n    if (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) { \n      ALOGW(\"Failed to mount emulated storage: %s\", strerror(errno)); \n      if (errno == ENOTCONN || errno == EROFS) { \n      } else { \n        RuntimeAbort(env, __LINE__, \"Cannot continue without emulated \n        storage\"); \n      } \n    } \n\n    if (!is_system_server) { \n        int rc = createProcessGroup(uid, getpid()); \n        if (rc != 0) { \n            if (rc == -EROFS) { \n                ALOGW(\"createProcessGroup failed, kernel missing \n                CONFIG_CGROUP_CPUACCT?\"); \n            } else { \n                ALOGE(\"createProcessGroup(%d, %d) failed: %s\", uid, \n                pid, strerror(-rc)); \n            } \n        } \n    } \n\n    SetGids(env, javaGids); \n\n    SetRLimits(env, javaRlimits); \n\n    if (use_native_bridge) { \n      ScopedUtfChars isa_string(env, instructionSet); \n      ScopedUtfChars data_dir(env, dataDir); \n      android::PreInitializeNativeBridge(data_dir.c_str(), \n      isa_string.c_str()); \n    } \n... \n    env->CallStaticVoidMethod(gZygoteClass, \n           gCallPostForkChildHooks,  \n           debug_flags, is_system_server ? NULL : instructionSet);  \n... \n  } else if (pid > 0) { \n    // the parent process \n\n#ifdef ENABLE_SCHED_BOOST \n    // unset scheduler knob \n    SetForkLoad(false); \n#endif \n\n  } \n  return pid; \n} \n\n```", "```kt\nbool NeedsNativeBridge(const char* instruction_set) { \n  if (instruction_set == nullptr) { \n    ALOGE(\"Null instruction set in NeedsNativeBridge.\"); \n    return false; \n  } \n  return strncmp(instruction_set, kRuntimeISA,  \n               strlen(kRuntimeISA) + 1) != 0; \n} \n\n```", "```kt\nbool PreInitializeNativeBridge(const char* app_data_dir_in,  \n     const char* instruction_set) { \n  if (state != NativeBridgeState::kOpened) { \n    ALOGE(\"Invalid state: native bridge is expected to be opened.\"); \n    CloseNativeBridge(true); \n    return false; \n  } \n\n  if (app_data_dir_in == nullptr) { \n    ALOGE(\"Application private directory cannot be null.\"); \n    CloseNativeBridge(true); \n    return false; \n  } \n\n  const size_t len = strlen(app_data_dir_in) +  \n                    strlen(kCodeCacheDir) + 2; // '\\0' + '/' \n  app_code_cache_dir = new char[len]; \n  snprintf(app_code_cache_dir, len, \"%s/%s\", app_data_dir_in,  \n  kCodeCacheDir); \n\n state = NativeBridgeState::kPreInitialized; \n\n#ifndef __APPLE__ \n  if (instruction_set == nullptr) { \n    return true; \n  } \n  size_t isa_len = strlen(instruction_set); \n  if (isa_len > 10) { \n    ALOGW(\"Instruction set %s is malformed, must be less than or equal \n    to 10 characters.\", instruction_set); \n    return true; \n  } \n\n  char cpuinfo_path[1024]; \n\n#if defined(__ANDROID__) \n  snprintf(cpuinfo_path, sizeof(cpuinfo_path), \"/system/lib\" \n#ifdef __LP64__ \n      \"64\" \n#endif  // __LP64__ \n      \"/%s/cpuinfo\", instruction_set); \n#else   // !__ANDROID__ \n  snprintf(cpuinfo_path, sizeof(cpuinfo_path), \"./cpuinfo\"); \n#endif \n\n  // Bind-mount. \n  if (TEMP_FAILURE_RETRY(mount(cpuinfo_path, \n                               \"/proc/cpuinfo\", \n                               nullptr, \n                               MS_BIND, \n                               nullptr)) == -1) { \n    ALOGW(\"Failed to bind-mount %s as /proc/cpuinfo: %s\", cpuinfo_path, \n    strerror(errno)); \n  } \n#else  // __APPLE__ \n  UNUSED(instruction_set); \n  ALOGW(\"Mac OS does not support bind-mounting. Host simulation of \n  native bridge impossible.\"); \n#endif \n\n  return true; \n} \n\n```", "```kt\nstatic void ZygoteHooks_nativePostForkChild(JNIEnv* env,  \n    jclass, jlong token, jint debug_flags,  \n    jstring instruction_set) { \n... \n  if (instruction_set != nullptr) { \n    ScopedUtfChars isa_string(env, instruction_set); \n    InstructionSet isa = \n    GetInstructionSetFromString(isa_string.c_str()); \n    Runtime::NativeBridgeAction action = \n    Runtime::NativeBridgeAction::kUnload; \n    if (isa != kNone && isa != kRuntimeISA) { \n      action = Runtime::NativeBridgeAction::kInitialize; \n    } \n    Runtime::Current()->DidForkFromZygote(env, action, \n    isa_string.c_str()); \n  } else { \n    Runtime::Current()->DidForkFromZygote(env, \n    Runtime::NativeBridgeAction::kUnload, nullptr); \n  } \n} \n\n```", "```kt\nvoid Runtime::DidForkFromZygote(JNIEnv* env,  \n    NativeBridgeAction action, const char* isa) { \n  is_zygote_ = false; \n\n  if (is_native_bridge_loaded_) { \n    switch (action) { \n      case NativeBridgeAction::kUnload: \n        UnloadNativeBridge(); \n        is_native_bridge_loaded_ = false; \n        break; \n\n      case NativeBridgeAction::kInitialize: \n InitializeNativeBridge(env, isa); \n        break; \n    } \n  } \n... \n} \n\n```", "```kt\nbool InitializeNativeBridge(JNIEnv* env,  \n    const char* instruction_set) { \n\n  if (state == NativeBridgeState::kPreInitialized) { \n    // Check for code cache: if it doesn't exist try to create it. \n    struct stat st; \n    if (stat(app_code_cache_dir, &st) == -1) { \n      if (errno == ENOENT) { \n        if (mkdir(app_code_cache_dir, S_IRWXU | S_IRWXG | S_IXOTH) \n        == -1) { \n          ALOGW(\"Cannot create code cache directory %s: %s.\", \n          app_code_cache_dir, strerror(errno)); \n          ReleaseAppCodeCacheDir(); \n        } \n      } else { \n        ALOGW(\"Cannot stat code cache directory %s: %s.\", \n        app_code_cache_dir, strerror(errno)); \n        ReleaseAppCodeCacheDir(); \n      } \n    } else if (!S_ISDIR(st.st_mode)) { \n      ALOGW(\"Code cache is not a directory %s.\", app_code_cache_dir); \n      ReleaseAppCodeCacheDir(); \n    } \n\n    if (state == NativeBridgeState::kPreInitialized) { \n      if (callbacks->initialize(runtime_callbacks, app_code_cache_dir, \n      instruction_set)) { \n        SetupEnvironment(callbacks, env, instruction_set); \n        state = NativeBridgeState::kInitialized; \n        ReleaseAppCodeCacheDir(); \n      } else { \n        // Unload the library. \n        dlclose(native_bridge_handle); \n        CloseNativeBridge(true); \n      } \n    } \n  } else { \n    CloseNativeBridge(true); \n  } \n\n  return state == NativeBridgeState::kInitialized; \n} \n\n```", "```kt\nbool JavaVMExt::LoadNativeLibrary(JNIEnv* env,  \n    const std::string& path, jobject class_loader,  \n    std::string* error_msg) { \n... \n  const char* path_str = path.empty() ? nullptr : path.c_str(); \n  void* handle = dlopen(path_str, RTLD_NOW); \n  bool needs_native_bridge = false; \n  if (handle == nullptr) { \n    if (android::NativeBridgeIsSupported(path_str)) { \n      handle = android::NativeBridgeLoadLibrary(path_str, RTLD_NOW); \n      needs_native_bridge = true; \n    } \n  } \n... \n  bool was_successful = false; \n  void* sym; \n  if (needs_native_bridge) { \n    library->SetNeedsNativeBridge(); \n sym = library->FindSymbolWithNativeBridge(\"JNI_OnLoad\", nullptr); \n  } else { \n    sym = dlsym(handle, \"JNI_OnLoad\"); \n  } \n... \n    typedef int (*JNI_OnLoadFn)(JavaVM*, void*); \n    JNI_OnLoadFn jni_on_load = reinterpret_cast<JNI_OnLoadFn>(sym); \n int version = (*jni_on_load)(this, nullptr);  \n... \n} \n\n```", "```kt\nbool NativeBridgeIsSupported(const char* libpath) { \n  if (NativeBridgeInitialized()) { \n    return callbacks->isSupported(libpath); \n  } \n  return false; \n} \n\n```", "```kt\nvoid* NativeBridgeLoadLibrary(const char* libpath, int flag) { \n  if (NativeBridgeInitialized()) { \n    return callbacks->loadLibrary(libpath, flag); \n  } \n  return nullptr; \n} \n\n```", "```kt\nvoid* FindSymbolWithNativeBridge(const std::string& symbol_name, \nconst char* shorty) { \n    CHECK(NeedsNativeBridge()); \n\n    uint32_t len = 0; \n    return android::NativeBridgeGetTrampoline(handle_,  \n    symbol_name.c_str(), shorty, len); \n} \n\n```", "```kt\nvoid* NativeBridgeGetTrampoline(void* handle, const char* name, \nconst char* shorty, uint32_t len) { \n  if (NativeBridgeInitialized()) { \n    return callbacks->getTrampoline(handle, name, shorty, len); \n  } \n  return nullptr; \n} \n\n```", "```kt\n$ cd device/generic/x86emu\n$ git checkout android-7.1.1_r4_x86emu_ch04_r1\n$ git branch android-7.1.1_r4_ch05\n$ git checkout android-7.1.1_r4_ch05  \n\n```", "```kt\n$ repo init -u https://github.com/shugaoye/manifests -b android-7.1.1_r4_ch05_aosp\n$ repo sync\n\n```", "```kt\n$ repo init -u {your local mirror}/github/manifests.git -b android-7.1.1_r4_ch05\n$ repo sync  \n\n```", "```kt\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<manifest> \n\n  <remote  name=\"github\" \n           fetch=\".\" /> \n\n  <remote  name=\"aosp\" \n           fetch=\"https://android.googlesource.com/\" /> \n  <default revision=\"refs/tags/android-7.1.1_r4\" \n           remote=\"aosp\" \n           sync-c=\"true\" \n           sync-j=\"1\" /> \n\n  <!-- github/shugaoye --> \n  <project path=\"kernel\" name=\"goldfish\" remote=\"github\"   \n  revision=\"refs/tags/android-7.1.1_r4_x86emu_ch05_r1\" /> \n  <project path=\"device/generic/common\" name=\"device_generic_common\" \n   groups=\"pdk\" \n  remote=\"github\" revision=\"refs/tags/android-7.1.1_r4_x86emu_ch05_r1\" /> \n  <project path=\"device/generic/goldfish\" \n  name=\"device_generic_goldfish\" \n  remote=\"github\" groups=\"pdk\" revision=\"refs/tags/android- \n  7.1.1_r4_x86emu_ch05_r1\" /> \n  <project path=\"device/generic/x86emu\" name=\"x86emu\" remote=\"github\" \n  revision=\"refs/tags/android-7.1.1_r4_x86emu_ch05_r1\" /> \n\n  <!-- aosp --> \n  <project path=\"build\" name=\"platform/build\" groups=\"pdk,tradefed\" > \n    <copyfile src=\"img/root.mk\" dest=\"Makefile\" /> \n... \n</manifest> \n\n```", "```kt\n... \n# houdini \n# Native Bridge ABI List \nNATIVE_BRIDGE_ABI_LIST_32_BIT := armeabi-v7a armeabi \nNATIVE_BRIDGE_ABI_LIST_64_BIT := arm64-v8a \nTARGET_CPU_ABI_LIST_32_BIT := $(TARGET_CPU_ABI) $(TARGET_CPU_ABI2) $(NATIVE_BRIDGE_ABI_LIST_32_BIT) \nTARGET_CPU_ABI_LIST := $(TARGET_CPU_ABI_LIST_32_BIT) \n\nBUILD_ARM_FOR_X86 := $(WITH_NATIVE_BRIDGE) \n... \n\n```", "```kt\n... \nPRODUCT_PROPERTY_OVERRIDES := \\ \n    persist.sys.nativebridge=1 \\ \n\nNB_PATH := $(LOCAL_PATH) \nNB_LIB_PATH := system/lib \nNB_ARM_PATH := $(NB_LIB_PATH)/arm \nNB_NBLIB_PATH := $(NB_ARM_PATH)/nb \nNB_BIN_PATH := system/bin \n\nPRODUCT_COPY_FILES += $(foreach LIB, $(filter-out nb liblog_legacy.so libbinder_legacy.so,\\  \n      $(notdir $(wildcard $(NB_PATH)/$(NB_ARM_PATH)/*))), $(NB_PATH)/$(NB_ARM_PATH)/$(LIB):$(NB_ARM_PATH)/$(LIB):intel) \nPRODUCT_COPY_FILES += $(foreach NB, $(filter-out libbinder_legacy.so, $(notdir $(wildcard $(NB_PATH)/$(NB_NBLIB_PATH)/*))),\\  \n      $(NB_PATH)/$(NB_NBLIB_PATH)/$(NB):$(NB_NBLIB_PATH)/$(NB):intel) \n... \n\n```", "```kt\n... \n# Get native bridge settings \n$(call inherit-product-if-exists,device/generic/common/nativebridge/nativebridge.mk) \n... \n\n```", "```kt\n# Enable native bridge \nWITH_NATIVE_BRIDGE := true \n\n# Native Bridge ABI List \nNATIVE_BRIDGE_ABI_LIST_32_BIT := armeabi-v7a armeabi \nNATIVE_BRIDGE_ABI_LIST_64_BIT := arm64-v8a \n\nLOCAL_SRC_FILES := bin/enable_nativebridge \n\nPRODUCT_COPY_FILES := $(foreach f,$(LOCAL_SRC_FILES),$(LOCAL_PATH)/$(f):system/$(f)) \n\nPRODUCT_PROPERTY_OVERRIDES := \\ \n    ro.dalvik.vm.isa.arm=x86 \\ \n    ro.enable.native.bridge.exec=1 \\  \n\nifeq ($(TARGET_SUPPORTS_64_BIT_APPS),true) \nPRODUCT_PROPERTY_OVERRIDES += \\ \n    ro.dalvik.vm.isa.arm64=x86_64 \\ \n    ro.enable.native.bridge.exec64=1 \nendif \n\nPRODUCT_DEFAULT_PROPERTY_OVERRIDES := ro.dalvik.vm.native.bridge=libnb.so \n\nPRODUCT_PACKAGES := libnb \n\n$(call inherit-product-if-exists,vendor/intel/houdini/houdini.mk) \n\n```", "```kt\n#define LOG_TAG \"libnb\" \n\n#include <dlfcn.h> \n#include <cutils/log.h> \n#include <cutils/properties.h> \n#include \"nativebridge/native_bridge.h\" \n\nnamespace android { \n\nstatic void *native_handle = nullptr; \n\nstatic NativeBridgeCallbacks *get_callbacks() \n{ \n    static NativeBridgeCallbacks *callbacks = nullptr; \n\n    if (!callbacks) { \n        const char *libnb = \"/system/\" \n        #ifdef __LP64__ \n                \"lib64/arm64/\" \n        #else \n                \"lib/arm/\" \n        #endif \n                \"libhoudini.so\"; \n        if (!native_handle) { \n            native_handle = dlopen(libnb, RTLD_LAZY); \n            if (!native_handle) { \n                ALOGE(\"Unable to open %s\", libnb); \n                return nullptr; \n            } \n        } \n        callbacks = reinterpret_cast<NativeBridgeCallbacks *> \n        (dlsym(native_handle, \"NativeBridgeItf\")); \n    } \n    return callbacks; \n} \n\n// NativeBridgeCallbacks implementations \nstatic bool native_bridge2_initialize(const    \n  NativeBridgeRuntimeCallbacks *art_cbs, const char  \n  *app_code_cache_dir, const char *isa) \n{ \n    ALOGV(\"enter native_bridge2_initialize %s %s\", \n    app_code_cache_dir, isa); \n    if (property_get_bool(\"persist.sys.nativebridge\", 0)) { \n        if (NativeBridgeCallbacks *cb = get_callbacks()) { \nreturn cb->initialize(art_cbs, app_code_cache_dir, isa); \n        } \n    } else { \n        ALOGW(\"Native bridge is disabled\"); \n    } \n    return false; \n} \n\nstatic void *native_bridge2_loadLibrary(const char *libpath, int flag) \n{ \n    ALOGV(\"enter native_bridge2_loadLibrary %s\", libpath); \n    NativeBridgeCallbacks *cb = get_callbacks(); \n return cb ? cb->loadLibrary(libpath, flag) : nullptr; \n} \n\nstatic void *native_bridge2_getTrampoline(void *handle,  \n  const char *name, const char* shorty, uint32_t len) \n{ \n    ALOGV(\"enter native_bridge2_getTrampoline %s\", name); \n    NativeBridgeCallbacks *cb = get_callbacks(); \n    return cb ? cb->getTrampoline(handle, name, shorty, len) \n    : nullptr; \n} \n\nstatic bool native_bridge2_isSupported(const char *libpath) \n{ \n    ALOGV(\"enter native_bridge2_isSupported %s\", libpath); \n    NativeBridgeCallbacks *cb = get_callbacks(); \n    return cb ? cb->isSupported(libpath) : false; \n} \n\nstatic const struct NativeBridgeRuntimeValues *native_bridge2_getAppEnv(const char *abi) \n{ \n    ALOGV(\"enter native_bridge2_getAppEnv %s\", abi); \n    NativeBridgeCallbacks *cb = get_callbacks(); \n    return cb ? cb->getAppEnv(abi) : nullptr; \n} \n\nstatic bool native_bridge2_is_compatible_compatible_with(uint32_t version) \n{ \n    // For testing, allow 1 and 2, but disallow 3+. \n    return version <= 2; \n} \n\nstatic NativeBridgeSignalHandlerFn native_bridge2_get_signal_handler(int signal) \n{ \n    ALOGV(\"enter native_bridge2_getAppEnv %d\", signal); \n    NativeBridgeCallbacks *cb = get_callbacks(); \n    return cb ? cb->getSignalHandler(signal) : nullptr; \n} \n\nstatic void __attribute__ ((destructor)) on_dlclose() \n{ \n    if (native_handle) { \n        dlclose(native_handle); \n        native_handle = nullptr; \n    } \n} \n\nextern \"C\" { \n\nNativeBridgeCallbacks NativeBridgeItf = { \n    version: 2, \n    initialize: &native_bridge2_initialize, \n    loadLibrary: &native_bridge2_loadLibrary, \n    getTrampoline: &native_bridge2_getTrampoline, \n    isSupported: &native_bridge2_isSupported, \n    getAppEnv: &native_bridge2_getAppEnv, \n    isCompatibleWith: &native_bridge2_is_compatible_compatible_with, \n    getSignalHandler: &native_bridge2_get_signal_handler, \n}; \n\n} // extern \"C\" \n} // namespace android \n\n```", "```kt\n$ mount binfmt_misc -t binfmt_misc /proc/sys/fs/binfmt_misc  \n\n```", "```kt\n:name:type:offset:magic:mask:interpreter:flags  \n\n```", "```kt\n... \n# \n# Houdini integration (Native Bridge) \n# \nhoudini_bin=0 \ndest_dir=/system/lib$1/arm$1 \nbinfmt_misc_dir=/proc/sys/fs/binfmt_misc \n\n# if you don't see the files 'register' and 'status' in /proc/sys/fs/binfmt_misc \n# then run the following command: \n# mount -t binfmt_misc none /proc/sys/fs/binfmt_misc \n\n# this is to add the supported binary formats via binfmt_misc \n\nif [ ! -e $binfmt_misc_dir/register ]; then \n   mount -t binfmt_misc none $binfmt_misc_dir \nfi \n\ncd $binfmt_misc_dir \nif [ -e register ]; then \n   # register Houdini for arm binaries \n   if [ -z \"$1\" ]; then \n         echo ':arm_exe:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x01\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x02\\\\x00\\\\x28::'\"$dest_dir/houdini:P\" > register \n         echo ':arm_dyn:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x01\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x03\\\\x00\\\\x28::'\"$dest_dir/houdini:P\" > register \n   else \n         echo ':arm64_exe:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x02\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x02\\\\x00\\\\xb7::'\"$dest_dir/houdini64:P\" > register \n         echo ':arm64_dyn:M::\\\\x7f\\\\x45\\\\x4c\\\\x46\\\\x02\\\\x01\\\\x01\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x03\\\\x00\\\\xb7::'\"$dest_dir/houdini64:P\" > register \n   fi \n   if [ -e arm${1}_exe ]; then \n         houdini_bin=1 \n   fi \nelse \n   log -pe -thoudini \"No binfmt_misc support\" \nfi \n\nif [ $houdini_bin -eq 0 ]; then \n   log -pe -thoudini \"houdini$1 enabling failed!\" \nelse \n   log -pi -thoudini \"houdini$1 enabled\" \nfi \n\n[ \"$(getprop ro.zygote)\" = \"zygote64_32\" -a -z \"$1\" ] && exec $0 64 \n\n```", "```kt\n$ adb shell\nroot@x86emu:/ # ls /proc/sys/fs/binfmt_misc/ \narm_dyn\narm_exe\nregister\nstatus  \n\n```", "```kt\nroot@x86emu:/ # cat /proc/sys/fs/binfmt_misc/arm_exe \nenabled\ninterpreter /system/lib/arm/houdini\nflags: P\noffset 0\nmagic 7f454c46010101000000000000000000020028  \n\n```", "```kt\n$ source build/envsetup.sh\n$ lunch x86emu_x86-eng\n$ m -j4  \n\n```", "```kt\n#include <stdio.h> \n\nvoid main() \n{ \n    printf(\"This is built using NDK r12.n\"); \n} \n\n```", "```kt\n$ cd ch05/test1\n$ ./build.sh \n[armeabi-v7a] Install : ch05_test => libs/armeabi-v7a/ch05_test\n$ file libs/armeabi-v7a/ch05_test\nlibs/armeabi-v7a/ch05_test: ELF 32-bit LSB  shared object, ARM, EABI5 version 1 (SYSV), dynamically linked (uses shared libs), BuildID[sha1]=b3cf0ae12c0d5b192053dc40c31f665196145039, stripped\n$ adb push libs/armeabi-v7a/ch05_test /data/local/tmp\n[100%] /data/local/tmp/ch05_test\n$ adb shell\nroot@x86emu:/ # cd /data/local/tmp\n127|root@x86emu:/data/local/tmp # ./ch05_test\nThis is built using NDK r12.  \n\n```", "```kt\n# Build both ARMv5TE and ARMv7-A and x86 machine code. \n# armeabi armeabi-v7a  \nAPP_ABI := armeabi armeabi-v7a \nAPP_PLATFORM := android-23 \n\n```", "```kt\n$ cd ch05/test2/jni\n$ ./build.sh\n[armeabi] Install : libHelloJNI.so => libs/armeabi/libHelloJNI.so\n[armeabi-v7a] Install: libHelloJNI.so => libs/armeabi-v7a/libHelloJNI.so  \n\n```", "```kt\n... \n10-02 00:44:57.871: I/ActivityManager(1527): START u0 {act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=fr.myrddin.hellojni/.HelloJNIActivity (has extras)} from uid 10008 on display 0 \n10-02 00:44:57.900: I/ActivityManager(1527): Start proc 2652:fr.myrddin.hellojni/u0a53 for activity fr.myrddin.hellojni/.HelloJNIActivity \n10-02 00:44:57.902: I/art(2652): Late-enabling JIT \n10-02 00:44:57.903: D/houdini(2652): [2652] Initialize library(version: 6.1.1a_x.48413 RELEASE)... successfully. \n10-02 00:44:57.907: W/art(2652): Unexpected CPU variant for X86 using defaults: x86 \n10-02 00:44:57.907: I/art(2652): JIT created with code_cache_capacity=2MB compile_threshold=1000 \n10-02 00:44:58.546: W/art(1527): Long monitor contention event with owner method=int com.android.server.wm.WindowManagerService.relayoutWindow(com.android.server.wm.Session, android.view.IWindow, int, android.view.WindowManager$LayoutParams, int, int, int, int, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.graphics.Rect, android.content.res.Configuration, android.view.Surface) from WindowManagerService.java:3104 waiters=0 for 632ms \n10-02 00:44:58.580: W/dex2oat(2667): Unexpected CPU variant for X86 using defaults: x86 \n10-02 00:44:58.581: W/dex2oat(2667): Mismatch between dex2oat instruction set features (ISA: X86 Feature string: smp,-ssse3,-sse4.1,-sse4.2,-avx,-avx2) and those of dex2oat executable (ISA: X86 Feature string: smp,ssse3,-sse4.1,-sse4.2,-avx,-avx2) for the command line: \n10-02 00:44:58.581: W/dex2oat(2667): /system/bin/dex2oat --runtime-arg -classpath --runtime-arg  --compiler-filter=interpret-only --instruction-set=x86 --instruction-set-features=smp,ssse3,-sse4.1,-sse4.2,-avx,-avx2 --runtime-arg -Xrelocate --boot-image=/system/framework/boot.art --runtime-arg -Xms64m --runtime-arg -Xmx512m --compiler-filter=verify-at-runtime --instruction-set-variant=x86 --instruction-set-features=default --dex-file=/data/app/fr.myrddin.hellojni-1/base.apk --oat-file=/data/dalvik-cache/x86/data@app@fr.myrddin.hellojni-1@base.apk@classes.dex \n10-02 00:44:58.581: E/dex2oat(2667): Failed to create oat file: /data/dalvik-cache/x86/data@app@fr.myrddin.hellojni-1@base.apk@classes.dex: Permission denied \n10-02 00:44:58.581: I/dex2oat(2667): dex2oat took 774.330us (threads: 2)  \n10-02 00:44:58.582: W/art(2652): Failed execv(/system/bin/dex2oat --runtime-arg -classpath --runtime-arg  --compiler-filter=interpret-only --instruction-set=x86 --instruction-set-features=smp,ssse3,-sse4.1,-sse4.2,-avx,-avx2 --runtime-arg -Xrelocate --boot-image=/system/framework/boot.art --runtime-arg -Xms64m --runtime-arg -Xmx512m --compiler-filter=verify-at-runtime --instruction-set-variant=x86 --instruction-set-features=default --dex-file=/data/app/fr.myrddin.hellojni-1/base.apk --oat-file=/data/dalvik-cache/x86/data@app@fr.myrddin.hellojni-1@base.apk@classes.dex) because non-0 exit status \n10-02 00:44:58.603: D/houdini(2652): [2652] Added shared library /data/app/fr.myrddin.hellojni-1/lib/arm/libHelloJNI.so for ClassLoader by Native Bridge. \n10-02 00:44:58.603: E/JNI(2652): Number : 4  \n... \n10-02 00:44:59.906: I/ActivityManager(1527): Displayed fr.myrddin.hellojni/.HelloJNIActivity: +2s9ms  \n... \n\n```"]