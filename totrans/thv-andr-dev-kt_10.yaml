- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting a Video Streaming App and Adding Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having mastered how to create engaging social apps such as WhatsApp and Instagram,
    it’s now time to dive into the world of video streaming services. This chapter
    marks the beginning of our third project: a Netflix-like app. Let’s call it Packtflix.
    Here, we will explore a different aspect of Android development, focusing on multimedia
    content delivery and user authentication, while continuing to build captivating
    user interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Our journey will begin by laying the groundwork for our streaming app. We’ll
    start from scratch, setting up a new project and introducing you to the app’s
    structure and modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the setup, we’ll dive into one of the most critical aspects of any
    app: authenticating your users. In today’s digital age, security and privacy are
    more relevant than ever, so you’ll learn how to implement robust authentication
    mechanisms using OAuth2\. This will ensure that your app’s users can securely
    access their accounts and personal preferences.'
  prefs: []
  type: TYPE_NORMAL
- en: Once our users can log in, we’ll focus on presenting them with a rich selection
    of movies. We’ll employ Jetpack Compose to create dynamic and responsive lists,
    showcasing the available content.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll delve into the details. Each movie or series in your app deserves
    its spotlight, and you’ll create detailed screens for them using Jetpack Compose.
    This will provide users with all the information they need to decide what to watch
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the app’s structure and modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the login screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating the app’s users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your movie list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the movie and series detail screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapter, you will need to have installed Android Studio (or
    another editor of your preference).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start a new project in this chapter, so it is not necessary
    to download the changes made in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find the complete code that we are going to build throughout this
    chapter in this repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-7).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the app’s structure and modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll lay the foundation for our Packtflix app by organizing
    it into feature modules. As we have seen before, by dividing the app into modules
    such as login, list, and playback, we can work on one feature at a time without
    affecting the others and speed up the build process for larger projects. Additionally,
    we’ll set up a version catalog for our dependencies as we did before to streamline
    the management of libraries such as Jetpack Compose, Dagger Hilt, and Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start creating the project. In Android Studio, select **File** | **New**
    | **New Project…**, and choose **Empty Compose Activity**. Then, in the **New
    Project** panel, fill out **Name**, **Package name**, and **Save location**. For
    the **Minimum SKD** option, we will choose **API 29** again as it guarantees the
    best percentage of compatibility at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: New project configuration for Packtflix](img/B19443_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: New project configuration for Packtflix'
  prefs: []
  type: TYPE_NORMAL
- en: The options in *Figure 7**.1* are the ones we will see using Android Studio
    Iguana (version 2023.2.1), though it may have variations depending on the version.
    For example, in other previous versions of Android Studio, we could also select
    whether we were going to use the version catalog for our dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the version catalog is created by default, so we will already get a `libs.versions.toml`
    file in our project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code adds the basic dependencies to the version catalog to build an app
    with Kotlin, Android, and Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step will be to create the modules needed. Here, we will create three
    feature modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**:feature:login**: We will use this module to include the login feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:feature:list**: In this module, we will include the list screen as well
    as the detail screen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:feature:playback**: In this module, we will host all the playback functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also create the following common modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**:app**: This module will contain the entry point for our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**:common**: This module will contain common functionality needed in more than
    one module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create these modules, use the **File** | **New** | **New Module…** option,
    as we have done in the previous projects. The final project structure should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Project module structure](img/B19443_07_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Project module structure'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created our module structure, it is time to set up the dependency
    injection framework.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the dependency injection framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous chapters, the need for scalability, performance optimization,
    and testability has made the use of a dependency injection framework practically
    a must in Android. In this case, we will use Hilt again (to learn more about it,
    please refer to [*Chapter 1*](B19443_01.xhtml#_idTextAnchor015) where we did a
    complete review of the framework and exposed its main advantages).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start adding the dependency to our version catalog. Open our `libs.versions.toml`
    file and add the Hilt dependencies in the `versions`, `libraries`, and `plugins`
    blocks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will add the plugin to the project-level `build.gradle.kts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `build.gradle.kts` file of every module, we will have to apply
    the plugin and add the Hilt dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `:app` module, we can create the `PacktflixApp` class, which will
    be the entry point for the Hilt configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this annotation, we are enabling Hilt to generate the necessary components
    under the hood that will be used for dependency injection throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we should include `PacktflixApp` in `AndroidManifest.xml`, so that
    our app uses it instead of the default `Application` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are all set to start building our new project. The first step will be
    to build the login screen as we want our users to authenticate themselves using
    their credentials. Let’s start working on it!
  prefs: []
  type: TYPE_NORMAL
- en: Building the login screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build the login screen, we will start creating a `LoginScreen` composable
    with Jetpack Compose. We will have to include the app’s logo, fields to introduce
    the email and password, and a **Login** button. We can also include a text to
    show whether there are any errors when the user tries to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This login screen is going to have four states (`Idle`, `Loading`, `Success`,
    and `Error`), so let’s start modeling the overall `ViewState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create the `LoginScreen` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We start the composable function by obtaining `LoginViewModel`, accessed via
    `hiltViewModel()`. This `ViewModel` component manages the login logic and exposes
    the current login state through a `StateFlow` stream. The `collectAsState().value`
    call converts the asynchronous stream of login states into a composable-friendly
    state that triggers recompositions when the login state changes.
  prefs: []
  type: TYPE_NORMAL
- en: The function uses `remember { mutableStateOf("") }` to maintain the state of
    user inputs for email and password within the composable’s lifecycle. This state
    is mutable and reactive, meaning any changes to the input fields (handled by `onValueChange`)
    automatically update the corresponding variables and thus the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s continue now with the next part of the composable, which will include
    the name of the app, the fields for `email` and `password`, and the **Login**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The UI dynamically adjusts based on the current login state. For example, if
    the login state is `LoginState.Error`, the function renders a `Text` composable
    to display the error message. This conditional rendering is crucial for providing
    feedback to the user, such as indicating a login failure or showing a loading
    indicator (`CircularProgressIndicator`) when the login process is underway. This
    approach to UI development is declarative, with the UI’s structure and content
    directly mapping to the application’s state.
  prefs: []
  type: TYPE_NORMAL
- en: The `OutlinedTextField` composables for `email` and `password` capture user
    inputs, which are then used to initiate the login process (`loginViewModel.login(email,
    password)`) when the user clicks the `password` field (via `KeyboardActions`).
    This demonstrates how to handle user actions and input in a composable, triggering
    `ViewModel` actions that ultimately lead to state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `LaunchedEffect` block listens for changes in the login state to
    perform side effects, such as navigation upon successful login or updating the
    error message state. This pattern separates side effects from the UI logic, ensuring
    that effects such as navigation or showing toasts only occur in response to state
    changes, not as a direct result of user actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start working on `LoginViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start with the dependency injection stuff: the use of `@HiltViewModel`
    indicates that Hilt will be responsible for the instantiation and provision of
    `LoginViewModel`. The `@Inject` constructor signifies that Hilt will inject the
    necessary dependencies into this `ViewModel` instance, in this case, an implementation
    of a use case called `DoLoginUseCase` (we will implement this use case later).'
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewModel` instance manages the login state using `MutableStateFlow<LoginState>`.
    Here, `_loginState` is a private, mutable state flow that holds the current state
    of the login process, which can be one of `Idle`, `Loading`, `Success`, or `Error`.
    The immutable `loginState` property exposes this state to the UI layer as a read-only
    `StateFlow`, ensuring that state updates are safely and efficiently communicated
    to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The login function embodies the core functionality of this `ViewModel` class.
    It initiates the login process by setting `_loginState` to `Loading`, indicating
    that the login operation has started. It then proceeds to call the `doLogin` method
    on the provided `loginUseCase` with the user’s email and password.
  prefs: []
  type: TYPE_NORMAL
- en: After attempting to log in, the function evaluates the result. If the login
    attempt fails (`result.isFailure`), `_loginState` is updated to `Error` with the
    exception message, providing feedback on why the login failed. If the login succeeds,
    `_loginState` is set to `Success`, indicating a successful login process. This
    conditional handling ensures that the UI can react appropriately to different
    outcomes of the login process.
  prefs: []
  type: TYPE_NORMAL
- en: The login process is launched within `viewModelScope`, a coroutine scope tied
    to the `ViewModel` lifecycle. This ensures that any ongoing login operation is
    automatically canceled if the `ViewModel` instance is cleared (typically, when
    the associated UI component is destroyed), preventing memory leaks and unnecessary
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have our login screen ready. The last step is to set up the Hilt
    modules and set the content of `MainActivity` to show the `LoginScreen` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now execute the app, we should see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Packtflix login screen](img/B19443_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Packtflix login screen'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished our UI, the next step will be to authenticate the
    users. Let’s learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating the app’s users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mobile applications, authentication plays a critical role in protecting user
    data and personal information from unauthorized access. As mobile devices often
    serve as personal gateways to a wide array of services and store a significant
    amount of sensitive data, ensuring that this data is securely managed and accessed
    is more important than ever. One of the preferred methods for authenticating users
    is OAuth2.
  prefs: []
  type: TYPE_NORMAL
- en: '**OAuth2** is an authorization framework that allows third-party services to
    exchange web resources on behalf of a user. It enables users to grant websites
    or applications access to their information on other websites without giving them
    their passwords. This is particularly useful for providing functionalities such
    as logging in with Google, Facebook, or other social media accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of OAuth2’s most important features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: It allows the user to authorize an application to access their
    resources on a different server without sharing their credentials, typically by
    using access tokens granted through a process involving user consent and secure
    token exchanges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OAuth **token** is a credential that represents the authorization granted
    to the application, allowing it to access specific resources on behalf of the
    user. These tokens can come in various formats, such as opaque tokens or **JSON
    Web Tokens** (**JWTs**). Opaque tokens are simple strings without any specific
    structure, while JWTs are structured tokens that consist of three parts – a header,
    a payload, and a signature – all encoded in Base64.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Scalability**: It allows for the delegation of user authentication to the
    service that hosts the user account, by offloading the technical complexities
    of secure authentication and infrastructure scalability to dedicated services.
    These services are usually managed by specific teams in charge of the complex
    and resource-intensive tasks of securing and scaling authentication processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: It supports multiple flows (based on grant types, which will
    determine the flow the authentication process has to follow) for different types
    of clients, including mobile apps, websites, and server-side applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User Experience**: It enables a smoother login experience for users, as users
    can use existing accounts to sign in to new services without creating new credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In essence, OAuth2 provides a secure and efficient way to implement authentication
    in mobile applications. It leverages existing user accounts, which simplifies
    the login process for users, and offloads the complexity of managing user credentials
    and sessions to a third-party service, enhancing both security and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add this feature to our app, starting by adding the models that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will define a simple user model that will hold the user information
    we will receive upon successful authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are defining the basic fields needed to hold the user information
    (depending on the requirements of your app, these fields will be different).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, to build the login request that we are going to send to the backend to
    obtain the authentication token, we will need another data class to hold the credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are including the `email` and `password` fields, which will be mandatory
    to be able to log users in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this request reaches the backend, if the credentials are correct, the
    backend will return an authorization token, which our app will store in a secure
    place and will use to authenticate the following API calls to the backend. We
    will need another model to hold this token information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s set Retrofit to get this authorization token.
  prefs: []
  type: TYPE_NORMAL
- en: Using Retrofit to get the authorization token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To obtain the authorization token, we need our app to request it when the user
    provides their credentials. In order to send this request to the backend, we are
    going to use Retrofit. We already used Retrofit in [*Chapter 4*](B19443_04_split_000.xhtml#_idTextAnchor089),
    so let’s skip the introductions and start with the setup of an interface that
    Retrofit will use to make the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code defines an interface called `AuthService` with a unique login function.
    We will pass a `LoginRequest` object with the data needed for the request and
    then will obtain an `AuthToken` response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build those models. First, we’ll build the `LoginRequest` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this model, we will send the user’s credentials – their email and password
    – to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if the login has been successful, the backend should answer with a response
    including an authorization token. We will structure this response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This `AuthToken` model will include the aforementioned authorization token.
    Note that, usually, these tokens have a time window and so have to be renewed
    before they have expired. For simplicity, we are going to assume this token will
    not expire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create our remote data source to retrieve the authorization token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the `LoginRemoteDataSource` class, which will act as a data
    source layer for handling login functionality by interacting with the remote authentication
    service. This class will have a single dependency, `authService`, which is an
    interface (presumably Retrofit or a similar networking library) responsible for
    making network requests related to authentication. The primary function within
    this class, `login`, is a suspended function that takes two parameters, `email`
    and `password`, which are used to construct a `LoginRequest` object. This object
    is then passed to the `authService.login` method, initiating a network request
    to log the user in.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the response from `authService.login`, the `run` block is executed
    to handle the response. Inside this block, the response is checked to determine
    whether the request was successful (`isSuccessful`) and whether the response body
    contains a non-`null` token. If both conditions are met, `Result.success(token)`
    is returned, encapsulating the token in a successful result. This indicates that
    the login was successful and provides the caller with the token. Conversely, if
    either condition is not satisfied – meaning the request failed or the token was
    null – a failure result is returned by calling `Result.failure(getError(this))`.
    The `getError` function will analyze the `Response<AuthToken>` object to determine
    the nature of the failure and return an appropriate `Throwable` object that describes
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, let’s build the `getError()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this `getError` function, we map the possible values of the status code from
    the response to different errors. If we wanted to, we could later process those
    errors and show messages to the user accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s also define those errors, in which we will map the server response. We
    will define them as part of a `LoginException` sealed class, which is a special
    type of class in Kotlin that restricts the inheritance hierarchy to a specific
    set of subclasses, providing exhaustive `when` expressions and ensuring that every
    possible type of error is handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our `LoginRemoteDataSource` component, it is time to define
    how to store the token.
  prefs: []
  type: TYPE_NORMAL
- en: Using DataStore to store the token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introduced by Google, **DataStore** is a data storage solution that provides
    an efficient, secure, and asynchronous way of persisting small pieces of data.
    It uses Kotlin coroutines and flow streams to store data asynchronously, ensuring
    UI thread safety and smoother performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'DataStore comes with several features that make it a preferable data storage
    option in Android applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Asynchronous by default**: DataStore operations are performed asynchronously
    using Kotlin coroutines, preventing blocking the main thread and improving app
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe and consistent**: With built-in transactional data APIs, DataStore ensures
    data consistency and integrity, even if an app process is killed during a write
    operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type safety**: DataStore offers two implementations: Preferences DataStore,
    which stores and retrieves key-value pairs, and Proto DataStore, which allows
    for storing type-safe objects using Protocol Buffers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: DataStore can be integrated with encryption mechanisms to securely
    store sensitive information. DataStore can be combined with encryption libraries
    such as Tink to encrypt the data before saving, making it a more secure option
    for handling user credentials, tokens, and other sensitive information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why will we use DataStore and not Room (which we used previously for our WhatsPackt
    messenger project)? While both are robust data persistence libraries, they serve
    different purposes and have distinct use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use case suitability**: DataStore is designed for storing small collections
    of data, such as settings, preferences, or application state. It excels in handling
    lightweight tasks where the data structure is simple. **RoomDatabase** is a SQLite
    abstraction that significantly reduces the amount of boilerplate code needed to
    use SQLite. It’s intended for more complex data storage requirements, such as
    storing large datasets, relational data, or when we need to perform complex queries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance and complexity**: DataStore provides a simpler API for data storage
    with minimal setup, making it ideal for straightforward tasks. Its performance
    is optimized for small datasets and simple data structures. **RoomDatabase**,
    being a database, is more suited for complex queries and large datasets. It involves
    more setup and is heavier than DataStore but offers more features and capabilities
    for comprehensive data management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data security**: DataStore, especially with Proto DataStore, can easily be
    integrated with encryption mechanisms to store data securely, making it a more
    secure option for sensitive information. **RoomDatabase** supports SQLite encryption,
    but integrating encryption requires additional setup and possibly third-party
    libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we just need to store a small value (the token) and given its security features,
    DataStore is the best option.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to start using it, first, we need to set up the DataStore dependency and
    its version in our version catalog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, need to add it to our modules’ `gradle.build.kts` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we are only adding it to the modules where we would need to
    use the dependency – initially, this will just be in the `:feature:login` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start using the DataStore library. We are going to build a `LoginLocalDataSource`
    component, which will be responsible for storing and retrieving the token in and
    from the DataStore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `LoginLocalDataSource`, first, we leverage Kotlin’s property delegation
    feature to initialize the DataStore. By defining `val Context.dataStore` with
    `preferencesDataStore(name: "user_preferences")`, we ensure a single instance
    of the DataStore is lazily initialized and tied to the application’s context.
    This method optimizes resource use and simplifies subsequent data operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Within `LoginLocalDataSource`, we define a companion object to hold `TOKEN_KEY`,
    a key used to store and retrieve the authentication token from the DataStore.
    This key is defined using `stringPreferencesKey("auth_token")`, indicating the
    data type we intend to store – in this case, a `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: In the `saveAuthToken` function, we perform a write operation on the DataStore
    by calling `edit` and passing a lambda that assigns the provided token to `TOKEN_KEY`.
    This operation is atomic and thread-safe, ensuring the integrity of our data.
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve the authentication token, `getAuthToken` also employs suspending
    semantics to facilitate asynchronous execution. It accesses the DataStore’s data
    as a flow, immediately fetching the first emitted value with `.data.first()`.
    This operation suspends the coroutine, effectively making the data retrieval feel
    synchronous while maintaining the benefits of asynchronous execution. The function
    then checks whether the token exists and returns it wrapped in `Result<String>`,
    providing a straightforward way to handle success and failure. In the absence
    of a token, it returns `Result.failure` with a custom `TokenNotFoundError`, offering
    precise error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to implement `LoginRepository`, which is responsible for coordinating
    between the remote and local data sources. We will build it, as always, by creating
    an interface in the domain layer and the implementation in the data layer. This
    is because the domain shouldn’t have any explicit dependency from the data layer,
    to respect the clean architecture. So, we define the interface like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the interface will have two functions: one to obtain the token so it
    can be used elsewhere (for example, for the backend requests to authenticate the
    user once it has been obtained) and another to perform the login and store the
    newly obtained authentication token.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s implement the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoginRepositoryImpl` class serves as an implementation of the `LoginRepository`
    interface, acting as a mediator between the application’s data sources and its
    use cases or view models. This class abstracts the details of data retrieval and
    storage, providing a cohesive API for authentication processes. It relies on two
    primary data sources: `localDataSource` for local data storage and retrieval,
    and `remoteDataSource` for handling network requests related to user authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `getToken` function, the repository directly delegates the call to `localDataSource.getAuthToken()`,
    which fetches the authentication token from local storage. This method returns
    a `Result<String>` object, encapsulating the outcome of the operation in a type-safe
    manner. The token retrieval is critical for checking the user’s authentication
    status or for subsequent authenticated API calls that require a token.
  prefs: []
  type: TYPE_NORMAL
- en: The `loginWithCredentials` function implements the process of authenticating
    a user with their email and password. It first attempts to log in through the
    `remoteDataSource.login(email, password)` method. Upon a successful login, indicated
    by the `onSuccess` branch of the fold, it saves the received authorization token
    using `localDataSource.saveAuthToken(it)` and then signals the completion of the
    login process with `Result.success(Unit)`. Conversely, if the remote login attempt
    fails (`onFailure`), it propagates the failure as `Result.failure(it)`, allowing
    the calling code to handle the error appropriately. This design effectively separates
    concerns between local and remote data handling, ensuring that the repository
    remains the single source of truth for all authentication-related data flows within
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can build a use case to perform the login, consuming this `LoginRepository`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `DoLogin` class implements the `DoLoginUseCase` interface, encapsulating
    the logic required to authenticate a user by their email and password. By delegating
    the authentication process to `loginRepository`, it invokes `loginRepository.loginWithCredentials(email,
    password)` to perform the actual login operation. The `DoLogin` use case simplifies
    the process of user authentication into a single method call, ensuring that the
    details of how the login is performed are encapsulated within the repository,
    thereby promoting the separation of concerns and making the code easier to maintain
    and test.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are all set to use the login functionality. Next, let’s use those tokens
    to validate the app requests.
  prefs: []
  type: TYPE_NORMAL
- en: Sending the authorization token in requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To finish the users authentication:authorization token, sending in requests”
    authentication tasks, there is still one thing we have to do. The reason we were
    obtaining this authentication token was to be used in the requests the app is
    going to send to the backend, so it will guarantee the authenticity of the user
    that has generated the request. To include the token in every request, we are
    going to take advantage of Retrofit interceptors.
  prefs: []
  type: TYPE_NORMAL
- en: A Retrofit **interceptor** is a powerful mechanism provided by OkHttp (the underlying
    HTTP client used by Retrofit) that allows you to intercept and manipulate the
    request and response chain. Interceptors can modify requests and responses or
    perform actions such as logging, adding headers, handling authentication, and
    much more, before the request is sent to the server or after the response is received
    by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interceptors can be broadly categorized into two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Application interceptors**: These interceptors are called once for any single
    call to the server. They don’t need to worry about network specifics such as retries
    and redirects. Application interceptors are perfect for tasks such as adding a
    common header to all requests, logging the request and response body for debugging
    purposes, or managing application-level caching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network interceptors**: These interceptors can monitor the data at the network
    level. They can observe and manipulate requests and responses that come from and
    go to the server, including any retries and redirects that occur as part of the
    network call process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add an authentication token to all outgoing requests, we will choose an application
    interceptor. We will choose an application interceptor in this scenario because
    they are designed to operate at the application layer, directly modifying requests
    before they are sent out and processing responses once they are received. This
    makes them well suited for tasks such as adding headers that should be included
    in every request to the server, such as authentication tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s write our interceptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This class plays a critical role in enriching outgoing HTTP requests with authentication
    details. It achieves this by integrating with `LoginRepository`, from which it
    retrieves the current user’s authorization token. Upon intercepting a request,
    the interceptor fetches theusers authentication:authorization token, sending in
    requests” token synchronously using `runBlocking` (a mechanism that allows for
    the seamless integration of coroutine-based asynchronous token retrieval into
    the synchronous flow expected by interceptors).
  prefs: []
  type: TYPE_NORMAL
- en: If a token is present, it’s appended to the request as an `Authorization` header,
    adhering to the widely accepted bearer token format (the bearer token format is
    a security scheme where a client sends a token in the header of the requests to
    authenticate access, prefixed with the word `Bearer` followed by a space and the
    token itself), thereby ensuring that the request carries the necessary credentials
    for authentication by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using `runBlocking` within the interceptor is a pragmatic approach to accommodate
    the synchronous nature of the `intercept()` method, allowing for the immediate
    availability of the token. However, it’s crucial to ensure that the token retrieval
    operation is efficient and non-blocking to avoid performance bottlenecks – ideally,
    by fetching the token from a local cache or storage.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of the function, we return `chain.proceed(requestwithToken)`,
    which will allow Retrofit to continue processing the request, including the interceptor
    changes (in this case, adding the authentication header).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should include `AuthInterceptor` as an interceptor when we are building
    the Retrofit client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see how we can integrate the interceptor we’ve created into our
    network layer setup, specifically within a Retrofit configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Within the function, an `OkHttpClient` instance is created and configured to
    include the `authInterceptor` instance via the `addInterceptor` method. This setup
    ensures that every HTTP request made by this client will first pass through the
    `authInterceptor`, allowing it to modify the request as needed before it is sent
    out.
  prefs: []
  type: TYPE_NORMAL
- en: Following the configuration of the `OkHttpClient` instance, the Retrofit instance
    is built. The configured `OkHttpClient` instance is set as the client for Retrofit,
    linking the HTTP client, with its interceptor, to the Retrofit instance. Now,
    all the requests using this Retrofit instance will include the authentication
    token in the header, if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, weusers authentication:authorization token, sending in requests”
    handled the app authentication, from obtaining the token and storing it to providing
    this token in every request. Now, it’s time to build the main screen: the list
    of movies and series.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your movie list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the goals of our Packtflix app is for users to have the freedom to explore
    and enjoy an extensive range of movies (or TV series), ensuring they stay engaged
    with our app. To achieve this, we must present our movie catalog in the most appealing
    manner possible. For that reason, in this section, we will focus on building a
    movie (or series!) catalog screen.
  prefs: []
  type: TYPE_NORMAL
- en: To start building the classical main screen of our streaming app, we first need
    to create the models we will use to represent the information.
  prefs: []
  type: TYPE_NORMAL
- en: Building the models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by building the `Movie` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is the model that will represent a movie – it includes the movie identification
    (`id`), its title, and a URL to an image of the movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, movies in a streaming app are arranged by genres, so let’s create
    a `Genre` model too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here we defined the name of the genre (needed to render it on the screen) and
    a list of the movies included in that genre.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need a `MoviesViewState` class to represent the movie list screen
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this `MoviesViewState` class, we are including just one property, `genres`,
    which will store the list of genres we want to show in the list of our streaming
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to start creating the `MoviesScreen` composable.
  prefs: []
  type: TYPE_NORMAL
- en: Building the MoviesScreen composable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build the `MoviesScreen` composable, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have created our `MoviesScreen` composable and a `Scaffold`
    inside of it. As a `topBar` component of the `Scaffold`, we are including a new
    composable called `PackflixTopBar`, then as a `bottomBar` component, we are including
    another new composable called `PacktflixBottomBar`. Finally, in the content of
    the Scaffold, we are showing a `GenreList` composable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s build these three composables: `PacktflixTopBar`, `PacktflixBottomBar`,
    and `GenreList`.'
  prefs: []
  type: TYPE_NORMAL
- en: PacktflixTopBar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is how we create the `PacktflixTopBar` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Inside `TopAppBar`, there’s a title that displays the text **PACKTFLIX** on
    the screen – the text will be colored in red, with a large font size and some
    padding to create some space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `TopAppBar` will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Top bar in MoviesScreen](img/B19443_07_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Top bar in MoviesScreen'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue with the bottom bar.
  prefs: []
  type: TYPE_NORMAL
- en: PacktflixBottomBar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s build the `PacktflixBottomBar` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This navigation bar sports a sleek black background with icons illuminated in
    white, offering a stark and stylish contrast. We’re also introducing four navigation
    items, each symbolized by a distinct icon. We’ve opted for icons from the Material
    Icons collection, assigning specific and intuitive symbols to signify **Home**,
    **Search**, **Downloads**, and **More** functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: For each navigation item within `NavigationBarItem`, we have set up an icon
    along with an `onClick` listener. Initially, all these items are not selected
    (`selected = false`) to indicate that their selection state will be managed dynamically
    through user interactions or specific logic to be implemented in the future. The
    implementation of these sections is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We are also pairing each icon with `contentDescription`. This approach enhances
    app accessibility by offering screen readers a concise explanation of each button’s
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is finished, this is how `PacktflixBottomBar` will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: Bottom bar in MoviesScreen](img/B19443_07_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Bottom bar in MoviesScreen'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s continue with the next step and complete this screen by implementing
    the list of movies.
  prefs: []
  type: TYPE_NORMAL
- en: GenreList
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s start building the `GenreList` composable. Generally, the content
    of a movie screen in a streaming app is composed of a list of genres, where each
    one contains a list of movies. Let’s use the `Genre` model we defined previously
    and create this list of lists. We will start creating a vertical list composed
    of rows where every row will show the content of every `Genre` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To efficiently display the `GenreList` composable, we employed `LazyColumn`,
    chosen for its ability to render items lazily – this means it only draws the items
    visible on the screen, enhancing performance, especially for long lists.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `LazyColumn`, we iterate over the genre list. For each genre, we call
    items, specifying the size of our genre list to determine the number of items
    it should prepare to display.
  prefs: []
  type: TYPE_NORMAL
- en: Then, for every item (or genre, in our context), we invoke `GenreRow`, a custom
    composable function that we will define in a moment. This function is responsible
    for rendering a single row in our list, which represents a genre. We pass each
    genre to `GenreRow` by indexing it into our genres list with `genres[index]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s build the `GenreRow` composable that we just mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start with a vertical container, `Column`, that stretches across the full
    width of the screen. At the top of this container, we place the genre’s name in
    large, readable text. This makes it clear to the user which genre they’re looking
    at.
  prefs: []
  type: TYPE_NORMAL
- en: Right below the genre’s name, we set up a horizontal scroll area, `LazyRow`,
    filled with movie cards. Each card represents a movie in the genre, and users
    can scroll through them horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each movie in the genre, we will create a `MovieCard` composable that will
    show the movie thumbnail image and the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We start by using a `Card` composable that provides a Material Design card layout.
    This card is given specific dimensions and padding to ensure that it looks neat
    and uniform across the app. Specifically, we set each card to be `120dp` wide
    and `180dp` tall, with an `8dp` padding around it. This size is ideal for displaying
    movie posters without taking up too much screen space or looking too cramped.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the card, we place an `Image` composable to show the movie’s poster.
    To load the image (the movie’s poster in this case) from a URL, we use `rememberAsyncImagePainter`,
    a handy function that handles asynchronous image loading and caching. This means
    our app can fetch movie posters from the internet efficiently and display them
    as they become available, without blocking the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: The image is set to crop to fit the card’s dimensions, ensuring that the most
    visually important part of the poster remains visible, even if the original image’s
    aspect ratio doesn’t exactly match the card’s dimensions. This cropping also maintains
    a consistent appearance across all movie cards.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we include `contentDescription` for the image, using the movie’s title,
    to make our list as accessible as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this component, we have finished our movie screen (or series screen –
    you just have to change the title and the content!). We can now test it using
    the `@Preview` annotation and providing a list of genres:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the preview feature of Jetpack Compose to see what our list
    will look like. We would need to create some sample content, and that’s what the
    `sampleMoviesScreen()` function will do for us. For example, we could create this
    fake list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating fake data to make the testing of `MoviesScreen` easier.
    Note that the URLs provided are not the actual image URLs, so you would have to
    replace them for actual movie posters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once finished, our list screen should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Movies list screen](img/B19443_07_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Movies list screen'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our list of genres and movies, let’s build the movie (or series)
    details page.
  prefs: []
  type: TYPE_NORMAL
- en: Making the movie and series detail screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create the detail screen, which is the screen that
    will be shown when the user clicks a movie or series from the list. This screen
    will include information such as the plot summary, cast, year of release, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Before building the necessary composables, we need to think about the models
    we need. Let’s start creating them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the detail models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define the models, we need to take into account the data we want to show
    in the detail screen. As we would like to create the same model for both movies
    and series, we will build an `ItemDetail` model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case that `ItemDetail` represents a streaming series item, we also should
    define the `Episode` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our models ready, we can start building the `DetailScreen`
    composable.
  prefs: []
  type: TYPE_NORMAL
- en: Building the DetailScreen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have done on other occasions, we will first build the structure we want
    the screen to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In `ItemDetailScreen`, all the composables included are shown in a vertical
    `Column`, which allows us to build the UI progressively as we add new composables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s start building all those composables, starting with `ItemBannerImage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This composable displays a banner image at the top of the screen, stretching
    it to fill the screen’s width. It uses a `Box` composable with a `Modifier` parameter
    that will make sure it takes up the full width of the screen, and an `Image` composable
    that loads an image from a given URL with the `rememberAsyncImagePainter` function.
    The image is set to be 200 dp tall and automatically adjusts its width to fit
    the screen, ensuring that it’s properly cropped to the allocated space.
  prefs: []
  type: TYPE_NORMAL
- en: On top of the image, there’s an `IconButton` composable that’s meant to act
    as a **Back** button. We place this button in the top-left corner with some padding.
    Inside this button, there’s an icon shaped like an arrow pointing back, suggesting
    that pressing it should take you back to the previous screen. The icon is white
    to make sure it’s visible on top of the banner image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s build the `ItemTitleAndMetadata` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a `Column` layout because we want the details to stack
    vertically.
  prefs: []
  type: TYPE_NORMAL
- en: In this column, we will display the title of the item. The style we choose here
    is `bodyMedium` from the Material Theme, ensuring it fits nicely with the overall
    design of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we align our HD indicator and the year of release in a row, centering
    them vertically to ensure that they line up perfectly. We include a conditional
    check – only if `isHD` is `true` do we display an **HD** badge. We give this badge
    a white border and a bit of padding to make it pop against any background.
  prefs: []
  type: TYPE_NORMAL
- en: Following a small spacer, which adds some breathing room between our **HD**
    badge and the year, we place the text for the year. It’s styled to be less prominent
    than the title, using a medium gray color.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, below the row, we will show the duration of the item. It’s also in
    medium gray, matching the year, and using the same `bodyMedium` style for consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create the `ItemActions` composable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We start by laying this function in a column format so that our action buttons
    stack vertically – this column will take up the full width available and will
    have padding all around for some space from the screen edges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside this column, we’re placing two action buttons: one for playing the item
    and another for adding the item to a user’s personal list. To create these buttons,
    we are using the `ActionButton` composable function, which neatly bundles an icon
    and a label together into a clickable area. For the **Play** action, we are using
    a play arrow icon, and for adding to the list, we are using an **Add** icon.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have left placeholders in the code where the play and add-to-list actions
    can be written. In the next chapter, we will implement the **Play** button; however,
    I will leave you to add the add-to-list feature yourself. To do this, one solution
    could be to call an endpoint when the **Add To List** button is pressed, so the
    backend can store it in the user list (of course, imagining that we have a backend
    that handles this feature). You can refer to [*Chapter 4*](B19443_04_split_000.xhtml#_idTextAnchor089)
    where we connected Packtagram with **NewsFeed** to understand how this can be
    done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s continue with the next composable, `CastAndCreatorsList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We start with `Column`, which is going to stack our elements vertically. We
    want this to take up the full width available, so we use `Modifier.fillMaxWidth()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we put a header labeled `Cast` at the top. We style this text to make
    it stand out using `MaterialTheme.typography.titleSmall` and set the color to
    white. To give it some breathing room, we add padding around it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we introduce a `LazyRow` composable to display each actor’s name from
    the cast list using a `Text` composable. We style the names to stand out against
    the background by applying `MaterialTheme.typography.bodyMedium` and setting the
    text color to white. To further distinguish each name, we give them a tag-like
    appearance with a dark gray background and rounded corners using `RoundedCornerShape(4.dp)`.
    Additionally, we add padding around the text to ensure that it doesn’t touch the
    edges of its gray backdrop, enhancing readability and visual appeal.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we separate the cast from the creators with a `Spacer` composable. This
    just adds a bit of vertical space between the two sections, so they don’t run
    into each other.
  prefs: []
  type: TYPE_NORMAL
- en: For the creators, the setup is pretty much the same. We have a header labeled
    `"Created by"`, styled similarly to the `Cast` header but a bit larger using `titleMedium`.
    Then, we list out the creators in another `LazyRow`, giving them the same styled
    text tags as the cast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to work on the last composable of the screen, `AdditionalMovieDetails`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In `AdditionalMovieDetails`, we’re setting up a column that expands to the maximum
    width of its parent container. Inside this column, we’re going through each episode
    in the `item.episodes` list and, for each one, we’re calling the `EpisodeItem`
    composable to render the details of that episode.
  prefs: []
  type: TYPE_NORMAL
- en: Now, moving on to the `EpisodeItem` composable function, this is where we lay
    out each episode’s information. We create a row that stretches across the full
    width, which can be tapped – this is where we will want to add the code for what
    happens when someone clicks to play the episode. We are also adding some padding
    for spacing.
  prefs: []
  type: TYPE_NORMAL
- en: Within this row, the first thing is the episode image. We use `rememberAsyncImagePainter`
    to load the image from the episode URL, and we make sure it’s nicely rounded and
    cropped to fit a specific size. This image will act as a thumbnail for the episode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the image, we add a spacer to give some breathing room before the text
    details of the episode. This is followed by a column that holds two pieces of
    text: the episode’s title, which stands out more, and below it, the duration of
    the episode in a smaller and less prominent color.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, after each episode item, we draw a thin gray line, a divider, to visually
    separate the episodes from one another. It’s a common design pattern that helps
    users distinguish between different pieces of content.
  prefs: []
  type: TYPE_NORMAL
- en: 'And with this composable, we have finished the detail screen and this chapter.
    Our detail screen should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: Detail screen](img/B19443_07_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Detail screen'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will bring those movies and series to life by implementing
    the playback.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we close this chapter, we have laid a solid foundation for Packtflix, our
    video streaming app. We began by conceptualizing the project’s structure and modules,
    setting the stage for an organized and scalable app. This structure is pivotal
    for our journey ahead, where complexity will grow as we add more features.
  prefs: []
  type: TYPE_NORMAL
- en: We then created the login screen, before venturing into the world of user authentication.
    Through the integration of OAuth2, we’ve equipped Packtflix with a secure authentication
    system that respects user privacy and guards against unauthorized access, ensuring
    a trustworthy environment for our users to enjoy their favorite content.
  prefs: []
  type: TYPE_NORMAL
- en: Our progress continued as we crafted a UI to display a curated list of movies,
    leveraging the power of Jetpack Compose to create a dynamic and engaging experience.
    This attention to detail in presenting content is what will turn first-time users
    into loyal fans of Packtflix.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about how to implement the playback,
    so our users can not only see the movies and series information but also play
    their videos.
  prefs: []
  type: TYPE_NORMAL
