["```kt\ndependencies {\n```", "```kt\n    ...\n```", "```kt\n    testImplementation ‘junit:junit:4.13.2’\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    ...\n```", "```kt\n    testImplementation ‘org.mockito:mockito-core:4.0.0’\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    ...\n```", "```kt\n    testImplementation ‘org.mockito.kotlin:mockito-\n```", "```kt\n      kotlin:4.0.0’\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    ... \n```", "```kt\n    testImplementation ‘androidx.arch.core:core-\n```", "```kt\n      testing:2.1.0’\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    ...\n```", "```kt\n    testImplementation ‘org.jetbrains.kotlinx:kotlinx-\n```", "```kt\n      coroutines-test:1.6.0’\n```", "```kt\n}\n```", "```kt\ndependencies {\n```", "```kt\n    ...\n```", "```kt\n    androidTestImplementation\n```", "```kt\n      ‘org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.0’\n```", "```kt\n}\n```", "```kt\n@ExperimentalCoroutinesApi\n```", "```kt\nclass MovieRepositoryUnitTest {\n```", "```kt\n    ...\n```", "```kt\n}\n```", "```kt\nclass MovieRepository (private val movieService:\n```", "```kt\n  MovieService) {\n```", "```kt\n    ...\n```", "```kt\n    private val movieLiveData =\n```", "```kt\n      MutableLiveData<List<Movie>>()\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        val movies = movieService.getMovies()\n```", "```kt\n        movieLiveData.postValue(movies.results)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass MovieRepositoryTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        runBlocking {\n```", "```kt\n            ...\n```", "```kt\n            val movieLiveData =\n```", "```kt\n              movieRepository.fetchMovies()\n```", "```kt\n            assertEquals(movieLiveData.value, movies)\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\n@ExperimentalCoroutinesApi\n```", "```kt\nclass MovieRepositoryTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        runTest {\n```", "```kt\n            ...\n```", "```kt\n            val movieLiveData =\n```", "```kt\n              movieRepository.fetchMovies()\n```", "```kt\n            assertEquals(movieLiveData.value, movies)\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\njava.lang.IllegalStateException: Module with the Main dispatcher had failed to initialize. For tests Dispatchers.setMain from kotlinx-coroutines-test module can be used\n```", "```kt\n@Before\n```", "```kt\nfun setUp() {\n```", "```kt\n    Dispatchers.setMain(UnconfinedTestDispatcher())\n```", "```kt\n}\n```", "```kt\n@After\n```", "```kt\nfun tearDown() {\n```", "```kt\n    Dispatchers.resetMain()\n```", "```kt\n}\n```", "```kt\n@ExperimentalCoroutinesApi\n```", "```kt\nclass TestCoroutineRule(val dispatcher: TestDispatcher =\n```", "```kt\n  UnconfinedTestDispatcher()):\n```", "```kt\n   TestWatcher() {\n```", "```kt\n   override fun starting(description: Description?) {\n```", "```kt\n       super.starting(description)\n```", "```kt\n       Dispatchers.setMain(dispatcher)\n```", "```kt\n   }\n```", "```kt\n   override fun finished(description: Description?) {\n```", "```kt\n       super.finished(description)\n```", "```kt\n       Dispatchers.resetMain()\n```", "```kt\n   }\n```", "```kt\n}\n```", "```kt\n@ExperimentalCoroutinesApi\n```", "```kt\nclass MovieRepositoryTest {\n```", "```kt\n    @get:Rule\n```", "```kt\n    var coroutineRule = TestCoroutineRule()\n```", "```kt\n    ...\n```", "```kt\n}\n```", "```kt\nclass MovieViewModel(private val dispatcher:\n```", "```kt\n  CoroutineDispatcher = Dispatchers.IO): ViewModel() {\n```", "```kt\n    ...\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        viewModelScope.launch(dispatcher) {\n```", "```kt\n            ...\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\n@ExperimentalCoroutinesApi\n```", "```kt\nclass MovieViewModelTest {\n```", "```kt\n    ...\n```", "```kt\n    @Test\n```", "```kt\n    fun fetchMovies() {\n```", "```kt\n        ...\n```", "```kt\n        runTest {\n```", "```kt\n            ...\n```", "```kt\n            val viewModel =\n```", "```kt\n              MovieViewModel(UnconfinedTestDispatcher())\n```", "```kt\n            viewModel.fetchMovies()\n```", "```kt\n            ...\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\n@Test\n```", "```kt\nfun loading() {\n```", "```kt\n    val dispatcher = StandardTestDispatcher()\n```", "```kt\n    runTest() {\n```", "```kt\n        val viewModel = MovieViewModel(dispatcher)\n```", "```kt\n        viewModel.fetchMovies()\n```", "```kt\n        dispatcher.scheduler.advanceUntilIdle()\n```", "```kt\n        assertEquals(false, viewModel.loading.value)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\n    testImplementation ‘org.mockito.kotlin:mockito-\n      kotlin:4.0.0’\n    testImplementation ‘androidx.arch.core:core-\n      testing:2.1.0’\n    testImplementation ‘org.jetbrains.kotlinx:kotlinx-\n      coroutines-test:1.6.0’\n    ```", "```kt\n    mock-maker-inline\n    ```", "```kt\nMockito cannot mock/spy because : final class\n```", "```kt\n    @OptIn(ExperimentalCoroutinesApi::class)\n    class MovieRepositoryTest {\n        ...\n    }\n    ```", "```kt\n    @get:Rule\n    val rule = InstantTaskExecutorRule()\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        ...\n    }\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        val movies = listOf(Movie(id = 3), Movie(id = 4))\n        val response = MoviesResponse(1, movies)\n\n        val movieService: MovieService = mock {\n            onBlocking { getMovies(anyString()) } doReturn\n              response\n        }\n        val movieRepository =\n          MovieRepository(movieService)\n    }\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        ...\n\n        runTest {\n            movieRepository.fetchMovies()\n            val movieLiveData = movieRepository.movies\n            assertEquals(movies, movieLiveData.value)\n        }\n    }\n    ```", "```kt\n    @Test\n    fun fetchMoviesWithError() {\n        ...\n    }\n    ```", "```kt\n    @Test\n    fun fetchMoviesWithError() {\n        val exception = “Test Exception” \n        val movieService: MovieService = mock {\n            onBlocking { getMovies(anyString()) } doThrow\n              RuntimeException(exception)\n        }\n        val movieRepository =\n          MovieRepository(movieService)\n    }\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        ...\n\n        runTest {\n            movieRepository.fetchMovies()\n\n            val movieLiveData = movieRepository.movies\n            assertNull(movieLiveData.value)\n\n            val errorLiveData = movieRepository.error\n            assertNotNull(errorLiveData.value)\n            assertTrue(errorLiveData.value.toString()\n              .contains(exception))\n            }\n    }\n    ```", "```kt\n    class MovieViewModel(private val movieRepository:\n      MovieRepository, private val dispatcher:\n      CoroutineDispatcher = Dispatchers.IO) : ViewModel() \n      {\n        ...\n    }\n    ```", "```kt\n    viewModelScope.launch(dispatcher) {\n        ...\n    }\n    ```", "```kt\n    @OptIn(ExperimentalCoroutinesApi::class)\n    class MovieViewModelTest {\n        ...\n    }\n    ```", "```kt\n    @get:Rule\n    val rule = InstantTaskExecutorRule()\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        val expectedMovies =\n          MutableLiveData<List<Movie>>()\n        expectedMovies.postValue(listOf(Movie\n          (title = “Movie”)))\n\n        val movieRepository: MovieRepository = mock {\n            onBlocking { movies } doReturn expectedMovies\n        }\n     }\n    ```", "```kt\n    @Test\n    fun fetchMovies() {\n        ...\n\n        val movieViewModel = \n          MovieViewModel(movieRepository)\n        assertEquals(expectedMovies.value,\n          movieViewModel.movies.value)\n    }\n    ```", "```kt\n    @Test\n    fun loading() {\n        ...\n    }\n    ```", "```kt\n    @Test\n    fun loading() {\n        val movieRepository: MovieRepository = mock()\n        val dispatcher = StandardTestDispatcher()\n\n        ...\n    }\n    ```", "```kt\n    @Test\n    fun loading() {\n        ...\n\n        runTest {\n            val movieViewModel =\n              MovieViewModel(movieRepository, dispatcher)\n\n            movieViewModel.fetchMovies()\n            assertTrue( movieViewModel.loading.value ==\n              true)\n            dispatcher.scheduler.advanceUntilIdle()\n            assertFalse(movieViewModel.loading.value ==\n              true)\n        }\n    }\n    ```"]