["```swift\nclass RecentList { \n\n    var slot1: String? \n    var slot2: String? \n    var slot3: String? \n    var slot4: String? \n    var slot5: String? \n\n    func add(recent: String) { \n\n        // Move each slot down 1 \n        slot5 = slot4 \n        slot4 = slot3 \n        slot3 = slot2 \n        slot2 = slot1 \n        slot1 = recent \n    } \n\n    func getAll() -> [String] { \n        var recent = [String]() \n        if let slot1 = slot1 { \n            recent.append(slot1) \n        } \n        if let slot2 = slot2 { \n            recent.append(slot2) \n        } \n        if let slot3 = slot3 { \n            recent.append(slot3) \n        } \n        if let slot4 = slot4 { \n            recent.append(slot4) \n        } \n        if let slot5 = slot5 { \n            recent.append(slot5) \n        } \n        return recent \n    } \n} \nlet recentlyCopiedList = RecentList() \nrecentlyCopiedList.add(recent: \"First\") \nrecentlyCopiedList.add(recent: \"Next\") \nrecentlyCopiedList.add(recent: \"Last\") \nvar recentlyCopied = recentlyCopiedList.getAll() \nprint(recentlyCopied) // Last, Next, First \n```", "```swift\nclass RecentList<ListItemType> { \n\n    var slot1: ListItemType? \n    var slot2: ListItemType? \n    var slot3: ListItemType? \n    var slot4: ListItemType? \n    var slot5: ListItemType? \n\n    func add(recent: ListItemType) { \n        // Move each slot down 1 \n        slot5 = slot4 \n        slot4 = slot3 \n        slot3 = slot2 \n        slot2 = slot1 \n        slot1 = recent \n    } \n\n    func getAll() -> [ListItemType] { \n        var recent = [ListItemType]() \n        if let slot1 = slot1 { \n            recent.append(slot1) \n        } \n        if let slot2 = slot2 { \n            recent.append(slot2) \n        } \n        if let slot3 = slot3 { \n            recent.append(slot3) \n        } \n        if let slot4 = slot4 { \n            recent.append(slot4) \n        } \n        if let slot5 = slot5 { \n            recent.append(slot5) \n        } \n        return recent \n    } \n}\n```", "```swift\nlet recentlyUsedWordList = RecentList<String>() \nrecentlyUsedWordList.add(recent: \"First\") \nrecentlyUsedWordList.add(recent: \"Next\") \nrecentlyUsedWordList.add(recent: \"Last\") \nvar recentlyUsedWords = recentlyUsedWordList.getAll() \nprint(recentlyUsedWords) // Last, Next, First\n```", "```swift\nclass Person { \n\n    let name: String \n    init(name: String) { \n        self.name = name \n    } \n}\n```", "```swift\nlet rod = Person(name: \"Rod\") \nlet jane = Person(name: \"Jane\") \nlet freddy = Person(name: \"Freddy\")  \n```", "```swift\nlet lastCalledList = RecentList<Person>() \n```", "```swift\nlastCalledList.add(recent: freddy) \nlastCalledList.add(recent: jane) \nlastCalledList.add(recent: rod) \n```", "```swift\nlet lastCalled = lastCalledList.getAll() \nfor person in lastCalled {\n    print(person.name)\n}\n// Rod\n// Jane\n// Freddy\n```", "```swift\nclass RecentList<ListItemType> { \n    //... \n}\n```", "```swift\nvar slot1: ListItemType? \n```", "```swift\nfunc add(recent: ListItemType) \n```", "```swift\nfunc getAll() -> [ListItemType] \n```", "```swift\nclass RecentList<ListItemType, SomeOtherType> { \n    //... \n} \n```", "```swift\nclass RecentList<ListItemType: CustomStringConvertible> { \n    //... \n}\n```", "```swift\nclass RecentList<ListItemType: CustomStringConvertible> { \nfunc printRecentList() {\n    for item in getAll() {\n        let printableItem = String(describing: item)\n        print(printableItem)\n    }\n}\n //... \n\n```", "```swift\nextension Person: CustomStringConvertible { \n    public var description: String { \n        return name \n    } \n} \n```", "```swift\n// Using String type\nlet recentlyUsedWordList = RecentList<String>()\nrecentlyUsedWordList.add(recent: \"First\")\nrecentlyUsedWordList.add(recent: \"Next\")\nrecentlyUsedWordList.add(recent: \"Last\")\nrecentlyUsedWordList.printRecentList()\n// Last\n// Next\n// First\n\n// Using Person type\nlet rod = Person(name: \"Rod\")\nlet jane = Person(name: \"Jane\")\nlet freddy = Person(name: \"Freddy\")\nlet lastCalledList = RecentList<Person>()\nlastCalledList.add(recent: freddy)\nlastCalledList.add(recent: jane)\nlastCalledList.add(recent: rod)\nlastCalledList.printRecentList()\n// Rod\n// Jane\n// Freddy\n```", "```swift\nfunc makeDuplicates<ItemType>(of item: ItemType, \n   withKeys keys: Set<String>) -> [String: ItemType] { \n\n    var duplicates = [String: ItemType]() \n    for key in keys { \n        duplicates[key] = item \n    } \n    return duplicates \n}\n```", "```swift\nlet awards: Set<String> = [\"Best Director\",\n                           \"Best Picture\", \n                           \"Best Original Screenplay\", \n                           \"Best International Feature\"] \nlet oscars2020 = makeDuplicates(of: \"Parasite\", withKeys: awards) \nprint(oscars2020[\"Best Picture\"] ?? \"\") \n// Parasite \nprint(oscars2020[\"Best International Feature\"] ?? \"\") \n// Parasite\n```", "```swift\nfunc makeDuplicates<ItemType>(of item: ItemType, \n   withKeys keys: Set<String>) -> [String: ItemType] { \n    //... \n} \n```", "```swift\nfunc makeDuplicates(of item: Any, withKeys keys: Set<String>) -> [String: Any] { \n    //... \n} \n```", "```swift\nlet oscars2020 = makeDuplicates(of: \"Parasite\", withKeys: awards)\n```", "```swift\nfunc makeDuplicates<ItemType, KeyType>(of item: ItemType, withKeys  \n  keys: Set<KeyType>) -> [KeyType: ItemType] { \n\n    var duplicates = [KeyType: ItemType]() \n    for key in keys { \n        duplicates[key] = item \n    } \n    return duplicates \n} \n```", "```swift\nfunc makeDuplicates<ItemType, KeyType: Hashable>(of item: ItemType, \n   withKeys keys: Set<KeyType>) -> [KeyType: ItemType] { \n\n    var duplicates = [KeyType: ItemType]() \n    for key in keys { \n        duplicates[key] = item \n    } \n    return duplicates \n} \n```", "```swift\nlet awards: Set<String> = [\"Best Director\", \n                           \"Best Picture\", \n                           \"Best Original Screenplay\", \n                           \"Best International Feature\"] \nlet oscars2020 = makeDuplicates(of: \"Parasite\", withKeys: awards) \nprint(oscars2020[\"Best Picture\"]) // Parasite \nprint(oscars2020[\"Best International Feature\"]) // Parasite\n```", "```swift\nprotocol TransportMethod { \n    associatedtype CollectionPoint \n    var defaultCollectionPoint: CollectionPoint { get } \n    var averageSpeedInKPH: Double { get } \n}\n```", "```swift\nstruct Train: TransportMethod { \n    typealias CollectionPoint = TrainStation \n\n    // User's home or nearest station \n    var defaultCollectionPoint: TrainStation { \n        return TrainStation.BMS \n    } \n\n    var averageSpeedInKPH: Double { \n        return 100 \n    } \n}\n```", "```swift\nenum TrainStation: String { \n    case BMS = \"Bromley South\" \n    case VIC = \"London Victoria\" \n    case RAI = \"Rainham (Kent)\" \n    case BTN = \"Brighton (East Sussex)\" \n    // Full list of UK train stations codes at  \n    // http://www.nationalrail.co.uk/static/documents/content\n      // /station_codes.csv\n}\n```", "```swift\nclass Journey<TransportType: TransportMethod> { \n\n    let start: TransportType.CollectionPoint \n    let end: TransportType.CollectionPoint \n\n    init(start: TransportType.CollectionPoint,  \n         end: TransportType.CollectionPoint) { \n        self.start = start \n        self.end = end \n    } \n}\n```", "```swift\nclass Journey<TransportType: TransportMethod> { \n\n    let start: TransportType.CollectionPoint \n    let end: TransportType.CollectionPoint \n    let method: TransportType \n\n    init(method: TransportType,  \n         start: TransportType.CollectionPoint,  \n         end: TransportType.CollectionPoint) { \n        self.start = start \n        self.end = end \n        self.method = method \n    } \n}\n```", "```swift\nprotocol TransportLocation { \n    var location: CLLocation { get } \n} \n```", "```swift\nimport CoreLocation\n```", "```swift\nprotocol TransportMethod { \n    associatedtype CollectionPoint: TransportLocation \n    var defaultCollectionPoint: CollectionPoint { get } \n    var averageSpeedInKPH: Double { get } \n} \n```", "```swift\nclass Journey<TransportType: TransportMethod> { \n\n    var start: TransportType.CollectionPoint \n    var end: TransportType.CollectionPoint \n    let method: TransportType \n    var distanceInKMs: Double \n    var durationInHours: Double  \n\n    init(method: TransportType,  \n         start: TransportType.CollectionPoint,  \n         end: TransportType.CollectionPoint) { \n        self.start = start \n        self.end = end \n        self.method = method \n        // CoreLocation provides the distance in meters,  \n        // so we divide by 1000 to get kilometers \n        distanceInKMs = end.location.distance(from: start.location) \n          / 1000 \n        durationInHours = distanceInKMs / method.averageSpeedInKPH  \n    } \n} \n```", "```swift\nenum TrainStation: String, TransportLocation { \n    case BMS = \"Bromley South\" \n    case VIC = \"London Victoria\" \n    case RAI = \"Rainham (Kent)\" \n    case BTN = \"Brighton (East Sussex)\" \n    // Full list of UK train stations codes can be found at  \n    // http://www.nationalrail.co.uk/static/documents/content\n      // /station_codes.csv \n\n    var location: CLLocation { \n        switch self { \n        case .BMS: \n            return CLLocation(latitude: 51.4000504, \n                              longitude: 0.0174237) \n        case .VIC: \n            return CLLocation(latitude: 51.4952103, \n                              longitude: -0.1438979) \n        case .RAI: \n            return CLLocation(latitude: 51.3663, \n                              longitude: 0.61137) \n        case .BTN: \n            return CLLocation(latitude: 50.829, \n                              longitude: -0.14125) \n        } \n    } \n}\n```", "```swift\nlet trainJourney = Journey(method: Train(), \n                           start: TrainStation.BMS, \n                           end: TrainStation.VIC) \nlet distanceByTrain = trainJourney.distanceInKMs \nlet durationByTrain = trainJourney.durationInHours \nprint(\"Journey distance: \\(distanceByTrain) km\") \nprint(\"Journey duration: \\(durationByTrain) hours\") \n```", "```swift\nprotocol TransportMethod { \n    associatedtype CollectionPoint \n    var defaultCollectionPoint: CollectionPoint { get } \n    var averageSpeedInKPH: Double { get } \n} \n```", "```swift\nstruct Train: TransportMethod { \n    typealias CollectionPoint = TrainStation \n\n    // User's home or nearest station \n    var defaultCollectionPoint: TrainStationPoint { \n        return TrainStation.BMS \n    } \n\n    var averageSpeedInKPH: Double { \n        return 100 \n    } \n}\n```", "```swift\nenum TrainStation: String { \n    case BMS = \"Bromley South\" \n    case VIC = \"London Victoria\" \n    case RAI = \"Rainham (Kent)\" \n    case BTN = \"Brighton (East Sussex)\" \n    // Full list of UK train stations codes at  \n    // http://www.nationalrail.co.uk/static/documents/content\n      // /station_codes.csv\n}\n```", "```swift\nclass Journey<TransportType: TransportMethod> { \n\n    let start: TransportType.CollectionPoint \n    let end: TransportType.CollectionPoint \n\n    init(start: TransportType.CollectionPoint,  \n         end: TransportType.CollectionPoint) { \n        self.start = start \n        self.end = end \n    } \n} \n```", "```swift\nclass Journey<TransportType: TransportMethod> { \n\n    let start: TransportType.CollectionPoint \n    let end: TransportType.CollectionPoint \n    let method: TransportType \n\n    init(method: TransportType,  \n         start: TransportType.CollectionPoint,  \n         end: TransportType.CollectionPoint) { \n        self.start = start \n        self.end = end \n        self.method = method \n    } \n} \n```", "```swift\nprotocol TransportLocation { \n    var location: CLLocation { get } \n} \n```", "```swift\nimport CoreLocation \n```", "```swift\nprotocol TransportMethod { \n    associatedtype CollectionPoint: TransportLocation \n    var defaultCollectionPoint: CollectionPoint { get } \n    var averageSpeedInKPH: Double { get } \n} \n```", "```swift\nclass Journey<TransportType: TransportMethod> { \n\n    var start: TransportType.CollectionPoint \n    var end: TransportType.CollectionPoint \n    let method: TransportType \n    var distanceInKMs: Double \n    var durationInHours: Double  \n\n    init(method: TransportType,  \n         start: TransportType.CollectionPoint,  \n         end: TransportType.CollectionPoint) { \n        self.start = start \n        self.end = end \n        self.method = method \n        // CoreLocation provides the distance in meters,  \n        // so we divide by 1000 to get kilometers \n        distanceInKMs = end.location.distance(from: start.location) / \n          1000 \n        durationInHours = distanceInKMs / method.averageSpeedInKPH  \n    } \n} \n```", "```swift\nenum TrainStation: String, TransportLocation { \n    case BMS = \"Bromley South\" \n    case VIC = \"London Victoria\" \n    case RAI = \"Rainham (Kent)\" \n    case BTN = \"Brighton (East Sussex)\" \n    // Full list of UK train stations codes can be found at  \n    // http://www.nationalrail.co.uk/static/documents/content\n     // /station_codes.csv \n\n    var location: CLLocation { \n        switch self { \n        case .BMS: \n            return CLLocation(latitude: 51.4000504, \n                              longitude: 0.0174237) \n        case .VIC: \n            return CLLocation(latitude: 51.4952103, \n                              longitude: -0.1438979) \n        case .RAI: \n            return CLLocation(latitude: 51.3663, \n                              longitude: 0.61137) \n        case .BTN: \n            return CLLocation(latitude: 50.829, \n                              longitude: -0.14125) \n        } \n    } \n}\n```", "```swift\nlet trainJourney = Journey(method: Train(), \n                           start: TrainStation.BMS, \n                           end: TrainStation.VIC) \nlet distanceByTrain = trainJourney.distanceInKMs \nlet durationByTrain = trainJourney.durationInHours \nprint(\"Journey distance: \\(distanceByTrain) km\") \nprint(\"Journey duration: \\(durationByTrain) hours\") \n```", "```swift\nenum Road: TransportMethod { \n    typealias CollectionPoint = CLLocation \n\n    case car \n    case motobike \n    case van \n    case hgv \n\n    // The users home or current location \n    var defaultCollectionPoint: CLLocation { \n        return CLLocation(latitude: 51.1, \n                          longitude: 0.1) \n    } \n\n    var averageSpeedInKPH: Double { \n        switch self {\n        case .car: return 60 \n        case .motobike: return 70 \n        case .van: return 55 \n        case .hgv: return 50 \n        } \n    } \n}\n```", "```swift\nextension CLLocation: TransportLocation { \n    var location: CLLocation { \n        return self \n    } \n} \n```", "```swift\nlet start = CLLocation(latitude: 51.3994669, \n                       longitude: 0.0116888) \nlet end = CLLocation(latitude: 51.2968654, \n                     longitude: 0.5053609) \nlet roadJourney = Journey(method: Road.car, \n                          start: start, \n                          end: end) \nlet distanceByRoad = roadJourney.distanceInKMs \nlet durationByRoad = roadJourney.durationInHours \nprint(\"Journey distance: \\(distanceByRoad) km\") \nprint(\"Journey duration: \\(durationByRoad) hours\") \n```", "```swift\nlet zero: Int  = 0b000 \nlet one: Int   = 0b001 \nlet two: Int   = 0b010 \nlet three: Int = 0b011 \nlet four: Int  = 0b100 \nlet five: Int  = 0b101 \nlet six: Int   = 0b110 \nlet seven: Int = 0b111 \n```", "```swift\nlet phone: Int        = 0b0000001 \nlet tablet: Int       = 0b0000010 \nlet watch: Int        = 0b0000100 \nlet laptop: Int       = 0b0001000 \nlet desktop: Int      = 0b0010000 \nlet tv: Int           = 0b0100000 \nlet brainImplant: Int = 0b1000000 \n\nvar supportedDevices: Int \n```", "```swift\n phone  = 0b0000001  + \n tablet = 0b0000010  + \n tv     = 0b0100000 \n ------------------ \n phone \n tablet = 0b0100011 \n tv \n```", "```swift\n Supported Devices    = 0b 0 1 0 0 0 1 1 \n Phone                = 0b 0 0 0 0 0 0 1 \n AND Operation Result = 0b 0 0 0 0 0 0 1 \n```", "```swift\n AND Operation Result = 0b 0 0 0 0 0 0 1 \n Phone                = 0b 0 0 0 0 0 0 1 \n```", "```swift\n<#left hand side value#> <#operator#> <#right hand side value#>  \n```", "```swift\n2 + 3\n```", "```swift\nlet phone: Int        = 1 << 0 // 0b0000001 \nlet tablet: Int       = 1 << 1 // 0b0000010 \nlet watch: Int        = 1 << 2 // 0b0000100 \nlet laptop: Int       = 1 << 3 // 0b0001000 \nlet desktop: Int      = 1 << 4 // 0b0010000 \nlet tv: Int           = 1 << 5 // 0b0100000 \nlet brainImplant: Int = 1 << 6 // 0b1000000 \n```", "```swift\nsupportedDevices = phone + tablet + tv \n\nfunc isSupported(device: Int) -> Bool { \n    let bitWiseANDResult = supportedDevices & device \n    let containsDevice = bitWiseANDResult == device \n    return containsDevice \n} \n\nlet phoneSupported = isSupported(device: phone) \nprint(phoneSupported) // true \n\nlet brainImplantSupported = isSupported(device: brainImplant) \nprint(brainImplantSupported) // false \n```", "```swift\nlet deviceThatSupportUIKit = phone + tablet + tv \nlet stationaryDevices = desktop + tv \nlet stationaryOrUIKitDevices = deviceThatSupportUIKit | \n  stationaryDevices \nlet orIsUnion = stationaryOrUIKitDevices == (phone + tablet + tv +\n  desktop) \nprint(orIsUnion) // true \n```", "```swift\nlet onlyStationaryOrUIKitDevices = deviceThatSupportUIKit ^ \n  stationaryDevices \nlet xorIsUnionMinusIntersection = onlyStationaryOrUIKitDevices == (phone + \n  tablet + desktop) \nprint(xorIsUnionMinusIntersection) // true\n```", "```swift\nstruct Devices: OptionSet { \n\n    let rawValue: Int \n\n    static let phone        = Devices(rawValue: 1 << 0) \n    static let tablet       = Devices(rawValue: 1 << 1) \n    static let watch        = Devices(rawValue: 1 << 2) \n    static let laptop       = Devices(rawValue: 1 << 3) \n    static let desktop      = Devices(rawValue: 1 << 4) \n    static let tv           = Devices(rawValue: 1 << 5) \n    static let brainImplant = Devices(rawValue: 1 << 6) \n\n    static let none: Devices = [] \n    static let all: Devices = [.phone, \n                               .tablet, \n                               .watch, \n                               .laptop, \n                               .desktop, \n                               .tv, \n                               .brainImplant] \n    static let stationary: Devices = [.desktop, .tv] \n    static let supportsUIKit: Devices = [.phone, \n                                         .tablet, \n                                         .tv] \n} \n\nlet supportedDevices: Devices = [.phone, \n                                 .tablet, \n                                 .watch, \n                                 .tv] \n```", "```swift\n// Contains / AND and comparison \nlet phoneIsSupported = supportedDevices.contains(.phone) \n\n// Union / OR  \nlet stationaryOrUIKitDevices = \n  Devices.supportsUIKit.union(Devices.stationary)  \n\n// Intersection / AND \nlet stationaryAndUIKitDevices =\n  Devices.supportsUIKit.intersection(Devices.stationary) \n```", "```swift\necho \"buy milk\" >> Tasks.txt\n```", "```swift\necho \"mow the lawn\" >> Tasks.txt \n```", "```swift\n<#What to append#> >> <#Where to append it#>\n```", "```swift\ninfix operator >>>\n```", "```swift\nfunc >>> (lhs: String, rhs: String) -> String { \n    var combined = rhs \n    combined.append(lhs) \n    return combined \n}  \n```", "```swift\nfunc >>> (lhs: String, rhs: [String]) -> [String] { \n    var combined = rhs \n    combined.append(lhs) \n    return combined \n}\n```", "```swift\nfunc >>> (lhs: [String], rhs: [String]) -> [String] { \n    var combined = rhs \n    combined.append(contentsOf: lhs) \n    return combined \n}\n```", "```swift\nlet appendedString = \"Two\" >>> \"One\" \nprint(appendedString) // OneTwo\n\nlet appendedStringToArray = \"three\" >>> [\"one\", \"two\"] \nprint(appendedStringToArray) // [\"one\", \"two\", \"three\"]\n\nlet appendedArray = [\"three\", \"four\"] >>> [\"one\", \"two\"] \nprint(appendedArray)  // [\"one\", \"two\", \"three\", \"four\"]\n```", "```swift\nfunc >>> <Element>(lhs: Element, \n                   rhs: Array<Element>) -> Array<Element> { \n    var combined = rhs \n    combined.append(lhs) \n    return combined \n} \n\nfunc >>> <Element>(lhs: Array<Element>, \n                   rhs: Array<Element>) -> Array<Element> { \n    var combined = rhs \n    combined.append(contentsOf: lhs) \n    return combined \n} \n```", "```swift\nlet appendedIntToArray = 3 >>> [1, 2] \nprint(appendedIntToArray) // [1, 2, 3]\n\nlet appendedIntArray = [3, 4] >>> [1, 2] \nprint(appendedIntArray) // [1, 2, 3, 4]\n```", "```swift\nstruct Task { \n    let name: String  \n} \n\nclass TaskList: CustomStringConvertible { \n    private var tasks: [Task] = [] \n    func append(task: Task) { \n        tasks.append(task) \n    } \n    var description: String { \n        return tasks.map { $0.name }.joined(separator: \"\\n\") \n    } \n} \n```", "```swift\nextension TaskList { \n    static func >>> (lhs: Task, rhs: TaskList) { \n        rhs.append(task: lhs) \n    } \n}\n```", "```swift\nlet shoppingList = TaskList() \nTask(name: \"get milk\") >>> shoppingList \nprint(shoppingList) \nTask(name: \"get teabags\") >>> shoppingList \nprint(shoppingList)\n```", "```swift\ninfix operator >>>\n```", "```swift\nlet trueValue = !falseValue\n```", "```swift\nlet unwrapped = optional!\n```", "```swift\nlet five = 2 + 3\n```", "```swift\nfunc >>> (lhs: String, rhs: String) -> String { \n    var combined = rhs \n    combined.append(lhs) \n    return combined \n}  \n```", "```swift\nfunc >>> (lhs: String, rhs: [String]) -> [String] { \n    var combined = rhs \n    combined.append(lhs) \n    return combined \n}\n```", "```swift\nfunc >>> (lhs: [String], rhs: [String]) -> [String] { \n    var combined = rhs \n    combined.append(contentsOf: lhs) \n    return combined \n}\n```", "```swift\nlet appendedString = \"Two\" >>> \"One\" \nprint(appendedString) // OneTwo\n\nlet appendedStringToArray = \"three\" >>> [\"one\", \"two\"] \nprint(appendedStringToArray) // [\"one\", \"two\", \"three\"]\n\nlet appendedArray = [\"three\", \"four\"] >>> [\"one\", \"two\"] \nprint(appendedArray)  // [\"one\", \"two\", \"three\", \"four\"]\n```", "```swift\nfunc >>> <Element>(lhs: Element, \n                   rhs: Array<Element>) -> Array<Element> { \n    var combined = rhs \n    combined.append(lhs) \n    return combined \n} \n\nfunc >>> <Element>(lhs: Array<Element>, \n                   rhs: Array<Element>) -> Array<Element> { \n    var combined = rhs \n    combined.append(contentsOf: lhs) \n    return combined \n} \n```", "```swift\nlet appendedIntToArray = 3 >>> [1, 2] \nprint(appendedIntToArray) // [1, 2, 3]\n\nlet appendedIntArray = [3, 4] >>> [1, 2] \nprint(appendedIntArray)  // [1, 2, 3, 4]\n```", "```swift\nstruct Task { \n    let name: String  \n} \n\nclass TaskList: CustomStringConvertible { \n    private var tasks: [Task] = [] \n    func append(task: Task) { \n        tasks.append(task) \n    } \n    var description: String { \n        return tasks.map { $0.name }.joined(separator: \"\\n\") \n    } \n} \n```", "```swift\nextension TaskList { \n  static func >>> (lhs: Task, rhs: TaskList) { \n    rhs.append(task: lhs) \n  } \n} \n```", "```swift\nlet shoppingList = TaskList() \nTask(name: \"get milk\") >>> shoppingList \nprint(shoppingList) \nTask(name: \"get teabags\") >>> shoppingList \nprint(shoppingList) \n```", "```swift\nlet result = 6 + 8 / 2 / 4\n```", "```swift\nlet result = 6 + ((8 / 2) / 4) \n```", "```swift\nlet result = 6 + (8 / 2 / 4) \n```", "```swift\nlet result = 6 + ((8 / 2) / 4) \n```", "```swift\nlet multiOperationArray = [5,6] >>> [3,4] >>> [1,2] + [9,10] >>> [7,8] \nprint(multiOperationArray) \n```", "```swift\nprecedencegroup AppendingPrecedence { \n    associativity: left \n    higherThan: AdditionPrecedence \n    lowerThan: MultiplicationPrecedence \n} \n```", "```swift\ninfix operator >>> : AppendingPrecedence \n```", "```swift\nlet multiOperationArray = [5,6] >>> [3,4] >>> [1,2] + [9,10] >>> [7,8] \n print(multiOperationArray) // [1,2,3,4,5,6,7,8,9,10] \n```", "```swift\nclass Device { \n\n    enum Category { \n        case watch \n        case phone \n        case tablet \n    } \n\n    enum Orientation { \n        case portrait \n        case portraitUpsideDown \n        case landscapeLeft \n        case landscapeRight \n    } \n\n    let category: Category \n    var currentOrientation: Orientation = .portrait \n\n    init(category: Category) { \n        self.category = category \n    } \n} \n```", "```swift\nlet phone = Device(category: .phone) \nlet desiredOrientation: Device.Orientation = .portrait \nlet phoneHasDesiredOrientation = phone.currentOrientation == \n  desiredOrientation  \n```", "```swift\nstruct UserInterface { \n\n    struct Version { \n        let major: Int \n        let minor: Int \n        let patch: Int \n    } \n\n    enum Orientation { \n        case portrait \n        case landscape \n    } \n\n    let version: Version \n    var orientation: Orientation \n} \n```", "```swift\nfunc uiOrientation(for deviceOrientation: Device.Orientation) -> \n  UserInterface.Orientation { \n    switch deviceOrientation { \n    case Device.Orientation.portrait, \n      Device.Orientation.portraitUpsideDown: \n        return UserInterface.Orientation.portrait \n    case Device.Orientation.landscapeLeft, \n      Device.Orientation.landscapeRight: \n        return UserInterface.Orientation.landscape \n    } \n} \nlet phoneUIOrientation = uiOrientation(for: \n   phone.currentOrientation) \nprint(phoneUIOrientation) // UserInterface.Orientation.portrait \n```", "```swift\nDevice.Orientation.portrait \nUserInterface.Orientation.portrait \n```", "```swift\nfunc uiOrientation(for deviceOrientation: Device.Orientation) -> UserInterface.Orientation { \n    switch deviceOrientation { \n    case .portrait, .portraitUpsideDown: \n        return .portrait \n    case .landscapeLeft, .landscapeRight: \n        return .landscape \n    } \n} \n```", "```swift\nclass Operation { \n\n    let doctorsName: String \n    let patientsName: String \n\n    init(doctorsName: String, patientsName: String) { \n        self.doctorsName = doctorsName \n        self.patientsName = patientsName \n    } \n} \n```", "```swift\nimport Foundation \n\nlet medicalOperation = Operation(doctorsName: \"Dr. Crusher\", \n                                 patientsName: \"Commander Riker\") \nlet longRunningOperation = Foundation.Operation() \n```"]