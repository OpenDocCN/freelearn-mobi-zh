["```swift\nimport AVKit\n```", "```swift\nlet playerController = AVPlayerViewController()\n```", "```swift\n// 1\naddChild(playerController)\nplayerController.didMove(toParent: self)\n// 2\nview.addSubview(playerController.view)\nlet playerView = playerController.view!\nplayerView.translatesAutoresizingMaskIntoConstraints = false\nNSLayoutConstraint\n  .activate([\n    playerView.widthAnchor.constraint(equalTo: view.widthAnchor, constant: -20),\n    playerView.heightAnchor.constraint(equalTo: playerView.widthAnchor, multiplier: 9/16),\n    playerView.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n    playerView.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n])\n```", "```swift\nlet url = Bundle.main.url(forResource: \"samplevideo\", withExtension: \"mp4\")!\nplayerController.player = AVPlayer(url: url)\n```", "```swift\nlet files = [\"one\", \"two\", \"three\"]\nvar currentTrack = 0\nvar audioPlayer: AVAudioPlayer!\n```", "```swift\nimport AVKit\n```", "```swift\nfunc loadTrack() {\n  let url = Bundle.main.url(forResource: files[currentTrack], withExtension: \"mp3\")!\n  audioPlayer = try! AVAudioPlayer(contentsOf: url)\n  audioPlayer.delegate = self\n}\n```", "```swift\nextension AudioViewController: AVAudioPlayerDelegate {\n}\n```", "```swift\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  loadTrack()\n}\n```", "```swift\nfunc startPlayback() {\n  audioPlayer.play()\n  playPause.setTitle(\"Pause\", for: .normal)\n}\nfunc pausePlayback() {\n  audioPlayer.pause()\n  playPause.setTitle(\"Play\", for: .normal)\n}\n```", "```swift\n@IBAction func playPauseTapped() {\n  if audioPlayer.isPlaying {\n    pausePlayback()\n  } else {\n    startPlayback()\n  }\n}\n```", "```swift\n@IBAction func nextTapped() {\n  currentTrack += 1\n  if currentTrack >= files.count {\n    currentTrack = 0\n  }\n  loadTrack()\n  audioPlayer.play()\n}\n@IBAction func previousTapped() {\n  currentTrack -= 1\n  if currentTrack < 0 {\n    currentTrack = files.count - 1\n  }\n  loadTrack()\n  audioPlayer.play()\n}\n```", "```swift\nfunc audioPlayerDidFinishPlaying(_ player: AVAudioPlayer, successfully flag: Bool) {\n  nextTapped()\n}\n```", "```swift\nvar timer: Timer?\n```", "```swift\nfunc startTimer() {\n  timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [unowned self] timer in\n    self.slider.value = Float(self.audioPlayer.currentTime / self.audioPlayer.duration)\n  }\n}\nfunc stopTimer() {\n  timer?.invalidate()\n}\n```", "```swift\n@IBAction func sliderDragStart() {\n  stopTimer()\n}\n@IBAction func sliderDragEnd() {\n  startTimer()\n}\n@IBAction func sliderChanged() {\n  audioPlayer.currentTime = Double(slider.value) * audioPlayer.duration\n}\n```", "```swift\nfunc showMetadataForURL(_ url: URL) {\n  let mediaItem = AVPlayerItem(url: url)\n  let metadata = mediaItem.asset.metadata\n  var information = [String]()\n  for item in metadata {\n    guard let identifier = item.identifier else { continue }\n    switch identifier {\n      case .id3MetadataTitleDescription, .id3MetadataBand:\n        information.append(item.value?.description ?? \"\")\n      default:\n        break\n    }\n  }\n  let trackTitle = information.joined(separator: \" - \")\n  titleLabel.text = trackTitle\n}\n```", "```swift\ntry? AVAudioSession.sharedInstance().setCategory(.playback, mode: .default, options: [.allowAirPlay])\ntry? AVAudioSession.sharedInstance().setActive(true, options: [])\n```", "```swift\nimport MediaPlayer\n```", "```swift\nNotificationCenter.default.addObserver(self, selector: #selector(updateNowPlaying), name: UIApplication.didEnterBackgroundNotification, object: nil)\n```", "```swift\n@objc func updateNowPlaying() {\n  var nowPlayingInfo = [String: Any]()\n  nowPlayingInfo[MPMediaItemPropertyTitle] = titleLabel.text ?? \"untitled\"\n  nowPlayingInfo[MPNowPlayingInfoPropertyElapsedPlaybackTime] = audioPlayer.currentTime\n  nowPlayingInfo[MPMediaItemPropertyPlaybackDuration] = audioPlayer.duration\n  MPNowPlayingInfoCenter.default().nowPlayingInfo = nowPlayingInfo\n}\n```", "```swift\nfunc configureRemoteCommands() {\n  let commandCenter = MPRemoteCommandCenter.shared()\n  commandCenter.playCommand.addTarget { [unowned self] event in\n    guard self.audioPlayer.isPlaying == false else { return .commandFailed }\n    self.startPlayback()\n    return .success\n  }\n  commandCenter.pauseCommand.addTarget { [unowned self] event in\n    guard self.audioPlayer.isPlaying else { return .commandFailed }\n    self.pausePlayback()\n    return .success\n  }\n  commandCenter.nextTrackCommand.addTarget { [unowned self] event in\n    self.nextTapped()\n    return .success\n  }\n  commandCenter.previousTrackCommand.addTarget { [unowned self] event in\n    self.previousTapped()\n    return .success\n  }\n  UIApplication.shared.beginReceivingRemoteControlEvents()\n}\n```", "```swift\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  let imagePicker = UIImagePickerController()\n  imagePicker.sourceType = .camera\n  imagePicker.delegate = self\n  present(imagePicker, animated: true, completion: nil)\n}\n```", "```swift\nextension ImageViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate {\n  func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {\n    picker.dismiss(animated: true, completion: nil)\n    guard let image = info[.originalImage] as? UIImage else { return }\n    selectedImage = image\n  }\n}\n```", "```swift\n@IBAction func saveImage() {\n  guard let image = selectedImage else { return }\n  UIImageWriteToSavedPhotosAlbum(image, self, #selector(didSaveImage(_:withError:contextInfo:)), nil)\n}\n@objc func didSaveImage(_ image: UIImage, withError error: Error?, contextInfo: UnsafeRawPointer) {\n  guard error == nil else { return }\n  presentAlertWithTitle(\"Success\", message: \"Image was saved succesfully\")\n}\n```", "```swift\nlet videoCaptureSession = AVCaptureSession()\nlet videoOutput = AVCaptureMovieFileOutput()\nvar previewLayer:  AVCaptureVideoPreviewLayer?\n```", "```swift\noverride func viewDidLoad() {\n  super.viewDidLoad()\n  // 1\n  guard let camera = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .back),\n  let microphone = AVCaptureDevice.default(.builtInMicrophone, for: .audio, position: .unspecified) else { return }\n  // 2\n  do {\n    let cameraInput = try AVCaptureDeviceInput(device: camera)\n    let microphoneInput = try AVCaptureDeviceInput(device: microphone)\n    videoCaptureSession.addInput(cameraInput)\n    videoCaptureSession.addInput(microphoneInput)\n    videoCaptureSession.addOutput(videoOutput)\n  } catch {\n    print(error.localizedDescription)\n  }\n}\n```", "```swift\npreviewLayer = AVCaptureVideoPreviewLayer(session: videoCaptureSession)\npreviewLayer?.videoGravity = .resizeAspectFill\nvideoView.layer.addSublayer(previewLayer!)\nvideoCaptureSession.startRunning()\n```", "```swift\noverride func viewDidLayoutSubviews() {\n  super.viewDidLayoutSubviews()\n  previewLayer?.bounds.size = videoView.frame.size\n  previewLayer?.position = CGPoint(x: videoView.frame.midX, y:videoView.frame.size.height / 2)\n}\n```", "```swift\n@IBAction func startStopRecording() {\n  // 1\n  if videoOutput.isRecording {\n    videoOutput.stopRecording()\n  } else {\n    // 2\n    guard let path = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first else { return }\n    let fileUrl = path.appendingPathComponent(\"recording.mov\")\n    // 3\n    try? FileManager.default.removeItem(at: fileUrl)\n    // 4\n    videoOutput.startRecording(to: fileUrl, recordingDelegate: self)\n  }\n}\n```", "```swift\nextension RecordVideoViewController: AVCaptureFileOutputRecordingDelegate {\n  // 1\n  func fileOutput(_ output: AVCaptureFileOutput, didStartRecordingTo fileURL: URL, from connections: [AVCaptureConnection]) {\n    startStopButton.setTitle(\"Stop Recording\", for: .normal)\n  }\n  // 2\n  func fileOutput(_ output: AVCaptureFileOutput, didFinishRecordingTo outputFileURL: URL, from connections: [AVCaptureConnection], error: Error?) {\n    guard error == nil else { return }\n    UISaveVideoAtPathToSavedPhotosAlbum(outputFileURL.path, self, #selector(didSaveVideo(at:withError:contextInfo:)), nil)\n  }\n  // 3\n  @objc func didSaveVideo(at path: String, withError error: Error?, contextInfo: UnsafeRawPointer?) {\n    guard error == nil else { return }\n    presentAlertWithTitle(\"Success\", message: \"Video was saved succesfully\")\n    startStopButton.setTitle(\"Start Recording\", for: .normal)\n  }\n}\n```", "```swift\nlet filter = CIFilter(name: \"CIPhotoEffectNoir\")\n```", "```swift\n@IBAction func applyGrayScale() {\n  // 1\n  guard let cgImage = selectedImage?.cgImage,\n  // 2\n  let initialOrientation = selectedImage?.imageOrientation,\n  // 3\n  let filter = CIFilter(name: \"CIPhotoEffectNoir\") else { return }\n  // 4\n  let sourceImage = CIImage(cgImage: cgImage)\n  filter.setValue(sourceImage, forKey: kCIInputImageKey)\n  // 5\n  let context = CIContext(options: nil)\n  guard let outputImage = filter.outputImage, let cgImageOut = context.createCGImage(outputImage, from: outputImage.extent) else { return }\n  // 6\n  selectedImage = UIImage(cgImage: cgImageOut, scale: 1, orientation: initialOrientation)\n}\n```", "```swift\n@IBAction func cropSquare() {\n  let context = CIContext(options: nil)\n  guard let cgImage = selectedImage?.cgImage, let initialOrientation = selectedImage?.imageOrientation, let filter = CIFilter(name: \"CICrop\") else { return }\n  let size = CGFloat(min(cgImage.width, cgImage.height))\n  let center = CGPoint(x: cgImage.width / 2, y: cgImage.height / 2)\n  let origin = CGPoint(x: center.x - size / 2, y: center.y - size / 2)\n  let cropRect = CGRect(origin: origin, size: CGSize(width: size, height: size))\n  let sourceImage = CIImage(cgImage: cgImage)\n  filter.setValue(sourceImage, forKey: kCIInputImageKey)\n  filter.setValue(CIVector(cgRect: cropRect), forKey: \"inputRectangle\")\n  guard let outputImage = filter.outputImage, let cgImageOut = context.createCGImage(outputImage, from: outputImage.extent) else { return }\n  selectedImage = UIImage(cgImage: cgImageOut, scale: 1, orientation: initialOrientation)\n  }\n}\n```"]