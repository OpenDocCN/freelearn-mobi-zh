<html><head></head><body>
		<div><h1 id="_idParaDest-105"><em class="italic"><a id="_idTextAnchor108"/>Chapter 7</em>: Classes, Structures, and Enumerations</h1>
			<p>In the previous chapter, you've learned how to group instruction sequences together using functions and closures.</p>
			<p>It's time to think about how to represent complex objects in your code. For example, think about a car. You could use a <code>String</code> constant to store a car name and a <code>Double</code> variable to store a car price, but they are not associated with one another. You've seen that you can group instructions together to make functions and closures. In this chapter, you'll learn how to group constants and variables together in a single entity using <strong class="bold">classes</strong> and <strong class="bold">structures</strong>, and how to manipulate them. You'll also learn how to use <strong class="bold">enumerations</strong> to group a set of related values together.</p>
			<p>By the end of this chapter, you'll have learned how to create and initialize a class, create a subclass from an existing class, create and initialize a structure, differentiate between classes and structures, and create an enumeration.</p>
			<p>The following topics will be covered in this chapter: </p>
			<ul>
				<li>Understanding classes</li>
				<li>Understanding structures</li>
				<li>Understanding enumerations</li>
			</ul>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor109"/>Technical requirements</h1>
			<p>The Xcode playground for this chapter is in the <code>Chapter07</code> folder of the code bundle for this book, which can be downloaded here:</p>
			<p><a href="https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition">https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition</a> </p>
			<p>Check out the following video to see the code in action:</p>
			<p><a href="https://bit.ly/3HbRJTA">https://bit.ly/3HbRJTA</a></p>
			<p>If you wish to start from scratch, create a new playground and name it <code>Classes,StructuresAndEnumerations</code>. You can type in and run all of the code in this chapter as you go along. Let's start with learning what a class is, and how to declare and define it.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor110"/>Understanding classes</h1>
			<p>Classes <a id="_idIndexMarker211"/>are useful for representing complex objects, for example: </p>
			<ul>
				<li>Individual employee information for a company</li>
				<li>Items for sale at an e-commerce site</li>
				<li>Items you have in your house for insurance purposes</li>
			</ul>
			<p>Here's what a class declaration and definition looks like:</p>
			<pre>class ClassName {
   property1
   property2 
   property3 
   method1() { 
      code
   }
   method2() {
      code
   }
} </pre>
			<p>Every class has a descriptive name, and it contains variables or constants used to represent an <a id="_idIndexMarker212"/>object. Variables or constants associated with a class are called <strong class="bold">properties</strong>.</p>
			<p>A class can also contain functions that perform specific tasks. Functions associated with a class are <a id="_idIndexMarker213"/>called <strong class="bold">methods</strong>.</p>
			<p>Once you have declared and defined a class, you can create <code>Animal</code> class, you can use instances of that class to represent different animal types at the zoo. Each of these instances will have different values for their properties.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">To learn more <a id="_idIndexMarker214"/>about classes, visit: <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html">https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html</a>.</p>
			<p>Let's look at how to work with classes. You'll learn how to declare and define classes, create instances <a id="_idIndexMarker215"/>based on the class declaration, and manipulate those instances. You'll start by creating a class declaration to represent animals in the next section.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor111"/>Creating a class declaration</h2>
			<p>Let's declare<a id="_idIndexMarker216"/> and define a class that can store details about animals. Add the following code to your playground:</p>
			<pre>class Animal {
   var name: String = "" 
   var sound: String = ""
   var numberOfLegs: Int = 0
   var breathesOxygen: Bool = true
   func makeSound() {
      print(self.sound)
   }
}</pre>
			<p>You've just declared a very simple class named <code>Animal</code>. Convention dictates that class names start with a capital letter. This class has properties to store the name of the animal, the sound it makes, the number of legs it has, and whether it breathes oxygen or not. This class also has a method, <code>makeSound()</code>, that prints the noise it makes to the Debug area.</p>
			<p>Now that <a id="_idIndexMarker217"/>you have an <code>Animal</code> class, let's use it to create an instance of an animal in the next section.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor112"/>Making an instance of the class</h2>
			<p>Once you have <a id="_idIndexMarker218"/>declared and defined a class, you can create instances of that class. You will now create an instance of the <code>Animal</code> class that represents a cat. Follow these steps:</p>
			<ol>
				<li>To create an instance of the <code>Animal</code> class, list all its properties and call its <code>makeSound()</code> method, type the following after your class declaration and run it:<pre>let cat = Animal()
print(cat.name)
print(cat.sound) 
print(cat.numberOfLegs) 
print(cat.breathesOxygen)
cat.makeSound()</pre><p>You access instance properties and methods by typing a dot after the instance name, followed by the property or method you want. You'll see the values for the instance properties and method calls listed in the Debug area. Since the values are the default values assigned when the class was created, <code>name</code> and <code>sound</code> contain empty strings, <code>numberOfLegs</code> contains <code>0</code>, <code>breathesOxygen</code> contains <code>true</code>, and the <code>makeSound()</code> method prints an empty string.</p></li>
				<li>Let's assign some values to this instance's properties. Modify your code as shown:<pre>let cat = Animal()
<code>makeSound() </code>method are printed to the Debug area. </p><p>Note that here you create the instance first, and then assign values to that instance. It is also possible to assign the values when the instance is being created, and you do this by implementing an initializer in your class declaration. </p></li>
				<li>An initializer is responsible for ensuring all of the instance properties have valid values when a class is created. Let's add an initializer for the <code>Animal</code> class. Modify your class definition as shown:<pre>class Animal {
   var name: String 
   var sound: String
   var numberOfLegs: Int
   var breathesOxygen: Bool
<code>init</code> keyword and has a list of parameters that will be used to set the property values. Note that the <code>self</code> keyword distinguishes the property names from the parameters. For example, <code>self.name</code> refers to the property and <code>name</code> refers to the parameter. At the end of the initialization process, every property in the class should have a valid value.</p></li>
				<li>You'll see some errors in your code at this point. You will need to update your function call to address this. Modify your code as shown and run it:<pre>   func makeSound() {
      print(self.sound)
   }
}
<strong class="bold">let cat = Animal(name: "Cat", sound: "Mew", </strong>
<strong class="bold">numberOfLegs: 4, breathesOxygen: true)</strong>
print(cat.name)</pre></li>
			</ol>
			<p>The results are the same as those in <em class="italic">Step 2</em>, but you created the instance and set its properties in a single instruction. Excellent!</p>
			<p>Now there are different types of animals, such as mammals, birds, reptiles, and fish. You could create a<a id="_idIndexMarker221"/> class for each type, but you could also create a <strong class="bold">subclass</strong> based on an existing class. Let's see how to do that in the next section.</p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor113"/>Making a subclass</h2>
			<p>A subclass of a<a id="_idIndexMarker222"/> class inherits all of the methods and properties of an existing class. You can also add additional properties and methods to it if you wish. You'll now create <code>Mammal</code>, a subclass of the <code>Animal</code> class. Follow these steps:</p>
			<ol>
				<li value="1">To declare the <code>Mammal</code> class, type in the following code just after the <code>Animal</code> class declaration:<pre>class Mammal: Animal {
   let hasFurOrHair: Bool = true
}</pre><p>Typing <code>: Animal</code> after the class name makes the <code>Mammal</code> class a subclass of the <code>Animal</code> class. It has all the properties and methods declared in the <code>Animal</code> class, and one additional property, <code>hasFurOrHair</code>. Since the <code>Animal</code> class is the parent of the <code>Mammal</code> class, you can refer to it as the <code>Mammal</code> class.</p></li>
				<li>Modify your code that creates an instance of your class as shown, and run it:<pre>let cat = <code>cat</code> is now an instance of the <code>Mammal</code> class instead of the <code>Animal</code> class. As you can see, the results displayed in the Debug area are the same as before, and there are no errors. The value for <code>hasFurOrHair</code> has not been displayed though. Let's fix that.</p></li>
				<li>Type in the following code after all other code in your playground to display the contents of the <code>hasFurOrHair</code> property and run it:<pre>print(cat.hasFurOrHair)</pre><p>Since the <a id="_idIndexMarker223"/>initializer for the <code>Animal</code> class does not have a parameter to assign a value to <code>hasFurOrHair</code>, the default value is used, and <code>true</code> will be displayed in the Debug area.</p><p>You have seen that a subclass can have additional properties. A subclass can also have additional methods, and method implementation in a subclass can differ from the superclass implementation. Let's see how to do that in the next section.</p></li>
			</ol>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor114"/>Overriding a superclass method</h2>
			<p>So far, you've<a id="_idIndexMarker224"/> been using multiple <code>print()</code> statements to display the values of the class instance. You'll implement a <code>description()</code> method to display all of the instance properties in the Debug area, so multiple <code>print()</code> statements will no longer be required. Follow these steps:</p>
			<ol>
				<li value="1">Modify your <code>Animal</code> class declaration to implement a <code>description()</code> method, as shown:<pre>class Animal {
   var name: String 
   var sound: String
   var numberOfLegs: Int
   var breathesOxygen: Bool = true
   init(name: String, sound: String, numberOfLegs:
   Int, breathesOxygen: Bool) {
      self.name = name 
      self.sound = sound
      self.numberOfLegs = numberOfLegs 
      self.breathesOxygen = breathesOxygen
   }
   func makeSound() {
      print(self.sound)
   }
<strong class="bold">   func description() -&gt; String {</strong>
<strong class="bold">      return "name: \(self.name) </strong>
<strong class="bold">      sound: \(self.sound)</strong>
<strong class="bold">      numberOfLegs: \(self.numberOfLegs)</strong>
<strong class="bold">      breathesOxygen: \(self.breathesOxygen)"</strong>
<strong class="bold">   }</strong>
}</pre></li>
				<li>Modify your <a id="_idIndexMarker225"/>code as shown to use the <code>description()</code> method in place of the multiple <code>print()</code> statements, and run the program:<pre>let cat = Mammal(name: "Cat", sound: "Mew", 
numberOfLegs: 4, breathesOxygen: true)
<code>description()</code> method is not implemented in the <code>Mammal</code> class, it is implemented in the <code>Animal</code> class. This means it will be inherited by the <code>Mammal</code> class, and the instance properties will be printed to the Debug area. Note that the value for the <code>hasFurOrHair</code> property is missing, and you can't put it in the <code>description()</code> method because the <code>hasFurOrHair</code> property does not exist for the <code>Animal</code> class.</p></li>
				<li>You can change the implementation of the <code>description()</code> method in the <code>Mammal</code> class <a id="_idIndexMarker226"/>to display the <code>hasFurOrHair</code> property's value. Add the following code to your <code>Mammal</code> class definition and run it:<pre>Mammal: Animal {
   let hasFurOrHair: Bool = true
<code>override</code> keyword is used here to specify that the <code>description()</code> method implemented here is to be used in place of the superclass implementation. The <code>super</code> keyword is used to call the superclass implementation of <code>description()</code>. The value in <code>hasFurOrHair</code> is then added to the string returned by <code>super.description()</code>. </p><p>You will see the following in the Debug area:</p><pre>name: Cat sound: Mew numberOfLegs: 4 breathesOxygen: true hasFurOrHair: true
Mew</pre></li>
			</ol>
			<p>The <code>hasFurOrHair</code> property's value is displayed in the Debug area, showing that you are using the <code>Mammal</code> subclass implementation of the <code>description()</code> method.</p>
			<p>You've created class and subclass declarations and made instances of both. You've also added initializers <a id="_idIndexMarker227"/>and methods to both. Cool! Let's look at how to declare and use structures in the next section.</p>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor115"/>Understanding structures</h1>
			<p>Like classes, structures<a id="_idIndexMarker228"/> also group together properties and methods used to represent an object and do specific tasks. Remember the <code>Animal</code> class you created? You can also use a structure to accomplish the same thing. There are differences between classes and structures though, and you will learn more about those later.</p>
			<p>Here's what a structure declaration and definition looks like:</p>
			<pre>struct StructName { 
   property1 
   property2 
   property3
   method1() {
      code
   }
   method2(){
      code
   }
}</pre>
			<p>As you can see, a structure is very similar to a class. It also has a descriptive name, can contain properties and methods, and you can create instances.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">To learn more <a id="_idIndexMarker229"/>about structures, visit: <a href="https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html">https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html</a>.</p>
			<p>Let's look at how to work with structures. You'll learn how to declare and define structures, create <a id="_idIndexMarker230"/>instances based on the structure, and manipulate them. You'll start by creating a structure to represent reptiles in the next section.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor116"/>Creating a structure declaration</h2>
			<p>Continuing <a id="_idIndexMarker231"/>with the animal theme, let's declare and define a structure that can store details of reptiles. Add the following code after all other code in your playground:</p>
			<pre>struct Reptile {
   var name: String 
   var sound: String
   var numberOfLegs: Int
   var breathesOxygen: Bool
   let hasFurOrHair: Bool = false 
   func makeSound() {
      print(sound)
   }
   func description() -&gt; String {
      return "Structure: Reptile name: \(self.name) 
      sound: \(self.sound) 
      numberOfLegs: \(self.numberOfLegs)
      breathesOxygen: \(self.breathesOxygen) 
      hasFurOrHair: \(self.hasFurOrHair)"
   }
}</pre>
			<p>As you can see, this is almost the same as the <code>Animal</code> class declaration you did earlier. Structure names also normally start with a capital letter, and this structure has properties to store the name of the animal, the sound it makes, how many legs it has, whether it breathes oxygen, and whether it has fur or hair. This structure also has a method, <code>makeSound()</code>, that prints the sound it makes to the Debug area.</p>
			<p>Now that you <a id="_idIndexMarker232"/>have a <code>Reptile</code> structure declaration, let's use it to create an instance representing a snake in the next section.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor117"/>Making an instance of the structure</h2>
			<p>As with classes, you <a id="_idIndexMarker233"/>can create instances from a structure declaration. You will now create an instance of the <code>Reptile</code> structure that represents a snake, print out the property values of that instance, and call the <code>makeSound()</code> method. Type the following after your structure declaration and run it:</p>
			<pre>var snake = Reptile(name: "Snake", sound: "Hiss", 
numberOfLegs: 0, breathesOxygen: true)
print(snake.description())
snake.makeSound()</pre>
			<p>Note that you did not need to implement an initializer; structures automatically get an initializer for all of their properties, called<a id="_idIndexMarker234"/> the <strong class="bold">memberwise</strong> initializer. Neat! The following will be displayed in the Debug area:</p>
			<pre>Structure: Reptile name: Snake sound: Hiss numberOfLegs: 0 breathesOxygen: true hasFurOrHair: false
Hiss</pre>
			<p>Even though the structure declaration is very similar to the class declaration, there are two differences between a class and a structure:</p>
			<ul>
				<li>Structures cannot inherit from another structure.</li>
				<li>Classes are <strong class="bold">reference types</strong>, while structures are <strong class="bold">value types</strong>.</li>
			</ul>
			<p>Let's look at the difference between value types and reference types in the next section.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor118"/>Comparing value types and reference types</h2>
			<p>Classes are <a id="_idIndexMarker235"/>reference types. This means when you assign a class instance to a variable, you are actually storing the memory location of the original instance in the variable, instead of the instance itself.</p>
			<p>Structures are value types. This means when you assign a structure instance to a variable, that instance is copied, and whatever changes you make to the original instance do not affect the copy. </p>
			<p>Now, you will create an instance of a class and a structure and observe the differences between them. Follow these steps:</p>
			<ol>
				<li value="1">You'll start by creating a variable containing a structure instance and assigning it to a second variable, then change the value of a property in the second variable. Type in the following code and run it:<pre>struct SampleValueType {
   var sampleProperty = 10
}
var a = SampleValueType()
var b = a 
b.sampleProperty = 20 
print(a.sampleProperty) 
print(b.sampleProperty)</pre><p>In this example, you declared a structure, <code>SampleValueType</code>, that contains one property, <code>sampleProperty</code>. Then, you created an instance of that structure and assigned it to a variable, <code>a</code>. After that, you assigned <code>a</code> to a new variable, <code>b</code>. Next, you changed the <code>sampleProperty</code> value of <code>b</code> to <code>20</code>. When you print out the <code>sampleProperty</code> value of <code>a</code>, <code>10</code> is printed in the Debug area, showing that any changes made to the <code>sampleProperty</code> value of <code>b</code> do not affect the <code>sampleProperty</code> value of <code>a</code>. This is because when you assigned <code>a</code> to <code>b</code>, a copy of <code>a</code> was assigned to <code>b</code>, so they are completely separate instances that don't affect one another.</p></li>
				<li>Next, you'll create a variable containing a class instance and assign it to a second variable, then change the value of a property in the second variable. Type in the following code and run it:<pre>class SampleReferenceType {
   var sampleProperty = 10
}
var c = SampleReferenceType()
var d = c 
c.sampleProperty = 20 
print(c.sampleProperty) 
print(d.sampleProperty)</pre></li>
			</ol>
			<p>In this<a id="_idIndexMarker236"/> example, you declared a class, <code>SampleReferenceType</code>, that contains one property, <code>sampleProperty</code>. Then, you created an instance of that class and assigned it to a variable, <code>c</code>. After that, you assigned <code>c</code> to a new variable, <code>d</code>. Next, you changed the <code>sampleProperty</code> value of <code>d</code> to <code>20</code>. When you print out the <code>sampleProperty </code>value of <code>c</code>, <code>20</code> is printed in the Debug area, showing that any changes made to <code>c</code> or <code>d</code> are affecting the same <code>SampleReferenceType</code> instance.</p>
			<p>Now, the question is, which should you use, classes or structures? Let's explore that in the next section.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor119"/>Deciding between classes and structures</h2>
			<p>You've seen<a id="_idIndexMarker237"/> that<a id="_idIndexMarker238"/> you can use either a class or a structure to represent a complex object. So, which should you use?</p>
			<p>It is recommended to use structures unless you need something that requires classes, such as subclasses. This actually helps to prevent some subtle errors that may occur due to classes being reference types.</p>
			<p>Fantastic! Now that you <a id="_idIndexMarker239"/>have learned about classes and structures, let's take a<a id="_idIndexMarker240"/> look at <strong class="bold">enumerations</strong>, which allow you to group related values together, in the next section.</p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor120"/>Understanding enumerations</h1>
			<p>Enumerations <a id="_idIndexMarker241"/>allow you to group related values together, for example: </p>
			<ul>
				<li>Compass directions (E, W, N, and S) </li>
				<li>Traffic light colors</li>
				<li>The colors of a rainbow</li>
			</ul>
			<p>To understand why enumerations would be ideal for this purpose, let's consider the following example.</p>
			<p>Imagine you're programming a traffic light. You can use an integer variable to represent different traffic light colors where <code>0</code> is red, <code>1</code> is yellow and <code>2</code> is green, like this:</p>
			<pre>var trafficLightColor = 2</pre>
			<p>Although this is a possible way to represent a traffic light, what happens when you assign <code>3</code> to <code>trafficLightColor</code>? This will cause problems as <code>3</code> does not represent a valid traffic light color. So, it would be better if you could limit the possible values of <code>trafficLightColor</code> to the colors it can display.</p>
			<p>Here's what an enumeration declaration looks like:</p>
			<pre>enum EnumName {
   case value1 
   case value2 
   case value3
}</pre>
			<p>Every enumeration has a descriptive name, and the body contains the associated values for that enumeration.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">To learn more <a id="_idIndexMarker242"/>about enumerations, visit <a href="https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html">https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html</a>.</p>
			<p>Let's look at how to work with enumerations. You'll learn how to create and manipulate them. You'll start<a id="_idIndexMarker243"/> by creating one to represent a traffic light color in the next section.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor121"/>Creating an enumeration</h2>
			<p>Let's create an <a id="_idIndexMarker244"/>enumeration to represent a traffic light. Follow these steps:</p>
			<ol>
				<li value="1">Add the following code to your playground and run it:<pre>enum TrafficLightColor {
   case red 
   case yellow 
   case green
}
var trafficLightColor = TrafficLightColor.red</pre><p>This creates an enumeration named <code>TrafficLightColor</code>, which groups together the red, yellow, and green values. As you can see, the value for the <code>trafficLightColor</code> variable is limited to red, yellow, and green; setting any other value will generate an error. </p></li>
				<li>Just like classes and structures, enumerations can contain methods. Let's add a method to <code>TrafficLightColor</code>. Modify your code as shown to make <code>TrafficLightColor</code> return a string representing the traffic light color and run it:<pre>enum TrafficLightColor {
   case red 
   case yellow 
   case green
<strong class="bold">   func description() -&gt; String {</strong>
<strong class="bold">      switch self {</strong>
<strong class="bold">      case .red:</strong>
<strong class="bold">         return "red" </strong>
<strong class="bold">      case .yellow:</strong>
<strong class="bold">         return "yellow" </strong>
<strong class="bold">      default:</strong>
<strong class="bold">         return "green"</strong>
<strong class="bold">      }</strong>
<strong class="bold">   }</strong>
}
var trafficLightColor = TrafficLightColor.red
<strong class="bold">print(trafficLightColor.description())</strong></pre></li>
			</ol>
			<p>The <code>description()</code> method returns a string depending on <code>trafficLightColor</code>'s value. Since <code>trafficLightColor</code>'s value is <code>TrafficLightColor.red</code>, <code>red</code> will appear in the Debug area.</p>
			<p>You've learned<a id="_idIndexMarker245"/> how to create and use enumerations to store grouped values, and how to add methods to them. This concludes this chapter. Good job!</p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor122"/>Summary</h1>
			<p>In this chapter, you learned how to declare complex objects using a class, create instances of a class, create a subclass, and override a class method. You've also learned how to declare a structure, create instances of a structure, and understand the difference between reference and value types. Finally, you learned how to use enumerations to represent a specific set of values.</p>
			<p>You now know how to use classes and structures to represent complex objects, and how to use enumerations to group related values together in your own programs.</p>
			<p>In the next chapter, you will study how to specify common traits in classes and structures using protocols, extend the capability of built-in classes using extensions, and handle errors in your programs.</p>
		</div>
	</body></html>