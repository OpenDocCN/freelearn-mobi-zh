- en: '*Chapter 1*: Getting Started with Kotlin'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bulk of this chapter will be dedicated to basic Kotlin syntax. It is important
    to be comfortable with a language before we start implementing any design patterns
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also briefly discuss what problems design patterns solve and why you should
    use them in Kotlin. This will be helpful to those who are less familiar with the
    concept of design patterns. But even for experienced engineers, it may provide
    an interesting perspective.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter doesn't aim to cover the entire language vocabulary but to get
    you familiar with some basic concepts and idioms. The following chapters will
    expose you to even more language features as they become relevant to the design
    patterns that we'll discuss.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic language syntax and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Kotlin code structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type system and `null` safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing Kotlin data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with text and loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extension functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have a knowledge of Kotlin's basics, which
    will be the foundation for the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the instructions in this chapter, you''ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA Community Edition ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenJDK 11 or higher ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter01).
  prefs: []
  type: TYPE_NORMAL
- en: Basic language syntax and features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you come from **Java**, **C#**, **Scala**, or any other statically typed
    programming language, you'll find Kotlin syntax quite familiar. This is not by
    coincidence but to make the transition to this new language as smooth as possible
    for those with previous experience in other languages. Besides that familiarity,
    Kotlin brings a vast amount of features, such as better type safety. As we move
    ahead, you'll notice that all of them are attempting to solve real-world problems.
    That pragmatic approach is remarkably consistent across the language. For example,
    one of the strongest benefits of Kotlin is complete Java interoperability. You
    can have Java and Kotlin classes alongside each other and freely use any library
    that is available in Java for a Kotlin project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the goals of the language are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pragmatic**: Makes things we do often easy to achieve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readable**: Keeps a balance between conciseness and clarity on what the code
    does'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to reuse**: Supports adapting code to different situations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safe**: Makes it hard to write code that crashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interoperable**: Allows the use of existing libraries and frameworks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will discuss how these goals are achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-paradigm language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the major paradigms in programming languages are procedural, object-oriented,
    and functional paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Being pragmatic, Kotlin allows for any of these paradigms. It has classes and
    inheritance, coming from the object-oriented approach. It has higher-order functions
    from functional programming. You don't have to wrap everything in classes if you
    don't want to, though. Kotlin allows you to structure your entire code as just
    a set of procedures and structs if you need to. You will see how all these approaches
    come together, as different examples will combine different paradigms to solve
    the problems discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of covering all aspects of a topic from start to finish, we will be
    building the knowledge as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Kotlin code structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you'll need to do when you start programming in Kotlin is to
    create a new file. Kotlin's file extension is usually `.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Java, there's no strong relationship between the filename and class name.
    You can put as many public classes in your file as you want, as long as the classes
    are related to one another and your file doesn't grow too long to read.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a convention, if your file contains a single class, name your file the same
    as your class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your file contains more than one class, then the filename should describe
    the common purpose of those classes. Use Camel case when naming your files, as
    per the Kotlin coding conventions: [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The main file in your Kotlin project should usually be named `Main.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **package** is a collection of files and classes that all share a similar
    purpose or domain. Packages are a convenient way to have all your classes and
    functions under the same namespace, and often in the same folder. That's the reason
    Kotlin, similar to many other languages, uses the notion of a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package that the file belongs to is declared using a `package` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Similar to placing classes in files, you can put any package in any directory
    or file, but if you're mixing Java and Kotlin, Kotlin files should follow Java
    package rules, as given at [https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html).
  prefs: []
  type: TYPE_NORMAL
- en: In purely Kotlin projects, common package prefixes can be omitted from the folder
    structure. For example, if all your projects are under the `me.soshin` package,
    and part of your application deals with mortgages, you can place your files directly
    in the `/mortgages` folder and not in the `/me/soshin/mortgages` folder like Java
    requires.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to declare a package for your `Main.kt` file.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Going forward, we will be documenting parts of the code using `//` for a single-line
    comment and `/* */` for multiline comments.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are a useful way to provide more context both to other developers and
    to your future self. Now, let's write our first Kotlin program and discuss how
    Kotlin's guiding principles are applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: Hello Kotlin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's no book dedicated to a programming language that can avoid the ubiquitous
    *Hello World* example. We're certainly not going to challenge that honored tradition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin learning how Kotlin works, let''s put the following code in our `Main.kt`
    file and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When your run this example, for example by pressing the **Run** button in your
    IntelliJ IDEA, it simply outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some interesting attributes in that piece of code in comparison to
    the following Java code that does exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's focus on those attributes in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: No wrapping class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java, C#, Scala, and many other languages, it's necessary to wrap every function
    in a class for it to become executable.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin, though, has the concept of **package-level functions**. If your function
    doesn't need to access properties of a class, you don't need to wrap it in a class.
    It's as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss package-level functions in more detail in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: From here on, we'll use ellipsis notation (*three dots*) to indicate that some
    parts of the code were omitted to focus on the important bits. You can always
    find the full code examples at the GitHub link for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: No arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arguments, supplied as an array of strings, are a way to configure your command-line
    application. In Java, you cannot have a runnable `main()` function that doesn''t
    take this array of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: But in Kotlin, those are entirely optional.
  prefs: []
  type: TYPE_NORMAL
- en: No static modifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some languages use the `static` keyword to indicate that a function in a class
    can be executed without the need to instantiate the class. The `main()` function
    is one such example.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, there's no such limitation. If your function doesn't have any state,
    you can place it outside of a class, and there is no `static` keyword in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: A less verbose print function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of the verbose `System.out.println` method that outputs a string to
    the standard output, Kotlin provides us with an alias called `println()` that
    does exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: No semicolons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java, and many other languages, every statement or expression must be terminated
    with a semicolon, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin is a pragmatic language. So, instead, it infers during compilation where
    it should put the semicolons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, you won't need to put semicolons in your code. They're considered
    optional.
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent example of how pragmatic and concise Kotlin is. It sheds
    lots of fluff and lets you focus on what's important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don''t have to write your code in a file for simple snippets. You can also
    play with the language online: try [https://play.kotlinlang.org/](https://play.kotlinlang.org/)
    or use a REPL and an interactive shell after installing Kotlin and running `kotlinc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we said that Kotlin is a type-safe language. Let's examine the Kotlin
    type system and compare it to what Java provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: The Java examples are for familiarity and not to prove that Kotlin is superior
    to Java in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Basic types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some languages make a distinction between primitive types and objects. Taking
    Java as an example, there is the `int` type and `Integer` – the former being more
    memory-efficient and the latter more expressive by supporting a lack of value
    and having methods.
  prefs: []
  type: TYPE_NORMAL
- en: There is no such distinction in Kotlin. From a developer's perspective, all
    the types are the same.
  prefs: []
  type: TYPE_NORMAL
- en: But it doesn't mean that Kotlin is less efficient than Java in that aspect.
    The Kotlin compiler optimizes types. So, you don't need to worry about it much.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the Kotlin types are named similarly to Java, the exceptions being Java's
    `Integer` being called `Int` and Java's void being called `Unit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t make much sense to list all the types, but here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 1.1 - Kotlin types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17816_01_Table01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1.1 - Kotlin types
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s declare our first Kotlin variable by extracting the string from our
    `Hello Kotlin` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that nowhere in our code is it stated that `greeting` is of the `String`
    type. Instead, the compiler decides what type of variable should be used. Unlike
    interpreted languages, such as JavaScript, Python, or Ruby, the type of variable
    is defined only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, this will produce an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to define the type of variable explicitly, you may use the following
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, variables can be declared `final`. Final variables can be assigned
    only once and their reference is effectively immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin urges us to use immutable data as much as possible. Immutable variables
    in Kotlin are called `val` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Values are preferable over variables. Immutable data is easier to reason about,
    especially when writing concurrent code. We'll touch more on that in [*Chapter
    5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison and equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We were taught very early in Java that comparing objects using `==` won't produce
    the expected results, since it tests for reference equality – whether two pointers
    are the same, and not whether two objects are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, in Java, we use `equals()` for objects and `==` to compare only primitives,
    which may cause some confusion.
  prefs: []
  type: TYPE_NORMAL
- en: 'JVM does integer caching and string interning to prevent that in some basic
    cases, so for the sake of the example, we''ll use a large integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior is far from intuitive. Instead, Kotlin translates `==` to `equals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do want to check for reference equality, use `===`. This won''t work
    for some of the basic types, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll discuss referential equality more when we learn how to instantiate classes.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, every method must be wrapped by a class or interface, even if it doesn't
    rely on any information from it. You're probably familiar with many `Util` classes
    in Java that only have static methods, and their only purpose is to satisfy the
    language requirements and bundle those methods together.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already mentioned earlier that in Kotlin, a function can be declared outside
    of a class. We''ve seen it with the `main()` function. The keyword to declare
    a function is `fun`. The argument type comes after the argument name, and not
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to return a result, its type will come after the function declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try this out yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If the function doesn't return anything, the return type can be omitted completely.
    There's no need to declare it as `void`, or its Kotlin counterpart, `Unit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a function is very short and consists of just a single expression, such
    as our `getGreeting()` function, we can remove the return type and the curly brackets,
    and use a shorter notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, the Kotlin compiler will infer that we're returning a `String` type.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some scripting languages, the order in which functions are declared is
    not important. Your `main` function will have access to all the other functions
    in its scope, even if those are declared after it in the code file.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other topics regarding function declarations, such as named arguments,
    default parameters, and variable numbers of arguments. We'll introduce them in
    the following chapters with relevant examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Many examples in this book assume that the code we provide is wrapped in the
    `main` function. If you don't see a signature of the function, it probably should
    be part of the `main` function. As an alternative, you can also run the examples
    in an IntelliJ scratch file.
  prefs: []
  type: TYPE_NORMAL
- en: Null safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most notorious exception in the Java world is `NullPointerException`.
    The reason behind this exception is that every object in Java can be `null`. The
    code here shows us why this is a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not like Java didn''t attempt to solve that problem, though. Since `Optional`
    construct that represents a value that may not be there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But it doesn''t solve our problem. If our function receives `Optional` as an
    argument, we can still pass it a `null` value and crash the program at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin checks for nulls during compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `printLength()` function written in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this function with `null` won''t compile at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specifically want your type to be able to receive nulls, you''ll need
    to mark it as nullable using the question mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There are multiple techniques in Kotlin for dealing with nulls, such as smart
    casts, the Elvis operator, and so on. We'll discuss alternatives to nulls in [*Chapter
    4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting Familiar with Behavioral
    Patterns*. Let's now move on to data structures in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Kotlin data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three important groups of data structures we should get familiar
    with in Kotlin: lists, sets, and maps. We''ll cover each briefly, then discuss
    some other topics related to data structures, such as mutability and tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `listOf()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Note that we didn't specify the type of the list. The reason is that the type
    inference can also be used when constructing collections in Kotlin, the same as
    when initializing variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to provide the type of the list, you similarly do that for defining
    arguments for a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To access an element in the list at a particular index, we use square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will output this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **set** represents a collection of unique elements. Looking for the presence
    of an element in a set is much faster than looking it up in a list. But, unlike
    lists, sets don't provide indexes access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a set of football World Cup champions until after 1994:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that each country exists in a set exactly once. To check whether
    an element is in a `Set` collection, you can use the `in` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that although sets, in general, do not guarantee the order of elements,
    the current implementation of a `setOf()` function returns `LinkedHashSet`, which
    preserves insertion order – `France` appears first in the output, since it was
    the first country in the input.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `to`. In fact, this is not a real keyword but a special function. We'll learn
    about it more in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing
    Functional Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, let''s create a map of some of the Batman movies and the actors
    that played Bruce Wayne in them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a value by its key, we use square brackets and provide the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will output this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Those data structures also support checking that an element doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Mutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the data structures we have discussed so far are immutable or, more correctly,
    read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no methods to add new elements to a list we create with the `listOf()`
    function, and we also cannot replace any element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Immutable data structures are great for writing concurrent code. But, sometimes,
    we still need a collection we can modify. In order to do that, we can use the
    mutable counterparts of the collection functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Editable collection types have functions such as `add()` that allow us to modify
    or, in other words, mutate them.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative implementations for collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have worked with JVM before, you may know that there are other implementations
    of sets and maps. For example, `TreeMap` stores the keys in a sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can instantiate them in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note that the names of the *Three Little Pigs* are ordered alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one other data structure we should cover in this section – `String[]`,
    while a list of strings is declared as `List<String>`. An element in a Java array
    is accessed using square brackets, while an element in a list is accessed using
    the `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To get the number of elements in an array in Java, we use the `length()` method,
    and to do the same with a collection, we use the `size()` method. This is part
    of Java's legacy and its attempts to resemble C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, array syntax is consistent with other types of collections. An array
    of strings is declared as `Array<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This is the first time we see angle brackets in Kotlin code. Similar to Java
    or TypeScript, the type between them is called **type argument**. It indicates
    that this array contains strings. We'll discuss this topic in detail in [*Chapter
    4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting Familiar with Behavioral
    Patterns*, while covering generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you already have a collection and would like to convert it into an array,
    use the `toTypedArray` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: In terms of its abilities, a Kotlin array is very similar to a list. For example,
    to get the number of elements in a Kotlin array, we use the same `size` property
    as other collections.
  prefs: []
  type: TYPE_NORMAL
- en: '*When would you need to use arrays then?* One example is accepting arguments
    in the `main` function. Previously, we''ve seen only main functions without arguments,
    but sometimes you want to pass them from a command line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a `main` function that accepts arguments from a command
    line and prints all of them, separated by commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Other cases include invoking Java functions that expect arrays or using `varargs`
    syntax, which we will discuss in [*Chapter 3*](B17816_03_ePub.xhtml#_idTextAnchor080),
    *Understanding Structural Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: As we are now familiar with some basic data structures, it's time to discuss
    how we can apply logic to them using `if` and `when` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You could say that the control flow is the bread and butter of writing programs.
    We'll start with two conditional expressions, `if` and `when`.
  prefs: []
  type: TYPE_NORMAL
- en: The if expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, `if` is a statement. Statements do not return any value. Let''s look
    at the following function, which returns one of two possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: While this example is easy to follow, in general, having multiple `return` statements
    is considered bad practice because they often make the code harder to comprehend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could rewrite this method using Java''s `var` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a single `return` statement, but we had to introduce a mutable
    variable. Again, with such a simple example, this is not an issue. But, in general,
    you should try to avoid mutable shared state as much as possible, since such code
    is not thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why are we having problems writing that in the first place, though?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to Java, in Kotlin, `if` is an expression, meaning it returns a value.
    We could rewrite the previous function in Kotlin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we could use a shorter form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Due to the fact that `if` is an expression, we didn't need to introduce any
    local variables.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we're again making use of single-expression functions and type inference.
    The important part is that `if` returns a value of the `String` type. There's
    no need for multiple return statements or mutable variables whatsoever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-line functions in Kotlin are very cool and pragmatic, but you should
    make sure that somebody else other than you understands what they do. Use with
    care.
  prefs: []
  type: TYPE_NORMAL
- en: The when expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*What if (no pun intended) we want to have more conditions in our* `if` *statement?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we use the `switch` statement. In Kotlin, there''s a `when` expression,
    which is a lot more powerful, since it can embed some other Kotlin features. Let''s
    create a method that''s given a superhero and tells us who their archenemy is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The `when` expression is very powerful. In the next chapters, we will elaborate
    on how we can combine it with ranges, `enums`, and `sealed` classes as well.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, use `when` if you have more than two conditions. Use `if`
    for simple cases.
  prefs: []
  type: TYPE_NORMAL
- en: Working with text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen many examples of working with text in the previous section.
    After all, it's not possible to print `Hello Kotlin` without using a string, or
    at least it would be very awkward and inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll discuss some of the more advanced features that allow
    you to manipulate text efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: String interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume now we would like to actually print the results from the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: First, as you may have already noticed, in one of the previous examples, Kotlin
    provides a nifty `println()` standard function that wraps the bulkier `System.out.println`
    command from Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, more importantly, as in many other modern languages, Kotlin supports string
    interpolation using the `${}` syntax. Let''s take the example from before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code would print as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you're interpolating a value of a function, you need to wrap it
    in curly braces. If it's a variable, curly braces could be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin supports multiline strings, also known as **raw strings**. This feature
    exists in many modern languages, and was brought to **Java 15** as **text blocks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is quite simple. If we want to print a piece of text that spans multiple
    lines, let''s say something from *Alice''s Adventures in Wonderland* by Lewis
    Carroll, one way is to concatenate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: While this approach certainly works, it's quite cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we could define the same string literal using triple quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: This is a much cleaner way to achieve the same goal. If you execute this example,
    you may be surprised that the poem is not indented correctly. The reason is that
    multiline strings preserve whitespace characters, such as tabs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the results correctly, we need to add a `trimIndent()` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiline strings also have another benefit – there''s no need to escape quotes
    in them. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the quote characters that are part of the text had to be escaped
    using the backslash character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the same text using multiline syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Note that there's no need for escape characters anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's discuss another typical control structure – a **loop**. Loops are
    a very natural construct for most developers. Without loops, it would be tough
    to repeat the same code block more than once (although we will discuss how to
    do that without loops in later chapters).
  prefs: []
  type: TYPE_NORMAL
- en: for-each loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Probably the most helpful type of a loop in Kotlin is a `for`-`each` loop.
    This loop can iterate over strings, data structures, and basically everything
    that has an iterator. We''ll learn more about iterators in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115),
    *Getting Familiar with Behavioral Patterns*, so for now, let''s demonstrate their
    use on a simple string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for`-`each` loop works on all the types of data structures we already
    discussed as well, that is, lists, sets, and maps. Let''s take a list as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: You'll see this loop many more times in this book, as it's very useful.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While in some languages `for`-`each` and `for` loops are two completely different
    constructs, in Kotlin a `for` loop is simply a `for`-`each` loop over a range.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand it better, let''s look at a `for` loop that prints all the single-digit
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: This doesn't look anything like a Java `for` loop and may remind you more of
    Python. The two dots are called a **range operator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this code, you will notice that this loop is inclusive. It prints
    all the numbers, including `9`. This is similar to the following Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want your range to be exclusive and not to include the last element,
    you can use the `until` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to print the numbers in reverse order, you can use the `downTo`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: It may seem confusing that `until` and `downTo` are called functions, although
    they look more like operators. This is another interesting Kotlin feature called
    **infix call**, which will be discussed later.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are no changes to the `while` loop functionality compared to some other
    languages, so we''ll cover them very briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print numbers from `1` to `10`. Note that we are forced to define
    `x` as `var`. The lesser-used `do while` loop is also present in the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Most probably, you won't be using the `while` loop and especially the `do while`
    loop much in Kotlin. In the following chapters, we'll discuss much more idiomatic
    ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Kotlin is a multi-paradigm language, it has a strong affinity to the
    Java programming language, which is based on classes. Keeping Java and JVM interoperability
    in mind, it's no wonder that Kotlin also has the notion of classes and classical
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll cover the syntax for declaring classes, interfaces, abstract
    classes, and data classes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `class` keyword, exactly like Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s imagine we''re building a video game. We can define a class to represent
    the player as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The instantiation of a class simply looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Note that there's no `new` keyword in Kotlin. The Kotlin compiler knows that
    we want to create a new instance of that class by the **round brackets** after
    the class name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the class has no body, as in this simple example, we can omit the curly
    braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Classes without any functions or properties aren't particularly useful, but
    we'll explore in [*Chapter 4*](B17816_04_ePub.xhtml#_idTextAnchor115), *Getting
    Familiar with Behavioral Patterns*, why this syntax exists and how it is consistent
    with other language features.
  prefs: []
  type: TYPE_NORMAL
- en: Primary constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be useful for the player to be able to specify their name during creation.
    In order to do that, let''s add a primary constructor to our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this declaration won''t work anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we''ll have to provide a name for every new player we instantiate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: We'll return to constructors soon enough. But for now, let's discuss properties.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java, we are used to the concept of getters and setters. If we were to write
    a class representing a player in a game in Kotlin using Java idioms, it may have
    looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: If we want to get a player's name, we invoke the `getName()` method. If we want
    to change a player's name, we invoke the `setName()` method. That's quite simple
    to follow but very verbose.
  prefs: []
  type: TYPE_NORMAL
- en: It is the first time we see the `this` keyword in Kotlin, so let's quickly explain
    what it means. Similar to many other languages, `this` holds the reference to
    the current object of that class. In our case, it points to the instance of a
    `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why don''t we write our classes like that, though?*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Seems like this approach has lots of benefits. It is much less verbose for sure.
    Reading a person's name is now much shorter – `player.name`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, changing the name is much more intuitive – `player.name = "Alex";`.
  prefs: []
  type: TYPE_NORMAL
- en: But by doing so, we lost a lot of control over our object. We cannot make `Player`
    immutable, for example. If we want everybody to be able to read the player's name,
    they'll also be able to change it at any point in time. This is a significant
    problem if we want to change that code later. With a setter, we can control that,
    but not with a public field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin properties provide a solution for all those problems. Let''s look at
    the following class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is almost the same as the example from the *Primary constructor*
    section, but now `name` has a `val` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: This may look the same as the `PublicPerson` Java example, with all its problems.
    But actually, this implementation is similar to `ImmutablePerson`, with all its
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: '*How is that possible?* Behind the scenes, Kotlin will generate a member and
    a getter with the same name for our convenience. We can set the property value
    in the constructor and then access it using its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to change the name of our `Player` will result in an error, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we defined this property as a value, it is read-only. To be able to change
    a property, we need to define it as mutable. Prefixing a constructor parameter
    with `var` will automatically generate both a getter and a setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t want the ability to provide the value at construction time, we
    can move the property inside the class body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Note that now we must also provide a default value for that property, since
    it cannot be simply `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom setters and getters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we can set a score now easily, its value may be invalid. Take the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have a mutable property with some validations, we need to define
    an explicit setter for it, using `set` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Here, `value` is the new value of the property and `field` is its current value.
    If our new value is negative, we decide to use a default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming from Java, you may be tempted to write the following code in your setter
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'But, in Kotlin, this will create an infinite recursion. You must remember that
    Kotlin generates a setter for mutable properties. So, the previous code will be
    translated to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: For that reason, we use the `field` identifier, which is provided automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar manner, we can declare a custom getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we save a value received as a constructor argument into a field with
    the same name. Then, we define a custom getter that will convert all characters
    in this property to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get this as our output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are probably already familiar with the concept of **interfaces** from other
    languages. But let's quickly recap.
  prefs: []
  type: TYPE_NORMAL
- en: In typed languages, interfaces provide a way to define behavior that some class
    will have to implement. The keyword to define an interface is simply `interface`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now define an interface for rolling a die:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: To implement the interface, a class specifies its name after a colon. There's
    no `implement` keyword in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: This is also the first time we see the `import` keyword. As the name implies,
    it allows us to import another package, such as `kotlin.random`, from the Kotlin
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interfaces in Kotlin also support default functions. If a function doesn''t
    rely on any state, such as this function that simply rolls a random number between
    `0` and `5`, we can move it into the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Abstract classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`interface`, an abstract class can contain state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an abstract class that is able to move our player on the board
    or, for the sake of simplicity, just store the new coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Any class that implements `Moveable` will inherit a `move()` function as well.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss in some more detail the `private` keyword you see here for
    the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We mentioned the `private` keyword earlier in this chapter but didn't have a
    chance to explain it. The `private` properties or functions are only accessible
    to the class that declared them – `Moveable`, in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The default visibility of classes and properties is public, so there is no need
    to use the `public` keyword all the time.
  prefs: []
  type: TYPE_NORMAL
- en: In order to extend an abstract class, we simply put its name after a colon.
    There's also no `extends` keyword in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '*How would you be able to differentiate between an abstract class and an interface,
    then?*'
  prefs: []
  type: TYPE_NORMAL
- en: An abstract class has round brackets after its name to indicate that it has
    a constructor. In the upcoming chapters, we'll see some uses of that syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from extending abstract classes, we can also extend regular classes as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to extend our `Player` class using the same syntax we used for an
    abstract class. We will attempt to create a `ConfusedPlayer` class, that is, a
    player that when given (*x* and *y*) moves to (*y* and *x*) instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s just create a class that inherits from `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the reason for round brackets even in abstract classes. This
    allows passing arguments to the parent class constructor. This is similar to using
    the `super` keyword in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Surprisingly, this doesn't compile. The reason for this is that all classes
    in Kotlin are final by default and cannot be inherited from.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow other classes to inherit from them, we need to declare them `open`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now try and override the `move` method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Overriding allows us to redefine the behavior of a function from a parent class.
    Whereas in Java, `@Override` is an optional annotation, in Kotlin `override` is
    a mandatory keyword. You cannot hide supertype methods, and code that doesn't
    use `override` explicitly won't compile.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other problems that we introduced in that piece of code. First,
    we cannot override a method that is not declared `open` as well. Second, we cannot
    modify the coordinates of our player from a child class since both coordinates
    are `private`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the `protected` visibility modifier the makes the properties accessible
    to child classes and mark the function as `open` to be able to override it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Now, both of the problems are fixed. You also see the `protected` keyword here
    for the first time. Similar to Java, this visibility modifier makes a property
    or a method visible only to the class itself and to its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that Kotlin is all about productiveness. One of the most common tasks
    for Java developers is to create yet another `equals` or `hashCode` methods. This
    task is so common that Kotlin has it built into the language. It's called a **data
    class**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: This will generate us a class with two getters and no setters (note the `val`
    part), which will also implement `equals`, `hashCode`, and `clone` functions in
    the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The introduction of `data` classes is one of the most significant improvements
    in reducing the amount of boilerplate in the Kotlin language. Just like the regular
    classes, `data` classes can have their own functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Compared to regular classes, the main limitation of `data` classes is that they
    are always `final`, meaning that no other class can inherit from them. But it's
    a small price to pay to have `equals` and `hashCode` functions generate automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin data classes versus Java records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Learning from Kotlin, Java 15 introduced the notion of `record`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Both syntaxes are pretty concise. *Are there any differences, though?*
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin `data` classes a have `copy()` function that records lack. We'll cover
    it in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062), *Working with Creational
    Patterns*, while discussing the **prototype** design pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a record, all properties must be `final`, or, in Kotlin terms, records support
    only values and not variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `data` classes can inherit from other classes, while records don't allow
    that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To summarize, `data` classes are superior to records in many ways. But both
    are great features of the respective languages. And since Kotlin is built with
    interoperability in mind, you can also easily mark a `data` class as a record
    to be accessible from Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Extension functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last feature we'll cover in this chapter before moving on is `final`. For
    example, you would like to have a string that has the `hidePassword()` function
    from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to achieve that is to declare a class that wraps the string for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: This solution is quite wasteful, though. It adds another level of indirection.
  prefs: []
  type: TYPE_NORMAL
- en: In Kotlin, there's a better way to implement this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extend a class without inheriting from it, we can prefix the function name
    with the name of the class we''d like to extend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: This looks almost like a regular top-level function declaration, but with one
    crucial change – before the function name comes a class name. That class is called
    a **method receiver**.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function body, `this` will refer to any `String` class that the function
    was invoked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s declare a regular string and try to invoke this new function on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '*What black magic is this?* We managed to add a function to a `final` class,
    something that technically should be impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is another feature of the Kotlin compiler, one among many. This extension
    function will be compiled to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: You can see that, in fact, this is a regular top-level function. Its first argument
    is an instance of the class that we extend. This also might remind you of how
    methods on structs in **Go** work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that prints the masked password will be adapted accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: For that reason, the extension functions cannot override the member function
    of the class, or access its `private` or `protected` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are a bit more familiar with basic Kotlin syntax, we can move on
    to discuss what design patterns are all about.
  prefs: []
  type: TYPE_NORMAL
- en: What are design patterns?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different misconceptions surrounding design patterns. In general,
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns are just missing language features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns are not necessary in a dynamic language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns are only relevant to object-oriented languages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns are only used in enterprises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, design patterns are just a proven way to solve a common problem. As
    a concept, they are not limited to a specific programming language (Java), nor
    to a family of languages (the C family, for example), nor are they limited to
    programming in general. You may have even heard of design patterns in software
    architecture, which discuss how different systems can efficiently communicate
    with each other. There are service-oriented architectural patterns, which you
    may know as **Service-Oriented Architecture** (**SOA**), and microservice design
    patterns that evolved from SOA and emerged over the past few years. The future
    will, for sure, bring us even more design pattern families.
  prefs: []
  type: TYPE_NORMAL
- en: Even in the physical world, outside software development, we're surrounded by
    design patterns and commonly accepted solutions to a particular problem. Let's
    look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns in real life
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Did you ride an elevator lately? Was there a mirror on the wall of the elevator?
    Why is that? How did you feel when you last rode an elevator that had no mirror
    and no glass walls?*'
  prefs: []
  type: TYPE_NORMAL
- en: The main reason we commonly have mirrors in our elevators is to solve a frequent
    problem – riding in an elevator is boring. We could put in a picture. But a picture
    would also get boring after a while, if you rode the same elevator at least twice
    a day. Cheap, but not much of an improvement.
  prefs: []
  type: TYPE_NORMAL
- en: We could put in a TV screen, as some do. But it makes the elevator more expensive.
    And it also requires a lot of maintenance. We need to put some content on the
    screen to make it not too repetitive. So, either there's a person whose responsibility
    is to renew the content once in a while or a third-party company that does it
    for us. We'll also have to handle different problems that may occur with screen
    hardware and the software behind it. Seeing the *blue screen of death* is amusing,
    of course, but only mildly.
  prefs: []
  type: TYPE_NORMAL
- en: Some architects even go for putting elevator shafts on the building exterior
    and making part of the walls transparent. This may provide some exciting views.
    But this solution also requires maintenance (dirty windows don't make for the
    best view) and a lot of architectural planning.
  prefs: []
  type: TYPE_NORMAL
- en: So, we put in a mirror. You get to watch an attractive person even if you ride
    alone. Some studies indicate that we find ourselves more attractive than we are,
    anyway. Maybe you get a chance to review your appearances one last time before
    that important meeting. Mirrors visually expand the visual space and make the
    entire trip less claustrophobic or less awkward if it's the start of a day and
    the elevator is really crowded.
  prefs: []
  type: TYPE_NORMAL
- en: Design process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try and understand what we did just now.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't invent mirrors in elevators. We've seen them thousands of times. But
    we formalized the problem (riding in an elevator is boring) and discussed alternative
    solutions (TV screens and glass walls) and the benefits of the commonly used solution
    (solves the problem and is easy to implement). That's what design patterns are
    all about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic steps of the design process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define exactly what the current problem is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider different alternatives, based on the pros and cons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the solution that solves the problem while best fitting your specific
    constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why use design patterns in Kotlin?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kotlin comes to solve the real-world problems of today. In the following chapters,
    we will discuss both the *design patterns* first introduced by the *Gang of Four*
    back in 1994, as well as design patterns that emerged from the functional programming
    paradigm and the design patterns that we use to handle concurrency in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: You'll find that some of the design patterns are so common or useful that they're
    already built into the language as reserved keywords or standard functions. Some
    of them will need to combine a set of language features. And some are not so useful
    anymore, since the world has moved forward, and other patterns are replacing them.
  prefs: []
  type: TYPE_NORMAL
- en: But in any case, familiarity with design patterns and best practices expands
    your *developer toolbox* and creates a shared vocabulary between you and your
    colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered the main goals of the Kotlin programming language.
    We learned how variables are declared, the basic types, `null` safety, and type
    inference. We observed how program flow is controlled by commands such as `if`,
    `when`, `for`, and `while`, and we also took a look at the different keywords
    used to define classes and interfaces: class, interface, `data` class, and `abstract`
    class. We learned how to construct new classes and how to implement interfaces
    and inherit from other classes. Finally, we covered what design patterns are suitable
    for and why we need them in Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should be able to write simple programs in Kotlin that are pragmatic
    and type-safe. There are many more aspects of the language we need to discuss.
    We'll cover them in later chapters once we need to apply them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss the first of the three design pattern families
    – creation patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the difference between `var` and `val` in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you extend a class in Kotlin?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you add functionality to a `final` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
