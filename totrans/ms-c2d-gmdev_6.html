<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Tidying Up and Polishing</h1></div></div></div><p>Polishing is the most important thing you'll learn in this entire book. If you can master the art of <a id="id342" class="indexterm"/>making your game polished, it doesn't matter how simple or complex it is; you'll have a great game. And yes, even though you may be a great programmer who hasn't had a bug in your program in years, or an artist who makes people faint when they see your character designs, you still need to polish you game. It's absolutely necessary for any modern game to be a solid experience for the player.</p><p>In this chapter, you'll learn what it takes to clean up the game, smooth out the rough edges, and turn that game with cool mechanics into a fun, playable, and unforgettable experience. But it's not just about making it look good. It needs to feel good, and the entire user experience needs to be joyful. In no particular order, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem">Button press visual</li><li class="listitem">Pulse on unit combine</li><li class="listitem">A tutorial</li><li class="listitem">Sharing over Facebook and Twitter (and more)</li><li class="listitem">Sound on/off</li><li class="listitem">Game Center leaderboards</li><li class="listitem">Slide transitions</li></ul></div><p>Obviously, you don't have to do all of these, but if you want more people to play your game, chances are that they're more likely to play it if it's polished. Now, the biggest thing when it comes to polishing is the graphical and sound styles. They need to be consistent throughout, as well as visually appealing so that the user doesn't get confused or put off when they play your game.</p><p>That being said, if you open the <code class="literal">Chapter 6</code> project, you'll see that the game's graphics and fonts have been updated. It looks and feels pretty solid. The only thing left to do is what's being covered in this chapter (as you just saw in the list). So let's get to it.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Button press visuals</h1></div></div></div><p>Yeah, button<a id="id343" class="indexterm"/> press visuals are great! Cocos2d is nice enough to provide a darkening of the button when we touch it, but let's add a bit more animation to our buttons to give them more of that "clicked" feeling.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec97"/>Modifying the CCButton class</h2></div></div></div><p>If we<a id="id344" class="indexterm"/> just wanted an individual button to have a specific effect, we would modify just that single button in the place where it exists. However, we want the same button effect across all buttons in our game, so we need to open <code class="literal">CCButton.m</code> file. The easiest way to do that is to search for <code class="literal">CCButton</code> in the project and click on any of the links to <code class="literal">CCButton.m</code>.</p><p>Here, you're going to add two functions near the top of the file: <code class="literal">scaleButtonUp</code> and <code class="literal">scaleButtonDown</code>. Both of them run actions on the button, and these actions give it a bouncy press effect found in many games:</p><div><h3 class="title"><a id="tip48"/>Tip</h3><p>Alternatively, you can extend/subclass <code class="literal">CCButton</code> and override the methods necessary to create the desired effect. This method is also slightly more stable in the case of a Cocos2d version update that changes the default code of <code class="literal">CCButton</code>. But for now, we'll just modify the existing <code class="literal">CCButton</code> code.</p></div><div><pre class="programlisting">@implementation CCButton

//add this one...
-(void)scaleButtonDown
{
  [self stopAllActions];
  
  id scaleDown = [CCActionEaseInOut actionWithAction:[CCActionScaleTo actionWithDuration:0.11f scale:0.8f] rate:2];
  id scaleBackUp = [CCActionEaseInOut actionWithAction:[CCActionScaleTo actionWithDuration:0.13f scale:0.9f] rate:2];
  id actionSequence = [CCActionSequence actions:scaleDown, scaleBackUp, nil];
  [self runAction:actionSequence];
}

//and this one...
-(void)scaleButtonUp
{
  [self stopAllActions];
  
  id scaleDown = [CCActionEaseInOut actionWithAction: [CCActionScaleTo actionWithDuration:0.11f scale:1.15f] rate:1.5f];
  id scaleBackUp = [CCActionEaseInOut actionWithAction: [CCActionScaleTo actionWithDuration:0.13f scale:1.0f] rate:2];
  id actionSequence = [CCActionSequence actions:scaleDown, scaleBackUp, nil];
  [self runAction:actionSequence];
}</pre></div><p>Then<a id="id345" class="indexterm"/> at the bottom of the <code class="literal">touchEntered</code> method, add the call to the <code class="literal">scaleButtonDown</code> method like so:</p><div><pre class="programlisting">- (void) touchEntered:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
   ...
  
  //add this:
  [self scaleButtonDown];
}</pre></div><p>Finally, in <code class="literal">touchExited</code> and <code class="literal">touchUpInside</code>, you have to add the call to the <code class="literal">scaleButtonUp</code> methods. This is meant for the following cases: either when the players, finger leaves the button (indicating that it won't be activated if they lift their finger), or when they actually "press" the button:</p><div><pre class="programlisting">- (void) touchExited:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
  self.highlighted = NO;
  
  //add this:
  [self scaleButtonUp];
}

- (void) touchUpInside:(CCTouch *)touch withEvent:(CCTouchEvent *)event
{
  ...

  //add this:
  [self scaleButtonUp];
}</pre></div><p>And that's it! It took a whole 2 minutes to add that extra bit of polishing to our buttons. It's not <a id="id346" class="indexterm"/>something that's going to sell the game on its own, but it's subtle enough to give your players a feeling like, "Wow, the developers really took the time to make this game right!"</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec44"/>Pulse on unit combine</h1></div></div></div><p>When<a id="id347" class="indexterm"/> our units combine, nothing special really happens. So, what we're going to do is add a slight pulse effect. Basically, when two units combine we want the unit to grow in a fashion similar to the button visual we just created (where it expands and then scales down again).</p><div><h3 class="title"><a id="tip49"/>Tip</h3><p>You can also do fancy things in general when the units spawn, such as particle effects (for example, a subtle explosion/burst effect), sprite animations, and other various things.</p><p>The key to polishing is thinking out of the box, yet looking at things you already have within the game to keep the aesthetic consistent and solid.</p></div><p>To carry out the pulsing we desire, since we'll most likely be placing the same code in multiple places, let's create a method that takes in a <code class="literal">CCNode</code> object and applies the effect we have in mind. So in <code class="literal">MainScene.m</code>, add the following method somewhere in the code (preferably near the combination code):</p><div><pre class="programlisting">-(void)pulseUnit:(CCNode*)unit
{
  CGFloat baseScale = 1.0f;
  if (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)
    baseScale = 0.8f;
  
  id scaleUp = [CCActionEaseInOut actionWithAction:[CCActionScaleTo actionWithDuration:0.15f scale:baseScale * 1.2f] rate:2];
  id scaleDown = [CCActionEaseInOut actionWithAction:[CCActionScaleTo actionWithDuration:0.15f scale:baseScale * 0.9f] rate:2];
  id scaleToFinal = [CCActionEaseInOut actionWithAction:[CCActionScaleTo actionWithDuration:0.25f scale:baseScale] rate:2];
  id seq = [CCActionSequence actions:scaleUp, scaleDown, scaleToFinal, nil];  

  [unit stopAllActions];
  [unit runAction:seq];
}</pre></div><p>This<a id="id348" class="indexterm"/> function takes into consideration the "original scale" of the unit, and then runs a two-action sequence of scaling up and then down. However, we want to make sure we stop all the current actions on the unit in the case of there being more than two units that combine (and we will subsequently call this function multiple times on the same unit).</p><p>Now that we have a function ready, let's add the calls to it in the four places where a unit is combined.</p><p>The first two places are in the <code class="literal">checkForCombineWithUnit</code> method (again, if you aren't using the <code class="literal">Chapter 6</code> code here, this method isn't implemented):</p><div><pre class="programlisting">-(void)checkForCombineWithUnit:(Unit*)first andUnit:(Unit*)other usingDeletionArray:(NSMutableArray*)array
{
  ...
  
      if (ov &gt; fv)
      {
        ...
        
        [self pulseUnit:other];
      }
      else
      {
        ...
        
        [self pulseUnit:first];
      }
  ...
}</pre></div><p>The last two places are in the <code class="literal">checkForAnyDirectionCombine</code> method:</p><div><pre class="programlisting">–(void)checkForAnyDirectionCombineWithUnit:(Unit*)first andUnit:(Unit*)other usingDeletionArray:(NSMutableArray*)array
{
  ...

    if (ov &gt; fv)
    {
      ...
      
      [self pulseUnit:other];
    }
    else
    {
      ...

      
      [self pulseUnit:first];
    }
}
}</pre></div><p>And<a id="id349" class="indexterm"/> that's it! Run the game and combine two units, and you'll see the pulsing effect. Again, it's subtle, but that's exactly what we need—many subtle changes that add up to a lot over time.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec45"/>Tutorial</h1></div></div></div><p>We're at<a id="id350" class="indexterm"/> the point where we need to teach our players how to play our game. Although you might have been able to explain the game to your testers when you were standing over their shoulders, you won't be able to do that for those who download the app from the App Store. Thus, we're in need of a tutorial, and a quick one because we want our players playing the game, not the tutorial.</p><p>For this project, we're going to have a simple tutorial that basically explains the main concepts of the game through only a few words and some images:</p><div><ul class="itemizedlist"><li class="listitem">Players sliding units with their fingers</li><li class="listitem">Combining their own units</li><li class="listitem">Defeating enemy units</li><li class="listitem">Protecting the central square</li></ul></div><p>Obviously, we are able to go a lot more in depth by explaining a few more of the subtle concepts, but instead, we're giving the player room to learn, experiment, and test things for themselves. We just want the tutorial to set them up so that they don't get frustrated when they either don't know what to do when the game starts, or lose and don't know why they lost.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec98"/>Tutorial phase variable and the NSUserDefaults key</h2></div></div></div><p>We want <a id="id351" class="indexterm"/>to know at what point in the tutorial our user is. So, we<a id="id352" class="indexterm"/> need to know what set of text and options to display. For example, if we create a tutorial that uses multiple scenes, we wouldn't have needed a variable, as the scene would have indicated which tutorial we were on. However, because we're doing everything within the <code class="literal">MainScene</code> (and because we want to smoothly transition into a regular game after the tutorial is over), it's best to use a variable to track how far we've gone.</p><p>So (since we'll want to access the variable in a later portion), let's create an <code class="literal">@property</code> variable in <code class="literal">MainScene.h</code>, like this:</p><div><pre class="programlisting">}
+(CCScene*)scene;

...

//here:
@property (nonatomic, assign) NSInteger tutorialPhase; 
@end</pre></div><p>If it's a good tutorial, the user learns the first time they're going through it, so it's a good assumption to set a "did they finish it?" variable to true after they've gone through all the steps. This means that we want to record in a variable whether or not they've finished the tutorial before, so we're going to use <code class="literal">NSUserDefaults</code> again. Let's define another key so that we can eliminate human errors as well as increase code readability. In <code class="literal">MainScene.h</code>, declare the following key with the rest at the top of the file:</p><div><pre class="programlisting">FOUNDATION_EXPORT NSString *const KeyFinishedTutorial;</pre></div><p>In <code class="literal">MainScene.m</code>, define the key at the top, with something like the following:</p><div><pre class="programlisting">NSString *const KeyFinishedTutorial = @"keyFinishedTutorial";</pre></div><p>Finally, we want to determine whether or not to show the tutorial. Since we have this key storing the determining factor, we can simply read that from <code class="literal">NSUserDefaults</code> and either run the game as normal or begin the tutorial in phase 1.</p><p>So in <code class="literal">MainScene.m</code>, at the bottom of your <code class="literal">init</code> method, modify the <code class="literal">spawnNewEnemy</code> call to the following:</p><div><pre class="programlisting">if ([[NSUserDefaults standardUserDefaults] boolForKey:KeyFinishedTutorial])
{
  [self spawnNewEnemy:[self getRandomEnemy]];
  self.tutorialPhase = 0;
}
else
{
  //spawn enemy on far right with value of 1
  Unit *newEnemy = [Unit enemyUnitWithNumber:1 atGridPosition:ccp(9, 5)];
  newEnemy.position = [MainScene getPositionForGridCoord: newEnemy.gridPos];
  [newEnemy setDirection:DirLeft];
  [self spawnNewEnemy:newEnemy];
  self.tutorialPhase = 1;
      
  [self showTutorialInstructions];
}</pre></div><p>Also, to <a id="id353" class="indexterm"/>eliminate errors and set ourselves up for easier coding<a id="id354" class="indexterm"/> later, we define the <code class="literal">showTutorialInstructions</code> object (the empty body is okay for now; we'll cover that next):</p><div><pre class="programlisting">-(void)showTutorialInstructions
{
}</pre></div><p>In the preceding if-else statement, you see the tutorialPhase being set to either 0 (not going through the tutorial this time) or 1 (begin the tutorial at phase 1), based on whether they've finished the tutorial or not. If they haven't, it will also spawn a new enemy at the far right with a value of 1.</p><p>That's the beginning of our tutorial—setting up the necessary structure. Next, we're going to tackle actually displaying some text, depending on what phase of the tutorial we're in.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec99"/>Displaying text for each phase (and CCSprite9Slice)</h2></div></div></div><p>Each<a id="id355" class="indexterm"/> tutorial phase needs to have its own text. To do that, we'll just reference the tutorial phase variable and assign the text to a label based on what phase we're in. That said, in the <code class="literal">showTutorialInstructions</code> method that we just created, we add the following lines to display our initial phase 1 text:</p><div><pre class="programlisting">NSString *tutString = @"";
if (self.tutorialPhase == 1)
{
tutString = @"Drag Friendly Units";
}
  
CCLabelBMFont *lblTutorialText = [CCLabelBMFont labelWithString:tutString fntFile:@"bmScoreFont.fnt"];
lblTutorialText.color = [CCColor colorWithRed:52/255.f green:73/255.f blue:94/255.f];
lblTutorialText.position = [MainScene getPositionForGridCoord:ccp(5,2)];
lblTutorialText.name = @"tutorialText";
[self addChild:lblTutorialText z:2];
CCSprite9Slice *background = [CCSprite9Slice spriteWithSpriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"imgUnit.png"]];
background.margin = 0.2;
background.position = ccp(0.5,0.4);
background.positionType = CCPositionTypeNormalized;
background.contentSize = CGSizeMake(1.05f, 1.2f);
background.contentSizeType = CCSizeTypeNormalized;
[lblTutorialText addChild:background z:-1];</pre></div><p>Run<a id="id356" class="indexterm"/> the project. You'll see the text spanning across the top center of the grid. But code-wise, there's a lot going on in the block we just added, so let's quickly go over the new stuff.</p><p>First, we're naming (a tag property in previous versions, but it's now a string) the label so that we can access the <code class="literal">CCNode</code> by searching for it later using the <code class="literal">getChildByName</code> function. Next, we're positioning the label at <code class="literal">z:2</code>, so we're ensuring that it's above everything else (the default is <code class="literal">z:0</code>, and at most, we have our units at <code class="literal">z:1</code>, so <code class="literal">z:2</code>, should be good).</p><p>There's also the <code class="literal">CCSprite9Slice</code> object, which is most likely new to you. If you've never heard of a 9-slice (or 9-patch) sprite before, refer to the following diagram to learn about it:</p><div><img src="img/image00266.jpeg" alt="Displaying text for each phase (and CCSprite9Slice)"/></div><p style="clear:both; height: 1em;"> </p><p>In<a id="id357" class="indexterm"/> short, the central section can scale in any direction, the corners do not scale, the top and bottom margins scale horizontally, and the left and right margins scale vertically.</p><p>You'll require the 9-slice sprite only when you want the margins to scale. In any other situation, it's better to use a regular <code class="literal">CCSprite</code>.</p><p>Since we want to keep our art style consistent, we can use <code class="literal">Unit.pn</code>g as our 9-slice sprite, along with a 20 percent margin (the rest is whitespace anyways, so this is a good number to go with). Then we'll position it behind the label (using <code class="literal">z:-1</code>) and set the content size to slightly larger than the width and height of the label.</p><div><h3 class="title"><a id="tip50"/>Tip</h3><p>When using <code class="literal">CCSprite9Slice</code>, if you want to change the <code class="literal">scale</code> of the button, you must change its <code class="literal">contentSize</code> value, <em>not</em> the scale property.</p><p>Also, the margin value (or values) can only go up to a maximum of 0.5 (which means 50 percent of the image in any direction).</p></div><p>Now we're actually going to take the tutorial to the next phase.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec100"/>Advancing the tutorial</h2></div></div></div><p>Just the<a id="id358" class="indexterm"/> fact that we have text displayed doesn't mean we have something impressive, as it's not really a tutorial up to this point. We need to implement the advanced portion. So, create a function called <code class="literal">advanceTutorial</code> as well as <code class="literal">removePreviousTutorialPhase</code> (which will be used to get rid of the previous phases' text) and edit them like this:</p><div><pre class="programlisting">-(void)advanceTutorial
{
  ++self.tutorialPhase;
  [self removePreviousTutorialPhase];

  if (self.tutorialPhase&lt;7)
  {
    [self showTutorialInstructions];
  }
  else
  {
    //the tutorial should be marked as "visible"
    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:KeyFinishedTutorial];
    [[NSUserDefaults standardUserDefaults] synchronize];
  }
}
-(void)removePreviousTutorialPhase
{
}</pre></div><p>Essentially, we're saying that if we advance to the next tutorial phase, and the phase is less than 7, we just show the next tutorial's instructions. Otherwise, we simply set the <code class="literal">didFinishTutorial</code> Boolean to <code class="literal">true</code>.</p><p>Finally, we should include the proper text for each phase so that when we start advancing the tutorial phase, we can actually see the progress. So, in the <code class="literal">showTutorialInstructions</code> function, modify the <code class="literal">if</code> statement to look like the following (which also creates and displays a <strong>How to Play</strong> label for the first phase):</p><div><pre class="programlisting">if (self.tutorialPhase == 1)
{
  tutString = @"Drag Friendly Units";
    
  CCLabelBMFont *lblHowToPlay = [CCLabelBMFont labelWithString:@"How to Play:" fntFile:@"bmScoreFont.fnt"];
  lblHowToPlay.color = [CCColor colorWithRed:52/255.f green:73/255.f blue:94/255.f];
  lblHowToPlay.position = [MainScene getPositionForGridCoord:ccp(5,1)];
  lblHowToPlay.name = @"lblHowToPlay";
  lblHowToPlay.scale = 0.8;
  [self addChild:lblHowToPlay z:2];
    
  CCSprite9Slice *bgHowTo = [CCSprite9Slice spriteWithSpriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"imgUnit.png"]];
  bgHowTo.margin = 0.2;
  bgHowTo.position = ccp(0.5,0.4);
  bgHowTo.positionType = CCPositionTypeNormalized;
  bgHowTo.contentSize = CGSizeMake(1.05f, 1.2f);
  bgHowTo.contentSizeType = CCSizeTypeNormalized;
  [lblHowToPlay addChild:bgHowTo z:-1];
}
else if (self.tutorialPhase == 2)
{
  tutString = @"Combine Friendly Units";
  
  id fadeRemoveHowToPlay = [CCActionSequence actions:[CCActionEaseInOut actionWithAction:[CCActionFadeOut actionWithDuration:0.5f] rate:2], [CCActionCallBlock actionWithBlock:^{
    [self removeChildByName:@"lblHowToPlay"];
  }], nil];
    
  [[self getChildByName:@"lblHowToPlay" recursively:NO] runAction:fadeRemoveHowToPlay];

}
else if (self.tutorialPhase == 3)
{
  tutString = @"Defeat Enemies";
}
else if (self.tutorialPhase == 4)
{
  tutString = @"Protect Center";
}
else if (self.tutorialPhase == 5)
{
  tutString = @"Survive";
}
else if (self.tutorialPhase == 6)
{
  tutString = @"Enjoy! :)";
}</pre></div><div><h3 class="title"><a id="tip51"/>Tip</h3><p>Note that the preceding code can also be written in the form of switch-case statements.</p></div><p>So <a id="id359" class="indexterm"/>that's it! Let's actually take our tutorial ahead so that we can see our progress in action as we walk through each phase.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec101"/>Advancing in all the right places</h2></div></div></div><p>Since<a id="id360" class="indexterm"/> we have all the functions laid out, all we need to do is call the <code class="literal">advanceTutorial</code> function when we want the next phase to begin.</p><p>The first phase will advance once we've moved the unit for the first time, so in the <code class="literal">moveUnit</code> function, add the following to the bottom:</p><div><pre class="programlisting">if (self.tutorialPhase == 1 || self.tutorialPhase == 2)
  [self advanceTutorial];</pre></div><p>And hey! While we're at it, we might as well include phase 2, right? After all, we're just sliding once in both phases.</p><p>Phase 3 will end when the enemy coming in from the right is destroyed, so in the <code class="literal">handleCollisionWithFriendly</code> function, you need to add the following method call within the if statement shown here. Phase 4 will also end when a unit gets destroyed, so we'll go ahead and include it as well:</p><div><pre class="programlisting">if (enemy.unitValue&lt;= 0)
{
  [arrEnemies removeObject:enemy];
  [selfremoveChild:enemy];
  ++numUnitsKilled;
  
  if (self.tutorialPhase == 3 || self.tutorialPhase == 4)
[selfadvanceTutorial];
}</pre></div><p>Next is going to be when tutorial phase 5 ends, which is after the user wants to make their move but before any unit movements have been calculated. The same applies to phase 6, so <a id="id361" class="indexterm"/>add the following call to the <code class="literal">advanceTutorial</code> function at the top of the <code class="literal">moveUnit</code> function. This is because we don't want to accidentally advance the tutorial twice (which is what would happen if we add it at the bottom):</p><div><pre class="programlisting">if (self.tutorialPhase == 5 || self.tutorialPhase == 6)
  [self advanceTutorial];</pre></div><p>But hold on for a second! We want to ensure the same experience for every person in the tutorial. So, just like the way we created a custom unit at the beginning of the scene in the <code class="literal">init</code> method, we're going to create a custom unit in the <code class="literal">moveUnit</code> function. In your <code class="literal">moveUnit</code> function, modify this <code class="literal">if</code> statement to create a custom unit when you're in the corresponding tutorial phase:</p><div><pre class="programlisting">if (numTurnSurvived % 3 == 0 || [arrEnemiescount] == 0)
{
  if (self.tutorialPhase == 4)
  {
    Unit *newEnemy = [Unit enemyUnitWithNumber:4 atGridPosition:ccp(5,9)];
    [newEnemy setDirection:DirUp];
    newEnemy.position = [MainScene getPositionForGridCoord:ccp(5,9)];
    [self spawnNewEnemy:newEnemy];
  }
  else
  {
    [self spawnNewEnemy:[self getRandomEnemy]];
  }
}</pre></div><p>Alright! With this in place, we should have a pretty solid tutorial, but it's still kind of clunky, and we can definitely use some polish (coincidentally, that's the chapter we're in). So, let's continue to make it the best tutorial that it can be.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec102"/>Removing the previous phases' text</h2></div></div></div><p>Right<a id="id362" class="indexterm"/> now, the old text is just piling up, so let's clear that up. In the <code class="literal">removePreviousTutorialPhase</code> function, add the following block. It will grab the text, rename it (so that there are no naming conflicts by accident), quickly fade out the text, and remove it:</p><div><pre class="programlisting">-(void)removePreviousTutorialPhase
{
  CCLabelBMFont *lblInstructions = (CCLabelBMFont*)[self getChildByName:@"tutorialText" recursively:NO];
  lblInstructions.name = @"old_instructions";
  
  id fadeRemoveInstructions = [CCActionSequence actions:[CCActionEaseInOut actionWithAction:[CCActionFadeTo actionWithDuration:0.5f opacity:0] rate:2], [CCActionCallBlock actionWithBlock:^{
    [self removeChild:lblInstructions];
  }], nil];
  
  [lblInstructions runAction:fadeRemoveInstructions];
}</pre></div><p>There <a id="id363" class="indexterm"/>we go! But it still needs more polish. Let's add some graphical elements to our tutorial to better explain what we want the user to do.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec103"/>Fingers pointing the way</h2></div></div></div><p>Text is <a id="id364" class="indexterm"/>great, but what about those who can't read English? Or what about those who don't understand what we mean by <strong>Drag Friendly Units</strong>? It's best to have an image to show what we mean. In this case, we're going to use a small hand with the index finger pointing to show a drag motion in the intended direction.</p><p>Here's what we're going to add. Notice the finger (which is being moved to the right and fading at the same time), as well as the text above it, which we added in the previous section, as shown in this screenshot:</p><div><img src="img/image00267.jpeg" alt="Fingers pointing the way"/></div><p style="clear:both; height: 1em;"> </p><p>In our <code class="literal">showTutorialInstructions</code> method, we want to create a finger that will guide the user<a id="id365" class="indexterm"/> in the right direction. So, at the bottom of your <code class="literal">showTutorialInstructions</code> method, add the following block of code to create a finger and position it so that it points to the center of the middle square:</p><div><pre class="programlisting">CCSprite *finger = [CCSprite spriteWithSpriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"imgFinger.png"]];
finger.anchorPoint = ccp(0.4,1);
finger.position = [MainScene getPositionForGridCoord:ccp(5,5)];
finger.name = @"finger";
finger.opacity = 0;
[self addChild:finger z:2];</pre></div><p>Notice how we've named the finger and positioned it at <code class="literal">z:2</code> (for consistency with the rest of our tutorial).</p><p>The next step is to animate our finger in the direction in which we want our users to slide their units. So, right after you've added the finger to the scene, make a call to the following function:</p><div><pre class="programlisting">... 
  [self addChild:finger z:2];
  
  [self runFingerArrowActionsWithFinger:finger];
}

-(void)runFingerArrowActionsWithFinger:(CCSprite*)finger
{
}</pre></div><p>Here, we<a id="id366" class="indexterm"/> just passed the finger variable directly to the function (as searching for a child with a matching name takes up more processing time). Now, all we need to do with our finger image is the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Fade the finger in</li><li class="listitem">Slide it to the right</li><li class="listitem">Fade it out while it is sliding to the right</li><li class="listitem">Wait a bit</li><li class="listitem">Reposition the finger</li><li class="listitem">Repeat</li></ol><div></div><p>This seems fairly simple, right? It is, except when we want to sequence all of these events. In that case, the code looks fairly convoluted. This is what we want the function to look like:</p><div><pre class="programlisting">-(void)runFingerArrowActionsWithFinger:(CCSprite*)finger
{
  Unit *u = [Unit friendlyUnit];
  if (self.tutorialPhase == 1 || self.tutorialPhase == 3)
  {
    id slideRight = [CCActionSequence actions:[CCActionEaseIn actionWithAction:[CCActionFadeIn actionWithDuration:0.25f] rate:2], [CCActionEaseInOut actionWithAction:[CCActionMoveBy actionWithDuration:1.0f position:ccp(u.gridWidth*2, 0)] rate:2],[CCActionDelay actionWithDuration:0.5f], nil];
    
    id fadeOutAndReposition = [CCActionSequence actions:[CCActionDelay actionWithDuration:0.25f], [CCActionEaseInOut actionWithAction:[CCActionFadeOut actionWithDuration:1.0f] rate:2], [CCActionDelay actionWithDuration:0.5f], [CCActionCallBlock actionWithBlock:^{
      finger.position = [MainScene getPositionForGridCoord:ccp(5,5)];
    }], nil];
    
    [finger runAction:[CCActionRepeatForever actionWithAction:slideRight]];
    [finger runAction:[CCActionRepeatForever actionWithAction:fadeOutAndReposition]];


  }  
  else if (self.tutorialPhase == 2)
  {

    finger.position = [MainScene getPositionForGridCoord:ccp(6,5)];
    id slideLeft = [CCActionSequence actions:[CCActionEaseIn actionWithAction:[CCActionFadeIn actionWithDuration:0.25f] rate:2], [CCActionEaseInOut actionWithAction:[CCActionMoveBy actionWithDuration:1.0f position:ccp(-u.gridWidth*2, 0)] rate:2],[CCActionDelay actionWithDuration:0.5f], nil];
    
    id fadeOutAndReposition = [CCActionSequence actions:[CCActionDelay actionWithDuration:0.25f], [CCActionEaseInOut actionWithAction:[CCActionFadeOut actionWithDuration:1.0f] rate:2], [CCActionDelay actionWithDuration:0.5f], [CCActionCallBlock actionWithBlock:^{
      finger.position = [MainScene getPositionForGridCoord:ccp(6,5)];
    }], nil];
    
    [finger runAction:[CCActionRepeatForever actionWithAction:slideLeft]];
    [finger runAction:[CCActionRepeatForever actionWithAction:fadeOutAndReposition]];

  }
}</pre></div><p>Essentially, the <a id="id367" class="indexterm"/>finger is going to fade in, slide to the right (while it's fading out), then get repositioned, and repeat these actions indefinitely in phase 1 and phase 3 of the tutorial (the opposite direction for phase 2).</p><p>Sadly, we're not done with coding for the entirety of the finger. We must still remove it once we wish to advance to the next phase, remember?</p><p>Therefore, in <code class="literal">removePreviousTutorialPhase</code>, we're just going to add a very similar removal style to the label, the only difference being that we'll apply it to the finger (and this time, we<a id="id368" class="indexterm"/> need to use the search function of <code class="literal">getChildByName</code>, as this function gets called at an undetermined time):</p><div><pre class="programlisting">CCSprite *finger = (CCSprite*)[self getChildByName:@"finger" recursively:NO];
finger.name = @"old_finger";
id fadeRemoveFinger = [CCActionSequence actions:[CCActionEaseInOut actionWithAction:[CCActionFadeTo actionWithDuration:0.5f opacity:0] rate:2], [CCActionCallBlock actionWithBlock:^{
  [self removeChild:finger];
}], nil];
[finger runAction:fadeRemoveFinger];</pre></div><p>And that's it for the finger! We've got ourselves a finger sliding in the direction we want, including a nice fade in/out. We also have the text displaying and getting removed, advancing text, and so on. The only thing left to do is to make sure our users are allowed to move their units only in the direction we want them to.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec104"/>Rejecting non-tutorial movement</h2></div></div></div><p>Our<a id="id369" class="indexterm"/> tutorial works as intended only when they move in a specific order. So, we need to restrict their initial movements when going through the tutorial.</p><p>In <code class="literal">Unit.m</code>, in the <code class="literal">touchMoved</code> function, we want to make sure that the unit can only begin to be dragged when they're going in the correct direction in the first three phases. So add the following if statement to the <code class="literal">touchMoved</code> function (when the distance is less than <code class="literal">20</code>):</p><div><pre class="programlisting">if (!self.isBeingDragged &amp;&amp; ccpDistance(touchPos, self.touchDownPos) &gt;20)
{
  ...
    
    if (
  (((MainScene*)self.parent).tutorialPhase == 1 &amp;&amp; self.dragDirection != DirRight) ||
  (((MainScene*)self.parent).tutorialPhase == 2 &amp;&amp; (self.dragDirection != DirLeft || self.unitValue == 1)) ||
  (((MainScene*)self.parent).tutorialPhase == 3 &amp;&amp; self.dragDirection != DirRight))
    {
      self.isBeingDragged = NO;
      self.dragDirection = DirStanding;
    }
}</pre></div><p>This is why we created the <code class="literal">tutorialPhase</code> object as a property—so that we can access the phase from within another class. But what's going on here is essentially a check of the tutorial <a id="id370" class="indexterm"/>phase, and if it's any one of phase 1, 2, or 3, it does another check to see whether <code class="literal">dragDirection</code> is indicating the correct way. There's a second check that's done for phase 2, as it's not allowed to be the unit with a value of 1.</p><p>If any of this comes out to true, we set <code class="literal">isBeingDragged</code> to <code class="literal">NO</code> and the drag direction to standing (so that no unexpected behavior happens in phase 2).</p><p>That's it for the tutorial! It took a while, but it's not only simple and quick; it's also fairly comprehensive, while not affecting the experience of the game.</p><p>Then, once our tutorial ends, it seamlessly flows into a regular game from that point. The other advantage is as follows: suppose players lose, don't finish, or hit menu or restart; or the phone dies at some point during the tutorial. When they come back, the tutorial will simply start from the beginning, which is good and intentional.</p><div><h3 class="title"><a id="tip52"/>Tip</h3><p>The key takeaway from the tutorial is to keep it short, save when they've completed it, and test all possible "dumb" ways a user could try to mess up the tutorial (hence the last part, about rejecting wrong movements).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Sharing on Facebook and Twitter (and more)</h1></div></div></div><p>Sharing <a id="id371" class="indexterm"/>games on social media is very common these <a id="id372" class="indexterm"/>days. Our game will not be an exception to that. It's not only an effective marketing tool for your game, as users promote the game for you on their social media pages, but also a great way for engagement to rise, as humans love competition. Being able to share and compare their scores (and indirectly compete) makes users want to play the game even more, which makes it a win-win situation for both the developers and players.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec105"/>Using the built-in share feature</h2></div></div></div><p>The <a id="id373" class="indexterm"/>easiest way to integrate Facebook, Twitter, messaging, e-mail, and other sharing options is through the <code class="literal">UIActivityView</code> object. It's the same sharing you'll see when you press the button in the bottom-left corner of the photos app.</p><p>Basically, all we need to do is tell the <code class="literal">ActivityView</code> object what we want to display and what activity types we want to exclude, and then present the view controller over the <code class="literal">CCDelegate</code>.</p><p>First, we need to create the <strong>Share</strong> button.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec106"/>Creating the Share button</h2></div></div></div><p>In <code class="literal">GameOverScene.m</code>, add the following block of code to the <code class="literal">initWithScoreData</code> method. This <a id="id374" class="indexterm"/>will create a <strong>Share</strong> button at the bottom center of our game over screen:</p><div><pre class="programlisting">//add share buttons
CCButton *btnShare = [CCButton buttonWithTitle:@"" spriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"btnShare.png"]];

[btnShare setTarget:self selector:@selector(openShareView)];
btnShare.position = ccp(winSize.width/2, winSize.height * 0.1);
[self addChild:btnShare];</pre></div><p>Then, create the method that the share button will call when it is pressed (this must be added now, or else the game will crash when you reach <code class="literal">GameOverScene</code>):</p><div><pre class="programlisting">-(void)openShareView
{

}</pre></div><p>Run the game, and when you get to the game over screen, you'll see the share button in the bottom center. Right now, it doesn't do anything, so let's display the activity view.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec107"/>Creating a variable for the current score</h2></div></div></div><p>We<a id="id375" class="indexterm"/> need a way to track the player's current score and the score of the most recent play. Even though we can pass that information to the game over scene, unless we store that value in an instance variable, we won't be able to use it in our sharing.</p><p>So, in <code class="literal">GameOverScene.h</code>, add a variable for the current score, like this:</p><div><pre class="programlisting">@interface GameOverScene : CCScene &lt;CCTableViewDataSource&gt;
{
  CGSize winSize;
  NSArray *arrScores;
  NSInteger highScoreIndex;
  
  //add this:
  NSInteger numCurrentScore;
}</pre></div><p>Then, in <a id="id376" class="indexterm"/>the <code class="literal">initWithScoreData</code> method, we add the following line so that we can grab the total score that was passed to the scene:</p><div><pre class="programlisting">numCurrentScore = [dict[DictTotalScore] integerValue];</pre></div><p>Now we're ready to actually use the score in the text that we share.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec108"/>Creating the UIActivityView object</h2></div></div></div><p>In <a id="id377" class="indexterm"/>the <code class="literal">openShareView</code> method you just created, add these few lines of code (explanation afterwards):</p><div><pre class="programlisting">NSString *textToShare = [NSString stringWithFormat:@"I scored %d in MathGame! See if you can beat me!",numCurrentScore];

NSString *appID = @"123456789"; //change to YOUR app's ID
NSURL *appStoreURL = [NSURL URLWithString:[NSString stringWithFormat:@"https://itunes.apple.com/app/id%@", appID]];

NSArray *objectsToShare = @[textToShare, appStoreURL];

UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:objectsToShare applicationActivities:nil];</pre></div><p>First comes the text that we're going to display. We need to keep it short for a few reasons. The most important reason is that Twitter allows only 140 characters, so we need to make sure we don't cross that. The second reason is that our potential future players might not read it if it's longer than a sentence or two. Finally, we want the <em>generic message</em> that's going to be sent to at least feel personal. It has to be like reading a conversation between two best friends.</p><p>Next is the link to the App Store, which also takes in the app's ID. Notice the <code class="literal">appID</code> variable<a id="id378" class="indexterm"/> is just <code class="literal">1</code> through <code class="literal">9</code>. This isn't the exact app ID at the moment (not even for the book's project), so what we're going to do is modify this line of code when we create the app in iTunes Connect (or if you already have an app created, you can use that app ID now).</p><p>After that is the array of objects to be included in the share. Simply add them to an array.</p><p>Finally, we create the <code class="literal">UIActivityViewController</code> object with the <code class="literal">objectsToShare</code> array.</p><p>But it's not yet displaying anything, so let's handle that.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec109"/>Displaying UIActivityViewController</h2></div></div></div><p>After <a id="id379" class="indexterm"/>you've initialized the <code class="literal">activityVC</code> variable in the <code class="literal">openShareView</code> method, add the following block of code. It will ensure that the activity view doesn't show certain activities, and then present the view controller over the shared <code class="literal">CCDelegate</code>:</p><div><pre class="programlisting">NSArray *excludeActivities = @[UIActivityTypeAirDrop,
    UIActivityTypePrint,
    UIActivityTypeAssignToContact,
    UIActivityTypeSaveToCameraRoll,
    UIActivityTypeAddToReadingList,
    UIActivityTypePostToFlickr,
    UIActivityTypePostToVimeo];

activityVC.excludedActivityTypes = excludeActivities;

[[CCDirector sharedDirector] presentViewController:activityVC animated:YES completion:nil];</pre></div><p>Since we don't want the user to print anything, assign anything to a contact, or add it to their reading list (Flickr, Vimeo, and so on), we need to exclude these activities, which basically means they won't show up on the view that appears when the user taps the share button.</p><p>This is a list of all the possible <code class="literal">UIAcitivityTypes</code>:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">UIActivityTypeAddToReadingList;</code></li><li class="listitem"><code class="literal">UIActivityTypeAirDrop;</code></li><li class="listitem"><code class="literal">UIActivityTypeAssignToContact;</code></li><li class="listitem"><code class="literal">UIActivityTypeCopyToPasteboard;</code></li><li class="listitem"><code class="literal">UIActivityTypeMail;</code></li><li class="listitem"><code class="literal">UIActivityTypeMessage;</code></li><li class="listitem"><code class="literal">UIActivityTypePostToFacebook;</code></li><li class="listitem"><code class="literal">UIActivityTypePostToFlickr;</code></li><li class="listitem"><code class="literal">UIActivityTypePostToTencentWeibo;</code></li><li class="listitem"><code class="literal">UIActivityTypePostToTwitter;</code></li><li class="listitem"><code class="literal">UIActivityTypePostToVimeo;</code></li><li class="listitem"><code class="literal">UIActivityTypePostToWeibo;</code></li><li class="listitem"><code class="literal">UIActivityTypePrint;</code></li><li class="listitem"><code class="literal">UIActivityTypeSaveToCameraRoll;</code></li></ul></div><p>So, for <a id="id380" class="indexterm"/>your own projects, feel free to include or exclude as many or as few of these as you wish. For example, if you're sharing a video, you can very easily allow Vimeo or saving the photos.</p><p>That's it! If you run the game at this point and click on the <strong>Share</strong> button, you'll see the activity view pop up, along with the various buttons for messaging, e-mail, Facebook, and Twitter. Clicking on any of these will load the respective view, along with the message and URL that was added.</p><div><h3 class="title"><a id="tip53"/>Tip</h3><p>When adding this to your own project, the key thing to note is the exclusion list.</p></div><p>Here's what the final version looks like:</p><div><img src="img/image00268.jpeg" alt="Displaying UIActivityViewController"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec110"/>Adding a screenshot to the share</h2></div></div></div><p>Even <a id="id381" class="indexterm"/>though we're adding some text and including a link to the game on the App Store, we should probably also include a screenshot because it's more likely someone will at least check out the game if there's a screenshot attached.</p><p>That being said, we don't really want a screenshot from the game over screen, so we'll have to grab a screenshot of the game right before we transition to <code class="literal">GameOverScene</code>.</p><p>So, open up <code class="literal">MainScene.m</code> and add the following method. It will take a screenshot of the game:</p><div><pre class="programlisting">-(UIImage*)screenshot
{
  [CCDirector sharedDirector].nextDeltaTimeZero = YES;
  
CCRenderTexture* rtx =
[CCRenderTexture renderTextureWithWidth:winSize.width
  height:winSize.height];
[rtx begin];
  [[[CCDirector sharedDirector] runningScene] visit];
[rtx end];
  
return [rtx getUIImage];
}</pre></div><p>Then, in <a id="id382" class="indexterm"/>the <code class="literal">endGame</code> method, let's call the preceding method and store it in a local variable so that we can pass it to the <code class="literal">GameOverScene</code> data:</p><div><pre class="programlisting">UIImage *image = [self takeScreenshot];
  
NSDictionary *scoreData = @{DictTotalScore : @(numTotalScore),
    DictTurnsSurvived :@(numTurnSurvived),
    DictUnitsKilled :@(numUnitsKilled),
    DictHighScoreIndex :@(hsIndex),  
    @"screenshot" : image};</pre></div><p>Notice the addition of the <code class="literal">@"screenshot"</code> key to the <code class="literal">scoreData</code> dictionary. This will pass our <code class="literal">UIImage</code> so that we can grab it in <code class="literal">GameOverScene</code>.</p><p>Next, in <code class="literal">GameOverScene.h</code>, add a variable for the screenshot, like this:</p><div><pre class="programlisting">@interface GameOverScene : CCScene &lt;CCTableViewDataSource&gt;
{
  CGSize winSize;
  NSArray *arrScores;
  NSInteger highScoreIndex;
  NSInteger numCurrentScore;
  
  //add this:
  UIImage *screenshot;
}</pre></div><p>Then in our <code class="literal">initWithScoreData</code> method in <code class="literal">GameOverScene.m</code>, we want to store the screenshot in the variable from the dictionary using the <code class="literal">@"screenshot"</code> key:</p><div><pre class="programlisting">screenshot = dict[@"screenshot"];</pre></div><p>Finally, in our <code class="literal">openShareView</code> method of the game over scene, all we need to do is add the screenshot variable to the <code class="literal">objectsToShare</code> array, and it will be automatically included:</p><div><pre class="programlisting">NSArray *objectsToShare = @[textToShare, myWebsite, screenshot];</pre></div><p>And that's it! By running the game now and getting to the share button, you'll see the image, whether you share via Facebook, Twitter, messages, or e-mail.</p><div><h3 class="title"><a id="tip54"/>Tip</h3><p>If you really want to get fancy, you can allow users to save the image just in case they want to keep it for their own records. To do that, just remove the <code class="literal">SaveToCameraRoll</code> option from the exclusion array in the <code class="literal">openShareView</code> method.</p></div><p>Here's what <a id="id383" class="indexterm"/>your game looks like with the screenshot added (sharing via Facebook):</p><div><img src="img/image00269.jpeg" alt="Adding a screenshot to the share"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>Turning sounds on and off</h1></div></div></div><p>Right <a id="id384" class="indexterm"/>now, we have sound effects and music playing all the time no<a id="id385" class="indexterm"/> matter what. Even though you might be someone who enjoys listening to sounds or music, when you design your games (as it's definitely an element that increases user engagement), you would want to be open to the fact that people just don't like to hear any sound at <a id="id386" class="indexterm"/>times. Thus, we must<a id="id387" class="indexterm"/> give them the option to turn the sound on and off.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec111"/>No options or settings? Main menu it is!</h2></div></div></div><p>Since<a id="id388" class="indexterm"/> we don't have a pause screen, options, settings, or anything similar, we're going to add the buttons to turn the sound on and off to the main menu. This means that a lot less code is required to add the buttons, instead of creating an entirely new scene exclusively for them. This arrangement also stays consistent with the clean feel of the game.</p><div><h3 class="title"><a id="tip55"/>Tip</h3><p>If you want to make a pause screen and add these two buttons to it, then go ahead by all means. The code, however, will be slightly different from what will be described here because if you push a <code class="literal">CCScene</code> instead of replace (which essentially allows you to pause the game while going to a new scene temporarily), and then pop off the scene that you pushed (in other words, resume the paused game), you need to make sure that the correct variables get set to false.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec112"/>Creating the buttons</h2></div></div></div><p>First, we're<a id="id389" class="indexterm"/> going to create the sound and music on/off buttons in the main menu. These are going to be a bit different from normal buttons because instead of just a normal button press, they're going to need to swap between the on and off states.</p><p>In <code class="literal">MenuScene.m</code>, let's create the initial buttons in the <code class="literal">init</code> method:</p><div><pre class="programlisting">if ((self=[super init]))
{
    
    //these values range 0 to 1.0, so use float to get ratio
    CCNode *background = [CCNodeColor nodeWithColor:[CCColor whiteColor]];
    [self addChild:background];
    
    winSize = [CCDirector sharedDirector].viewSize;
    CCButton *btnPlay = [CCButton buttonWithTitle:@"" spriteFrame:[CCSpriteFrame frameWithImageNamed: @"btnPlay.png"]];
    btnPlay.position = ccp(winSize.width/2, winSize.height * 0.5);
    [btnPlay setTarget:self selector:@selector(goToGame)];
    [self addChild:btnPlay];
    
    //add the sound and music buttons:
    
    CCButton *btnSound = [CCButton buttonWithTitle:@"" spriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"btnSoundOn.png"]];
    [btnSound setBackgroundSpriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName: @"btnSoundOff.png"] forState:CCControlStateSelected];
    btnSound.position = ccp(winSize.width * 0.35, winSize.height * 0.2);
    [btnSound setTogglesSelectedState:YES];
    [btnSound setTarget:self selector:@selector(soundToggle)];
    [self addChild:btnSound];
    
    CCButton *btnMusic = [CCButton buttonWithTitle:@"" spriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"btnMusicOn.png"]];
    [btnMusic setBackgroundSpriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"btnMusicOff.png"] forState:CCControlStateSelected];
    btnMusic.position = ccp(winSize.width * 0.65, winSize.height * 0.2);
    [btnMusic setTogglesSelectedState:YES];
    [btnMusic setTarget:self selector:@selector(musicToggle)];
    [self addChild:btnMusic];

  ...
}</pre></div><p>Then we<a id="id390" class="indexterm"/> need to make sure we create the methods that the buttons will be calling when they're pressed:</p><div><pre class="programlisting">-(void)soundToggle
{
  
}

-(void)musicToggle
{
  
}</pre></div><p>Running the game at this point will result in what is shown in the following screenshot. If you press <a id="id391" class="indexterm"/>either of the buttons, they will switch between each other, and if you exit and come back, the buttons will be reset to their original state.</p><div><img src="img/image00270.jpeg" alt="Creating the buttons"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec113"/>Creating the keys</h2></div></div></div><p>What we<a id="id392" class="indexterm"/> need to do to grab (and store) the sound and music variables is make use of <code class="literal">NSUserDefaults</code>, just as we did in the past. To remove any user error when coding, we want to define constants for our dictionary keys.</p><p>Since <code class="literal">MainScene</code> has been imported into all of our classes, we can safely define the constant there. So, open <code class="literal">MainScene.h</code> and add the following code to the top of the file, along with the other constants:</p><div><pre class="programlisting">FOUNDATION_EXPORT NSString *const KeySound;
FOUNDATION_EXPORT NSString *const KeyMusic;</pre></div><p>Then, in <code class="literal">MainScene.m</code>, add this code at the top of the file with the rest of the constants so that they are defined:</p><div><pre class="programlisting">NSString *const KeySound = @"keySound";
NSString *const KeyMusic = @"keyMusic";</pre></div><p>Now we're<a id="id393" class="indexterm"/> able to grab the data that's been stored as well as efficiently save any values if we need to.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec114"/>Grabbing the sound and music Boolean from NSUserDefaults</h2></div></div></div><p>We <a id="id394" class="indexterm"/>want to store the data in a variable so that we don't have to read and write again and again from <code class="literal">NSUserDefaults</code>, and can do so only when we really need to.</p><p>Therefore, in <code class="literal">MainScene.h</code>, add two Boolean variables for sound on/off and music on/off, like this:</p><div><pre class="programlisting">@interface MenuScene :CCNode
{
  CGSize winSize;
  BOOL isSoundOn, isMusicOn;
}</pre></div><p>Then, after you've added the buttons to the scene in the <code class="literal">init</code> method of <code class="literal">MainScene.m</code>, read the sound and music values from <code class="literal">NSUserDefaults</code> using the keys you just defined:</p><div><pre class="programlisting">isSoundOn = [[NSUserDefaults standardUserDefaults] boolForKey:KeySound];
isMusicOn = [[NSUserDefaults standardUserDefaults] boolForKey:KeyMusic];</pre></div><p>Now we want to actually tell the sound and music buttons whether or not they should show their <strong>X</strong> mark or check mark. To do so, we'll just set the selected value to whatever the opposite of the variable is. That's because if the sound is not on, we want to show the selected version:</p><div><pre class="programlisting">btnSound.selected= !isSoundOn;
btnMusic.selected= !isMusicOn;</pre></div><p>This works, but there's no way to test it, so let's actually modify the values when the respective buttons are pressed.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec115"/>Setting and saving the values</h2></div></div></div><p>In <a id="id395" class="indexterm"/>the <code class="literal">soundToggle</code> method, we're going to set the <code class="literal">isSoundOn</code> variable to<a id="id396" class="indexterm"/> the opposite of itself (toggle it on and off). Right after that, we're going to set (and save) its value to the key we defined earlier:</p><div><pre class="programlisting">-(void)soundToggle
{
  isSoundOn = !isSoundOn;
  [[NSUserDefaults standardUserDefaults] setBool:isSoundOn forKey:KeySound];
  [[NSUserDefaults standardUserDefaults] synchronize];
}</pre></div><p>Then we're <a id="id397" class="indexterm"/>going to do the same for the <code class="literal">isMusicOn</code> variable<a id="id398" class="indexterm"/> in the <code class="literal">musicToggle</code> method:</p><div><pre class="programlisting">-(void)musicToggle
{
  isMusicOn = !isMusicOn;
  [[NSUserDefaults standardUserDefaults] setBool:isMusicOn forKey:KeyMusic];
  [[NSUserDefaults standardUserDefaults] synchronize];
}</pre></div><p>If you run the game now, you'll be able to switch between the true/false variables of the sound and music, and when you either go to another scene and come back, or exit the game and come back, the values will be retained from whatever you last set them to. But it's still not pausing the music or turning off the sound, so let's fix that.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec116"/>Pausing/resuming background music and sound</h2></div></div></div><p>If <a id="id399" class="indexterm"/>the background music is playing when <a id="id400" class="indexterm"/>the music button is pressed, we'll need to pause it, and vice versa for when it's not playing.</p><p>To start, let's go to the <code class="literal">musicToggle</code> method and add a check for the <code class="literal">isMusicOn</code> variable. If it is enabled, we can play the background music. Otherwise, we'll just pause the music until the user turns it on again:</p><div><pre class="programlisting">isMusicOn ? [[OALSimpleAudio sharedInstance] playBg] : [[OALSimpleAudio sharedInstance] bgPaused];</pre></div><p>After that, we'll also add a check to see whether the <code class="literal">isSoundOn</code> is enabled. If it is, we'll play the <code class="literal">buttonClick</code> sound effect:</p><div><pre class="programlisting">if (isSoundOn)
[[OALSimpleAudio sharedInstance] playEffect:@"buttonClick.mp3"];</pre></div><p>We're going to do the same for the <code class="literal">toggleSound</code> method as well as the <code class="literal">goToGame</code> method, both of which are methods that get called when a button is pressed. Therefore, we are going to play a button click sound effect (only if the sound is enabled):</p><div><pre class="programlisting">-(void)goToGame
{
  if (isSoundOn)
    [[OALSimpleAudio sharedInstance] playEffect:@"buttonClick.mp3"];
  [[CCDirector sharedDirector] replaceScene:[MainScene scene]];
}

-(void)soundToggle
{
  ...
  
  if (isSoundOn)
    [[OALSimpleAudio sharedInstance] playEffect:@"buttonClick.mp3"];
}</pre></div><p>For <code class="literal">MenuScene</code>, all is done! If you press the music button and/or the sound button, you'll notice <a id="id401" class="indexterm"/>the effects turning on and off, just <a id="id402" class="indexterm"/>as intended. Now that we have handled <code class="literal">MenuScene</code>, let's go for every other location where we'll be playing the sound effects (and starting the music).</p><div><h3 class="title"><a id="tip56"/>Tip</h3><p>Alternatively, you can create a class that has methods for starting and stopping the background music, playing certain sound effects, and playing the button click, all using <code class="literal">OALSimpleAudio</code>.</p><p>Then you can locate and replace all the instances of <code class="literal">OALSimpleAudio</code> with your own custom class.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>Handling MainScene sound</h2></div></div></div><p>Since <a id="id403" class="indexterm"/>we have sound effects and music playing in just about every class of this game, we need to make sure they play only when the corresponding value is true.</p><p>So for starters, let's open <code class="literal">MainScene.h</code> and add a similar variable for a sound:</p><div><pre class="programlisting">@interface MainScene :CCScene
{
  BOOL isSoundOn;
}</pre></div><p>Next, in the <code class="literal">init</code> method, make sure you grab the values from <code class="literal">NSUserDefaults</code>:</p><div><h3 class="title"><a id="tip57"/>Tip</h3><p>Also <a id="id404" class="indexterm"/>make sure you set the <code class="literal">isSoundOn</code> variable in the <code class="literal">init</code> method before you attempt to play any sound effect. If you assign the value afterwards, you may experience unintended results.</p></div><div><pre class="programlisting">-(id)init
{
    if ((self=[super init]))
    {
      //used for positioning items on screen
      winSize = [[CCDirector sharedDirector] viewSize];
    isSoundOn = [[NSUserDefaults standardUserDefaults] boolForKey:KeySound];

    ...
}
return self;
return self;
}</pre></div><p>In <code class="literal">MainScene.m</code>, search for <code class="literal">OALSimpleAudio</code>, and go to every instance of it, adding the following <code class="literal">if</code> statement above it so that the sound effect plays only when that particular sound is enabled:</p><div><pre class="programlisting">if (isSoundOn)
  ...</pre></div><p>There should be two in <code class="literal">playUnitCombineSound</code>, one in <code class="literal">goToMenu</code>, one in <code class="literal">restartGame</code>, and one in <code class="literal">moveUnit</code>. Obviously, if you have more sound effects playing, then you should add them there as well, but these are the five that are present at this point.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>Repeating for GameOverScene (and any other scenes)</h2></div></div></div><p>It's <a id="id405" class="indexterm"/>basically the same as <code class="literal">MainScene</code>, so there won't be too much explanation. But all you really need to do is the following:</p><div><ul class="itemizedlist"><li class="listitem">Create the <code class="literal">isSoundOn</code> variable in <code class="literal">GameOverScene.h</code></li><li class="listitem">Assign the value in the <code class="literal">init</code> method from <code class="literal">NSUserDefaults</code></li><li class="listitem">Add the if statement before every sound effect that gets played</li><li class="listitem">Since this is your only other scene, move on to <code class="literal">AppDelegate</code></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>Handling AppDelegate music</h2></div></div></div><p>We<a id="id406" class="indexterm"/> need to make sure the music doesn't randomly start playing when users first load the game if they had decided to turn it off in a previous version.</p><p>So in <code class="literal">AppDelegate.m</code>, add the following if statement before the call to the <code class="literal">playBgWithLoop</code> method. Note that we don't need to store it in a variable because we're going to use it only once:</p><div><pre class="programlisting">if ([[NSUserDefaults standardUserDefaults] boolForKey:KeyMusic])
    [[OALSimpleAudiosharedInstance] playBgWithLoop:YES];</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec120"/>Making sure that sound/music starts enabled</h2></div></div></div><p>One<a id="id407" class="indexterm"/> of the things we want to make sure of is that the sound and music start as enabled when the user starts the game. By default, any Boolean in <code class="literal">NSUserDefaults</code> is false. Therefore, we need to make sure that both get set to true before the game starts, but only on the first time they run the game.</p><p>So in <code class="literal">AppDelegate.m</code>, at the very beginning of <code class="literal">startScene</code>, let's add code to check whether they've played before:</p><div><pre class="programlisting">- (CCScene*) startScene
{
  //if they have not played before (in other words, first time playing)
  if (![[NSUserDefaults standardUserDefaults] boolForKey:@"hasPlayedBefore"])
  {
    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:KeySound];
    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:KeyMusic];
    [[NSUserDefaults standardUserDefaults] setBool:YES forKey:@"hasPlayedBefore"];
    
    [[NSUserDefaults standardUserDefaults] synchronize];
  }
  
  ...
  
  return [MainScene scene];//[CCBReader loadAsScene:@"MainScene"];
}</pre></div><p>And that's it! It<a id="id408" class="indexterm"/> took a little bit of careful planning to make sure we handled every case that the user could run into, but that's the entire point of polishing your game—making sure that no matter what your user does or can do, the game responds appropriately and as intended.</p><div><h3 class="title"><a id="tip58"/>Tip</h3><p>The key takeaways from adding on/off settings for sound and music are as follows: storing the value in the <code class="literal">NSUserDefaults</code>, grabbing that value from a local variable in each scene, and using that variable to determine whether you should play a sound effect or not. If you want to be sure you've gotten all the instances, look up the project for <code class="literal">OALSimpleAudio</code> and go through all the classes you've created.</p><p>Make sure that you check for the variable for any future sound effects you add.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Game Center leaderboards</h1></div></div></div><p>We've <a id="id409" class="indexterm"/>already got a set of top 20 high scores that are stored on the user's device, so why not make a global leaderboard? In fact, even though many players don't use Game Center when they play games, it is yet another element that drives engagement. Plus (and this is the really cool part)—if you didn't know already—you can actually have players rate your game within Game Center. It's not even an extra feature or anything, as they can just tap the star count at the top of the leaderboard or achievement pane and it'll send the rating to the App Store.</p><p>Creating a leaderboard to display in our game isn't just about code, so we have to create the leaderboard in iTunes Connect first. Before we can create the app in iTunes Connect, we need to set up an App ID.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec121"/>Creating the App ID</h2></div></div></div><p>At this<a id="id410" class="indexterm"/> point, if you wish to add a leaderboard, you must sign up for an Apple developer account if you don't have one already. In <a class="link" title="Chapter 1. Refreshing Your Cocos2d Knowledge" href="part0014.xhtml">Chapter 1</a>, <em>Refreshing Our Cocos2d Knowledge,</em> the signup process was explained. Otherwise, if you're just following along for practice, feel free to do so, but you cannot create leaderboards or achievements without a developer account.</p><p>First, you need to create the App ID from the developer website. Go to <a class="ulink" href="https://developer.apple.com/devcenter/ios/index.action">https://developer.apple.com/devcenter/ios/index.action</a> and log in to your Apple account that has the iOS developer license on it.</p><p>Once logged in, under <strong>iOS Dev Center</strong>, go to the <strong>Certificates, Identifiers &amp; Profiles</strong> section, as shown in this screenshot:</p><div><img src="img/image00271.jpeg" alt="Creating the App ID"/></div><p style="clear:both; height: 1em;"> </p><p>From here, go to the <strong>Identifiers</strong> section so that we can create an App ID, as shown in the following screenshot:</p><div><img src="img/image00272.jpeg" alt="Creating the App ID"/></div><p style="clear:both; height: 1em;"> </p><p>Then begin<a id="id411" class="indexterm"/> to create an App ID by clicking on the <strong>+</strong> button in the top-right corner. Here, we need to enter a name for the App ID, the name of the bundle identifier (which is generally reverse DNS notation; for example, <a class="ulink" href="http://www.keitgames.com">www.keitgames.com</a> might have <code class="literal">com.keitgames.mygame</code> as the bundle ID), as well as any services we want (which we'll leave as the default for now). This is shown in the following screenshot for your reference:</p><div><img src="img/image00273.jpeg" alt="Creating the App ID"/></div><p style="clear:both; height: 1em;"> </p><p>Make<a id="id412" class="indexterm"/> sure you use your own bundle identifier (the preceding screenshot simply shows an example and where it all goes).</p><p>Once that's done, click on <strong>Continue</strong> and then on <strong>Submit</strong>. Then the App ID should be created.</p><p>Next, in the Xcode project's settings, select the iOS target and update the bundle identifier to the one you just created.</p><div><img src="img/image00274.jpeg" alt="Creating the App ID"/></div><p style="clear:both; height: 1em;"> </p><p>Now that the bundle ID and App ID are set up, we can create the app in iTunes Connect, and it will <a id="id413" class="indexterm"/>allow us to set up and test our leaderboards.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec122"/>Creating the app in iTunes Connect</h2></div></div></div><p>Creating <a id="id414" class="indexterm"/>the app in iTunes Connect is relatively simple, and is only going to be used as a wireframe so that we can create the leaderboards. In the next chapter, we'll cover all the details; for now you just need to know that the only reason we're setting it up in iTunes Connect now (instead of later) is for the purpose of setting up a leaderboard.</p><p>First, go to <a class="ulink" href="https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa">https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa</a>
and sign in to your developer account. Then click on <strong>My Apps</strong>, create a new app by clicking on the <strong>+</strong> button in the top-left corner, and click on <strong>New iOS App</strong>.</p><div><img src="img/image00275.jpeg" alt="Creating the app in iTunes Connect"/></div><p style="clear:both; height: 1em;"> </p><p>Then fill in the information it asks, including the App ID you created earlier. The SKU doesn't really matter, as it's for your own internal use.</p><div><img src="img/image00276.jpeg" alt="Creating the app in iTunes Connect"/></div><p style="clear:both; height: 1em;"> </p><p>Once<a id="id415" class="indexterm"/> the app has been created in iTunes connect, click on <strong>Game Center</strong>.</p><div><img src="img/image00277.jpeg" alt="Creating the app in iTunes Connect"/></div><p style="clear:both; height: 1em;"> </p><p>When it asks whether it's for a single game or multiple games, that's up to you to decide when creating projects on your own. But for the purpose of this book's project, we're going to create it for a single game.</p><div><img src="img/image00278.jpeg" alt="Creating the app in iTunes Connect"/></div><p style="clear:both; height: 1em;"> </p><p>After<a id="id416" class="indexterm"/> that, you'll be taken to the Game Center setup screen, and you're ready to move on to the next step.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec123"/>Creating the leaderboard</h2></div></div></div><p>From<a id="id417" class="indexterm"/> the Game Center setup section within iTunes Connect, click on the <strong>Add Leaderboard</strong> button and then on <strong>Single Leaderboard</strong>.</p><div><img src="img/image00279.jpeg" alt="Creating the leaderboard"/></div><p style="clear:both; height: 1em;"> </p><p>The <a id="id418" class="indexterm"/>leaderboard reference is for internal use within iTunes Connect, just in case you wish to search for it (or know at a glance which leaderboard it is). The <strong>Leaderboard ID</strong> will be used within the code, so it should be something unique and distinct from your other leaderboards (if you've created any). The score format is only whole numbers, so we'll use the <strong>Integer</strong> format. We want only the best score to be submitted (as only one score per person can exist in a leaderboard) and sorted from High to Low. Finally, we want the range to be from 0 to 999,999. Technically, we don't have to set this, but we're going to anyway.</p><p>Next, we add a language. Here's an example showing <strong>English</strong>:</p><div><img src="img/image00280.jpeg" alt="Creating the leaderboard"/></div><p style="clear:both; height: 1em;"> </p><p>The <strong>Name</strong> is<a id="id419" class="indexterm"/> the title at the top of the leaderboard that the users will see, so we want it to be obvious which leaderboard it is. The <strong>Score Format</strong> is the same as what you just saw. The <strong>Score Format Suffix</strong> works as follow: since we have <strong>Points</strong>, a score of 625 will look like <strong>625 Points</strong> in the leaderboard. If you think it would look weird to include the word <strong>Points</strong> in every score, feel free to leave it out, but for now, we're going to have it in there.</p><p>Once all of this information has been entered, click on <strong>Save</strong> at the bottom. And voilà! It's created! What comes next is coding the Game Center login, authentication, leaderboard presentation, submitting the score, and everything else that comes with handling Game Center.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec124"/>Adding the GameKit framework</h2></div></div></div><p>Before we<a id="id420" class="indexterm"/> do any coding, we need to include the GameKit framework in our project. So, in your project's settings, go to the <strong>iOS target</strong>, then go to <strong>Build Phases</strong>, and in the <strong>Link Binary With Libraries</strong> section, click on the <strong>+</strong> button to add a framework to the project, as shown in this<a id="id421" class="indexterm"/> screenshot:</p><div><img src="img/image00281.jpeg" alt="Adding the GameKit framework"/></div><p style="clear:both; height: 1em;"> </p><p>Then, search for <code class="literal">gamekit</code> (case insensitive), click on the <code class="literal">GameKit.framework</code> result, and then click on <strong>Add</strong>.</p><div><img src="img/image00282.jpeg" alt="Adding the GameKit framework"/></div><p style="clear:both; height: 1em;"> </p><p>And<a id="id422" class="indexterm"/> we're done! Now we're ready to code.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec125"/>GameKit helper files</h2></div></div></div><p>For the <a id="id423" class="indexterm"/>sake of simplicity, you can just copy the <code class="literal">GKHelper</code> files to your project (make sure you have the <strong>Copy</strong> checkbox selected). It's not that coding the Game Center stuff is hard—it's the same for literally every project that has Game Center. So why waste time manually typing the code when you can just have the files ready?</p><p>Essentially, what the <code class="literal">GKHelper</code> singleton class does is manage your <code class="literal">GKLocalPlayer</code> (the currently logged-in user in Game Center on the device), any calls to and from the server, and any leaderboard score posting and achievement tracking.</p><div><h3 class="title"><a id="tip59"/>Tip</h3><p>The <code class="literal">GKHelper</code> class <a id="id424" class="indexterm"/>was created using the online tutorial <a class="ulink" href="http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6">http://www.raywenderlich.com/23189/whats-new-with-game-center-in-ios-6</a>, if you're looking for more explanation. There is another guide at <a class="ulink" href="http://www.appcoda.com/ios-game-kit-framework/%20">http://www.appcoda.com/ios-game-kit-framework/ </a>that covers Game Center in depth. Refer to it if you're getting stuck, or still need extra help (as it can be confusing for those new to coding Game Center).</p></div><p>
<em>This is important</em>: Suppose you're getting this error message:</p><div><pre class="programlisting">GameKitHelper ERROR: {
NSLocalizedDescription = "The requested operation could not be completed because this application is not recognized by Game Center.";
}</pre></div><p>Then you must go to device <strong>Settings</strong> | <strong>Game Center</strong> and enable <strong>Sandbox</strong>, as shown in this screenshot:</p><div><img src="img/image00283.jpeg" alt="GameKit helper files"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec126"/>Authenticating the user</h2></div></div></div><p>Now <a id="id425" class="indexterm"/>that everything is in place, created, and ready for use, we can begin to code the actual leaderboard and make it appear when users sign in to Game Center.</p><p>First, we need to authenticate the local player; that is, have them sign in if they aren't signed in already, or just send a request for the <code class="literal">GKLocalPlayer</code>.</p><p>We're going to do this at the beginning of our app, so in <code class="literal">AppDelegate.m</code>, import the <code class="literal">GKHelper.h</code> file and add the following method call to the top of the <code class="literal">startScene</code> method:</p><div><pre class="programlisting">[[GKHelper sharedGameKitHelper] authenticateLocalPlayer];</pre></div><p>If everything was done correctly, when you run the game at this point, you should see a banner going across the top of your screen welcoming the currently logged-in player. If not, it will ask them to log in.</p><p>If you're getting an error message that says something along the lines of a requested operation being cancelled or disabled, go to the <strong>Settings</strong> app and then to <strong>Game Center</strong>. Try either logging in and out again, or enabling the <strong>Sandbox</strong> mode at the bottom (see the preceding screenshot). This should fix it.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec127"/>Creating the Game Center button</h2></div></div></div><p>We <a id="id426" class="indexterm"/>want a button for access to the leaderboards and other Game Center stuff, so in the <strong>GameOverScene.m</strong> file's <code class="literal">init</code> method, add the following code. It will create a button in the bottom-right corner of the screen:</p><div><pre class="programlisting">//add Game Center buttons
CCButton *btnGameCenter = [CCButton buttonWithTitle:@"" spriteFrame:[[CCSpriteFrameCache sharedSpriteFrameCache] spriteFrameByName:@"btnGameCenter.png"]];
[btnGameCenter setTarget:self selector:@selector(viewGameCenter1)];
btnGameCenter.position = ccp(0.75, 0.1);
btnGameCenter.positionType = CCPositionTypeNormalized;
[self addChild:btnGameCenter];</pre></div><p>We also want to display the leaderboards, and this requires the <code class="literal">GKHelper</code>, so at the top of <code class="literal">GameOverScene.m</code>, import the <code class="literal">GKHelper.h</code> file:</p><div><pre class="programlisting">#import "GKHelper.h"</pre></div><p>Then create the <code class="literal">viewGameCenter</code> method, which is simply a call for presenting the leaderboards:</p><div><pre class="programlisting">-(void)viewGameCenter
{
  [[GKHelper sharedGameKitHelper] presentLeaderboards];
}</pre></div><p>If you <a id="id427" class="indexterm"/>run the game at this point and get to the game over scene, you'll see a button for <strong>Game Center</strong> in the bottom-right corner, and when clicked on (and if you're signed in to Game Center), it'll open the leaderboard. The only thing left to do now is to submit the score to Game Center so it can be seen in the leaderboard.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec128"/>Submitting the score</h2></div></div></div><p>Since<a id="id428" class="indexterm"/> our <code class="literal">GKHelper</code> class can do all of the score reporting for us, all we need to do is call the respective function. Since we know <code class="literal">GameOverScene</code> will contain the total score from the most recent game, we can use the passed-in dictionary as the score value we submit to the leaderboard.</p><p>So, in the <code class="literal">init</code> method of <code class="literal">GameOverScene.m</code>, add a call to the <code class="literal">submitScore</code> function:</p><div><pre class="programlisting">[[GKHelper sharedGameKitHelper] submitScore:[dict[DictTotalScore] integerValue]];</pre></div><p>And that's it! It took a while to set up, and about 10 lines of code, but we have a global leaderboard.</p><p>There are two things to note here:</p><div><ul class="itemizedlist"><li class="listitem">You may want to implement achievements, but that code has not been implemented in the <code class="literal">GKHelper</code> class yet, so unfortunately, you're on your own. Although this is not too difficult, it wasn't necessary for this game, so it was skipped. As linked earlier, there's a great resource at <a class="ulink" href="http://www.appcoda.com/ios-game-kit-framework/">http://www.appcoda.com/ios-game-kit-framework/</a> that explains how to implement achievements. It was written in March 2014, so the code should still work by the time you read this book.</li><li class="listitem">While implementing leaderboards, if you ever run into an issue, make sure that everything, from the iTunes Connect setup to the Game Center to <strong>Sandbox</strong> mode and the code itself, is all in line. Game Center can be tricky and annoying. It's gotten better over the years, but can still be a bit finicky. If you're still having issues, it's likely that you're not the only one. A great place to start searching is Stack Overflow. If you aren't familiar with the site, don't worry. They have a question-and-answer format where tons of people have asked questions about code and other issues, and many more have given correct answers.</li></ul></div><p>And<a id="id429" class="indexterm"/> that's it for Game Center! The last thing to do to polish our project includes creating a custom transition between scenes to make the game feel more robust, instead of just instantly shifting back and forth between scenes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Slide transition</h1></div></div></div><p>Although it's fine for testing purposes, instant transitions between our scenes (as well as the <a id="id430" class="indexterm"/>game suddenly showing up when it first loads) are bad. We're going to add a nice quick slide between each scene. In other words, when the user taps a button or an event happens that's supposed to replace the scene with a new scene, we're going to make it seem as if all the scenes are on one giant white sheet, just out of view of the user.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec129"/>Creating a generic slide function</h2></div></div></div><p>Since<a id="id431" class="indexterm"/> we're going to be doing this all over the place, we need a function that's generic enough for us to pass to it any scene from any location, and it will do exactly what we want it to do.</p><p>So again, since <code class="literal">MainScene.h</code> is imported everywhere, we're going to create our generic function in it. Open <code class="literal">MainScene.h</code> and add this enumeration above the <code class="literal">@interface</code> line:</p><div><pre class="programlisting">NS_ENUM(NSInteger, kMoveDirection)
{
  kMoveDirectionUp,
  kMoveDirectionDown,
  kMoveDirectionLeft,
  kMoveDirectionRight
};

@interface MainScene :CCScene
{ ... }</pre></div><p>This will allow us to tell the generic function in which direction to slide our scene.</p><p>After that, add the following method declaration in <code class="literal">MainScene.h</code>:</p><div><pre class="programlisting">+(void)rubberBandToScene:(CCNode*)scene fromParent:(CCNode*)parent withDuration:(CGFloat)duration withDirection: (enumkMoveDirection)direction;</pre></div><p>The parameters this method takes are the scene you want to transition to, the parent (the scene <a id="id432" class="indexterm"/>you're currently on), how long you want the slide to last, and in what direction you want the slide to occur.</p><p>Next, in <code class="literal">MainScene.m</code>, add the actual function. It will slide our scene into the view and then replace it with <code class="literal">CCDirector</code> (the detailed explanation is in the comments):</p><div><pre class="programlisting">+(void)rubberBandToScene:(CCScene*)scene fromParent:(CCNode*)parent withDuration:(CGFloat)duration withDirection:(enumkMoveDirection)direction
{
  //grab the view size, so we know the width/height of the screen
  CGSize winSize = [[CCDirector sharedDirector] viewSize];
  
  //add the new scene to the current scene
  [parent addChild:scene z:-1];
  
  //set a distance to "over move" by
  NSInteger distance = 25;
  
  //variables for how much to move in each direction
  CGPoint posBack = ccp(0,0);
  CGPoint posForward = ccp(0,0);
  
  //determine the specifics based on which direction the slide is going to go
  if (direction == kMoveDirectionUp)
  {
    posBack.y = -distance;
    posForward.y = winSize.height + distance*2;
    scene.position = ccp(0,-winSize.height);
  }
  elseif (direction == kMoveDirectionDown)
  {
    posBack.y = distance;
    posForward.y = -(winSize.height + distance*2);
    scene.position = ccp(0,winSize.height);
  }
  elseif (direction == kMoveDirectionLeft)
  {
    posBack.x = distance;
    posForward.x = -(winSize.width + distance*2);
    scene.position = ccp(winSize.width, 0);
  }
  elseif (direction == kMoveDirectionRight)
  {
    posBack.x = -distance;
    posForward.x = winSize.width + distance*2;
    scene.position = ccp(-winSize.width,0);
  }
  
  //declare the slide actions
  id slideBack = [CCActionEaseInOut actionWithAction:[CCActionMoveBy actionWithDuration:duration/4 position:posBack] rate:2];
  id slideForward = [CCActionEaseInOut actionWithAction:[CCActionMoveBy actionWithDuration:duration/2 position:posForward] rate:2];
  id slideBackAgain = [CCActionEaseInOut actionWithAction:[CCActionMoveBy actionWithDuration:duration/4 position:posBack] rate:2];
  id replaceScene = [CCActionCallBlock actionWithBlock:^{
    
    //remove the new scene from the current scene (so we can use it in the replace)
    [parent removeChild:scene cleanup:NO];
    
    //reset its position to (0,0)
    scene.position = ccp(0,0);
    
    //actually replace our scene with the passed-in one
    [[CCDirector sharedDirector] replaceScene:scene];
  }];
  
  //arrange the actions into a sequence (which also includes the replacing)
  id slideSeq = [CCActionSequence actions:slideBack, slideForward, slideBackAgain, replaceScene, nil];
  
  //execute the sequence of actions
  [parent runAction:slideSeq];
} </pre></div><p>However, since we're moving the scenes slightly off screen in one direction or another, we<a id="id433" class="indexterm"/> need to make sure we have enough "background" to cover the extras.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec130"/>Extending the background</h2></div></div></div><p>At the<a id="id434" class="indexterm"/> top of our <code class="literal">MainScene.m</code> files <code class="literal">init</code> method, we change our declaration of the background to the following:</p><div><pre class="programlisting">CCNode *background = [CCNodeColor nodeWithColor:[CCColor whiteColor] width:winSize.width*5 height:winSize.height*5];
background.anchorPoint = ccp(0.5,0.5);
background.position = ccp(winSize.width/2, winSize.height/2);
[self addChild:background z:-2];</pre></div><p>The <code class="literal">z</code> value is set to <code class="literal">-2</code> so that we can place the new scene at <code class="literal">-1</code> (as seen in preceding code). Thus, even though the background is five times the width and the height of the screen, the new scene will still be visible when it slides into the view.</p><p>Now the only thing left to do is to actually call the function.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec131"/>Replacing the scene with a rubber band transition</h2></div></div></div><p>Because <a id="id435" class="indexterm"/>we made such a convenient generic function, we don't need to do anything besides calling it once. So in <code class="literal">MainScene.m</code>, modify your <code class="literal">goToMenu</code> function to call the <code class="literal">rubberBandToScene</code> method you just created:</p><div><pre class="programlisting">-(void)goToMenu
{
  if (isSoundOn)
    [[OALSimpleAudio sharedInstance] playEffect:@"buttonClick.mp3"];
  
  [MainScene rubberBandToScene:[MenuScene scene] fromParent:self withDuration:0.5f withDirection:kMoveDirectionDown];
}</pre></div><p>Also modify the same line in the <code class="literal">endGame</code> method in <code class="literal">MainScene.m</code>:</p><div><pre class="programlisting">-(void)endGame
{
  //right here:
  NSInteger hsIndex = [self saveHighScore];
  
  UIImage *image = [self takeScreenshot];
  
  NSDictionary *scoreData = @{DictTotalScore : @(numTotalScore),
    DictTurnsSurvived :@(numTurnSurvived),
    DictUnitsKilled :@(numUnitsKilled),
    DictHighScoreIndex :@(hsIndex),
    @"screenshot" : image};
  
  [MainScene rubberBandToScene:[GameOverScene sceneWithScoreData: scoreData] fromParent:self withDuration:0.5f withDirection:kMoveDirectionUp];
  
}</pre></div><p>Notice<a id="id436" class="indexterm"/> that the one going to the menu is <code class="literal">DirectionDown</code>, whereas the <code class="literal">endGame</code> object is <code class="literal">DirectionUp</code>. Now run the game and press that <strong>Menu</strong> button. Beautiful isn't it? But that's just one of the many scene transitions we have. So let's handle the rest, shall we?</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec132"/>Transition in MenuScene</h2></div></div></div><p>When <a id="id437" class="indexterm"/>we click on the <strong>Play</strong> button, we'd ideally want the same effect, so we first need to create the extra-large background. In <code class="literal">MenuScene.m</code>, modify the background code to look like <code class="literal">MainScene</code>:</p><div><pre class="programlisting">-(id)init
{
  if ((self=[super init]))
  {
    winSize = [CCDirector sharedDirector].viewSize;
    
    //these values range 0 to 1.0, so use float to get ratio
    CCNode *background = [CCNodeColor nodeWithColor: [CCColorwhiteColor] width:winSize.width*5 height:winSize.height*5];
    background.anchorPoint = ccp(0.5,0.5);
    background.position = ccp(winSize.width/2, winSize.height/2);
  [self addChild:background z:-2];
  ...
}</pre></div><p>Then, in the <code class="literal">goToGame</code> function, we simply make a call to the generic function we made previously:</p><div><pre class="programlisting">-(void)goToGame
{
  if (isSoundOn)
    [[OALSimpleAudio sharedInstance] playEffect: @"buttonClick.mp3"];
  
  [MainScene rubberBandToScene:[MainScene scene] fromParent:self withDuration:0.5f withDirection:kMoveDirectionUp];
} </pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec133"/>Transition in GameOver</h2></div></div></div><p>So far, we've gotten the to-menu and to-gameover transitions into the main game scene. We've <a id="id438" class="indexterm"/>also implemented the to-game transition in the main menu scene. The only thing left to do is to put the transition for to-menu and to-game in the <code class="literal">GameOverScene</code>.</p><p>To do this, you can do in <code class="literal">GameOverScene.m</code> what you've been doing so far, and modify the <code class="literal">replaceScene</code> line of code in the <code class="literal">goToMenu</code> and <code class="literal">restartGame</code> methods:</p><div><pre class="programlisting">-(void)goToMenu
{
  //to be filled in later
  [MainScene rubberBandToScene:[MenuScene scene] fromParent:self withDuration:0.5f withDirection:kMoveDirectionDown];
}

-(void)restartGame
{
  //to be filled in later
  [MainScene rubberBandToScene:[MainScene scene] fromParent:self withDuration:0.5f withDirection:kMoveDirectionDown];
}</pre></div><p>And that's it! We've managed to not only create a custom transition (compared to the rather boring transitions that Cocos2d version 3.0+ comes with) but also implement it with ease. It adds just that bit of the "Whee! This is fun!" factor, which is a good thing because it's what the players will be feeling. Happy players means higher engagement, and higher engagement means higher ratings and more referrals to their friends (which means more money in your pocket).</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec134"/>Other ideas for polishing</h2></div></div></div><p>Some other <a id="id439" class="indexterm"/>ideas for polishing that weren't covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Smoother animation for characters or units</li><li class="listitem">Fluid movements (such as the Bézier effect, as covered in the previous chapter)</li><li class="listitem">No loading screen (ending the current scene looking exactly like how the next scene will begin, and transitioning instantly)</li><li class="listitem">No crashes (yes, fix all of them)</li><li class="listitem">Subtle details such as background movement or brief NPC voice-overs</li><li class="listitem">Saving the user's spot in case of an interruption (phone call, battery dead, and so on)</li></ul></div><p>But these are just a few examples. There's a million little things you could do to your game to make it ever so slightly better, but alas! At some point, we need to release the game, so that's what the next chapter is going to focus on—adding the finishing touches and submitting the game to Apple.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Summary</h1></div></div></div><p>In this chapter, you learned various ways to polish your game and really focus on some subtle, but important, elements such as on/off buttons for sound and music, sliding between scenes, and the social sharing feature.</p><p>There's always something that can be tweaked and tuned to make it more polished. For example, if you wish to learn more about more traditional sprite animations, you can do so using <code class="literal">CCAnimation</code>. There's a great reference guide for this at <a class="ulink" href="http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html">http://www.cocos2d-swift.org/docs/api/Classes/CCAnimation.html</a>.</p><p>Notice that as of now, we still haven't come up with a name for the game. Although the name is something that all users will see and familiarize themselves with, it's not important for the development of the game, which is why it's coming last.</p></div></body></html>