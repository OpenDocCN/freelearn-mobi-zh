- en: Chapter 10. Harnessing the Past – Understanding and Translating Objective-C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 利用过去 – 理解和翻译Objective-C
- en: While Apple's platforms have been around for many years, Swift is still a very
    new language. Even before the release of the first iPhone, Apple's primary language
    of choice was Objective-C. This means that there are a vast number of resources
    in the world for developing on Apple's platforms using Objective-C. There are
    many amazing tutorials, code libraries, articles, and more, that are written in
    Objective-C that are still incredibly valuable for a Swift developer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管苹果的平台已经存在很多年，但Swift仍然是一种非常新的语言。甚至在第一代iPhone发布之前，苹果首选的主要语言就是Objective-C。这意味着世界上有大量使用Objective-C在苹果平台上开发的应用资源。有许多令人惊叹的教程、代码库、文章等等，这些都是在Objective-C中编写的，对于Swift开发者来说仍然非常有价值。
- en: To take advantage of these resources, you must have at least a basic understanding
    of Objective-C, so that you can translate the concepts learned in tutorials and
    articles into Swift, as well as make use of the time tested Objective-C libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这些资源，您至少需要具备Objective-C的基本理解，这样您才能将教程和文章中学到的概念翻译成Swift，并利用经过时间考验的Objective-C库。
- en: 'In this chapter, we will develop a basic understanding of Objective-C with
    a focus on how it compares to Swift with the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题来了解Objective-C的基础知识，并关注其与Swift的比较：
- en: Swift's relationship to Objective-C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift与Objective-C的关系
- en: Background of Objective-C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C的背景
- en: Constants and variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量和变量
- en: Containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Control flow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流
- en: Functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Projects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目
- en: Calling Objective-C code from Swift
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Swift调用Objective-C代码
- en: Swift's relationship to Objective-C
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift与Objective-C的关系
- en: As we discussed already, Objective-C was previously the primary language for
    developing on Apple's platforms. This means that Objective-C had a lot of influence
    on Swift; the largest of which is that Swift was designed to interoperate with
    Objective-C. Swift code can call Objective-C code and, likewise, Objective-C code
    can call Swift code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Objective-C曾是开发苹果平台应用的主要语言。这意味着Objective-C对Swift产生了很大影响；其中最大的影响是Swift被设计成与Objective-C互操作。Swift代码可以调用Objective-C代码，同样，Objective-C代码也可以调用Swift代码。
- en: Ultimately, Swift was designed, and is still is being designed, to be the next
    step in programming languages, without having to throw away all of our Objective-C
    code. Apple's stated goals for the language are for Swift to be more modern, interactive,
    safe, fast, and powerful. These words would be pretty much meaningless if we didn't
    already have a baseline to compare Swift against. Since Swift was designed primarily
    for Apple's platforms, that baseline is largely Objective-C.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的设计初衷，并且仍在设计中，是为了成为编程语言的下一步，而不必丢弃我们所有的Objective-C代码。苹果对这种语言的目标是使Swift更加现代、交互式、安全、快速和强大。如果我们没有与Swift进行比较的基准，这些话将毫无意义。由于Swift主要设计用于苹果平台，这个基准在很大程度上是Objective-C。
- en: Background of Objective-C
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C的背景
- en: Before we can talk about the details of Objective-C, we need to acknowledge
    its history. Objective-C is based on a language called simply "C". The C programming
    language was one of the first highly portable languages. Portable means that the
    same C code could be compiled to run on any processor as long as someone writes
    a compiler for that platform. Before that, most of the code was written in Assembly;
    which always had to be written specifically for each processor it would run on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够讨论Objective-C的细节之前，我们需要承认其历史。Objective-C基于一种被称为“C”的语言。C编程语言是第一种高度可移植的语言之一。可移植意味着相同的C代码可以被编译成在任何处理器上运行，只要有人为该平台编写一个编译器。在此之前，大多数代码都是用汇编语言编写的；这总是需要针对每个将要运行的处理器进行编写。
- en: C is what is commonly referred to as a procedural programming language. It is
    built on the concept of a series of functions that call each other. It has a very
    basic support to create your own types, but it has no built in concept of objects.
    Objective-C was developed as an object-oriented extension to C. Just as Swift
    is backwards compatible with Objective-C, Objective-C is backwards compatible
    with C. Really, it simply adds object-oriented features on top of C with some
    new syntax and built-in libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C通常被称为过程式编程语言。它基于一系列相互调用的函数的概念。它提供了非常基本的创建自定义类型的支持，但没有内置的对象概念。Objective-C被开发为C的面向对象扩展。正如Swift与Objective-C向后兼容一样，Objective-C也与C向后兼容。实际上，它只是在C的基础上添加了一些新的语法和内置库，以实现面向对象的功能。
- en: 'The real important thing is that Apple developed their current APIs: Cocoa
    and Cocoa Touch, for Objective-C. This is one of the biggest reasons why Objective-C
    is still very relevant to us as Swift developers. Even though we are primarily
    writing Swift code, we are still going to be regularly interacting with the Cocoa
    and Cocoa Touch libraries written in Objective-C.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 真正重要的是苹果开发了他们当前的 API：Cocoa 和 Cocoa Touch，用于 Objective-C。这是 Objective-C 仍然对我们作为
    Swift 开发者来说非常相关的一个最大原因。尽管我们主要编写 Swift 代码，但我们仍然会定期与用 Objective-C 编写的 Cocoa 和 Cocoa
    Touch 库进行交互。
- en: Constants and variables
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量和变量
- en: 'Now, we are ready to dive into the basics of the Objective-C language. Objective-C
    has constants and variables very similar to Swift but they are declared and worked
    with slightly differently. Let''s take a look at declaring a variable in both
    Swift and Objective-C:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备深入探讨 Objective-C 语言的基础知识。Objective-C 中的常量和变量与 Swift 非常相似，但它们的声明和工作方式略有不同。让我们来看看在
    Swift 和 Objective-C 中如何声明一个变量：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line should look familiar, as it is Swift. The Objective-C version
    doesn''t actually look all that different. The important difference is that the
    type of the variable is declared before the name instead of after. It is also
    important to note that Objective-C has no concept of type inference. Every time
    a variable is declared, it must be given a specific type. You will also see that
    there is a semicolon after the name. This is because every line of code in Objective-C
    must end with a semicolon. Lastly, you should notice that we have not explicitly
    declared `number` as a variable. This is because all information is assumed to
    be variable in Objective-C unless specified otherwise. To define `number` as a
    constant, we will add the `const` keyword before its type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行应该看起来很熟悉，因为它是 Swift 语法。Objective-C 版本实际上并没有太大的区别。重要的区别在于变量的类型是在名称之前而不是之后声明的。还应注意，Objective-C
    没有类型推断的概念。每次声明变量时，都必须给它指定一个特定的类型。你还会看到在名称后面有一个分号。这是因为 Objective-C 中的每一行代码都必须以分号结束。最后，你应该注意到我们没有显式地将
    `number` 声明为变量。这是因为除非明确指定，否则 Objective-C 中假设所有信息都是变量。为了将 `number` 定义为常量，我们将在其类型之前添加
    `const` 关键字：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Objective-C has value and reference types just like Swift. However, in Objective-C,
    the difference between them is more conceptual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 有值类型和引用类型，就像 Swift 一样。然而，在 Objective-C 中，它们之间的区别更具有概念性。
- en: Value types
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: The number we declared above is a value type in both languages. They are copied
    if they are passed to another function and there cannot be more than one variable
    referencing the exact same instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面声明的数字在这两种语言中都是值类型。如果将它们传递给另一个函数，它们会被复制，并且不能有多个变量引用相同的实例。
- en: It is actually easier to determine if a variable is a value type or a reference
    type in Objective-C because, as we will see, virtually all reference types are
    declared with an asterisk (`*`). If there is an asterisk, you can be safe to assume
    that it is a reference type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在 Objective-C 中确定变量是值类型还是引用类型更容易，因为我们将会看到，几乎所有的引用类型都是用星号 (`*`) 声明的。如果有星号，你可以安全地假设它是一个引用类型。
- en: Reference types
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'Objective-C actually allows you to make any type a reference type by adding
    an asterisk:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 实际上允许你通过添加一个星号来将任何类型转换为引用类型：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This declares a reference to a number variable, more commonly referred to as
    a **pointer**. In a pointer declaration, the asterisk should always come after
    the type and before the name.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个指向数字变量的引用，更常见的是称为 **指针**。在指针声明中，星号应该始终位于类型之后和名称之前。
- en: 'In Objective-C, reference types are actually loosely mixed with the concept
    of optional in Swift. All reference types are optional because a pointer can always
    point to nil:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，引用类型实际上与 Swift 中的可选概念松散地混合在一起。所有引用类型都是可选的，因为指针可以始终指向 nil：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A pointer can also always be tested for nil:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 指针也可以始终检查 nil：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To access the referenced value, you must dereference it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问引用的值，你必须取消引用它：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can dereference a pointer by adding an asterisk before it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在指针前添加一个星号来取消引用它。
- en: This is how pointers are similar to optionals in Swift. The difference is that
    there is no way to declare a non-optional reference type in Objective-C. Every
    reference type could technically be nil, even if you design it to never actually
    be nil. This can often add a lot of unnecessary nil checking and means every function
    you write that accepts a reference type should probably deal with the nil case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Swift 中指针与可选类型相似的地方。区别在于在 Objective-C 中无法声明非可选的引用类型。每个引用类型在技术上都可以是 nil，即使你设计它永远不会是
    nil。这通常会增加很多不必要的 nil 检查，意味着你编写的每个接受引用类型的函数都应该处理 nil 的情况。
- en: 'Finally, the other difference between reference types in the two languages
    is that Objective-C is not very strict when it comes to what type the pointer
    is referencing. For example, Objective-C won''t complain if we create a new double
    reference that points at the same thing as the `int` pointer:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这两种语言中引用类型的另一个区别是，Objective-C 在指针引用的类型上不是很严格。例如，如果我们在 `int` 指针指向相同的东西上创建一个新的双引用，Objective-C
    不会抱怨：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have two variables: `number` and `another`; they are pointing at the
    same value but assuming that they both are of different types. One of them is
    clearly going to be wrong, but Objective-C will happily try to use the same value
    as both a `double` and an `int` if you try. This is just one bug that Swift makes
    impossible by design.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个变量：`number` 和 `another`；它们指向相同的值，但假设它们是不同类型的。其中之一显然是错误的，但如果你尝试，Objective-C
    会愉快地尝试将相同的值用作 `double` 和 `int`。这正是 Swift 通过设计使其不可能的一个错误。
- en: So far, all of the Objective-C code we have looked at is actually strict C.
    We have not used any of the features that Objective-C added onto C. The main thing
    that Objective-C adds to C is its class system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们查看的所有 Objective-C 代码实际上都是严格的 C 语言。我们没有使用 Objective-C 添加到 C 中的任何功能。Objective-C
    添加到 C 中的主要事情是其类系统。
- en: 'Lets take a look at our first actual Objective-C type called `NSString` compared
    to the Swift `String` type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的第一个实际的 Objective-C 类型 `NSString` 与 Swift 的 `String` 类型进行比较：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like in Swift, you can create a string instance using double quotes; however,
    in Objective-C you must put an `@` sign before it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Swift 中一样，你可以使用双引号创建一个字符串实例；然而，在 Objective-C 中，你必须在其前面放置一个 `@` 符号。
- en: One big thing to remember with the Objective-C class system is that it is not
    possible to create an instance of a class that is a value type. All instances
    must be referenced by a reference type. We cannot create a plain `NSString`. It
    must always be an `NSString*` pointer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 类系统中有一个重要的事情要记住，那就是无法创建一个值类型的类的实例。所有实例都必须通过引用类型来引用。我们不能创建一个普通的
    `NSString`。它必须始终是一个 `NSString*` 指针。
- en: Containers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Objective-C has the same exact core containers that Swift does, with the two
    exceptions being that they are named slightly differently, and all of the containers
    in Objective-C are reference types because of the basic requirement that all Objective-C
    types must be reference types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 与 Swift 具有完全相同的核心容器，有两个例外：它们的命名略有不同，并且由于 Objective-C 中所有类型都必须是引用类型的基本要求，Objective-C
    中的所有容器都是引用类型。
- en: Arrays
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'In Objective-C arrays are called `NSArray`. Let''s take a look at the initialization
    of an array in both Swift and Objective-C side-by-side:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，数组被称为 `NSArray`。让我们看看 Swift 和 Objective-C 中数组的初始化是如何并排进行的：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have defined a variable called `array` that is a reference to the type `NSArray`.
    We then assign it to a newly allocated instance of `NSArray`. The square bracket
    notation in Objective-C allows us to call methods on a type or on an instance.
    Each separate call is always contained within a single set of square brackets.
    In this case, we are first calling the `alloc` method on the `NSArray` class.
    This returns a newly allocated variable that is of the type `NSArray`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `array` 的变量，它是对 `NSArray` 类型的引用。然后我们将其分配给一个新的 `NSArray` 实例。Objective-C
    中的方括号表示法允许我们在类型或实例上调用方法。每个单独的调用总是包含在单个方括号集中。在这种情况下，我们首先在 `NSArray` 类上调用 `alloc`
    方法。这返回一个新分配的变量，其类型为 `NSArray`。
- en: In contrast to Swift, Objective-C requires a two-step process to initialize
    a new instance. First, the memory must be allocated and then it must be initialized.
    Allocating means that we are reserving the memory for that object and initializing
    it means that we are setting it to its default value. This is what we are doing
    in the second line. The second line asks the instance to initialize itself. We
    reassign the array to the result of the call to `init`, because it is possible
    for `init` to return nil. Note that we are not dereferencing the `array` variable
    in order to make a call on it. We actually call the methods directly on the pointer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Swift 不同，Objective-C 需要两步过程来初始化一个新的实例。首先，必须分配内存，然后必须初始化。分配意味着我们为该对象预留内存，初始化意味着我们将它设置为默认值。这就是我们在第二行所做的事情。第二行要求实例初始化自己。我们将数组重新赋值为对
    `init` 调用的结果，因为 `init` 可能返回 nil。请注意，我们没有解引用 `array` 变量来对其调用方法。我们实际上是在指针上直接调用方法。
- en: 'Now, it is kind of a waste to use two lines to initialize a new instance, so
    often the calls are chained together:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用两行来初始化一个新的实例有点浪费，所以通常会将调用链式连接起来：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This calls `alloc` on `NSArray` and then immediately calls on `init` on the
    result of that. The `array` variable is then assigned to the result of the `init`
    call. Be aware that it is possible for `alloc` to return nil, in which case we
    would be calling `init` on nil. In Objective-C this is OK; if you call a method
    on nil, it will simply always return nil. This is similar to how optional chaining
    works in Swift.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在 `NSArray` 上调用 `alloc`，然后立即在 `alloc` 的结果上调用 `init`。然后，`array` 变量被分配给 `init`
    调用的结果。请注意，`alloc` 可能返回 nil，在这种情况下，我们将对 nil 调用 `init`。在 Objective-C 中这是可以的；如果你在
    nil 上调用方法，它将简单地总是返回 nil。这与 Swift 中的可选链式调用类似。
- en: 'There is also an alternative to calling `alloc` and `init`; it''s called simply
    `new`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用 `alloc` 和 `init` 之外，还有一个简单的替代方法，那就是使用 `new`：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class method allocates and initializes the instance at the same time. This
    is great when you are not passing any arguments into `init`, but you will still
    need to call `alloc` separately when you are passing arguments into it. We will
    see examples of this later on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类方法同时分配和初始化实例。当你没有向 `init` 传递任何参数时，这很棒，但当你向其中传递参数时，你仍然需要单独调用 `alloc`。我们将在稍后看到这个例子。
- en: You may have noticed that we have not specified what type this array is supposed
    to hold. This is because it is actually not possible. All arrays in Objective-C
    can contain any mix of types as long as they are not C types. This means that
    an `NSArray` cannot contain an `int` (there is an `NSNumber` class instead), but
    it can contain any mix of `NSStrings`, `NSArrays`, or any other Objective-C type.
    The compiler will not do any form of type checking for you, which means that we
    can write code expecting the wrong type to be in the array. This is yet another
    classification of bug that Swift makes impossible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有指定这个数组应该包含什么类型。这是因为实际上这是不可能的。在 Objective-C 中，只要不是 C 类型，所有数组都可以包含任何类型的混合。这意味着
    `NSArray` 不能包含 `int`（而是使用 `NSNumber` 类），但它可以包含任何混合的 `NSStrings`、`NSArrays` 或其他
    Objective-C 类型。编译器不会为你进行任何形式的类型检查，这意味着我们可以编写期望数组中包含错误类型的代码。这是 Swift 使之不可能的另一种错误分类。
- en: 'So how do we add objects to our array? The reality is that the `NSArray` class
    does not allow us to add or remove objects from it. In other words, `NSArray`
    is immutable. Instead, there is a version of an array called `NSMutableArray`
    that allows us to add and remove objects. Then we can use the `addObject:` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何向我们的数组中添加对象呢？实际上，`NSArray` 类不允许我们向其中添加或删除对象。换句话说，`NSArray` 是不可变的。相反，有一个名为
    `NSMutableArray` 的数组版本，允许我们添加和删除对象。然后我们可以使用 `addObject:` 方法：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Methods in Objective-C and Swift are named in the same way with a colon indicating
    each argument. In Objective-C, the colon is also used when calling the method
    to indicate the following code is the value to pass into the method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 和 Swift 中的方法命名方式相同，冒号用于表示每个参数。在 Objective-C 中，冒号也用于调用方法，以表示以下代码是传递给方法的值。
- en: The existence of a plain `NSArray` is to serve the same basic purpose as a constant
    array in Swift. In fact, we will see that all Objective-C containers are split
    into mutable and non-mutable versions. A mutable container can be passed into
    a method and treated like the non-mutable version to add some safety by not allowing
    unwanted code to modify the array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹的`NSArray`的存在是为了与Swift中的常量数组实现相同的基本目的。实际上，我们将看到所有Objective-C容器都被分为可变和不可变版本。可变容器可以被传递到方法中，并像不可变版本一样处理，通过不允许不想要的代码修改数组来增加一些安全性。
- en: 'Now, to access a value in an `NSArray` we have two options. The full way is
    to use the `objectAtIndex:` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要访问`NSArray`中的值，我们有两种选择。完整的方式是使用`objectAtIndex:`方法：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use square brackets, similar to Swift:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用方括号，类似于Swift：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that we are just assuming that the type returned from the array is an
    `NSString`. We can just as easily assume that it is another type, say `NSArray`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们只是假设从数组返回的类型是`NSString`。我们同样可以假设它是另一种类型，比如`NSArray`：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we know, this will be wrong and will almost certainly cause bugs later in
    the code but the compiler will not complain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，这将是不正确的，并且几乎肯定会在代码的后期引发错误，但编译器不会抱怨。
- en: 'Lastly, to remove an object from a mutable array, we can use the `removeObjectAtIndex:`
    method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要从可变数组中删除对象，我们可以使用`removeObjectAtIndex:`方法：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The other important feature that you will need to be aware of is that Objective-C
    also has array literals, so you don''t have to build them up dynamically:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的另一个重要特性是，Objective-C也有数组字面量，因此你不必动态构建它们：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Array literals start with an `@` symbol just like a string, but then it is defined
    by a list of objects within square brackets just like Swift.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 数组字面量以`@`符号开头，就像字符串一样，但随后它由方括号内的对象列表定义，就像Swift一样。
- en: There is a lot more that arrays can do, but you should be able to understand
    what each method does when you see it because most are well named. The methods
    are also often named the same in each language or you can look them up online,
    where Apple has extensive documentation. The purpose of this chapter is just to
    get you comfortable enough to have a high-level understanding of Objective-C code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以做很多事情，但你应该能够在看到每个方法时理解它所做的是什么，因为大多数方法命名得很好。这些方法在每种语言中通常都有相同的名称，或者你可以在网上查找，苹果公司有广泛的文档。本章的目的是让你对Objective-C代码有一个足够高的层次理解。
- en: Dictionaries
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典
- en: 'Following the same pattern as arrays, dictionaries in Objective-C are called
    `NSDictionary` and `NSMutableDictionary`. A dictionary is initialized in the exact
    same way as shown:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照与数组相同的模式，Objective-C中的字典被称为`NSDictionary`和`NSMutableDictionary`。字典的初始化方式与所示完全相同：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To set a value, we use the `setObject:forKey:` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个值，我们使用`setObject:forKey:`方法：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Just like with arrays, we cannot set new objects on non-mutable dictionaries.
    Also, this is our first example of a method that takes more than one argument.
    As you can see, each argument is contained within the square brackets but separated
    by a space and the label for that argument. In this pattern, Objective-C methods
    can have a number of arguments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组一样，我们无法在不可变字典上设置新对象。此外，这是我们第一个需要多个参数的方法的例子。正如你所看到的，每个参数都包含在方括号内，但由空格和该参数的标签分隔。在这种模式中，Objective-C方法可以有多个参数。
- en: 'Now to access a value we can use the `objectForKey:` method or square brackets
    again:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要访问一个值，我们可以使用`objectForKey:`方法或再次使用方括号：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, we are assuming that the resulting object being returned is a string,
    because we know what we just put into the dictionary. This assumption isn't always
    safe and we also need to always be aware that this method will return nil if an
    object does not exist for that key.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们假设返回的结果是一个字符串，因为我们知道我们刚刚放入字典中的内容。这种假设并不总是安全的，我们还需要始终意识到，如果该键不存在对象，此方法将返回nil。
- en: 'Lastly, to remove an object, we can use the `removeObjectForKey:` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要删除对象，我们可以使用`removeObjectForKey:`方法：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is all relatively straightforward, especially when you are reading the
    code. This verbosity was always a great feature of Objective-C to write understandable
    code and this was definitely carried forward into Swift.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切相对简单明了，尤其是在阅读代码时。这种冗长性一直是Objective-C编写可理解代码的伟大特性，并且这一特性也被明确地继承到了Swift中。
- en: 'Dictionaries also have literals, but unlike `NSArrays` and Swift array literals,
    dictionary literals in Objective-C are declared using curly brackets. Otherwise,
    it looks very similar to Swift:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 字典也有字面量，但与 `NSArrays` 和 Swift 数组字面量不同，Objective-C 中的字典字面量使用花括号声明。否则，它看起来与 Swift
    非常相似：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, we have to start our literal with an `@` symbol. We can also see that
    we can use numbers as objects in our containers as long as we put an `@` symbol
    before each one. Instead of creating something such as an `int` type, this creates
    an `NSNumber` instance. You shouldn't need to know much about the `NSNumber` class
    except that it is a class to represent many different forms of numbers as objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们必须以 `@` 符号开始我们的字面量。我们还可以看到，只要我们在每个数字前加上 `@` 符号，我们就可以在我们的容器中使用数字作为对象。这不像创建一个
    `int` 类型，而是创建一个 `NSNumber` 实例。你不需要了解太多关于 `NSNumber` 类的信息，除了它是一个表示许多不同形式的数字的对象类。
- en: Control flow
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: 'Objective-C has many of the same control flow paradigms as Swift. We will go
    through each of them quickly, but before we do, let''s take a look at the Objective-C
    equivalent of `print`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 与 Swift 有许多相同的控制流范式。我们将快速浏览每个，但在我们这样做之前，让我们看看 Objective-C 中 `print`
    的等价物：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of `print`, we are using a function called `NSLog`. Objective-C does
    not have string interpolation, so `NSLog` is a somewhat more complex solution
    than `print`. The first argument to `NSLog` is a string that describes the format
    to be printed out. This includes a placeholder for each piece of information we
    want to log that indicates the type it should expect. Every placeholder starts
    with a percent symbol. In this case, we are using an at-symbol to indicate what
    we are going to be substituting in a string. Every argument after the initial
    format will be substituted for the placeholders in the same order they are passed
    in. Here, this means that it will end up logging **Hello Sarah** just like the
    Swift code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是使用 `print`，而是使用一个名为 `NSLog` 的函数。Objective-C 没有字符串插值，所以 `NSLog` 是一个比 `print`
    稍微复杂一些的解决方案。`NSLog` 的第一个参数是一个描述要打印格式的字符串。这包括每个我们想要记录的信息的占位符，它指示应该期望的类型。每个占位符都以百分号符号开始。在这种情况下，我们使用
    at 符号来指示我们将在字符串中替换的内容。初始格式之后的每个参数都将按照传入的顺序替换占位符。这里，这意味着它最终会记录 **Hello Sarah**，就像
    Swift 代码一样。
- en: Now, we are ready to look at the different methods of control flow in Objective-C.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好查看 Objective-C 中不同的控制流方法了。
- en: Conditionals
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'A conditional looks exactly the same in both Swift and Objective-C except parentheses
    are required in Objective-C:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 和 Objective-C 中，条件语句看起来几乎完全相同，只是在 Objective-C 中需要括号：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can also include those parentheses in Swift, but they are optional. Here,
    you also see that Objective-C still has the idea of the dot syntax for calling
    some methods. In this case, we have used `invitees.count` instead of `[invitees
    count]`. This is only an option when we are accessing a property of the instance
    or we are calling a method that takes no arguments and returns something, as if
    it were a calculated property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Swift 中包含那些括号，但它们是可选的。在这里，你还可以看到 Objective-C 仍然有点语法来调用某些方法的概念。在这种情况下，我们使用了
    `invitees.count` 而不是 `[invitees count]`。这只有在访问实例的属性或调用不带参数且返回某些内容的方法时才是可选的，就像它是一个计算属性一样。
- en: Switches
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开关
- en: 'Switches in Objective-C are profoundly less powerful than switches in Swift.
    In fact, switches are a feature of strict C and are not enhanced at all by Objective-C.
    Switches cannot be used like a series of conditionals; they can only be used to
    do equality comparisons:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 中的 `switch` 与 Swift 中的 `switch` 相比，功能要弱得多。实际上，`switch` 是严格 C 的一个特性，并且
    Objective-C 并没有对其进行任何增强。`switch` 不能像一系列条件语句那样使用；它只能用于进行相等比较：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, parentheses are required in Objective-C, where they are optional in Swift.
    The most important difference with Objective-C switches is that by default, one
    case will flow into the next unless you specifically use the `break` keyword to
    get out of the switch. That is the opposite of Swift, where it will only flow
    into the next case if you use the `fallthrough` keyword. In practice, this means
    that the vast majority of Objective-C switch cases will need to end with `break`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在 Objective-C 中需要括号，而在 Swift 中则是可选的。与 Objective-C 中的 `switch` 相比，最重要的区别是默认情况下，一个
    case 会流入下一个，除非你明确使用 `break` 关键字来退出 `switch`。这与 Swift 相反，Swift 中只有在使用 `fallthrough`
    关键字时才会流入下一个 case。在实践中，这意味着绝大多数 Objective-C 的 `switch` case 都需要以 `break` 结尾。
- en: Objective-C switches are not powerful enough to allow us to create cases for
    ranges of values and certainly cannot test a list of arbitrary conditionals like
    we can in Swift.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 的 switch 语句功能不足以让我们为一系列值创建情况，当然也不能像 Swift 那样测试一系列任意条件。
- en: Loops
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: 'Just like conditionals, loops in Objective-C are very similar to Swift. While-loops
    are identical except that the parentheses are required:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就像条件语句一样，Objective-C 中的循环与 Swift 非常相似。while 循环完全相同，只是需要括号：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The for-in loops are slightly different, in this you must specify the type
    of the variable you are looping through with the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: for-in 循环略有不同，在这个循环中，你必须指定你正在遍历的变量的类型，如下所示：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You may have also noticed that when we are looping through an `NSDictionary`
    in Objective-C you only get the key. This is because tuples do not exist in Objective-C.
    Instead, you must access the value from the original dictionary, using the key
    as you loop through.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到了，当我们遍历 Objective-C 中的 `NSDictionary` 时，你只能得到键。这是因为 Objective-C 中不存在元组。相反，你必须使用键作为遍历的依据来从原始字典中访问值。
- en: 'The other feature that is missing from Objective-C is ranges. To loop through
    a range of numbers, Objective-C programmers must use a different kind of loop
    called a `for` loop:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 缺失的另一个特性是范围。为了遍历一系列数字，Objective-C 程序员必须使用一种不同的循环，称为 `for` 循环：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This loop is made up of three parts: an initial value, a condition to run until,
    and an operation to perform after each loop. This version loops through the numbers
    1 to 10 just like the Swift version. Clearly, it is still possible to translate
    the Swift code into Objective-C; it just isn''t as clean.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环由三部分组成：一个初始值，一个运行条件，以及每次循环后要执行的操作。这个版本与 Swift 版本一样，循环遍历数字 1 到 10。显然，仍然可以将
    Swift 代码翻译成 Objective-C；只是它并不那么简洁。
- en: Even with that limitation, you can see that Objective-C and Swift loops are
    pretty much the same except for the parentheses requirement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有这个限制，你仍然可以看出，Objective-C 和 Swift 的循环几乎相同，只是需要括号。
- en: Functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: So far we have called some Objective-C functions but we have not defined any
    yet. Let's see what the Objective-C versions are of the functions we defined in
    [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables, Collections, and
    Flow Control"), *Building Blocks – Variables, Collections, and Flow Control*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经调用了一些 Objective-C 函数，但还没有定义它们。让我们看看我们在 [第 2 章](ch02.html "第 2 章。构建块
    – 变量、集合和流程控制")，*构建块 – 变量、集合和流程控制*中定义的函数的 Objective-C 版本。
- en: 'Our most basic function definition didn''t take any arguments and didn''t return
    anything. The Objective-C version looks similar to the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最基本的函数定义没有接受任何参数，也没有返回任何内容。Objective-C 版本看起来类似于以下代码：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Objective-C functions always starts with the type that the function returns
    instead of the keyword `func`. In this case, we aren't actually returning anything,
    so we use the keyword `void` to indicate that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 函数总是以函数返回的类型开头，而不是 `func` 关键字。在这种情况下，我们实际上并没有返回任何内容，所以我们使用 `void`
    关键字来表示。
- en: 'Functions that take arguments and return values have more of a disparity between
    the two languages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接受参数并返回值的函数在这两种语言之间有更大的差异：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, the Objective-C version defines what it is returning at the beginning
    of the function. Also, just like variables, parameters to functions must have
    their type defined before their name instead of after. The rest however, is pretty
    similar: the arguments are contained within parentheses and separated by commas;
    the code of the function is contained within curly brackets and we use the `return`
    keyword to indicate what we want to return.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Objective-C 版本在函数开始处就定义了返回类型。同样，与变量一样，函数的参数必须在名称之前而不是之后定义其类型。然而，其余部分相当相似：参数包含在括号内，并用逗号分隔；函数的代码包含在大括号内，我们使用
    `return` 关键字来指示我们想要返回的内容。
- en: This specific implementation actually brings up an interesting requirement for
    dealing with arrays in Objective-C. Just like we want to avoid mutable arrays
    in Swift, we normally want to avoid them in Objective-C. In this case, we still
    don't want to modify the passed in array, we just want to add the new invitee
    to the end of a copied version. In Swift, because arrays are value types, the
    copy is made for us and we can use the addition operator to add on the new invitee.
    In Objective-C, we need to explicitly make a copy of the array. More than that,
    we need the copy to be mutable so that we can add the new invitee to it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的实现实际上提出了处理Objective-C中数组的一个有趣的要求。就像我们希望在Swift中避免可变数组一样，我们通常也希望在Objective-C中避免它们。在这种情况下，我们仍然不想修改传入的数组，我们只想将新邀请者添加到复制的版本末尾。在Swift中，因为数组是值类型，复制是自动进行的，我们可以使用加法运算符来添加新邀请者。在Objective-C中，我们需要显式地复制数组。更重要的是，我们需要这个复制是可变的，这样我们才能向其中添加新邀请者。
- en: All in all, the biggest difference between Swift functions and Objective-C methods
    is the definition of the return value being at the beginning or the end of the
    parameters. The memory is handled in the same way in both languages. When passing
    in a pointer in Objective-C, the pointer itself is copied but both versions are
    going to reference the exact same instance. When a value type is passed into a
    function in Swift, the value is simply copied and the two versions have nothing
    to do with each other after that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些加在一起，Swift函数和Objective-C方法之间最大的区别是返回值的定义位于参数的开始或结束位置。两种语言都以相同的方式处理内存。当在Objective-C中传递指针时，指针本身被复制，但两个版本都将引用同一个实例。当值类型在Swift中传递给函数时，值被简单地复制，之后两个版本之间没有任何关系。
- en: Types
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: The type system in Objective-C is a little bit more disparate than Swift. This
    is because the structures and enumerations in Objective-C come from C. Only classes
    and categories come from the Objective-C extension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的类型系统比Swift稍微复杂一些。这是因为Objective-C中的结构和枚举来自C语言。只有类和类别来自Objective-C的扩展。
- en: Structures
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构
- en: 'In Swift, structures are very similar to classes, but in Objective-C, they
    are much more different. Structures in Objective-C are essentially just a way
    of giving a name to a collection of individual types. They cannot contain methods.
    Even more restrictive than that, structures can''t contain Objective-C types.
    This leaves us with only basic possibilities:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，结构与类非常相似，但在Objective-C中，它们差别很大。Objective-C中的结构本质上只是给一组单独的类型命名的一种方式。它们不能包含方法。甚至更为严格的是，结构不能包含Objective-C类型。这让我们只剩下基本的可能性：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Structures in Objective-C start with the keyword `typedef`, which is short for
    type definition. This is then followed by the `struct` keyword and the different
    components of the structure contained within curly brackets. Finally, after the
    curly brackets is the name of the structure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的结构以关键字`typedef`开始，它是类型定义的简称。然后是`struct`关键字，以及包含在花括号内的结构的不同组成部分。最后，在花括号之后是结构的名称。
- en: Advanced C programmers will do a lot more with structures. There are ways to
    simulate some features of inheritance with structures and to do other more advanced
    things, but that is beyond the scope of this book and not very relevant in most
    modern programming projects. There are some types in Apple's APIs that are structures
    like CGRect so you should know how to interact with them, but you most likely
    won't have to deal with custom structure definitions when looking at Objective-C
    resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 高级C程序员会更多地使用结构。有一些方法可以模拟继承的一些功能，以及进行其他更高级的操作，但这超出了本书的范围，并且在大多数现代编程项目中并不相关。在Apple的API中，有一些类型是结构，比如CGRect，所以你应该知道如何与之交互，但在查看Objective-C资源时，你很可能不需要处理自定义结构定义。
- en: Enumerations
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enumerations are also much more restrictive in Objective-C. They are really
    just a simple mechanism to represent a finite list of related possible values.
    This allows us to still represent possible primary colors:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在Objective-C中也非常受限。它们实际上只是一个简单的机制，用于表示一系列相关的可能值。这允许我们仍然表示可能的基本颜色：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Just like with structures, Objective-C enumerations start with the keyword `typedef`
    followed by `enum` with the name at the end of the definition. Each case is contained
    within the curly brackets and separated by a comma.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像结构一样，Objective-C枚举以关键字`typedef`开始，然后是`enum`，定义的末尾是名称。每个情况都包含在花括号内，并用逗号分隔。
- en: Notice that every case of the enumeration starts with the name of the enumeration.
    This is a very common convention, to make it easy for code completion and to show
    all possible values of an enumeration. This is because in Objective-C, you cannot
    specify a specific enumeration value through the name of the enumeration itself.
    Instead, every case is its own keyword. This is why when we are assigning our
    `color` variable to blue; we use the case name by itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，枚举的每个情况都以枚举的名称开头。这是一个非常常见的约定，使得代码补全变得容易，并显示枚举的所有可能值。这是因为Objective-C中，你不能通过枚举本身的名称来指定特定的枚举值。相反，每个情况都是其自己的关键字。这就是为什么当我们把`color`变量赋值为蓝色时，我们只使用情况名称本身。
- en: 'Enumerations in Objective-C cannot have methods, associated values, or represent
    any other values except for integers. In fact, in Objective-C enumerations, every
    case has a numeric value. If you don''t specify any, they start at `0` and go
    up by `1` for each case. If you want, you can manually specify a value for one
    or more of the cases:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的枚举不能有方法、关联值或表示任何其他值，除了整数。实际上，在Objective-C枚举中，每个情况都有一个数值。如果你没有指定任何值，它们从`0`开始，每个情况增加`1`。如果你想的话，你可以手动指定一个或多个情况的值：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each case after a manually specified case will continue to increase by one.
    This means that in the preceding code `PrimaryColorRed` is still `0` but `PrimaryColorBlue`
    is `11`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动指定的情况之后，每个情况将继续增加一个。这意味着在前面代码中`PrimaryColorRed`仍然是`0`，但`PrimaryColorBlue`是`11`。
- en: Classes
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Unlike Objective-C structures and enumerations, classes are very similar to
    their Swift counterparts. Objective-C classes can contain methods and properties,
    use inheritance, and get initialized. However, they look pretty different. Most
    notably, a class in Objective-C is split into two parts: its interface and its
    implementation. The interface is intended to be the public interface to the class,
    while the implementation includes the implementation of that interface in addition
    to any other private methods.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与Objective-C的结构体和枚举不同，类与它们的Swift对应物非常相似。Objective-C类可以包含方法属性，使用继承，并且可以初始化。然而，它们看起来相当不同。最值得注意的是，Objective-C中的类分为两部分：其接口和其实现。接口旨在成为类的公共接口，而实现包括该接口的实现以及任何其他私有方法。
- en: Basic class
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本类
- en: 'Let''s start by looking again at our contact class from [Chapter 3](ch03.html
    "Chapter 3. One Piece at a Time – Types, Scopes, and Projects"), *One Piece at
    a Time – Types, Scopes, and Projects* and what it looks like in Objective-C:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看[第3章](ch03.html "第3章。一次一个部分 – 类型、作用域和项目")中的联系人类，*一次一个部分 – 类型、作用域和项目*，以及它在Objective-C中的样子：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Already Objective-C is taking a lot more lines of code. First, we have the interface
    declaration. This begins with the `@interface` keyword and ends with the `@end`
    keyword. Within the square brackets is a list of attributes. These are essentially
    the same as the attributes of a structure, except that you can include Objective-C
    objects in the attributes. These attributes are not commonly written like this
    because using the properties will create these automatically, as we will see later.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多行Objective-C代码了。首先，我们有接口声明。它从`@interface`关键字开始，以`@end`关键字结束。方括号内是一个属性列表。这些属性本质上与结构体的属性相同，只是你可以在属性中包含Objective-C对象。这些属性通常不会这样写，因为使用属性会自动创建它们，就像我们稍后将要看到的那样。
- en: 'You will also notice that our class is inheriting from a class called `NSObject`,
    as indicated by `: NSObject`. This is because every class in Objective-C must
    inherit from `NSObject`, which makes `NSObject` the most basic form of class.
    However, don''t let the term "basic" fool you; `NSObject` provides a lot of functionality.
    We won''t really get into that here, but you should at least be aware of it.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '你还会注意到，我们的类是从名为`NSObject`的类继承的，正如`: NSObject`所示。这是因为Objective-C中的每个类都必须继承自`NSObject`，这使得`NSObject`成为最基本的类形式。然而，不要被“基本”这个词所迷惑；`NSObject`提供了很多功能。我们在这里不会深入探讨，但你至少应该知道这一点。'
- en: The other part of the class is the implementation. It starts with the `@implementation`
    keyword followed by the name of the class we are implementing and then ends again
    with the `@end` keyword. Here, we have not actually added any extra functionality
    to our contact class. However, you may notice that our class is missing something
    that the Swift version has.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类的另一个部分是实现。它以 `@implementation` 关键字开始，后面跟着我们要实现的类名，然后以 `@end` 关键字结束。在这里，我们没有实际上为我们联系人类添加任何额外的功能。然而，你可能注意到我们的类缺少
    Swift 版本中存在的东西。
- en: Initializers
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化器
- en: 'Objective-C does not allow specifying default values for any attributes or
    properties. This means that we have to implement an initializer that sets the
    default values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 不允许为任何属性或属性指定默认值。这意味着我们必须实现一个设置默认值的初始化器：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Objective-C, initializers are the exact same as a method, except that by
    convention they start with the name `init`. This is actually just a convention
    but it is important, as it will cause problems down the line with memory management
    and interacting with the code from Swift.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，初始化器与一个方法完全相同，只是按照惯例它们以 `init` 为名开头。这实际上只是一种惯例，但很重要，因为它会在内存管理和与
    Swift 代码交互时引起后续问题。
- en: 'The minus sign at the beginning indicates that this is a method. Next, the
    return type is specified within parentheses, which is then followed by the name
    of the method: in this case `init`. The body of the method is contained in curly
    brackets just like a function.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 开头带有减号的符号表示这是一个方法。接下来，在括号内指定返回类型，然后是方法名：在这种情况下是 `init`。方法体包含在类似于函数的大括号内。
- en: The return type for all initializers is going to be `id` by convention. This
    allows us to easily override initializers of subclasses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有初始化器的返回类型都将是 `id`，这是惯例。这使我们能够轻松地覆盖子类的初始化器。
- en: Virtually all initializers will follow this same pattern. Just like in Swift,
    `self` references the instance that this method is being called on. The first
    line assigns the `self` reference to the result by calling the superclass's initializer
    with `[super init]`. We then allow for the possibility that the initializer fails
    and returns nil by testing it for nil in the `if (self)` statement. The `if` statement
    will fail if `self` is nil. If it is not nil, we assign the default values. Finally,
    we return self, so that calling code can maintain a reference to the newly initialized
    object. However, this is just a convention and Objective-C does not have any protection
    around properly initializing properties.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有初始化器都将遵循这种相同的模式。就像在 Swift 中一样，`self` 引用被调用的实例。第一行通过调用父类的初始化器 `[super init]`
    将 `self` 引用赋值给结果。然后我们允许初始化器失败并返回 nil 的可能性，通过在 `if (self)` 语句中测试它是否为 nil。如果 `self`
    为 nil，则 `if` 语句将失败。如果不是 nil，我们分配默认值。最后，我们返回 `self`，以便调用代码可以维持对新初始化对象的引用。然而，这只是一个惯例，Objective-C
    没有任何保护措施来确保属性被正确初始化。
- en: Properties
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'The Objective-C version of the contact class still isn''t exactly like the
    Swift version because the `firstName` and `lastName` attributes are not accessible
    from outside the class. To make them accessible we need to define them as public
    properties and we can drop them from being explicit attributes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 版本的联系人类仍然不完全像 Swift 版本，因为 `firstName` 和 `lastName` 属性无法从类外部访问。为了使它们可访问，我们需要将它们定义为公共属性，并可以将它们从显式属性中删除：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the properties are defined outside of the curly brackets but still
    within the `@interface`. In fact, you can leave off the curly brackets altogether
    if you have nothing to define in it. Properties automatically generate attributes
    by the same name except with an underscore at the beginning:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性是在大括号之外但仍在 `@interface` 内定义的。实际上，如果你没有要定义的内容，你可以完全省略大括号。属性会自动生成同名的属性，但名称前有一个下划线：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, you can just set the values using `self`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以直接使用 `self` 来设置值：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are nuances to each approach but for just general reading purposes, it
    doesn't matter which one is used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其细微差别，但仅就一般阅读目的而言，使用哪一种并不重要。
- en: 'Also, just as you can define weak references in Swift, you can do so in Objective-C:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如你可以在 Swift 中定义弱引用一样，你可以在 Objective-C 中这样做：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you want, you can replace `weak` with `strong`, but just like Swift, all
    properties are strong by default. Weak references in Objective-C will automatically
    be set to nil if the referenced object gets deallocated. You can also use the
    `unsafe_unretained` keyword, which is equivalent to unowned in Swift. However,
    this is rarely used as the only difference between the two in Objective-C is that
    `unsafe_unretained` does not reset the value to nil; instead, it will reference
    an invalid object if the object gets deallocated causing confusing crashes if
    used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以用 `strong` 替换 `weak`，但就像 Swift 一样，所有属性默认都是强引用。Objective-C 中的弱引用如果引用的对象被释放，将自动设置为
    nil。你还可以使用 `unsafe_unretained` 关键字，它在 Swift 中相当于 `unowned`。然而，这很少被单独使用，因为在 Objective-C
    中，`unsafe_unretained` 不会将值重置为 nil；相反，如果对象被释放，它将引用一个无效的对象，如果使用它，可能会导致混淆的崩溃。
- en: 'In addition to `weak` or `strong`, you can also specify that a property is
    `readonly` or `readwrite`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `weak` 或 `strong` 之外，你还可以指定属性是 `readonly` 或 `readwrite`：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each property attribute should be written inside the parentheses separated by
    a comma. As the `readonly` name implies, this makes it so that the property can
    be read but not written to. Every property is read-write by default, so normally
    it is not necessary to include it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性属性应该写在括号内，用逗号分隔。正如 `readonly` 名称所暗示的，这使得属性可读但不能写入。每个属性默认都是读写，所以通常不需要包含它。
- en: Note that you may also see the keyword `nonatomic` in the parentheses. This
    is a more advanced topic that is beyond the scope of this book.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可能会在括号中看到关键字 `nonatomic`。这是一个更高级的话题，超出了本书的范围。
- en: Methods
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'We have already seen an example of a method in the form of an initializer,
    but let''s take a look at some methods that take parameters:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个初始化器形式的示例方法，但让我们看看一些带有参数的方法：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Each parameter is defined with a public label followed by a colon, its type
    in parentheses, and an internal name. Then, each parameter is separated by a space
    or new line.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都通过一个冒号后的公共标签定义，括号内是其类型，以及一个内部名称。然后，每个参数通过空格或换行符分隔。
- en: You can also see an example way to format a long method call with the creation
    of the `newString` instance. Similar to Swift, any space can be converted to a
    new line instead. This allows us to convert a single long line into multiple lines,
    as long as we don't put semicolons after the partial lines.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到一种格式化长方法调用的示例，即创建 `newString` 实例。类似于 Swift，任何空格都可以转换为换行符。这允许我们将单行转换为多行，只要我们不在部分行后放置分号。
- en: 'Like Swift, Objective-C also has the idea of class methods. Class methods are
    indicated with a plus sign instead of a minus sign:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Swift 一样，Objective-C 也具有类方法的概念。类方法用加号而不是减号表示：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So now you can call the method directly on the class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你可以直接在类上调用该方法：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Inheritance
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Just as all of our classes so far have inherited from `NSObject`, any class
    can inherit from any other class just like in Swift and all the same rules apply.
    Methods and properties are inherited from their superclass and you can choose
    to override methods in subclasses. However, the compiler enforces the rules much
    less. The compiler does not force you to specify that you intend your method to
    override another. The compiler does not enforce any rules around initializers
    and whom they call. However, all the conventions exist because those conventions
    were the inspiration for the Swift requirements.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们迄今为止的所有类都继承自 `NSObject` 一样，任何类都可以像 Swift 一样继承自任何其他类，并且所有相同的规则都适用。方法和属性从其超类继承，你可以在子类中覆盖方法。然而，编译器对规则的强制程度较低。编译器不会强迫你指定你的方法意图覆盖另一个方法。编译器不会对初始化器和它们调用的对象施加任何规则。然而，所有这些约定都存在，因为这些约定是
    Swift 要求的灵感来源。
- en: Categories
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别
- en: 'Categories in Objective-C are just like Swift extensions. They allow you to
    add new methods to existing classes. They look very similar to plain classes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 中的类别就像 Swift 扩展一样。它们允许你向现有类添加新方法。它们看起来与普通类非常相似：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We know that this is a category instead of a normal class because we added a
    name within parentheses after the class name. Every category on a class must have
    a unique name. In this case, we are calling it `Helpers` and we are adding a method
    to return the contact's full name.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这是一个类别而不是普通类，因为我们已经在类名后面添加了一个括号内的名称。一个类上的每个类别都必须有一个唯一的名称。在这种情况下，我们将其称为 `Helpers`，并添加了一个返回联系人的全名的方法。
- en: Here, for the first time, we are declaring a method inside the interface. This
    is also possible with classes. A method definition looks exactly like an implementation
    except that it ends in a semicolon instead of the code inside the curly brackets.
    This will allow us to call the method from outside the current file, as we will
    see in more detail in the upcoming projects section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们第一次在接口内部声明了一个方法。这也适用于类。方法定义看起来与实现完全相同，只是它以分号结束，而不是花括号内的代码。这将允许我们从当前文件外部调用该方法，正如我们将在即将到来的项目部分中更详细地看到的那样。
- en: 'Categories can also add properties, but you will have to define your own getter
    and setter methods because just like Swift extensions can''t add stored properties,
    Objective-C categories can''t add attributes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类别也可以添加属性，但你必须定义自己的获取器和设置器方法，因为就像Swift扩展不能添加存储属性一样，Objective-C类别也不能添加属性：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These types of properties are very similar to calculated properties. If you
    need to allow reading from a property, you must implement a method with the exact
    same name that takes no parameters and returns the same type. If you want to be
    able to write to the property you will have to implement a method that starts
    with `set`, followed by the same property name with a capital first letter, that
    takes the property type as a parameter and returns nothing. This allows outside
    classes to interact with the property as if it were an attribute, when in fact
    it is just another set of methods. Again, this is possible within a class or a
    category.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的属性与计算属性非常相似。如果你需要允许从属性中读取，你必须实现一个具有完全相同名称的方法，该方法不接受任何参数并返回相同的类型。如果你想能够写入属性，你必须实现一个以`set`开头的方法，后面跟着以大写字母开头的相同属性名称，该方法接受属性类型作为参数并返回无值。这允许外部类以属性属性的方式与属性交互，尽管实际上它只是一组方法。同样，这可以在类或类别中实现。
- en: Protocols
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议
- en: 'Like Swift, Objective-C has the idea of protocols. Their definition looks similar
    to this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Swift一样，Objective-C也有协议的概念。它们的定义看起来类似于以下这样：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we are using the `@protocol` keyword instead of `@interface` and it still
    ends with the `@end` keyword. We can define any properties or methods that we
    want. We can then say that a class implements the protocol similar to this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`@protocol`关键字而不是`@interface`，并且它仍然以`@end`关键字结束。我们可以定义任何我们想要的属性或方法。然后我们可以说一个类实现了这个协议，类似于以下这样：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The list of protocols that a class implements should be listed within angled
    brackets after the class it inherits from separated by commas. In this case we
    are only implementing a single protocol so we don''t need any commas. This code
    also declares a `contents` property, so that we can implement the protocol as
    shown:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类实现的协议列表应该列在它继承的类之后，用尖括号括起来，并用逗号分隔。在这种情况下，我们只实现了一个协议，所以不需要任何逗号。此代码还声明了一个`contents`属性，因此我们可以像下面这样实现协议：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we don't do anything special in the implementation to implement a
    protocol; we just need to make sure the proper methods and computed properties
    are implemented.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在实现中并没有做任何特殊的事情来实现协议；我们只需要确保实现了正确的方法和计算属性。
- en: 'The other thing you should be aware of is that protocols in Objective-C are
    not used in the same way as classes. You can''t just define a variable to be a
    protocol; instead, you must give it a type and require that it implement the protocol.
    Most commonly, this is done with the `id` type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意的另一件事是，Objective-C中的协议并不像类那样使用。你不能仅仅定义一个变量为协议；相反，你必须给它一个类型，并要求它实现该协议。最常见的是使用`id`类型：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Any variable declaration can require that it not only inherits from a specific
    type, but also implements certain protocols.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 任何变量声明都可能要求它不仅继承自特定类型，还实现某些协议。
- en: Blocks
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: 'Lastly, blocks are the Objective-C alternative to closures in Swift. They are
    actually a late addition to Objective-C so their syntax is somewhat complex:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，块是Objective-C中Swift闭包的替代品。实际上，它们是Objective-C的后期添加，因此它们的语法有些复杂：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Let's break this down. We start like any other variable with the variable's
    name and type before the equals sign. The name starts with a carrot symbol (`^`)
    inside the first set of parentheses. In this case, we are calling it `doubleClosure`.
    The actual type of the closure surrounds that. The type it starts with is the
    type the closure returns, which in this case is an `int`. The second set of parentheses
    lists the types of the parameters the closure accepts. In total, this means that
    we are defining a closure called `doubleClosure` that accepts `int` and returns
    `int`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。我们像任何其他变量一样开始，变量名和类型在等号之前。名称以第一个括号内的胡萝卜符号（`^`）开头。在这种情况下，我们将其称为 `doubleClosure`。闭包的实际类型包围着它。它开始的类型是闭包返回的类型，在这个例子中是
    `int`。第二组括号列出了闭包接受的参数类型。总的来说，这意味着我们正在定义一个名为 `doubleClosure` 的闭包，它接受 `int` 并返回
    `int`。
- en: Then, we move on to the business of implementing the closure. All closure implementations
    start with a carrot symbol followed by any arguments in parentheses and curly
    brackets with the actual implementation. Once a closure is defined, it can be
    called similar to any other function. However, you should always be aware that
    it is possible for a closure to be nil, in which calling it will cause the program
    to crash.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向实现闭包的业务。所有闭包实现都以胡萝卜符号开头，后面跟着括号内的任何参数，以及包含实际实现的括号。一旦定义了闭包，就可以像调用任何其他函数一样调用它。然而，你应该始终意识到闭包可能是
    nil，调用它会导致程序崩溃。
- en: 'It is also possible to define a function or method that accepts a closure as
    a parameter. First, a function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以定义一个接受闭包作为参数的函数或方法。首先是一个函数：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that the type `id` signifies any Objective-C object and even though it
    doesn''t have an asterisk, it is a reference type. The usage above looks exactly
    like a standalone block usage. However, the syntax looks somewhat different in
    a method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型 `id` 表示任何 Objective-C 对象，尽管它没有星号，但它是一个引用类型。上面的用法看起来与独立的代码块用法完全一样。然而，在方法中的语法看起来有些不同：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is because a method's parameter name is separated by parentheses. This
    causes the name of the parameter to be moved from being with the carrot to after
    the parentheses. In the end, we can say that the nuances of the syntax aren't
    too important when reading Objective-C code and translating to Swift, as long
    as you recognize that a carrot symbol indicates a block. Many Objective-C programmers
    look up the syntax of a block on a regular basis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为一个方法的参数名称由括号分隔。这导致参数的名称从与胡萝卜符号一起移动到括号之后。最终，我们可以说，在阅读 Objective-C 代码并将其翻译为
    Swift 时，只要认识到胡萝卜符号表示一个代码块，那么语法的细微差别并不太重要。许多 Objective-C 程序员会定期查阅代码块语法的细节。
- en: 'All of the same memory concerns exist in Objective-C with blocks. By default,
    all arguments are captured strongly and the syntax to capture them weakly is much
    more convoluted. Instead of including the weak captures in the block itself, you
    must create weak variables outside of the block and use them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，与代码块相关的所有内存问题都存在。默认情况下，所有参数都是强引用捕获，而弱引用捕获的语法要复杂得多。你必须在代码块外部创建弱变量，并使用它们来捕获：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here we use the keyword `__weak` (that has two underscores) to indicate that
    the `weakBall` variable should only have a weak reference to `ball`. We can then
    safely reference the `weakBall` variable within the block and not create a circular
    reference.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用关键字 `__weak`（有两个下划线）来表示 `weakBall` 变量应该只对 `ball` 有弱引用。然后我们可以在代码块内安全地引用
    `weakBall` 变量，而不会创建循环引用。
- en: Projects
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: Now that we have a pretty good understanding of Objective-C, let's discuss what
    Objective-C code looks like in a project. Unlike the Swift code, Objective-C is
    written in two different types of files. One of the types is called a header file
    and ends in the extension `h`. The other type is called an implementation file
    and ends in the extension `m`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Objective-C 有了一个相当好的理解，让我们讨论一下项目中的 Objective-C 代码看起来是什么样子。与 Swift 代码不同，Objective-C
    使用两种不同类型的文件编写。其中一种类型称为头文件，以扩展名 `h` 结尾。另一种类型称为实现文件，以扩展名 `m` 结尾。
- en: Before we can really discuss what the difference is between the two, we first
    have to discuss code exposure. In Swift, all the code you write is accessible
    to all other code in your project. This is not true with Objective-C. In Objective-C,
    you must explicitly indicate that you want to have access to the code in another
    file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正讨论两者之间的区别之前，我们首先必须讨论代码暴露。在Swift中，你写的所有代码都可以访问项目中的其他所有代码。在Objective-C中并非如此。在Objective-C中，你必须明确表示你想要访问另一个文件中的代码。
- en: Header files
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'The header files are the types of files that can be included by other files.
    This means that header files should only contain the interfaces of types. In fact,
    this is why the separation exists between class interfaces and implementations.
    Any file can import a header file and that essentially inserts all the code of
    one file into the file that is importing it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是其他文件可以包含的文件类型。这意味着头文件应该只包含类型的接口。事实上，这就是为什么类接口和实现之间存在分离。任何文件都可以导入头文件，这实际上是将一个文件的代码插入到导入它的文件中：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This allows us to separate each class into its own file just as we like to do
    in Swift. The danger is that we must only put code that can be safely imported
    into headers. If you try to put implementations in a header, you will end up with
    duplicate implementations for every time you import the header.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将每个类单独放入自己的文件中，就像我们在Swift中喜欢做的那样。危险在于我们必须只将可以安全导入到头文件中的代码放入。如果你试图在头文件中放置实现，你将得到每次导入头文件时的重复实现。
- en: In the preceding example, we actually imported one header file into another.
    This means that if a different file now includes this header file, it will essentially
    be importing both header files.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们实际上是将一个头文件导入到了另一个文件中。这意味着如果现在有另一个文件包含了这个头文件，它实际上会导入这两个头文件。
- en: You will also notice that there are two different ways to import a file. We
    import foundation with angled brackets and imported our car header with quotes.
    Angled brackets are used for importing header files from frameworks, while quotes
    are used for importing header files within the same framework or application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到导入文件有两种不同的方式。我们使用尖括号导入基础文件，而使用引号导入我们的汽车头文件。尖括号用于从框架中导入头文件，而引号用于在同一个框架或应用程序中导入头文件。
- en: 'A lot of the time it isn''t actually necessary for one header file to include
    another because all it needs to know about is the existence of the class. If it
    doesn''t need to know any actual details about the class, it can simply indicate
    that the class exists using the `@class` keyword:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 很多的时间，一个头文件包含另一个头文件实际上并不是必要的，因为它只需要知道类的存在。如果它不需要知道类的任何实际细节，它可以使用`@class`关键字简单地指示类存在：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, the compiler will not complain that it doesn't know what `Car` is. However,
    you will most likely still need to import the car header in the implementation
    file because you will probably be interacting with some part of that class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器不会抱怨它不知道`Car`是什么。然而，你很可能仍然需要在实现文件中导入汽车头文件，因为你很可能会与该类的一些部分进行交互。
- en: Implementation files
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现文件
- en: As you might have guessed, implementation files are generally for the implementation
    of your types. These files are not imported into others; they simply fulfill the
    promises of what the interface files have defined. This means that header and
    implementation files generally exist in pairs. If you are defining a steering
    wheel class, you will most likely create a `SteeringWheel.h` header and a `SteeringWheel.m`
    implementation file. Any other code that needs to interact with the details of
    the steering wheel class will import the header and at compile time, the compiler
    will make all of the implementations available to the running program.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜到的，实现文件通常是用于你的类型的实现。这些文件不会被导入到其他文件中；它们只是履行接口文件定义的承诺。这意味着头文件和实现文件通常成对存在。如果你正在定义方向盘类，你很可能会创建一个`SteeringWheel.h`头文件和一个`SteeringWheel.m`实现文件。任何需要与方向盘类的细节进行交互的其他代码将导入头文件，在编译时，编译器将所有实现提供给运行程序。
- en: 'Implementation files are also a great place to hide private code, because they
    cannot be imported by other code. Since the code is not visible anywhere else,
    it is unlikely to be interacted with. This means that people will sometimes add
    class interfaces to implementation files if their use is localized to just that
    file. It is also very common to add what is called an anonymous category to an
    implementation file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件也是一个很好的地方来隐藏私有代码，因为它们不能被其他代码导入。由于代码在其他任何地方都不可见，因此不太可能被交互。这意味着有时如果类的使用仅限于该文件，人们会向实现文件添加类接口。将所谓的匿名类别添加到实现文件中也是非常常见的：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is considered anonymous because the category was not actually given a name.
    This means there is no way to pair an implementation directly with that category.
    Instead, the implementation should be defined within the normal implementation
    of the class. This provides a great way to define any private properties and methods
    at the top of an implementation file. You don't technically need to define any
    private methods because as long as they are implemented in the same file, they
    can be interacted with. However, it is often nice to have a concise list of the
    available properties and methods at the top of the file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这被认为是匿名的，因为该类别实际上并没有被赋予一个名称。这意味着无法直接将实现与该类别配对。相反，实现应该在类的正常实现中定义。这为在实现文件顶部定义任何私有属性和方法提供了一个很好的方法。从技术上讲，你不需要定义任何私有方法，因为只要它们在同一个文件中实现，就可以进行交互。然而，通常在文件顶部有一个简洁的属性和方法列表会很好。
- en: This brings up another point, that only methods that you intend to use from
    outside files should be declared in the header. You should always consider a header
    to be the public interface of your class and it should be as minimal as possible.
    It is always written from the perspective of outside files. This is the way that
    Objective-C implements access control. It isn't formally built into the language
    but the compiler will warn you if you try to interact with code that has not been
    imported. It is actually still possible to interact with these private interfaces,
    especially if you duplicate the interface declaration somewhere else, but it is
    considered best practice to not do that and Apple will actually reject your apps
    during review if you try to interact with private parts of their API.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这又提出了另一个观点，即只有打算从外部文件使用的方法才应该在头文件中声明。你应该始终将头文件视为你类的公共接口，并且它应该尽可能简单。它总是从外部文件的角度来写。这是Objective-C实现访问控制的方式。它并没有正式地构建到语言中，但编译器会在你尝试与未导入的代码交互时发出警告。实际上，仍然可以与这些私有接口交互，特别是如果你在其他地方复制了接口声明，但被认为是一个最佳实践，不要这样做，并且苹果实际上会在审查期间拒绝你的应用程序，如果你尝试与它们的API的私有部分交互。
- en: Organization
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织
- en: Other than the obvious difference, the Objective-C projects will have two different
    types of files. They are organized in the exact same way as Swift files. It is
    still considered to be a good practice to create folders to group related files
    together. Most of the time you will want to keep header file and implementation
    file pairs together, as people will be switching between the two types of files
    a lot. However, people can also use the keyboard shortcuts *Control*/*Command*
    up arrow or *Control*/*Command* down arrow to quickly swap between a header file
    and its implementation file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的区别之外，Objective-C项目将有两种不同类型的文件。它们的组织方式与Swift文件完全相同。仍然被认为是一个好习惯，创建文件夹来将相关的文件分组在一起。大多数时候，你都会想将头文件和实现文件配对，因为人们会经常在这两种类型的文件之间切换。然而，人们也可以使用键盘快捷键*Control*/*Command*向上箭头或*Control*/*Command*向下箭头来快速在头文件和它的实现文件之间切换。
- en: Calling Objective-C code from Swift
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Swift调用Objective-C代码
- en: The last and possibly the most critical component of understanding Objective-C
    for our purpose is to be able to call Objective-C code from Swift. This is actually
    pretty straightforward in most circumstances. We will not take any time to discuss
    calling Swift code from Objective-C because this book assumes that you are only
    writing Swift code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，理解Objective-C的最后也是可能最重要的一个组成部分是能够从Swift调用Objective-C代码。在大多数情况下，这实际上是非常直接的。我们不会花时间讨论从Objective-C调用Swift代码，因为这本书假设你只编写Swift代码。
- en: Bridging header
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接头文件
- en: 'The most important part of being able to call Objective-C code from Swift is
    how to make the code visible to Swift. As we now know, Objective-C code needs
    to be imported to be visible to other code. This still holds true with Swift,
    but Swift has no mechanism to import individual files. Instead, when you add your
    first Objective-C code to a Swift project, Xcode is going to ask you if you want
    to add what is called a **bridging header**:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 能够从 Swift 调用 Objective-C 代码的最重要部分是如何让代码对 Swift 可见。正如我们所知，Objective-C 代码需要导入才能被其他代码看到。这一点在
    Swift 中仍然适用，但 Swift 没有导入单个文件的机制。相反，当你将第一个 Objective-C 代码添加到 Swift 项目中时，Xcode 会询问你是否想要添加一个称为
    **桥接头** 的文件：
- en: '![Bridging header](img/B05103_10_01.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![桥接头](img/B05103_10_01.jpg)'
- en: You should select **Yes** and then Xcode will automatically create a header
    file named after the project ending in `Bridging-Header.h`. This is the file where
    you need to import any Objective-C headers that you want to expose to Swift. It
    will just be a file with a list of imports. You still do not need to import any
    of the implementation files.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择 **是**，然后 Xcode 将自动创建一个以项目结尾名为 `Bridging-Header.h` 的头文件。这就是你需要导入任何想要暴露给
    Swift 的 Objective-C 头文件的文件。它将只是一个包含导入列表的文件。你仍然不需要导入任何实现文件。
- en: Using functions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数
- en: 'After you have exposed the headers to Swift, it is very simple to call functions.
    You can simply call the functions directly as if they didn''t have parameter names:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在将头文件暴露给 Swift 之后，调用函数非常简单。你可以直接调用函数，就像它们没有参数名称一样：
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Xcode will even autocomplete the code for you. From your Swift files point of
    view, there is no way to know if that function is implemented in Objective-C or
    Swift.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 甚至会为你自动完成代码。从你的 Swift 文件的角度来看，你无法知道该函数是在 Objective-C 中实现还是在 Swift 中实现。
- en: Using types
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型
- en: 'You can use types the same way you use functions. Once the proper header files
    are imported in the bridging header, you can just use the type as if it were a
    Swift type:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类型的方式使用函数。一旦在桥接头文件中导入了适当的头文件，你就可以像使用 Swift 类型一样使用该类型：
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, from Swift's point of view, there is absolutely no difference between
    how we write the code that uses our Objective-C class and how we would write it
    if the class were implemented in Objective-C. We were even able to call the `addToInviteeList:includeLastName:`
    method with the same parameter names. This makes it even more clear that Swift
    was designed with backwards compatibility in mind.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，从 Swift 的角度来看，我们编写使用 Objective-C 类的代码的方式与我们如果该类是在 Objective-C 中实现的方式之间绝对没有区别。我们甚至能够使用相同的参数名称调用
    `addToInviteeList:includeLastName:` 方法。这使得更加清楚，Swift 是在设计时考虑了向后兼容性的。
- en: 'The only real restrictions are that all classes defined in Objective-C are
    still going to inherit from `NSObject` and Objective-C enumerations aren''t going
    to translate perfectly into Swift enumerations. Instead, they are still exposed
    as individual constants:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的限制是，所有在 Objective-C 中定义的类都将继承自 `NSObject`，并且 Objective-C 枚举不会完美地转换为 Swift
    枚举。相反，它们仍然以单个常量的形式暴露出来：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Containers
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: 'You may have also noticed that the `NSString` and `NSArray` types seem to translate
    transparently to `String` and `Array` classes in the preceding code. This is another
    wonderful feature of the bridge between Swift and Objective-C. These types, as
    well as dictionaries, translate almost perfectly. The only difference is that
    since Objective-C does require an element type when defining a container, they
    are translated into Swift as containing objects of type `AnyObject`. If you want
    to treat them as a more specific type, you will have to cast them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，`NSString` 和 `NSArray` 类型似乎在前面的代码中透明地转换为 `String` 和 `Array` 类。这是 Swift
    和 Objective-C 之间桥接的另一个奇妙特性。这些类型，以及字典，几乎完美地转换。唯一的区别是，由于 Objective-C 在定义容器时确实需要一个元素类型，因此它们在
    Swift 中被转换为包含 `AnyObject` 类型的对象。如果你想将它们视为更具体的类型，你必须进行类型转换：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The actual return value of this method when translated to Swift is `[AnyObject]!`.
    Therefore, if you are sure that the method never returns nil and always returns
    an array of `Strings`, it is safe to do the forced casting that we did above.
    Otherwise, you should still check for nil and do an optional casting (`as?`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当此方法转换为 Swift 时，其实际返回值是 `[AnyObject]!`。因此，如果你确定该方法永远不会返回 nil 并且总是返回一个 `Strings`
    数组，那么进行我们上面所做的那种强制转换是安全的。否则，你仍然应该检查 nil 并进行可选转换 (`as?`)。
- en: Annotations
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: You will note that this acts as a pattern when Objective-C types are translated
    to Swift. Any reference type is going to be translated, by default, to an implicitly
    unwrapped optional because of the nature of Objective-C reference types. The compiler
    can't automatically know if the value returned could be nil or not, so it doesn't
    know if it should be translated as a regular optional or a non-optional. However,
    Objective-C developers can add annotations to let the compiler know if a value
    can be nil or not.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当 Objective-C 类型被转换为 Swift 时，这就像是一个模式。任何引用类型默认都会被转换为隐式解包的可选类型，这是由于 Objective-C
    引用类型的特性。编译器无法自动知道返回的值是否可能为 nil，因此它不知道是否应该将其转换为常规可选类型或非可选类型。然而，Objective-C 开发者可以添加注释来让编译器知道一个值是否可能为
    nil。
- en: Nullability
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可空性
- en: 'The first thing Objective-C developers can add annotations for is whether a
    specific variable can be null or not:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 开发者首先可以为特定变量是否可以为 null 添加注释：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `__nonnull` keyword indicates that it cannot be nil, so it will be translated
    in Swift to a non-optional and the `__nullable` keyword indicates that it can
    be nil, so in Swift it will translated to a regular optional.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`__nonnull` 关键字表示它不能为 nil，因此它将在 Swift 中被转换为非可选类型，而 `__nullable` 关键字表示它可以被 nil，因此在
    Swift 中它将被转换为常规可选类型。'
- en: Container element types
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器元素类型
- en: 'Objective-C developer can also annotate their container types to say what type
    they contain. For this, use the angled brackets just like Swift:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 开发者也可以注释他们的容器类型，以说明它们包含的类型。为此，使用与 Swift 一样的尖括号：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, this method will really work just like Swift methods in that it will take
    an optional array of strings and return a non-optional array of strings; there
    will be no casting necessary:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法将真正像 Swift 方法一样工作，它将接受一个可选的字符串数组并返回一个非可选的字符串数组；将不需要进行类型转换：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you have control over the Objective-C code you are importing then you may
    want to add it. Otherwise, you might be able to ask the developer of the code
    to add the annotations to make your Swift coding much easier and more clean.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制着你要导入的 Objective-C 代码，那么你可能想要添加它。否则，你可能能够请求代码的开发者添加注释，以便让你的 Swift 编码更加容易和整洁。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While Swift is the hot new language right now in the Apple development community,
    there is no immediate sign that Objective-C is getting replaced fully. All of
    Apple's APIs are still written in Objective-C and it would be a lot of work for
    Apple to rewrite them, if they even wanted to. Apple definitely designed Swift
    to be able to live alongside Objective-C, so for now we have to assume that Objective-C
    is here to stay. This makes understanding and being able to interact with Objective-C
    very valuable, even as a Swift developer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 目前是苹果开发社区中的热门新语言，但没有迹象表明 Objective-C 将被完全取代。苹果的所有 API 仍然是用 Objective-C
    编写的，如果苹果想要重写它们，这将是一项巨大的工作。苹果肯定设计了 Swift 以能够与 Objective-C 并存，所以现在我们必须假设 Objective-C
    将会持续存在。这使得理解和能够与 Objective-C 交互变得非常有价值，即使作为 Swift 开发者也是如此。
- en: In this chapter, we have gotten an overview of the most pertinent Objective-C
    features and syntax from the point of view of a primarily Swift developer. We
    have learned how Swift is basically a part of a long line of evolving languages.
    It was heavily influenced by Apple's desire to make it backwards compatible with
    Objective-C and Objective-C was actually an evolution of C which was an evolution
    of Assembly and so on. Objective-C is still a powerful language with the ability
    to express many of the same concepts as Swift. Objective-C has similar concepts
    of constants and variables with more of a stress on variables. It also has the
    same basic containers but control flow is slightly different in the two languages.
    Swift has more powerful switches and ranges, but the underlying concepts are still
    very much the same. Functions are almost identical between the two languages but
    the type system in Objective-C is somewhat more limited because it can only express
    classes unlike Swift which has a powerful concept of classes, structures, and
    enumerations. Structures and enumerations still exist in Objective-C, but they
    really come directly from C and can do a lot less. Finally, we saw that organizing
    Objective-C in a project is very much the same and calling Objective-C code from
    Swift is actually quite straightforward.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从主要使用Swift开发者的角度概述了最相关的Objective-C特性和语法。我们了解到Swift基本上是演变语言长河的一部分。它受到了苹果希望使其与Objective-C向后兼容的强烈影响，而Objective-C实际上是C语言的一个演变，C语言又是汇编语言的一个演变，等等。Objective-C仍然是一种强大的语言，能够表达与Swift许多相同的概念。Objective-C有类似常量和变量的概念，但更侧重于变量。它也有相同的基本容器，但两种语言中的控制流略有不同。Swift有更强大的switch和ranges，但底层概念仍然非常相似。函数在这两种语言中几乎是相同的，但Objective-C的类型系统在某种程度上更为有限，因为它只能表达类，而Swift有强大的类、结构和枚举的概念。结构和枚举在Objective-C中仍然存在，但它们实际上直接来自C语言，并且可以做更少的事情。最后，我们看到了在项目中组织Objective-C的方式非常相似，并且从Swift调用Objective-C代码实际上相当直接。
- en: 'There is some debate in the Apple developer community about how relevant Objective-C
    will be moving forward. There are people that have jumped into Swift development
    full time and there are others that are waiting for Swift to mature even more
    before they commit energy to truly learning it. However, there is little debate
    over the fact that Objective-C knowledge is still going to be relevant for a while,
    most notably because of the vast resources that exist and the fact that all existing
    Apple APIs are written in Objective-C. We will put those APIs to use in our next
    chapter: [Chapter 11](ch11.html "Chapter 11. A Whole New World – Developing an
    App"), *A Whole New World – Developing an App*, when we will finally dive into
    some real app development.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果开发者社区中，关于Objective-C在未来将有多大的相关性存在一些争议。有些人已经全职投入到Swift开发中，而有些人则在等待Swift更加成熟后再投入精力真正学习它。然而，关于Objective-C知识在一段时间内仍将保持相关性的事实，争议并不多，尤其是考虑到存在的大量资源和所有现有的苹果API都是用Objective-C编写的。我们将在下一章中利用这些API：[第11章](ch11.html
    "第11章. 一个全新的世界 – 开发一个应用"), *一个全新的世界 – 开发一个应用*，届时我们将最终深入到一些真正的应用开发中。
