- en: Chapter 10. Harnessing the Past – Understanding and Translating Objective-C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 利用过去 – 理解和翻译Objective-C
- en: While Apple's platforms have been around for many years, Swift is still a very
    new language. Even before the release of the first iPhone, Apple's primary language
    of choice was Objective-C. This means that there are a vast number of resources
    in the world for developing on Apple's platforms using Objective-C. There are
    many amazing tutorials, code libraries, articles, and more, that are written in
    Objective-C that are still incredibly valuable for a Swift developer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管苹果的平台已经存在很多年，但Swift仍然是一种非常新的语言。甚至在第一代iPhone发布之前，苹果首选的主要语言就是Objective-C。这意味着世界上有大量使用Objective-C在苹果平台上开发的应用资源。有许多令人惊叹的教程、代码库、文章等等，这些都是在Objective-C中编写的，对于Swift开发者来说仍然非常有价值。
- en: To take advantage of these resources, you must have at least a basic understanding
    of Objective-C, so that you can translate the concepts learned in tutorials and
    articles into Swift, as well as make use of the time tested Objective-C libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用这些资源，您至少需要具备Objective-C的基本理解，这样您才能将教程和文章中学到的概念翻译成Swift，并利用经过时间考验的Objective-C库。
- en: 'In this chapter, we will develop a basic understanding of Objective-C with
    a focus on how it compares to Swift with the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过以下主题来了解Objective-C的基础知识，并关注其与Swift的比较：
- en: Swift's relationship to Objective-C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift与Objective-C的关系
- en: Background of Objective-C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C的背景
- en: Constants and variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量和变量
- en: Containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Control flow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流
- en: Functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型
- en: Projects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目
- en: Calling Objective-C code from Swift
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Swift调用Objective-C代码
- en: Swift's relationship to Objective-C
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift与Objective-C的关系
- en: As we discussed already, Objective-C was previously the primary language for
    developing on Apple's platforms. This means that Objective-C had a lot of influence
    on Swift; the largest of which is that Swift was designed to interoperate with
    Objective-C. Swift code can call Objective-C code and, likewise, Objective-C code
    can call Swift code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Objective-C曾是开发苹果平台应用的主要语言。这意味着Objective-C对Swift产生了很大影响；其中最大的影响是Swift被设计成与Objective-C互操作。Swift代码可以调用Objective-C代码，同样，Objective-C代码也可以调用Swift代码。
- en: Ultimately, Swift was designed, and is still is being designed, to be the next
    step in programming languages, without having to throw away all of our Objective-C
    code. Apple's stated goals for the language are for Swift to be more modern, interactive,
    safe, fast, and powerful. These words would be pretty much meaningless if we didn't
    already have a baseline to compare Swift against. Since Swift was designed primarily
    for Apple's platforms, that baseline is largely Objective-C.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的设计初衷，并且仍在设计中，是为了成为编程语言的下一步，而不必丢弃我们所有的Objective-C代码。苹果对这种语言的目标是使Swift更加现代、交互式、安全、快速和强大。如果我们没有与Swift进行比较的基准，这些话将毫无意义。由于Swift主要设计用于苹果平台，这个基准在很大程度上是Objective-C。
- en: Background of Objective-C
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C的背景
- en: Before we can talk about the details of Objective-C, we need to acknowledge
    its history. Objective-C is based on a language called simply "C". The C programming
    language was one of the first highly portable languages. Portable means that the
    same C code could be compiled to run on any processor as long as someone writes
    a compiler for that platform. Before that, most of the code was written in Assembly;
    which always had to be written specifically for each processor it would run on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够讨论Objective-C的细节之前，我们需要承认其历史。Objective-C基于一种被称为“C”的语言。C编程语言是第一种高度可移植的语言之一。可移植意味着相同的C代码可以被编译成在任何处理器上运行，只要有人为该平台编写一个编译器。在此之前，大多数代码都是用汇编语言编写的；这总是需要针对每个将要运行的处理器进行编写。
- en: C is what is commonly referred to as a procedural programming language. It is
    built on the concept of a series of functions that call each other. It has a very
    basic support to create your own types, but it has no built in concept of objects.
    Objective-C was developed as an object-oriented extension to C. Just as Swift
    is backwards compatible with Objective-C, Objective-C is backwards compatible
    with C. Really, it simply adds object-oriented features on top of C with some
    new syntax and built-in libraries.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: C通常被称为过程式编程语言。它基于一系列相互调用的函数的概念。它提供了非常基本的创建自定义类型的支持，但没有内置的对象概念。Objective-C被开发为C的面向对象扩展。正如Swift与Objective-C向后兼容一样，Objective-C也与C向后兼容。实际上，它只是在C的基础上添加了一些新的语法和内置库，以实现面向对象的功能。
- en: 'The real important thing is that Apple developed their current APIs: Cocoa
    and Cocoa Touch, for Objective-C. This is one of the biggest reasons why Objective-C
    is still very relevant to us as Swift developers. Even though we are primarily
    writing Swift code, we are still going to be regularly interacting with the Cocoa
    and Cocoa Touch libraries written in Objective-C.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Constants and variables
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to dive into the basics of the Objective-C language. Objective-C
    has constants and variables very similar to Swift but they are declared and worked
    with slightly differently. Let''s take a look at declaring a variable in both
    Swift and Objective-C:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line should look familiar, as it is Swift. The Objective-C version
    doesn''t actually look all that different. The important difference is that the
    type of the variable is declared before the name instead of after. It is also
    important to note that Objective-C has no concept of type inference. Every time
    a variable is declared, it must be given a specific type. You will also see that
    there is a semicolon after the name. This is because every line of code in Objective-C
    must end with a semicolon. Lastly, you should notice that we have not explicitly
    declared `number` as a variable. This is because all information is assumed to
    be variable in Objective-C unless specified otherwise. To define `number` as a
    constant, we will add the `const` keyword before its type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Objective-C has value and reference types just like Swift. However, in Objective-C,
    the difference between them is more conceptual.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number we declared above is a value type in both languages. They are copied
    if they are passed to another function and there cannot be more than one variable
    referencing the exact same instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: It is actually easier to determine if a variable is a value type or a reference
    type in Objective-C because, as we will see, virtually all reference types are
    declared with an asterisk (`*`). If there is an asterisk, you can be safe to assume
    that it is a reference type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objective-C actually allows you to make any type a reference type by adding
    an asterisk:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This declares a reference to a number variable, more commonly referred to as
    a **pointer**. In a pointer declaration, the asterisk should always come after
    the type and before the name.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C, reference types are actually loosely mixed with the concept
    of optional in Swift. All reference types are optional because a pointer can always
    point to nil:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A pointer can also always be tested for nil:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To access the referenced value, you must dereference it:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can dereference a pointer by adding an asterisk before it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This is how pointers are similar to optionals in Swift. The difference is that
    there is no way to declare a non-optional reference type in Objective-C. Every
    reference type could technically be nil, even if you design it to never actually
    be nil. This can often add a lot of unnecessary nil checking and means every function
    you write that accepts a reference type should probably deal with the nil case.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the other difference between reference types in the two languages
    is that Objective-C is not very strict when it comes to what type the pointer
    is referencing. For example, Objective-C won''t complain if we create a new double
    reference that points at the same thing as the `int` pointer:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we have two variables: `number` and `another`; they are pointing at the
    same value but assuming that they both are of different types. One of them is
    clearly going to be wrong, but Objective-C will happily try to use the same value
    as both a `double` and an `int` if you try. This is just one bug that Swift makes
    impossible by design.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of the Objective-C code we have looked at is actually strict C.
    We have not used any of the features that Objective-C added onto C. The main thing
    that Objective-C adds to C is its class system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets take a look at our first actual Objective-C type called `NSString` compared
    to the Swift `String` type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like in Swift, you can create a string instance using double quotes; however,
    in Objective-C you must put an `@` sign before it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: One big thing to remember with the Objective-C class system is that it is not
    possible to create an instance of a class that is a value type. All instances
    must be referenced by a reference type. We cannot create a plain `NSString`. It
    must always be an `NSString*` pointer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objective-C has the same exact core containers that Swift does, with the two
    exceptions being that they are named slightly differently, and all of the containers
    in Objective-C are reference types because of the basic requirement that all Objective-C
    types must be reference types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Objective-C arrays are called `NSArray`. Let''s take a look at the initialization
    of an array in both Swift and Objective-C side-by-side:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have defined a variable called `array` that is a reference to the type `NSArray`.
    We then assign it to a newly allocated instance of `NSArray`. The square bracket
    notation in Objective-C allows us to call methods on a type or on an instance.
    Each separate call is always contained within a single set of square brackets.
    In this case, we are first calling the `alloc` method on the `NSArray` class.
    This returns a newly allocated variable that is of the type `NSArray`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to Swift, Objective-C requires a two-step process to initialize
    a new instance. First, the memory must be allocated and then it must be initialized.
    Allocating means that we are reserving the memory for that object and initializing
    it means that we are setting it to its default value. This is what we are doing
    in the second line. The second line asks the instance to initialize itself. We
    reassign the array to the result of the call to `init`, because it is possible
    for `init` to return nil. Note that we are not dereferencing the `array` variable
    in order to make a call on it. We actually call the methods directly on the pointer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is kind of a waste to use two lines to initialize a new instance, so
    often the calls are chained together:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This calls `alloc` on `NSArray` and then immediately calls on `init` on the
    result of that. The `array` variable is then assigned to the result of the `init`
    call. Be aware that it is possible for `alloc` to return nil, in which case we
    would be calling `init` on nil. In Objective-C this is OK; if you call a method
    on nil, it will simply always return nil. This is similar to how optional chaining
    works in Swift.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an alternative to calling `alloc` and `init`; it''s called simply
    `new`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class method allocates and initializes the instance at the same time. This
    is great when you are not passing any arguments into `init`, but you will still
    need to call `alloc` separately when you are passing arguments into it. We will
    see examples of this later on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have not specified what type this array is supposed
    to hold. This is because it is actually not possible. All arrays in Objective-C
    can contain any mix of types as long as they are not C types. This means that
    an `NSArray` cannot contain an `int` (there is an `NSNumber` class instead), but
    it can contain any mix of `NSStrings`, `NSArrays`, or any other Objective-C type.
    The compiler will not do any form of type checking for you, which means that we
    can write code expecting the wrong type to be in the array. This is yet another
    classification of bug that Swift makes impossible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we add objects to our array? The reality is that the `NSArray` class
    does not allow us to add or remove objects from it. In other words, `NSArray`
    is immutable. Instead, there is a version of an array called `NSMutableArray`
    that allows us to add and remove objects. Then we can use the `addObject:` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Methods in Objective-C and Swift are named in the same way with a colon indicating
    each argument. In Objective-C, the colon is also used when calling the method
    to indicate the following code is the value to pass into the method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The existence of a plain `NSArray` is to serve the same basic purpose as a constant
    array in Swift. In fact, we will see that all Objective-C containers are split
    into mutable and non-mutable versions. A mutable container can be passed into
    a method and treated like the non-mutable version to add some safety by not allowing
    unwanted code to modify the array.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to access a value in an `NSArray` we have two options. The full way is
    to use the `objectAtIndex:` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use square brackets, similar to Swift:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that we are just assuming that the type returned from the array is an
    `NSString`. We can just as easily assume that it is another type, say `NSArray`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we know, this will be wrong and will almost certainly cause bugs later in
    the code but the compiler will not complain.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to remove an object from a mutable array, we can use the `removeObjectAtIndex:`
    method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The other important feature that you will need to be aware of is that Objective-C
    also has array literals, so you don''t have to build them up dynamically:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Array literals start with an `@` symbol just like a string, but then it is defined
    by a list of objects within square brackets just like Swift.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more that arrays can do, but you should be able to understand
    what each method does when you see it because most are well named. The methods
    are also often named the same in each language or you can look them up online,
    where Apple has extensive documentation. The purpose of this chapter is just to
    get you comfortable enough to have a high-level understanding of Objective-C code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the same pattern as arrays, dictionaries in Objective-C are called
    `NSDictionary` and `NSMutableDictionary`. A dictionary is initialized in the exact
    same way as shown:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To set a value, we use the `setObject:forKey:` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Just like with arrays, we cannot set new objects on non-mutable dictionaries.
    Also, this is our first example of a method that takes more than one argument.
    As you can see, each argument is contained within the square brackets but separated
    by a space and the label for that argument. In this pattern, Objective-C methods
    can have a number of arguments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to access a value we can use the `objectForKey:` method or square brackets
    again:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, we are assuming that the resulting object being returned is a string,
    because we know what we just put into the dictionary. This assumption isn't always
    safe and we also need to always be aware that this method will return nil if an
    object does not exist for that key.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to remove an object, we can use the `removeObjectForKey:` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is all relatively straightforward, especially when you are reading the
    code. This verbosity was always a great feature of Objective-C to write understandable
    code and this was definitely carried forward into Swift.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries also have literals, but unlike `NSArrays` and Swift array literals,
    dictionary literals in Objective-C are declared using curly brackets. Otherwise,
    it looks very similar to Swift:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Again, we have to start our literal with an `@` symbol. We can also see that
    we can use numbers as objects in our containers as long as we put an `@` symbol
    before each one. Instead of creating something such as an `int` type, this creates
    an `NSNumber` instance. You shouldn't need to know much about the `NSNumber` class
    except that it is a class to represent many different forms of numbers as objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objective-C has many of the same control flow paradigms as Swift. We will go
    through each of them quickly, but before we do, let''s take a look at the Objective-C
    equivalent of `print`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Instead of `print`, we are using a function called `NSLog`. Objective-C does
    not have string interpolation, so `NSLog` is a somewhat more complex solution
    than `print`. The first argument to `NSLog` is a string that describes the format
    to be printed out. This includes a placeholder for each piece of information we
    want to log that indicates the type it should expect. Every placeholder starts
    with a percent symbol. In this case, we are using an at-symbol to indicate what
    we are going to be substituting in a string. Every argument after the initial
    format will be substituted for the placeholders in the same order they are passed
    in. Here, this means that it will end up logging **Hello Sarah** just like the
    Swift code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to look at the different methods of control flow in Objective-C.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A conditional looks exactly the same in both Swift and Objective-C except parentheses
    are required in Objective-C:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can also include those parentheses in Swift, but they are optional. Here,
    you also see that Objective-C still has the idea of the dot syntax for calling
    some methods. In this case, we have used `invitees.count` instead of `[invitees
    count]`. This is only an option when we are accessing a property of the instance
    or we are calling a method that takes no arguments and returns something, as if
    it were a calculated property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Switches
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Switches in Objective-C are profoundly less powerful than switches in Swift.
    In fact, switches are a feature of strict C and are not enhanced at all by Objective-C.
    Switches cannot be used like a series of conditionals; they can only be used to
    do equality comparisons:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, parentheses are required in Objective-C, where they are optional in Swift.
    The most important difference with Objective-C switches is that by default, one
    case will flow into the next unless you specifically use the `break` keyword to
    get out of the switch. That is the opposite of Swift, where it will only flow
    into the next case if you use the `fallthrough` keyword. In practice, this means
    that the vast majority of Objective-C switch cases will need to end with `break`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C switches are not powerful enough to allow us to create cases for
    ranges of values and certainly cannot test a list of arbitrary conditionals like
    we can in Swift.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like conditionals, loops in Objective-C are very similar to Swift. While-loops
    are identical except that the parentheses are required:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The for-in loops are slightly different, in this you must specify the type
    of the variable you are looping through with the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You may have also noticed that when we are looping through an `NSDictionary`
    in Objective-C you only get the key. This is because tuples do not exist in Objective-C.
    Instead, you must access the value from the original dictionary, using the key
    as you loop through.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The other feature that is missing from Objective-C is ranges. To loop through
    a range of numbers, Objective-C programmers must use a different kind of loop
    called a `for` loop:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This loop is made up of three parts: an initial value, a condition to run until,
    and an operation to perform after each loop. This version loops through the numbers
    1 to 10 just like the Swift version. Clearly, it is still possible to translate
    the Swift code into Objective-C; it just isn''t as clean.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Even with that limitation, you can see that Objective-C and Swift loops are
    pretty much the same except for the parentheses requirement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have called some Objective-C functions but we have not defined any
    yet. Let's see what the Objective-C versions are of the functions we defined in
    [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables, Collections, and
    Flow Control"), *Building Blocks – Variables, Collections, and Flow Control*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Our most basic function definition didn''t take any arguments and didn''t return
    anything. The Objective-C version looks similar to the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Objective-C functions always starts with the type that the function returns
    instead of the keyword `func`. In this case, we aren't actually returning anything,
    so we use the keyword `void` to indicate that.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that take arguments and return values have more of a disparity between
    the two languages:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Again, the Objective-C version defines what it is returning at the beginning
    of the function. Also, just like variables, parameters to functions must have
    their type defined before their name instead of after. The rest however, is pretty
    similar: the arguments are contained within parentheses and separated by commas;
    the code of the function is contained within curly brackets and we use the `return`
    keyword to indicate what we want to return.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: This specific implementation actually brings up an interesting requirement for
    dealing with arrays in Objective-C. Just like we want to avoid mutable arrays
    in Swift, we normally want to avoid them in Objective-C. In this case, we still
    don't want to modify the passed in array, we just want to add the new invitee
    to the end of a copied version. In Swift, because arrays are value types, the
    copy is made for us and we can use the addition operator to add on the new invitee.
    In Objective-C, we need to explicitly make a copy of the array. More than that,
    we need the copy to be mutable so that we can add the new invitee to it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的实现实际上提出了处理Objective-C中数组的一个有趣的要求。就像我们希望在Swift中避免可变数组一样，我们通常也希望在Objective-C中避免它们。在这种情况下，我们仍然不想修改传入的数组，我们只想将新邀请者添加到复制的版本末尾。在Swift中，因为数组是值类型，复制是自动进行的，我们可以使用加法运算符来添加新邀请者。在Objective-C中，我们需要显式地复制数组。更重要的是，我们需要这个复制是可变的，这样我们才能向其中添加新邀请者。
- en: All in all, the biggest difference between Swift functions and Objective-C methods
    is the definition of the return value being at the beginning or the end of the
    parameters. The memory is handled in the same way in both languages. When passing
    in a pointer in Objective-C, the pointer itself is copied but both versions are
    going to reference the exact same instance. When a value type is passed into a
    function in Swift, the value is simply copied and the two versions have nothing
    to do with each other after that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些加在一起，Swift函数和Objective-C方法之间最大的区别是返回值的定义位于参数的开始或结束位置。两种语言都以相同的方式处理内存。当在Objective-C中传递指针时，指针本身被复制，但两个版本都将引用同一个实例。当值类型在Swift中传递给函数时，值被简单地复制，之后两个版本之间没有任何关系。
- en: Types
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型
- en: The type system in Objective-C is a little bit more disparate than Swift. This
    is because the structures and enumerations in Objective-C come from C. Only classes
    and categories come from the Objective-C extension.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的类型系统比Swift稍微复杂一些。这是因为Objective-C中的结构和枚举来自C语言。只有类和类别来自Objective-C的扩展。
- en: Structures
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构
- en: 'In Swift, structures are very similar to classes, but in Objective-C, they
    are much more different. Structures in Objective-C are essentially just a way
    of giving a name to a collection of individual types. They cannot contain methods.
    Even more restrictive than that, structures can''t contain Objective-C types.
    This leaves us with only basic possibilities:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，结构与类非常相似，但在Objective-C中，它们差别很大。Objective-C中的结构本质上只是给一组单独的类型命名的一种方式。它们不能包含方法。甚至更为严格的是，结构不能包含Objective-C类型。这让我们只剩下基本的可能性：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Structures in Objective-C start with the keyword `typedef`, which is short for
    type definition. This is then followed by the `struct` keyword and the different
    components of the structure contained within curly brackets. Finally, after the
    curly brackets is the name of the structure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的结构以关键字`typedef`开始，它是类型定义的简称。然后是`struct`关键字，以及包含在花括号内的结构的不同组成部分。最后，在花括号之后是结构的名称。
- en: Advanced C programmers will do a lot more with structures. There are ways to
    simulate some features of inheritance with structures and to do other more advanced
    things, but that is beyond the scope of this book and not very relevant in most
    modern programming projects. There are some types in Apple's APIs that are structures
    like CGRect so you should know how to interact with them, but you most likely
    won't have to deal with custom structure definitions when looking at Objective-C
    resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 高级C程序员会更多地使用结构。有一些方法可以模拟继承的一些功能，以及进行其他更高级的操作，但这超出了本书的范围，并且在大多数现代编程项目中并不相关。在Apple的API中，有一些类型是结构，比如CGRect，所以你应该知道如何与之交互，但在查看Objective-C资源时，你很可能不需要处理自定义结构定义。
- en: Enumerations
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enumerations are also much more restrictive in Objective-C. They are really
    just a simple mechanism to represent a finite list of related possible values.
    This allows us to still represent possible primary colors:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举在Objective-C中也非常受限。它们实际上只是一个简单的机制，用于表示一系列相关的可能值。这允许我们仍然表示可能的基本颜色：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Just like with structures, Objective-C enumerations start with the keyword `typedef`
    followed by `enum` with the name at the end of the definition. Each case is contained
    within the curly brackets and separated by a comma.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像结构一样，Objective-C枚举以关键字`typedef`开始，然后是`enum`，定义的末尾是名称。每个情况都包含在花括号内，并用逗号分隔。
- en: Notice that every case of the enumeration starts with the name of the enumeration.
    This is a very common convention, to make it easy for code completion and to show
    all possible values of an enumeration. This is because in Objective-C, you cannot
    specify a specific enumeration value through the name of the enumeration itself.
    Instead, every case is its own keyword. This is why when we are assigning our
    `color` variable to blue; we use the case name by itself.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，枚举的每个情况都以枚举的名称开头。这是一个非常常见的约定，使得代码补全变得容易，并显示枚举的所有可能值。这是因为Objective-C中，你不能通过枚举本身的名称来指定特定的枚举值。相反，每个情况都是其自己的关键字。这就是为什么当我们把`color`变量赋值为蓝色时，我们只使用情况名称本身。
- en: 'Enumerations in Objective-C cannot have methods, associated values, or represent
    any other values except for integers. In fact, in Objective-C enumerations, every
    case has a numeric value. If you don''t specify any, they start at `0` and go
    up by `1` for each case. If you want, you can manually specify a value for one
    or more of the cases:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的枚举不能有方法、关联值或表示任何其他值，除了整数。实际上，在Objective-C枚举中，每个情况都有一个数值。如果你没有指定任何值，它们从`0`开始，每个情况增加`1`。如果你想的话，你可以手动指定一个或多个情况的值：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Each case after a manually specified case will continue to increase by one.
    This means that in the preceding code `PrimaryColorRed` is still `0` but `PrimaryColorBlue`
    is `11`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动指定的情况之后，每个情况将继续增加一个。这意味着在前面代码中`PrimaryColorRed`仍然是`0`，但`PrimaryColorBlue`是`11`。
- en: Classes
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Unlike Objective-C structures and enumerations, classes are very similar to
    their Swift counterparts. Objective-C classes can contain methods and properties,
    use inheritance, and get initialized. However, they look pretty different. Most
    notably, a class in Objective-C is split into two parts: its interface and its
    implementation. The interface is intended to be the public interface to the class,
    while the implementation includes the implementation of that interface in addition
    to any other private methods.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与Objective-C的结构体和枚举不同，类与它们的Swift对应物非常相似。Objective-C类可以包含方法属性，使用继承，并且可以初始化。然而，它们看起来相当不同。最值得注意的是，Objective-C中的类分为两部分：其接口和其实现。接口旨在成为类的公共接口，而实现包括该接口的实现以及任何其他私有方法。
- en: Basic class
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本类
- en: 'Let''s start by looking again at our contact class from [Chapter 3](ch03.html
    "Chapter 3. One Piece at a Time – Types, Scopes, and Projects"), *One Piece at
    a Time – Types, Scopes, and Projects* and what it looks like in Objective-C:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看[第3章](ch03.html "第3章。一次一个部分 – 类型、作用域和项目")中的联系人类，*一次一个部分 – 类型、作用域和项目*，以及它在Objective-C中的样子：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Already Objective-C is taking a lot more lines of code. First, we have the interface
    declaration. This begins with the `@interface` keyword and ends with the `@end`
    keyword. Within the square brackets is a list of attributes. These are essentially
    the same as the attributes of a structure, except that you can include Objective-C
    objects in the attributes. These attributes are not commonly written like this
    because using the properties will create these automatically, as we will see later.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有很多行Objective-C代码了。首先，我们有接口声明。它从`@interface`关键字开始，以`@end`关键字结束。方括号内是一个属性列表。这些属性本质上与结构体的属性相同，只是你可以在属性中包含Objective-C对象。这些属性通常不会这样写，因为使用属性会自动创建它们，就像我们稍后将要看到的那样。
- en: 'You will also notice that our class is inheriting from a class called `NSObject`,
    as indicated by `: NSObject`. This is because every class in Objective-C must
    inherit from `NSObject`, which makes `NSObject` the most basic form of class.
    However, don''t let the term "basic" fool you; `NSObject` provides a lot of functionality.
    We won''t really get into that here, but you should at least be aware of it.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '你还会注意到，我们的类是从名为`NSObject`的类继承的，正如`: NSObject`所示。这是因为Objective-C中的每个类都必须继承自`NSObject`，这使得`NSObject`成为最基本的类形式。然而，不要被“基本”这个词所迷惑；`NSObject`提供了很多功能。我们在这里不会深入探讨，但你至少应该知道这一点。'
- en: The other part of the class is the implementation. It starts with the `@implementation`
    keyword followed by the name of the class we are implementing and then ends again
    with the `@end` keyword. Here, we have not actually added any extra functionality
    to our contact class. However, you may notice that our class is missing something
    that the Swift version has.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类的另一个部分是实现。它以 `@implementation` 关键字开始，后面跟着我们要实现的类名，然后以 `@end` 关键字结束。在这里，我们没有实际上为我们联系人类添加任何额外的功能。然而，你可能注意到我们的类缺少
    Swift 版本中存在的东西。
- en: Initializers
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化器
- en: 'Objective-C does not allow specifying default values for any attributes or
    properties. This means that we have to implement an initializer that sets the
    default values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 不允许为任何属性或属性指定默认值。这意味着我们必须实现一个设置默认值的初始化器：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In Objective-C, initializers are the exact same as a method, except that by
    convention they start with the name `init`. This is actually just a convention
    but it is important, as it will cause problems down the line with memory management
    and interacting with the code from Swift.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，初始化器与一个方法完全相同，只是按照惯例它们以 `init` 为名开头。这实际上只是一种惯例，但很重要，因为它会在内存管理和与
    Swift 代码交互时引起后续问题。
- en: 'The minus sign at the beginning indicates that this is a method. Next, the
    return type is specified within parentheses, which is then followed by the name
    of the method: in this case `init`. The body of the method is contained in curly
    brackets just like a function.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 开头带有减号的符号表示这是一个方法。接下来，在括号内指定返回类型，然后是方法名：在这种情况下是 `init`。方法体包含在类似于函数的大括号内。
- en: The return type for all initializers is going to be `id` by convention. This
    allows us to easily override initializers of subclasses.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所有初始化器的返回类型都将是 `id`，这是惯例。这使我们能够轻松地覆盖子类的初始化器。
- en: Virtually all initializers will follow this same pattern. Just like in Swift,
    `self` references the instance that this method is being called on. The first
    line assigns the `self` reference to the result by calling the superclass's initializer
    with `[super init]`. We then allow for the possibility that the initializer fails
    and returns nil by testing it for nil in the `if (self)` statement. The `if` statement
    will fail if `self` is nil. If it is not nil, we assign the default values. Finally,
    we return self, so that calling code can maintain a reference to the newly initialized
    object. However, this is just a convention and Objective-C does not have any protection
    around properly initializing properties.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有初始化器都将遵循这种相同的模式。就像在 Swift 中一样，`self` 引用被调用的实例。第一行通过调用父类的初始化器 `[super init]`
    将 `self` 引用赋值给结果。然后我们允许初始化器失败并返回 nil 的可能性，通过在 `if (self)` 语句中测试它是否为 nil。如果 `self`
    为 nil，则 `if` 语句将失败。如果不是 nil，我们分配默认值。最后，我们返回 `self`，以便调用代码可以维持对新初始化对象的引用。然而，这只是一个惯例，Objective-C
    没有任何保护措施来确保属性被正确初始化。
- en: Properties
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'The Objective-C version of the contact class still isn''t exactly like the
    Swift version because the `firstName` and `lastName` attributes are not accessible
    from outside the class. To make them accessible we need to define them as public
    properties and we can drop them from being explicit attributes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 版本的联系人类仍然不完全像 Swift 版本，因为 `firstName` 和 `lastName` 属性无法从类外部访问。为了使它们可访问，我们需要将它们定义为公共属性，并可以将它们从显式属性中删除：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the properties are defined outside of the curly brackets but still
    within the `@interface`. In fact, you can leave off the curly brackets altogether
    if you have nothing to define in it. Properties automatically generate attributes
    by the same name except with an underscore at the beginning:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性是在大括号之外但仍在 `@interface` 内定义的。实际上，如果你没有要定义的内容，你可以完全省略大括号。属性会自动生成同名的属性，但名称前有一个下划线：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, you can just set the values using `self`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以直接使用 `self` 来设置值：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are nuances to each approach but for just general reading purposes, it
    doesn't matter which one is used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都有其细微差别，但仅就一般阅读目的而言，使用哪一种并不重要。
- en: 'Also, just as you can define weak references in Swift, you can do so in Objective-C:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如你可以在 Swift 中定义弱引用一样，你可以在 Objective-C 中这样做：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you want, you can replace `weak` with `strong`, but just like Swift, all
    properties are strong by default. Weak references in Objective-C will automatically
    be set to nil if the referenced object gets deallocated. You can also use the
    `unsafe_unretained` keyword, which is equivalent to unowned in Swift. However,
    this is rarely used as the only difference between the two in Objective-C is that
    `unsafe_unretained` does not reset the value to nil; instead, it will reference
    an invalid object if the object gets deallocated causing confusing crashes if
    used.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `weak` or `strong`, you can also specify that a property is
    `readonly` or `readwrite`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Each property attribute should be written inside the parentheses separated by
    a comma. As the `readonly` name implies, this makes it so that the property can
    be read but not written to. Every property is read-write by default, so normally
    it is not necessary to include it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Note that you may also see the keyword `nonatomic` in the parentheses. This
    is a more advanced topic that is beyond the scope of this book.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already seen an example of a method in the form of an initializer,
    but let''s take a look at some methods that take parameters:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Each parameter is defined with a public label followed by a colon, its type
    in parentheses, and an internal name. Then, each parameter is separated by a space
    or new line.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: You can also see an example way to format a long method call with the creation
    of the `newString` instance. Similar to Swift, any space can be converted to a
    new line instead. This allows us to convert a single long line into multiple lines,
    as long as we don't put semicolons after the partial lines.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Swift, Objective-C also has the idea of class methods. Class methods are
    indicated with a plus sign instead of a minus sign:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So now you can call the method directly on the class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Inheritance
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as all of our classes so far have inherited from `NSObject`, any class
    can inherit from any other class just like in Swift and all the same rules apply.
    Methods and properties are inherited from their superclass and you can choose
    to override methods in subclasses. However, the compiler enforces the rules much
    less. The compiler does not force you to specify that you intend your method to
    override another. The compiler does not enforce any rules around initializers
    and whom they call. However, all the conventions exist because those conventions
    were the inspiration for the Swift requirements.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Categories
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Categories in Objective-C are just like Swift extensions. They allow you to
    add new methods to existing classes. They look very similar to plain classes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We know that this is a category instead of a normal class because we added a
    name within parentheses after the class name. Every category on a class must have
    a unique name. In this case, we are calling it `Helpers` and we are adding a method
    to return the contact's full name.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Here, for the first time, we are declaring a method inside the interface. This
    is also possible with classes. A method definition looks exactly like an implementation
    except that it ends in a semicolon instead of the code inside the curly brackets.
    This will allow us to call the method from outside the current file, as we will
    see in more detail in the upcoming projects section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们第一次在接口内部声明了一个方法。这也适用于类。方法定义看起来与实现完全相同，只是它以分号结束，而不是花括号内的代码。这将允许我们从当前文件外部调用该方法，正如我们将在即将到来的项目部分中更详细地看到的那样。
- en: 'Categories can also add properties, but you will have to define your own getter
    and setter methods because just like Swift extensions can''t add stored properties,
    Objective-C categories can''t add attributes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 类别也可以添加属性，但你必须定义自己的获取器和设置器方法，因为就像Swift扩展不能添加存储属性一样，Objective-C类别也不能添加属性：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These types of properties are very similar to calculated properties. If you
    need to allow reading from a property, you must implement a method with the exact
    same name that takes no parameters and returns the same type. If you want to be
    able to write to the property you will have to implement a method that starts
    with `set`, followed by the same property name with a capital first letter, that
    takes the property type as a parameter and returns nothing. This allows outside
    classes to interact with the property as if it were an attribute, when in fact
    it is just another set of methods. Again, this is possible within a class or a
    category.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的属性与计算属性非常相似。如果你需要允许从属性中读取，你必须实现一个具有完全相同名称的方法，该方法不接受任何参数并返回相同的类型。如果你想能够写入属性，你必须实现一个以`set`开头的方法，后面跟着以大写字母开头的相同属性名称，该方法接受属性类型作为参数并返回无值。这允许外部类以属性属性的方式与属性交互，尽管实际上它只是一组方法。同样，这可以在类或类别中实现。
- en: Protocols
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议
- en: 'Like Swift, Objective-C has the idea of protocols. Their definition looks similar
    to this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Swift一样，Objective-C也有协议的概念。它们的定义看起来类似于以下这样：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we are using the `@protocol` keyword instead of `@interface` and it still
    ends with the `@end` keyword. We can define any properties or methods that we
    want. We can then say that a class implements the protocol similar to this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`@protocol`关键字而不是`@interface`，并且它仍然以`@end`关键字结束。我们可以定义任何我们想要的属性或方法。然后我们可以说一个类实现了这个协议，类似于以下这样：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The list of protocols that a class implements should be listed within angled
    brackets after the class it inherits from separated by commas. In this case we
    are only implementing a single protocol so we don''t need any commas. This code
    also declares a `contents` property, so that we can implement the protocol as
    shown:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类实现的协议列表应该列在它继承的类之后，用尖括号括起来，并用逗号分隔。在这种情况下，我们只实现了一个协议，所以不需要任何逗号。此代码还声明了一个`contents`属性，因此我们可以像下面这样实现协议：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we don't do anything special in the implementation to implement a
    protocol; we just need to make sure the proper methods and computed properties
    are implemented.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在实现中并没有做任何特殊的事情来实现协议；我们只需要确保实现了正确的方法和计算属性。
- en: 'The other thing you should be aware of is that protocols in Objective-C are
    not used in the same way as classes. You can''t just define a variable to be a
    protocol; instead, you must give it a type and require that it implement the protocol.
    Most commonly, this is done with the `id` type:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该注意的另一件事是，Objective-C中的协议并不像类那样使用。你不能仅仅定义一个变量为协议；相反，你必须给它一个类型，并要求它实现该协议。最常见的是使用`id`类型：
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Any variable declaration can require that it not only inherits from a specific
    type, but also implements certain protocols.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 任何变量声明都可能要求它不仅继承自特定类型，还实现某些协议。
- en: Blocks
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块
- en: 'Lastly, blocks are the Objective-C alternative to closures in Swift. They are
    actually a late addition to Objective-C so their syntax is somewhat complex:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，块是Objective-C中Swift闭包的替代品。实际上，它们是Objective-C的后期添加，因此它们的语法有些复杂：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Let's break this down. We start like any other variable with the variable's
    name and type before the equals sign. The name starts with a carrot symbol (`^`)
    inside the first set of parentheses. In this case, we are calling it `doubleClosure`.
    The actual type of the closure surrounds that. The type it starts with is the
    type the closure returns, which in this case is an `int`. The second set of parentheses
    lists the types of the parameters the closure accepts. In total, this means that
    we are defining a closure called `doubleClosure` that accepts `int` and returns
    `int`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。我们像任何其他变量一样开始，变量名和类型在等号之前。名称以第一个括号内的胡萝卜符号（`^`）开头。在这种情况下，我们将其称为 `doubleClosure`。闭包的实际类型包围着它。它开始的类型是闭包返回的类型，在这个例子中是
    `int`。第二组括号列出了闭包接受的参数类型。总的来说，这意味着我们正在定义一个名为 `doubleClosure` 的闭包，它接受 `int` 并返回
    `int`。
- en: Then, we move on to the business of implementing the closure. All closure implementations
    start with a carrot symbol followed by any arguments in parentheses and curly
    brackets with the actual implementation. Once a closure is defined, it can be
    called similar to any other function. However, you should always be aware that
    it is possible for a closure to be nil, in which calling it will cause the program
    to crash.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向实现闭包的业务。所有闭包实现都以胡萝卜符号开头，后面跟着括号内的任何参数，以及包含实际实现的括号。一旦定义了闭包，就可以像调用任何其他函数一样调用它。然而，你应该始终意识到闭包可能是
    nil，调用它会导致程序崩溃。
- en: 'It is also possible to define a function or method that accepts a closure as
    a parameter. First, a function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以定义一个接受闭包作为参数的函数或方法。首先是一个函数：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that the type `id` signifies any Objective-C object and even though it
    doesn''t have an asterisk, it is a reference type. The usage above looks exactly
    like a standalone block usage. However, the syntax looks somewhat different in
    a method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型 `id` 表示任何 Objective-C 对象，尽管它没有星号，但它是一个引用类型。上面的用法看起来与独立的代码块用法完全一样。然而，在方法中的语法看起来有些不同：
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is because a method's parameter name is separated by parentheses. This
    causes the name of the parameter to be moved from being with the carrot to after
    the parentheses. In the end, we can say that the nuances of the syntax aren't
    too important when reading Objective-C code and translating to Swift, as long
    as you recognize that a carrot symbol indicates a block. Many Objective-C programmers
    look up the syntax of a block on a regular basis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为一个方法的参数名称由括号分隔。这导致参数的名称从与胡萝卜符号一起移动到括号之后。最终，我们可以说，在阅读 Objective-C 代码并将其翻译为
    Swift 时，只要认识到胡萝卜符号表示一个代码块，那么语法的细微差别并不太重要。许多 Objective-C 程序员会定期查阅代码块语法的细节。
- en: 'All of the same memory concerns exist in Objective-C with blocks. By default,
    all arguments are captured strongly and the syntax to capture them weakly is much
    more convoluted. Instead of including the weak captures in the block itself, you
    must create weak variables outside of the block and use them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中，与代码块相关的所有内存问题都存在。默认情况下，所有参数都是强引用捕获，而弱引用捕获的语法要复杂得多。你必须在代码块外部创建弱变量，并使用它们来捕获：
- en: '[PRE52]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here we use the keyword `__weak` (that has two underscores) to indicate that
    the `weakBall` variable should only have a weak reference to `ball`. We can then
    safely reference the `weakBall` variable within the block and not create a circular
    reference.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用关键字 `__weak`（有两个下划线）来表示 `weakBall` 变量应该只对 `ball` 有弱引用。然后我们可以在代码块内安全地引用
    `weakBall` 变量，而不会创建循环引用。
- en: Projects
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: Now that we have a pretty good understanding of Objective-C, let's discuss what
    Objective-C code looks like in a project. Unlike the Swift code, Objective-C is
    written in two different types of files. One of the types is called a header file
    and ends in the extension `h`. The other type is called an implementation file
    and ends in the extension `m`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Objective-C 有了一个相当好的理解，让我们讨论一下项目中的 Objective-C 代码看起来是什么样子。与 Swift 代码不同，Objective-C
    使用两种不同类型的文件编写。其中一种类型称为头文件，以扩展名 `h` 结尾。另一种类型称为实现文件，以扩展名 `m` 结尾。
- en: Before we can really discuss what the difference is between the two, we first
    have to discuss code exposure. In Swift, all the code you write is accessible
    to all other code in your project. This is not true with Objective-C. In Objective-C,
    you must explicitly indicate that you want to have access to the code in another
    file.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正讨论两者之间的区别之前，我们首先必须讨论代码暴露。在Swift中，你写的所有代码都可以访问项目中的其他所有代码。在Objective-C中并非如此。在Objective-C中，你必须明确表示你想要访问另一个文件中的代码。
- en: Header files
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头文件
- en: 'The header files are the types of files that can be included by other files.
    This means that header files should only contain the interfaces of types. In fact,
    this is why the separation exists between class interfaces and implementations.
    Any file can import a header file and that essentially inserts all the code of
    one file into the file that is importing it:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件是其他文件可以包含的文件类型。这意味着头文件应该只包含类型的接口。事实上，这就是为什么类接口和实现之间存在分离。任何文件都可以导入头文件，这实际上是将一个文件的代码插入到导入它的文件中：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This allows us to separate each class into its own file just as we like to do
    in Swift. The danger is that we must only put code that can be safely imported
    into headers. If you try to put implementations in a header, you will end up with
    duplicate implementations for every time you import the header.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将每个类单独放入自己的文件中，就像我们在Swift中喜欢做的那样。危险在于我们必须只将可以安全导入到头文件中的代码放入。如果你试图在头文件中放置实现，你将得到每次导入头文件时的重复实现。
- en: In the preceding example, we actually imported one header file into another.
    This means that if a different file now includes this header file, it will essentially
    be importing both header files.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们实际上是将一个头文件导入到了另一个文件中。这意味着如果现在有另一个文件包含了这个头文件，它实际上会导入这两个头文件。
- en: You will also notice that there are two different ways to import a file. We
    import foundation with angled brackets and imported our car header with quotes.
    Angled brackets are used for importing header files from frameworks, while quotes
    are used for importing header files within the same framework or application.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到导入文件有两种不同的方式。我们使用尖括号导入基础文件，而使用引号导入我们的汽车头文件。尖括号用于从框架中导入头文件，而引号用于在同一个框架或应用程序中导入头文件。
- en: 'A lot of the time it isn''t actually necessary for one header file to include
    another because all it needs to know about is the existence of the class. If it
    doesn''t need to know any actual details about the class, it can simply indicate
    that the class exists using the `@class` keyword:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 很多的时间，一个头文件包含另一个头文件实际上并不是必要的，因为它只需要知道类的存在。如果它不需要知道类的任何实际细节，它可以使用`@class`关键字简单地指示类存在：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, the compiler will not complain that it doesn't know what `Car` is. However,
    you will most likely still need to import the car header in the implementation
    file because you will probably be interacting with some part of that class.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编译器不会抱怨它不知道`Car`是什么。然而，你很可能仍然需要在实现文件中导入汽车头文件，因为你很可能会与该类的一些部分进行交互。
- en: Implementation files
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现文件
- en: As you might have guessed, implementation files are generally for the implementation
    of your types. These files are not imported into others; they simply fulfill the
    promises of what the interface files have defined. This means that header and
    implementation files generally exist in pairs. If you are defining a steering
    wheel class, you will most likely create a `SteeringWheel.h` header and a `SteeringWheel.m`
    implementation file. Any other code that needs to interact with the details of
    the steering wheel class will import the header and at compile time, the compiler
    will make all of the implementations available to the running program.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜到的，实现文件通常是用于你的类型的实现。这些文件不会被导入到其他文件中；它们只是履行接口文件定义的承诺。这意味着头文件和实现文件通常成对存在。如果你正在定义方向盘类，你很可能会创建一个`SteeringWheel.h`头文件和一个`SteeringWheel.m`实现文件。任何需要与方向盘类的细节进行交互的其他代码将导入头文件，在编译时，编译器将所有实现提供给运行程序。
- en: 'Implementation files are also a great place to hide private code, because they
    cannot be imported by other code. Since the code is not visible anywhere else,
    it is unlikely to be interacted with. This means that people will sometimes add
    class interfaces to implementation files if their use is localized to just that
    file. It is also very common to add what is called an anonymous category to an
    implementation file:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文件也是一个很好的地方来隐藏私有代码，因为它们不能被其他代码导入。由于代码在其他任何地方都不可见，因此不太可能被交互。这意味着有时如果类的使用仅限于该文件，人们会向实现文件添加类接口。将所谓的匿名类别添加到实现文件中也是非常常见的：
- en: '[PRE55]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is considered anonymous because the category was not actually given a name.
    This means there is no way to pair an implementation directly with that category.
    Instead, the implementation should be defined within the normal implementation
    of the class. This provides a great way to define any private properties and methods
    at the top of an implementation file. You don't technically need to define any
    private methods because as long as they are implemented in the same file, they
    can be interacted with. However, it is often nice to have a concise list of the
    available properties and methods at the top of the file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这被认为是匿名的，因为该类别实际上并没有被赋予一个名称。这意味着无法直接将实现与该类别配对。相反，实现应该在类的正常实现中定义。这为在实现文件顶部定义任何私有属性和方法提供了一个很好的方法。从技术上讲，你不需要定义任何私有方法，因为只要它们在同一个文件中实现，就可以进行交互。然而，通常在文件顶部有一个简洁的属性和方法列表会很好。
- en: This brings up another point, that only methods that you intend to use from
    outside files should be declared in the header. You should always consider a header
    to be the public interface of your class and it should be as minimal as possible.
    It is always written from the perspective of outside files. This is the way that
    Objective-C implements access control. It isn't formally built into the language
    but the compiler will warn you if you try to interact with code that has not been
    imported. It is actually still possible to interact with these private interfaces,
    especially if you duplicate the interface declaration somewhere else, but it is
    considered best practice to not do that and Apple will actually reject your apps
    during review if you try to interact with private parts of their API.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这又提出了另一个观点，即只有打算从外部文件使用的方法才应该在头文件中声明。你应该始终将头文件视为你类的公共接口，并且它应该尽可能简单。它总是从外部文件的角度来写。这是Objective-C实现访问控制的方式。它并没有正式地构建到语言中，但编译器会在你尝试与未导入的代码交互时发出警告。实际上，仍然可以与这些私有接口交互，特别是如果你在其他地方复制了接口声明，但被认为是一个最佳实践，不要这样做，并且苹果实际上会在审查期间拒绝你的应用程序，如果你尝试与它们的API的私有部分交互。
- en: Organization
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织
- en: Other than the obvious difference, the Objective-C projects will have two different
    types of files. They are organized in the exact same way as Swift files. It is
    still considered to be a good practice to create folders to group related files
    together. Most of the time you will want to keep header file and implementation
    file pairs together, as people will be switching between the two types of files
    a lot. However, people can also use the keyboard shortcuts *Control*/*Command*
    up arrow or *Control*/*Command* down arrow to quickly swap between a header file
    and its implementation file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了明显的区别之外，Objective-C项目将有两种不同类型的文件。它们的组织方式与Swift文件完全相同。仍然被认为是一个好习惯，创建文件夹来将相关的文件分组在一起。大多数时候，你都会想将头文件和实现文件配对，因为人们会经常在这两种类型的文件之间切换。然而，人们也可以使用键盘快捷键*Control*/*Command*向上箭头或*Control*/*Command*向下箭头来快速在头文件和它的实现文件之间切换。
- en: Calling Objective-C code from Swift
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Swift调用Objective-C代码
- en: The last and possibly the most critical component of understanding Objective-C
    for our purpose is to be able to call Objective-C code from Swift. This is actually
    pretty straightforward in most circumstances. We will not take any time to discuss
    calling Swift code from Objective-C because this book assumes that you are only
    writing Swift code.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的来说，理解Objective-C的最后也是可能最重要的一个组成部分是能够从Swift调用Objective-C代码。在大多数情况下，这实际上是非常直接的。我们不会花时间讨论从Objective-C调用Swift代码，因为这本书假设你只编写Swift代码。
- en: Bridging header
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接头文件
- en: 'The most important part of being able to call Objective-C code from Swift is
    how to make the code visible to Swift. As we now know, Objective-C code needs
    to be imported to be visible to other code. This still holds true with Swift,
    but Swift has no mechanism to import individual files. Instead, when you add your
    first Objective-C code to a Swift project, Xcode is going to ask you if you want
    to add what is called a **bridging header**:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridging header](img/B05103_10_01.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: You should select **Yes** and then Xcode will automatically create a header
    file named after the project ending in `Bridging-Header.h`. This is the file where
    you need to import any Objective-C headers that you want to expose to Swift. It
    will just be a file with a list of imports. You still do not need to import any
    of the implementation files.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Using functions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have exposed the headers to Swift, it is very simple to call functions.
    You can simply call the functions directly as if they didn''t have parameter names:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Xcode will even autocomplete the code for you. From your Swift files point of
    view, there is no way to know if that function is implemented in Objective-C or
    Swift.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Using types
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use types the same way you use functions. Once the proper header files
    are imported in the bridging header, you can just use the type as if it were a
    Swift type:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Again, from Swift's point of view, there is absolutely no difference between
    how we write the code that uses our Objective-C class and how we would write it
    if the class were implemented in Objective-C. We were even able to call the `addToInviteeList:includeLastName:`
    method with the same parameter names. This makes it even more clear that Swift
    was designed with backwards compatibility in mind.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'The only real restrictions are that all classes defined in Objective-C are
    still going to inherit from `NSObject` and Objective-C enumerations aren''t going
    to translate perfectly into Swift enumerations. Instead, they are still exposed
    as individual constants:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Containers
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have also noticed that the `NSString` and `NSArray` types seem to translate
    transparently to `String` and `Array` classes in the preceding code. This is another
    wonderful feature of the bridge between Swift and Objective-C. These types, as
    well as dictionaries, translate almost perfectly. The only difference is that
    since Objective-C does require an element type when defining a container, they
    are translated into Swift as containing objects of type `AnyObject`. If you want
    to treat them as a more specific type, you will have to cast them:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The actual return value of this method when translated to Swift is `[AnyObject]!`.
    Therefore, if you are sure that the method never returns nil and always returns
    an array of `Strings`, it is safe to do the forced casting that we did above.
    Otherwise, you should still check for nil and do an optional casting (`as?`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will note that this acts as a pattern when Objective-C types are translated
    to Swift. Any reference type is going to be translated, by default, to an implicitly
    unwrapped optional because of the nature of Objective-C reference types. The compiler
    can't automatically know if the value returned could be nil or not, so it doesn't
    know if it should be translated as a regular optional or a non-optional. However,
    Objective-C developers can add annotations to let the compiler know if a value
    can be nil or not.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当 Objective-C 类型被转换为 Swift 时，这就像是一个模式。任何引用类型默认都会被转换为隐式解包的可选类型，这是由于 Objective-C
    引用类型的特性。编译器无法自动知道返回的值是否可能为 nil，因此它不知道是否应该将其转换为常规可选类型或非可选类型。然而，Objective-C 开发者可以添加注释来让编译器知道一个值是否可能为
    nil。
- en: Nullability
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可空性
- en: 'The first thing Objective-C developers can add annotations for is whether a
    specific variable can be null or not:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 开发者首先可以为特定变量是否可以为 null 添加注释：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `__nonnull` keyword indicates that it cannot be nil, so it will be translated
    in Swift to a non-optional and the `__nullable` keyword indicates that it can
    be nil, so in Swift it will translated to a regular optional.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`__nonnull` 关键字表示它不能为 nil，因此它将在 Swift 中被转换为非可选类型，而 `__nullable` 关键字表示它可以被 nil，因此在
    Swift 中它将被转换为常规可选类型。'
- en: Container element types
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器元素类型
- en: 'Objective-C developer can also annotate their container types to say what type
    they contain. For this, use the angled brackets just like Swift:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 开发者也可以注释他们的容器类型，以说明它们包含的类型。为此，使用与 Swift 一样的尖括号：
- en: '[PRE61]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, this method will really work just like Swift methods in that it will take
    an optional array of strings and return a non-optional array of strings; there
    will be no casting necessary:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法将真正像 Swift 方法一样工作，它将接受一个可选的字符串数组并返回一个非可选的字符串数组；将不需要进行类型转换：
- en: '[PRE62]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you have control over the Objective-C code you are importing then you may
    want to add it. Otherwise, you might be able to ask the developer of the code
    to add the annotations to make your Swift coding much easier and more clean.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制着你要导入的 Objective-C 代码，那么你可能想要添加它。否则，你可能能够请求代码的开发者添加注释，以便让你的 Swift 编码更加容易和整洁。
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While Swift is the hot new language right now in the Apple development community,
    there is no immediate sign that Objective-C is getting replaced fully. All of
    Apple's APIs are still written in Objective-C and it would be a lot of work for
    Apple to rewrite them, if they even wanted to. Apple definitely designed Swift
    to be able to live alongside Objective-C, so for now we have to assume that Objective-C
    is here to stay. This makes understanding and being able to interact with Objective-C
    very valuable, even as a Swift developer.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 目前是苹果开发社区中的热门新语言，但没有迹象表明 Objective-C 将被完全取代。苹果的所有 API 仍然是用 Objective-C
    编写的，如果苹果想要重写它们，这将是一项巨大的工作。苹果肯定设计了 Swift 以能够与 Objective-C 并存，所以现在我们必须假设 Objective-C
    将会持续存在。这使得理解和能够与 Objective-C 交互变得非常有价值，即使作为 Swift 开发者也是如此。
- en: In this chapter, we have gotten an overview of the most pertinent Objective-C
    features and syntax from the point of view of a primarily Swift developer. We
    have learned how Swift is basically a part of a long line of evolving languages.
    It was heavily influenced by Apple's desire to make it backwards compatible with
    Objective-C and Objective-C was actually an evolution of C which was an evolution
    of Assembly and so on. Objective-C is still a powerful language with the ability
    to express many of the same concepts as Swift. Objective-C has similar concepts
    of constants and variables with more of a stress on variables. It also has the
    same basic containers but control flow is slightly different in the two languages.
    Swift has more powerful switches and ranges, but the underlying concepts are still
    very much the same. Functions are almost identical between the two languages but
    the type system in Objective-C is somewhat more limited because it can only express
    classes unlike Swift which has a powerful concept of classes, structures, and
    enumerations. Structures and enumerations still exist in Objective-C, but they
    really come directly from C and can do a lot less. Finally, we saw that organizing
    Objective-C in a project is very much the same and calling Objective-C code from
    Swift is actually quite straightforward.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从主要使用Swift开发者的角度概述了最相关的Objective-C特性和语法。我们了解到Swift基本上是演变语言长河的一部分。它受到了苹果希望使其与Objective-C向后兼容的强烈影响，而Objective-C实际上是C语言的一个演变，C语言又是汇编语言的一个演变，等等。Objective-C仍然是一种强大的语言，能够表达与Swift许多相同的概念。Objective-C有类似常量和变量的概念，但更侧重于变量。它也有相同的基本容器，但两种语言中的控制流略有不同。Swift有更强大的switch和ranges，但底层概念仍然非常相似。函数在这两种语言中几乎是相同的，但Objective-C的类型系统在某种程度上更为有限，因为它只能表达类，而Swift有强大的类、结构和枚举的概念。结构和枚举在Objective-C中仍然存在，但它们实际上直接来自C语言，并且可以做更少的事情。最后，我们看到了在项目中组织Objective-C的方式非常相似，并且从Swift调用Objective-C代码实际上相当直接。
- en: 'There is some debate in the Apple developer community about how relevant Objective-C
    will be moving forward. There are people that have jumped into Swift development
    full time and there are others that are waiting for Swift to mature even more
    before they commit energy to truly learning it. However, there is little debate
    over the fact that Objective-C knowledge is still going to be relevant for a while,
    most notably because of the vast resources that exist and the fact that all existing
    Apple APIs are written in Objective-C. We will put those APIs to use in our next
    chapter: [Chapter 11](ch11.html "Chapter 11. A Whole New World – Developing an
    App"), *A Whole New World – Developing an App*, when we will finally dive into
    some real app development.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在苹果开发者社区中，关于Objective-C在未来将有多大的相关性存在一些争议。有些人已经全职投入到Swift开发中，而有些人则在等待Swift更加成熟后再投入精力真正学习它。然而，关于Objective-C知识在一段时间内仍将保持相关性的事实，争议并不多，尤其是考虑到存在的大量资源和所有现有的苹果API都是用Objective-C编写的。我们将在下一章中利用这些API：[第11章](ch11.html
    "第11章. 一个全新的世界 – 开发一个应用"), *一个全新的世界 – 开发一个应用*，届时我们将最终深入到一些真正的应用开发中。
