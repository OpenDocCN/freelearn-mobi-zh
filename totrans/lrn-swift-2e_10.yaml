- en: Chapter 10. Harnessing the Past – Understanding and Translating Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Apple's platforms have been around for many years, Swift is still a very
    new language. Even before the release of the first iPhone, Apple's primary language
    of choice was Objective-C. This means that there are a vast number of resources
    in the world for developing on Apple's platforms using Objective-C. There are
    many amazing tutorials, code libraries, articles, and more, that are written in
    Objective-C that are still incredibly valuable for a Swift developer.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of these resources, you must have at least a basic understanding
    of Objective-C, so that you can translate the concepts learned in tutorials and
    articles into Swift, as well as make use of the time tested Objective-C libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will develop a basic understanding of Objective-C with
    a focus on how it compares to Swift with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Swift's relationship to Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background of Objective-C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling Objective-C code from Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift's relationship to Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed already, Objective-C was previously the primary language for
    developing on Apple's platforms. This means that Objective-C had a lot of influence
    on Swift; the largest of which is that Swift was designed to interoperate with
    Objective-C. Swift code can call Objective-C code and, likewise, Objective-C code
    can call Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, Swift was designed, and is still is being designed, to be the next
    step in programming languages, without having to throw away all of our Objective-C
    code. Apple's stated goals for the language are for Swift to be more modern, interactive,
    safe, fast, and powerful. These words would be pretty much meaningless if we didn't
    already have a baseline to compare Swift against. Since Swift was designed primarily
    for Apple's platforms, that baseline is largely Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Background of Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can talk about the details of Objective-C, we need to acknowledge
    its history. Objective-C is based on a language called simply "C". The C programming
    language was one of the first highly portable languages. Portable means that the
    same C code could be compiled to run on any processor as long as someone writes
    a compiler for that platform. Before that, most of the code was written in Assembly;
    which always had to be written specifically for each processor it would run on.
  prefs: []
  type: TYPE_NORMAL
- en: C is what is commonly referred to as a procedural programming language. It is
    built on the concept of a series of functions that call each other. It has a very
    basic support to create your own types, but it has no built in concept of objects.
    Objective-C was developed as an object-oriented extension to C. Just as Swift
    is backwards compatible with Objective-C, Objective-C is backwards compatible
    with C. Really, it simply adds object-oriented features on top of C with some
    new syntax and built-in libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real important thing is that Apple developed their current APIs: Cocoa
    and Cocoa Touch, for Objective-C. This is one of the biggest reasons why Objective-C
    is still very relevant to us as Swift developers. Even though we are primarily
    writing Swift code, we are still going to be regularly interacting with the Cocoa
    and Cocoa Touch libraries written in Objective-C.'
  prefs: []
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to dive into the basics of the Objective-C language. Objective-C
    has constants and variables very similar to Swift but they are declared and worked
    with slightly differently. Let''s take a look at declaring a variable in both
    Swift and Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line should look familiar, as it is Swift. The Objective-C version
    doesn''t actually look all that different. The important difference is that the
    type of the variable is declared before the name instead of after. It is also
    important to note that Objective-C has no concept of type inference. Every time
    a variable is declared, it must be given a specific type. You will also see that
    there is a semicolon after the name. This is because every line of code in Objective-C
    must end with a semicolon. Lastly, you should notice that we have not explicitly
    declared `number` as a variable. This is because all information is assumed to
    be variable in Objective-C unless specified otherwise. To define `number` as a
    constant, we will add the `const` keyword before its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Objective-C has value and reference types just like Swift. However, in Objective-C,
    the difference between them is more conceptual.
  prefs: []
  type: TYPE_NORMAL
- en: Value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number we declared above is a value type in both languages. They are copied
    if they are passed to another function and there cannot be more than one variable
    referencing the exact same instance.
  prefs: []
  type: TYPE_NORMAL
- en: It is actually easier to determine if a variable is a value type or a reference
    type in Objective-C because, as we will see, virtually all reference types are
    declared with an asterisk (`*`). If there is an asterisk, you can be safe to assume
    that it is a reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objective-C actually allows you to make any type a reference type by adding
    an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This declares a reference to a number variable, more commonly referred to as
    a **pointer**. In a pointer declaration, the asterisk should always come after
    the type and before the name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Objective-C, reference types are actually loosely mixed with the concept
    of optional in Swift. All reference types are optional because a pointer can always
    point to nil:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A pointer can also always be tested for nil:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the referenced value, you must dereference it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can dereference a pointer by adding an asterisk before it.
  prefs: []
  type: TYPE_NORMAL
- en: This is how pointers are similar to optionals in Swift. The difference is that
    there is no way to declare a non-optional reference type in Objective-C. Every
    reference type could technically be nil, even if you design it to never actually
    be nil. This can often add a lot of unnecessary nil checking and means every function
    you write that accepts a reference type should probably deal with the nil case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the other difference between reference types in the two languages
    is that Objective-C is not very strict when it comes to what type the pointer
    is referencing. For example, Objective-C won''t complain if we create a new double
    reference that points at the same thing as the `int` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two variables: `number` and `another`; they are pointing at the
    same value but assuming that they both are of different types. One of them is
    clearly going to be wrong, but Objective-C will happily try to use the same value
    as both a `double` and an `int` if you try. This is just one bug that Swift makes
    impossible by design.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of the Objective-C code we have looked at is actually strict C.
    We have not used any of the features that Objective-C added onto C. The main thing
    that Objective-C adds to C is its class system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets take a look at our first actual Objective-C type called `NSString` compared
    to the Swift `String` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just like in Swift, you can create a string instance using double quotes; however,
    in Objective-C you must put an `@` sign before it.
  prefs: []
  type: TYPE_NORMAL
- en: One big thing to remember with the Objective-C class system is that it is not
    possible to create an instance of a class that is a value type. All instances
    must be referenced by a reference type. We cannot create a plain `NSString`. It
    must always be an `NSString*` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objective-C has the same exact core containers that Swift does, with the two
    exceptions being that they are named slightly differently, and all of the containers
    in Objective-C are reference types because of the basic requirement that all Objective-C
    types must be reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Objective-C arrays are called `NSArray`. Let''s take a look at the initialization
    of an array in both Swift and Objective-C side-by-side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a variable called `array` that is a reference to the type `NSArray`.
    We then assign it to a newly allocated instance of `NSArray`. The square bracket
    notation in Objective-C allows us to call methods on a type or on an instance.
    Each separate call is always contained within a single set of square brackets.
    In this case, we are first calling the `alloc` method on the `NSArray` class.
    This returns a newly allocated variable that is of the type `NSArray`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to Swift, Objective-C requires a two-step process to initialize
    a new instance. First, the memory must be allocated and then it must be initialized.
    Allocating means that we are reserving the memory for that object and initializing
    it means that we are setting it to its default value. This is what we are doing
    in the second line. The second line asks the instance to initialize itself. We
    reassign the array to the result of the call to `init`, because it is possible
    for `init` to return nil. Note that we are not dereferencing the `array` variable
    in order to make a call on it. We actually call the methods directly on the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is kind of a waste to use two lines to initialize a new instance, so
    often the calls are chained together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This calls `alloc` on `NSArray` and then immediately calls on `init` on the
    result of that. The `array` variable is then assigned to the result of the `init`
    call. Be aware that it is possible for `alloc` to return nil, in which case we
    would be calling `init` on nil. In Objective-C this is OK; if you call a method
    on nil, it will simply always return nil. This is similar to how optional chaining
    works in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an alternative to calling `alloc` and `init`; it''s called simply
    `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This class method allocates and initializes the instance at the same time. This
    is great when you are not passing any arguments into `init`, but you will still
    need to call `alloc` separately when you are passing arguments into it. We will
    see examples of this later on.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we have not specified what type this array is supposed
    to hold. This is because it is actually not possible. All arrays in Objective-C
    can contain any mix of types as long as they are not C types. This means that
    an `NSArray` cannot contain an `int` (there is an `NSNumber` class instead), but
    it can contain any mix of `NSStrings`, `NSArrays`, or any other Objective-C type.
    The compiler will not do any form of type checking for you, which means that we
    can write code expecting the wrong type to be in the array. This is yet another
    classification of bug that Swift makes impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we add objects to our array? The reality is that the `NSArray` class
    does not allow us to add or remove objects from it. In other words, `NSArray`
    is immutable. Instead, there is a version of an array called `NSMutableArray`
    that allows us to add and remove objects. Then we can use the `addObject:` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Methods in Objective-C and Swift are named in the same way with a colon indicating
    each argument. In Objective-C, the colon is also used when calling the method
    to indicate the following code is the value to pass into the method.
  prefs: []
  type: TYPE_NORMAL
- en: The existence of a plain `NSArray` is to serve the same basic purpose as a constant
    array in Swift. In fact, we will see that all Objective-C containers are split
    into mutable and non-mutable versions. A mutable container can be passed into
    a method and treated like the non-mutable version to add some safety by not allowing
    unwanted code to modify the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to access a value in an `NSArray` we have two options. The full way is
    to use the `objectAtIndex:` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use square brackets, similar to Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are just assuming that the type returned from the array is an
    `NSString`. We can just as easily assume that it is another type, say `NSArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we know, this will be wrong and will almost certainly cause bugs later in
    the code but the compiler will not complain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to remove an object from a mutable array, we can use the `removeObjectAtIndex:`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The other important feature that you will need to be aware of is that Objective-C
    also has array literals, so you don''t have to build them up dynamically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Array literals start with an `@` symbol just like a string, but then it is defined
    by a list of objects within square brackets just like Swift.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more that arrays can do, but you should be able to understand
    what each method does when you see it because most are well named. The methods
    are also often named the same in each language or you can look them up online,
    where Apple has extensive documentation. The purpose of this chapter is just to
    get you comfortable enough to have a high-level understanding of Objective-C code.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following the same pattern as arrays, dictionaries in Objective-C are called
    `NSDictionary` and `NSMutableDictionary`. A dictionary is initialized in the exact
    same way as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To set a value, we use the `setObject:forKey:` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Just like with arrays, we cannot set new objects on non-mutable dictionaries.
    Also, this is our first example of a method that takes more than one argument.
    As you can see, each argument is contained within the square brackets but separated
    by a space and the label for that argument. In this pattern, Objective-C methods
    can have a number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to access a value we can use the `objectForKey:` method or square brackets
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are assuming that the resulting object being returned is a string,
    because we know what we just put into the dictionary. This assumption isn't always
    safe and we also need to always be aware that this method will return nil if an
    object does not exist for that key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, to remove an object, we can use the `removeObjectForKey:` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is all relatively straightforward, especially when you are reading the
    code. This verbosity was always a great feature of Objective-C to write understandable
    code and this was definitely carried forward into Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries also have literals, but unlike `NSArrays` and Swift array literals,
    dictionary literals in Objective-C are declared using curly brackets. Otherwise,
    it looks very similar to Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Again, we have to start our literal with an `@` symbol. We can also see that
    we can use numbers as objects in our containers as long as we put an `@` symbol
    before each one. Instead of creating something such as an `int` type, this creates
    an `NSNumber` instance. You shouldn't need to know much about the `NSNumber` class
    except that it is a class to represent many different forms of numbers as objects.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Objective-C has many of the same control flow paradigms as Swift. We will go
    through each of them quickly, but before we do, let''s take a look at the Objective-C
    equivalent of `print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `print`, we are using a function called `NSLog`. Objective-C does
    not have string interpolation, so `NSLog` is a somewhat more complex solution
    than `print`. The first argument to `NSLog` is a string that describes the format
    to be printed out. This includes a placeholder for each piece of information we
    want to log that indicates the type it should expect. Every placeholder starts
    with a percent symbol. In this case, we are using an at-symbol to indicate what
    we are going to be substituting in a string. Every argument after the initial
    format will be substituted for the placeholders in the same order they are passed
    in. Here, this means that it will end up logging **Hello Sarah** just like the
    Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to look at the different methods of control flow in Objective-C.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A conditional looks exactly the same in both Swift and Objective-C except parentheses
    are required in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can also include those parentheses in Swift, but they are optional. Here,
    you also see that Objective-C still has the idea of the dot syntax for calling
    some methods. In this case, we have used `invitees.count` instead of `[invitees
    count]`. This is only an option when we are accessing a property of the instance
    or we are calling a method that takes no arguments and returns something, as if
    it were a calculated property.
  prefs: []
  type: TYPE_NORMAL
- en: Switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Switches in Objective-C are profoundly less powerful than switches in Swift.
    In fact, switches are a feature of strict C and are not enhanced at all by Objective-C.
    Switches cannot be used like a series of conditionals; they can only be used to
    do equality comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, parentheses are required in Objective-C, where they are optional in Swift.
    The most important difference with Objective-C switches is that by default, one
    case will flow into the next unless you specifically use the `break` keyword to
    get out of the switch. That is the opposite of Swift, where it will only flow
    into the next case if you use the `fallthrough` keyword. In practice, this means
    that the vast majority of Objective-C switch cases will need to end with `break`.
  prefs: []
  type: TYPE_NORMAL
- en: Objective-C switches are not powerful enough to allow us to create cases for
    ranges of values and certainly cannot test a list of arbitrary conditionals like
    we can in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like conditionals, loops in Objective-C are very similar to Swift. While-loops
    are identical except that the parentheses are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The for-in loops are slightly different, in this you must specify the type
    of the variable you are looping through with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You may have also noticed that when we are looping through an `NSDictionary`
    in Objective-C you only get the key. This is because tuples do not exist in Objective-C.
    Instead, you must access the value from the original dictionary, using the key
    as you loop through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other feature that is missing from Objective-C is ranges. To loop through
    a range of numbers, Objective-C programmers must use a different kind of loop
    called a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This loop is made up of three parts: an initial value, a condition to run until,
    and an operation to perform after each loop. This version loops through the numbers
    1 to 10 just like the Swift version. Clearly, it is still possible to translate
    the Swift code into Objective-C; it just isn''t as clean.'
  prefs: []
  type: TYPE_NORMAL
- en: Even with that limitation, you can see that Objective-C and Swift loops are
    pretty much the same except for the parentheses requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have called some Objective-C functions but we have not defined any
    yet. Let's see what the Objective-C versions are of the functions we defined in
    [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables, Collections, and
    Flow Control"), *Building Blocks – Variables, Collections, and Flow Control*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our most basic function definition didn''t take any arguments and didn''t return
    anything. The Objective-C version looks similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Objective-C functions always starts with the type that the function returns
    instead of the keyword `func`. In this case, we aren't actually returning anything,
    so we use the keyword `void` to indicate that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that take arguments and return values have more of a disparity between
    the two languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the Objective-C version defines what it is returning at the beginning
    of the function. Also, just like variables, parameters to functions must have
    their type defined before their name instead of after. The rest however, is pretty
    similar: the arguments are contained within parentheses and separated by commas;
    the code of the function is contained within curly brackets and we use the `return`
    keyword to indicate what we want to return.'
  prefs: []
  type: TYPE_NORMAL
- en: This specific implementation actually brings up an interesting requirement for
    dealing with arrays in Objective-C. Just like we want to avoid mutable arrays
    in Swift, we normally want to avoid them in Objective-C. In this case, we still
    don't want to modify the passed in array, we just want to add the new invitee
    to the end of a copied version. In Swift, because arrays are value types, the
    copy is made for us and we can use the addition operator to add on the new invitee.
    In Objective-C, we need to explicitly make a copy of the array. More than that,
    we need the copy to be mutable so that we can add the new invitee to it.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, the biggest difference between Swift functions and Objective-C methods
    is the definition of the return value being at the beginning or the end of the
    parameters. The memory is handled in the same way in both languages. When passing
    in a pointer in Objective-C, the pointer itself is copied but both versions are
    going to reference the exact same instance. When a value type is passed into a
    function in Swift, the value is simply copied and the two versions have nothing
    to do with each other after that.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type system in Objective-C is a little bit more disparate than Swift. This
    is because the structures and enumerations in Objective-C come from C. Only classes
    and categories come from the Objective-C extension.
  prefs: []
  type: TYPE_NORMAL
- en: Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Swift, structures are very similar to classes, but in Objective-C, they
    are much more different. Structures in Objective-C are essentially just a way
    of giving a name to a collection of individual types. They cannot contain methods.
    Even more restrictive than that, structures can''t contain Objective-C types.
    This leaves us with only basic possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Structures in Objective-C start with the keyword `typedef`, which is short for
    type definition. This is then followed by the `struct` keyword and the different
    components of the structure contained within curly brackets. Finally, after the
    curly brackets is the name of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced C programmers will do a lot more with structures. There are ways to
    simulate some features of inheritance with structures and to do other more advanced
    things, but that is beyond the scope of this book and not very relevant in most
    modern programming projects. There are some types in Apple's APIs that are structures
    like CGRect so you should know how to interact with them, but you most likely
    won't have to deal with custom structure definitions when looking at Objective-C
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enumerations are also much more restrictive in Objective-C. They are really
    just a simple mechanism to represent a finite list of related possible values.
    This allows us to still represent possible primary colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Just like with structures, Objective-C enumerations start with the keyword `typedef`
    followed by `enum` with the name at the end of the definition. Each case is contained
    within the curly brackets and separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that every case of the enumeration starts with the name of the enumeration.
    This is a very common convention, to make it easy for code completion and to show
    all possible values of an enumeration. This is because in Objective-C, you cannot
    specify a specific enumeration value through the name of the enumeration itself.
    Instead, every case is its own keyword. This is why when we are assigning our
    `color` variable to blue; we use the case name by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enumerations in Objective-C cannot have methods, associated values, or represent
    any other values except for integers. In fact, in Objective-C enumerations, every
    case has a numeric value. If you don''t specify any, they start at `0` and go
    up by `1` for each case. If you want, you can manually specify a value for one
    or more of the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Each case after a manually specified case will continue to increase by one.
    This means that in the preceding code `PrimaryColorRed` is still `0` but `PrimaryColorBlue`
    is `11`.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike Objective-C structures and enumerations, classes are very similar to
    their Swift counterparts. Objective-C classes can contain methods and properties,
    use inheritance, and get initialized. However, they look pretty different. Most
    notably, a class in Objective-C is split into two parts: its interface and its
    implementation. The interface is intended to be the public interface to the class,
    while the implementation includes the implementation of that interface in addition
    to any other private methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by looking again at our contact class from [Chapter 3](ch03.html
    "Chapter 3. One Piece at a Time – Types, Scopes, and Projects"), *One Piece at
    a Time – Types, Scopes, and Projects* and what it looks like in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Already Objective-C is taking a lot more lines of code. First, we have the interface
    declaration. This begins with the `@interface` keyword and ends with the `@end`
    keyword. Within the square brackets is a list of attributes. These are essentially
    the same as the attributes of a structure, except that you can include Objective-C
    objects in the attributes. These attributes are not commonly written like this
    because using the properties will create these automatically, as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice that our class is inheriting from a class called `NSObject`,
    as indicated by `: NSObject`. This is because every class in Objective-C must
    inherit from `NSObject`, which makes `NSObject` the most basic form of class.
    However, don''t let the term "basic" fool you; `NSObject` provides a lot of functionality.
    We won''t really get into that here, but you should at least be aware of it.'
  prefs: []
  type: TYPE_NORMAL
- en: The other part of the class is the implementation. It starts with the `@implementation`
    keyword followed by the name of the class we are implementing and then ends again
    with the `@end` keyword. Here, we have not actually added any extra functionality
    to our contact class. However, you may notice that our class is missing something
    that the Swift version has.
  prefs: []
  type: TYPE_NORMAL
- en: Initializers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objective-C does not allow specifying default values for any attributes or
    properties. This means that we have to implement an initializer that sets the
    default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In Objective-C, initializers are the exact same as a method, except that by
    convention they start with the name `init`. This is actually just a convention
    but it is important, as it will cause problems down the line with memory management
    and interacting with the code from Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'The minus sign at the beginning indicates that this is a method. Next, the
    return type is specified within parentheses, which is then followed by the name
    of the method: in this case `init`. The body of the method is contained in curly
    brackets just like a function.'
  prefs: []
  type: TYPE_NORMAL
- en: The return type for all initializers is going to be `id` by convention. This
    allows us to easily override initializers of subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Virtually all initializers will follow this same pattern. Just like in Swift,
    `self` references the instance that this method is being called on. The first
    line assigns the `self` reference to the result by calling the superclass's initializer
    with `[super init]`. We then allow for the possibility that the initializer fails
    and returns nil by testing it for nil in the `if (self)` statement. The `if` statement
    will fail if `self` is nil. If it is not nil, we assign the default values. Finally,
    we return self, so that calling code can maintain a reference to the newly initialized
    object. However, this is just a convention and Objective-C does not have any protection
    around properly initializing properties.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Objective-C version of the contact class still isn''t exactly like the
    Swift version because the `firstName` and `lastName` attributes are not accessible
    from outside the class. To make them accessible we need to define them as public
    properties and we can drop them from being explicit attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the properties are defined outside of the curly brackets but still
    within the `@interface`. In fact, you can leave off the curly brackets altogether
    if you have nothing to define in it. Properties automatically generate attributes
    by the same name except with an underscore at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can just set the values using `self`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There are nuances to each approach but for just general reading purposes, it
    doesn't matter which one is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, just as you can define weak references in Swift, you can do so in Objective-C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can replace `weak` with `strong`, but just like Swift, all
    properties are strong by default. Weak references in Objective-C will automatically
    be set to nil if the referenced object gets deallocated. You can also use the
    `unsafe_unretained` keyword, which is equivalent to unowned in Swift. However,
    this is rarely used as the only difference between the two in Objective-C is that
    `unsafe_unretained` does not reset the value to nil; instead, it will reference
    an invalid object if the object gets deallocated causing confusing crashes if
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `weak` or `strong`, you can also specify that a property is
    `readonly` or `readwrite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Each property attribute should be written inside the parentheses separated by
    a comma. As the `readonly` name implies, this makes it so that the property can
    be read but not written to. Every property is read-write by default, so normally
    it is not necessary to include it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you may also see the keyword `nonatomic` in the parentheses. This
    is a more advanced topic that is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already seen an example of a method in the form of an initializer,
    but let''s take a look at some methods that take parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Each parameter is defined with a public label followed by a colon, its type
    in parentheses, and an internal name. Then, each parameter is separated by a space
    or new line.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see an example way to format a long method call with the creation
    of the `newString` instance. Similar to Swift, any space can be converted to a
    new line instead. This allows us to convert a single long line into multiple lines,
    as long as we don't put semicolons after the partial lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Swift, Objective-C also has the idea of class methods. Class methods are
    indicated with a plus sign instead of a minus sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'So now you can call the method directly on the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as all of our classes so far have inherited from `NSObject`, any class
    can inherit from any other class just like in Swift and all the same rules apply.
    Methods and properties are inherited from their superclass and you can choose
    to override methods in subclasses. However, the compiler enforces the rules much
    less. The compiler does not force you to specify that you intend your method to
    override another. The compiler does not enforce any rules around initializers
    and whom they call. However, all the conventions exist because those conventions
    were the inspiration for the Swift requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Categories in Objective-C are just like Swift extensions. They allow you to
    add new methods to existing classes. They look very similar to plain classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We know that this is a category instead of a normal class because we added a
    name within parentheses after the class name. Every category on a class must have
    a unique name. In this case, we are calling it `Helpers` and we are adding a method
    to return the contact's full name.
  prefs: []
  type: TYPE_NORMAL
- en: Here, for the first time, we are declaring a method inside the interface. This
    is also possible with classes. A method definition looks exactly like an implementation
    except that it ends in a semicolon instead of the code inside the curly brackets.
    This will allow us to call the method from outside the current file, as we will
    see in more detail in the upcoming projects section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Categories can also add properties, but you will have to define your own getter
    and setter methods because just like Swift extensions can''t add stored properties,
    Objective-C categories can''t add attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: These types of properties are very similar to calculated properties. If you
    need to allow reading from a property, you must implement a method with the exact
    same name that takes no parameters and returns the same type. If you want to be
    able to write to the property you will have to implement a method that starts
    with `set`, followed by the same property name with a capital first letter, that
    takes the property type as a parameter and returns nothing. This allows outside
    classes to interact with the property as if it were an attribute, when in fact
    it is just another set of methods. Again, this is possible within a class or a
    category.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like Swift, Objective-C has the idea of protocols. Their definition looks similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `@protocol` keyword instead of `@interface` and it still
    ends with the `@end` keyword. We can define any properties or methods that we
    want. We can then say that a class implements the protocol similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of protocols that a class implements should be listed within angled
    brackets after the class it inherits from separated by commas. In this case we
    are only implementing a single protocol so we don''t need any commas. This code
    also declares a `contents` property, so that we can implement the protocol as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't do anything special in the implementation to implement a
    protocol; we just need to make sure the proper methods and computed properties
    are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing you should be aware of is that protocols in Objective-C are
    not used in the same way as classes. You can''t just define a variable to be a
    protocol; instead, you must give it a type and require that it implement the protocol.
    Most commonly, this is done with the `id` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Any variable declaration can require that it not only inherits from a specific
    type, but also implements certain protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, blocks are the Objective-C alternative to closures in Swift. They are
    actually a late addition to Objective-C so their syntax is somewhat complex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Let's break this down. We start like any other variable with the variable's
    name and type before the equals sign. The name starts with a carrot symbol (`^`)
    inside the first set of parentheses. In this case, we are calling it `doubleClosure`.
    The actual type of the closure surrounds that. The type it starts with is the
    type the closure returns, which in this case is an `int`. The second set of parentheses
    lists the types of the parameters the closure accepts. In total, this means that
    we are defining a closure called `doubleClosure` that accepts `int` and returns
    `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we move on to the business of implementing the closure. All closure implementations
    start with a carrot symbol followed by any arguments in parentheses and curly
    brackets with the actual implementation. Once a closure is defined, it can be
    called similar to any other function. However, you should always be aware that
    it is possible for a closure to be nil, in which calling it will cause the program
    to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to define a function or method that accepts a closure as
    a parameter. First, a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the type `id` signifies any Objective-C object and even though it
    doesn''t have an asterisk, it is a reference type. The usage above looks exactly
    like a standalone block usage. However, the syntax looks somewhat different in
    a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is because a method's parameter name is separated by parentheses. This
    causes the name of the parameter to be moved from being with the carrot to after
    the parentheses. In the end, we can say that the nuances of the syntax aren't
    too important when reading Objective-C code and translating to Swift, as long
    as you recognize that a carrot symbol indicates a block. Many Objective-C programmers
    look up the syntax of a block on a regular basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the same memory concerns exist in Objective-C with blocks. By default,
    all arguments are captured strongly and the syntax to capture them weakly is much
    more convoluted. Instead of including the weak captures in the block itself, you
    must create weak variables outside of the block and use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the keyword `__weak` (that has two underscores) to indicate that
    the `weakBall` variable should only have a weak reference to `ball`. We can then
    safely reference the `weakBall` variable within the block and not create a circular
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a pretty good understanding of Objective-C, let's discuss what
    Objective-C code looks like in a project. Unlike the Swift code, Objective-C is
    written in two different types of files. One of the types is called a header file
    and ends in the extension `h`. The other type is called an implementation file
    and ends in the extension `m`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can really discuss what the difference is between the two, we first
    have to discuss code exposure. In Swift, all the code you write is accessible
    to all other code in your project. This is not true with Objective-C. In Objective-C,
    you must explicitly indicate that you want to have access to the code in another
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Header files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The header files are the types of files that can be included by other files.
    This means that header files should only contain the interfaces of types. In fact,
    this is why the separation exists between class interfaces and implementations.
    Any file can import a header file and that essentially inserts all the code of
    one file into the file that is importing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to separate each class into its own file just as we like to do
    in Swift. The danger is that we must only put code that can be safely imported
    into headers. If you try to put implementations in a header, you will end up with
    duplicate implementations for every time you import the header.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we actually imported one header file into another.
    This means that if a different file now includes this header file, it will essentially
    be importing both header files.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that there are two different ways to import a file. We
    import foundation with angled brackets and imported our car header with quotes.
    Angled brackets are used for importing header files from frameworks, while quotes
    are used for importing header files within the same framework or application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of the time it isn''t actually necessary for one header file to include
    another because all it needs to know about is the existence of the class. If it
    doesn''t need to know any actual details about the class, it can simply indicate
    that the class exists using the `@class` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, the compiler will not complain that it doesn't know what `Car` is. However,
    you will most likely still need to import the car header in the implementation
    file because you will probably be interacting with some part of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might have guessed, implementation files are generally for the implementation
    of your types. These files are not imported into others; they simply fulfill the
    promises of what the interface files have defined. This means that header and
    implementation files generally exist in pairs. If you are defining a steering
    wheel class, you will most likely create a `SteeringWheel.h` header and a `SteeringWheel.m`
    implementation file. Any other code that needs to interact with the details of
    the steering wheel class will import the header and at compile time, the compiler
    will make all of the implementations available to the running program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation files are also a great place to hide private code, because they
    cannot be imported by other code. Since the code is not visible anywhere else,
    it is unlikely to be interacted with. This means that people will sometimes add
    class interfaces to implementation files if their use is localized to just that
    file. It is also very common to add what is called an anonymous category to an
    implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is considered anonymous because the category was not actually given a name.
    This means there is no way to pair an implementation directly with that category.
    Instead, the implementation should be defined within the normal implementation
    of the class. This provides a great way to define any private properties and methods
    at the top of an implementation file. You don't technically need to define any
    private methods because as long as they are implemented in the same file, they
    can be interacted with. However, it is often nice to have a concise list of the
    available properties and methods at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: This brings up another point, that only methods that you intend to use from
    outside files should be declared in the header. You should always consider a header
    to be the public interface of your class and it should be as minimal as possible.
    It is always written from the perspective of outside files. This is the way that
    Objective-C implements access control. It isn't formally built into the language
    but the compiler will warn you if you try to interact with code that has not been
    imported. It is actually still possible to interact with these private interfaces,
    especially if you duplicate the interface declaration somewhere else, but it is
    considered best practice to not do that and Apple will actually reject your apps
    during review if you try to interact with private parts of their API.
  prefs: []
  type: TYPE_NORMAL
- en: Organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other than the obvious difference, the Objective-C projects will have two different
    types of files. They are organized in the exact same way as Swift files. It is
    still considered to be a good practice to create folders to group related files
    together. Most of the time you will want to keep header file and implementation
    file pairs together, as people will be switching between the two types of files
    a lot. However, people can also use the keyboard shortcuts *Control*/*Command*
    up arrow or *Control*/*Command* down arrow to quickly swap between a header file
    and its implementation file.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Objective-C code from Swift
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last and possibly the most critical component of understanding Objective-C
    for our purpose is to be able to call Objective-C code from Swift. This is actually
    pretty straightforward in most circumstances. We will not take any time to discuss
    calling Swift code from Objective-C because this book assumes that you are only
    writing Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: Bridging header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important part of being able to call Objective-C code from Swift is
    how to make the code visible to Swift. As we now know, Objective-C code needs
    to be imported to be visible to other code. This still holds true with Swift,
    but Swift has no mechanism to import individual files. Instead, when you add your
    first Objective-C code to a Swift project, Xcode is going to ask you if you want
    to add what is called a **bridging header**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridging header](img/B05103_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should select **Yes** and then Xcode will automatically create a header
    file named after the project ending in `Bridging-Header.h`. This is the file where
    you need to import any Objective-C headers that you want to expose to Swift. It
    will just be a file with a list of imports. You still do not need to import any
    of the implementation files.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have exposed the headers to Swift, it is very simple to call functions.
    You can simply call the functions directly as if they didn''t have parameter names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Xcode will even autocomplete the code for you. From your Swift files point of
    view, there is no way to know if that function is implemented in Objective-C or
    Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Using types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use types the same way you use functions. Once the proper header files
    are imported in the bridging header, you can just use the type as if it were a
    Swift type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Again, from Swift's point of view, there is absolutely no difference between
    how we write the code that uses our Objective-C class and how we would write it
    if the class were implemented in Objective-C. We were even able to call the `addToInviteeList:includeLastName:`
    method with the same parameter names. This makes it even more clear that Swift
    was designed with backwards compatibility in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only real restrictions are that all classes defined in Objective-C are
    still going to inherit from `NSObject` and Objective-C enumerations aren''t going
    to translate perfectly into Swift enumerations. Instead, they are still exposed
    as individual constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have also noticed that the `NSString` and `NSArray` types seem to translate
    transparently to `String` and `Array` classes in the preceding code. This is another
    wonderful feature of the bridge between Swift and Objective-C. These types, as
    well as dictionaries, translate almost perfectly. The only difference is that
    since Objective-C does require an element type when defining a container, they
    are translated into Swift as containing objects of type `AnyObject`. If you want
    to treat them as a more specific type, you will have to cast them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The actual return value of this method when translated to Swift is `[AnyObject]!`.
    Therefore, if you are sure that the method never returns nil and always returns
    an array of `Strings`, it is safe to do the forced casting that we did above.
    Otherwise, you should still check for nil and do an optional casting (`as?`).
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will note that this acts as a pattern when Objective-C types are translated
    to Swift. Any reference type is going to be translated, by default, to an implicitly
    unwrapped optional because of the nature of Objective-C reference types. The compiler
    can't automatically know if the value returned could be nil or not, so it doesn't
    know if it should be translated as a regular optional or a non-optional. However,
    Objective-C developers can add annotations to let the compiler know if a value
    can be nil or not.
  prefs: []
  type: TYPE_NORMAL
- en: Nullability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing Objective-C developers can add annotations for is whether a
    specific variable can be null or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `__nonnull` keyword indicates that it cannot be nil, so it will be translated
    in Swift to a non-optional and the `__nullable` keyword indicates that it can
    be nil, so in Swift it will translated to a regular optional.
  prefs: []
  type: TYPE_NORMAL
- en: Container element types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Objective-C developer can also annotate their container types to say what type
    they contain. For this, use the angled brackets just like Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this method will really work just like Swift methods in that it will take
    an optional array of strings and return a non-optional array of strings; there
    will be no casting necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you have control over the Objective-C code you are importing then you may
    want to add it. Otherwise, you might be able to ask the developer of the code
    to add the annotations to make your Swift coding much easier and more clean.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Swift is the hot new language right now in the Apple development community,
    there is no immediate sign that Objective-C is getting replaced fully. All of
    Apple's APIs are still written in Objective-C and it would be a lot of work for
    Apple to rewrite them, if they even wanted to. Apple definitely designed Swift
    to be able to live alongside Objective-C, so for now we have to assume that Objective-C
    is here to stay. This makes understanding and being able to interact with Objective-C
    very valuable, even as a Swift developer.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have gotten an overview of the most pertinent Objective-C
    features and syntax from the point of view of a primarily Swift developer. We
    have learned how Swift is basically a part of a long line of evolving languages.
    It was heavily influenced by Apple's desire to make it backwards compatible with
    Objective-C and Objective-C was actually an evolution of C which was an evolution
    of Assembly and so on. Objective-C is still a powerful language with the ability
    to express many of the same concepts as Swift. Objective-C has similar concepts
    of constants and variables with more of a stress on variables. It also has the
    same basic containers but control flow is slightly different in the two languages.
    Swift has more powerful switches and ranges, but the underlying concepts are still
    very much the same. Functions are almost identical between the two languages but
    the type system in Objective-C is somewhat more limited because it can only express
    classes unlike Swift which has a powerful concept of classes, structures, and
    enumerations. Structures and enumerations still exist in Objective-C, but they
    really come directly from C and can do a lot less. Finally, we saw that organizing
    Objective-C in a project is very much the same and calling Objective-C code from
    Swift is actually quite straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is some debate in the Apple developer community about how relevant Objective-C
    will be moving forward. There are people that have jumped into Swift development
    full time and there are others that are waiting for Swift to mature even more
    before they commit energy to truly learning it. However, there is little debate
    over the fact that Objective-C knowledge is still going to be relevant for a while,
    most notably because of the vast resources that exist and the fact that all existing
    Apple APIs are written in Objective-C. We will put those APIs to use in our next
    chapter: [Chapter 11](ch11.html "Chapter 11. A Whole New World – Developing an
    App"), *A Whole New World – Developing an App*, when we will finally dive into
    some real app development.'
  prefs: []
  type: TYPE_NORMAL
