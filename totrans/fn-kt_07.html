<html><head></head><body>
        

                            
                    <h1 class="header-title">Asynchronous Programming with Coroutines</h1>
                
            
            
                
<p class="mce-root">Today's software development landscape makes asynchronous processing one of the most important topics. The ever-increasing number of processors and cores and the massive consumption of external services (which has grown in recent years with the adoption of microservices architectures) are some of the factors that we should keep an eye on and strive to use a good asynchronous approach.</p>
<p>Kotlin's implementation of coroutines is an excellent tool to build asynchronous applications.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Coroutines</li>
<li>Alternative approaches</li>
<li>Asynchronous processing</li>
<li>Channels and actors</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction to coroutines</h1>
                
            
            
                
<p>Let's start with a simple example without coroutines:</p>
<pre>import kotlin.concurrent.thread<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   thread {<br/>      Thread.sleep(1000)<br/>      println("World!")<br/>   }<br/>   print("Hello ")<br/>   Thread.sleep(2000)<br/>}</pre>
<p>The <kbd>thread</kbd> function executes a block of code in a different thread. Inside the block, we are simulating an expensive I/O computation (such as accessing data from a microservice over HTTP) with <kbd>Thread.sleep</kbd>. <kbd>Thread.sleep</kbd> will block the current thread for the number of milliseconds passed as a parameter. In this example, we don't wait until the computation finishes to keep working on other things; we print another message, <kbd>"Hello"</kbd>, while the other computation is being executed. At the end, we wait for two seconds until the computation is finished.</p>
<p>That's not a pretty code, and we can do better: </p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val computation = thread {<br/>      Thread.sleep(1000)<br/>      println("World!")<br/>   }<br/>   print("Hello ")<br/>   computation.join()<br/>}</pre>
<p>In this version, we have a reference to our thread called, <kbd>computation</kbd>; at the end, we wait for the <kbd>join()</kbd> method to finish. This is smarter than just waiting for a fixed amount of time, as real-life computations could have different execution times.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding JVM threads</h1>
                
            
            
                
<p>Threads are the building blocks of asynchronous concurrent applications on JVM (and other platforms, too). A JVM thread is, most of the time, backed by a hardware thread (such as a core inside a processor). A hardware thread can support several software threads (a JVM thread is a kind of software thread), but only one software thread is executed at any given time.</p>
<p>The OS (or the JVM) decides which software thread is executed on each hardware thread and switches quickly among the live threads, thereby, giving the appearance that there are several software threads executing at the same time, when in reality there are as many active software threads being executed as there are hardware threads. But, in most circumstances, it is useful to think that all software threads are being performed at the same time. </p>
<p>Threads in JVM are very fast and responsive, but they come at a cost. Each <kbd>Thread</kbd> has a cost in CPU time and memory on creation, disposal (when garbage is collected), and context switch (the process to store and recover a thread's state when it becomes the executing thread or stops being it). Because this cost is relatively high, a JVM application can't have a significant number of threads.</p>
<p>A JVM application on a typical development machine can easily handle 100 threads:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val threads = List(100){<br/>      thread {<br/>         Thread.sleep(1000)<br/>         print('.')<br/>      }<br/>   }<br/>   threads.forEach(Thread::join)<br/>}</pre>
<p>If you use any external application to monitor the JVM application, such as VisualVM or JConsole (among others), you'll see a graphic like this:</p>
<div><img height="582" width="446" src="img/8001e2a4-f132-429f-b70e-395a0d19f861.png"/></div>
<p>We can increase our threads to 1,000 as shown in the following screenshot:</p>
<div><img height="600" width="458" src="img/57378487-0433-49f3-9d6b-a949b372100f.png"/></div>
<p>The amount of memory is growing at a fast rate, reaching more than 1.5 GB.</p>
<p>Can we increase our threads to 10,000? Take a look at the following screenshot:</p>
<div><img height="634" width="487" src="img/7ecf2a92-c546-463f-877c-77b1df3b49f4.png"/></div>
<p>The answer is a blunt no; around 2,020 threads were created when the application died with <kbd>OutOfMemoryError</kbd> (this application was running with default settings; those settings can be changed at startup time).</p>
<p>Let's try with 1,900, a fair estimate of what we can execute safely:</p>
<div><img height="579" width="442" src="img/9bb2bf52-dc3a-483d-8164-cae5b7ea75b2.png"/></div>
<p>Yes, we can run 1,900 concurrent threads.</p>
<p>In modern JVM applications, creating and destroying threads is considered a bad practice; instead, we use <kbd>Executor</kbd>, an abstraction that lets us manage and reuse threads, reducing the cost of creation and disposal:</p>
<pre>import java.util.concurrent.Executors<br/>import java.util.concurrent.TimeUnit<br/><br/>fun main(args: Array&lt;String&gt;){<br/>   val executor = Executors.newFixedThreadPool(1024)<br/>   repeat(10000){<br/>      executor.submit {<br/>         Thread.sleep(1000)<br/>         print('.')<br/>      }<br/>   }<br/>   executor.shutdown() <br/>}</pre>
<p>We created an <kbd>executor</kbd> value that, internally, has a thread pool of up to 1,024 threads. Then, we submit 10,000 tasks; at the end, we shut down <kbd>Executor</kbd>. When we shut down <kbd>Executor</kbd>, it can't accept new tasks and executes all pending ones as follows:</p>
<div><img height="607" width="461" src="img/5908d8bf-a749-4bd4-b949-5f61661ef9e1.png"/></div>
<p>There are many options to fine-tune and play with, <kbd>Executor</kbd>, such as the number of threads and the type of pool or its actual implementation.</p>
<p>There is a lot more theory on JVM threads than is possible to cover in this book. If you want to read and learn more about threads and concurrency, we recommend the classic book, <em>Java Concurrency in Practice (2006)</em> by Dough Lea, David Holmes, Joseph Bower, Joshua Block, Tim Peierls, and Brian Goetz, from Addison-Wesley Professional. We also recommend <em>Programming Concurrency on the JVM (2011)</em> by Venkat Subramanian from Pragmatic Bookshelf, and the <em>Java Concurrency LiveLessons (2015)</em> video by Douglas Schmidt from Addison-Wesley Professional. Last but not least,  we suggest the series of books and videos, <em>Java Concurrency</em> by Javier Fernández Gonzáles, published by Packt. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hello, coroutine world!</h1>
                
            
            
                
<p>Now, let's rewrite our <kbd>Hello World</kbd> application with coroutines.</p>
<p>But, hey! What is a coroutine? Basically, a coroutine is a very light thread that runs a block of code and has a similar life cycle, but can complete with a return value or an exception. Technically, a coroutine is an instance of a suspendable computation, a computation that may suspend. Coroutines aren't bound to a particular thread and can suspend in one <kbd>Thread</kbd> and resume execution in a different one:</p>
<pre>import kotlinx.coroutines.experimental.delay<br/>import kotlinx.coroutines.experimental.launch<br/>import kotlinx.coroutines.experimental.runBlocking<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>    launch {<br/>        delay(1000)<br/>        println("World")<br/>    }<br/>    print("Hello ")<br/>    delay(2000)<br/>}</pre>
<p>There are a few things to cover here:</p>
<ul>
<li><kbd>runBlocking</kbd>: This function creates a coroutine and blocks the current <kbd>Thread</kbd> until the coroutine finishes, returning its result value (<kbd>Unit</kbd> in this case).</li>
<li><kbd>launch</kbd>: This function creates a new coroutine without blocking the current <kbd>Thread</kbd> and returns <kbd>Job</kbd> (ignored here).</li>
<li><kbd>delay</kbd>: This function is a suspending (more on this later) function that delays the current coroutine without blocking the current thread.</li>
<li><kbd>suspend</kbd>: A suspending function is a function that may suspend the execution of a coroutine, without blocking the current <kbd>Thread</kbd>; therefore a suspending function must be called inside a coroutine—it can't be invoked from normal code. The function must be marked with the <kbd>suspend</kbd> modifier. So, <kbd>delay</kbd> can be invoked inside <kbd>runBlocking</kbd> and <kbd>launch</kbd>, both functions (among others) take a suspending lambda as the last parameter—a suspending lambda is a lambda marked with the <kbd>suspend</kbd> modifier.</li>
</ul>
<p>Let's summarize what we know now, and a few other concepts before going further:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Concept</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Coroutine</strong></p>
</td>
<td>
<p>A very light thread that can return a value and can suspend and resume.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Suspending function</strong></p>
</td>
<td>
<p>A function marked with a <kbd>suspend</kbd> modifier. It can suspend a coroutine without blocking the thread. Suspending functions must be invoked inside a coroutine, for example <kbd>delay</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Suspending lambda</strong></p>
</td>
<td>
<p>A lambda function marked with a <kbd>suspend</kbd> modifier. It can suspend a coroutine without blocking the thread.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Coroutine builder</strong></p>
</td>
<td>
<p>A function that takes a suspending lambda, creates a coroutine and may return a result, for example <kbd>runBlocking</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Suspension point</strong></p>
</td>
<td>
<p>A point where a suspending function is invoked.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Continuation</strong></p>
</td>
<td>
<p>The state of a suspended coroutine at a suspension point, it represents the rest of its execution after suspension point.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">Let's get back to business.</p>
<p>As we discussed previously, computations can have different execution times. So, <kbd>delay</kbd> isn't ideal in our <kbd>Hello World</kbd> example:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   val job = launch {<br/>      delay(1000)<br/>      println("World")<br/>   }<br/>   print("Hello ")<br/>   job.join()<br/>}</pre>
<p>As with our example with threads, we take the reference to the job created by <kbd>launch</kbd>, and we suspend it at the end with the suspending function <kbd>join</kbd>.</p>
<p>So far, so good. But are coroutines so very light? Can we have 10,000 coroutines?</p>
<p>Let's try it by executing the following code snippet:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>      val jobs = List(10000) {<br/>         launch {<br/>            delay(1000)<br/>            print('.')<br/>         }<br/>      }<br/>      jobs.forEach { job -&gt; job.join() }<br/>   }<br/>}</pre>
<p>Oh, indeed! It works:</p>
<div><img height="635" width="487" src="img/b4ef915b-0b6c-4500-ae98-3abd33dc1c36.png"/></div>
<p>They are orders of magnitude faster than the <kbd>Executor</kbd> solution, a lot less memory, fewer threads (barely seven threads) and, on top of that, are very easy to read.</p>
<p>Let's go with 1 million coroutines:</p>
<div><img height="550" width="420" src="img/976557d1-0cf2-4969-9415-6f931b29b2aa.png"/></div>
<p>Less than 2,000 threads need more than 1.5 GB of memory. 1 million coroutines need less than 700 MB of memory—I rest my case. The verdict is that the coroutines are very, very light.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using coroutines in real life</h1>
                
            
            
                
<p>Microbenchmarks are very funny and they give us an idea of the power of Kotlin coroutines, but they don't represent a real-case scenario.</p>
<p>Let's introduce our real-case scenario:</p>
<pre>enum class Gender {<br/>   MALE, FEMALE;<br/><br/>   companion object {<br/>      fun valueOfIgnoreCase(name: String): Gender = valueOf(name.toUpperCase())<br/>   }<br/>}<br/><br/>typealias UserId = Int<br/><br/>data class User(val id: UserId, val firstName: String, val lastName: String, val gender: Gender)<br/><br/>data class Fact(val id: Int, val value: String, val user: User? = null)<br/><br/>interface UserService {<br/>   fun getFact(id: UserId): Fact<br/>}</pre>
<p>Our <kbd>UserService</kbd> interface has just one method—<kbd>getFact</kbd> will return a Chuck Norris-style fact about our user, identified by the user ID.</p>
<p>The implementation should check first on a local database for a user; if the user doesn't exist in the database, it should get it from the <strong>RandomUser API</strong> service, (<a href="https://randomuser.me/documentation">https://randomuser.me/documentation</a>), and then store for future use. Once the service has a user, it should check again in the database for a fact related to that user; if the fact doesn't exist in the database, it should get it from The <strong>Internet Chuck Norris Database API</strong> service, (<a href="http://www.icndb.com/api/">http://www.icndb.com/api/</a>), and store it in the database. Once the service has a fact, it could be returned. The service must try to reduce the number of external calls (database, API services) without using a cache.</p>
<p>Now, let's introduce other interfaces, HTTP clients—<kbd>UserClient</kbd> and <kbd>FactClient</kbd>:</p>
<pre>interface UserClient {<br/>   fun getUser(id: UserId): User<br/>}<br/><br/>interface FactClient {<br/>   fun getFact(user: User): Fact<br/>}</pre>
<p>Our clients will be implemented using <kbd>http4k</kbd> (<a href="https://www.http4k.org/">https://www.http4k.org/</a>) for HTTP communication, and Kotson (<a href="https://github.com/SalomonBrys/Kotson">https://github.com/SalomonBrys/Kotson</a>) for JSON processing. Both libraries are being designed for Kotlin, but any other library should work fine:</p>
<pre>import com.github.salomonbrys.kotson.*<br/>import com.google.gson.GsonBuilder<br/>import org.http4k.client.ApacheClient<br/><br/>abstract class WebClient {<br/>   protected val apacheClient = ApacheClient()<br/><br/>   protected val gson = GsonBuilder()<br/>         .registerTypeAdapter&lt;User&gt; {<br/>            deserialize { des -&gt;<br/>               val json = des.json<br/>               User(json["info"]["seed"].int,<br/>                     json["results"][0]["name"]["first"].string.capitalize(),<br/>                     json["results"][0]["name"]["last"].string.capitalize(),<br/>                     Gender.valueOfIgnoreCase(json["results"][0]["gender"].string))<br/><br/>            }<br/>         }<br/>         .registerTypeAdapter&lt;Fact&gt; {<br/>            deserialize { des -&gt;<br/>               val json = des.json<br/>               Fact(json["value"]["id"].int,<br/>                     json["value"]["joke"].string)<br/>            }<br/>         }.create()!!<br/>}</pre>
<p>Both clients will extend a common parent class that contains <kbd>http4k ApacheClient</kbd> and a <kbd>Gson</kbd> value configured with Kotson DSL:</p>
<pre>import org.http4k.core.Method<br/>import org.http4k.core.Request<br/><br/>class Http4KUserClient : WebClient(), UserClient {<br/>   override fun getUser(id: UserId): User {<br/>      return gson.fromJson(apacheClient(Request(Method.GET, "https://randomuser.me/api")<br/>            .query("seed", id.toString()))<br/>            .bodyString())<br/>   }<br/>}</pre>
<p><kbd>Http4KUserClient</kbd> is very simple, both libraries are easy to use, and we move a lot of code to the parent class:</p>
<pre>class Http4KFactClient : WebClient(), FactClient {<br/>   override fun getFact(user: User): Fact {<br/>      return gson.fromJson&lt;Fact&gt;(apacheClient(Request(Method.GET, "http://api.icndb.com/jokes/random")<br/>            .query("firstName", user.firstName)<br/>            .query("lastName", user.lastName))<br/>            .bodyString())<br/>            .copy(user = user)<br/>   }<br/>}</pre>
<p><kbd>Http4KFactClient</kbd> sets the user value inside the <kbd>Fact</kbd> instance, using the <kbd>copy</kbd> method.</p>
<p>These classes are very nicely implemented, but to test the actual performance of our algorithm, we will mock these interfaces:</p>
<pre>class MockUserClient : UserClient {<br/>   override fun getUser(id: UserId): User {<br/>      println("MockUserClient.getUser")<br/>      Thread.sleep(500)<br/>      return User(id, "Foo", "Bar", Gender.FEMALE)<br/>   }<br/>}<br/><br/>class MockFactClient : FactClient {<br/>   override fun getFact(user: User): Fact {<br/>      println("MockFactClient.getFact")<br/>      Thread.sleep(500)<br/>      return Fact(Random().nextInt(), "FACT ${user.firstName}, ${user.lastName}", user)<br/>   }<br/>}</pre>
<p>Take a look at the following database repositories, <kbd>UserRepository</kbd> and <kbd>FactRepository</kbd>:</p>
<pre>interface UserRepository {<br/>   fun getUserById(id: UserId): User?<br/>   fun insertUser(user: User)<br/>}<br/><br/>interface FactRepository {<br/>   fun getFactByUserId(id: UserId): Fact?<br/>   fun insertFact(fact: Fact)<br/>}</pre>
<p>For our repositories, we'll use <kbd>JdbcTemplate</kbd> of Spring 5. Spring 5 comes with support for Kotlin, including extension functions for easy and idiomatic Kotlin use (you can use <kbd>JdbcTemplate</kbd> in any application, it doesn't need to be a Spring one):</p>
<pre>import org.springframework.dao.EmptyResultDataAccessException<br/>import org.springframework.jdbc.core.JdbcTemplate<br/><br/>abstract class JdbcRepository(protected val template: JdbcTemplate) {<br/>   protected fun &lt;T&gt; toNullable(block: () -&gt; T): T? {<br/>      return try {<br/>         block()<br/>      } catch (_: EmptyResultDataAccessException) {<br/>         null<br/>      }<br/>   }<br/>}</pre>
<p>As with the clients, both repositories will have a parent class—in this case, with a function to transform, <kbd>EmptyResultDataAccessException</kbd>; (spring's way to indicate a non-existing record) into a nullable—idiomatic Kotlin.</p>
<p>Both implementations are straightforward, as follows:</p>
<pre>import org.springframework.jdbc.core.queryForObject<br/><br/>class JdbcUserRepository(template: JdbcTemplate) : JdbcRepository(template), UserRepository {<br/>   override fun getUserById(id: UserId): User? {<br/>      return toNullable {<br/>         template.queryForObject("select * from USERS where id = ?", id) { resultSet, _ -&gt;<br/>            with(resultSet) {<br/>               User(getInt("ID"),<br/>                     getString("FIRST_NAME"),<br/>                     getString("LAST_NAME"),<br/>                     Gender.valueOfIgnoreCase(getString("GENDER")))<br/>            }<br/>         }<br/>      }<br/>   }<br/><br/>   override fun insertUser(user: User) {<br/>      template.update("INSERT INTO USERS VALUES (?,?,?,?)",<br/>            user.id,<br/>            user.firstName,<br/>            user.lastName,<br/>            user.gender.name)<br/>   }<br/>}<br/><br/>class JdbcFactRepository(template: JdbcTemplate) : JdbcRepository(template), FactRepository {<br/>   override fun getFactByUserId(id: Int): Fact? {<br/>      return toNullable {<br/>         template.queryForObject("select * from USERS as U inner join FACTS as F on U.ID = F.USER where U.ID = ?", id) { resultSet, _ -&gt;<br/>            with(resultSet) {<br/>               Fact(getInt(5),<br/>                     getString(6),<br/>                     User(getInt(1),<br/>                           getString(2),<br/>                           getString(3),<br/>                           Gender.valueOfIgnoreCase(getString(4))))<br/>            }<br/>         }<br/>      }<br/>   }<br/><br/>   override fun insertFact(fact: Fact) {<br/>      template.update("INSERT INTO FACTS VALUES (?,?,?)", fact.id, fact.value, fact.user?.id)<br/>   }<br/>}</pre>
<p>For our database, we are using the H2 in-memory database, but any database will work (you can make this application work with some different persistence mechanisms, such as NoSQL database or any cache):</p>
<pre>fun initJdbcTemplate(): JdbcTemplate {<br/>   return JdbcTemplate(JdbcDataSource()<br/>         .apply {<br/>            setUrl("jdbc:h2:mem:facts_app;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false")<br/>         })<br/>         .apply {<br/>            execute("CREATE TABLE USERS (ID INT AUTO_INCREMENT PRIMARY KEY, FIRST_NAME VARCHAR(64) NOT NULL, LAST_NAME VARCHAR(64) NOT NULL, GENDER VARCHAR(8) NOT NULL);")<br/>            execute("CREATE TABLE FACTS (ID INT AUTO_INCREMENT PRIMARY KEY, VALUE_ TEXT NOT NULL, USER INT NOT NULL,  FOREIGN KEY (USER) REFERENCES USERS(ID) ON DELETE RESTRICT)")<br/>         }<br/>}</pre>
<p>The function <kbd>initJdbcTemplate</kbd> creates <kbd>JdbcTemplate</kbd> with an H2 <kbd>DataSource</kbd>, and, once it is ready, it creates the tables inside the <kbd>apply</kbd> extension function. The <kbd>apply</kbd> extension function is useful to configure properties and call initialization code, returning the same value:</p>
<pre>public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T {<br/>    block()<br/>    return this<br/>}</pre>
<p>As with the clients, for testing, we will use mocks:</p>
<pre>class MockUserRepository : UserRepository {<br/>   private val users = hashMapOf&lt;UserId, User&gt;()<br/><br/>   override fun getUserById(id: UserId): User? {<br/>      println("MockUserRepository.getUserById")<br/>      Thread.sleep(200)<br/>      return users[id]<br/>   }<br/><br/>   override fun insertUser(user: User) {<br/>      println("MockUserRepository.insertUser")<br/>      Thread.sleep(200)<br/>      users[user.id] = user<br/>   }<br/>}<br/><br/>class MockFactRepository : FactRepository {<br/><br/>   private val facts = hashMapOf&lt;UserId, Fact&gt;()<br/><br/>   override fun getFactByUserId(id: UserId): Fact? {<br/>      println("MockFactRepository.getFactByUserId")<br/>      Thread.sleep(200)<br/>      return facts[id]<br/>   }<br/><br/>   override fun insertFact(fact: Fact) {<br/>      println("MockFactRepository.insertFact")<br/>      Thread.sleep(200)<br/>      facts[fact.user?.id ?: 0] = fact<br/>   }<br/><br/>}</pre>
<p>With these mocks, our worst case scenario is around 1,600 milliseconds:</p>
<ul>
<li><kbd>UserRepository.getUserById = 200ms ~</kbd></li>
<li><kbd>UserClient.getUser = 500ms ~</kbd></li>
<li><kbd>UserRepository = 200ms ~</kbd></li>
<li><kbd>FactClient.getFact = 500ms ~</kbd></li>
<li><kbd>FactRepository.insertRepository = 200ms ~</kbd></li>
</ul>
<p>Now, we'll implement <kbd>UserService</kbd> with different styles of asynchronicity, including a synchronous implementation, our baseline.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Synchronous implementation</h1>
                
            
            
                
<p>Synchronous code is easy to write, predictable, and easy to test, but in some cases, it doesn't use system resources in an optimal manner: </p>
<pre>class SynchronousUserService(private val userClient: UserClient,<br/>                      private val factClient: FactClient,<br/>                      private val userRepository: UserRepository,<br/>                      private val factRepository: FactRepository) : UserService {<br/><br/>   override fun getFact(id: UserId): Fact {<br/>      val user = userRepository.getUserById(id)<br/>      return if (user == null) {<br/>         val userFromService = userClient.getUser(id)<br/>         userRepository.insertUser(userFromService)<br/>         getFact(userFromService)<br/>      } else {<br/>         factRepository.getFactByUserId(id) ?: getFact(user)<br/>      }<br/>   }<br/><br/>   private fun getFact(user: User): Fact {<br/>      val fact = factClient.getFact(user)<br/>      factRepository.insertFact(fact)<br/>      return fact<br/>   }<br/>}</pre>
<p>There's nothing fancy here, just your normal, old boring code:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   <br/>   fun execute(userService: UserService, id: Int) {<br/>         val (fact, time) = inTime {<br/>            userService.getFact(id)<br/>         }<br/>         println("fact = $fact")<br/>         println("time = $time ms.")<br/>      }<br/>   <br/>   val userClient = MockUserClient()<br/>   val factClient = MockFactClient()<br/>   val userRepository = MockUserRepository()<br/>   val factRepository = MockFactRepository()<br/><br/>   val userService = SynchronousUserService(userClient,<br/>         factClient,<br/>         userRepository,<br/>         factRepository)<br/><br/>   execute(userService, 1)<br/>   execute(userService, 2)<br/>   execute(userService, 1)<br/>   execute(userService, 2)<br/>   execute(userService, 3)<br/>   execute(userService, 4)<br/>   execute(userService, 5)<br/>   execute(userService, 10)<br/>   execute(userService, 100)   <br/>   <br/>}</pre>
<p>We execute the <kbd>UserService.getFact</kbd> method 10 times to warm up the JVM (JVM optimizations make the application run faster after a while). Needless to say, execution time is 1,600 milliseconds, no surprises here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Callbacks</h1>
                
            
            
                
<p>A popular style of asynchronous code is to execute the code in a separate thread and invoke a <kbd>callback</kbd> function when the aforementioned thread finishes its execution. One downside of the callback style is that our asynchronous functions now need an extra parameter. Callback style is easy to write in Kotlin with its support for lambdas.</p>
<p>For our callback implementation, we'll need adapters for our clients and repositories:</p>
<pre>import kotlin.concurrent.thread<br/><br/>class CallbackUserClient(private val client: UserClient) {<br/>   fun getUser(id: Int, callback: (User) -&gt; Unit) {<br/>      thread {<br/>         callback(client.getUser(id))<br/>      }<br/>   }<br/>}<br/><br/>class CallbackFactClient(private val client: FactClient) {<br/>   fun get(user: User, callback: (Fact) -&gt; Unit) {<br/>      thread {<br/>         callback(client.getFact(user))<br/>      }<br/>   }<br/>}<br/><br/>class CallbackUserRepository(private val userRepository: UserRepository) {<br/>   fun getUserById(id: UserId, callback: (User?) -&gt; Unit) {<br/>      thread {<br/>         callback(userRepository.getUserById(id))<br/>      }<br/>   }<br/><br/>   fun insertUser(user: User, callback: () -&gt; Unit) {<br/>      thread {<br/>         userRepository.insertUser(user)<br/>         callback()<br/>      }<br/><br/>   }<br/>}<br/><br/>class CallbackFactRepository(private val factRepository: FactRepository) {<br/>   fun getFactByUserId(id: Int, callback: (Fact?) -&gt; Unit) {<br/>      thread {<br/>         callback(factRepository.getFactByUserId(id))<br/>      }<br/>   }<br/><br/>   fun insertFact(fact: Fact, callback: () -&gt; Unit) {<br/>      thread {<br/>         factRepository.insertFact(fact)<br/>         callback()<br/>      }<br/>   }<br/>}</pre>
<p>These adapters execute our code in a separate thread and invoke the callback, lambda, once it is completed:</p>
<pre>class CallbackUserService(private val userClient: CallbackUserClient,<br/>                    private val factClient: CallbackFactClient,<br/>                    private val userRepository: CallbackUserRepository,<br/>                    private val factRepository: CallbackFactRepository) : UserService {<br/><br/>   override fun getFact(id: UserId): Fact {<br/>      var aux: Fact? = null<br/>      userRepository.getUserById(id) { user -&gt;<br/>         if (user == null) {<br/>            userClient.getUser(id) { userFromClient -&gt;<br/>               userRepository.insertUser(userFromClient) {}<br/>               factClient.get(userFromClient) { fact -&gt;<br/>                  factRepository.insertFact(fact) {}<br/>                  aux = fact<br/>               }<br/><br/>            }<br/>         } else {<br/>            factRepository.getFactByUserId(id) { fact -&gt;<br/>               if (fact == null) {<br/>                  factClient.get(user) { factFromClient -&gt;<br/>                     factRepository.insertFact(factFromClient) {}<br/>                     aux = factFromClient<br/>                  }<br/>               } else {<br/>                  aux = fact<br/>               }<br/>            }<br/>         }<br/>      }<br/>      while (aux == null) {<br/>         Thread.sleep(2)<br/>      }<br/>      return aux!!<br/>   }<br/>}</pre>
<p>Callback style tends to be very obscure and hard to read; when several callbacks are nested, it is even worse (affectionately known in the community as callback hell). The <kbd>while</kbd> block at the end with <kbd>Thread.sleep</kbd> looks very hacky. It is also very fast with an execution time of 1,200 milliseconds but with many threads created and memory consumption to match it.</p>
<p>A callback implementation that creates a thread per function call will quickly consume all the application's resources in a production scenario; therefore, it should be based on some <kbd>Executor</kbd> implementation or similar.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Java Futures</h1>
                
            
            
                
<p>As callback style tends to be hard to maintain, other styles have emerged in recent years. One of these styles is futures. A <strong>future</strong> is a computation that may complete in the future. When we invoke the <kbd>Future.get</kbd> method, it will obtain its result, but we also block the thread:</p>
<pre>import java.util.concurrent.ExecutorService<br/>import java.util.concurrent.Executors<br/><br/>class FutureUserService(private val userClient: UserClient,<br/>                  private val factClient: FactClient,<br/>                  private val userRepository: UserRepository,<br/>                  private val factRepository: FactRepository) : UserService {<br/>   override fun getFact(id: UserId): Fact {<br/><br/>      val executor = Executors.newFixedThreadPool(2)<br/><br/>      val user = executor.submit&lt;User?&gt; { userRepository.getUserById(id) }.get()<br/>      return if (user == null) {<br/>         val userFromService = executor.submit&lt;User&gt; { userClient.getUser(id) }.get()<br/>         executor.submit { userRepository.insertUser(userFromService) }<br/>         getFact(userFromService, executor)<br/>      } else {<br/>         executor.submit&lt;Fact&gt; {<br/>            factRepository.getFactByUserId(id) ?: getFact(user, executor)<br/>         }.get()<br/>      }.also {<br/>         executor.shutdown()<br/>      }<br/>   }<br/><br/>   private fun getFact(user: User, executor: ExecutorService): Fact {<br/>      val fact = executor.submit&lt;Fact&gt; { factClient.getFact(user) }.get()<br/>      executor.submit { factRepository.insertFact(fact) }<br/>      return fact<br/>   }<br/>}</pre>
<p>The implementation with futures is very similar to our synchronous implementation, but with those weird <kbd>submit</kbd> and <kbd>get</kbd> functions all over the place. We also have <kbd>Executor</kbd> that we need to take care of. Total time is around 1,200 milliseconds, with many threads created, more than in the callback example. One possible option is to have <kbd>Executor</kbd> per instance or globally, but in that case, we also need to have some way to manage its life cycle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Promises with Kovenant </h1>
                
            
            
                
<p>Another option to write asynchronous code is to use promises. A <strong>promise</strong> is similar to a future (in many frameworks, futures and promises are synonymous), as it represents a computation that may complete in the future. We have a blocking method to obtain its result, but we can also react to its result, callback style. </p>
<p><strong>Kovenant</strong> (<a href="http://kovenant.komponents.nl/">http://kovenant.komponents.nl/</a>) is an implementation of promises for Kotlin:</p>
<pre>import nl.komponents.kovenant.Promise<br/>import nl.komponents.kovenant.task<br/>import nl.komponents.kovenant.then<br/><br/>class PromiseUserService(private val userClient: UserClient,<br/>                   private val factClient: FactClient,<br/>                   private val userRepository: UserRepository,<br/>                   private val factRepository: FactRepository) : UserService {<br/><br/>   override fun getFact(id: UserId): Fact {<br/><br/>      return (task {<br/>         userRepository.getUserById(id)<br/>      } then { user -&gt;<br/>         if (user == null) {<br/>            task {<br/>               userClient.getUser(id)<br/>            } success  { userFromService -&gt;<br/>               userRepository.insertUser(userFromService)<br/>            } then { userFromService -&gt;<br/>               getFact(userFromService).get()<br/>            }<br/>         } else {<br/>            task { factRepository.getFactByUserId(id) ?: getFact(user).get() }<br/>         }<br/>      }).get().get()<br/>   }<br/><br/>   private fun getFact(user: User): Promise&lt;Fact, Exception&gt; = task {<br/>      factClient.getFact(user)<br/>   } success  { fact -&gt;<br/>      factRepository.insertFact(fact)<br/>   }<br/>}</pre>
<p>The function <kbd>task</kbd> creates <kbd>Promise&lt;T, Exception&gt;</kbd> (something that we didn't cover previously in our other implementations). We can interact with <kbd>Promise&lt;T, Exception&gt;</kbd> in several ways:</p>
<ul>
<li><kbd>get(): T</kbd>: This blocks the current thread and returns the promise's result.</li>
<li><kbd>then(bind: (T) -&gt; R): Promise&lt;R, Exception&gt;</kbd>: This is similar to <kbd>map</kbd> on functional collections; it returns a new <kbd>Promise</kbd> value with a new type.</li>
<li><kbd>success(callback: (T) -&gt; Unit): Promise&lt;T, Exception&gt;</kbd>: This is callback on successful <kbd>Promise</kbd> execution. It's useful for side effects</li>
<li><kbd>fail(callback: (Exception) -&gt; Unit): Promise&lt;T, Exception&gt;</kbd>: This is callback on fail, like a <kbd>catch</kbd> block.</li>
<li><kbd>always(callback: () -&gt; Unit): Promise&lt;T, Exception&gt;</kbd>: This always executes, like a <kbd>finally</kbd> block.</li>
</ul>
<p>The codes feel difficult to grasp at first sight, but, once you get used to the promise idioms, it is easy to read. Also, notice that a promise is a future, so you can write something similar to our future's example but without messing around with <kbd>Executors</kbd>. Java 8 includes a new type of future named <kbd>CompletableFuture&lt;T&gt;</kbd> which can be considered a promise.</p>
<p>Execution time is around 1,350 milliseconds for the first execution (Kovenant initialization phase), and then it stabilizes around 1,200 milliseconds. On its default configuration, Kovenant uses as many threads as possible, resulting in a high use of memory, but Kovenant can be fine-tuned to use fewer threads.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coroutines</h1>
                
            
            
                
<p>Now, let's rework our example with coroutines:</p>
<pre>import kotlinx.coroutines.experimental.Deferred<br/>import kotlinx.coroutines.experimental.async<br/>import kotlinx.coroutines.experimental.launch<br/>import kotlinx.coroutines.experimental.runBlocking<br/><br/>class CoroutineUserService(private val userClient: UserClient,<br/>                     private val factClient: FactClient,<br/>                     private val userRepository: UserRepository,<br/>                     private val factRepository: FactRepository) : UserService {<br/>   override fun getFact(id: UserId): Fact = runBlocking {<br/>      val user = async { userRepository.getUserById(id) }.await()<br/>      if (user == null) {<br/>         val userFromService = async { userClient.getUser(id) }.await()<br/>         launch { userRepository.insertUser(userFromService) }<br/>         getFact(userFromService)<br/>      } else {<br/>         async { factRepository.getFactByUserId(id) ?: getFact(user) }.await()<br/>      }<br/>   }<br/><br/>   private suspend fun getFact(user: User):Fact {<br/>      val fact: Deferred&lt;Fact&gt; = async { factClient.getFact(user) }<br/>      launch { factRepository.insertFact(fact.await()) }<br/>      return fact.await()<br/>   }<br/>}</pre>
<p>Our code is more straightforward than our <kbd>Future</kbd> example, getting very close to our synchronous code. We covered <kbd>runBlocking</kbd> and <kbd>launch</kbd> in the previous section, but a new coroutine builder is introduced here, <kbd>async</kbd>.</p>
<p>The <kbd>async</kbd> coroutine builder takes a block of code and executes it asynchronously, returning <kbd>Deferred&lt;T&gt;</kbd>. A <kbd>Deferred</kbd> is a <kbd>Future</kbd> with an <kbd>await</kbd> method that blocks the coroutine until completion but not the thread; <kbd>Deferred</kbd> also extends from <kbd>Job</kbd> so inherits all its methods, such as <kbd>join</kbd>.</p>
<p>Coroutine code feels natural yet it is explicit when we are using asynchronous code, but due to the low cost on resources, we can use as many coroutines as we want in our code; for example, <kbd>CoroutineUserService</kbd> uses less than half of threads and memory than any other implementation.</p>
<p>Now that we have all implementations, we can compare code complexity and resource consumption:</p>
<table>
<tbody>
<tr>
<td/>
<td>
<p><strong>Code complexity</strong></p>
</td>
<td>
<p><strong>Resource consumption</strong></p>
</td>
</tr>
<tr>
<td>
<p><strong>Synchronous</strong></p>
</td>
<td>
<p>There is very low code complexity.</p>
</td>
<td>
<p>The resource consumption is very low with slow performance.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Callbacks</strong></p>
</td>
<td>
<p>Very high adapters are needed; duplication is expected; nested callbacks are hard to read; and there are various hacks.</p>
</td>
<td>
<p>The resource consumption is high. It could improve using a shared <kbd>Executor</kbd>, but it will add more code complexity.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Futures</strong></p>
</td>
<td>
<p>Code complexity is medium. <kbd>Executors</kbd> and <kbd>get()</kbd> are noisy but it is still readable.</p>
</td>
<td>
<p>Resource consumption is high, but it can be fine-tuned using different <kbd>Executor</kbd> implementations and sharing executors but this adds code complexity.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Promises</strong></p>
</td>
<td>
<p>Code complexity is medium using promise style (<kbd>then</kbd>, <kbd>success</kbd>). Using a futures style (<kbd>get</kbd>), it can be as slick as coroutines without affecting performance.</p>
</td>
<td>
<p>Resource consumption is very high, with top performance, but it can be fine-tuned without altering the code.</p>
</td>
</tr>
<tr>
<td>
<p><strong>Coroutines</strong></p>
</td>
<td>
<p>Code complexity is low; it's the same size as synchronous style with explicit blocks for asynchronous operations.</p>
</td>
<td>
<p>Resource consumption is low, with top performance out of the box.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Overall, coroutines are a clear winner, with Kovenant promises coming in a close second.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Coroutine context</h1>
                
            
            
                
<p>Coroutines always run in a context. All coroutine builders have context specified by default, and that context is available through the value <kbd>coroutineContext</kbd>, inside the coroutine body:</p>
<pre>import kotlinx.coroutines.experimental.*<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   println("run blocking coroutineContext = $coroutineContext")<br/>   println("coroutineContext[Job] = ${coroutineContext[Job]}")<br/>   println(Thread.currentThread().name)<br/>   println("-----")<br/><br/>   val jobs = listOf(<br/>         launch {<br/>            println("launch coroutineContext = $coroutineContext")<br/>            println("coroutineContext[Job] = ${coroutineContext[Job]}")<br/>            println(Thread.currentThread().name)<br/>            println("-----")<br/>         },<br/>         async {<br/>            println("async coroutineContext = $coroutineContext")<br/>            println("coroutineContext[Job] = ${coroutineContext[Job]}")<br/>            println(Thread.currentThread().name)<br/>            println("-----")<br/>         },<br/>         launch(CommonPool) {<br/>            println("common launch coroutineContext = $coroutineContext")<br/>            println("coroutineContext[Job] = ${coroutineContext[Job]}")<br/>            println(Thread.currentThread().name)<br/>            println("-----")<br/>         },<br/>         launch(coroutineContext) {<br/>            println("inherit launch coroutineContext = $coroutineContext")<br/>            println("coroutineContext[Job] = ${coroutineContext[Job]}")<br/>            println(Thread.currentThread().name)<br/>            println("-----")<br/>         }<br/>   )<br/><br/>   jobs.forEach { job -&gt;<br/>      println("job = $job")<br/>      job.join()<br/>   }<br/>}</pre>
<p>Each coroutine context also includes <kbd>CoroutineDispatcher</kbd> that decides which thread the coroutine runs. Coroutines builders, such as <kbd>async</kbd> and <kbd>launch</kbd>, use the <kbd>DefaultDispatcher</kbd> dispatcher as default (in the current coroutines version, 0.2.1, <kbd>DefaultDispatcher</kbd> is equal to <kbd>CommonPool</kbd>; however, this behavior can change in the future).</p>
<p>The coroutine context can also hold values; for example, you can recover the coroutine's job by using <kbd>coroutineContext[Job]</kbd>.</p>
<p>Coroutine contexts can be used to control its children. Our 1 million coroutines example can be reworked to join all its children:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/><br/>   val job = launch {<br/>      repeat(1_000_000) {<br/>         launch(coroutineContext) {<br/>            delay(1000)<br/>            print('.')<br/>         }<br/>      }<br/>   }<br/><br/>   job.join()<br/>}</pre>
<p>Instead of each one of the million coroutines having its own context, we can set a shared coroutine context that actually comes from the external <kbd>launch</kbd> coroutine context. When we join the outer <kbd>launch</kbd> job, it joins all its coroutine children, too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Channels</h1>
                
            
            
                
<p>One way for two coroutines to communicate (or for a coroutine to the external world as with <kbd>async</kbd>) is through <kbd>Deferred&lt;T&gt;</kbd>:</p>
<pre>import kotlinx.coroutines.experimental.delay<br/>import kotlinx.coroutines.experimental.launch<br/>import kotlinx.coroutines.experimental.runBlocking<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>    val result = CompletableDeferred&lt;String&gt;()<br/><br/>   val world = launch {<br/>      delay(500)<br/>      result.complete("World (from another coroutine)")<br/>   }<br/><br/>   val hello =launch {<br/>      println("Hello ${result.await()}")<br/>   }<br/><br/>   hello.join()<br/>   world.join()<br/>}</pre>
<p>Deferreds are fine for single values, but sometimes we want to send a sequence or a stream. In that case, we can use <kbd>Channel</kbd>. <kbd>Channel</kbd> which is similar to <kbd>BlockingQueue</kbd>, but with suspending operations instead of blocking ones, also <kbd>Channel</kbd> can be <kbd>close</kbd>:</p>
<pre>import kotlinx.coroutines.experimental.channels.*<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {<br/>   val channel = Channel&lt;String&gt;()<br/><br/>   val world = launch {<br/>      delay(500)<br/>      channel.send("World (from another coroutine using a channel)")<br/>   }<br/><br/>   val hello = launch {<br/>      println("Hello ${channel.receive()}")<br/>   }<br/><br/>   hello.join()<br/>   world.join()<br/>}</pre>
<p>Let's write our 1 million coroutines example with channels as follows:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {<br/><br/>   val channel = Channel&lt;Char&gt;()<br/><br/>   val jobs = List(1_000_000) {<br/>      launch {<br/>         delay(1000)<br/>         channel.send('.')<br/>      }<br/>   }<br/><br/>   repeat(1_000_000) {<br/>      print(channel.receive())<br/>   }<br/><br/>   jobs.forEach { job -&gt; job.join() }<br/>}</pre>
<p class="mce-root">Of course, this isn't the intended use case for channels. Usually, a single coroutine (or many) sends messages to the channel:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {<br/><br/>   val channel = Channel&lt;Char&gt;()<br/><br/>   val sender = launch {<br/>      repeat(1000) {<br/>         delay(10)<br/>         channel.send('.')<br/>         delay(10)<br/>         channel.send(',')<br/>      }<br/>      channel.close()<br/>   }<br/><br/>   for (msg in channel) {<br/>      print(msg)<br/>   }<br/><br/>   sender.join()<br/><br/>}</pre>
<p>A channel is itself an Iterator, so it can be used on the <kbd>for</kbd> blocks.</p>
<p>A simpler way to write this code is by using the <kbd>produce</kbd> builder as follows:</p>
<pre>fun dotsAndCommas(size: Int) = produce {<br/>   repeat(size) {<br/>      delay(10)<br/>      send('.')<br/>      delay(10)<br/>      send(',')<br/>   }<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking&lt;Unit&gt; {<br/>   val channel = dotsAndCommas(1000)<br/><br/>   for (msg in channel) {<br/>      print(msg)<br/>   }<br/>}</pre>
<p>The <kbd>produce</kbd> builder returns <kbd>ReceiveChannel&lt;T&gt;</kbd>, a channel type just for receiving. A <kbd>Channel&lt;T&gt;</kbd> extends both types, <kbd>SendChannel&lt;T&gt;</kbd> and <kbd>ReceiveChannel&lt;T&gt;</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Channel pipelines</h1>
                
            
            
                
<p>When we have channels, we can have related patterns, such as pipelines. A <strong>pipeline</strong> is a series of channels connecting consumers and producers, similar to Unix pipes or <strong>Enterprise Integration Patterns</strong> (<strong>EIP</strong>).</p>
<p>Let's write our own sales system using EIPs. Let's first take a look at the models:</p>
<pre>data class Quote(val value: Double, val client: String, val item: String, val quantity: Int)<br/><br/>data class Bill(val value: Double, val client: String)<br/><br/>data class PickingOrder(val item: String, val quantity: Int)</pre>
<p>Now, let's take a look at the patterns:</p>
<pre>import kotlinx.coroutines.experimental.CoroutineContext<br/><br/>fun calculatePriceTransformer(coroutineContext: CoroutineContext, quoteChannel: ReceiveChannel&lt;Quote&gt;) = produce(coroutineContext) {<br/>   for (quote in quoteChannel) {<br/>      send(Bill(quote.value * quote.quantity, quote.client) to PickingOrder(quote.item, quote.quantity))<br/>   }<br/>}</pre>
<p>The <kbd>calculatePriceTransformer</kbd> function receives quotes from a channel and transforms it into <kbd>Pair&lt;Bill, PickingOrder&gt;</kbd>:</p>
<pre>fun cheapBillFilter(coroutineContext: CoroutineContext, billChannel: ReceiveChannel&lt;Pair&lt;Bill, PickingOrder&gt;&gt;) = produce(coroutineContext) {<br/>   billChannel.consumeEach { (bill, order) -&gt;<br/>      if (bill.value &gt;= 100) {<br/>         send(bill to order)<br/>      } else {<br/>         println("Discarded bill $bill")<br/>      }<br/>   }<br/>}</pre>
<p>The <kbd>cheapBillFilter</kbd> function well filters the <kbd>bill</kbd> value below <kbd>100</kbd>:</p>
<pre>suspend fun splitter(filteredChannel: ReceiveChannel&lt;Pair&lt;Bill, PickingOrder&gt;&gt;,<br/>                accountingChannel: SendChannel&lt;Bill&gt;,<br/>                warehouseChannel: SendChannel&lt;PickingOrder&gt;) = launch {<br/>   filteredChannel.consumeEach { (bill, order) -&gt;<br/>      accountingChannel.send(bill)<br/>      warehouseChannel.send(order)<br/>   }<br/>}</pre>
<p><kbd>splitter</kbd> splits <kbd>Pair&lt;Bill, PickingOrder&gt;</kbd> into their own channels:</p>
<pre>suspend fun accountingEndpoint(accountingChannel: ReceiveChannel&lt;Bill&gt;) = launch {<br/>   accountingChannel.consumeEach { bill -&gt;<br/>      println("Processing bill = $bill")<br/>   }<br/>}<br/><br/>suspend fun warehouseEndpoint(warehouseChannel: ReceiveChannel&lt;PickingOrder&gt;) = launch {<br/>   warehouseChannel.consumeEach { order -&gt;<br/>      println("Processing order = $order")<br/>   }<br/>}</pre>
<p>Both <kbd>accountingEndpoint</kbd> and <kbd>warehouseEndpoint</kbd> process their respective messages by printing, but, in a real-life scenario, we could be storing these messages into our database, sending emails or sending messages to other systems using <strong>JMS</strong>, <strong>AMQP</strong>, or <strong>Kafka</strong>:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/><br/>   val quoteChannel = Channel&lt;Quote&gt;()<br/>   val accountingChannel = Channel&lt;Bill&gt;()<br/>   val warehouseChannel = Channel&lt;PickingOrder&gt;()<br/>   <br/>   val transformerChannel = calculatePriceTransformer(coroutineContext, quoteChannel)<br/><br/>   val filteredChannel = cheapBillFilter(coroutineContext, transformerChannel)<br/><br/>   splitter(filteredChannel, accountingChannel, warehouseChannel)<br/><br/>   warehouseEndpoint(warehouseChannel)<br/><br/>   accountingEndpoint(accountingChannel)<br/><br/>   launch(coroutineContext) {<br/>      quoteChannel.send(Quote(20.0, "Foo", "Shoes", 1))<br/>      quoteChannel.send(Quote(20.0, "Bar", "Shoes", 200))<br/>      quoteChannel.send(Quote(2000.0, "Foo", "Motorbike", 1))<br/>   }<br/>   <br/>   delay(1000)<br/>   coroutineContext.cancelChildren()<br/>}</pre>
<p>The <kbd>main</kbd> method assembles our sales system and tests it.</p>
<p>Many other channel messages patterns can be implemented with coroutine channels, such as fan-in, fan-out, and <kbd>actors</kbd>. We'll cover <kbd>actors</kbd> in our next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing mutable state</h1>
                
            
            
                
<p>The main concern (and nightmare fuel) when we deal with asynchronous code is how to handle mutable state. We covered how to reduce mutable state with a functional style in <a href="3d8794f8-c237-4d9e-992e-c54a1392a89c.xhtml">Chapter 3</a>, <em>Immutability - It's Important</em>. But sometimes it is impossible to use a functional immutable style. Coroutines offer some alternatives to this problem.</p>
<p>In the following example, we'll use several coroutines to update a counter:</p>
<pre>import kotlin.system.measureTimeMillis<br/><br/>suspend fun repeatInParallel(times: Int, block: suspend () -&gt; Unit) {<br/>   val job = launch {<br/>      repeat(times) {<br/>         launch(coroutineContext) {<br/>            block()<br/>         }<br/>      }<br/>   }<br/>   job.join()<br/>}<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   var counter = 0<br/><br/>   val time = measureTimeMillis {<br/>      repeatInParallel(1_000_000) {<br/>         counter++<br/>      }<br/>   }<br/>   println("counter = $counter")<br/>   println("time = $time")<br/>}</pre>
<p>On smaller numbers, <kbd>counter</kbd> is right, but once we start increasing the size, we'll see wacky numbers.</p>
<p>Now we can have a look at the alternatives that coroutines provide us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Switching contexts</h1>
                
            
            
                
<p>Our first option is to use a different context for our update operation:</p>
<pre>import kotlinx.coroutines.experimental.*<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   var counter = 0<br/><br/>   val counterContext = newSingleThreadContext("CounterContext")<br/><br/>   val time = measureTimeMillis {<br/>      repeatInParallel(1_000_000) {<br/>         withContext(counterContext) {<br/>            counter++<br/>         }<br/>      }<br/>   }<br/>   println("counter = $counter")<br/>   println("time = $time")<br/>}</pre>
<p>The <kbd>withContext</kbd> function executes a block in a specific coroutine context—in this case, a single-threaded one. Switching context is a powerful technique that lets us manipulate, in a fine-grained way, how our code runs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Thread safe structures</h1>
                
            
            
                
<p>From Java 5 and onwards, we have access to some atomic thread safe structures, that are still useful with coroutines:</p>
<pre>import java.util.concurrent.atomic.AtomicInteger<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   val counter = AtomicInteger(0)<br/><br/>   val time = measureTimeMillis {<br/>      repeatInParallel(1_000_000) {<br/>         counter.incrementAndGet()<br/>      }<br/>   }<br/>   println("counter = ${counter.get()}")<br/>   println("time = $time")<br/>}</pre>
<p><kbd>AtomicInteger</kbd> gives us many atomic operations that are thread safe. There are more thread safe structures such as other atomic primitives and concurrent collections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mutexes</h1>
                
            
            
                
<p>A <kbd>Mutex</kbd> (mutual exclusion) object allows access to multiple coroutines to share the same resource but not simultaneously:</p>
<pre>import kotilnx.coroutines.experimental.sync.Mutex<br/>import kotlinx.coroutines.experimental.sync.withLock<br/><br/>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   val mutex = Mutex()<br/>   var counter = 0<br/><br/>   val time = measureTimeMillis {<br/>      repeatInParallel(1_000_000) {<br/>         mutex.withLock {<br/>            counter++<br/>         }<br/>      }<br/>   }<br/>   println("counter = $counter")<br/>   println("time = $time")<br/>}</pre>
<p>A <kbd>Mutex</kbd> object works similarly to a synchronized control structure, but, instead of blocking the thread, it just blocks the coroutine.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Actors</h1>
                
            
            
                
<p>An <kbd>actor</kbd> is kind of object that interacts with other actors and with the external world through messages. An <kbd>actor</kbd> object can have a private internal mutable state that can be modified and accessed externally through messages, but not directly. Actors are growing in popularity in recent years due to their consistent programming model, and have been tested successfully in multi-million user applications, such as <strong>WhatsApp</strong> that is built with <strong>Erlang</strong>, the language that brings actors into the limelight:</p>
<pre>import kotlinx.coroutines.experimental.channels.actor<br/><br/>sealed class CounterMsg<br/>object IncCounter : CounterMsg()<br/>class GetCounter(val response: CompletableDeferred&lt;Int&gt;) : CounterMsg()<br/><br/>fun counterActor(start:Int) = actor&lt;CounterMsg&gt; {<br/>   var counter = start<br/>   for (msg in channel) {<br/>      when (msg) {<br/>         is IncCounter -&gt; counter++<br/>         is GetCounter -&gt; msg.response.complete(counter)<br/>      }<br/>   }<br/>}<br/><br/></pre>
<p>To write an <kbd>actor</kbd>, first, we need to define which messages we want to send. Here, we are creating two messages, <kbd>IncCounter</kbd> and <kbd>GetCounter</kbd>. <kbd>GetCounter</kbd> has a <kbd>CompletableDeferred&lt;Int&gt;</kbd> value that will let us know the counter value outside the <kbd>actor</kbd>.</p>
<p>We can use the <kbd>actor&lt;CounterMsg&gt;</kbd> builder to create <kbd>actor</kbd>. Inside our <kbd>actor</kbd> coroutine, we have access to the <kbd>channel</kbd> property, <kbd>ReceiveChannel&lt;CounterMsg&gt;</kbd>, to receive the messages and react to them. The <kbd>counterActor(Int)</kbd> function will return <kbd>SendChannel&lt;CounterMsg&gt;</kbd>; therefore, the only functions that we can call are <kbd>send(CounterMsg)</kbd> and <kbd>close()</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) = runBlocking {<br/>   val counterActor = counterActor(0)<br/><br/>   val time = measureTimeMillis {<br/>      repeatInParallel(1_000_000) {<br/>         counterActor.send(IncCounter)<br/>      }<br/>   }<br/>   <br/>   val counter = CompletableDeferred&lt;Int&gt;()<br/>   counterActor.send(GetCounter(counter))<br/>   println("counter = ${counter.await()}")<br/>   println("time = $time")<br/>}</pre>
<p>Actors can be hard to grasp at the beginning but once, you understand, the <kbd>actor</kbd> model is straightforward for creating complex and powerful systems.</p>
<p>In the example code for this book, you can find an implementation of our <kbd>UserService</kbd> example using <kbd>actors</kbd>. You can watch it online at <a href="https://github.com/MarioAriasC/FunctionalKotlin/blob/master/Chapter07/src/main/kotlin/com/packtpub/functionalkotlin/chapter07/facts.kt#L377">https://github.com/MarioAriasC/FunctionalKotlin/blob/master/Chapter07/src/main/kotlin/com/packtpub/functionalkotlin/chapter07/facts.kt#L377</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Coroutines show a high potential to transform the way we think about asynchronous code and execution. In this chapter, we covered how to write coroutines and how to use coroutine contexts and channels. We also took a comprehensive look at how to deal with asynchronous shared mutable state.</p>
<p>In our next chapter, we'll learn about functional collections and their operations.</p>


            

            
        
    </body></html>