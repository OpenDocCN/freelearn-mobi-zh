- en: Chapter 3. Basic Moai SDK Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every game engine has its own concepts behind it that define its internal workings.
    In this chapter, we will take a quick tour of the different ideas that Moai SDK
    uses, in order to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: The Moai SDK Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moai's Runtime uses two important data structures, namely, a *dependency graph
    of objects/nodes* and a *tree of actions*. What you'll (mostly) do as a developer
    is modify those data structures (in Lua, using the Moai SDK API).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Moai update loop has three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Process the Input Queue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the Action Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the Node Graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Moai, *rendering is detached from the game loop*, since we might want to
    have more than one update step for every rendered frame.
  prefs: []
  type: TYPE_NORMAL
- en: Input Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you press a key, move the mouse, or tap on your iPhone's screen, the system
    generates an input event that is passed to Moai by the **Host** and put into a
    queue (Using AKUEnqueue* methods). In every step of the simulation, Moai handles
    all input callbacks, processes the Input Queue, and then continues with the game
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Input Queue](img/5064_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the events that occur during the game loop are enqueued in the next simulation
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Action Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nodes are basically all of the objects that have information for your game,
    for example, an instance of a bullet would be a node in Moai, specifically a node
    that can be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Actions are in charge of managing the node's variation over time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, changes in position, rotation, or scale would create an animation.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the the Action Tree is to create a hierarchy of actions. The main
    goal for this is to enable actions to be responsible for the execution of child
    actions. Moai has a main root action that will run all of the actions appended
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Actions are the only objects in Moai that receive time steps. This means that
    time-based changes to Moai objects may only occur while processing the Action
    Tree. The Node Graph or rendering processes should not perform any change to the
    state of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Node Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, as we saw before, nodes are basically the objects that are living in your
    game. These objects connect with one another forming a graph. In every update
    loop step, Moai processes the nodes that have different states than the previous
    step. This is achieved with a queue of modified nodes. Every time an action modifies
    a node (or the node is linked to another node that was modified, or when a node's
    property was set directly), it's scheduled (along with the nodes it's connected
    to, and so on) and processed in the next simulation step.
  prefs: []
  type: TYPE_NORMAL
- en: '![Node Graph](img/5064_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This behavior defines a parent/child relationship that is built at a low level,
    and thus allows easily created scene and animation hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, where does the rendering take place then? In Moai SDK, rendering is detached
    from the update loop. The Render Manager is a singleton that is in charge of rendering.
    It keeps a table of objects to be rendered, you can modify that table as you want,
    and it will render all of the objects in it. It is worth mentioning that subtables
    are also rendered, so you can create a hierarchy of objects to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Moai Hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key concepts behind Moai SDK is that of **hosts**.
  prefs: []
  type: TYPE_NORMAL
- en: This is a neat solution that the folks from Zipline proposed for Moai SDK and
    basically states that Moai SDK provides a Lua interpreter and a C++ interface
    to the outside world. This interface is called **AKU** , and can be found in the
    Moai SDK source code.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you want to create a game for a specific platform, your host is in
    charge of configuring the input and sending input events to Moai, solving any
    threading issues from that platform, and also providing all platform-specific
    logic and Lua extensions along with an OpenGL canvas for rendering.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, a game built in Moai is potentially deployable to all platforms
    that support C++ and OpenGL (well, not all OpenGL, just a subset of it, such as
    OpenGL ES), and those being industry standards, there is hardly any limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Moai SDK is shipped with sample hosts for Windows, Mac OS X, iOS, Android, and
    Google's Native Client. You should be able to modify these hosts, and with little
    tweaks, have your game working on them.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you build your game once using Lua, and you'll get all of these platforms
    to run on.
  prefs: []
  type: TYPE_NORMAL
- en: Lua and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting feature behind Moai is the that you have access to both
    Lua and C++ to develop your game.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up your nodes and actions using Lua, Moai SDK runs the simulation
    using native code written in C++. This means that you get the best of both worlds—the
    flexibility of Lua and the speed of C++.
  prefs: []
  type: TYPE_NORMAL
- en: All the platform-specific stuff (for example, handling the accelerometer on
    a smartphone) should be handled natively and connected to Moai SDK using a Lua
    extension or input events (check how hosts configure AKU, search for the AKUSetInputDevice*
    family of methods).
  prefs: []
  type: TYPE_NORMAL
- en: This is a key concept for Moai SDK development, because you can see that there
    is no limit to what libraries you can use with Moai SDK. It's just a matter of
    taking the time to write a Lua extension for it, and Bam! It's available in the
    scripting environment; you can combine the library functionality with your already
    existing game.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from this, there is always the interpreted versus compiled native code
    dilemma. You know that working with Lua is more productive than using C++ for
    all the coding, but there are times when you just can't do something in Lua because
    of performance requirements. (Although this is extremely rare, Lua is fairly fast
    and bottlenecks usually are to be found in rendering, logic execution takes very
    little time). You can always port your code to C++ (you can decide whether this
    is needed using profiling tools), then create a Lua extension with the same API,
    and you won't need to modify the rest of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about the nuts and bolts of the Moai SDK update loop
    in order to understand its inner workings. We took a look at the three main steps
    in the update loop, namely, the Input Queue, processing of the Action Tree, and
    processing of the Node Graph. We talked about Moai's detached rendering nature,
    the importance of hosts, and the idea behind having the C++ and Lua worlds tied
    together, and how to make wise use of that.
  prefs: []
  type: TYPE_NORMAL
- en: Well, enough talk about what's going on behind the scenes. Get a coffee now,
    since in the next chapter, we'll finally start implementing our first game and
    your curiosity won't let you take a break then.
  prefs: []
  type: TYPE_NORMAL
