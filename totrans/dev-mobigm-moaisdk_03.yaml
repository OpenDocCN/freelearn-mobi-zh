- en: Chapter 3. Basic Moai SDK Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 基本Moai SDK概念
- en: Every game engine has its own concepts behind it that define its internal workings.
    In this chapter, we will take a quick tour of the different ideas that Moai SDK
    uses, in order to understand it better.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏引擎都有其背后的概念，这些概念定义了其内部工作方式。在本章中，我们将快速浏览Moai SDK使用的不同想法，以便更好地理解它。
- en: The Moai SDK Runtime
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moai SDK 运行时
- en: Moai's Runtime uses two important data structures, namely, a *dependency graph
    of objects/nodes* and a *tree of actions*. What you'll (mostly) do as a developer
    is modify those data structures (in Lua, using the Moai SDK API).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Moai的运行时使用两个重要的数据结构，即对象/节点的*依赖图*和*动作树*。作为开发者，你主要会修改这些数据结构（在Lua中使用Moai SDK API）。
- en: 'The Moai update loop has three steps:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Moai更新循环有三个步骤：
- en: Process the Input Queue
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理输入队列
- en: Process the Action Tree
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理动作树
- en: Process the Node Graph
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理节点图
- en: In Moai, *rendering is detached from the game loop*, since we might want to
    have more than one update step for every rendered frame.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Moai中，*渲染与游戏循环分离*，因为我们可能希望每个渲染帧有多个更新步骤。
- en: Input Queue
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入队列
- en: When you press a key, move the mouse, or tap on your iPhone's screen, the system
    generates an input event that is passed to Moai by the **Host** and put into a
    queue (Using AKUEnqueue* methods). In every step of the simulation, Moai handles
    all input callbacks, processes the Input Queue, and then continues with the game
    loop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下一个键、移动鼠标或在iPhone屏幕上轻触时，系统会生成一个输入事件，由**主机**传递给Moai并放入队列（使用AKUEnqueue*方法）。在模拟的每个步骤中，Moai处理所有输入回调，处理输入队列，然后继续游戏循环。
- en: '![Input Queue](img/5064_03_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![输入队列](img/5064_03_01.jpg)'
- en: All the events that occur during the game loop are enqueued in the next simulation
    step.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏循环期间发生的所有事件都会在下一个模拟步骤中排队。
- en: Action Tree
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作树
- en: Nodes are basically all of the objects that have information for your game,
    for example, an instance of a bullet would be a node in Moai, specifically a node
    that can be rendered.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 节点基本上是所有为你游戏提供信息的对象，例如，子弹的实例在Moai中就是一个节点，具体来说是一个可以渲染的节点。
- en: Actions are in charge of managing the node's variation over time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 动作负责管理节点随时间的变化。
- en: For example, changes in position, rotation, or scale would create an animation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，位置、旋转或缩放的变化将创建一个动画。
- en: The role of the the Action Tree is to create a hierarchy of actions. The main
    goal for this is to enable actions to be responsible for the execution of child
    actions. Moai has a main root action that will run all of the actions appended
    to it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 动作树的作用是创建动作的层次结构。这样做的主要目的是让动作负责执行子动作。Moai有一个主根动作，将运行附加到其上的所有动作。
- en: Actions are the only objects in Moai that receive time steps. This means that
    time-based changes to Moai objects may only occur while processing the Action
    Tree. The Node Graph or rendering processes should not perform any change to the
    state of nodes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是Moai中唯一接收时间步的对象。这意味着Moai对象的时间相关变化可能只发生在处理动作树时。节点图或渲染过程不应对节点的状态进行任何更改。
- en: Node Graph
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点图
- en: So, as we saw before, nodes are basically the objects that are living in your
    game. These objects connect with one another forming a graph. In every update
    loop step, Moai processes the nodes that have different states than the previous
    step. This is achieved with a queue of modified nodes. Every time an action modifies
    a node (or the node is linked to another node that was modified, or when a node's
    property was set directly), it's scheduled (along with the nodes it's connected
    to, and so on) and processed in the next simulation step.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们之前所看到的，节点基本上是存在于你的游戏中的对象。这些对象相互连接形成一个图。在每次更新循环步骤中，Moai处理与前一步状态不同的节点。这是通过一个修改节点的队列来实现的。每当一个动作修改一个节点（或者节点被链接到另一个被修改的节点，或者当一个节点的属性被直接设置时），它就会被安排（连同它连接的节点，等等）并在下一个模拟步骤中处理。
- en: '![Node Graph](img/5064_03_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![节点图](img/5064_03_02.jpg)'
- en: This behavior defines a parent/child relationship that is built at a low level,
    and thus allows easily created scene and animation hierarchies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为定义了一个在低级别构建的父/子关系，因此可以轻松创建场景和动画层次结构。
- en: Rendering
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染
- en: So, where does the rendering take place then? In Moai SDK, rendering is detached
    from the update loop. The Render Manager is a singleton that is in charge of rendering.
    It keeps a table of objects to be rendered, you can modify that table as you want,
    and it will render all of the objects in it. It is worth mentioning that subtables
    are also rendered, so you can create a hierarchy of objects to be rendered.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，渲染在哪里进行呢？在Moai SDK中，渲染与更新循环分离。渲染管理器是一个单例，负责渲染。它维护一个待渲染的对象表，你可以按需修改该表，并且它将渲染表中的所有对象。值得一提的是，子表也会被渲染，因此你可以创建一个待渲染对象的层次结构。
- en: Moai Hosts
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moai主机
- en: One of the key concepts behind Moai SDK is that of **hosts**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Moai SDK背后的一个关键概念是**主机**。
- en: This is a neat solution that the folks from Zipline proposed for Moai SDK and
    basically states that Moai SDK provides a Lua interpreter and a C++ interface
    to the outside world. This interface is called **AKU** , and can be found in the
    Moai SDK source code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由Zipline团队为Moai SDK提出的解决方案，基本上表明Moai SDK提供了一个Lua解释器和对外界的C++接口。这个接口被称为**AKU**，可以在Moai
    SDK源代码中找到。
- en: Whenever you want to create a game for a specific platform, your host is in
    charge of configuring the input and sending input events to Moai, solving any
    threading issues from that platform, and also providing all platform-specific
    logic and Lua extensions along with an OpenGL canvas for rendering.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你想为特定平台创建游戏，你的主机负责配置输入并将输入事件发送到Moai，解决该平台的所有线程问题，并提供所有平台特定的逻辑和Lua扩展，以及一个OpenGL画布用于渲染。
- en: In this way, a game built in Moai is potentially deployable to all platforms
    that support C++ and OpenGL (well, not all OpenGL, just a subset of it, such as
    OpenGL ES), and those being industry standards, there is hardly any limitation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，在Moai中构建的游戏有可能部署到所有支持C++和OpenGL（好吧，不是所有的OpenGL，只是其中的一部分，如OpenGL ES）的平台，而这些是行业标准，几乎没有限制。
- en: Moai SDK is shipped with sample hosts for Windows, Mac OS X, iOS, Android, and
    Google's Native Client. You should be able to modify these hosts, and with little
    tweaks, have your game working on them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Moai SDK附带Windows、Mac OS X、iOS、Android和Google的Native Client的示例主机。你应该能够修改这些主机，并且通过一些小的调整，让你的游戏在这些主机上运行。
- en: Again, you build your game once using Lua, and you'll get all of these platforms
    to run on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，你只需使用Lua构建一次游戏，就可以让所有这些平台运行。
- en: Lua and C++
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lua和C++
- en: Another interesting feature behind Moai is the that you have access to both
    Lua and C++ to develop your game.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Moai背后的另一个有趣特性是，你可以访问Lua和C++来开发你的游戏。
- en: After setting up your nodes and actions using Lua, Moai SDK runs the simulation
    using native code written in C++. This means that you get the best of both worlds—the
    flexibility of Lua and the speed of C++.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Lua设置你的节点和动作后，Moai SDK使用用C++编写的本地代码运行模拟。这意味着你得到了两者的最佳结合——Lua的灵活性和C++的速度。
- en: All the platform-specific stuff (for example, handling the accelerometer on
    a smartphone) should be handled natively and connected to Moai SDK using a Lua
    extension or input events (check how hosts configure AKU, search for the AKUSetInputDevice*
    family of methods).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有平台特定的东西（例如，处理智能手机上的加速度计）都应该以本地方式处理，并通过Lua扩展或输入事件连接到Moai SDK（检查主机如何配置AKU，搜索AKUSetInputDevice*方法系列）。
- en: This is a key concept for Moai SDK development, because you can see that there
    is no limit to what libraries you can use with Moai SDK. It's just a matter of
    taking the time to write a Lua extension for it, and Bam! It's available in the
    scripting environment; you can combine the library functionality with your already
    existing game.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Moai SDK开发的一个关键概念，因为你可以看到，你可以使用Moai SDK的库没有限制。这只是一个花时间编写Lua扩展的问题，然后Bam！它就在脚本环境中可用；你可以将库功能与你的现有游戏结合起来。
- en: Aside from this, there is always the interpreted versus compiled native code
    dilemma. You know that working with Lua is more productive than using C++ for
    all the coding, but there are times when you just can't do something in Lua because
    of performance requirements. (Although this is extremely rare, Lua is fairly fast
    and bottlenecks usually are to be found in rendering, logic execution takes very
    little time). You can always port your code to C++ (you can decide whether this
    is needed using profiling tools), then create a Lua extension with the same API,
    and you won't need to modify the rest of your code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个之外，还有解释型代码与编译型原生代码的困境。你知道使用 Lua 进行编程比使用 C++ 更有效率，但有时由于性能要求，你就是在 Lua 中也做不了某些事情。（尽管这种情况非常罕见，Lua
    还是相当快的，瓶颈通常出现在渲染上，逻辑执行花费的时间非常少）。你总是可以将你的代码移植到 C++（你可以使用性能分析工具来决定是否需要这样做），然后创建一个具有相同
    API 的 Lua 扩展，你就不需要修改你代码的其他部分了。
- en: Summary
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we talked about the nuts and bolts of the Moai SDK update loop
    in order to understand its inner workings. We took a look at the three main steps
    in the update loop, namely, the Input Queue, processing of the Action Tree, and
    processing of the Node Graph. We talked about Moai's detached rendering nature,
    the importance of hosts, and the idea behind having the C++ and Lua worlds tied
    together, and how to make wise use of that.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了 Moai SDK 更新循环的细节，以便理解其内部工作原理。我们考察了更新循环中的三个主要步骤，即输入队列、动作树的处理以及节点图的处理。我们讨论了
    Moai 的独立渲染特性、主机的重要性以及将 C++ 和 Lua 世界联系在一起的理念，以及如何明智地利用这一点。
- en: Well, enough talk about what's going on behind the scenes. Get a coffee now,
    since in the next chapter, we'll finally start implementing our first game and
    your curiosity won't let you take a break then.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，关于幕后发生的事情我们已经说得够多了。现在去喝杯咖啡吧，因为接下来的一章，我们将最终开始实现我们的第一个游戏，你的好奇心不会让你那时停下来休息。
