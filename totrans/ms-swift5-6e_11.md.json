["```swift\nfunc swapInts(a: inout Int,b: inout Int) { \n    let tmp = a\n    a = b\n    b = tmp\n}\nfunc swapDoubles(a: inout Double,b: inout Double) { \n    let tmp = a\n    a = b\n    b = tmp\n}\nfunc swapStrings(a: inout String, b: inout String) { \n    let tmp = a\n    a = b\n    b = tmp\n} \n```", "```swift\nfunc swapGeneric<T>(a: inout T, b: inout T) { \n    let tmp = a\n    a = b\n    b = tmp\n} \n```", "```swift\nfunc swapGeneric<G>(a: inout G, b: inout G) {\n    //Statements\n}\nfunc swapGeneric<xyz>(a: inout xyz, b: inout xyz) {\n    //Statements\n} \n```", "```swift\nfunc testGeneric<T,E>(a: T, b: E) {\n    //Statements\n} \n```", "```swift\nvar a = 5\nvar b = 10\nswapGeneric(a: &a, b: &b)\nprint(\"a:\\(a) b:\\(b)\") \n```", "```swift\nvar c = \"My String 1\"\nvar d = \"My String 2\"\nswapGeneric(a: &c, b: &d)\nprint(\"c:\\(c) d:\\(d)\") \n```", "```swift\nvar a = 5\nvar c = \"My String 1\"\nswapGeneric(a: &a, b: &c) \n```", "```swift\nfunc testGeneric<T,E>(a: T, b: E) { \n    print(\"\\(a)\\(b)\")\n} \n```", "```swift\nfunc genericEqual<T>(a: T, b: T) -> Bool{ \n    return a == b\n} \n```", "```swift\nfunc testGenericComparable<T: Comparable>(a: T, b: T) -> Bool{ \n   a == b\n} \n```", "```swift\nfunc testFunction<T: MyClass, E: MyProtocol>(a: T, b: E) {\n    //Statements\n} \n```", "```swift\nclass List<T> {\n} \n```", "```swift\nvar stringList = List<String>() \nvar intList = List<Int>()\nvar customList = List<MyObject>() \n```", "```swift\nstruct GenericStruct<T> {\n}\n   enum GenericEnum<T> {\n} \n```", "```swift\nclass List<T> {\n   var items = [T]()\n} \n```", "```swift\nfunc add(item: T) { \n    items.append(item)\n} \n```", "```swift\nfunc getItemAtIndex(index: Int) -> T? { \n    if items.count>index {\n        return items[index]\n    } else {\n        return nil\n    }\n} \n```", "```swift\nclass List<T> {\n    var items = [T]() \n    func add(item: T) {\n        items.append(item)\n    }\n    func getItemAtIndex(index: Int) -> T? { \n        guard items.count < index else {\n            return items[index]\n         }\n         return nil\n    }\n} \n```", "```swift\nvar list = List<String>()\nlist.add(item: \"Hello\")\nlist.add(item: \"World\")\nprint(list.getItemAtIndex(index: 1)) \n```", "```swift\nclass MyClass<T,E>{\n//Code\n} \n```", "```swift\nvar mc = MyClass<String, Int>() \n```", "```swift\nclass MyClass<T: Comparable>{} \n```", "```swift\nextension List where T: Numeric { \n    func sum () -> T {\n       items.reduce (0, +)\n    }\n} \n```", "```swift\nvar list2 = List<Int>()\nlist2.add(item: 2)\nlist2.add(item: 4)\nlist2.add(item: 6)\nprint(list2.sum()) \n```", "```swift\nextension List { \n    func sum () -> T where T: Numeric {\n       items.reduce (0, +)\n    }\n} \n```", "```swift\nextension List { \n    func sum () -> T where T: Numeric {\n        items.reduce (0, +)\n    }\n    func sorted() -> [T] where T: Comparable {\n        items.sorted()\n    }\n} \n```", "```swift\nextension List: Equatable where T: Equatable { \n    static func ==(l1:List, l2:List) -> Bool {\n        if l1.items.count != l2.items.count { \n            return false\n        }\n        for (e1, e2) in zip(l1.items, l2.items) { \n            if e1 != e2 {\n                return false\n            }\n        }\n        return true\n    }\n} \n```", "```swift\nsubscript<T: Hashable>(item: T) -> Int { \n    return item.hashValue\n} \n```", "```swift\nsubscript<T>(key: String) -> T? { \n    return dictionary[key] as? T\n} \n```", "```swift\nprotocol QueueProtocol { \n    associatedtype QueueType\n    mutating func add(item: QueueType) \n    mutating func getItem() -> QueueType? \n    func count() -> Int\n} \n```", "```swift\nclass IntQueue: QueueProtocol { \n    var items = [Int]()\n    func add(item: Int) { \n        items.append(item)\n    }\n    func getItem() -> Int? {\n        return items.count > 0 ? items.remove(at: 0) : nil\n    }\n    func count() -> Int { \n        return items.count\n    }\n} \n```", "```swift\nvar intQ = IntQueue()\nintQ.add(item: 2)\nintQ.add(item: 4)\nprint(intQ.getItem()!)\nintQ.add(item: 6) \n```", "```swift\nclass GenericQueue<T>: QueueProtocol { \n    var items = [T]()\n    func add(item: T) {\n        items.append(item)\n    }\n    func getItem() -> T? {\n        return items.count > 0 ? items.remove(at:0) : nil\n    }\n    func count() -> Int { \n        return items.count\n    }\n} \n```", "```swift\nvar intQ2 = GenericQueue<Int>()\nintQ2.add(item: 2)\nintQ2.add(item: 4)\nprint(intQ2.getItem()!)\nintQ2.add(item: 6) \n```", "```swift\nassociatedtype QueueType: Hashable \n```"]