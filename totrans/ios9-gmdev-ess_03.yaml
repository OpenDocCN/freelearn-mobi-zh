- en: Chapter 2. Structuring and Planning a Game Using iOS 9 Storyboards and Segues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 使用 iOS 9 Storyboard 和 Segues 构建和规划游戏
- en: Video game development has had an interesting history. It started as an offshoot
    of both electrical engineering and computer science. Games were a great challenge
    for engineers to make the most out of the limited hardware and, of course, make
    something fun. Today, video games and video game development are still built on
    those foundations of technology, math, and engineering but, for decades, have
    also been major players in the world of entertainment, storytelling, and media.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 电子游戏开发有着有趣的历史。它始于电气工程和计算机科学的分支。游戏是工程师们充分利用有限硬件的巨大挑战，当然，还要制作出有趣的东西。今天，电子游戏和电子游戏开发仍然建立在技术、数学和工程的基础上，但几十年来，也一直是娱乐、叙事和媒体领域的主要参与者。
- en: Be it if you are a major studio, a small team, or creating games all by yourself,
    planning and structuring your game projects can give you the foundation needed
    to save time in the development process, divide the work out to others if on a
    team, and of course, bring your game to life as close as possible to how you imagined
    it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你是大型工作室、小型团队，还是独自制作游戏，规划和构建你的游戏项目可以为你提供在开发过程中节省时间的基础，如果是在团队中，可以将工作分配给他人，当然，还可以将你的游戏制作得尽可能接近你想象的样子。
- en: Starting with iOS 5, Apple took a page from the entertainment industry in how
    to structure and plan a project, big or small; by using the concept of storyboards.
    Storyboards are a graphic representation of the various steps and structures of
    a project; be it an animation, a movie, or in our case, iOS games. Storyboards
    will graphically show the flow of a production or app. In animation, for example,
    storyboards are used to flesh out major frames or story points of the production.
    Once it's agreed on as to what the series of events in a scene will be, animators
    will animate around those key points. Depending on whether the production is prelay
    or ADR, voice acting could also be placed into the storyboard process, which gives
    the animators even more specific content to work with.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iOS 5 开始，Apple 从娱乐行业借鉴了如何构建和规划项目的方法，无论是大项目还是小项目；通过使用 Storyboard 的概念。Storyboard
    是项目各种步骤和结构的图形表示；无论是动画、电影，还是我们这里的 iOS 游戏。Storyboard 将图形化地展示制作或应用程序的流程。例如，在动画中，Storyboard
    用于细化制作的主要帧或故事点。一旦就场景中的事件序列达成一致，动画师将围绕这些关键点进行动画制作。根据制作是预录音还是ADR，配音也可以放入 Storyboard
    流程中，这为动画师提供了更多具体的内容来工作。
- en: In the case of the actual game application, storyboards can represent major
    parts of your game, such as the Intro scene, Opening Menu screen, Pause Screen,
    Game Over Screen, or the generic look of a main game level. Apple named these
    structures in Xcode **storyboards**, and the paths between them are known as **segues**.
    Throughout this chapter, we shall be looking into how to make use of these features
    while making a game app.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的游戏应用程序中，Storyboard 可以表示游戏的主要部分，例如开场场景、开始菜单屏幕、暂停屏幕、游戏结束屏幕，或者主游戏级别的通用外观。Apple
    在 Xcode 中将这些结构命名为 **Storyboard**，它们之间的路径被称为 **Segues**。在本章中，我们将探讨如何在制作游戏应用程序时利用这些功能。
- en: '![Structuring and Planning a Game Using iOS 9 Storyboards and Segues](img/00002.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![使用 iOS 9 Storyboard 和 Segues 构建和规划游戏](img/00002.jpeg)'
- en: The preceding is an example of a simple iOS Storyboard.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上文是一个简单的 iOS Storyboard 示例。
- en: Model-View-Controller
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器
- en: Before we get into storyboards in iOS 9, it's best that we first discuss the
    basic flow of an iOS app and the concept of **Model-View-Controller** (**MVC**).
    Model-View-Controller is an architectural paradigm used in software engineering,
    programming, and even now in web design. We can think of the model portion of
    MVC as the logic or *brains* of an application's behavior. This logic is usually
    independent of the user interface and determines what to do with the app's data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨 iOS 9 中的 Storyboard 之前，最好我们先讨论一下 iOS 应用程序的基本流程以及 **模型-视图-控制器**（**MVC**）的概念。模型-视图-控制器是软件工程、编程，甚至在现在的网页设计中使用的一种架构范式。我们可以将
    MVC 的模型部分视为应用程序行为的逻辑或 *大脑*。这种逻辑通常独立于用户界面，并决定如何处理应用程序的数据。
- en: We've actually already gone over the model portion of MVC! The Swift programming
    language discussed in the previous chapter is that model; this is the case with
    its Objective-C predecessor and any other programming language used in iOS or
    any other game development. Your game's code controls what to do with the player,
    level, and enemy/goal data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经讨论了 MVC 的模型部分！前一章中讨论的 Swift 编程语言就是那个模型；这与它的 Objective-C 前身以及 iOS 或任何其他游戏开发中使用的任何其他编程语言都是如此。你的游戏代码控制玩家、关卡和敌人/目标数据应该做什么。
- en: The view portion of MVC is the visual representation of the model. This of course
    would include the numerous visual aspects of our games, from our player's animation
    frames, various in-game stats on the HUD, particle effects, and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 中的视图部分是模型的视觉表示。这当然包括我们游戏中的许多视觉方面，从玩家的动画帧、HUD 上的各种游戏统计信息、粒子效果等等。
- en: The controller portion of MVC can be thought of as the *glue* that holds the
    model and view together. It is also the point at which the user of your game interacts
    with. Be it actions, such as a button press, a basic touch, a swipe, or other
    gestures, recognized by your iOS device, the controller takes that user input,
    manipulates your model and then the model updates your view accordingly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 中的控制器部分可以被视为将模型和视图粘合在一起的“胶水”。它也是用户与游戏交互的点。无论是动作，如按钮点击、基本的触摸、滑动或其他由 iOS 设备识别的手势，控制器都会接收用户输入，操作模型，然后模型根据相应地更新视图。
- en: '![Model-View-Controller](img/00003.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![模型-视图-控制器](img/00003.jpeg)'
- en: This diagram is taken from Apple's own Adventure Game Example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此图来自苹果自己的冒险游戏示例。
- en: When we work with iOS apps, the first recommended entry point for code and storyboard
    info is the Root View Controller. As we'll come to find out, MVC is intrinsically
    built into iOS app development and the Xcode IDE. Storyboards are a collection
    of different types of view controllers with varying tasks that are linked by segues.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们与 iOS 应用程序合作时，代码和故事板信息的第一个推荐入口点是根视图控制器。正如我们将要发现的，MVC（模型-视图-控制器）在 iOS 应用程序开发和
    Xcode 集成开发环境（IDE）中是固有的。故事板是一系列不同类型的视图控制器，它们具有不同的任务，并通过转场（segues）相互连接。
- en: An iOS app's lifecycle
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS 应用程序的生命周期
- en: Before we move on to working with storyboards, segues, and the foundation of
    our game apps, it's best we go over the overall lifecycle of an iOS app as it's
    important to know the entry points of our code and various objects/structures
    of our apps.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理故事板、转场和游戏应用程序的基础之前，最好回顾一下 iOS 应用程序的整体生命周期，因为了解我们代码的入口点和应用程序的各种对象/结构非常重要。
- en: Insert app lifecycle imagery here before we move on to working with storyboards,
    segues, and the foundation of our game apps. It's best we go over the overall
    lifecycle of an iOS app as it's important to know the entry points of our code
    and various objects/structures of our apps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理故事板、转场和游戏应用程序的基础之前，插入应用程序生命周期图。最好我们回顾一下 iOS 应用程序的整体生命周期，因为了解我们代码的入口点和应用程序的各种对象/结构非常重要。
- en: '![An iOS app''s lifecycle](img/00004.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![iOS 应用程序的生命周期](img/00004.jpeg)'
- en: 'Source: [https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)
- en: Anyone who has worked with C/C++, Java, or other languages will be familiar
    with the `main()` function. The `main()` function is used to designate your program's
    main entry point. The preceding example is how Apple designates the typical main
    function for apps. Essentially what this is doing is calling the first class in
    the typical lifecycle of iOS apps, the `AppDelegate` class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用过 C/C++、Java 或其他语言的人都会熟悉 `main()` 函数。`main()` 函数用于指定程序的入口点。前面的例子是苹果为应用程序指定的典型
    `main()` 函数。本质上，这是在调用 iOS 应用程序典型生命周期中的第一个类，即 `AppDelegate` 类。
- en: The main() function
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`main()` 函数'
- en: 'Here''s the code with the `main()` function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有 `main()` 函数的代码：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how the `main()` function is written in Objective-C. Swift again makes
    declaring the entry of your application easier.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `main()` 函数是如何用 Objective-C 编写的。Swift 再次使声明应用程序的入口点变得简单。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While building an iOS app with Swift, the `main.m` file seen in prior Objective-C
    projects is no longer needed. Instead, we use an Attribute call, `@UIApplicationMain`,
    just before the declaration of the class that is first called.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Swift 构建iOS应用程序时，先前Objective-C项目中看到的 `main.m` 文件不再需要。相反，我们在类声明的开头使用一个属性调用，`@UIApplicationMain`。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Swift attributes**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift 属性**'
- en: 'Attributes, beginning with the *at* character, `@`, are used to add additional
    information to a declaration or a type. In Swift, they have the following syntax:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *at* 字符 `@` 开头的属性用于向声明或类型添加附加信息。在 Swift 中，它们具有以下语法：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As in other programming languages, attributes, depending on their functionality,
    can be used to describe objects, functions, and even entire classes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他编程语言中，属性根据其功能，可以用来描述对象、函数，甚至整个类。
- en: For example, the `@objc` attribute is used to declare code that is readable
    in Objective-C.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`@objc` 属性用于声明在 Objective-C 中可读的代码。
- en: As we'll see while using and linking various objects in the storyboards with
    our code, the attributes `@IBOutlet` and `@IBAction` are used to describe objects
    and functions representing objects we create in Xcode's Interface Builder.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在使用和将故事板中的各种对象与我们的代码链接时看到的那样，属性 `@IBOutlet` 和 `@IBAction` 用于描述我们在 Xcode
    的 Interface Builder 中创建的对象和函数。
- en: We will discuss more on Attributes in [Chapter 7](part0055_split_000.html#1KEEU2-d06b23b4a4554b3182353558917969c2
    "Chapter 7. Publishing Our iOS Game"), *Publishing Our iOS 9.0 Game*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](part0055_split_000.html#1KEEU2-d06b23b4a4554b3182353558917969c2 "第7章。发布我们的iOS游戏")*发布我们的iOS
    9.0游戏*中进一步讨论属性。
- en: The UIApplication class/object
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UIApplication 类/对象
- en: '`UIApplication` is the object responsible for controlling an app''s event-loop
    as well as handling other upper-level app processes. Game app or not, this is
    present in all iOS apps and is what is first called at the main entry point and
    works together with the `AppDelegate` class. Though it is possible to subclass
    `UIApplication`, it''s usually not recommended. Customizations to what your game
    does during various app states are what we use the `AppDelegate` class and `ViewControllers`
    for, even if storyboards are not utilized (that is if you choose to mostly hardcode
    your game).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIApplication` 是负责控制应用程序的事件循环以及处理其他高级应用程序流程的对象。无论游戏应用程序与否，它都存在于所有 iOS 应用程序中，并在主入口点首先被调用，并与
    `AppDelegate` 类协同工作。尽管可以子类化 `UIApplication`，但通常不推荐这样做。对您的游戏在应用程序各种状态下的行为进行定制是我们使用
    `AppDelegate` 类和 `ViewControllers` 的原因，即使没有使用故事板（也就是说，如果您选择主要使用硬编码来编写游戏）。'
- en: The AppDelegate class
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppDelegate 类
- en: We can think of the `AppDelegate` class as your app's main hub. It's the top
    level of general customization for your game. While making an app in Swift (game
    or not), it's the class that is given the `@UIApplicationMain` attribute because
    it's the general first entry of your game's model/code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `AppDelegate` 类视为您应用程序的主枢纽。它是您游戏的一般自定义的最高级别。在用 Swift（游戏或非游戏）制作应用程序时，它被赋予
    `@UIApplicationMain` 属性，因为它是您游戏模型/代码的一般首次入口。
- en: 'Here''s the code that Apple provides with almost every iOS app preset in Xcode:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Apple 几乎为每个在 Xcode 中预设的 iOS 应用程序提供的代码：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the direct code and comments (as of Xcode 6.4) that Apple provides for
    us when using the iOS 9 game preset. Before we dive into structuring our games
    with storyboards and the two main frameworks (SpriteKit and SceneKit), it's best
    to understand what happens in this class. Events that happen to your game app
    relating to the device, particularly those that are outside of the player's control,
    such as incoming phone calls, notifications, and the device shutting down due
    to low battery power, as well as those controlled by the player (that is pausing
    the game), are handled by this class. As we see, Apple already provides great
    instructions for what each function of this class does, so be sure to review them.
    We will come back to these as we create our games and handle those specific situations.
    Note that the `AppDelegate` class has an optional variable (meaning it can be
    nil) named window and is of the type, `UIWindow`. A `UIWindow` object is a child
    of `UIView` and can allocate various displays/objects that can be put into the
    view of the user. Technically, we can use objects of `UIWindow` and `UIView` in
    code directly to create the visuals of our game, but Apple provides more robust
    objects that handle both the user's interaction with the screen and view. These
    objects are what make up iOS storyboards; the ably named, `ViewControllers`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Apple在iOS 9游戏预设中为我们提供的直接代码和注释（截至Xcode 6.4）。在我们深入使用故事板和两个主要框架（SpriteKit和SceneKit）来构建游戏结构之前，最好了解这个类中发生的事情。与设备相关的事件，尤其是那些在玩家控制之外的，如来电、通知以及由于低电量而关闭设备，以及那些由玩家控制的（即暂停游戏）事件，都由这个类处理。正如我们所见，Apple已经为这个类的每个函数提供了很好的说明，所以请务必查看它们。我们将在创建游戏和处理那些特定情况时回到这些说明。请注意，`AppDelegate`类有一个可选变量（意味着它可以设置为nil），名为`window`，其类型为`UIWindow`。`UIWindow`对象是`UIView`的子类，可以分配各种显示/对象，这些对象可以被放入用户的视图中。技术上，我们可以直接在代码中使用`UIWindow`和`UIView`的对象来创建游戏的视觉效果，但Apple提供了更健壮的对象，这些对象可以处理用户与屏幕和视图的交互。这些对象构成了iOS故事板，被命名为`ViewControllers`。
- en: View controllers
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图控制器
- en: View controllers are probably one of the most vital structures of iOS development
    and are what storyboards are visually representing when designing them in Xcode's
    Interface Builder. In terms of their typical entry point order, it's `MAIN` -->
    `AppDelegate` --> `RootViewController` --> [calls to any additional `ViewControllers`
    instance].
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器可能是iOS开发中最关键的架构之一，也是Xcode的Interface Builder在设计时在视觉上所表示的内容。就它们典型的入口顺序而言，是`MAIN`
    --> `AppDelegate` --> `RootViewController` --> [调用任何额外的`ViewControllers`实例]。
- en: 'When we create a new app project in Xcode, Apple will make a default Root View
    Controller named `ViewController` for us. Here''s it''s code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Xcode中创建一个新的应用项目时，Apple会为我们创建一个默认的根视图控制器，命名为`ViewController`。以下是它的代码：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is the starter code given to us in Xcode with the default `ViewController.swift`
    class. As we see, it's a subclass of `UIViewController` and thus inherits all
    of its parent class's functions. One of them shown here is the function `viewDidLoad()`.
    In Swift, when we wish to override a function of a parent class, we use the keyword
    `override` before the function declaration. We also see that `super.viewDidLoad()`
    is called as well. What this does is call the parent's own version of this function
    before we add our own code/customizations and is recommended when using any of
    the functions of `UIViewController`. The `UIViewController` functions handle various
    view states; `viewDidLoad()` handles when the view is first loaded and is called
    once for the life of the `UIViewController` object during an app's lifecycle.
    If we want to call some code every time a view is seen, we can use the `viewDidAppear()`
    function of `UIViewController` instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Xcode中默认提供的`ViewController.swift`类作为起始代码。正如我们所见，它是`UIViewController`的子类，因此继承了其父类的所有功能。其中之一就是这里显示的`viewDidLoad()`函数。在Swift中，当我们希望覆盖父类的一个函数时，我们在函数声明前使用关键字`override`。我们还可以看到`super.viewDidLoad()`也被调用了。这样做的作用是在我们添加自己的代码/自定义之前调用父类自己的这个函数版本，当使用`UIViewController`的任何函数时，这是推荐的。`UIViewController`函数处理各种视图状态；`viewDidLoad()`处理视图首次加载时的情况，在应用的生命周期中，`UIViewController`对象只会被调用一次。如果我们想在每次视图可见时调用一些代码，我们可以使用`UIViewController`的`viewDidAppear()`函数代替。
- en: Here's a visual representation of these view states.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对这些视图状态的一种视觉表示。
- en: '![View controllers](img/00005.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![视图控制器](img/00005.jpeg)'
- en: Here storyboards and segues, as we'll see, essentially give us a visual and
    customizable representation of these very states and the transitions between them
    without using too much code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，故事板和转场基本上为我们提供了这些状态及其之间的转换的视觉和可定制表示，而不需要编写太多代码。
- en: 'To dive even deeper into the `UIViewController` methods, check out Apple''s
    documentation on the subject:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解 `UIViewController` 方法，请查看苹果关于该主题的文档：
- en: '[https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/](https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/)'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For anyone familiar with the game development engine Unity (which has scripts
    written in either C#, JavaScript, or the Python derivative), one way we can imagine
    the `UIViewController` functions `viewDidLoad()` and `viewDidAppear()` is that
    they are somewhat similar to the Unity functions `Awake()` and `OnEnabled()`,
    respectively. One function is called when the scene is first loaded and the other
    just before the first frame that the object is visible/enabled. The `UIViewController`
    functions however are on a more upper-level basis for the entirety of the app
    as opposed to a per `gameObject` basis.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉游戏开发引擎 Unity（其脚本用 C#、JavaScript 或 Python 衍生物编写）的人来说，我们可以想象 `UIViewController`
    函数 `viewDidLoad()` 和 `viewDidAppear()` 分别类似于 Unity 函数 `Awake()` 和 `OnEnabled()`。一个函数在场景首次加载时被调用，另一个则在对象可见/启用前的第一帧被调用。然而，`UIViewController`
    函数是基于整个应用程序的更高级别，而不是基于每个 `gameObject`。
- en: 'For more information and graphics on the entire iOS app lifecycle, check out
    the full documentation here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于整个 iOS 应用生命周期和图形信息，请查看完整的文档：
- en: '[https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html](https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html)'
- en: View controller types
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图控制器类型
- en: View controllers come in a number of types and we can create our own by subclassing
    them. The two main types are **container** view controller, which hold other view
    controllers, and content view controllers, which as we can imagine, are what display
    the content. Content view controllers include the `RootViewController`, which
    is the first view controller accessed after the app's entry point and is also
    the first view controller seen in the default `Main.Storyboard` file in a preset
    Xcode project's inspector. There are also other special types of view controllers,
    like the `UITableViewController`, used to display data listed in table cell formats
    and the `NavigationController`, which controls the navigation logic/imagery of
    the app when moving between other view controllers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 视图控制器有多种类型，我们可以通过继承它们来创建自己的视图控制器。主要有两种类型：**容器视图控制器**，它包含其他视图控制器，以及内容视图控制器，正如我们可以想象的那样，它们是显示内容的地方。内容视图控制器包括
    `RootViewController`，这是在应用程序的入口点之后访问的第一个视图控制器，也是预设 Xcode 项目中默认 `Main.Storyboard`
    文件中看到的第一个视图控制器。还有其他特殊类型的视图控制器，如用于以表格单元格格式显示数据的 `UITableViewController` 和控制应用程序在视图控制器之间移动时的导航逻辑/图像的
    `NavigationController`。
- en: 'For a more in-depth look at the various view controllers available in UIKit,
    check out the official documentation seen here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要更深入地了解 UIKit 中可用的各种视图控制器，请查看以下官方文档：
- en: '[https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1](https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)'
- en: It's actually at this point that we can begin to code our game, albeit entirely
    programming the MVC model. In the beginning of iOS game development, this was
    essentially how one would go about developing a game for the original iPhone.
    We'd programmatically work with the `UIWindow` and `ViewController` objects and
    our game's own custom classes to craft the app. As the family of iOS devices grew,
    an obvious issue began to arise. Though we can, and sometimes might have to. programmatically
    change code based on the device, dealing with a growing number of screen sizes
    and device types made it so that our code would always have to be refactored and
    produced ever increasing ambiguity whenever a new Apple iOS device was announced.
    Also, let's not forget that game development is as much of a visual designer /
    animator's work as it is a programmer's. Editing, positioning, refining, and later
    updating various visual aspects of a game can be very time consuming if done entirely
    via code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，正是在这一点上，我们可以开始编写我们的游戏代码，尽管是完全编程MVC模型。在iOS游戏开发的初期，这基本上是开发原始iPhone游戏的方式。我们会通过编程方式与`UIWindow`和`ViewController`对象以及我们游戏的自定义类一起工作来构建应用。随着iOS设备家族的壮大，一个明显的问题开始出现。尽管我们可以，有时可能不得不根据设备编程地更改代码，但处理不断增长的屏幕尺寸和设备类型使得我们的代码总是需要重构，并且每当宣布一款新的Apple
    iOS设备时，都会产生越来越多的模糊性。此外，别忘了游戏开发与视觉设计师/动画师的工作一样，也是程序员的工作。如果完全通过代码进行编辑、定位、精炼和更新游戏的各个视觉方面，可能会非常耗时。
- en: 'Storyboards were made to help alleviate this issue by allowing us to visually
    design our game in the project itself as oppose to having our own possibly handwritten
    storyboards that describe just a model-based, code-centric design. With the introduction
    of Auto Layout in Xcode 5, we can, without using any code, make one project and
    general view for all varieties of iOS devices. We shall touch on AutoLayout as
    we now finally move on to working with Storyboards and segues, but for a more
    in-depth look on Auto Layout, check out the official documentation on Apple''s
    developer portal: [https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG](https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 故事板是为了帮助解决这一问题而设计的，它允许我们在项目中直观地设计我们的游戏，而不是拥有我们自己的可能手写的仅描述基于模型、以代码为中心的设计的故事板。随着Xcode
    5中自动布局的引入，我们可以不使用任何代码，为所有类型的iOS设备制作一个项目和通用视图。当我们现在终于转向与故事板和转场一起工作时，我们将涉及自动布局，但为了更深入地了解自动布局，请查看Apple开发者门户上的官方文档：[https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG](https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG)。
- en: Storyboards and segues
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事板和转场
- en: Let's now finally get to working with these tools and learn the basics of structuring
    game apps on a broader storyboard level. As of the writing of this book, the latest
    version of Xcode available is version 7.0\. This will be the version we shall
    work with, but Xcode is always updating with even a beta version available to
    separately test the newest features.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在终于开始使用这些工具，并学习在更广泛的Storyboard级别上结构化游戏应用的基础知识。截至本书编写时，可用的最新Xcode版本是7.0。这将是我们将使用的版本，但Xcode总是在更新，甚至有一个单独的测试最新功能的测试版。
- en: Visit [https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)
    to download and read up on all that Xcode has to offer for iOS developers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://developer.apple.com/xcode/](https://developer.apple.com/xcode/)下载并了解Xcode为iOS开发者提供的一切。
- en: 'To start structuring your app using storyboards, follow these instructions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用故事板来结构化你的应用，请遵循以下说明：
- en: First, open Xcode in your `Applications` folder (or in your Dock if you placed
    it there for easy access).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的`Applications`文件夹中打开Xcode（或者如果你将其放在Dock中以方便访问，就在Dock中打开）。
- en: Next, click on **Create a new Xcode Project**.![Storyboards and segues](img/00006.jpeg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**创建一个新的Xcode项目**。![故事板和转场](img/00006.jpeg)
- en: You will now be asked to choose a template preset.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你将需要选择一个模板预设。
- en: For the sake of just understanding storyboards and segues, select the Single
    View Application template. (Don't worry, we will be using the game template in
    the next chapter).![Storyboards and segues](img/00007.jpeg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了仅仅理解故事板和转场，选择单视图应用模板。（不要担心，我们将在下一章中使用游戏模板）。![故事板和转场](img/00007.jpeg)
- en: Now we choose our project's options. Name your project `StoryBoardExample`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们选择我们的项目选项。将你的项目命名为`StoryBoardExample`。
- en: In the **Language** dropdown, make sure that it is set to **Swift** and ensure
    the **Devices** dropdown is set to **Universal**.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**语言**下拉菜单中，确保它设置为**Swift**，并确保**设备**下拉菜单设置为**通用**。
- en: There should be other fields filled in by Xcode, such as your organization name
    and organization identifier. Those are involved with the information that will
    be published with your app when it comes to deployment as well as the content
    of your code's copyright comments. We can for now keep these at their default
    setting that Xcode has filled in.![Storyboards and segues](img/00008.jpeg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该还有其他字段由Xcode填写，例如你的组织名称和组织标识符。这些与你的应用程序部署时将发布的信息以及你的代码版权注释的内容有关。我们现在可以保持这些默认设置，即Xcode已填写的设置。![故事板和转场](img/00008.jpeg)
- en: Click on **Next** and then select a valid location in your files to save this
    project.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**下一步**，然后选择一个有效的位置来保存此项目。
- en: Now we have our default app created by the template. We should see on the left-hand
    side, in the File Navigator Pane, various files and folders created for us. As
    we can see, the `AppDelegate.swift` and the `ViewController.swift` files were
    automatically created for us and right below that, we'd find the `Main.Storyboard`
    file. This is our storyboard and when you click on it, you should see the two
    panes open at the center of your Xcode window. The left side is the view controller
    **Scene** dropdown, which shows the hierarchy of the scene controlled by the provided
    the view controller. The right pane in the center allows us to visually see the
    view controller and eventually elements that we can place in it. The main visual
    part of the storyboard can be zoomed in and zoomed out. As we add more scenes
    to it, this will allow us to see the entirety of our storyboard or the portions
    we are working on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过模板创建了默认应用程序。我们应该在左侧的文件导航器面板中看到为我们创建的各种文件和文件夹。正如我们所看到的，`AppDelegate.swift`和`ViewController.swift`文件已经为我们自动创建，在其下方，我们会找到`Main.Storyboard`文件。这是我们的故事板，当你点击它时，你应该在Xcode窗口的中心看到两个面板打开。左侧是视图控制器**场景**下拉菜单，它显示了由提供的视图控制器控制的场景层次结构。中心右侧的面板允许我们直观地看到视图控制器以及我们可以放置其中的元素。故事板的主要视觉部分可以放大和缩小。当我们向其中添加更多场景时，这将允许我们看到整个故事板或我们正在工作的部分。
- en: You might have to zoom out slightly to see it (using your mouse or using the
    pinching gesture on your trackpad with a MacBook), but to the left of the View
    Controller scene there's a gray arrow. This is the entry point and the first View
    Controller scene attached to this arrow is your `RootViewController`/Initial scene.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要稍微缩小一些才能看到它（使用鼠标或使用MacBook上的捏合手势），但在视图控制器场景的左侧有一个灰色箭头。这是入口点，与这个箭头相连的第一个视图控制器场景是你的`RootViewController`/初始场景。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When adding more scenes to your storyboard, for either debugging purposes or
    design choice, you can simply change the scene that is first entered by clicking
    and dragging that arrow to the left of that scene.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要为你的故事板添加更多场景，无论是为了调试目的还是设计选择，你可以简单地通过点击并拖动该场景左侧的箭头来更改第一个进入的场景。
- en: 'Let''s start by creating a separate scene for our storyboard:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先为我们的故事板创建一个单独的场景：
- en: At the bottom of the **Utilities** panel (the far right panel of the Xcode project),
    there are four icons designating the various snippets and objects we can place
    in our project's code and the storyboard. Click on the third icon from the left
    if it's not already selected. This will open the Object Library.![Storyboards
    and segues](img/00009.jpeg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**实用工具**面板的底部（Xcode项目的最右侧面板），有四个图标代表我们可以放置在我们项目代码和故事板中的各种代码片段和对象。如果第三个图标尚未选中，请点击它。这将打开对象库。![故事板和转场](img/00009.jpeg)
- en: We can see that the very top of the Object Library has a **View Controller**
    object.![Storyboards and segues](img/00010.jpeg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以看到对象库的顶部有一个**视图控制器**对象。![故事板和转场](img/00010.jpeg)
- en: Drag this onto the storyboard's canvas, preferably to the right of the initial
    scene.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其拖动到故事板的画布上，最好拖动到初始场景的右侧。
- en: Note
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the **Utilities** panel isn't open, click on the upper right-most icon at
    the top of your project's toolbar window.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果**实用工具**面板没有打开，请点击项目工具栏窗口右上角的最图标。
- en: '![Storyboards and segues](img/00011.jpeg)'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![故事板和转场](img/00011.jpeg)'
- en: Note
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The three buttons in your toolbar can be toggled to close the **Navigation**
    pane, **Debug** pane, and **Utilities** pane, respectively. Closing these when
    applicable can help expand the general view, known as the canvas of your storyboard
    scenes.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工具栏中的三个按钮可以切换以关闭**导航**面板、**调试**面板和**实用工具**面板。在适用的情况下关闭这些面板可以帮助扩展一般视图，即你的故事板场景的画布。
- en: Now we have two scenes in our storyboard, but nothing is there to tell us what
    they are. They are just two blank scenes!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们故事板中有两个场景，但没有任何东西告诉我们它们是什么。它们只是两个空场景！
- en: Let's put a **Label** object in these scenes to represent what they are and
    at runtime tell us which one we are in.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这些场景中放置一个**标签**对象来表示它们是什么，并在运行时告诉我们我们处于哪个场景。
- en: To keep this in the mindset of developing a game, let's put a label in the first
    one called **Intro Scene**, where we'd maybe have an intro animation to our game
    with a **Start/Options** menu, and in the next one, put the label `Game Scene`
    to represent that this is where that actual gameplay would occur.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持开发游戏的思维模式，让我们在第一个场景中放置一个名为**Intro Scene**的标签，在那里我们可能会有一个游戏开场动画和一个**开始/选项**菜单，在下一个场景中，放置标签`Game
    Scene`来表示实际游戏玩法将在这里发生。
- en: 'Here''s how to do that:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何做到这一点：
- en: Go to the bottom of the **Utilities** panel and use the search field to search
    `label`. This will isolate the `label` object, so you don't have to scroll through
    the entire list.![Storyboards and segues](img/00012.jpeg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**实用工具**面板底部，使用搜索字段搜索`label`。这将隔离`label`对象，因此你不必在整个列表中滚动。![故事板和转场](img/00012.jpeg)
- en: Drag the `label` object to the canvas of the first scene. If it doesn't look
    like it's trying to snap to the scene's canvas, you might have to select the **View**
    portion of that view controller scene's hierarchy, using the left pane of the
    Main/Storyboard's main view. Alternately, you can also double-click the view in
    the Inspector to get the scene in focus so that you can place the label onto it.![Storyboards
    and segues](img/00013.jpeg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`label`对象拖动到第一个场景的画布上。如果它看起来没有尝试吸附到场景的画布上，你可能需要选择该视图控制器场景层次结构中的**视图**部分，使用主/故事板主视图的左侧面板。或者，你也可以在检查器中双击视图以获得场景焦点，这样你就可以将标签放置在上面。![故事板和转场](img/00013.jpeg)
- en: As we drag it, try to center the label as best as possible. The canvas will
    indicate that we are at the vertical and/or horizontal part of that scene with
    dotted blue lines. Drop it in the center.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们拖动时，尽量将标签居中。画布会用虚线表示我们处于场景的垂直和/或水平部分。将其放在中心。
- en: The **Utilities** pane should have some fields visible when selecting the label
    to control various aspects of its text like font size, alignment, and style.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择标签时，**实用工具**面板应该会显示一些字段，以控制其文本的各个方面，如字体大小、对齐方式和样式。
- en: '![Storyboards and segues](img/00014.jpeg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![故事板和转场](img/00014.jpeg)'
- en: The label will just say `Label` as the default, so let's rename it to `Intro
    Scene` for the first scene by either double-clicking the label itself in the canvas,
    or changing the name in the second field down from **Text** in the **Utilities**
    panel.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签默认情况下会显示为`Label`，所以让我们通过在画布上双击标签本身，或者在**实用工具**面板中**文本**字段下方第二个字段中更改名称，将第一个场景重命名为`Intro
    Scene`。
- en: Let's make this label a bit more prominent, so single-click on the label, click
    on the [T] icon in the **Font** field, and make the style bold with a size of
    28.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让这个标签更加突出，所以单击标签，点击**字体**字段中的[T]图标，并将样式设置为粗体，大小为28。
- en: Note how the label is clipped from the size increase and hardly visible.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意标签是如何被尺寸增加裁剪的，几乎看不见。
- en: '![Storyboards and segues](img/00015.jpeg)'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![故事板和转场](img/00015.jpeg)'
- en: Simply click on the label and expand out any one of the eight scaling icons
    at the corners of the label object on the canvas.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地单击标签，并展开画布上标签对象角落的任意一个八向缩放图标。
- en: Reposition the label to return it to the center of the scene.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将标签重新定位以将其放回场景中心。
- en: '![Storyboards and segues](img/00016.jpeg)'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![故事板和转场](img/00016.jpeg)'
- en: Create the same label for the second scene we added by simply typing *Command*
    + *D* to duplicate the label (as to not have to repeat all of the steps) and then
    drag it to the center of the other scene. Zoom out as needed and possibly click
    back on to the view part of the hierarchy if the focus change prevents the ability
    to drag the label across.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过简单地按*Command* + *D*复制标签（这样就不必重复所有步骤），然后将它拖动到另一个场景的中心。根据需要缩小视图，如果焦点改变阻止你拖动标签，可能还需要单击层次结构视图部分。
- en: Though rather rudimentary and with still some more work to do with, this is
    all it takes to create separate scenes visually. If you have an idea of how you
    want to structure your game, this is where you can start with the use of storyboards.
    Of course, there is still more to do here before we make this storyboard have
    any function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这相当基础，并且还需要做更多的工作，但这就是创建单独场景所需的全部。如果你有一个关于如何构建你的游戏的思路，这就是你可以使用故事板开始的地方。当然，在我们使这个故事板具有任何功能之前，这里还有更多的工作要做。
- en: 'We can see that Xcode is giving us the following warning:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Xcode给出了以下警告：
- en: Scene is unreachable due to lack of entry points and does not have an identifier
    for runtime access via `-instantiateViewControllerWithIdentifier`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 场景由于缺少入口点而无法访问，并且没有用于运行时访问的标识符`-instantiateViewControllerWithIdentifier`。
- en: This is referring to the Game Scene object that is essentially orphaned due
    to no connection to the Intro Scene nor the app's entry point.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指由于没有与Intro场景或应用的入口点连接而实际上成为孤儿的游戏场景对象。
- en: This is where segues come into play. Yet, before we work with segues and create
    a flow to these scenes and more, if we were to run this app, we'd note another
    issue. We could have sworn that we centered the text, but if simulating or running
    this in, say, an iPhone 6s, the text is completely off to the upper-right side.
    This is because the default canvas is a generalized *all device* template to begin
    with via Auto Layout.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是segues发挥作用的地方。然而，在我们使用segues并创建到这些场景和其他场景的流程之前，如果我们运行这个应用，我们会注意到另一个问题。我们确信我们已经将文本居中了，但如果我们模拟或运行这个应用，比如在iPhone
    6s上，文本完全偏离了右上角。这是因为默认画布是通过Auto Layout开始的一个通用的**所有设备**模板。
- en: Auto Layout has gotten easier with each new build of Xcode, but one could still
    argue it's still a bit of a hassle at times to fine tune, particularly when creating
    constraints (set spaces/margining between various storyboard objects). Let's take
    a quick look at how to work with constraints.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Xcode每个新版本的发布，Auto Layout变得更加容易，但有时仍然可以说它仍然有点麻烦，尤其是在创建约束（设置故事板对象之间的空间/边距）时。让我们快速看看如何处理约束。
- en: One quick way to alleviate the issue we have here is to just work with the **Base
    Values** panel found at the bottom center of the storyboard canvas by clicking
    on the **w/Any h/Any** text. Once clicked, a pop-up table of cells will appear.
    Rolling over with your mouse or trackpad to the various cells will bring up a
    number of different configurations as oppose to w/Any h/Any. What's great about
    this is that you can change/add and delete various objects simply based on the
    device type using these options.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解决我们这里问题的快速方法就是通过点击故事板画布底部的中心处的**Base Values**面板中的**w/Any h/Any**文本。一旦点击，就会弹出一个单元格表格。用鼠标或触控板在各个单元格上滚动，会显示与**w/Any
    h/Any**不同的多种配置。这很好，因为你可以根据设备类型简单地通过这些选项来更改/添加和删除各种对象。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before storyboards and Auto Layout, this would involve huge amounts of testing
    and refactoring of code in a view controller or Nib classes to get the layout
    just the way you'd like visually. Apple would then create the next device with
    a different screen size to prior devices, it would become an even greater hassle
    or the developer would risk a broken game on the newest device.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在故事板和Auto Layout之前，这会涉及到在视图控制器或Nib类中进行大量的测试和代码重构，以获得你想要的视觉布局。然后苹果会创建具有不同屏幕大小的下一个设备，这会变成更大的麻烦，或者开发者会在最新设备上冒游戏损坏的风险。
- en: 'To make the labels be in the center for all iPhones in portrait mode for example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使标签在所有纵向模式的iPhone上居中，例如：
- en: Hover and click on the center left-hand side of the Auto Layout panel where
    it'll say **Compact Width | Any Height** at the top of that pop-up panel/table.![Storyboards
    and segues](img/00017.jpeg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在Auto Layout面板的中心左侧，那里会显示弹出面板/表格顶部的**Compact Width | Any Height**。![故事板和segues](img/00017.jpeg)
- en: This should now change the display text at the bottom of the canvas to **w/Compact
    h/Any** and shrink the width of the scene as this layout represents all iPhones
    in Portrait and of any height (so it could be a bit off in height on an older
    iPhone 4S as oppose to the iPhone 5 or later).![Storyboards and segues](img/00018.jpeg)
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会改变画布底部的显示文本为**w/Compact h/Any**，并缩小场景的宽度，因为这个布局代表所有纵向模式的iPhone以及任何高度（所以它可能在较旧的iPhone
    4S上有点不合适，与iPhone 5或更新的设备相比）。![故事板和segues](img/00018.jpeg)
- en: Note how the labels are off center toward the upper right. This is what would
    have been seen in the simulator or on an actual iPhone in the portrait orientation.
    Drag them back to the center, and they should now look as they are seen in this
    configuration of the storyboard's canvas. If designing for iPad, then the other
    configurations would need to be changed for that.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意标签是如何偏离中心向右上方的。这就是在模拟器或实际iPhone的纵向模式中看到的样子。将它们拖回到中心，它们现在应该看起来像在这个Storyboard画布配置中看到的那样。如果为iPad设计，那么其他配置也需要相应更改。
- en: Note
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pinning with constraints could actually streamline this process. For example,
    let's say that you want to place a **Pause** button at the upper right corner
    of your Game Scene and you know that no matter the orientation, it will always
    be at a certain distance (in percentages or pixels) away from the right and top
    of a device's screen. We can click on the pin button ![Storyboards and segues](img/00019.jpeg)
    at the bottom of the canvas to create these constraints in the **w/Any h/Any**
    configuration and skip manually adjusting the icon on every one of the base configurations.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用约束可以实际上简化这个过程。例如，假设你想要在游戏场景的右上角放置一个**暂停**按钮，并且你知道无论设备方向如何，它始终会保持一定的距离（以百分比或像素为单位）远离屏幕的右侧和顶部。我们可以点击画布底部的![Storyboards
    and segues](img/00019.jpeg)固定按钮来创建这些**w/Any h/Any**配置的约束，并跳过手动调整每个基本配置上的图标。
- en: Xcode already gives us a scene, the `LaunchScreen.xib` file, which, if you have
    already ran your code, was actually what was seen first before the first view
    controller in the storyboard.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Xcode已经为我们提供了一个场景，即`LaunchScreen.xib`文件，如果你已经运行过你的代码，那么实际上在Storyboard中的第一个视图控制器之前，我们看到的就是这个文件。
- en: 'To have just your `Main.Storyboard` file be at startup you can select the main
    project file at the top left corner in the **Navigation** pane and in the **Launch
    Screen** dropdown of the **Apps Icons and Launch Images** section, select `Main.Storyboard`.
    Then, you can delete the `LaunchScreen.xib` file if no longer needed. It can be
    a good file to see working constraints, and if so be it, it can be your initial
    splash screen for your game. More on constraints can be found here in the official
    documentation: [https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html](https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html).'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要在启动时只使用`Main.Storyboard`文件，你可以在**导航**面板的左上角选择主项目文件，并在**应用程序图标和启动图像**部分的**启动屏幕**下拉菜单中选择`Main.Storyboard`。然后，如果你不再需要，可以删除`LaunchScreen.xib`文件。这个文件可以用来查看工作约束，如果需要的话，它也可以成为你游戏的初始启动画面。更多关于约束的信息可以在官方文档中找到：[https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html](https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html)。
- en: Segues
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转场
- en: 'Games have scenes, and all scenes have transitions between them. Segues are
    simply transitions between scenes in a storyboard. Segues come in various types:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏有场景，所有场景之间都有过渡。转场只是Storyboard中场景之间的过渡。转场有多种类型：
- en: '**Show**: This pushes the next view controller on top of the current one; it
    also allows for calling back if using a `UINavigationController` instance.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示**：这种方式将下一个视图控制器推到当前视图控制器之上；如果使用`UINavigationController`实例，它还允许回退。'
- en: '**Show Detail**: When using `UISplitViewController`, a Container view controller
    is typically used in iPad apps to browse news/email apps, where the left side
    of the page is a `UITableViewController` object and the other side of the same
    page are the details of that table/list. This calls the details for the `DetailView`
    controller portion of the page when triggered by a gesture from the selected item
    on the `UITableViewController` side.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示详情**：当使用`UISplitViewController`时，通常在iPad应用中使用容器视图控制器来浏览新闻/电子邮件应用，其中页面左侧是一个`UITableViewController`对象，而同一页面的另一侧是该表格/列表的详情。当从`UITableViewController`侧的选择项触发手势时，它会调用页面`DetailView`控制器部分的详情。'
- en: '**Present modally**: This presents the next view controller over the current
    but in such a way that it can be canceled, such as a full-page popup.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模态呈现**：这种方式会在当前视图控制器之上呈现下一个视图控制器，并且可以取消，例如全页弹出窗口。'
- en: '**Popover**: This is like Present modally but with more options in sizing to
    create a smaller pop-up window that can be closed and disposed of.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出视图**: 这类似于模态显示，但提供了更多尺寸选项来创建一个更小的弹出窗口，可以关闭和销毁。'
- en: '**Custom**: This is a version of a segue that you can completely customize
    with OOP code.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**: 这是一个可以完全使用面向对象（OOP）代码定制的过渡版本。'
- en: The typical storyboard structure when building say, an e-mail app, will more
    than likely need to make use of a navigation controller and `UITableView` controllers
    to structure the data and flow of the app. Now, we can very well do the same thing
    for game apps. Game Over, Menu, Rankings, and Pause screens could make use of
    these view controllers. For our example, we'll keep it simple and unrestricted
    to let you, the developer, have a better starting point to branch from.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建例如电子邮件应用时，典型的故事板结构很可能需要使用导航控制器和`UITableView`控制器来结构化数据和应用的流程。现在，我们同样可以为游戏应用做同样的事情。游戏结束、菜单、排名和暂停屏幕都可以使用这些视图控制器。在我们的例子中，我们将保持简单和不受限制，以便你，开发者，有一个更好的起点来分支。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our example here is rather simple, but in addition to providing code for this
    project, an even more detailed storyboard will be available using various view
    controllers and objects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里的例子相当简单，但除了提供这个项目的代码外，还将提供使用各种视图控制器和对象的更详细的故事板。
- en: Let's take care of that warning and link up these scenes as well as begin to
    show the overall structure of a typical game using storyboards.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来处理那个警告，并将这些场景链接起来，同时开始展示使用故事板的一个典型游戏的总体结构。
- en: First, in the **Intro Scene**, place a button labeled **START** right under
    the **Intro Scene** label. Placing a button on a storyboard is done exactly the
    same as with a label. Search for `button` or scroll down the objects in the **Utilities**
    panel and then drag and drop the button onto the scene.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在**简介场景**中，在**简介场景**标签下方放置一个标签为**开始**的按钮。在故事板上放置按钮的方式与放置标签的方式完全相同。在**实用工具**面板中搜索`button`或向下滚动对象，然后将按钮拖放到场景中。
- en: Now create two more buttons on the Game Scene view; one button labeled **Pause**
    at the top-right corner of the scene and another named **Quit** opposite the Pause
    button on the upper-left corner.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在游戏场景视图中创建另外两个按钮；一个按钮标签为**暂停**位于场景的右上角，另一个名为**退出**位于暂停按钮的左上角。
- en: Create a new `ViewController` object on the scene, preferably above or below
    the Game Scene on the canvas.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中创建一个新的`ViewController`对象，最好在画布上的游戏场景之上或之下。
- en: On the new Pause Scene, create a label `PAUSED` the same way the `Game Scene`
    and `Intro Scene` labels were made.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的暂停场景中，创建一个标签`PAUSED`，其方式与创建`Game Scene`和`Intro Scene`标签的方式相同。
- en: Then, add two buttons, **Quit** and **Resume**, and place them right under the
    **PAUSED** label.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加两个按钮，**退出**和**继续**，并将它们放在**PAUSED**标签的正下方。
- en: 'Now to create the segues visually using the storyboard:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用故事板来创建视觉上的过渡：
- en: Control-Click the **START** button object on the Intro Scene and then while
    still pressing Control-Click, drag the object toward the **Game Scene** on the
    canvas. You should see a blue line follow your cursor as you drag across. (if
    you need more space, zoom out a bit and also temporarily close the **Navigation**
    and **Utilities** panels using the toll bar buttons).
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在简介场景中，按住控制键点击**开始**按钮对象，然后仍然按住控制键，将对象拖向画布上的**游戏场景**。当你拖动时，你应该会看到一条蓝色线条跟随你的光标。（如果你需要更多空间，稍微缩小一些，并暂时使用工具栏按钮关闭**导航**和**实用工具**面板）。
- en: Drop this point anywhere on the view that isn't another object; you should see
    the entire view glow blue while doing so.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此点放置在视图上的任何非对象位置；这样做时，你应该会看到整个视图变蓝。
- en: A popup asking for the type of Segue will come up. Select **Show**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会弹出一个询问过渡类型的对话框。选择**显示**。
- en: That's it! You've created a segue, and you've also told the storyboard that
    when the user clicks that button, it'll open the Game Scene—View Controller.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这样！你已经创建了一个过渡，并且也已经告诉故事板，当用户点击那个按钮时，它将打开游戏场景—视图控制器。
- en: 'Before you move on to creating more segues, click on the door-like symbol on
    the canvas that represents the segue. On the top right in the **Utilities** panel''s
    Assets inspector, you should see an empty **Identifier** field. We can leave the
    segue empty if we''d like, but naming it could be of use if we wish to call the
    segue in code with the following line:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你继续创建更多过渡之前，点击画布上代表过渡的门形符号。在**实用工具**面板的资产检查器中，顶部右侧应该看到一个空的**标识符**字段。如果我们愿意，我们可以让过渡保持为空，但如果我们希望在代码中使用以下行来调用过渡，那么命名它可能是有用的：
- en: '[PRE5]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now repeat steps *1* through *3* to create the following segues:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在重复步骤*1*至*3*以创建以下过渡：
- en: Link Game Scene's **Quit** button back to Intro Scene.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏场景的**退出**按钮重新链接到Intro场景。
- en: Link Game Scene's **Pause** button to the PAUSED Scene.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将游戏场景的**暂停**按钮链接到PAUSED场景。
- en: Link PAUSED Scene's **Resume** button to the Game Scene.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PAUSED场景的**恢复**按钮链接到游戏场景。
- en: Link PAUSED Scene's **Quit** button to the Intro Scene.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PAUSED场景的**退出**按钮链接到Intro场景。
- en: The warning should now be gone as all of the scenes are connected with segues,
    and after possibly some Auto Layout fixes, running the app now has a game-like
    scene structure that transition the way we'd normally see in other games. We can
    go from here and make other scenes, such as a Game Over scene, a Stage Win scene,
    or others. Even if this might not be the way you'd like your final game's transitions
    to end up (particularly since the default transition of the Show segue does a
    quick vertical), this can be a very quick way of prototyping your game right off
    the bat. Custom segues and segues triggered with code are how we can dive deeper
    into fine tuning when the default setting might not match with our vision of our
    games.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有场景都已通过过渡连接，警告应该已经消失，并且在可能进行一些自动布局修复后，现在运行的应用程序具有类似游戏的场景结构，并且过渡方式与我们通常在其他游戏中看到的方式相同。我们可以从这里开始并创建其他场景，例如游戏结束场景、阶段胜利场景或其他场景。即使这可能不是你希望最终游戏过渡结束的方式（尤其是默认的Show过渡执行快速垂直过渡），这也可以是一个非常快速的方法来直接原型化你的游戏。自定义过渡和通过代码触发的过渡是我们深入了解并微调设置以符合我们对游戏愿景的方式。
- en: 'Here''s more documentation on making custom segue classes if you really want
    to dive deeper into segues:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想深入了解过渡，这里有一些关于创建自定义过渡类的文档：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStoryboardSegue_Class/index.html#//apple_ref/doc/uid/TP40010911-CH1-SW11](https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStoryboardSegue_Class/index.html#//apple_ref/doc/uid/TP40010911-CH1-SW11)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStoryboardSegue_Class/index.html#//apple_ref/doc/uid/TP40010911-CH1-SW11](https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStoryboardSegue_Class/index.html#//apple_ref/doc/uid/TP40010911-CH1-SW11)'
- en: Similarly to how we Control-Dragged the button's linkage to the next view controller
    scene, we can do the same to our `ViewController.swift` file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们如何通过拖动按钮的链接到下一个视图控制器场景，我们也可以对`ViewController.swift`文件做同样的事情。
- en: 'Here''s a summery on how to do that for the first view controller:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于如何为第一个视图控制器进行总结：
- en: Remove the previous segue. One way to do so is to right-click the button and
    to click on **x** in the **Triggered Segues** section.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除之前的过渡。这样做的一种方法是在按钮上右键单击，然后在**触发过渡**部分点击**x**。
- en: Click on the Intro Scene's view in the hierarchy to get it in focus.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击层次结构中的Intro场景视图以使其获得焦点。
- en: Control-Drag a blue line from the yellow icon on the top left of the Intro Scene's
    view controller to the Game Scene's view controller and select the Show type of
    segue.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Intro场景视图控制器左上角的黄色图标开始，控制拖动一条蓝色线到游戏场景视图控制器，并选择Show类型的过渡。
- en: Click on the segue icon in the canvas and now give the identifier of this segue
    the name `startGame`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击画布中的过渡图标，现在给这个过渡的标识符命名为`startGame`。
- en: Open the Assistant Editor (the two interlocking circles button on the top-right
    portion of the Xcode toolbar); close some panes to make any needed room.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开辅助编辑器（Xcode工具栏右上角的两个重叠的圆圈按钮）；关闭一些面板以腾出所需的空间。
- en: Control-Drag the **Start** button into the `ViewController` class; preferably
    at the bottom of the code but still within the class's closing brackets.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**开始**按钮拖动到`ViewController`类中；最好在代码底部，但仍然在类的闭合括号内。
- en: This will prompt the outlet/action popup. Select the **Action** option in the
    **Connection** dropdown and name it `startButton`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将提示输出/动作弹出窗口。在**连接**下拉菜单中选择**动作**选项，并将其命名为`startButton`。
- en: 'This will create the `IBAction` function: `@IBAction func startButton(sender:
    AnyObject) {}`.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将创建`IBAction`函数：`@IBAction func startButton(sender: AnyObject) {}`。'
- en: 'Type the following code between the braces: `self.performSegueWithIdentifier("startGame",
    sender: nil)`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在花括号之间输入以下代码：`self.performSegueWithIdentifier("startGame", sender: nil)`'
- en: This tells the view controller to perform the segue when this button is prompted
    using code.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这告诉视图控制器在代码提示此按钮时执行过渡。
- en: Storyboards versus coding
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故事板与编码
- en: There's no single correct way to do the design structure of your app as long
    as the MVC model is followed. Actually, there are programmers out there who are
    completely fine with just using the initial view controller and never use a single
    Nib or storyboard file; thus purely building their game controlled by the logic
    of their code and calls to the various View objects programmatically. In iOS development,
    there's somewhat of a design split between three main branches, hardcoding, Nibs,
    and storyboards. The original methodology was coding; Nibs came in later to first
    allow direct visual editing in Xcode and then that evolved into Storyboards, further
    built upon with the addition of Auto Layout.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 只要遵循MVC模型，就没有单一正确的方式来设计你的应用程序的结构。实际上，有些程序员完全满意于只使用初始视图控制器，而从不使用任何Nib或Storyboard文件；因此，他们纯粹通过代码逻辑和程序调用各种视图对象来构建游戏。在iOS开发中，设计上大致分为三个主要分支：硬编码、Nibs和Storyboard。最初的方法是编码；Nibs后来出现，首先允许在Xcode中进行直接视觉编辑，然后演变为Storyboard，并通过添加Auto
    Layout进一步发展。
- en: The reason there's a split between some developers and studios on the visual
    structure methodology of an iOS app is because one drawback to Nibs and storyboards
    are their lack of portability. If you wanted to port your game to another platform,
    such as Android, at descent pace, heavy use of storyboards would make it a rather
    tough to port the app to the other platform since these design features are specific
    to the iOS platform. This is when pure code would be more beneficial. Storyboards
    though give us developers an editable, visual representation of the app/game we
    wish to make and the ability to do little to no changes as the family of devices
    change.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者和工作室在iOS应用程序的视觉结构方法上存在分歧的原因是，Nibs和Storyboard的一个缺点是它们缺乏可移植性。如果你想要将你的游戏移植到另一个平台，如Android，并且以合理的速度进行，过度使用Storyboard会使将应用程序移植到其他平台变得相当困难，因为这些设计功能是特定于iOS平台的。这时，纯代码会更有益。尽管如此，Storyboard为我们开发者提供了一个可编辑的、可视化的应用程序/游戏表示，以及随着设备家族的变化进行少量或无变化的能力。
- en: Even other game development engines, such as Unity, Unreal Engine, and more,
    work on a more sandboxing, visual representation methodology with your code acting
    as more of a component to the visual as opposed to the full structure of everything
    that appears before your game characters even get rendered to the screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是其他游戏开发引擎，如Unity、Unreal Engine等，也更多地采用沙盒化、视觉表示方法，你的代码在视觉上更像是一个组件，而不是游戏角色在屏幕上渲染之前出现的所有事物的完整结构。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went over a number of app project structuring and introduction
    topics. First, we went over the Model-View-Controller paradigm followed by all
    apps, game or not, and the overall lifecycle of an iOS app that follows this structuring.
    Next, we reviewed the entry point(s) and pathway of your code in a typical app
    as well as the upper-level objects used along the way, such as the Application
    system object, the `AppDelegate` class, and view controller. Last but not least,
    we discussed the main topic of the chapter—storyboards, segues, and instructions
    on how to create a simple game flow structure. From here, we can see how relatively
    easy and quick it can be to structure various scenes for your game and transition
    between them with segues. Again, note that although storyboards are recommended,
    they can simply start as a general guide toward the final product, which gives
    you, the developer, the ability to visualize your game even if in the end preferring
    a more code-heavy design choice.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了多个应用程序项目结构和介绍主题。首先，我们讨论了所有应用程序（无论是否为游戏）都遵循的模型-视图-控制器（MVC）范式，以及遵循这种结构的iOS应用程序的整体生命周期。接下来，我们回顾了典型应用程序中你的代码的入口点（s）和路径，以及沿途使用的上层对象，例如应用程序系统对象、`AppDelegate`类和视图控制器。最后但同样重要的是，我们讨论了本章的主要主题——Storyboard、转场和创建简单游戏流程结构的说明。从这里，我们可以看到如何相对容易且快速地为游戏构建各种场景并在它们之间通过转场进行切换。再次提醒，尽管Storyboard被推荐使用，但它们可以简单地作为一个通向最终产品的通用指南，这给了你，作为开发者，即使最终更倾向于更密集的代码设计选择，也能可视化你的游戏。
- en: In the next two chapters, we are going to finally get into really coding and
    designing actual playable games. We will start off with 2D games, and since iOS
    7, Apple has given iOS developers it's own framework to handle 2D sprites and
    game physics. This framework is amply named Spritekit.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将最终开始真正编写和设计可玩的游戏。我们将从2D游戏开始，自从iOS 7以来，苹果为iOS开发者提供了一个自己的框架来处理2D精灵和游戏物理。这个框架被充分命名为Spritekit。
