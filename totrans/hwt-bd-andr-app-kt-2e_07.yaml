- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Permissions and Google Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach you how to request and obtain app permissions in Android.
    You will gain a solid understanding of how to include local and global interactive
    maps in your app by using the Google Maps API and how to request permissions to
    use device features that provide richer functionality.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to create permission requests for
    your app and handle missing permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to present data in lists using `RecyclerView`.
    Then, we used that knowledge to present the user with a list of secret cat agents.
    In this chapter, we will learn how to find the user’s location on the map and
    how to deploy cat agents to the field by selecting locations on the map.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will explore the Android permissions system. Many Android features
    are not immediately available to us. These features are gated behind a permission
    system to protect the user. For us to access those features, we must ask the user
    to allow us to do so. Some such features include but are not limited to obtaining
    the user’s location, accessing the user’s contacts, accessing their camera, and
    establishing a Bluetooth connection. Different Android versions enforce different
    permission rules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When Android 6 (Marshmallow) was introduced in 2015, for example, several permissions
    you could silently obtain on installation were deemed insecure and became runtime
    permissions, requiring explicit user consent.
  prefs: []
  type: TYPE_NORMAL
- en: We will then look at the Google Maps API. This API allows us to present the
    user with a map of any desired location in the world. We will add data to that
    map and let the user interact with the map. The API also lets you show points
    of interest and render a street view of supported locations, though we will not
    explore these features in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permission from the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing a map of the user’s location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Map clicks and custom markers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/6ShZd](https://packt.link/6ShZd)
  prefs: []
  type: TYPE_NORMAL
- en: Requesting permission from the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app might want to implement certain features that Google deems dangerous.
    This usually means access to those features could risk the user’s privacy. For
    example, some permissions may allow you to read users’ messages or determine their
    current location.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the required permission and the target Android API level we are
    developing, we may need to request that permission from the user. If the device
    is running on Android 6 (Marshmallow, API level 23), and the target API of our
    app is 23 or higher (it almost certainly will be, as most devices by now will
    run newer versions of Android), there will be no alert for the user about any
    permissions requested by the app at install time. Instead, our app must ask the
    user to grant those permissions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: When we request permission, the user sees a dialog like the one shown in *Figure
    7**.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Permission dialog for device location access](img/B19411_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Permission dialog for device location access
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For a full list of permissions and their protection level, see here: [https://developer.android.com/reference/android/Manifest.permission](https://developer.android.com/reference/android/Manifest.permission).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must include permissions in our manifest file when we intend to use them.
    A manifest with the `SEND_SMS` permission would look something like the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Safe permissions (or normal permissions, as Google calls them) would be automatically
    granted to the user. However, dangerous ones would only be granted if explicitly
    approved by the user. If we fail to request permission from the user and try to
    execute an action that requires that permission, the result would be the action
    not running at best and our app crashing at worst.
  prefs: []
  type: TYPE_NORMAL
- en: We should first check whether the user has already granted us that permission
    before asking the user for permission. If the user has not yet granted us permission,
    we may need to check whether a rationale dialog should be shown prior to the permission
    request. This depends on how obvious the justification for the request would be
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a camera app requests permission to access the camera, we can
    safely assume the reason would be clear to the user. However, some cases may not
    be as clear to the user, especially if the user is not tech-savvy. In those cases,
    we may have to justify the request to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Google provides us with a function called `shouldShowRequestPermissionRationale(Activity,
    String)` for this purpose. Under the hood, this function checks whether the user
    has previously denied the permission but also whether the user has denied us permission
    before.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to allow us to justify our request to the user for permission before
    requesting it, thus increasing the likelihood of them approving the request. Once
    we determine whether the app should present the user with our rationale or whether
    no rationale was required, we can proceed to request the permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how we can request permission. First, we must include the Jetpack
    Activity and Fragment dependencies in our app `gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will provide us with `ActivityResultLauncher`, which we will use to launch
    the permission request dialog and handle the user’s response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an `Activity` class requesting the `Location`
    permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When `Activity` is created, we register the launcher to handle permission request
    responses. We keep a reference to the result for later use. When `Activity` is
    resumed, we check the status of the permission and continue accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by checking the location permission (`ACCESS_FINE_LOCATION`) by calling
    `getHas``LocationPermissions()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function checks whether the user has granted us the requested permissions
    by calling `checkSelfPermission(Context, String)` with the requested permission.
  prefs: []
  type: TYPE_NORMAL
- en: If the user hasn’t granted us permission, we call `shouldShowRequestPermission`
    **Rationale(Activity, String)**, which we mentioned earlier, to check whether
    a rationale dialog should be presented to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'If showing our rationale is needed, we call `showPermissionRationale(() ->
    Unit)`, passing in a lambda that will use `requestPermissionLauncher` to launch
    the request dialog after the user dismisses our rationale dialog using the positive
    button. If no rationale is needed, we launch the dialog with `requestPermissionLauncher`
    directly. The following code is for presenting the rationale dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `showPermissionRationale` function presents the user with a dialog with
    a brief explanation of why we need their permission. The **OK** button will execute
    the positive action provided, and the **Cancel** one will dismiss the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Rationale dialog](img/B19411_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Rationale dialog
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we request permission by calling `requestPermissionLauncher.launch(ACCESS_FINE_LOCATION)`
    using the request permission launcher we declared earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we’ve requested the location permission from the user, the response will
    be processed by the request permission launcher depending on the value returned
    via `isGranted`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code is the expansion of the code we observed earlier, added to the `onCreate`
    function of `Activity`. This chapter will take us through the development of an
    app that shows us our current location on a map and allows us to place a marker
    where we want to deploy our secret cat agent.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with our first exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.01 – requesting the location permission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will request that the user provide the location permission.
    We will first create a **Google Maps Activity** project. Then, we will define
    the permission required in the manifest file. To get started, let’s implement
    the code required to request permission from the user to access their location:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new Google Maps Activity project (**File** | **New** |
    **New Project** | **Google Maps Activity**). We’re not using Google Maps in this
    exercise. However, the Google Maps Activity is still a good choice in this case.
    It will save you a lot of boilerplate coding in the next exercise (*Exercise 7.02*).
    Don’t worry; it will have no impact on your current exercise. Click **Next**,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Choose your project](img/B19411_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Choose your project
  prefs: []
  type: TYPE_NORMAL
- en: Name your application `Cat` `Agent Deployer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure your package name is `com.example.catagentdeployer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the save location to where you want to save your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave everything else at its default values and click **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you are on the **Android** view in your **Project** pane:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – The Android view](img/B19411_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – The Android view
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `AndroidManifest.xml` file. Make sure the location permission was
    already added to your app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`ACCESS_FINE_LOCATION` is the permission you will need to obtain the user’s
    location based on GPS in addition to the less accurate Wi-Fi and mobile data-based
    location information you could obtain by using the `ACCESS_COARSE_LOCATION` permission.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `MapsActivity.kt` file. At the bottom of the `MapsActivity` class
    block, add an empty `getLastLocation()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will be the function you will call when you have ensured the user has granted
    you the location permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the request permission launcher to the top of the `MapsActivity`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the variable through which we will launch the permission request and
    track user responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now navigate to the bottom of the `onCreate()` function and register for activity
    results, storing the result in `requestPermissionLauncher`, which you declared
    in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To present users with the rationale for the permission request, implement the
    `show` **PermissionRationale(() -> Unit)** function right before the `getLast``Location()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function will present the user with a simple alert dialog explaining that
    the app will not work without knowing their current location, as shown in *Figure
    7**.1*. Tapping `positiveAction` lambda. Tapping **CANCEL** will dismiss the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether or not your app already has the location permission, introduce
    the following `hasLocationPermission()` function right before the `requestPermissionWithRationaleIfNeeded()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, update the `onMapReady()` function of your `MapsActivity` class to
    determine the permission status and proceed accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `when` statement will check whether the permission was already granted.
    If not, it will check whether a rationale dialog should be presented. Then, if
    the rationale is accepted by the user or no rationale dialog is required, it will
    present a standard permission request dialog to the user (as shown in *Figure
    7**.1*), asking them to allow the app to access their location. You pass the requested
    permission you want the user to grant your app (`Manifest.permission.ACCESS_FINE_LOCATION`).
  prefs: []
  type: TYPE_NORMAL
- en: Run your app. You should now see a system permission dialog requesting you to
    allow the app to access the location of the device, as shown in *Figure 7**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – App requesting the location permission](img/B19411_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – App requesting the location permission
  prefs: []
  type: TYPE_NORMAL
- en: If the user denies the permission, the rationale dialog will appear. If the
    rationale is accepted, the system permission dialog will show again. Up until
    SDK 31, the user had the option to choose not to let the app ask for permission
    again (*Figure 7**.6*). From SDK 31 onwards, not asking a third time is the default.
    Allowing it afterwards requires using the device settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The Don’t ask again message](img/B19411_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The Don’t ask again message
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has allowed or permanently denied the permission, the dialog will
    never show again. To reset the state of your app permissions, you would have to
    manually grant it permission via the **App** **Info** interface.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can get the location permission, we will now look into obtaining
    the user’s current location.
  prefs: []
  type: TYPE_NORMAL
- en: Showing a map of the user’s location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having successfully obtained permission from the user to access their location,
    we can now ask the user’s device to provide us with its last known location. This
    is also usually the user’s current location. We will then use this location to
    present the user with a map of their current location.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the user’s last known location, Google has provided us with the Google
    Play Location service and, more specifically, with the `FusedLocationProviderClient`
    class. The `FusedLocationProviderClient` class helps us interact with Google’s
    Fused Location Provider API, which is a location API that intelligently combines
    different signals from multiple device sensors to provide us with device location
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the `FusedLocationProviderClient` class, we must first include the
    Google Play Location service library in our project. This simply means adding
    the following code snippet to the `dependencies` block of our `build.gradle` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With the location service imported, we can now obtain an instance of the `FusedLocation`
    **ProviderClient** class by calling `LocationServices.getFusedLocationProvider``Client(this@MainActivity)`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a fused location client, we can obtain the user’s last location
    by calling `fused``LocationClient.lastLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is given that we have already received the location permission from the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is an asynchronous call, we should also provide a success listener
    as a minimum. If we wanted to, we could also add listeners for cancellation, failure,
    and the completion of requests. Calling `lastLocation` returns `Task<Location>`.
    `Task` is a Google API abstract class whose implementations perform async operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, that operation is returning a location. So, adding listeners
    is simply a matter of chaining calls. We will add the following code snippet to
    our call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `location` parameter could be `null` if the client fails to obtain
    the user’s current location. This is not very common but could happen if, for
    example, the user disabled their location services during the call.
  prefs: []
  type: TYPE_NORMAL
- en: Once the code inside our success listener block is executed, and `location`
    is not `null`, we have the user’s current location in the form of a `Location`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: A `Location` instance holds a single coordinate on Earth, expressed using longitude
    and latitude.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For our purpose, it is sufficient to know that each point on the surface of
    the Earth is mapped to a single pair of **longitude** (**Lng**) and **latitude**
    (**Lat**) values.
  prefs: []
  type: TYPE_NORMAL
- en: This is where it gets exciting. Google lets us present any location on an interactive
    map by using a `SupportMapFragment` class. All it takes is to sign up for a free
    API key. When you create your application with a Google Maps Activity, Android
    Studio immediately opens the `AndroidManifest.xml` file. A comment in the file
    sends us to [https://packt.link/FK58V](https://packt.link/FK58V) to obtain the
    required API key. You can copy that link to your browser or press *Ctrl*/*Command*
    + click on it.
  prefs: []
  type: TYPE_NORMAL
- en: On the page, follow the directions and click `YOUR_API_KEY` string in the meta
    tag value with your newly obtained key.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if you run your app, you will already see an interactive map
    on your screen, as seen in *Figure 7**.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Interactive map](img/B19411_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Interactive map
  prefs: []
  type: TYPE_NORMAL
- en: 'To position the map based on our current location, we create a `LatLng` instance
    with the coordinates from our `Location` instance and call `moveCamera(CameraUpdate)`
    on the `GoogleMap` instance. To satisfy the `CameraUpdate` requirement, we call
    `CameraUpdateFactory.newLatLng(LatLng)`, passing in the `LatLng` parameter created
    earlier. The call would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To discover the rest of the available `CameraUpdateFactory` options, visit [https://packt.link/EBRnt](https://packt.link/EBRnt).
  prefs: []
  type: TYPE_NORMAL
- en: We could also call `newLatLngZoom(LatLng, Float)` to modify the zoom-in and
    zoom-out features of the map.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Valid zoom values range between 2.0 (farthest) and 21.0 (closest). Values outside
    of that range are capped.
  prefs: []
  type: TYPE_NORMAL
- en: Some areas may not have tiles to render the closest zoom values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call `addMarker(MarkerOptions)` on the `GoogleMap` instance to add a marker
    at the user’s coordinate. The `MarkerOptions` parameters are configured by chaining
    calls to a `MarkerOptions()` instance. We could call `position(LatLng)` and `title(String)`
    for a simple marker at our desired position. The call would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The order in which we chain the calls does not matter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s practice this in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.02 – obtaining the user’s current location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that your app can be granted location permission, you can use the location
    permission to get the user’s current location. You will then display the map and
    update it to zoom into the user’s current location and show a pin at that location.
    To do this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the Google Play location service to your `build.gradle` file. You
    should add it within the `dependencies` block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Click the **Sync Project with Gradle Files** button in Android Studio for Gradle
    to fetch the newly added dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Obtain an API key: open the `AndroidManifest.xml` file (`app/src/main/AndroidManifest.xml`)
    and *Ctrl* / *Cmd* + click the link [https://developers.google.com/maps/documentation/android-sdk/get-api-key](https://developers.google.com/maps/documentation/android-sdk/get-api-key).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the instructions on the website until you have generated a new API key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update your `google_maps_api.xml` file by replacing `YOUR_API_KEY` with your
    new API key in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open your `MapsActivity.kt` file. At the top of your `MapsActivity` class,
    define a lazily initialized fused location provider client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By making `fusedLocationProviderClient` initialize lazily, you are ensuring
    it is only initialized when needed, which essentially guarantees the `Activity`
    class will have been created before initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduce an `updateMapLocation(LatLng)` function and an `addMarkerAtLocation(LatLng,
    String)` function immediately after the `getLastLocation()` function to zoom the
    map at a given location and add a marker at that location, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now update your `getLastLocation()` function to retrieve the user’s location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your code requests the last location by calling `lastLocation` and then attaches
    a `lambda` function as an `OnSuccessListener` interface. Once a location is obtained,
    the `lambda` function is executed, updating the map location. The code then adds
    a marker at that location with the `You` title if a non-null location was returned.
  prefs: []
  type: TYPE_NORMAL
- en: Run your app. It should look like *Figure 7**.8*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Interactive map with a marker at the current location](img/B19411_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Interactive map with a marker at the current location
  prefs: []
  type: TYPE_NORMAL
- en: Once the app has been granted permission, it can request the user’s last location
    from the Google Play location service via the fused location provider client.
    This gives you an easy and concise way to fetch the user’s current location. Remember
    to turn on the location on your device for the app to work.
  prefs: []
  type: TYPE_NORMAL
- en: With the user’s location, your app can tell the map where to zoom and where
    to place a marker. If the user clicks on the marker, they will see the title you
    assigned to it (`You` in the exercise).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to respond to clicks on the map and how
    to move markers.
  prefs: []
  type: TYPE_NORMAL
- en: Map clicks and custom markers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a map showing the user’s current location by zooming in at the right location
    and placing a marker there, we have a rudimentary knowledge of how to render the
    desired map and how to obtain the required permissions and the user’s current
    location.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to respond to a user interacting with the
    map and how to use markers more extensively. We will learn how to move markers
    on the map and replace the default pin marker with custom icons. When we know
    how to let the user place a marker anywhere on the map, we can let them choose
    where to deploy the secret cat agent.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a listener to the `GoogleMap` instance to listen for clicks
    on the map. Looking at our `MapsActivity.kt` file, the best place to do so would
    be in `onMapReady(GoogleMap)`. A naïve implementation might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: However, if we ran this code, we’d find that a new marker is added for every
    click on the map. This is not our desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To control a marker on the map, we need to keep a reference to that marker.
    That is achieved easily enough by keeping a reference to the output of `GoogleMap.addMarker(MarkerOptions)`.
    The `addMarker` function returns a `Marker` instance. To move a marker on the
    map, we assign a new position value to it by calling its `position` setter.
  prefs: []
  type: TYPE_NORMAL
- en: To replace the default pin icon with a custom icon, we must provide a `BitmapDescriptor`
    to the marker or the `MarkerOptions()` instance. The `BitmapDescriptor` wrappers
    work around bitmaps used by `GoogleMap` to render markers and ground overlays,
    but we won’t cover that in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We obtain `BitmapDescriptor` by using `BitmapDescriptorFactory`. The factory
    will require an asset, which can be provided in a few ways. You can provide it
    with the name of a bitmap in the `assets` directory, a `Bitmap`, a filename of
    a file in the internal storage, or a resource ID.
  prefs: []
  type: TYPE_NORMAL
- en: The factory can also create default markers of different colors. We are interested
    in the `Bitmap` option because we intend to use a vector drawable, and the factory
    does not directly support those. In addition, when converting the drawable to
    a `Bitmap`, we can manipulate it to suit our needs (for example, we could change
    its color).
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio offers us quite a wide range of free vector `Drawables` out of
    the box. For this example, we want the `paw` drawable. To do this, right-click
    anywhere in the left Android pane, and select **New** | **Vector Asset**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click the Android icon next to the **Clip Art** label for the list of
    icons (see *Figure 7**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Asset Studio](img/B19411_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Asset Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll now access a window to choose from the offered pool of clip art (*Figure
    7**.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Selecting an icon](img/B19411_07_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Selecting an icon
  prefs: []
  type: TYPE_NORMAL
- en: Once we choose an icon, we can name it, and it will be created for us as a vector
    drawable XML file. We will name it `target_icon`.
  prefs: []
  type: TYPE_NORMAL
- en: To use the created asset, we must first get it as a `Drawable` instance. This
    is done by calling `Context` **Compat.getDrawable(Context, Int)**, passing in
    the activity and `R.drawable.target_icon` as a reference to our asset. Next, we
    need to define bounds for the `Drawable` instance to draw in.
  prefs: []
  type: TYPE_NORMAL
- en: Calling `Drawable.setBound(Int, Int, Int, Int)` with (`0`, `0`, `drawable.intrinsic`
    **Width**, `drawable.intrinsicHeight`) will tell the drawable to draw within its
    intrinsic size.
  prefs: []
  type: TYPE_NORMAL
- en: To change the color of our icon, we can tint it. To tint a `Drawable` instance
    in a way that is supported by devices running APIs older than `21`, we must first
    wrap our `Drawable` instance with `DrawableCompat` by calling `DrawableCompat.wrap(Drawable)`.
    The returned `Drawable` can then be tinted using `DrawableCompat.setTint(Drawable,
    Int)`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to create a `Bitmap` to hold our icon. Its dimensions can match
    those of the `Drawable` bounds, and we want its `Config` to be `Bitmap.Config.ARGB_8888`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`8` indicates the number of bits per channel. `ARGB_8888` means we want 8-bit
    red, green, blue, and alpha channels.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then create a `Canvas` for the `Bitmap`, allowing us to draw our `Drawable`
    instance by calling…you guessed it, `Drawable.draw(Canvas)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With the `Bitmap` containing our icon, we are now ready to obtain a `BitmapDescriptor`
    instance from `BitmapDescriptorFactory`. Don’t forget to recycle your `Bitmap`
    afterward. This will avoid a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned how to present the user with a meaningful map by centering
    it on their current location and showing their current location using a custom
    marker.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.03 – adding a custom marker where the map was clicked
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will respond to a user’s map click by placing a red paw-shaped
    marker at the location on the map the user clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MapsActivity.kt` (found under `app/src/main/java/com/example/catagentdeployer`),
    right below the definition of the `mMap` variable, define a nullable `Marker`
    variable to hold a reference to the paw marker on the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `addMarkerAtLocation(LatLng, String)` to also accept a nullable `BitmapDescriptor`
    with a default value of `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `markerIcon` provided is not null, the app sets it to `MarkerOptions`.
    The function now returns the marker it added to the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `getBitmapDescriptorFromVector(Int): BitmapDescriptor?` function below
    your `addMarkerAtLocation(LatLng, String, BitmapDescriptor?): Marker` function
    to provide `BitmapDescriptor` given a `Drawable` resource ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function first obtains a drawable using `ContextCompat` by passing in the
    provided resource ID. It then sets the drawing bounds for the drawable, wraps
    it in `DrawableCompat`, and sets its tint to red.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it creates a `Bitmap` and a `Canvas` for that `Bitmap`, upon which it
    draws the tinted drawable. The bitmap is then returned to be used by `BitmapDescriptorFactory`
    to build `BitmapDescriptor`. Lastly, `Bitmap` is recycled to avoid a memory leak.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can use the `Drawable` instance, you must first create it. Right-click
    on the Android pane, and then select **New** | **Vector Asset**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the window that opens, click on the Android icon next to the **Clip Art**
    label to select a different icon (*Figure 7**.11*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Asset Studio](img/B19411_07_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Asset Studio
  prefs: []
  type: TYPE_NORMAL
- en: 'From the list of icons, select the `pets` into the search field if you can’t
    find the icon. Once you select the **pets** icon, click **OK**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Selecting an icon](img/B19411_07_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Selecting an icon
  prefs: []
  type: TYPE_NORMAL
- en: Name your icon `target_icon`. Click **Next** and **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define an `addOrMoveSelectedPositionMarker(LatLng)` function to create a new
    marker or move it to the provided location if one has already been created. Add
    it after the `getBitmapDescriptorFromVector(Int)` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update your `onMapReady(GoogleMap)` function to set an `OnMapClickListener`
    event on `mMap`, which will add a marker to the clicked location or move the existing
    marker to the clicked location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run your app. It should look like *Figure 7**.13*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – The complete app](img/B19411_07_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – The complete app
  prefs: []
  type: TYPE_NORMAL
- en: Clicking anywhere on the map will now move the paw icon to that location. Clicking
    the paw icon will show the **Deploy** **here** label.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The location of the paw is a geographical one, not a screen one. That means
    if you drag your map or zoom in, the paw will move with the map and remain in
    the same geographical location.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to respond to user clicks on the map and add and move markers
    around. You also know how to customize the appearance of markers.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 7.01 – creating an app to find the location of a parked car
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some people often forget where it was that they parked their car. Let’s say
    you want to help these people by developing an app that lets the user store the
    last place they parked. The app will show a pin at the car’s location when the
    user launches the app. The user can click an **I’m parked here** button to update
    the pin location to the current location the next time they park.
  prefs: []
  type: TYPE_NORMAL
- en: Your goal in this activity is to develop an app that shows the user a map of
    the current location. The app must first ask the user for permission to access
    their location. Make sure to also provide a rationale dialog, if needed, according
    to the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: The app will show a car icon where the user last told it the car was. The user
    can click a button labeled **I’m parked here** to move the car icon to the current
    location. When the user relaunches the app, it will show the user’s current location
    and the car icon where the car was last parked.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus feature of your app, you can choose to add functionality that stores
    the car’s location so that it can be restored after the user has killed and then
    re-opened the app. This bonus functionality relies on using `SharedPreferences`;
    a concept that will be covered in [*Chapter 10*](B19411_10.xhtml#_idTextAnchor512),
    *Persisting Data*. As such, *steps 9* and *10* here will give you the required
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Google Maps Activity app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain an API key for the app and update your `google_maps_api.xml` file with
    that key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show a button at the bottom with an **I’m parked** **here** label.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the location service in your app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request the user’s permission to access their location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Obtain the user’s location and place a pin on the map at that location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a car icon to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add functionality to move the car icon to the user’s current location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Bonus step: store the selected location in `SharedPreferences`. This function,
    placed in your activity, will help you do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bonus step: restore any saved location from `SharedPreferences`. You can use
    the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this activity completed, you have demonstrated your understanding of requesting
    permissions in an Android app. You have also shown that you can present the user
    with a map and control pins on that map. Finally, you have also demonstrated your
    knowledge of obtaining the user’s current location. Well done.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/By7eE](https://packt.link/By7eE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Android permissions. We touched on the reasons
    for having them and saw how we could request the user’s permission to perform
    certain tasks. We also learned how to use Google’s Maps API and how to present
    the user with an interactive map.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we leveraged our knowledge of presenting a map and requesting permissions
    to find out the user’s current location and present it on the map. Of course,
    there is a lot more that can be done with the Google Maps API, and you could explore
    a lot more possibilities with certain permissions.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have enough understanding of the foundations to explore further.
    To read more about permissions, visit [https://packt.link/57BdN](https://packt.link/57BdN).
    To read more about the Maps API, visit [https://packt.link/8akrP](https://packt.link/8akrP).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to perform background tasks using `Services`
    and `WorkManager`. We will also learn how to present the user with notifications,
    even when the app is not running. These are powerful tools to have in your arsenal
    as a mobile developer.
  prefs: []
  type: TYPE_NORMAL
