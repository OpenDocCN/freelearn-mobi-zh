<html><head></head><body>
		<div id="_idContainer020">
			<h1 id="_idParaDest-32"><em class="italic"><a id="_idTextAnchor068"/>Chapter </em>2: Understanding Test-Driven Development</h1>
			<p>Now that we have seen what unit tests are and how they can help in development, we are going to learn about <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>).</p>
			<p>After giving you some insights into the origin and objective of TDD, we will move ahead and have a look at the benefits and drawbacks of it. By the end of the chapter, you will have a clear idea about the relevance of TDD and what should be or can be tested using it. </p>
			<p>These are the main topics that we will cover in the chapter: </p>
			<ul>
				<li>The origin of TDD</li>
				<li>The TDD workflow</li>
				<li>Advantages of TDD</li>
				<li>Disadvantages of TDD</li>
				<li>What to test</li>
			</ul>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor069"/>The origin of TDD</h1>
			<p>In 1996, Kent Beck, Ward Cunningham, and Ron Jeffries introduced a new software development <a id="_idIndexMarker032"/>methodology called <strong class="bold">Extreme Programming</strong> while they <a id="_idIndexMarker033"/>were working on the project <em class="italic">Comprehensive Compensation System</em> at Chrysler. The word <em class="italic">Extreme</em> indicates that the concepts behind Extreme Programming are totally different from the concepts used in software development back then. For many people, these concepts sound extreme even today.</p>
			<p>The methodology is based on 12 rules or practices. One of the rules states that developers have to write unit tests and all parts of the software have to be thoroughly tested. All tests have to pass before the software (or a new feature) can be released to customers. The tests should be written before the production code that they test.</p>
			<p>This so-called test-first programming led to TDD. As the name suggests, in TDD, tests drive the development. This means that the developer writes code only because there is a test that fails. The tests dictate whether the code has to be written, and they also provide a measure when a feature is "done" – it is done when all tests for the feature pass.</p>
			<p>This might sound silly to you if you haven't done any TDD before. You have to <a id="_idIndexMarker034"/>try and keep with it for some time to see the advantages and that it's not silly but rather quite clever. In TDD you always focus on one feature of the product you are building. And as you have tests for all the features you have built before, you don't have to keep the details of the rest of the code in mind. You can trust in the existing tests and that you won't break something that worked before.</p>
			<p>Because of the focus on just one feature at a time, you will have a working piece of software almost all the time. So, when your boss enters your office and asks you for a demonstration of the current status of the project, you are only a few minutes away from a presentable (that is, compiled) and thoroughly tested piece of software.</p>
			<p>Now that we know what TDD refers to, let's look into its workflow.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor070"/>The TDD workflow – red, green, refactor</h1>
			<p>The normal <a id="_idIndexMarker035"/>workflow of TDD comprises three steps – <em class="italic">red</em>, <em class="italic">green</em>, <em class="italic">refactor</em>. The following sections describe these steps in detail.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor071"/>Red</h2>
			<p>You start <a id="_idIndexMarker036"/>by writing a failing test. It needs to test a required feature of the software product that is not already implemented or an edge case that you want to make sure is covered. The name red comes from the way most IDEs indicate a failing test. Xcode uses a red diamond with a white x on it as shown in the following figure:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.01_B18127.jpg" alt="Figure 2.1 – Xcode marks a failing test with a white cross in a red diamond&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Xcode marks a failing test with a white cross in a red diamond</p>
			<p>It is very important that the test you write in this step initially fails. Otherwise, you can't ensure that <a id="_idIndexMarker037"/>the test works and really tests the feature that you want to implement. It could be that you have written a test that always passes and is, therefore, useless. Or, it is possible that the feature is already implemented. Either way, you gain insight into your code.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor072"/>Green</h2>
			<p>In the green step, you write the simplest code that makes the test pass. It doesn't matter <a id="_idIndexMarker038"/>whether the code you write is good and clean. The code can also be silly and even wrong. It is enough when all the tests pass. The name green refers to how most IDEs indicate a passing test. Xcode uses a green diamond with a white checkmark.</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.02_B18127.jpg" alt="Figure 2.2 – Xcode marks a passing test with a white checkmark in a green diamond&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – Xcode marks a passing test with a white checkmark in a green diamond</p>
			<p>It is very important that you try to write the simplest code that makes the test pass. By doing so, you only write code that you actually need and that is the simplest implementation possible. When I say simple, I mean that it should be easy to read, understand, and change. Test code should always be easy to understand. Try to write your tests such that you understand them even when you haven't worked on them for months. When tests break, it's often while you are working on something completely different. A clear and easy-to-understand test helps you to find the problem quickly and get back to the context you were working on.</p>
			<p>Often the <a id="_idIndexMarker039"/>simplest implementation will not be enough for the feature you're trying to implement, but still enough to make all the tests pass. This just means that you need another failing test to further drive the development of that feature.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor073"/>Refactor</h2>
			<p>During the <a id="_idIndexMarker040"/>green step, you write just enough code to make all the tests pass again. As I just mentioned, it doesn't matter what the code looks like in the green step. In the refactor step you improve the code. You remove duplication, extract common values, and so on. Do what is needed to make the code as good as possible. The tests help you to not break already implemented features while refactoring.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Don't skip this step. Always try to think about how you can improve the code after you have implemented a feature. Doing so helps to keep the code clean and maintainable. This ensures that it is always in good shape.</p>
			<p>As you have written only a few lines of code since the last refactor step, the changes needed to make the code clean shouldn't take much time.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor074"/>The advantages of TDD</h1>
			<p>TDD comes <a id="_idIndexMarker041"/>with advantages and disadvantages. These are the main advantages:</p>
			<ul>
				<li><strong class="bold">You only write code that is needed</strong>: You should stop writing production code when all your tests pass and you can't think of another test to write. If your project needs another feature, you need a test to drive the implementation of that feature. The code you write is the simplest code possible. So, all the code ending up in the product is actually needed to implement the features.</li>
				<li><strong class="bold">More modular design</strong>: In TDD, you concentrate on one microfeature at a time. And as you write the test first, the code automatically becomes easy to test. Code that is easy to test has a clear interface. This results in a modular design for your app.</li>
				<li><strong class="bold">Easier to maintain</strong>: As the different parts of your app are decoupled from each other <a id="_idIndexMarker042"/>and have clear interfaces, the code becomes easier to maintain. You can exchange the implementation of a microfeature with a better implementation without affecting another module. You could even keep the tests and rewrite the complete app. When all the tests pass, you are done.</li>
				<li><strong class="bold">Easier to refactor</strong>: Every feature is thoroughly tested. You don't need to be afraid to make drastic changes because if all the tests still pass, everything is fine. This point is very important because you, as a developer, improve your skills each and every day. If you open the project after 6 months of working on something else, most probably, you'll have many ideas on how to improve the code. But your memory about all the different parts and how they fit together won't be fresh anymore. So, making changes can be dangerous. With a complete test suite, you can easily improve the code without the fear of breaking your app.</li>
				<li><strong class="bold">High test coverage</strong>: There is a test for every feature. This results in high test coverage. High test coverage helps you gain confidence in your code.</li>
				<li><strong class="bold">Tests document the code</strong>: Test code shows how your code is meant to be used. As such, it documents your code. Test code is sample code that shows what the code does and how the interface has to be used.</li>
				<li><strong class="bold">Less debugging</strong>: How often have you wasted a day finding a nasty bug? How often have you copied an error message from Xcode and searched for it on the internet? With TDD, you write fewer bugs because the tests tell you early on whether you've made a mistake. And the bugs you write are found much earlier. You can concentrate on fixing bugs when your memory is still fresh about what the code is supposed to do and how it does it.</li>
			</ul>
			<p>In the next section, we'll discuss the disadvantages of TDD.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor075"/>The disadvantages of TDD</h1>
			<p>Just like <a id="_idIndexMarker043"/>everything else in the world, TDD has some disadvantages. The main ones are listed here:</p>
			<ul>
				<li><strong class="bold">No silver bullet</strong>: Tests help to find bugs, but they can't find all bugs that you introduce in the test code and implementation code. If you haven't understood the problem you need to solve, writing tests most probably won't help.</li>
				<li><strong class="bold">It seems slower at the beginning</strong>: When you start TDD, you will get the feeling that it takes longer to make easy implementations. You need to think about the interfaces, write the test code, and run the tests before you can finally start writing the code.</li>
				<li><strong class="bold">All the members of a team need to do it</strong>: As TDD influences the design of code, it is recommended that either all the members of a team use TDD or no one at all. In addition to this, it's sometimes difficult to justify TDD to management because they often have the feeling that the implementation of new features takes longer if developers write code that won't end up in the product half of the time. It helps if the whole team agrees on the importance of unit tests.</li>
				<li><strong class="bold">Tests need to be maintained when requirements change</strong>: Probably, the strongest argument against TDD is that the tests have to be maintained just as the code has to. Whenever requirements change, you need to change the code and tests. But you are working with TDD. This means that you need to change the tests first, and then make the tests pass. So, in reality, tests help you to understand the new requirements and implement the code without breaking other features.</li>
			</ul>
			<p>Beginners often ask which part of their code they should write tests for. The following section tries to find an answer to that.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor076"/>What to test</h1>
			<p>What should be tested? When using TDD and following its ideology, the answer is easy – everything. You only write production code because there is a failing test.</p>
			<p>In practice, it's not that easy. For example, should the position and color of a button be tested? Should the view hierarchy be tested? Probably not; the color and exact position of the button is not important for the functioning of an app. In the early stages of development, these kinds of things tend to change. With Auto Layout, different screen sizes, and different localizations of apps, the exact position of buttons and labels depends on many parameters.</p>
			<p>In general, you should test the features that make the app useful for a user and those that need to work. Users don't care whether the button is exactly 20 points from the rightmost edge of the screen. Users seek apps that are easy to understand and a joy to use.</p>
			<p>In addition to this, you should not test the whole app at once using unit tests. Unit tests are meant to test small units of computation. They need to be fast and reliable. Things such as database access and networking should be tested using integration tests, where the tests drive the real finished app. Integration tests are allowed to be slow because they are run a lot less often than unit tests. Usually, they are run with the help of a continuous integration system each night on a server, where it doesn't matter that the complete test suite takes several minutes (or even hours) to execute.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor077"/>Summary</h1>
			<p>In this chapter, we dipped our toes into the new waters of TDD in general. The chapter showed the workflow of TDD – red, green, refactor – which we will use throughout this book to build an app. In addition, we have seen what the advantages and the disadvantages of TDD are.</p>
			<p>In the following chapter, we will explore how TDD works in Xcode, the tool most of us use to build iOS apps.</p>
		</div>
	</body></html>