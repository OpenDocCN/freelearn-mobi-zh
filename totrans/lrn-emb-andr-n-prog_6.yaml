- en: Chapter 6\. "Cooking" Your First ROM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 5, *Customizing Kernel and Boot Sequence*, we took an amazing journey
    into the Linux kernel—now you know how to obtain the right version for your device
    and how to build it. We got great satisfaction customizing and building your own
    kernel version, specific for your device—we added new drivers for your hardware
    and removed those that were unnecessary. You finally learned about the boot sequence.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enter the *modding* world and we will move forward
    with your first customized ROM. You will learn how to set up the system and how
    to create a custom ROM. We will see an overview of the most popular ROMs, and
    all the tools you need and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: History of Android modding (Cyanogenmod)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kitchen and other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History of custom ROMs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First things first—What does "Custom ROM" mean?
  prefs: []
  type: TYPE_NORMAL
- en: Most Android devices come with so-called *NAND memories*. A NAND memory is a
    particular type of flash memory. A flash memory is based on transistors, instead
    of rotating disks, like in old hard drives. This type of memory is completely
    electrically managed—it can be written and erased and can store data indefinitely
    (not volatile). Knowing this, we may think that everything is writable on Android.
    Well, not exactly!
  prefs: []
  type: TYPE_NORMAL
- en: The acronym ROM stands for Read-Only Memory. This type of memory is often used
    in embedded systems to safely store all those files that are part of the core
    system. In an effort to guarantee the highest system integrity possible, developers
    must be sure that the core system stays intact over device reboots and possible
    failures. That's why the core system is stored in a type of memory that can only
    be written once—Read-Only Memory, to be precise. With time, the Android hacking
    community took the acronym and transformed it. Nowadays, in saying Custom ROM,
    you are simply saying "My own custom Android system for this specific device,"
    and this is the meaning we will use in the following pages.
  prefs: []
  type: TYPE_NORMAL
- en: As for the Linux kernel, Android is one of the most popular open source projects
    currently developed. Free to use and customizable, used by millions of people,
    Android is the base element for hundreds of customized operating systems—most
    of them were experiments, some were custom versions fixing particular bugs for
    specific scenarios, and others were optimized versions of the original system.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, the modding community was very scattered—lots of lone wolves,
    hacking in their dark rooms. Over time, most of them converged into more social
    environments, combining their efforts in forums and communities, creating modding
    teams to provide users with better and more reliable ROMs.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, *Customizing Kernel and Boot Sequence*, we saw how to create a
    custom version of Android working with the source code. We were able to radically
    alter the original system to create our version, perfectly fitting our needs,
    so what's all this hype about modding? Why couldn't we just grab the source code
    and customize our system? The truth is that, unfortunately, Google is a needle
    in a haystack. Most of the other manufacturers play the whole open source game
    a bit differently and it is not always possible to rebuild a system from scratch,
    due to the lack of provided source code.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, Android customization can be achieved by following a *different
    path*—going straight to the system memory partition, decompiling the components,
    and making customizations, or so-called **surface modifications**.
  prefs: []
  type: TYPE_NORMAL
- en: A totally different game is played in the Linux kernel field. As you can remember,
    Android and the Linux kernel have different licenses—Android is distributed under
    the Apache License v2, while the Linux kernel is distributed under the GPL license.
    The GPL license is stricter about modification and redistribution and the manufacturers
    have a hard time keeping the kernel *secret*. That's why the Linux kernel is always
    available and modders can add, remove, and improve whatever aspect they want—new
    drivers, improved power management, improved CPU management, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When you look at the whole custom ROM idea, you end up thinking that you see
    custom ROMs everywhere and every day—manufacturer's ROM. If we think that the
    *really pure* Android system is the one shipped with Nexus devices, we realize
    that manufacturers are the *first modders*, turning the original system into something
    often completely different. Just think about Samsung or HTC custom UI. Those are
    huge modifications to the UI. Think about those devices that have an AM/FM radio—again,
    serious customization. Some manufacturers have gone so far with customizations
    over the years that they eventually made their device incompatible even with Google
    Play Store.
  prefs: []
  type: TYPE_NORMAL
- en: In the following pages, we will see an overview of the most popular custom ROMs
    to try to understand why they are so loved by advanced users.
  prefs: []
  type: TYPE_NORMAL
- en: Cyanogenmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the undisputedly most popular Android custom ROMs is Cyanogenmod. It''s
    one of the oldest ones and it brings features and performance that cannot be found
    in the official Android system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_89.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Since the beginning, just after the first public releases of Android open source
    code, the Cyanogen team started back-porting the latest Android version to old
    devices. They basically overcame manufacturers' *business decisions* to leave
    old devices with old Android versions and made an effort to give new glory to
    so-called *legacy devices*.
  prefs: []
  type: TYPE_NORMAL
- en: During the years, the Cyanogenmod team added and tuned tons of features, and
    this approach attracted thousands of users. The improvements have been so good
    that often the official Google Android team merged them into the official Android
    source base, in the real open source community spirit.
  prefs: []
  type: TYPE_NORMAL
- en: As said earlier, the Cyanogenmod team didn't start the project from scratch.
    They used the Android Open Source Project and enhanced it. Using a different approach
    to lots of other customizers, they decided that the whole project had to be available
    as open source code, allowing everybody to enjoy all the features, learn from
    the source code, and contribute to the project itself. Over the years, the community
    has grown significantly, and lots and lots of blog posts, tutorials, and practical
    guides have invaded the web-sphere, making Cyanogenmod one of the most popular
    custom ROMs currently available.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a list of the most-loved features that Cyanogenmod currently provides:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Theming support**: The whole system UI can be customized with user-made themes
    that can be applied to the system at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FLAC support**: Free Lossless Audio Codec is one of the many audio codecs
    available on the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bigger APN (Access Point Network) list**: Lots of different APNs have been
    added over time, making it easy to quickly set up an Internet connection on a
    multitude of devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenVPN client**: The popular VPN software is available and ready to be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enriched Power Off menu**: The Power Off menu contains new actions such as
    Reboot, Recovery Mode Reboot, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some other features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for Wi-Fi, Bluetooth, and USB tethering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU Overclock management and system-wide performance enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced management of Soft Buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Toggle Buttons in the system notification menu such as GPS, Bluetooth, and
    Wi-Fi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Application permissions management, for a meticulously secured system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System-wide graphics enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased performance and reliability, as stated by the team, compared to any
    other Android system derived from the official Google vanilla one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In April 2013, Cyanogenmod went from community project to an actual company.
    Despite this, the open source nature is still one of the main core values of the
    company. So far, it counts 17 employees working full-time on the project. In the
    last three years, they received a few donations from third-party partners, such
    as Benchmark Capital and Redpoint Ventures, pushing the development of an easier
    Cyanogenmod installation process.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, Cyanogenmod announced a partnership with OnePlus, a smartphone manufacturer,
    to distribute their devices with a pre-installed Cyanogenmod. According to their
    analytics, Cyanogenmod is currently used by 50 million devices.
  prefs: []
  type: TYPE_NORMAL
- en: Building Cyanogenmod
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inspired by Google AOSP, Cyanogenmod provides an official website where you
    can download the project source code and access the support forum: [www.cyanogenmod.org](http://www.cyanogenmod.org).'
  prefs: []
  type: TYPE_NORMAL
- en: The website also provides a complete list of every supported device. Unlike
    Google AOSP, which formally supports only Nexus devices, Cyanogenmod is available
    for dozens of different devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Cyanogenmod build system is the exact same one you already mastered in the
    previous chapters. Knowing that, we leave it as an exercise to download and build
    your own Cyanogenmod version to fully understand how far Android AOSP can be customized
    and improved.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a pre-build version
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Being an open source project, you could build Cyanogen from source. If you want
    a quicker solution, Cyanogenmod provides pre-built installable versions of the
    system for a plethora of devices. Just check the website and look for one of your
    devices—chances are that it's on the list of supported devices.
  prefs: []
  type: TYPE_NORMAL
- en: Once you find that your device is supported, you can pick one of the many versions
    available. The release cycle is very different from Google's. One of the most
    *adventurous* features of the whole Cyanogenmod world is the **nightly build**—every
    night, an automatic system starts a new build with the latest contribution to
    the source code repository. These are tricky versions, which must be considered
    unstable, but will contain all the new things that the development team adds to
    the system daily—*only for the brave!*
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the different release cycle, Cyanogenmod also uses a different
    version naming convention. The team uses tags to specify the different versions
    of the ROM:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nightly**: As Already explained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experimental**: This is the version currently under testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**M Snapshot, or Milestone Snapshot**: This is more stable than a nightly,
    but still to be considered unstable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release Candidate**: This is the final step before reaching the *stable*
    state. This is the first release that it would be *wise* to use on a daily basis
    on your device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stable**: This is the final state, targeting all users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Android Open Kang Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Android Open Kang Project, also known as AOKP, is an open source project born
    in 2011 with the goal of providing an alternative to official Google Android for
    smartphones and tablets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_90.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can imagine, the Kang team didn't create the system from scratch. They
    used the Android Open Source Project by Google as a starting point, as Cyanogenmod
    did. This particular Android version targets high-end smartphones and tablets
    and improves a few aspects to make the system more efficient and customizable.
    These are some of its main pros, which are the reason why more and more users
    decide to switch to AOKP.
  prefs: []
  type: TYPE_NORMAL
- en: One of the aspects that users love is that the AOKP team focused on making the
    system as light as possible. They stripped away every unnecessary app and basically
    left just the official Google apps, to create the smallest possible system.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the smartphones and tablets nowadays contain lots and lots of *esthetical*
  prefs: []
  type: TYPE_NORMAL
- en: features that could slow down the system and are heavy on the eye. These types
    of apps are called **bloatware** and are usually pre-installed system apps that
    are impossible to remove from the system. AOKP made getting rid of these useless
    apps one of its main goals.
  prefs: []
  type: TYPE_NORMAL
- en: The Kang team works very hard to guarantee the maximum level of customization
    for the user's system. AOKP provides a **ROM Control** menu to customize lots
    of aspects of the system, from UI customization to behavior customizations. A
    large amount of energy has been spent in the gesture management domain, and one
    of the coolest features is the possibility to launch any desired app with a finger
    gesture instead of tapping on an icon.
  prefs: []
  type: TYPE_NORMAL
- en: As with Cyanogenmod, AOKP also provides plenty of documentation and downloads
    on their website at [http://aokp.co](http://aokp.co). Again, you can check out
    the source code and build it yourself, or try out an already built version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick list of the goodies you can find in AOKP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vibration Pattern**: Every contact can be associated to a particular vibration
    pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigation Ring**: The Android lock screen can be customized with user-chosen
    apps to quickly access them even with a locked device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LED Control**: The system LED behavior can be customized in terms of color,
    blinking, and duration to create custom notifications for your custom scenarios'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom Toggles**: The notification area can be customized with different
    toggle buttons to create the perfect setup that fits your needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows two screenshots from the actual system:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one shows how to customize the **Navigation Ring**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one shows how to customize the **Vibration** pattern![](img/epub_36702041_91.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing AOKP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'AOKP versioning is different from Google''s and Cyanogenmod''s. AOKP provides
    only too versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Nightlies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Milestones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nightlies are the equivalent of Cyanogenmod's nightly build. Indeed, this is
    just a build automatically generated every night by the AOKP build system. This
    is to be considered highly unstable and only to be installed for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, Milestones are stable builds, meant to be installed for stable
    daily usage.
  prefs: []
  type: TYPE_NORMAL
- en: To keep the community engaged, the Kang team created **AOKP PUSH**, an app that
    keeps the phone updated with new builds and also includes the ability to install
    a system update, when available. As a final note, like Cyanogenmod, AOKP is completely
    free and open to your contributions.
  prefs: []
  type: TYPE_NORMAL
- en: Minor ROMs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, we saw an overview of the two most popular custom
    ROMs available nowadays for Android smartphones and tablets. As you can imagine,
    this is just the tip of the iceberg—over the years, dozens of different custom
    ROMs have been developed and released. Lots of them target specific scenarios
    to solve specific issues or satisfy specific needs of their users, improving the
    Android system in their own way. Most of them are not built from scratch, but
    are based on already available systems that have been customized and redistributed.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the available custom ROMs target a specific device, to solve device-specific
    issues and improve usability and performance. **DroniX** (project created by the
    authors of this very book, targeted a specific device, the Huawei Ideos U8150,
    a low-end device that became very popular at the time. The development team focused
    on performance and squeezed every available Megahertz from the Ideos CPU. With
    the Kernel source code available, we were able to improve CPU frequencies and
    governors. Better power management meant better battery management, with better
    performance and increased battery life.
  prefs: []
  type: TYPE_NORMAL
- en: As always, be careful when you try out custom ROMs. Some of them could be very
    *extreme* and could be dangerous for your devices. This is unfortunate, but it's
    a real scenario. There is no magic for *cooking* a custom ROM, and there are a
    lot of things that can go wrong. Things like extreme overclocking, for instance,
    are dangerous, and a wise user should distrust ROMs that try to sell these kinds
    of features. Experimenting with Android can be fun, satisfying, and challenging,
    but it must be done with knowledge and wisdom.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t list here every custom ROM available in the wild. What we can do
    is to point you in the right direction: [http://www.xda-developers.com/](http://www.xda-developers.com/).
    This is probably the most famous forum to get the latest news and the latest crazy
    things.'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of OEM customizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if they are not commonly considered custom ROMs, all the Android variants
    distributed by manufacturers can be considered to have heavy customizations. We
    witness these every day—every time you look at a Samsung device, you know that
    it's not pure Android.
  prefs: []
  type: TYPE_NORMAL
- en: From the system launcher to the Settings menu, every single component of these
    systems is heavily customized by the OEM and very far from the official Google
    version. In some cases, the system is so different that the average user doesn't
    know that he is using the same Android 5 system, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: This is a list of the most popular OEM customizations to demonstrate how a system
    can be modified and how different the same Android version can look on devices
    by different manufactures.
  prefs: []
  type: TYPE_NORMAL
- en: Samsung – TouchWiz
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: TouchWiz is a graphical interface, optimized for touch interfaces. It has been
    developed by Samsung and its technical partners. Often, it's incorrectly defined
    as a "custom operating system", but technically speaking, it's just a heavy customization
    of the Android UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first version of TouchWiz was released in 2010, for Android 2.1 and BADA,
    an operating system created by Samsung for its smartphones and tablets. The current
    version is TouchWiz 5 and we can find lots of improvements, added over the years.
    In the beginning, TouchWiz was just a *different UI*. Today, it''s a collection
    of custom system applications, customized UI widgets, and lots of new settings
    and features, such as sound profiles, power management, toggles, and so on. The
    following screenshot shows the home screen and the applications drawer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_92.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Huawei EMUI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Under the influence of Samsung's work, Huawei also provides its own version
    of Android UI for its devices. As with Samsung, they started with a customized
    UI and added lots of features, such as theme customization—icons, colors, fonts,
    and lock screen. The notification area has been customized and improved, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most useful new features is definitely the advanced power management.
    It provides three possible setups: Ultra, Smart, and Normal. Ultra is the *extreme*
    setup—one click, and you can turn off every sensor but the bare minimum ones,
    aiming to achieve the longest possible battery life. Smart tries to automatically
    manage the power usage as much as possible. Normal is all about performance—the
    battery won''t last long, but the device will work at full speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the Hawei EMUI home screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_93.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: HTC Sense
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 2009, HTC release the first version of its customized UI for smartphones.
    It targeted Android and Windows Mobile with a shared graphical user experience
    to not confuse users.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular feature in HTC is the big collection of home widgets, but there
    are other features that are just as interesting, such as a tracking system for
    use if the device is stolen. This system allows the user to make remote operations
    on the device to locate it or wipe the memory, or simply lock it. It's even possible
    to show a custom message on the lock screen, with an address or a reward to reobtain
    the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the home screen of HTC Sense 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_94.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: LG Optimus UI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: LG, like others, provides a customized UI—user-picked images for the system
    icons, colors, and a few custom settings. An interesting feature is the **vocal
    command** to take a picture and the ability to pick the best picture from a burst
    of photo photos.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the home screen and the customized notification area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_95.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Xiaomi MIUI
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is definitely the heaviest customized system and it has one specific feature
    that none of the previous ones have—it's open source! Xiaomi began to work on
    MIUI with Android 2.3.7 and Cyanogenmod 7—those two were the core of the system.
    Over the years, they created a custom ROM that is way more than just a customized
    UI, adding more and more features.
  prefs: []
  type: TYPE_NORMAL
- en: In 2011, Xiaomi jumped into the market, switching from system customizer to
    device manufacturer, with high-end, low-cost devices, equipped with its MIUI system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the MIUI home screen and app store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_94.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, this is a popular trend—an easy method for branding and to assure
    customer loyalty, but it's not always the recommended way to go.
  prefs: []
  type: TYPE_NORMAL
- en: There are other manufacturers that prefer to ship their devices with a vanilla
    Android—Motorola, for instance. Motorola's branding approach is to add just a
    couple of *by Motorola* apps. These are usually utility apps, aiming to enrich
    the user experience while keeping the system clean.
  prefs: []
  type: TYPE_NORMAL
- en: Motorola's strategy also has one big pro—a system very close to Google's original
    one means faster updates. Every time Google releases a new Android version, Motorola
    devices receive system updates as well in a few days. This is very unusual for
    most of the other manufacturers, somehow doomed to stay on old Android versions
    due to the huge amount of work necessary to update such a heavily customized system.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Android recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most important parts of the whole Android architecture is the `Recovery`
    partition. A recovery partition is very common in embedded systems, and we saw
    an overview of it in previous chapters. As we know, the so-called `Recovery` is
    a minimal runtime system, completely decoupled from the main Android system and
    totally self-sufficient. Its main goal is to guarantee system integrity and provide
    the necessary tools to fix common minor issues and restore a properly working
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an Android vanilla `Recovery`, we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the Android system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wipe the data partition and the cache partition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiping the data and cache partition is a common practice if we want to restore
    our device to the factory defaults, for instance, in order to have a clean system
    to start experimenting on something specific, or if we just want to sell it.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into Android recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android `Recovery` system is completely standalone. This means that whatever
    might happen to the main Android system, `recovery` will be always able to restore
    a working system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this level of resilience, `recovery` contains its own Linux kernel
    and its own `rootfs`. The following screenshot shows how `recovery` actually lives
    near the Android system, but is completely separate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_97.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The previous screenshot shows how access to the `recovery` is bound to the `BootLoader`.
    The `BootLoader` is unable to decide if the current boot sequence is going to
    end with a running `recovery` or a running Android system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recovery mode can be accessed with a button combination when the device is
    turned off. For our reference device, Google Nexus 6, you can take the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Press and hold *Volume Down*, *Volume Up* and *Power buttons* simultaneously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release all buttons when the `Fastboot Mode` menu appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *Volume* buttons until the upper part of the screen displays the `Recovery
    Mode` text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Power* to select `Recovery Mode`—after that you will see an Android icon
    laid on its back.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press and hold the *Power* button, then press the *Volume Up* button once.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have landed on the recovery main screen, you can navigate using the
    *Volume* buttons and confirm your choice using the *Power* button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options you will find in the recovery menu could vary, but an Android vanilla
    `recovery` will definitely provide these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reboot system now**: This option will restart the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apply update from ADB**: Android Debug Bridge can be used from a host computer
    to upload an official Google system update. Only certified updates can be uploaded
    and applied this way due to security measures enforced by the recovery to guarantee
    system integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wipe cache partition**: This option will erase the *cache* partition. This
    partition usually contains the system''s temporary data and app cache data. Deleting
    this file will free quite an amount of disk space, without losing user data or
    apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wipe data/factory reset**: This option will erase the volatile memory and
    restore the original factory system. Everything that is not strictly system-related
    will be deleted: videos, music, documents, user apps, and so on. The cache partition
    will be erased as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot show a stock Android `recovery`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_98.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installing an alternative recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with the whole Android system, even the `recovery` source code is available
    for study and modifications and, over the years, the Android community has developed
    alternatives that can be used in place of the Android stock `recovery`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these alternatives aim to improve and add more features to the stock recovery.
    The most common features are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ability to save and restore system backups**: NANDroid is extremely useful
    for experimenting with custom systems and adventurous configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ability to install custom ROMs**: Probably the most important among the added
    features, from a custom ROM developer''s point of view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced UI and UXD**: Some of these custom recoveries provide support for
    the touchscreen, instead of the default *Volume*/*Power* button navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most popular `recovery` alternatives are:'
  prefs: []
  type: TYPE_NORMAL
- en: Clockworkmod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4EXT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amon Ra Recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team Win Recovery Project (TWRP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every one of them is different in some way—look and feel, advanced features,
    and so on, but all of them provide a clear way to allow the advanced user to install
    custom ROMs.
  prefs: []
  type: TYPE_NORMAL
- en: Clockworkmod
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is definitely one of the most popular custom recoveries in the game. It's
    often called `CWM`, and has been developed by Koushik *"Koush"* Dutta. He started
    with the ancient Android 2.1 recovery source code and, since then, he has kept
    on adding features.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main features is the NANDroid backup, which allows the user to safely
    save and restore the whole system structure. Another interesting feature is the
    ability to connect to the recovery shell from a computer, via ADB. A critically
    important feature is the ability to update the system using unofficial update
    packages. Unlike the stock recovery, Clockworkmod ignores all signature certificates,
    knowing that only an advanced user would try to flash a custom-made update package.
  prefs: []
  type: TYPE_NORMAL
- en: Clockworkmod recovery can be easily installed using the specific app distributed
    via Google Play Store, or manually, as we will see.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it manually on your trusted Nexus device, you can use `fastboot`.
    Follow these steps to install Clockworkmod recovery:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First thing to do—download it. The Clockworkmod website has a complete list
    of supported devices and specific download files: [https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the file, decompress it and you will have a `.img` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, put your device in `fastboot` mode, as we saw in previous chapters, fire
    up a terminal, and use the following command to flash the `.img` file to the recovery
    partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the brand new recovery has been installed, you can reboot the device straight
    to recovery mode with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From this moment on, we can install custom ROMs or perform a total system backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to recompile the Clockworkmod source code from scratch,
    since the project is open source. You can also find a custom recovery source code
    in the custom Cyanogenmod ROM that we have discussed in previous paragraphs. Building
    Cyanogenmod from the source code follows the same steps you already followed to
    build official Android: the build system and the build setup are the same. Applying
    the same know-how as for vanilla Android, you can easily create a Cyanogenmod
    system image and a Clockworkmod custom recovery.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of the Clockworkmod UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_99.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: TWRP – Team Win Recovery Project
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One alternative to the famous Clockworkmod recovery is TWRP, which stands for
    Team Win Recovery Project. One of the most important features of this recovery
    mod is support for touchscreens.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can interact with the recovery mod directly using the screen,
    like you normally do using Android, which is very convenient, especially if we
    compare it to the volume keys used in all the other recovery mods. The graphical
    interface is pretty usable, with big buttons that show all the various options
    (they are very similar to the ones in the Clockwork mod). Using TWRP, you can
    install unofficial ROMs and also perform a complete system backup.
  prefs: []
  type: TYPE_NORMAL
- en: The project was born on 30th July 2011 and is an open source project— also,
    here you can either download a binary for your device or recompile from source
    code.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on the official website at [http://teamw.in/](http://teamw.in/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some screenshots of TWRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting to the recovery shell using ADB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Custom recovery can be operated using their standard UI, as we saw, and using
    an ADB connection. This feature is not available in the stock recovery and will
    be very useful during our experiments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the custom recovery is installed, fire up a terminal and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'ADB will list all the available devices, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Knowing that there is just a single device, we can simply use the following
    command to connect to the recovery shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will be prompted with a `#` symbol, which lets you know that you have administrator
    powers as a *root* user. Being a *root* user gives you the opportunity to do advanced
    tasks, such as mount the `system/` in *read/write mode* and add or remove any
    file you want, without starting the whole Android system.
  prefs: []
  type: TYPE_NORMAL
- en: Device permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen in previous chapters, Android is based on Linux, so it also
    inherits the part that concerns user permissions. As with a standard Linux system,
    Android also manages everything through groups and users. In the default configuration,
    it's not possible to obtain administrator (root) access, in order to prevent tampering
    with the system. Also, with access to the whole operating system, it's easy to
    corrupt the system itself, accidentally or deliberately (for example, to steal
    user data using a virus).
  prefs: []
  type: TYPE_NORMAL
- en: Every Android app, when installed on the system, generates a new user and group,
    and inter-app communications are performed according to Android SDK constraints
    and protocols. Sometimes, though, it's useful to have complete control over the
    device, like, for example, when installing apps that manage CPU frequency and
    the CPU governor.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how to obtain root access and what the implications of rooting
    the device are.
  prefs: []
  type: TYPE_NORMAL
- en: Root access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Root access enables the users of smartphones, tablets, and other devices with
    Android OS installed to obtain privileged access, also called root access, to
    the whole Android operating system. As we have already mentioned, Android uses
    a Linux kernel, so obtaining root access is very similar to obtaining administrator
    (superuser) access to a regular Linux or Unix-like OS, such as FreeBSD or Mac
    OS X.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the reason for obtaining root access is to overcome the limits imposed
    on the device by the hardware producers. As a root user, you have the ability
    to modify or replace system apps and change the settings. Also, you can use the
    apps that require root permissions themselves, enabling you to execute operations
    that would otherwise be inaccessible to normal Android users. Rooting the device,
    that is, obtaining root access, can also help if you want to totally remove the
    device OS and replace it with another, maybe more recent, one.
  prefs: []
  type: TYPE_NORMAL
- en: In the following paragraphs, we will see how to obtain root access, which is
    the key precondition for installing the custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: SuperSu
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use root permissions in Android apps, an independent developer known as
    Chainfir Jorrit Jongma has developed a library that enables you to use them from
    your app and therefore execute root-level operations. Everything is open source
    and you can explore the documentation regarding the API at the official website
    of the developer: [https://su.chainfire.eu](https://su.chainfire.eu).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to check out the library source code, you can find it (and
    contribute) here: [https://github.com/Chainfire/libsuperuser](https://github.com/Chainfire/libsuperuser).'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining root access
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now it's time to see how to obtain root permissions on our device in practice.
    Unfortunately, it's not that simple, and there are various ways to obtain root
    permissions on a device. Every device has its quirks, and hence a different procedure
    to execute in order to obtain root permissions. Generally, we can say that if
    there's a possibility of installing a recovery mod, then there's also a possibility
    of installing everything necessary to become root. We just need to copy the right
    files to the system partition that is mounted as read-only by default, so we can
    access it either by making an ad hoc system partition using the source files,
    or—in cases when we don't have the Android source code—by mounting the partition
    in read/write mode through one of the custom recovery mods we described previously.
  prefs: []
  type: TYPE_NORMAL
- en: Up till now, we haven't talked about the legal issues regarding modifying the
    software present on the device. In general, it is not illegal to install custom
    ROMs onto our devices, except that there's the possibility of invalidating the
    device warranty. As far as the Nexus devices are concerned, there's no problem
    whatsoever; they are being sold for the purposes of software development, so the
    product warranty isn't tied to the software but to the hardware instead.
  prefs: []
  type: TYPE_NORMAL
- en: Chef toolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main goals of this book is to help you realize your own version of
    a ROM customization. In the dictionary of modders, the act of modifying a version
    of Android in order to produce one's own ROM customization is often referred to
    with the verb *to cook* and the word *kitchen*.
  prefs: []
  type: TYPE_NORMAL
- en: '"Cooking one''s own ROM" means to modify the stock version of Android installed
    on one''s device, with the aim of creating a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, all the tools that might help to make the development of a
    ROM customization easier are called **Chef toolkit**.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapters, it is indeed possible to create one's
    own ROM version starting from the source code, but this is not always possible,
    as some device manufacturers do not release their source code. In all those cases,
    we need to act on the system partitions, often directly on the binaries that build
    the internal core, both on the application framework and on the filesystem utilities.
  prefs: []
  type: TYPE_NORMAL
- en: In the next paragraphs, we will learn how to cook a ROM starting from binary
    images, beginning from the environment and analyzing the development tools that
    will help us carry out our first ROM customization.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can start developing the ROM, we most certainly need to prepare an
    adequate environment on our computer. Android can be used with basically all the
    most recent operating systems, from Windows, to Linux, to OS X.
  prefs: []
  type: TYPE_NORMAL
- en: We always refer to Ubuntu, as we did in the previous chapters when we dealt
    with compiling Android from the source code. Therefore, all you need to start
    is a computer with a recent version of Ubuntu installed on it. Besides that, we
    suggest to also install a good text editor for developers—it could either be VIM
    from the command line, or graphic editors such as ATOM, SublimeText, and so on.
    We will mostly work from the console, using different scripts and tools in order
    to finalize our first custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: Android kitchen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the *chef's* most important tools is undoubtedly the `Kitchen`. Although
    we are stealing our analogies from the world of cooking, we are actually focusing
    on the preparation of our first Android customization—the first step is obtaining
    the system binary images.
  prefs: []
  type: TYPE_NORMAL
- en: We refer to as the `Android Kitchen` the set of tools that are usually used,
    such as the scripts to be used in a shell, and which help the developer perform
    automated tasks, such as decompressing and editing the system images that build
    a ROM, decompiling APK packets, sometimes adding the root privileges to the ROM,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, many different kitchens exist online, each one with its own peculiarities.
    We will study some of them and we will try to perform simple actions in order
    to get our first custom ROM ready to be flashed onto our device.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular `Android Kitchens` is **dsixda**. The project is formally
    "retired," but it has been forked by lots of users and the development is still
    ongoing. It's open source and you can download it or fork it and contribute to
    the project starting from [https://github.com/dsixda/Android-Kitchen](https://github.com/dsixda/Android-Kitchen).
  prefs: []
  type: TYPE_NORMAL
- en: 'The dsixda `kitchen` is based on a suite of `Bash` scripts and tools to provide
    an easy method to perform the most common *cooking* operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Add Busybox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add root permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize the boot screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are just few of the possible operations available in its console menu.
    This kitchen is compatible with Windows, Linux, and OS X. We are going to use
    it with our trusted Ubuntu. Once you have downloaded the kitchen ([https://github.com/dsixda/Android-Kitchen/archive/0.224.zip](https://github.com/dsixda/Android-Kitchen/archive/0.224.zip)),
    uncompress it into a folder, enter the folder, and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will fire up the main menu, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The dsixda kitchen manipulates two specific partitions—system and boot-respectively
    compressed in `system.img` and `boot.img` files. In the following sections, we
    will dig into extracting these partitions and customizing them.
  prefs: []
  type: TYPE_NORMAL
- en: Other developers' tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many other different tools could come in handy for the developer, of course
    strictly depending on one's specific needs. A **hexadecimal editor** would certainly
    be very useful for the analysis of binary images, while simple graphics editing
    software would help when it comes to modifying icons or other graphical aspects
    of the ROM, as well as for preparing the whole environment for compiling the Linux
    kernel, and possibly Android applications to add to the ROM.
  prefs: []
  type: TYPE_NORMAL
- en: We usually prepare the environment as if we had to compile Android from the
    source together with the Linux kernel, so that we definitely have all the necessary
    tools to build our custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating DEX files with APKTool
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Working with an Android system, it's quite common to need to manipulate DEX
    files. DEX stands for **Dalvik Executable** and these files are used by Android
    Virtual Machine. To easily manipulate these files, you can use APKTool by Ryszard
    Wiśniewski and Connor Tumbleson. The tools are open source and you can download
    them at [http://ibotpeaches.github.io/Apktool/](http://ibotpeaches.github.io/Apktool/).
  prefs: []
  type: TYPE_NORMAL
- en: 'APKTool is written in Java, so you need a JVM to use it. Once you have the
    APKTool `jar` file in place, fire up a terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the version with yours, if necessary. The following screenshot shows
    the initial help menu of the tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'APKTool is based on two other tools—`smali` and `baksmali`, to assemble and
    disassemble the files. It requires an initial setup to work properly: `framework-res.apk`
    position. You must specify where APKTool must look to obtain this file. `framework-res.apk`
    is part of the Android system and can be extracted from a running Android device,
    using our trusted ADB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will copy the APK from the Android device into the current
    folder. Once we have the file in place, we can tell APKTool where to find it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that everything is configured, we can try to decompile and customize an
    APK, using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The APK content will be placed in the destination folder we specified and we
    can edit any file we want. After all our modifications, we can *recompress* the
    folder into an APK file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once the new APK is ready, we can copy it to the device with a file transfer
    app or using `ADB push`, as we saw in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Cooking our first ROM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen an overview of the suite of tools we need to create a custom
    ROM from a binary system image. The most important of all is the `kitchen`, and
    it needs `system.img` and `boot.img` partition files to properly do its job.
  prefs: []
  type: TYPE_NORMAL
- en: If you are targeting Google devices, this is an easy game. Google provides system
    source code for its devices, so we can always build our `.img` files from the
    source, as we learned in previous chapters. We can also grab the `.img` files
    from the official system installation packages that Google also provides for its
    devices at every new release of the Android system.
  prefs: []
  type: TYPE_NORMAL
- en: If you are targeting a device that's not a Nexus, things become more adventurous.
    Most of the time you don't have the system source code; often you don't even have
    the downloadable system images. As you will see in the next sections, there is
    always a way to obtain every last piece of the puzzle to create our custom ROM.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering the ingredients
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The list is quite short. All you need is:'
  prefs: []
  type: TYPE_NORMAL
- en: Kernel source code, if you want to customize the system at core level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`system.img`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot.img`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two `.img` files may be provided by the manufacturer, like Google does,
    or can be manually dumped from a running device system memory. The first scenario
    is the *lucky* one; the second one is more advanced and requires a bit of creativity.
    This is the scenario we are going to explore in greater depth, because, if you
    are lucky enough to have the manufactured system restore file, you simply need
    to decompress it into a folder and you will get the `.img` files you are looking
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Dumping system partitions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a dump of the system memory, you will need to access the system with
    root privileges. As we already know, there are a few ways to gain root privileges—device-specific
    rooting, installing a custom recovery, and so on. Pick the technique you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have root privileges, fire up a terminal and connect to your device
    shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The system will welcome us with a `#` symbol. We can now proceed with dumping
    the partitions. To get an overview of the partitions structure, you can use the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output for a standard Google Nexus 6 device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The number of partitions is almost overwhelming, but we need to focus just on
    the system partition and the boot partition. We know that the partitions we are
    interested in are there, among all those listed partitions. Now, we have to figure
    out which of those partitions is actually `system/` and which is `boot/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between a physical partition and its role in the Android architecture
    is shown with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command will show something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it shows every relevant partition and its role. We can easily
    figure out that the physical `mccblk0p41` will become our `system.img` and `mmcblk0p37`
    will become our `boot.img` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take advantage of the `/sdcard` partition to store the dumps, and we
    will create the dumps using the utility `dd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the previous command, you are copying the whole system partition into
    a single file on the SD card. This process can take a while—be patient. Once you
    have the `system.img` file, you can move on to creating the `boot.img` file, with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You now have the two most important files to create a custom ROM. Let's start
    customizing them.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an Android system binary image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to modify an Android system binary image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `system.img`. First of all, you need to bring it on to your
    host computer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you need to create a mount point to mount the image into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can mount it as a common image file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On old devices, the filesystem used for `system.img` was `yaffs`. Over the years,
    the Android system migrated to an `ext4` filesystem, also very common on lots
    of Linux systems. Chances are that you are working with an `ext4` filesystem right
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering the mount point with `cd` and listing the files with `ls`, you will
    see a folder structure similar to the one in the next image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/epub_36702041_105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can now navigate the folders tree and study the structure, removing or adding
    the file you want. One interesting file to study is `build.prop`. This file contains
    juicy information about the system and its configuration. It's a very hardware-specific
    file, due to the infinite possibilities for customizing an Android system, but
    most of the variants share common details, such as memory heap size, display density,
    device code name, manufacturer name, Android framework SDK version, Android system
    version, and so on. There is even information about the system build time and
    the default ringtone for notifications and calls. There are plenty of little customizations
    with which you can play and experiment. For heavier modifications, keep reading
    and get ready for what's coming in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an Android binary boot image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you already learned from the previous chapters, the boot image is a bit
    different from a system image. First of all, it doesn''t contain a filesystem
    we can mount on our host system: the boot image has to be *decompressed*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To decompress the boot image, you are going to use the specific menu item in
    the `Android Kitchen` from the previous pages. The boot image is a key component
    of a custom ROM: that''s where the kernel is and where the `init` scripts are.
    It''s the perfect spot to place a system customization that must be applied before
    the Android system starts, such as the CPU governor setup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with the boot image, just copy the file into the `Kitchen`
    folder, fire up the menu, and start picking the options you want from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the ROM name can be the perfect first step
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add root permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zipalign` the APK files for faster reading and loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deodexk` the APK file for easy file manipulation, paying the price of slower
    loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you are satisfied with the modifications, use the `kitchen` to generate
    an update file. This is a `.zip` file that can be flashed to the device using
    the custom recovery and represents your first custom ROM—congratulations!
  prefs: []
  type: TYPE_NORMAL
- en: Flashing our custom ROM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have your `.zip` file and your customized system partition, and you are
    thrilled to have flashed them to your device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To flash the system partition, we can use `fastboot`. First, you must unmount
    the partition itself using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we start experimenting with the system partition, it''s always wise
    to do a system backup:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Be prepared. You never know."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can put the device in Fastboot mode, according to the specific sequence
    of your device. For our reference device, Google Nexus 6, the sequence is:'
  prefs: []
  type: TYPE_NORMAL
- en: Power off
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Volume Up*, *Volume Down*, and *Power* at the same time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release when the `Fastboot` menu appears
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The device is now ready to receive the new system partition. Flash it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Your brand new system partition is in place! If your modifications were very
    extreme and adventurous, you could end up in a *bootloop*—the system keeps on
    rebooting and never ends the boot sequence. Stock system images distributed by
    manufacturers, or your own backups, come in very handy in this unfortunate scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are working with a Samsung device and you have a Windows system, you
    can check out `Samsung Odin`, a GUI tool to flash your ROMs and root your devices.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to flash the `.zip` file you generated with the `kitchen`.
    The file is generated according to a specific file structure and it's ready to
    be passed to your custom `recovery`. The `recovery` will treat it as a "system
    update" even if it's a completely brand new, customized system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, reboot your system in recovery mode. You can do it with a button
    sequence or using ADB, with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the device is in recovery mode, navigate with the volume buttons and select
    **Apply update from ADB**. This will put the device in waiting mode. Go back to
    your terminal and navigate to the `.zip` file generated with the `kitchen`. Finally,
    load the file to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! Your first custom ROM is *live* on your device. Now, go back
    to customize it even more!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter taught us what a custom ROM is. We started from a description of
    the currently existing, most relevant projects, and we have proceeded deep into
    the details. We have also had a look at some very important components, such as
    *Android Recovery*, both the stock ones and those that have been modified. Finally,
    as we did in the previous chapters, we have adopted a practical approach, learning
    how to prepare a suitable environment for Android customization. We have also
    studied the different tools that are generally used to perform this task, and,
    in the end, we have applied the concepts we just learned through a simple example
    of creating a custom ROM. In the next chapter, we will be diving deeper into every
    single aspect of a ROM, using practical examples to show how to customize and
    increase the performance of your ROM.
  prefs: []
  type: TYPE_NORMAL
