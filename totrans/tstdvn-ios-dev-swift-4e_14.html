<html><head></head><body>
		<div id="_idContainer076">
			<h1 id="_idParaDest-141"><em class="italic"><a id="_idTextAnchor444"/>Chapter 10</em>: Testing Networking Code</h1>
			<p>Almost all iOS apps communicate with some kind of server to synchronize data to other devices or to provide additional features that are not possible on the iOS device alone. As the code of the server application is separate from the code of the iOS application, the unit tests for the iOS app should not test features implemented in the server application. The unit tests for the iOS app should only fail if the code of the iOS app has bugs.</p>
			<p>To achieve that, the unit tests need to be independent of the server application. This separation has several advantages. The main ones are as follows:</p>
			<ul>
				<li>The unit tests are faster when they don't need to wait for the responses of the server.</li>
				<li>The unit tests do not fail because the server is not available.</li>
				<li>The networking code can be developed using test-driven development, even before the server application is available.</li>
			</ul>
			<p>In this chapter, we will implement two different kinds of networking code using test-driven development and mock objects. After you have worked through this chapter, you will be able to write tests for code that communicates with <strong class="source-inline">CLGeoCoder</strong>. You will also learn how to write tests for networking code using the new async/await API of <strong class="source-inline">URLSession</strong>.</p>
			<p>This chapter is structured as follows:</p>
			<ul>
				<li>Mocking <strong class="source-inline">CLGeoCoder</strong></li>
				<li>Testing async/await code that communicates with a <strong class="source-inline">URLSession</strong> instance</li>
				<li>Handling errors</li>
			</ul>
			<p>Writing tests for networking code is exciting, so let's get started.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor445"/>Mocking CLGeoCoder</h1>
			<p><strong class="source-inline">CLGeoCoder</strong> is a class <a id="_idIndexMarker419"/>provided by Apple that helps you to get coordinates <a id="_idIndexMarker420"/>from an address string and vice versa. The methods in <strong class="source-inline">CLGeoCoder</strong> are based on completion closures. In this chapter, we will explore how to mock and test such methods.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor446"/>Cleaning your project</h2>
			<p>Before we <a id="_idIndexMarker421"/>write the first test for this chapter, let's clean up the project a bit. Add sections in the project navigator and move the files to those sections according to your structure scheme. For inspiration, here is the structure I use for the main target:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_10.1_B18127.jpg" alt="Figure 10.1 – Adding structure in the project navigator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Adding structure in the project navigator</p>
			<p>Your structure <a id="_idIndexMarker422"/>can be completely different. Use the structure you usually use in iOS projects. Also, add a similar structure to the files in the test target.</p>
			<p>When you add new files to the project, you have to choose the correct folder depending on the structure you applied.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor447"/>Preparations for the tests</h2>
			<p>Before we <a id="_idIndexMarker423"/>can write tests for the <strong class="source-inline">APIClient</strong> class we added in <a href="B18127_09_ePub.xhtml#_idTextAnchor324"><em class="italic">Chapter 9</em></a>, <em class="italic">Test-Driven Input View in SwiftUI</em>, we need a new test case class. Follow these steps to add it:</p>
			<ol>
				<li>Add a new <strong class="bold">Unit Test Case Class</strong> file with the <strong class="bold">Class</strong> n<a id="_idTextAnchor448"/><a id="_idTextAnchor449"/>ame <strong class="source-inline">APIClientTests</strong> to the test target. Remove the two test template methods.</li>
				<li>Import the <strong class="source-inline">ToDo</strong> module using the <strong class="source-inline">@testable</strong> keyword and add setup and teardown code to the <strong class="source-inline">TestCase</strong> class:<p class="source-code">// APIClientTests.swift</p><p class="source-code">import XCTest</p><p class="source-code">@testable import ToDo</p><p class="source-code"> </p><p class="source-code">class APIClientTests<a id="_idTextAnchor450"/>: XCTestCase {</p><p class="source-code"> </p><p class="source-code">  var sut: APIClient!</p><p class="source-code"> </p><p class="source-code">  override func setUpWithError() throws {</p><p class="source-code">    sut = APIClient()</p><p class="source-code">  }</p><p class="source-code"> </p><p class="source-code">  override func tearDownWithError() throws {</p><p class="source-code">    sut = nil</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor451"/>Creating the first test</h2>
			<p>With this preparation, we are ready to write the first test for the <strong class="source-inline">APIClient</strong> class. Follow these <a id="_idIndexMarker424"/>steps to add a test for fetching the coordinate of an address using a <strong class="source-inline">CLGeoCoder</strong> instance and make it pass:</p>
			<ol>
				<li value="1">To be able to replace <strong class="source-inline">CLGeoCoder</strong> in the <strong class="source-inline">APIClient</strong> class with a mock object, we need to define the interface we expect in a protocol. Import the <strong class="source-inline">CoreLocation</strong> framework to <strong class="source-inline">APIClient.swift</strong> and add the following protocol definition to <strong class="source-inline">APIClient.swift</strong> outside of the <strong class="source-inline">APIClient</strong> class implementation:<p class="source-code">// APIClient.s<a id="_idTextAnchor452"/><a id="_idTextAnchor453"/>wift</p><p class="source-code">protocol GeoCoderProtocol {</p><p class="source-code">  func geocodeAddressString(</p><p class="source-code">    _ addressString: String,</p><p class="source-code">    completionHandler:</p><p class="source-code">    @escaping CLGeocodeCompletionHandler)</p><p class="source-code">}</p></li>
				<li>Next, we need to tell the compiler that <strong class="source-inline">CLGeoCoder</strong> already conforms to that protocol. It does so because it already implements a method with this exact signature. Add this line below the <strong class="source-inline">GeoCoderProtocol</strong> implementation:<p class="source-code">// APIClient.s<a id="_idTextAnchor454"/><a id="_idTextAnchor455"/>wift</p><p class="source-code">extension CLGeocoder: GeoCoderProtocol {}</p></li>
				<li>Now, we can define a mock object we will use in the test. Add a new Swift file to the test target and cal<a id="_idTextAnchor456"/><a id="_idTextAnchor457"/>l it <strong class="source-inline">GeoCoderProtocolMock.swift</strong>. Replace its content with the following:<p class="source-code">// GeoCoderProtocolMock.swift</p><p class="source-code">import Foundation</p><p class="source-code">@testable import <a id="_idTextAnchor458"/><a id="_idTextAnchor459"/>ToDo</p><p class="source-code">import CoreLocati<a id="_idTextAnchor460"/><a id="_idTextAnchor461"/>on</p><p class="source-code"> </p><p class="source-code">class GeoCoderProtocolMock: GeoCoderProtocol { </p><p class="source-code">  var geocodeAddressString: String?</p><p class="source-code">  var completionHandler: CLGeocodeCompletionHandler?</p><p class="source-code"> </p><p class="source-code">  func geocodeAddressString(</p><p class="source-code">    _ addressString: String,</p><p class="source-code">    completionHandler:</p><p class="source-code">    @escaping CLGeocodeCompletionHandler) { </p><p class="source-code">      geocodeAddressString = addressString</p><p class="source-code">      self.completionHandler = completionHandler</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>In the <a id="_idIndexMarker425"/>test, we want to call the <strong class="source-inline">geocodeAddressString(_:completionHandler:)</strong> method and pass a <strong class="source-inline">CLPlacemark</strong> instance into the completion handler. To create a <strong class="source-inline">CLPlacemark</strong> instance in a test, we need to import the <strong class="source-inline">Intents</strong> and <strong class="source-inline">Contacts</strong> frameworks, because the initializer we need is defined in the <strong class="source-inline">Intents</strong> framework and uses classes from the <strong class="source-inline">Contacts</strong> framework (I got this tip from the <em class="italic">StackOverflow</em> answer fo<a href="https://stackoverflow.com/a/52932708/498796">und at https://stackoverflow.com/a/52932708</a>/498796):<p class="source-code">// APIClientTests.<a id="_idTextAnchor462"/><a id="_idTextAnchor463"/>swift</p><p class="source-code">import Intents</p><p class="source-code">import Contacts</p></li>
				<li>Now, we can start with writing the tests. Add the following fragment of a test to <strong class="source-inline">APIClientTests</strong>:<p class="source-code">// APIClientTests.<a id="_idTextAnchor464"/><a id="_idTextAnchor465"/>swift</p><p class="source-code">func test_coordinate_fetchesCoordinate() {</p><p class="source-code">  let geoCoderMock = GeoCoderProtocolMock()</p><p class="source-code">  sut.geoCoder = geoCoderMock</p><p class="source-code">}</p></li>
			</ol>
			<p>Xcode tells <a id="_idIndexMarker426"/>us that we need to add a property for the <strong class="source-inline">geoCoder</strong> property to <strong class="source-inline">APIClient</strong>.</p>
			<ol>
				<li value="6">Go to the <strong class="source-inline">APIClient</strong> class and add the following property:<p class="source-code">// APIClient<a id="_idTextAnchor466"/><a id="_idTextAnchor467"/>.swift</p><p class="source-code">lazy var geoCoder: GeoCoderProtocol</p><p class="source-code">  = CLGeocoder()</p></li>
			</ol>
			<p>The <strong class="source-inline">lazy</strong> keyword means that the initializer is called the first time the property is accessed.</p>
			<ol>
				<li value="7">Go back to the test and make it look like this:<p class="source-code">// APIClientTests<a id="_idTextAnchor468"/><a id="_idTextAnchor469"/>.swift</p><p class="source-code">func test_coordinate_fetchesCoordinate() {</p><p class="source-code">  let geoCoderMock = GeoCoderProtocolMock()</p><p class="source-code">  sut.geoCoder = geoCoderMock</p><p class="source-code">  let location = CLLocation(latitude: 1,</p><p class="source-code">    longitude: 2)</p><p class="source-code">  let placemark = CLPlacemark(location: location,</p><p class="source-code">    name: nil,</p><p class="source-code">    postalAddress: nil)</p><p class="source-code">  let expectedAddress = "dummy address"</p><p class="source-code">  var result: Coordinate?</p><p class="source-code">  sut.coordinate(for: expectedAddress) { coordinate in</p><p class="source-code">    result = coordinate</p><p class="source-code">  }</p><p class="source-code">  geoCoderMock.completionHandler?([placemark], nil)</p><p class="source-code">  XCTAssertEqual(geoCoderMock.geocodeAddressString,</p><p class="source-code">    expectedAddress)</p><p class="source-code">  XCTAssertEqual(result?.latitude,</p><p class="source-code">    location.coordinate.latitude)</p><p class="source-code">  XCTAssertEqual(result?.longitude,</p><p class="source-code">    location.coordinate.longitude)</p><p class="source-code">}</p></li>
			</ol>
			<p>After we <a id="_idIndexMarker427"/>have set up the <strong class="source-inline">geoCoderMock</strong> instance, we create dummy variables and call the method we want to test. The <strong class="source-inline">GeoCoderProtocolMock</strong> class captures the completion handler of the <strong class="source-inline">geocodeAddressString(_:complectionHandler:)</strong> call. This allows us to call this completion handler with a placemark we created. In the test assertions, we check whether the method was called with the address string we provided and whether the coordinate was passed into the <strong class="source-inline">completion</strong> closure of the <strong class="source-inline">coordinate(for:completion:)</strong> method.</p>
			<ol>
				<li value="8">Replace the implementation of <strong class="source-inline">coordinate(for:completion:)</strong> in <strong class="source-inline">APIClient</strong> with the following implementation:<p class="source-code">// APIClient.swift</p><p class="source-code">func coordinate<a id="_idTextAnchor470"/><a id="_idTextAnchor471"/>(</p><p class="source-code">  for address: String,</p><p class="source-code">  completion: (Coordinate?) -&gt; <a id="_idTextAnchor472"/><a id="_idTextAnchor473"/>Void) {</p><p class="source-code">    geoCoder.geocodeAddressString(</p><p class="source-code">      address) { placemarks, error in</p><p class="source-code">      }</p><p class="source-code">}</p></li>
			</ol>
			<p>Note that we added an internal name for the address string parameter.</p>
			<p>Run the tests. The new test still fails, but the first assertion doesn't fail anymore. This tells <a id="_idIndexMarker428"/>us that our test does too much. We should split this test into two tests: one that checks whether the method is called with the address string we provide, and another one that checks that the coordinate is passed into the completion closure.</p>
			<ol>
				<li value="9">We should always only have one failing test, so add <strong class="source-inline">x_</strong> in front of the method name of <strong class="source-inline">test_coordinate_fetchesCoordinate</strong>:<p class="source-code">// APIClientTests.swift</p><p class="source-code">func x_test_coordinate_fetchesCoordinate() {</p><p class="source-code">  // …</p></li>
			</ol>
			<p>As the test runner searches for methods beginning with the word <strong class="source-inline">test</strong>, adding <strong class="source-inline">x_</strong> hides the method from the test runner. To confirm that this is true, run all tests again.</p>
			<ol>
				<li value="10">Now, add the following test method to <strong class="source-inline">APIClientTests</strong>:<p class="source-code"> // APIClientTes<a id="_idTextAnchor474"/><a id="_idTextAnchor475"/>ts.swift</p><p class="source-code">func test_coordinate_shouldCallGeoCoderWithAddress() {</p><p class="source-code">  let geoCoderMock = GeoCoderProtocolMock()</p><p class="source-code">  sut.geoCoder = geoCoderMock</p><p class="source-code">  let expectedAddress = "dummy address"</p><p class="source-code">  sut.coordinate(for: expectedAddress) { _ in</p><p class="source-code">  }</p><p class="source-code">  XCTAssertEqual(geoCoderMock.geocodeAddressString,</p><p class="source-code">    expectedAddress)</p><p class="source-code">}</p></li>
				<li>Remove the code we added to <strong class="source-inline">coordinate(for:completion:)</strong> in <strong class="source-inline">APIClient</strong> and run the tests to see this new test fail.</li>
				<li>Add the <a id="_idIndexMarker429"/>code again and run the tests. All tests should pass now.</li>
				<li>Now, we can remove the check for the address string from <strong class="source-inline">test_coordinate_fetchesCoordinate()</strong> because it is now asserted in <strong class="source-inline">test_coordinate_shouldCallGeoCoderWithAddress()</strong>:<p class="source-code">// APIClientTe<a id="_idTextAnchor476"/><a id="_idTextAnchor477"/>sts.swift</p><p class="source-code">func test_coordinate_fetchesCoordinate() {</p><p class="source-code">  let geoCoderMock = GeoCoderProtocolMock()</p><p class="source-code">  sut.geoCoder = geoCoderMock</p><p class="source-code">  let location = CLLocation(latitude: 1,</p><p class="source-code">    longitude: 2)</p><p class="source-code">  let placemark = CLPlacemark(location: location,</p><p class="source-code">    name: nil,</p><p class="source-code">    postalAddress: nil)</p><p class="source-code">  var result: Coordinate?</p><p class="source-code">  sut.coordinate(for: "") { coordinate in</p><p class="source-code">    result = coordinate</p><p class="source-code">  }</p><p class="source-code">  geoCoderMock.completionHandler?([placemark], nil)</p><p class="source-code">  XCTAssertEqual(result?.latitude,</p><p class="source-code">    location.coordinate.latitude)</p><p class="source-code">  XCTAssertEqual(result?.longitude,</p><p class="source-code">    location.coordinate.longitude)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run all tests to see this test fail.</p>
			<ol>
				<li value="14">To make <a id="_idIndexMarker430"/>this test pass, we need to get the coordinate from the <strong class="source-inline">CLGeoCoder</strong> instance and pass it into the completion handler. Replace the <strong class="source-inline">coordinate(for:completion:)</strong> method with the following implementation:<p class="source-code">// APICl<a id="_idTextAnchor478"/><a id="_idTextAnchor479"/>ient.swift</p><p class="source-code">func coordinate(</p><p class="source-code">  for address: String,</p><p class="source-code">  completion: @escaping (Coordinate?) -&gt; Void) {</p><p class="source-code">    geoCoder.geocodeAddressString(address) { </p><p class="source-code">      placemarks, error in</p><p class="source-code">      guard let clCoordinate =</p><p class="source-code">        placemarks?.first?.location?.coordinate</p><p class="source-code">      else {</p><p class="source-code">        completion(nil)</p><p class="source-code">        return</p><p class="source-code">      }</p><p class="source-code">      let coordinate = Coordinate(</p><p class="source-code">        latitude: clCoordinate.latitude,</p><p class="source-code">        longitude: clCoordinate.longitude)</p><p class="source-code">      completion(coordinate)</p><p class="source-code">    }</p><p class="source-code">  }</p></li>
			</ol>
			<p>Now, Xcode <a id="_idIndexMarker431"/>complains that <strong class="bold">Type 'APIClient' does not conform to protocol 'APIClientProtocol'</strong>. To fix this error, we need to add the <strong class="source-inline">@escaping</strong> keyword to the <strong class="source-inline">completion</strong> parameter in the <strong class="source-inline">APIClientProtocol</strong> protocol.</p>
			<ol>
				<li value="15">Replace the <strong class="source-inline">APIClientProtocol</strong> definition with the following:<p class="source-code">// APIClient.swift</p><p class="source-code">protocol APIClientProtocol {</p><p class="source-code">  func coordinate(</p><p class="source-code">    for: String,</p><p class="source-code">    completion: @escaping (Coordinate?) -&gt; Void)</p><p class="source-code">}</p></li>
				<li>Run all tests to confirm that now all tests pass.</li>
			</ol>
			<p>With this implementation, our app can now fetch the coordinate of an address string. This feature enables our users to add a location to a to-do item.</p>
			<p>In the next section, we will implement fetching to-do items from a server. We don't need an actual server to write the tests and the implementation for this feature. This is one of the many advantages of test-driven development.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor480"/>Testing async/await code that communicates with URLSession</h1>
			<p>In 2021, Apple introduced async/await in Swift. With async/await, asynchronous code (for example, fetching information from a server) is easier to write and easier to understand. In this section, we will learn how to implement fetching data from a web server <a id="_idIndexMarker432"/>using the async/await APIs of the <strong class="source-inline">URLSession</strong> class; and we will do this, of course, using test-driven development.</p>
			<p>Unit tests <a id="_idIndexMarker433"/>need to be fast and repeatable. This means we don't want to rely on a connection to a real server in our unit tests. Instead, we will replace the communication with the server with a mock object. </p>
			<p>Follow these steps to implement fetching to-do items from a server:</p>
			<ol>
				<li value="1">In the test, we will use a mock object of a <strong class="source-inline">URLSession</strong> class instead of the real <strong class="source-inline">URLSession</strong> instance. To be able to replace the real <strong class="source-inline">URLSession</strong> instance with the mock, we need a protocol that defines the interface we want to replace.</li>
				<li>Add the following protocol definition to <strong class="source-inline">APIClient.swift</strong>:<p class="source-code">// AP<a id="_idTextAnchor481"/><a id="_idTextAnchor482"/>IClient.swift</p><p class="source-code">protocol URLSessionProtocol {</p><p class="source-code">  func data(for request: URLRequest,</p><p class="source-code">    delegate: URLSessionTaskDelegate?)</p><p class="source-code">  async throws -&gt; (Data, URLResponse)</p><p class="source-code">}</p></li>
				<li>Next, we need to tell the compiler that the <strong class="source-inline">URLSession</strong> class already conforms to this protocol. Add the following code to <strong class="source-inline">APIClient.swift</strong>:<p class="source-code">// AP<a id="_idTextAnchor483"/><a id="_idTextAnchor484"/>IClient.swift</p><p class="source-code">extension URLSession: URLSessionProtocol {}</p></li>
				<li>Select <a id="_idIndexMarker434"/>the <strong class="bold">ToDoTests</strong> group <a id="_idIndexMarker435"/>in the project navigator and add a new Swift f<a id="_idTextAnchor485"/><a id="_idTextAnchor486"/>ile and call it <strong class="source-inline">URLSessionProtocolMock</strong>. Replace its contents with the following:<p class="source-code">// URLSessionProtoclMock.swift</p><p class="source-code">im<a id="_idTextAnchor487"/><a id="_idTextAnchor488"/>port Foundation</p><p class="source-code">@testabl<a id="_idTextAnchor489"/><a id="_idTextAnchor490"/>e import ToDo</p><p class="source-code"> </p><p class="source-code">class URLSessionProtocolMock: URLSessionProtocol { </p><p class="source-code">  var dataForDelegateReturnValue: (Data, URLResponse)?</p><p class="source-code">  var dataForDelegateRequest: URLRequest?</p><p class="source-code"> </p><p class="source-code">  func data(for request: URLRequest,</p><p class="source-code">    delegate: URLSessionTaskDelegate?)</p><p class="source-code">  async throws -&gt; (Data, URLResponse) {</p><p class="source-code"> </p><p class="source-code">    dataForDelegateRequest = request</p><p class="source-code"> </p><p class="source-code">    guard let dataForDelegateReturnValue =</p><p class="source-code">      dataForDelegateReturnValue else {</p><p class="source-code">        fatalError()</p><p class="source-code">        }</p><p class="source-code">    return dataForDelegateReturnValue</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This mock object allows us to define the return value of <strong class="source-inline">data(for:delegate:)</strong> in the test we are going to write.</p>
			<ol>
				<li value="5">With <a id="_idIndexMarker436"/>this preparation, we <a id="_idIndexMarker437"/>can start writing the test. Add the following fragment of the test method to <strong class="source-inline">APIClientTests</strong>:<p class="source-code">// API<a id="_idTextAnchor491"/><a id="_idTextAnchor492"/>ClientTests.swift</p><p class="source-code">func test_toDoItems_shouldFetcheItems() async throws {</p><p class="source-code">  let url = try XCTUnwrap</p><p class="source-code">    (URL(string: "http://toodoo.app/items"))</p><p class="source-code">  let urlSessionMock = URLSessionProtocolMock()</p><p class="source-code">  let expected = [ToDoItem(title: "dummy title")]</p><p class="source-code">  urlSessionMock.dataForDelegateReturnValue = (</p><p class="source-code">    try JSONEncoder().encode(expected),</p><p class="source-code">    HTTPURLResponse(url: url,</p><p class="source-code">      statusCode: 200,</p><p class="source-code">      httpVers<a id="_idTextAnchor493"/><a id="_idTextAnchor494"/>ion: "HTTP/1.1",</p><p class="source-code">      headerFields: nil)!</p><p class="source-code">  )</p><p class="source-code">  sut.session = urlSessionMock</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we define the URL and the data to be used in the mock response. The <strong class="source-inline">urlSessionMock</strong> class returns a JSON object with one <strong class="source-inline">ToDoItem</strong> object and an <strong class="source-inline">HTTPURLResponse</strong> instance with the expected URL and the status code <strong class="source-inline">200</strong>.</p>
			<p>We have to pause writing the test because the system under test (the <strong class="source-inline">APIClient</strong> class) doesn't have a <strong class="source-inline">session</strong> property yet.</p>
			<ol>
				<li value="6">Go to <strong class="source-inline">APIClient</strong> and add the property like this:<p class="source-code">/<a id="_idTextAnchor495"/><a id="_idTextAnchor496"/>/ APIClient.swift</p><p class="source-code">lazy var session: URLSessionProtocol</p><p class="source-code">= URLSession.shared</p></li>
				<li>Switch <a id="_idIndexMarker438"/>back to the <a id="_idIndexMarker439"/>test class and add the call to fetch the to-do items:<p class="source-code">// APIClientTests.swift</p><p class="source-code"><a id="_idTextAnchor497"/><a id="_idTextAnchor498"/>func test_toDoItems_shouldFetcheItems() async throws {</p><p class="source-code">  let url = try XCTUnwrap</p><p class="source-code">    (URL(string: "http://toodoo.app/items"))</p><p class="source-code">  let urlSessionMock = URLSessionProtocolMock()</p><p class="source-code">  let expected = [ToDoItem(title: "dummy title")]</p><p class="source-code">  urlSessionMock.dataForDelegateReturnValue = (</p><p class="source-code">    try JSONEncoder().encode(expected),</p><p class="source-code">    HTTPURLResponse(url: url,</p><p class="source-code">      statusCode: 200,</p><p class="source-code">      httpVersion: "HTTP/1.1",</p><p class="source-code">      headerFields: nil)!</p><p class="source-code">  )</p><p class="source-code">  sut.sessio<a id="_idTextAnchor499"/><a id="_idTextAnchor500"/>n = urlSessionMock</p><p class="source-code">  let items = try await sut.toDoItems()</p><p class="source-code">}</p></li>
			</ol>
			<p>Again, we have to pause because this method is not defined yet.</p>
			<ol>
				<li value="8">Go to <strong class="source-inline">APIClient</strong> and add the minimal implementation to make the test compile:<a id="_idTextAnchor501"/><a id="_idTextAnchor502"/><p class="source-code">// APIClient.swift</p><p class="source-code">func toDoItems() async throws -&gt; [ToDoItem] {</p><p class="source-code">  return []</p><p class="source-code">}</p></li>
				<li>Finally, we <a id="_idIndexMarker440"/>can finish <a id="_idIndexMarker441"/>the test. Add the assertion call as shown in this code snippet:<p class="source-code">// APIClientTests.swift</p><p class="source-code">func test_toDoItems_shouldFetcheItems() async throws {</p><p class="source-code">  let url = try XCTUnwrap</p><p class="source-code">    (URL(string: "http://toodoo.app/items"))</p><p class="source-code">  let urlSessionMock = URLSessionProtocolMock()</p><p class="source-code">  let expected = [ToDoItem(title: "dummy title")]</p><p class="source-code">  urlSessionMock.dataForDelegateReturnValue = (</p><p class="source-code">    try JSONEncoder().encode(expected),</p><p class="source-code">    HTTPURLResponse(url: url,</p><p class="source-code">      statusCode: 200,</p><p class="source-code">      httpVersion: "HTTP/1.1",</p><p class="source-code">      headerFields: nil)!</p><p class="source-code">  )</p><p class="source-code">  sut.session = urlSessionMock</p><p class="source-code">  let items = try awa<a id="_idTextAnchor503"/><a id="_idTextAnchor504"/>it sut.toDoItems()</p><p class="source-code">  XCTAssertEqual(items, expected)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="10">To make <a id="_idIndexMarker442"/>the test <a id="_idIndexMarker443"/>pass, replace the <strong class="source-inline">toDoItems</strong> method in the <strong class="source-inline">APIClient</strong> class with the following c<a id="_idTextAnchor505"/><a id="_idTextAnchor506"/>ode:<p class="source-code">// APIClient.swift</p><p class="source-code">func toDoItems() async throws -&gt; [ToDoItem] {</p><p class="source-code">  guard let url =</p><p class="source-code">    URL(string: "dummy")</p><p class="source-code">  else {</p><p class="source-code">    return []</p><p class="source-code">  }</p><p class="source-code">  let request = URLRequest(url: url)</p><p class="source-code">  let (data, _) = try await session.data(</p><p class="source-code">    for: request,</p><p class="source-code">      delegate: nil)</p><p class="source-code">  let items = try JSONDecoder()</p><p class="source-code">    .decode([ToDoItem].self, from: data)</p><p class="source-code">  return items</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we define the URL, create a request, call <strong class="source-inline">data(for:delegate:)</strong> on the session property, and try to decode the result into an array of <strong class="source-inline">ToDoItems</strong>.</p>
			<p>Run the tests to confirm that this code makes the tests pass.</p>
			<p>But, there is something strange with this code. The URL is wrong. We need to expand the test to also check for the used URL.</p>
			<ol>
				<li value="11">Add <a id="_idIndexMarker444"/>the following <a id="_idIndexMarker445"/>assert function call to the end of <strong class="source-inline">test_doToItems_shouldFetchesItems<a id="_idTextAnchor507"/><a id="_idTextAnchor508"/></strong>:<p class="source-code">// APIClientTests.swift</p><p class="source-code">XCTAssertEqual(urlSessionMock.dataForDelegateRequest,</p><p class="source-code">  URLRequest(url: url))</p></li>
			</ol>
			<p>Run the tests to confirm that the test now fails because we used the wrong URL in the implementation.</p>
			<ol>
				<li value="12">To make the test pass, replace the URL initialization in the <strong class="source-inline">toDoItems</strong> method with this implement<a id="_idTextAnchor509"/><a id="_idTextAnchor510"/>ation:<p class="source-code">// APIClient.swift</p><p class="source-code">guard let url =</p><p class="source-code">  URL(string: "http://toodoo.app/items")</p><p class="source-code">else {</p><p class="source-code">  return []</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that now all tests pass.</p>
			<p>Of course, this implementation is just an example to get you started testing network calls. In a real app, you would add authorization to the network calls to ensure that users can only access their to-do items and not the ones of other users.</p>
			<p>Fetching data from a web service can go wrong. In the following section, we will test whether the error from the <strong class="source-inline">URLSession</strong> instance is passed down to the caller of <strong class="source-inline">toDoItems</strong>.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor511"/>Handling errors</h1>
			<p>To test the <a id="_idIndexMarker446"/>handling of errors in the <strong class="source-inline">URLSession</strong> call to the web service, we first need to enhance <strong class="source-inline">URLSessionProtocolMock</strong>. Follow these steps to test that an error in fetching data is passed down to the caller of the <strong class="source-inline">APIClient</strong> instance:</p>
			<ol>
				<li value="1">Add the following property to <strong class="source-inline">URLSessionProtocolMock</strong>:<p class="source-code">// UR<a id="_idTextAnchor512"/><a id="_idTextAnchor513"/>LSessionProtocolMock.swift</p><p class="source-code">var dataForDelegateError: Error?</p></li>
				<li>Next, add the following handling of the error to the start of <strong class="source-inline">data(for:delegate:)</strong>:<p class="source-code">// UR<a id="_idTextAnchor514"/><a id="_idTextAnchor515"/>LSessionProtocolMock.swift</p><p class="source-code">if let error = dataForDelegateError {</p><p class="source-code">  throw error</p><p class="source-code">}</p></li>
			</ol>
			<p>If there is an error set to the <strong class="source-inline">dataForDelegateError</strong> property, we throw it before we do anything else in this method.</p>
			<ol>
				<li value="3">Now, we are ready to add the test method to <strong class="source-inline">APIClientTest<a id="_idTextAnchor516"/><a id="_idTextAnchor517"/>s</strong>:<p class="source-code">// APIClientTests.swift</p><p class="source-code">func test_toDoItems_whenError_shouldPassError() async</p><p class="source-code"> throws {</p><p class="source-code">  let urlSessionMock = URLSessionProtocolMock()</p><p class="source-code">  let expected = NSError(domain: "", code: 1234)</p><p class="source-code">  urlSessionMock.dataForDelegateError = expected</p><p class="source-code">  sut.session = urlSessionMock</p><p class="source-code">  do {</p><p class="source-code">    _ = try await sut.toDoItems()</p><p class="source-code">    XCTFail()</p><p class="source-code">  } catch {</p><p class="source-code">    let nsError = try XCTUnwrap(error as NSError)</p><p class="source-code">    XCTAssertEqual(nsError, expected)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we <a id="_idIndexMarker447"/>create an error and assign it to the <strong class="source-inline">dataForDelegateError</strong> property of <strong class="source-inline">urlSessionMock</strong>. Then, we call <strong class="source-inline">sut.toDoItems()</strong> within a <strong class="source-inline">do-catch</strong> block to catch the error we expect from the call. If no error is thrown from <strong class="source-inline">toDoItems()</strong> the test fails with <strong class="source-inline">XCTFail</strong>. Otherwise, we compare the error with the expected value.</p>
			<p>Run the tests. All tests pass already. This is bad. As you already learned, in test-driven development we need to see a test fail before we make it green. Otherwise, we can't be sure that the tests can fail. It's easy to write tests that always pass. So, let's make the test fail.</p>
			<ol>
				<li value="4">Change the implementation of <strong class="source-inline">data(for:delegate:)</strong> in <strong class="source-inline">URLSessionProtocolMock</strong> so that it looks like this:<p class="source-code">// URLSessionProtocolMock.swift</p><p class="source-code">func data(for request: URLRequest,</p><p class="source-code">  delegate: URLSessionTaskDelegate?)</p><p class="source-code">async throws <a id="_idTextAnchor518"/><a id="_idTextAnchor519"/>-&gt; (Data, URLResponse) {</p><p class="source-code">  throw NSError(domain: "dummy", code: 0)</p><p class="source-code">  if let error = dataForDelegateError {</p><p class="source-code">    throw error</p><p class="source-code">  }</p><p class="source-code">  dataForDelegateRequest = request</p><p class="source-code">  guard let dataForDelegateReturnValue =</p><p class="source-code">          dataForDelegateReturnValue else {</p><p class="source-code">            fatalError()</p><p class="source-code">          }</p><p class="source-code">  return dataForDelegateReturnValue</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests <a id="_idIndexMarker448"/>again to confirm that with this change, the new test fails.</p>
			<ol>
				<li value="5">Remove the <strong class="source-inline">throw NSError(domain: "dummy", code: 0)</strong> line again and run the tests to see all tests pass again.</li>
			</ol>
			<p>With this test, we have confirmed that an error in fetching the data from the web service is passed down to the caller of <strong class="source-inline">toDoItems()</strong>.</p>
			<p>But what happens when the data from the web service is not in the format we expect? What should happen in this case? Follow these steps to add a test for this case:</p>
			<ol>
				<li value="1">Add the following test method to <strong class="source-inline">APIClientTe<a id="_idTextAnchor520"/><a id="_idTextAnchor521"/>sts</strong>:<p class="source-code">/<a id="_idTextAnchor522"/><a id="_idTextAnchor523"/>/ APIClientTests.swift</p><p class="source-code">func</p><p class="source-code"> test_toDoItems_whenJSONIsWrong_shouldFetcheItems()</p><p class="source-code"> async throws {</p><p class="source-code">  let url = try XCTUnwrap(URL(string: "foo"))</p><p class="source-code">  let urlSessionMock = URLSessionProtocolMock()</p><p class="source-code">  urlSessionMock.dataForDelegateReturnValue = (</p><p class="source-code">    try JSONEncoder().encode("dummy"),</p><p class="source-code">    HTTPURLResponse(url: url,</p><p class="source-code">      statusCode: 200,</p><p class="source-code">      httpVersion: "HTTP/1.1",</p><p class="source-code">      headerFields: nil)!</p><p class="source-code">  )</p><p class="source-code">  sut.session = urlSessionMock</p><p class="source-code">  do {</p><p class="source-code">    _ = try await sut.toDoItems()</p><p class="source-code">    XCTFail()</p><p class="source-code">  } catch {</p><p class="source-code">    XCTAssertTrue(error is Swift.DecodingError)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>The data <a id="_idIndexMarker449"/>we return here when <strong class="source-inline">toDoItems</strong> of <strong class="source-inline">urlSessionMock</strong> is called is a JSON object of the <strong class="source-inline">dummy</strong> string. Trying to decode this into an array of <strong class="source-inline">ToDoItem</strong> objects should result in an error of the <strong class="source-inline">Swift.DecodingError</strong> type. This is what the last assertion in the test asserts.</p>
			<ol>
				<li value="2">Run the tests. Again, all tests pass. And again, we need to change something to see this test fail.</li>
				<li>Go to <strong class="source-inline">APIClient</strong> and replace <strong class="source-inline">toDoItems()</strong> with the following implementation:<p class="source-code">// APIClient.swift</p><p class="source-code">func toDoItems() async throws -&gt; [ToDoItem] {</p><p class="source-code">  guard let url =</p><p class="source-code">    URL(string: "http://toodoo.app/items")</p><p class="source-code">  else {</p><p class="source-code">    return []</p><p class="source-code">  }</p><p class="source-code">  let request = URLRequest(url: url)</p><p class="source-code">  let (data, _) = try await session.data(</p><p class="source-code">    for: request,</p><p class="source-code">      delegate: nil)</p><p class="source-code">  let items = try? JSONDecoder()</p><p class="source-code">    .decode([ToDoItem].self, from: data)</p><p class="source-code">  return items ?? []</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we have changed the last three lines of that method. Instead of <strong class="source-inline">try</strong>, we use <strong class="source-inline">try?</strong> when we try to decode the data from the web service. When the data <a id="_idIndexMarker450"/>cannot be decoded into an array of <strong class="source-inline">ToDoItem</strong>s, the result is optional and no error is thrown. As a result, we also need to change the <strong class="source-inline">return</strong> value. When the value of the <strong class="source-inline">items</strong> property is <strong class="source-inline">nil</strong>, we return an <strong class="source-inline">empty</strong> array.</p>
			<p>Run the tests. The test we added last now fails and we have confirmed that it actually can fail.</p>
			<ol>
				<li value="4">Change the implementation of <strong class="source-inline">toDoItems()</strong> to what it was before:<p class="source-code">// APIClient.swift</p><p class="source-code">func toDoItems() async throws -&gt; [ToDoItem] {</p><p class="source-code">  guard let url =</p><p class="source-code">    URL(string: "http://toodoo.app/items")</p><p class="source-code">  else {</p><p class="source-code">    return []</p><p class="source-code">  }</p><p class="source-code">  let request = URLRequest(url: url)</p><p class="source-code">  let (data, _) = try await session.data(</p><p class="source-code">    for: request,</p><p class="source-code">      delegate: nil)</p><p class="source-code">  let items = try JSONDecoder()</p><p class="source-code">    .decode([ToDoItem].self, from: data)</p><p class="source-code">  return items</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests again to see all tests pass again.</p>
			<p>There are many <a id="_idIndexMarker451"/>more tests to write for the implementation of this web service call. For example, you should also write tests for cases when the web service answers with an HTTP status code other than <strong class="source-inline">200</strong>. These tests are left as an exercise for you. Add tests for this API call until you are confident that this feature does not break unnoticed in the future.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor524"/>Summary</h1>
			<p>In this chapter, we have learned how to write tests for calls to <strong class="source-inline">CLGeoCoder</strong> and how to test the async/await REST API calls of <strong class="source-inline">URLSession</strong>. We have seen what we need to do in the test method to test whether an error is thrown in an async/await call. In addition, we have learned how to make our network code tests independent from the implementation of server infrastructure. This way we made our tests fast and robust.</p>
			<p>You can use the skills gained in this chapter to write tests for the complete network layer of your apps. But you don't have to stop there. The strategies we've covered in this chapter also help to write tests for all kinds of async/await APIs.</p>
			<p>In the next chapter, we will put all the code that we wrote up to now together, and finally see the app running on the simulator.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor525"/>Exercises</h1>
			<ol>
				<li value="1">We have deactivated a test method using the <strong class="source-inline">x_</strong> prefix to hide it from the test runner. There are other ways to deactivate a single test. Do some research on the internet to figure these out.</li>
				<li>In this chapter, we wrote tests for the async/await API of <strong class="source-inline">URLSession</strong>. But, <strong class="source-inline">URLSession</strong> also provides an API that uses the delegate pattern and one that uses Combine. Do some research on the internet to find out how to write unit tests for these APIs. Make sure that these tests also run when there is no connection to the server.</li>
			</ol>
		</div>
	</body></html>