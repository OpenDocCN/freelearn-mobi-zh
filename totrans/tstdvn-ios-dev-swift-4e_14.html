<html><head></head><body>
		<div><h1 id="_idParaDest-141"><em class="italic"><a id="_idTextAnchor444"/>Chapter 10</em>: Testing Networking Code</h1>
			<p>Almost all iOS apps communicate with some kind of server to synchronize data to other devices or to provide additional features that are not possible on the iOS device alone. As the code of the server application is separate from the code of the iOS application, the unit tests for the iOS app should not test features implemented in the server application. The unit tests for the iOS app should only fail if the code of the iOS app has bugs.</p>
			<p>To achieve that, the unit tests need to be independent of the server application. This separation has several advantages. The main ones are as follows:</p>
			<ul>
				<li>The unit tests are faster when they don't need to wait for the responses of the server.</li>
				<li>The unit tests do not fail because the server is not available.</li>
				<li>The networking code can be developed using test-driven development, even before the server application is available.</li>
			</ul>
			<p>In this chapter, we will implement two different kinds of networking code using test-driven development and mock objects. After you have worked through this chapter, you will be able to write tests for code that communicates with <code>CLGeoCoder</code>. You will also learn how to write tests for networking code using the new async/await API of <code>URLSession</code>.</p>
			<p>This chapter is structured as follows:</p>
			<ul>
				<li>Mocking <code>CLGeoCoder</code></li>
				<li>Testing async/await code that communicates with a <code>URLSession</code> instance</li>
				<li>Handling errors</li>
			</ul>
			<p>Writing tests for networking code is exciting, so let's get started.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor445"/>Mocking CLGeoCoder</h1>
			<p><code>CLGeoCoder</code> is a class <a id="_idIndexMarker419"/>provided by Apple that helps you to get coordinates <a id="_idIndexMarker420"/>from an address string and vice versa. The methods in <code>CLGeoCoder</code> are based on completion closures. In this chapter, we will explore how to mock and test such methods.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor446"/>Cleaning your project</h2>
			<p>Before we <a id="_idIndexMarker421"/>write the first test for this chapter, let's clean up the project a bit. Add sections in the project navigator and move the files to those sections according to your structure scheme. For inspiration, here is the structure I use for the main target:</p>
			<div><div><img src="img/Figure_10.1_B18127.jpg" alt="Figure 10.1 – Adding structure in the project navigator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – Adding structure in the project navigator</p>
			<p>Your structure <a id="_idIndexMarker422"/>can be completely different. Use the structure you usually use in iOS projects. Also, add a similar structure to the files in the test target.</p>
			<p>When you add new files to the project, you have to choose the correct folder depending on the structure you applied.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor447"/>Preparations for the tests</h2>
			<p>Before we <a id="_idIndexMarker423"/>can write tests for the <code>APIClient</code> class we added in <a href="B18127_09_ePub.xhtml#_idTextAnchor324"><em class="italic">Chapter 9</em></a>, <em class="italic">Test-Driven Input View in SwiftUI</em>, we need a new test case class. Follow these steps to add it:</p>
			<ol>
				<li>Add a new <code>APIClientTests</code> to the test target. Remove the two test template methods.</li>
				<li>Import the <code>ToDo</code> module using the <code>@testable</code> keyword and add setup and teardown code to the <code>TestCase</code> class:<pre>// APIClientTests.swift
import XCTest
@testable import ToDo
 
class APIClientTests<a id="_idTextAnchor450"/>: XCTestCase {
 
  var sut: APIClient!
 
  override func setUpWithError() throws {
    sut = APIClient()
  }
 
  override func tearDownWithError() throws {
    sut = nil
  }
}</pre></li>
			</ol>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor451"/>Creating the first test</h2>
			<p>With this preparation, we are ready to write the first test for the <code>APIClient</code> class. Follow these <a id="_idIndexMarker424"/>steps to add a test for fetching the coordinate of an address using a <code>CLGeoCoder</code> instance and make it pass:</p>
			<ol>
				<li value="1">To be able to replace <code>CLGeoCoder</code> in the <code>APIClient</code> class with a mock object, we need to define the interface we expect in a protocol. Import the <code>CoreLocation</code> framework to <code>APIClient.swift</code> and add the following protocol definition to <code>APIClient.swift</code> outside of the <code>APIClient</code> class implementation:<pre>// APIClient.s<a id="_idTextAnchor452"/><a id="_idTextAnchor453"/>wift
protocol GeoCoderProtocol {
  func geocodeAddressString(
    _ addressString: String,
    completionHandler:
    @escaping CLGeocodeCompletionHandler)
}</pre></li>
				<li>Next, we need to tell the compiler that <code>CLGeoCoder</code> already conforms to that protocol. It does so because it already implements a method with this exact signature. Add this line below the <code>GeoCoderProtocol</code> implementation:<pre>// APIClient.s<a id="_idTextAnchor454"/><a id="_idTextAnchor455"/>wift
extension CLGeocoder: GeoCoderProtocol {}</pre></li>
				<li>Now, we can define a mock object we will use in the test. Add a new Swift file to the test target and cal<a id="_idTextAnchor456"/><a id="_idTextAnchor457"/>l it <code>GeoCoderProtocolMock.swift</code>. Replace its content with the following:<pre>// GeoCoderProtocolMock.swift
import Foundation
@testable import <a id="_idTextAnchor458"/><a id="_idTextAnchor459"/>ToDo
import CoreLocati<a id="_idTextAnchor460"/><a id="_idTextAnchor461"/>on
 
class GeoCoderProtocolMock: GeoCoderProtocol { 
  var geocodeAddressString: String?
  var completionHandler: CLGeocodeCompletionHandler?
 
  func geocodeAddressString(
    _ addressString: String,
    completionHandler:
    @escaping CLGeocodeCompletionHandler) { 
      geocodeAddressString = addressString
      self.completionHandler = completionHandler
  }
}</pre></li>
				<li>In the <a id="_idIndexMarker425"/>test, we want to call the <code>geocodeAddressString(_:completionHandler:)</code> method and pass a <code>CLPlacemark</code> instance into the completion handler. To create a <code>CLPlacemark</code> instance in a test, we need to import the <code>Intents</code> and <code>Contacts</code> frameworks, because the initializer we need is defined in the <code>Intents</code> framework and uses classes from the <code>Contacts</code> framework (I got this tip from the <em class="italic">StackOverflow</em> answer fo<a href="https://stackoverflow.com/a/52932708/498796">und at https://stackoverflow.com/a/52932708</a>/498796):<pre>// APIClientTests.<a id="_idTextAnchor462"/><a id="_idTextAnchor463"/>swift
import Intents
import Contacts</pre></li>
				<li>Now, we can start with writing the tests. Add the following fragment of a test to <code>APIClientTests</code>:<pre>// APIClientTests.<a id="_idTextAnchor464"/><a id="_idTextAnchor465"/>swift
func test_coordinate_fetchesCoordinate() {
  let geoCoderMock = GeoCoderProtocolMock()
  sut.geoCoder = geoCoderMock
}</pre></li>
			</ol>
			<p>Xcode tells <a id="_idIndexMarker426"/>us that we need to add a property for the <code>geoCoder</code> property to <code>APIClient</code>.</p>
			<ol>
				<li value="6">Go to the <code>APIClient</code> class and add the following property:<pre>// APIClient<a id="_idTextAnchor466"/><a id="_idTextAnchor467"/>.swift
lazy var geoCoder: GeoCoderProtocol
  = CLGeocoder()</pre></li>
			</ol>
			<p>The <code>lazy</code> keyword means that the initializer is called the first time the property is accessed.</p>
			<ol>
				<li value="7">Go back to the test and make it look like this:<pre>// APIClientTests<a id="_idTextAnchor468"/><a id="_idTextAnchor469"/>.swift
func test_coordinate_fetchesCoordinate() {
  let geoCoderMock = GeoCoderProtocolMock()
  sut.geoCoder = geoCoderMock
  let location = CLLocation(latitude: 1,
    longitude: 2)
  let placemark = CLPlacemark(location: location,
    name: nil,
    postalAddress: nil)
  let expectedAddress = "dummy address"
  var result: Coordinate?
  sut.coordinate(for: expectedAddress) { coordinate in
    result = coordinate
  }
  geoCoderMock.completionHandler?([placemark], nil)
  XCTAssertEqual(geoCoderMock.geocodeAddressString,
    expectedAddress)
  XCTAssertEqual(result?.latitude,
    location.coordinate.latitude)
  XCTAssertEqual(result?.longitude,
    location.coordinate.longitude)
}</pre></li>
			</ol>
			<p>After we <a id="_idIndexMarker427"/>have set up the <code>geoCoderMock</code> instance, we create dummy variables and call the method we want to test. The <code>GeoCoderProtocolMock</code> class captures the completion handler of the <code>geocodeAddressString(_:complectionHandler:)</code> call. This allows us to call this completion handler with a placemark we created. In the test assertions, we check whether the method was called with the address string we provided and whether the coordinate was passed into the <code>completion</code> closure of the <code>coordinate(for:completion:)</code> method.</p>
			<ol>
				<li value="8">Replace the implementation of <code>coordinate(for:completion:)</code> in <code>APIClient</code> with the following implementation:<pre>// APIClient.swift
func coordinate<a id="_idTextAnchor470"/><a id="_idTextAnchor471"/>(
  for address: String,
  completion: (Coordinate?) -&gt; <a id="_idTextAnchor472"/><a id="_idTextAnchor473"/>Void) {
    geoCoder.geocodeAddressString(
      address) { placemarks, error in
      }
}</pre></li>
			</ol>
			<p>Note that we added an internal name for the address string parameter.</p>
			<p>Run the tests. The new test still fails, but the first assertion doesn't fail anymore. This tells <a id="_idIndexMarker428"/>us that our test does too much. We should split this test into two tests: one that checks whether the method is called with the address string we provide, and another one that checks that the coordinate is passed into the completion closure.</p>
			<ol>
				<li value="9">We should always only have one failing test, so add <code>x_</code> in front of the method name of <code>test_coordinate_fetchesCoordinate</code>:<pre>// APIClientTests.swift
func x_test_coordinate_fetchesCoordinate() {
  // …</pre></li>
			</ol>
			<p>As the test runner searches for methods beginning with the word <code>test</code>, adding <code>x_</code> hides the method from the test runner. To confirm that this is true, run all tests again.</p>
			<ol>
				<li value="10">Now, add the following test method to <code>APIClientTests</code>:<pre> // APIClientTes<a id="_idTextAnchor474"/><a id="_idTextAnchor475"/>ts.swift
func test_coordinate_shouldCallGeoCoderWithAddress() {
  let geoCoderMock = GeoCoderProtocolMock()
  sut.geoCoder = geoCoderMock
  let expectedAddress = "dummy address"
  sut.coordinate(for: expectedAddress) { _ in
  }
  XCTAssertEqual(geoCoderMock.geocodeAddressString,
    expectedAddress)
}</pre></li>
				<li>Remove the code we added to <code>coordinate(for:completion:)</code> in <code>APIClient</code> and run the tests to see this new test fail.</li>
				<li>Add the <a id="_idIndexMarker429"/>code again and run the tests. All tests should pass now.</li>
				<li>Now, we can remove the check for the address string from <code>test_coordinate_fetchesCoordinate()</code> because it is now asserted in <code>test_coordinate_shouldCallGeoCoderWithAddress()</code>:<pre>// APIClientTe<a id="_idTextAnchor476"/><a id="_idTextAnchor477"/>sts.swift
func test_coordinate_fetchesCoordinate() {
  let geoCoderMock = GeoCoderProtocolMock()
  sut.geoCoder = geoCoderMock
  let location = CLLocation(latitude: 1,
    longitude: 2)
  let placemark = CLPlacemark(location: location,
    name: nil,
    postalAddress: nil)
  var result: Coordinate?
  sut.coordinate(for: "") { coordinate in
    result = coordinate
  }
  geoCoderMock.completionHandler?([placemark], nil)
  XCTAssertEqual(result?.latitude,
    location.coordinate.latitude)
  XCTAssertEqual(result?.longitude,
    location.coordinate.longitude)
}</pre></li>
			</ol>
			<p>Run all tests to see this test fail.</p>
			<ol>
				<li value="14">To make <a id="_idIndexMarker430"/>this test pass, we need to get the coordinate from the <code>CLGeoCoder</code> instance and pass it into the completion handler. Replace the <code>coordinate(for:completion:)</code> method with the following implementation:<pre>// APICl<a id="_idTextAnchor478"/><a id="_idTextAnchor479"/>ient.swift
func coordinate(
  for address: String,
  completion: @escaping (Coordinate?) -&gt; Void) {
    geoCoder.geocodeAddressString(address) { 
      placemarks, error in
      guard let clCoordinate =
        placemarks?.first?.location?.coordinate
      else {
        completion(nil)
        return
      }
      let coordinate = Coordinate(
        latitude: clCoordinate.latitude,
        longitude: clCoordinate.longitude)
      completion(coordinate)
    }
  }</pre></li>
			</ol>
			<p>Now, Xcode <a id="_idIndexMarker431"/>complains that <code>@escaping</code> keyword to the <code>completion</code> parameter in the <code>APIClientProtocol</code> protocol.</p>
			<ol>
				<li value="15">Replace the <code>APIClientProtocol</code> definition with the following:<pre>// APIClient.swift
protocol APIClientProtocol {
  func coordinate(
    for: String,
    completion: @escaping (Coordinate?) -&gt; Void)
}</pre></li>
				<li>Run all tests to confirm that now all tests pass.</li>
			</ol>
			<p>With this implementation, our app can now fetch the coordinate of an address string. This feature enables our users to add a location to a to-do item.</p>
			<p>In the next section, we will implement fetching to-do items from a server. We don't need an actual server to write the tests and the implementation for this feature. This is one of the many advantages of test-driven development.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor480"/>Testing async/await code that communicates with URLSession</h1>
			<p>In 2021, Apple introduced async/await in Swift. With async/await, asynchronous code (for example, fetching information from a server) is easier to write and easier to understand. In this section, we will learn how to implement fetching data from a web server <a id="_idIndexMarker432"/>using the async/await APIs of the <code>URLSession</code> class; and we will do this, of course, using test-driven development.</p>
			<p>Unit tests <a id="_idIndexMarker433"/>need to be fast and repeatable. This means we don't want to rely on a connection to a real server in our unit tests. Instead, we will replace the communication with the server with a mock object. </p>
			<p>Follow these steps to implement fetching to-do items from a server:</p>
			<ol>
				<li value="1">In the test, we will use a mock object of a <code>URLSession</code> class instead of the real <code>URLSession</code> instance. To be able to replace the real <code>URLSession</code> instance with the mock, we need a protocol that defines the interface we want to replace.</li>
				<li>Add the following protocol definition to <code>APIClient.swift</code>:<pre>// AP<a id="_idTextAnchor481"/><a id="_idTextAnchor482"/>IClient.swift
protocol URLSessionProtocol {
  func data(for request: URLRequest,
    delegate: URLSessionTaskDelegate?)
  async throws -&gt; (Data, URLResponse)
}</pre></li>
				<li>Next, we need to tell the compiler that the <code>URLSession</code> class already conforms to this protocol. Add the following code to <code>APIClient.swift</code>:<pre>// AP<a id="_idTextAnchor483"/><a id="_idTextAnchor484"/>IClient.swift
extension URLSession: URLSessionProtocol {}</pre></li>
				<li>Select <a id="_idIndexMarker434"/>the <code>URLSessionProtocolMock</code>. Replace its contents with the following:<pre>// URLSessionProtoclMock.swift
im<a id="_idTextAnchor487"/><a id="_idTextAnchor488"/>port Foundation
@testabl<a id="_idTextAnchor489"/><a id="_idTextAnchor490"/>e import ToDo
 
class URLSessionProtocolMock: URLSessionProtocol { 
  var dataForDelegateReturnValue: (Data, URLResponse)?
  var dataForDelegateRequest: URLRequest?
 
  func data(for request: URLRequest,
    delegate: URLSessionTaskDelegate?)
  async throws -&gt; (Data, URLResponse) {
 
    dataForDelegateRequest = request
 
    guard let dataForDelegateReturnValue =
      dataForDelegateReturnValue else {
        fatalError()
        }
    return dataForDelegateReturnValue
  }
}</pre></li>
			</ol>
			<p>This mock object allows us to define the return value of <code>data(for:delegate:)</code> in the test we are going to write.</p>
			<ol>
				<li value="5">With <a id="_idIndexMarker436"/>this preparation, we <a id="_idIndexMarker437"/>can start writing the test. Add the following fragment of the test method to <code>APIClientTests</code>:<pre>// API<a id="_idTextAnchor491"/><a id="_idTextAnchor492"/>ClientTests.swift
func test_toDoItems_shouldFetcheItems() async throws {
  let url = try XCTUnwrap
    (URL(string: "http://toodoo.app/items"))
  let urlSessionMock = URLSessionProtocolMock()
  let expected = [ToDoItem(title: "dummy title")]
  urlSessionMock.dataForDelegateReturnValue = (
    try JSONEncoder().encode(expected),
    HTTPURLResponse(url: url,
      statusCode: 200,
      httpVers<a id="_idTextAnchor493"/><a id="_idTextAnchor494"/>ion: "HTTP/1.1",
      headerFields: nil)!
  )
  sut.session = urlSessionMock
}</pre></li>
			</ol>
			<p>In this code, we define the URL and the data to be used in the mock response. The <code>urlSessionMock</code> class returns a JSON object with one <code>ToDoItem</code> object and an <code>HTTPURLResponse</code> instance with the expected URL and the status code <code>200</code>.</p>
			<p>We have to pause writing the test because the system under test (the <code>APIClient</code> class) doesn't have a <code>session</code> property yet.</p>
			<ol>
				<li value="6">Go to <code>APIClient</code> and add the property like this:<pre>/<a id="_idTextAnchor495"/><a id="_idTextAnchor496"/>/ APIClient.swift
lazy var session: URLSessionProtocol
= URLSession.shared</pre></li>
				<li>Switch <a id="_idIndexMarker438"/>back to the <a id="_idIndexMarker439"/>test class and add the call to fetch the to-do items:<pre>// APIClientTests.swift
<a id="_idTextAnchor497"/><a id="_idTextAnchor498"/>func test_toDoItems_shouldFetcheItems() async throws {
  let url = try XCTUnwrap
    (URL(string: "http://toodoo.app/items"))
  let urlSessionMock = URLSessionProtocolMock()
  let expected = [ToDoItem(title: "dummy title")]
  urlSessionMock.dataForDelegateReturnValue = (
    try JSONEncoder().encode(expected),
    HTTPURLResponse(url: url,
      statusCode: 200,
      httpVersion: "HTTP/1.1",
      headerFields: nil)!
  )
  sut.sessio<a id="_idTextAnchor499"/><a id="_idTextAnchor500"/>n = urlSessionMock
  let items = try await sut.toDoItems()
}</pre></li>
			</ol>
			<p>Again, we have to pause because this method is not defined yet.</p>
			<ol>
				<li value="8">Go to <code>APIClient</code> and add the minimal implementation to make the test compile:<a id="_idTextAnchor501"/><a id="_idTextAnchor502"/><pre>// APIClient.swift
func toDoItems() async throws -&gt; [ToDoItem] {
  return []
}</pre></li>
				<li>Finally, we <a id="_idIndexMarker440"/>can finish <a id="_idIndexMarker441"/>the test. Add the assertion call as shown in this code snippet:<pre>// APIClientTests.swift
func test_toDoItems_shouldFetcheItems() async throws {
  let url = try XCTUnwrap
    (URL(string: "http://toodoo.app/items"))
  let urlSessionMock = URLSessionProtocolMock()
  let expected = [ToDoItem(title: "dummy title")]
  urlSessionMock.dataForDelegateReturnValue = (
    try JSONEncoder().encode(expected),
    HTTPURLResponse(url: url,
      statusCode: 200,
      httpVersion: "HTTP/1.1",
      headerFields: nil)!
  )
  sut.session = urlSessionMock
  let items = try awa<a id="_idTextAnchor503"/><a id="_idTextAnchor504"/>it sut.toDoItems()
  XCTAssertEqual(items, expected)
}</pre></li>
			</ol>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="10">To make <a id="_idIndexMarker442"/>the test <a id="_idIndexMarker443"/>pass, replace the <code>toDoItems</code> method in the <code>APIClient</code> class with the following c<a id="_idTextAnchor505"/><a id="_idTextAnchor506"/>ode:<pre>// APIClient.swift
func toDoItems() async throws -&gt; [ToDoItem] {
  guard let url =
    URL(string: "dummy")
  else {
    return []
  }
  let request = URLRequest(url: url)
  let (data, _) = try await session.data(
    for: request,
      delegate: nil)
  let items = try JSONDecoder()
    .decode([ToDoItem].self, from: data)
  return items
}</pre></li>
			</ol>
			<p>In this code, we define the URL, create a request, call <code>data(for:delegate:)</code> on the session property, and try to decode the result into an array of <code>ToDoItems</code>.</p>
			<p>Run the tests to confirm that this code makes the tests pass.</p>
			<p>But, there is something strange with this code. The URL is wrong. We need to expand the test to also check for the used URL.</p>
			<ol>
				<li value="11">Add <a id="_idIndexMarker444"/>the following <a id="_idIndexMarker445"/>assert function call to the end of <code>test_doToItems_shouldFetchesItems<a id="_idTextAnchor507"/><a id="_idTextAnchor508"/></code>:<pre>// APIClientTests.swift
XCTAssertEqual(urlSessionMock.dataForDelegateRequest,
  URLRequest(url: url))</pre></li>
			</ol>
			<p>Run the tests to confirm that the test now fails because we used the wrong URL in the implementation.</p>
			<ol>
				<li value="12">To make the test pass, replace the URL initialization in the <code>toDoItems</code> method with this implement<a id="_idTextAnchor509"/><a id="_idTextAnchor510"/>ation:<pre>// APIClient.swift
guard let url =
  URL(string: "http://toodoo.app/items")
else {
  return []
}</pre></li>
			</ol>
			<p>Run the tests to confirm that now all tests pass.</p>
			<p>Of course, this implementation is just an example to get you started testing network calls. In a real app, you would add authorization to the network calls to ensure that users can only access their to-do items and not the ones of other users.</p>
			<p>Fetching data from a web service can go wrong. In the following section, we will test whether the error from the <code>URLSession</code> instance is passed down to the caller of <code>toDoItems</code>.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor511"/>Handling errors</h1>
			<p>To test the <a id="_idIndexMarker446"/>handling of errors in the <code>URLSession</code> call to the web service, we first need to enhance <code>URLSessionProtocolMock</code>. Follow these steps to test that an error in fetching data is passed down to the caller of the <code>APIClient</code> instance:</p>
			<ol>
				<li value="1">Add the following property to <code>URLSessionProtocolMock</code>:<pre>// UR<a id="_idTextAnchor512"/><a id="_idTextAnchor513"/>LSessionProtocolMock.swift
var dataForDelegateError: Error?</pre></li>
				<li>Next, add the following handling of the error to the start of <code>data(for:delegate:)</code>:<pre>// UR<a id="_idTextAnchor514"/><a id="_idTextAnchor515"/>LSessionProtocolMock.swift
if let error = dataForDelegateError {
  throw error
}</pre></li>
			</ol>
			<p>If there is an error set to the <code>dataForDelegateError</code> property, we throw it before we do anything else in this method.</p>
			<ol>
				<li value="3">Now, we are ready to add the test method to <code>APIClientTest<a id="_idTextAnchor516"/><a id="_idTextAnchor517"/>s</code>:<pre>// APIClientTests.swift
func test_toDoItems_whenError_shouldPassError() async
 throws {
  let urlSessionMock = URLSessionProtocolMock()
  let expected = NSError(domain: "", code: 1234)
  urlSessionMock.dataForDelegateError = expected
  sut.session = urlSessionMock
  do {
    _ = try await sut.toDoItems()
    XCTFail()
  } catch {
    let nsError = try XCTUnwrap(error as NSError)
    XCTAssertEqual(nsError, expected)
  }
}</pre></li>
			</ol>
			<p>In this code, we <a id="_idIndexMarker447"/>create an error and assign it to the <code>dataForDelegateError</code> property of <code>urlSessionMock</code>. Then, we call <code>sut.toDoItems()</code> within a <code>do-catch</code> block to catch the error we expect from the call. If no error is thrown from <code>toDoItems()</code> the test fails with <code>XCTFail</code>. Otherwise, we compare the error with the expected value.</p>
			<p>Run the tests. All tests pass already. This is bad. As you already learned, in test-driven development we need to see a test fail before we make it green. Otherwise, we can't be sure that the tests can fail. It's easy to write tests that always pass. So, let's make the test fail.</p>
			<ol>
				<li value="4">Change the implementation of <code>data(for:delegate:)</code> in <code>URLSessionProtocolMock</code> so that it looks like this:<pre>// URLSessionProtocolMock.swift
func data(for request: URLRequest,
  delegate: URLSessionTaskDelegate?)
async throws <a id="_idTextAnchor518"/><a id="_idTextAnchor519"/>-&gt; (Data, URLResponse) {
  throw NSError(domain: "dummy", code: 0)
  if let error = dataForDelegateError {
    throw error
  }
  dataForDelegateRequest = request
  guard let dataForDelegateReturnValue =
          dataForDelegateReturnValue else {
            fatalError()
          }
  return dataForDelegateReturnValue
}</pre></li>
			</ol>
			<p>Run the tests <a id="_idIndexMarker448"/>again to confirm that with this change, the new test fails.</p>
			<ol>
				<li value="5">Remove the <code>throw NSError(domain: "dummy", code: 0)</code> line again and run the tests to see all tests pass again.</li>
			</ol>
			<p>With this test, we have confirmed that an error in fetching the data from the web service is passed down to the caller of <code>toDoItems()</code>.</p>
			<p>But what happens when the data from the web service is not in the format we expect? What should happen in this case? Follow these steps to add a test for this case:</p>
			<ol>
				<li value="1">Add the following test method to <code>APIClientTe<a id="_idTextAnchor520"/><a id="_idTextAnchor521"/>sts</code>:<pre>/<a id="_idTextAnchor522"/><a id="_idTextAnchor523"/>/ APIClientTests.swift
func
 test_toDoItems_whenJSONIsWrong_shouldFetcheItems()
 async throws {
  let url = try XCTUnwrap(URL(string: "foo"))
  let urlSessionMock = URLSessionProtocolMock()
  urlSessionMock.dataForDelegateReturnValue = (
    try JSONEncoder().encode("dummy"),
    HTTPURLResponse(url: url,
      statusCode: 200,
      httpVersion: "HTTP/1.1",
      headerFields: nil)!
  )
  sut.session = urlSessionMock
  do {
    _ = try await sut.toDoItems()
    XCTFail()
  } catch {
    XCTAssertTrue(error is Swift.DecodingError)
  }
}</pre></li>
			</ol>
			<p>The data <a id="_idIndexMarker449"/>we return here when <code>toDoItems</code> of <code>urlSessionMock</code> is called is a JSON object of the <code>dummy</code> string. Trying to decode this into an array of <code>ToDoItem</code> objects should result in an error of the <code>Swift.DecodingError</code> type. This is what the last assertion in the test asserts.</p>
			<ol>
				<li value="2">Run the tests. Again, all tests pass. And again, we need to change something to see this test fail.</li>
				<li>Go to <code>APIClient</code> and replace <code>toDoItems()</code> with the following implementation:<pre>// APIClient.swift
func toDoItems() async throws -&gt; [ToDoItem] {
  guard let url =
    URL(string: "http://toodoo.app/items")
  else {
    return []
  }
  let request = URLRequest(url: url)
  let (data, _) = try await session.data(
    for: request,
      delegate: nil)
  let items = try? JSONDecoder()
    .decode([ToDoItem].self, from: data)
  return items ?? []
}</pre></li>
			</ol>
			<p>In this code, we have changed the last three lines of that method. Instead of <code>try</code>, we use <code>try?</code> when we try to decode the data from the web service. When the data <a id="_idIndexMarker450"/>cannot be decoded into an array of <code>ToDoItem</code>s, the result is optional and no error is thrown. As a result, we also need to change the <code>return</code> value. When the value of the <code>items</code> property is <code>nil</code>, we return an <code>empty</code> array.</p>
			<p>Run the tests. The test we added last now fails and we have confirmed that it actually can fail.</p>
			<ol>
				<li value="4">Change the implementation of <code>toDoItems()</code> to what it was before:<pre>// APIClient.swift
func toDoItems() async throws -&gt; [ToDoItem] {
  guard let url =
    URL(string: "http://toodoo.app/items")
  else {
    return []
  }
  let request = URLRequest(url: url)
  let (data, _) = try await session.data(
    for: request,
      delegate: nil)
  let items = try JSONDecoder()
    .decode([ToDoItem].self, from: data)
  return items
}</pre></li>
			</ol>
			<p>Run the tests again to see all tests pass again.</p>
			<p>There are many <a id="_idIndexMarker451"/>more tests to write for the implementation of this web service call. For example, you should also write tests for cases when the web service answers with an HTTP status code other than <code>200</code>. These tests are left as an exercise for you. Add tests for this API call until you are confident that this feature does not break unnoticed in the future.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor524"/>Summary</h1>
			<p>In this chapter, we have learned how to write tests for calls to <code>CLGeoCoder</code> and how to test the async/await REST API calls of <code>URLSession</code>. We have seen what we need to do in the test method to test whether an error is thrown in an async/await call. In addition, we have learned how to make our network code tests independent from the implementation of server infrastructure. This way we made our tests fast and robust.</p>
			<p>You can use the skills gained in this chapter to write tests for the complete network layer of your apps. But you don't have to stop there. The strategies we've covered in this chapter also help to write tests for all kinds of async/await APIs.</p>
			<p>In the next chapter, we will put all the code that we wrote up to now together, and finally see the app running on the simulator.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor525"/>Exercises</h1>
			<ol>
				<li value="1">We have deactivated a test method using the <code>x_</code> prefix to hide it from the test runner. There are other ways to deactivate a single test. Do some research on the internet to figure these out.</li>
				<li>In this chapter, we wrote tests for the async/await API of <code>URLSession</code>. But, <code>URLSession</code> also provides an API that uses the delegate pattern and one that uses Combine. Do some research on the internet to find out how to write unit tests for these APIs. Make sure that these tests also run when there is no connection to the server.</li>
			</ol>
		</div>
	</body></html>