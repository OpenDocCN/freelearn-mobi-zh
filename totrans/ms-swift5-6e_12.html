<html><head></head><body>
  <div id="_idContainer077">
    <h1 class="chapterNumber">12</h1>
    <h1 id="_idParaDest-219" class="chapterTitle">Error Handling and Availability</h1>
    <p class="normal">When I first started writing applications with Objective-C, one of the most noticeable deficiencies was the lack of exception handling. Most modern programming languages, such as Java and C#, use <code class="Code-In-Text--PACKT-">try...catch</code> blocks, or something similar, for exception handling. While Objective-C did have the <code class="Code-In-Text--PACKT-">try...catch</code> block, it wasn't used within the Cocoa framework itself, and it never really felt like a true part of the language. I have significant experience in C, so I was able to understand how Apple's frameworks received and responded to errors. To be honest, I sometimes preferred this method, even though I had grown accustomed to exception handling with Java and C#. When Swift was first introduced, I was hoping that Apple would put true error handling into the language so that we would have the option of using it; however, it was not in the initial release of Swift. It wasn't until Swift 2 was released that Apple added error handling to Swift. While this kind of error handling may look similar to exception handling in Java and C#, there are some very significant differences.</p>
    <p class="normal">We will cover the following topics in this chapter:</p>
    <ul>
      <li class="bullet">How to represent errors</li>
      <li class="bullet">How to use the <code class="Code-In-Text--PACKT-">do-catch</code> block in Swift </li>
      <li class="bullet">How to use the <code class="Code-In-Text--PACKT-">defer</code> statement </li>
      <li class="bullet">How to use the availability attribute</li>
    </ul>
    <p class="normal">Let's get started!</p>
    <h1 id="_idParaDest-220" class="title">Native error handling</h1>
    <p class="normal">Languages such as Java <a id="_idIndexMarker519"/>and C# generally refer to the error handling process as exception handling. Within the Swift documentation, Apple refers to this process as error handling. While on the outside, Java and C# exception handling may look somewhat similar to Swift's error handling, there are some significant differences that those familiar with exception handling in other languages will notice throughout this chapter.</p>
    <h2 id="_idParaDest-221" class="title">Representing errors</h2>
    <p class="normal">Before we can really understand how error handling works in Swift, we must see how we can represent an <a id="_idIndexMarker520"/>error. In Swift, errors are represented by values of types that conform to the <code class="Code-In-Text--PACKT-">Error</code> protocol. Swift's enumerations are very well suited to modeling error conditions because we generally have a finite number of error conditions to represent.</p>
    <p class="normal">Let's look at how we would use an enumeration to represent an error. For this, we will define a fictitious error named <code class="Code-In-Text--PACKT-">MyError</code> with three error conditions, <code class="Code-In-Text--PACKT-">Minor</code>, <code class="Code-In-Text--PACKT-">Bad</code>, and <code class="Code-In-Text--PACKT-">Terrible</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span><span class="hljs-class"> </span><span class="hljs-title">MyError</span><span class="hljs-class">: </span><span class="hljs-title">Error</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">case</span> <span class="hljs-type">Minor</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Bad</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Terrible</span>
}
</code></pre>
    <p class="normal">In this example, we defined that the <code class="Code-In-Text--PACKT-">MyError</code> enumeration conforms to the <code class="Code-In-Text--PACKT-">Error</code> protocol and also defined three error conditions: <code class="Code-In-Text--PACKT-">Minor</code>, <code class="Code-In-Text--PACKT-">Bad</code>, and <code class="Code-In-Text--PACKT-">Terrible</code>. That is all there is to defining basic error conditions.</p>
    <p class="normal">We can also use the associated values with our error conditions to add more details about the error condition. Let's say that we want to add a description to the <code class="Code-In-Text--PACKT-">Terrible</code> error condition. We would do so like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span><span class="hljs-class"> </span><span class="hljs-title">MyError</span><span class="hljs-class">: </span><span class="hljs-title">Error</span><span class="hljs-class"> </span>{ 
    <span class="hljs-keyword">case</span> <span class="hljs-type">Minor</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Bad</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Terrible</span>(description:<span class="hljs-type">String</span>)
}
</code></pre>
    <p class="normal">Those who are familiar with exception handling in Java and C# can see that representing errors in Swift is a lot cleaner and easier, because we do not need to create a lot of boilerplate code or a full class. With Swift, it can be as simple as defining an enumeration with our error conditions. Another advantage is that it is very easy to define multiple error conditions and group them together so that all the related error conditions are of one type.</p>
    <p class="normal">Now, let's learn how to model errors in Swift. For this example, we'll look at how we would assign numbers to players on a baseball team. For a baseball team, every new player who is called up is assigned a unique number. This number must also be within a certain range, because only two numbers fit on a baseball jersey.</p>
    <p class="normal">Therefore, we would have three error conditions: the number is too large, the number is too small, and the number is not unique. The following example shows how we might represent these error conditions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span><span class="hljs-class"> </span><span class="hljs-title">PlayerNumberError</span><span class="hljs-class">: </span><span class="hljs-title">Error</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberTooHigh</span>(description: <span class="hljs-type">String</span>) 
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberTooLow</span>(description: <span class="hljs-type">String</span>) 
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberAlreadyAssigned</span>
}
</code></pre>
    <p class="normal">With the <code class="Code-In-Text--PACKT-">PlayerNumberError</code> type, we define three very specific error conditions that tell us exactly what <a id="_idIndexMarker521"/>went wrong. These error conditions are also grouped together in one type since they are all related to assigning the players' numbers.</p>
    <p class="normal">This method of defining errors allows us to define very specific errors that let our code know exactly what went wrong if an error condition occurs. It also lets us group the errors so that all related errors can be defined in the same type.</p>
    <p class="normal">Now that we know how to represent errors, let's look at how to throw errors.</p>
    <h2 id="_idParaDest-222" class="title">Throwing errors</h2>
    <p class="normal">When an error <a id="_idIndexMarker522"/>occurs in a function, the code that called the function must be made <a id="_idIndexMarker523"/>aware of it; this is called <strong class="keyword">throwing an error</strong>. When a function throws an error, it assumes that the code that called the function, or some code further up the chain, will catch and recover appropriately from the error.</p>
    <p class="normal">To throw an error from a function, we use the <code class="Code-In-Text--PACKT-">throws</code> keyword. This keyword lets the code that called it know that an error may be thrown from the function. Unlike exception handling in other languages, we do not list the specific error types that may be thrown.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Since we do not list the specific error types that may be thrown from a function within the function's definition, it would be good practice to list them in the documentation and comments for the function. This allows other developers who use the function to know what error types to catch.</p>
    </div>
    <p class="normal">Soon, we will look at how to throw errors. But first, let's add a fourth error to the <code class="Code-In-Text--PACKT-">PlayerNumberError</code> type that we defined earlier. This demonstrates how easy it is to add error conditions to our error types. This error condition is thrown if we are trying to retrieve a player by their number, but no player has been assigned that number.</p>
    <p class="normal">The new <code class="Code-In-Text--PACKT-">PlayerNumberError</code> type will now look similar to this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">enum</span><span class="hljs-class"> </span><span class="hljs-title">PlayerNumberError</span><span class="hljs-class">: </span><span class="hljs-title">Error</span><span class="hljs-class"> </span>{
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberTooHigh</span>(description: <span class="hljs-type">String</span>) 
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberTooLow</span>(description: <span class="hljs-type">String</span>) 
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberAlreadyAssigned</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">NumberDoesNotExist</span>
}
</code></pre>
    <p class="normal">To demonstrate how to throw errors, let's create a <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure that will contain a list of players for a given team. These players will be stored in a dictionary object named <code class="Code-In-Text--PACKT-">players</code>. We will use the player's number as the key because we know that each player must have a unique number. The <code class="Code-In-Text--PACKT-">BaseballPlayer</code> type, which will be used to represent a single player, will be a <code class="Code-In-Text--PACKT-">typealias</code> for a tuple type, and is defined like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">typealias</span> <span class="hljs-type">BaseballPlayer</span> = (firstName: <span class="hljs-type">String</span>, lastName: <span class="hljs-type">String</span>, number: <span class="hljs-type">Int</span>)
</code></pre>
    <p class="normal">In this <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure, we will have two methods. The first one will be named <code class="Code-In-Text--PACKT-">addPlayer()</code>. This method <a id="_idIndexMarker524"/>will accept one parameter of the <code class="Code-In-Text--PACKT-">BaseballPlayer</code> type and attempt to add the player to the team. This method can also throw one of three error conditions: <code class="Code-In-Text--PACKT-">NumberTooHigh</code>, <code class="Code-In-Text--PACKT-">NumberTooLow</code>, or <code class="Code-In-Text--PACKT-">NumberAlreadyExists</code>. Here is how we would write this method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">addPlayer</span><span class="hljs-params">(player: BaseballPlayer)</span> <span class="hljs-keyword">throws</span> { 
    <span class="hljs-keyword">guard</span> player.number &lt; maxNumber <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooHigh</span>(description: <span class="hljs-string">"Max         number is \(maxNumber)"</span>)
    }
    <span class="hljs-keyword">guard</span> player.number &gt; minNumber <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooLow</span>(description: <span class="hljs-string">"Min number         is \(minNumber)"</span>)
    }
    <span class="hljs-keyword">guard</span> players[player.number] == <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberAlreadyAssigned</span>
    }
    players[player.number] = player
}
</code></pre>
    <p class="normal">We can see that the <code class="Code-In-Text--PACKT-">throws</code> keyword is added to the method's definition. The <code class="Code-In-Text--PACKT-">throws</code> keyword lets any code that calls this method know that it may throw an error and that the error must be handled. We then use the three <code class="Code-In-Text--PACKT-">guard</code> statements to verify that the number is not too large, not too small, and is unique in the <code class="Code-In-Text--PACKT-">players</code> dictionary. If any of these conditions are not met, we throw the appropriate error using the <code class="Code-In-Text--PACKT-">throw</code> keyword. If we make it through all three checks, the player is then added to the <code class="Code-In-Text--PACKT-">players</code> dictionary.</p>
    <p class="normal">The second method that we will be adding to the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure is the <code class="Code-In-Text--PACKT-">getPlayerByNumber()</code> method. This method will attempt to retrieve the baseball player that has been assigned a given number. If no player is assigned that number, this method will throw a <code class="Code-In-Text--PACKT-">NumberDoesNotExist</code> error. The <code class="Code-In-Text--PACKT-">getPlayerByNumber()</code> method will look similar to this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">getPlayerByNumber</span><span class="hljs-params">(number: Int)</span> <span class="hljs-keyword">throws</span> -&gt; <span class="hljs-type">BaseballPlayer</span> { 
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> player = players[number] {
        <span class="hljs-keyword">return</span> player
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">throw</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberDoesNotExist</span>
    }
}
</code></pre>
    <p class="normal">We have <a id="_idIndexMarker525"/>added the <code class="Code-In-Text--PACKT-">throws</code> keyword to this method definition as well; however, this method also has a return type. When we use the <code class="Code-In-Text--PACKT-">throws</code> keyword with a return type, it must be placed before the return type in the method's definition.</p>
    <p class="normal">Within the method, we attempt to retrieve the baseball player with the number that is passed into the method. If we can retrieve the player, we return it; otherwise, we throw the <code class="Code-In-Text--PACKT-">NumberDoesNotExist</code> error. Note that if we throw an error from a method that has a return type, a return value is not required.</p>
    <p class="normal">Now, let's learn how to catch an error with Swift.</p>
    <h1 id="_idParaDest-223" class="title">Catching errors</h1>
    <p class="normal">When an error is thrown from a function, we need to catch it in the code that called it; this is done <a id="_idIndexMarker526"/>using the <code class="Code-In-Text--PACKT-">do-catch</code> block. We use the <code class="Code-In-Text--PACKT-">try</code> keyword, within the <code class="Code-In-Text--PACKT-">do-catch</code> block, to identify the places in the code that may throw an error. The <code class="Code-In-Text--PACKT-">do-catch</code> block with a <code class="Code-In-Text--PACKT-">try</code> statement has the following syntax:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">try</span> [<span class="hljs-type">Some</span> function that <span class="hljs-keyword">throws</span>]
<span class="hljs-keyword">    </span>[<span class="hljs-type">Code</span> <span class="hljs-keyword">if</span> no error was thrown]
} <span class="hljs-keyword">catch</span> [pattern] {
    [<span class="hljs-type">Code</span> <span class="hljs-keyword">if</span> function threw error]
}
</code></pre>
    <p class="normal">If an error is thrown, it is propagated out until it is handled by a <code class="Code-In-Text--PACKT-">catch</code> clause. The <code class="Code-In-Text--PACKT-">catch</code> clause consists of the <code class="Code-In-Text--PACKT-">catch</code> keyword, followed by a pattern to match the error against. If the error matches the pattern, the code within the <code class="Code-In-Text--PACKT-">catch</code> block is executed.</p>
    <p class="normal">Let's look at how to use the <code class="Code-In-Text--PACKT-">do-catch</code> block by calling both the <code class="Code-In-Text--PACKT-">getPlayerByNumber()</code> and <code class="Code-In-Text--PACKT-">addPlayer()</code> methods of the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure. Let's look at the <code class="Code-In-Text--PACKT-">getPlayerByNumber()</code> method first, since it only throws one error condition:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> player = <span class="hljs-keyword">try</span> myTeam.getPlayerByNumber(number: <span class="hljs-number">34</span>) 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Player is \(player.firstName) \(player.lastName)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberDoesNotExist</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"No player has that number"</span>)
}
</code></pre>
    <p class="normal">Within this example, the <code class="Code-In-Text--PACKT-">do-catch</code> block calls the <code class="Code-In-Text--PACKT-">getPlayerByNumber()</code> method of the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure. This method will throw the <code class="Code-In-Text--PACKT-">NumberDoesNotExist</code> error condition if no player on the team has been assigned this number; therefore, we attempt to match this error in the <code class="Code-In-Text--PACKT-">catch</code> statement.</p>
    <p class="normal">Any time an error is thrown within a <code class="Code-In-Text--PACKT-">do-catch</code> block, the remainder of the code within the block is skipped and the code within the <code class="Code-In-Text--PACKT-">catch</code> block that matches the error is executed. Therefore, in our example, if the <code class="Code-In-Text--PACKT-">NumberDoesNotExist</code> error is thrown by the <code class="Code-In-Text--PACKT-">getPlayerByNumber()</code> method, the first <code class="Code-In-Text--PACKT-">print</code> statement is never reached.</p>
    <p class="normal">We do not have to include a pattern after the <code class="Code-In-Text--PACKT-">catch</code> statement. If a pattern is not included after the <code class="Code-In-Text--PACKT-">catch</code> statement, or if we put in an underscore, the <code class="Code-In-Text--PACKT-">catch</code> statement will match all the error conditions. For example, either one of the following two <code class="Code-In-Text--PACKT-">catch</code> statements will catch all errors:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
<span class="hljs-comment">    // our statements</span>
} <span class="hljs-keyword">catch</span> {
<span class="hljs-comment">    // our error conditions</span>
}
<span class="hljs-keyword">do</span> {
<span class="hljs-comment">    // our statements</span>
} <span class="hljs-keyword">catch</span> <span class="hljs-number">_</span> {
<span class="hljs-comment">    // our error conditions</span>
}
</code></pre>
    <p class="normal">If we want to capture the error, we can use the <code class="Code-In-Text--PACKT-">let</code> keyword, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
<span class="hljs-comment">    // our statements</span>
} <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error:\(error)"</span>)
}
</code></pre>
    <p class="normal">Now, let's look at how to use the <code class="Code-In-Text--PACKT-">catch</code> statement, similar to a <code class="Code-In-Text--PACKT-">switch</code> statement, to catch different <a id="_idIndexMarker527"/>error conditions. To do this, we will call the <code class="Code-In-Text--PACKT-">addPlayer()</code> method of the <code class="Code-In-Text--PACKT-">BaseballTeam</code> structure:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">try</span> myTeam.addPlayer(player:(<span class="hljs-string">"David"</span>, <span class="hljs-string">"Ortiz"</span>, <span class="hljs-number">34</span>))
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooHigh</span>(<span class="hljs-keyword">let</span> description) { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooLow</span>(<span class="hljs-keyword">let</span> description) { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberAlreadyAssigned</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Number already assigned"</span>)
}
</code></pre>
    <p class="normal">In this example, we have three <code class="Code-In-Text--PACKT-">catch</code> statements. Each <code class="Code-In-Text--PACKT-">catch</code> statement has a different pattern to match; therefore, they will each match a different error condition. As you may recall, the <code class="Code-In-Text--PACKT-">NumberTooHigh</code> and <code class="Code-In-Text--PACKT-">NumberToLow</code> error conditions have associated values. To retrieve the associated values, we use the <code class="Code-In-Text--PACKT-">let</code> statement within parentheses, as shown in the preceding example.</p>
    <p class="normal">It is always good practice to make your last <code class="Code-In-Text--PACKT-">catch</code> statement an empty <code class="Code-In-Text--PACKT-">catch</code> statement so that it will catch any errors that did not match any of the patterns in the previous <code class="Code-In-Text--PACKT-">catch</code> statements. Therefore, the previous example should be rewritten like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">try</span> myTeam.addPlayer(player:(<span class="hljs-string">"David"</span>, <span class="hljs-string">"Ortiz"</span>, <span class="hljs-number">34</span>))
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooHigh</span>(<span class="hljs-keyword">let</span> description) { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooLow</span>(<span class="hljs-keyword">let</span> description) {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberAlreadyAssigned</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Number already assigned"</span>)
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Unknown Error"</span>)
}
</code></pre>
    <p class="normal">We can also let the errors propagate out rather than immediately catching them. To do this, we just need to add the <code class="Code-In-Text--PACKT-">throws</code> keyword to the function definition. For instance, in the following <a id="_idIndexMarker528"/>example, rather than catching the error, we could let it propagate out to the code that called the function, like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">myFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> {
    <span class="hljs-keyword">try</span> myTeam.addPlayer(player:(<span class="hljs-string">"David"</span>, <span class="hljs-string">"Ortiz"</span>, <span class="hljs-number">34</span>))
}
</code></pre>
    <p class="normal">If we are certain that an error will not be thrown, we can call the function using a forced-try expression, which is written as <code class="Code-In-Text--PACKT-">try!</code>. The forced-try expression disables error propagation and wraps the function call in a runtime assertion so no error will be thrown from this call. If an error is thrown, you will get a runtime error, so be very careful when using this expression.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">It is highly recommended that you avoid using the forced-try expression in production code since it can cause a runtime error and cause your application to crash.</p>
    </div>
    <p class="normal">When I work with exceptions in languages such as Java and C#, I see a lot of empty <code class="Code-In-Text--PACKT-">catch</code> blocks. This is where we need to catch the exception, because one might be thrown; however, we do not want to do anything with it. In Swift, the code would look something like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">let</span> player = <span class="hljs-keyword">try</span> myTeam.getPlayerByNumber(number: <span class="hljs-number">34</span>) 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Player is \(player.firstName) \(player.lastName)"</span>)
} <span class="hljs-keyword">catch</span> {}
</code></pre>
    <p class="normal">Code like this is one of the things that I dislike about exception handling. Well, the Swift developers have an answer for this: <code class="Code-In-Text--PACKT-">try?</code>. This attempts to perform an operation that may throw an error and converts it into an optional value; therefore, the result of the operation will be either <code class="Code-In-Text--PACKT-">nil</code> if an error is thrown, or the result of the operation if no error is thrown.</p>
    <p class="normal">Since the results of <code class="Code-In-Text--PACKT-">try?</code> are returned in the form of an optional, we would normally use this with optional binding. We could rewrite the previous example like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> player = <span class="hljs-keyword">try</span>? myTeam.getPlayerByNumber(number: <span class="hljs-number">34</span>) { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Player is \(player.firstName) \(player.lastName)"</span>)
}
</code></pre>
    <p class="normal">As we can see, this <a id="_idIndexMarker529"/>makes our code much cleaner and easier to read.</p>
    <p class="normal">If we need to perform a cleanup action, regardless of whether we had any errors, we can use a <code class="Code-In-Text--PACKT-">defer</code> statement. We use <code class="Code-In-Text--PACKT-">defer</code> statements to execute a block of code just before the code execution leaves the current scope. The following example shows how we can use the <code class="Code-In-Text--PACKT-">defer</code> statement:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">deferFunction</span><span class="hljs-params">()</span>{ 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Function started"</span>) 
    <span class="hljs-keyword">var</span> str: <span class="hljs-type">String?</span>
    <span class="hljs-keyword">defer</span> {
        <span class="hljs-built_i">print</span>(<span class="hljs-string">"In defer block"</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> s = str {
            <span class="hljs-built_i">print</span>(<span class="hljs-string">"str is \(s)"</span>)
        }
    }
    str = <span class="hljs-string">"Jon"</span>
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Function finished"</span>)
}
</code></pre>
    <p class="normal">If we called this function, the first line to be printed to the console would be <code class="Code-In-Text--PACKT-">Function started</code>. The code's execution would skip over the <code class="Code-In-Text--PACKT-">defer</code> block, and <code class="Code-In-Text--PACKT-">Function finished</code> would then be printed to the console. Finally, the <code class="Code-In-Text--PACKT-">defer</code> block of code would be executed just before we leave the function's scope, and we would see the <code class="Code-In-Text--PACKT-">In defer block</code> message. The following is the output of this function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Function</span> started
<span class="hljs-type">Function</span> finished
<span class="hljs-type">In</span> <span class="hljs-keyword">defer</span> block
str <span class="hljs-keyword">is</span> <span class="hljs-type">Jon</span>
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">defer</code> block will always be called before the execution leaves the current scope, even if an error is thrown. The <code class="Code-In-Text--PACKT-">defer</code> statement is very useful when we want to make sure we perform all <a id="_idIndexMarker530"/>the necessary cleanup, even if an error is thrown. For example, if we successfully open a file to write to, we will always want to make sure we close that file, even if we encounter an error during the write operation.</p>
    <p class="normal">In this case, we could put the file-closed functionality in a <code class="Code-In-Text--PACKT-">defer</code> block to make sure that the file is always closed prior to leaving the current scope.</p>
    <h1 id="_idParaDest-224" class="title">Multi-pattern catch clauses</h1>
    <p class="normal">In the previous <a id="_idIndexMarker531"/>section, we had code that looked like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">try</span> myTeam.addPlayer(player:(<span class="hljs-string">"David"</span>, <span class="hljs-string">"Ortiz"</span>, <span class="hljs-number">34</span>))
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooHigh</span>(<span class="hljs-keyword">let</span> description) { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooLow</span>(<span class="hljs-keyword">let</span> description) {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberAlreadyAssigned</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Number already assigned"</span>)
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Unknown Error"</span>)
}
</code></pre>
    <p class="normal">You will notice that the <code class="Code-In-Text--PACKT-">catch</code> clause for the <code class="Code-In-Text--PACKT-">PlayerNmberError.NumberTooHigh</code> and <code class="Code-In-Text--PACKT-">PlayerNumberError.NumberTooLow</code> errors contains duplicate code. When you are developing, it is always good to find a way to eliminate duplicate code like this. However, prior to Swift 5.3, we did not have a choice. Swift introduced multi-pattern <code class="Code-In-Text--PACKT-">catch</code> clauses with SE-0276 in Swift 5.3 to help reduce duplicate code like this. Let's take a look at this by rewriting the previous code to use a multi-pattern <code class="Code-In-Text--PACKT-">catch</code> clause:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">do</span> {
    <span class="hljs-keyword">try</span> myTeam.addPlayer(player:(<span class="hljs-string">"David"</span>, <span class="hljs-string">"Ortiz"</span>, <span class="hljs-number">34</span>))
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooHigh</span>(<span class="hljs-keyword">let</span> description), <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberTooLow</span>(<span class="hljs-keyword">let</span> description) { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: \(description)"</span>)
} <span class="hljs-keyword">catch</span> <span class="hljs-type">PlayerNumberError</span>.<span class="hljs-type">NumberAlreadyAssigned</span> { 
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Number already assigned"</span>)
} <span class="hljs-keyword">catch</span> {
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Error: Unknown Error"</span>)
}
</code></pre>
    <p class="normal">Notice that in the first <code class="Code-In-Text--PACKT-">catch</code> clause, we are now catching both the <code class="Code-In-Text--PACKT-">PlayerNmberError.NumberTooHigh</code> and <code class="Code-In-Text--PACKT-">PlayerNumberError.NumberTooLow</code> errors and that the errors are <a id="_idIndexMarker532"/>separated by a comma.</p>
    <p class="normal">Next, we'll look at how to use the new availability attribute with Swift.</p>
    <h1 id="_idParaDest-225" class="title">The availability attribute</h1>
    <p class="normal">Developing our applications for the latest <strong class="keyword">Operating System</strong> (<strong class="keyword">OS</strong>) version gives us access to all the <a id="_idIndexMarker533"/>latest features for the platform that we are developing for. However, there are times when we want to also target older platforms. Swift allows us to use the availability attribute to safely wrap code to run only when the correct version of the operating system is available. This was first introduced in Swift 2.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The availability attribute is only available when we use Swift on Apple platforms.</p>
    </div>
    <p class="normal">The availability block essentially lets us, if we are running the specified version of the operating system or higher, run this code or otherwise run some other code. There are two ways in which we can use the availability attribute. The first way allows us to execute a specific block of code that can be used with an <code class="Code-In-Text--PACKT-">if</code> or a <code class="Code-In-Text--PACKT-">guard</code> statement. The second way allows us to mark a method or type as available only on certain platforms.</p>
    <p class="normal">The availability attribute accepts up to six comma-separated arguments, which allow us to define the minimum version of the operating system or application extension needed to execute our code. These arguments are as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">iOS</code>: This is the minimum iOS version that is compatible with our code.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">OSX</code>: This is the minimum OS X version that is compatible with our code.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">watchOS</code>: This is the minimum watchOS version that is compatible with our code.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">tvOS</code>: This is the minimum tvOS version that is compatible with our code.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">iOSApplicationExtension</code>: This is the minimum iOS application extension that is compatible with our code.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">OSXApplicationExtension</code>: This is the minimum OS X application extension that is compatible with our code.</li>
    </ul>
    <p class="normal">After the argument, we specify the minimum version that is required. We only need to include the arguments that are compatible with our code. As an example, if we are writing an iOS application, we only need to include the iOS argument in the availability attribute. We end <a id="_idIndexMarker534"/>the argument list with an <code class="Code-In-Text--PACKT-">*</code> (asterisk) as it is a placeholder for future versions. Let's look at how we would execute a specific block of code only if we met the minimum requirements:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> #available(iOS <span class="hljs-number">9.0</span>, <span class="hljs-type">OSX</span> <span class="hljs-number">10.10</span>, watchOS <span class="hljs-number">2</span>, *) {
    <span class="hljs-comment">//Available for iOS 9, OSX 10.10, watchOS 2 or above</span>
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Minimum requirements met"</span>)
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//Block on anything below the above minimum requirements</span>
    <span class="hljs-built_i">print</span>(<span class="hljs-string">"Minimum requirements not met"</span>)
}
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">if #available(iOS 9.0, OSX 10.10, watchOS 2, *)</code> line of code prevents the block of code from executing when the application is run on a system that does not meet the specified minimum operating system version. In this example, we also use the <code class="Code-In-Text--PACKT-">else</code> statement to execute a separate block of code if the operating system does not meet the minimum requirements.</p>
    <p class="normal">We can also restrict access to a function or a type. In the previous code, the <code class="Code-In-Text--PACKT-">available</code> attribute <a id="_idIndexMarker535"/>was prefixed with the <code class="Code-In-Text--PACKT-">#</code> (pound, also known as <strong class="keyword">octothorpe</strong> and <strong class="keyword">hash</strong>) character. To <a id="_idIndexMarker536"/>restrict access to a function or type, we prefix the <code class="Code-In-Text--PACKT-">available</code> attribute with an <code class="Code-In-Text--PACKT-">@</code> (at) character. The following example shows how we could restrict access to a type and function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@available</span>(iOS <span class="hljs-number">9.0</span>, *)
<span class="hljs-meta">    </span><span class="hljs-keyword">func</span><span class="hljs-function"> </span><span class="hljs-title">testAvailability</span><span class="hljs-params">()</span> {
        <span class="hljs-comment">// Function only available for iOS 9 or above</span>
}
<span class="hljs-meta">@available</span>(iOS <span class="hljs-number">9.0</span>, *)
    <span class="hljs-keyword">struct</span><span class="hljs-class"> </span><span class="hljs-title">TestStruct</span><span class="hljs-class"> </span>{
        <span class="hljs-comment">// Type only available for iOS 9 or above</span>
}
</code></pre>
    <p class="normal">In the previous example, we specified that the <code class="Code-In-Text--PACKT-">testAvailability()</code> function and the <code class="Code-In-Text--PACKT-">testStruct()</code> type could only be accessed if the code was run on a device that has iOS version 9 or newer. In order to use the <code class="Code-In-Text--PACKT-">@available</code> attribute to block access to a function or type, we must wrap the code that calls that function or type with the <code class="Code-In-Text--PACKT-">#available</code> attribute.</p>
    <p class="normal">The following <a id="_idIndexMarker537"/>example shows how we could call the <code class="Code-In-Text--PACKT-">testAvailability()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> #available(iOS <span class="hljs-number">9.0</span>, *) { 
    testAvailability()
} <span class="hljs-keyword">else</span> {
<span class="hljs-comment">    // Fallback on earlier versions</span>
}
</code></pre>
    <p class="normal">In this example, the <code class="Code-In-Text--PACKT-">testAvailability()</code> function is only called if the application is running on a device that has iOS version 9 or later.</p>
    <h1 id="_idParaDest-226" class="title">Summary</h1>
    <p class="normal">In this chapter, we looked at Swift's error handling features. While we are not required to use these features in our custom types, they do give us a uniform way to handle and respond to errors. Apple has also started to use this form of error handling in their frameworks. It is recommended that we use error handling in our code.</p>
    <p class="normal">We also looked at the availability attribute, which allows us to develop applications that take advantage of the latest features of our target operating systems, while still allowing our applications to run on older versions. In the next chapter, we'll take a look at how to write custom subscripts.</p>
  </div>
</body></html>