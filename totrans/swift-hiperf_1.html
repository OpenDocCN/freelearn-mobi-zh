<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Exploring Swift's Power and Performance</h1></div></div></div><p class="calibre8">In the 2014, Apple<a id="id0" class="calibre1"/> released a new programming language, called Swift. Swift <a id="id1" class="calibre1"/>has been designed from scratch with many powerful features. It is statically typed and very safe. It has a clean and nice syntax, it's fast, it's flexible, and it has many other advantages that you will learn later in the book. Swift seems to be very powerful and it has big potential. Apple has set big expectations for Swift, and their main goal for Swift is that it should be a replacement for Objective-C, which is going to happen in the near future.</p><p class="calibre8">In this chapter, you will become familiar with the Swift programming language, what it was made for, and what its advantages and features are. We will also make our first Swift application and see how easy it is to integrate with existing Objective-C code.</p><p class="calibre8">In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Welcome to Swift</li><li class="listitem">Writing swift code</li><li class="listitem">Swift interoperability</li><li class="listitem">The importance of performance and performance key metrics</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>Swift speed</h1></div></div></div><p class="calibre8">I can guess<a id="id2" class="calibre1"/> you opened this book because you are interested in speed and are probably wondering, "How fast can Swift be?" Before you even start learning Swift and discovering all the good things about it, let's answer it right here and right now.</p><p class="calibre8">Let's take an array of 100,000 random numbers; sort it in Swift, Objective-C, and C using the standard <code class="literal">sort</code> function from <code class="literal">stdlib</code> (<code class="literal">sort</code> in Swift, <code class="literal">qsort</code> in C, and <code class="literal">compare</code> in Objective-C); and measure how much time each would take.</p><p class="calibre8">Sorting an array with 100,000 integer elements gives us this:</p><div><table border="1" class="calibre14"><colgroup class="calibre15"><col class="calibre16"/><col class="calibre16"/></colgroup><thead class="calibre17"><tr class="calibre18"><th valign="bottom" class="calibre19">
<p class="calibre20">Technology</p>
</th><th valign="bottom" class="calibre19">
<p class="calibre20">Time taken</p>
</th></tr></thead><tbody class="calibre21"><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">Swift</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.00600 sec</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">C</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.01396 sec</p>
</td></tr><tr class="calibre18"><td valign="top" class="calibre22">
<p class="calibre20">Objective-C</p>
</td><td valign="top" class="calibre22">
<p class="calibre20">0.08705 sec</p>
</td></tr></tbody></table></div><p class="calibre8">And the winner is, Swift! Swift is <strong class="calibre9">14.5</strong> times faster than Objective-C and <strong class="calibre9">2.3</strong> times faster than C.</p><p class="calibre8">In other<a id="id3" class="calibre1"/> examples and experiments, C is usually faster than Swift and Swift is way faster than Objective-C. These measurements were done with Xcode 7.0 beta 6 and Swift 2.0. It's important to highlight that the improvements in Swift 2.0 were mainly focused on making it cleaner, more powerful, safer, and more stable, and preparing it for open sourcing. Swift's performance hasn't reached its full potential yet, and the future is so exciting!</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Welcome to Swift</h1></div></div></div><p class="calibre8">The Swift<a id="id4" class="calibre1"/> programming language has been designed by Apple from the ground up. It was released with the slogan <em class="calibre10">Objective-C without the C</em>. The meaning of this phrase is that Swift doesn't have any limitation of backward compatibilities. It's totally new and with no old baggage. Before you start learning all the power of Swift, I think it would be useful to answer a few questions about why should you learn it, and if you have any doubts about that, I should dispel them.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Why should I learn Swift?</h2></div></div></div><p class="calibre8">Swift is a very new<a id="id5" class="calibre1"/> programming language but it has become very popular and has gained huge traction. However, many iOS and OS X developers ask these questions:</p><div><ul class="itemizedlist"><li class="listitem">Should I learn Swift?</li><li class="listitem">What should I learn, Swift or Objective-C?</li><li class="listitem">Is Objective-C going to stay or die?</li><li class="listitem">Is Swift ready for production apps?</li><li class="listitem">Is Swift faster than Objective-C or C?</li><li class="listitem">What applications can I write using Swift?</li></ul></div><p class="calibre8">My answer is, "Yes. Definitely!" You should learn Swift. It doesn't matter whether you are a new iOS and OS X developer or you have some Objective-C background; you should definitely learn Swift.</p><p class="calibre8">If you are new developer, then it's really useful to start with Swift, because you will learn programming basics and techniques in Swift, and further Swift learning would be much easier. Although it would definitely useful to learn Objective-C as well, I would recommend learning Swift first so that you build your programming mindset on Swift.</p><p class="calibre8">If you already have some experience in Objective-C, then you should try Swift as soon as possible. It will not only give you the knowledge of a new programming language, but also open the door to<a id="id6" class="calibre1"/> new ideas and ways of solving problems in Objective-C. We can see that Objective-C has started evolving right now because of Swift.</p><p class="calibre8">Objective-C has many limitations because of its backward capabilities with C. It was created 23 years ago, in 1983, but it will die much sooner than Swift.</p><p class="calibre8">After the release of Swift version 1.0, in only a year's time we have seen many Swift applications successfully developed and released on the App Store. In this time period, many Swift tools and open source libraries that increase development productivity have been created.</p><p class="calibre8">During WWDC 2015, Apple announced that Swift will be made open source. This means that Swift can be used to write any software and not only iOS or OS X apps. You can write a piece of server-side code or web app in Swift. This is one more reason you should learn it.</p><p class="calibre8">On the other hand, we see that Swift is under constant development. There were many changes and improvements in version 1.2, and there were even more changes in version 2.0. Although it's very easy to upgrade to the newer Swift version with the Xcode migrator, it's something you should think about.</p><p class="calibre8">Swift has some promising performance characteristics. We have seen a huge performance improvement in the Swift 1.2 release, and some improvements in Swift 2.0 as well. You have seen from the previous example how fast Swift is, and in general, Swift has more potential to achieve high performance than Objective-C.</p><p class="calibre8">Finally, I want to mention a phrase I really like, by Bryan Irace:</p><div><blockquote class="blockquote1"><p class="calibre23"><em class="calibre10">When the iOS SDK says "Jump", ask "How High?"</em></p></blockquote></div><p class="calibre8">Don't wait, learn Swift!</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Swift's features and benefits</h1></div></div></div><p class="calibre8">At this point, you <a id="id7" class="calibre1"/>know that you should learn Swift, and you shouldn't have any <a id="id8" class="calibre1"/>doubts. Let's take a look what makes Swift so amazing and <a id="id9" class="calibre1"/>powerful. Here is a list of a few important features that we are going to cover:</p><div><ul class="itemizedlist"><li class="listitem">Clean and beautiful syntax</li><li class="listitem">Type-safe</li><li class="listitem">Reach types system</li><li class="listitem">Powerful value types</li><li class="listitem">A multiparadigm language—object-oriented, protocol-oriented, and functional</li><li class="listitem">Generic<a id="id10" class="calibre1"/> purpose</li><li class="listitem">Fast</li><li class="listitem">Safe</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec08" class="calibre1"/>Clean and beautiful</h2></div></div></div><p class="calibre8">Powerful features <a id="id11" class="calibre1"/>and performance are important, but I think that cleanness and beauty are no less important. You write and read code everyday, and it has to be clean and beautiful so that you can enjoy it. Swift is very clean and beautiful, and the following are the main features that make it so.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>No semicolons</h3></div></div></div><p class="calibre8">Semicolons were<a id="id12" class="calibre1"/> created for the compiler. They help the compiler understand the source code and split it into commands and instructions. But the source code is written for people, and we should probably get rid of the compiler instructions from it:</p><div><pre class="programlisting">var number = 10
number + 5

// Not recommended
var count = 1;
var age = 18; age++</pre></div><p class="calibre8">There is no need for a semicolon (;) at the end of every instruction. It may seem like a very small feature, but it makes code so much nicer and easier to write and read. You can, however, put semicolons if you want. A semicolon is required when you have two instructions on the same line. There are also some exceptions when you have to use semicolons, a <code class="literal">for</code> loop as an example (<code class="literal">for var i = 0; i &lt; 10; i++</code>), but in that context, they are used for a different purpose.</p><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">I strongly recommend not using semicolons, and avoid using more than one instruction in the same line.</p></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Type inference</h3></div></div></div><p class="calibre8">With type<a id="id13" class="calibre1"/> inference, you don't need to specify the types of variables and <a id="id14" class="calibre1"/>constants. Swift automatically detects the correct type from the context. Sometimes, however, you have to specify the type explicitly and provide type annotation. When there is no value assigned to the variable, Swift can't predict what type that variable should be:</p><div><pre class="programlisting">var count = 10            //count: Int
var name = "Sara"         //name: String
var empty = name.isEmpty   //empty: Bool

// Not recommended
var count: Int = 10
var name: String = "Sara"
var empty: Bool = name.isEmpty

// When you must provide type annotation
var count: Int
var name: String

count = 10
name = "Sara"</pre></div><p class="calibre8">In most cases, Swift <a id="id15" class="calibre1"/>can understand a variable's type from the value assigned to it.</p><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">Don't use type <a id="id16" class="calibre1"/>annotation if it's not required. Giving your variables descriptive names should be enough. This makes your code clean and nice to read.</p></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Other clean code Swift features</h3></div></div></div><p class="calibre8">The list of all of Swift's clean code features is very long; here are few of them: closure syntax, functions' default parameter values, functions' external parameter names, default initializers, subscripts, and operators:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Clean closure syntax</strong>: A <a id="id17" class="calibre1"/>closure is a standalone block of code that can be treated as a light unnamed function. It has the same functionality as a function but has a cleaner syntax. You can assign it to a variable, call it, or pass it as an argument to a function. For example, <code class="literal">{ $0 + 10 }</code> is a closure:<div><pre class="programlisting">let add10 = { $0 + 10 }
add10(5)

let numbers = [1, 2, 3, 4]
numbers.map { $0 + 10 }
numbers.map(add10)</pre></div></li><li class="listitem"><strong class="calibre9">Default parameter values and external names</strong>: While declaring a function, you can define <a id="id18" class="calibre1"/>default values for parameters and give them different external names, which are used when you call that function. With default parameters, you can define one function but <a id="id19" class="calibre1"/>call it with different arguments. This reduces the need for creating unnecessary functions:<div><pre class="programlisting">func complexFunc (x: Int, _ y: Int = 0, extraNumber z: Int = 0, name: String = "default") -&gt; String{
    return  "\(name): \(x) + \(y) + \(z) = \(x + y + z)"
}

complexFunc(10)
complexFunc(10, 11)
complexFunc(10, 11, extraNumber: 20, name: "name")</pre></div></li><li class="listitem"><strong class="calibre9">Default and memberwise initializers</strong>: Swift can create initializers for struct and base classes<a id="id20" class="calibre1"/> in some scenarios for you. Less code, better code:<div><pre class="programlisting">struct Person {
    let name: String
    let lastName: String
    let age: Int
}

Person(name: "Jon", lastName: "Bosh", age: 23)</pre></div></li><li class="listitem"><strong class="calibre9">Subscripts</strong>: This is<a id="id21" class="calibre1"/> a nice way of accessing the<a id="id22" class="calibre1"/> member elements of a collection. You can use any type as a key:<div><pre class="programlisting">let numbers = [1, 2, 3, 4]
let num2 = numbers[2]

let population = [
  "China" : 1_370_940_000,
  "Australia" : 23_830_900
]
population["Australia"]</pre></div><p class="calibre24">You can also define a subscript operator for your own types or extend existing types by adding own subscript operator to them in an extension:</p><div><pre class="programlisting">// Custom subscript
struct Stack {
  private var items: [Int]
  
  subscript (index: Int) -&gt; Int {
    return items[index]
  }

  // Stack standard functions
  mutating func push(item: Int) {
    items.append(item)
  }
  
  mutating func pop() -&gt; Int {
    return items.removeLast()
  }
}

var stack = Stack(items: [10, 2])
stack.push(6)
stack[2]
stack.pop()</pre></div></li><li class="listitem"><strong class="calibre9">Operators</strong>: These<a id="id23" class="calibre1"/> are symbols that represent<a id="id24" class="calibre1"/> functionality, for example, the <code class="literal">+</code> operator. You can extend your types to support standard operators or create your own custom operators:<div><pre class="programlisting">let numbers = [10, 20]
let array = [1, 2, 3]
let res = array + numbers

struct Vector {
  let x: Int
  let y: Int
}

func + (lhs: Vector, rhs: Vector) -&gt; Vector {
  return Vector(x: lhs.x + rhs.x, y: lhs.y + rhs.y);
}

let a = Vector(x: 10, y: 5)
let b = Vector(x: 2, y: 3)

let c = a + b</pre></div><div><h3 class="title2"><a id="tip04" class="calibre1"/>Tip</h3><p class="calibre8">Define your custom operators carefully. They can make code cleaner, but they can also bring much more complexity into the code and make it hard to understand.</p></div></li><li class="listitem"><strong class="calibre9">guard</strong>: The <code class="literal">guard</code> statement is used to check whether a condition is met before continuing to execute the code. If the condition isn't met, it must<a id="id25" class="calibre1"/> exit the scope. The <code class="literal">guard</code> statement removes nested conditional statements and the Pyramid of Doom problem:<div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">Read more about the<a id="id26" class="calibre1"/> Pyramid of Doom at <a class="calibre1" href="https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)">https://en.wikipedia.org/wiki/Pyramid_of_doom_(programming)</a>.</p></div><div><pre class="programlisting">func doItGuard(x: Int?, y: Int) {
  guard let x = x else { return }
  //handle x 
  print(x)
    
  guard y &gt; 10 else { return }
  //handle y
  print(y)
 }</pre></div></li></ul></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>A clean code summary</h3></div></div></div><p class="calibre8">As you can see, Swift is <a id="id27" class="calibre1"/>very clean and nice. The best way to show how clean and beautiful Swift is is by trying to implement the same functionality in Swift and Objective-C.</p><p class="calibre8">Let's say we have a list of people and we need to find the people with a certain age criteria and make their names lowercase.</p><p class="calibre8">This is what the Swift version of this code will look like:</p><div><pre class="programlisting">struct Person {
  let name: String
  let age: Int
}

let people = [
  Person(name: "Sam", age: 10),
  Person(name: "Sara", age: 24),
  Person(name: "Ola", age: 42),
  Person(name: "Jon", age: 19)
]

let kids = people.filter { person in person.age &lt; 18 }
let names = people.map { $0.name.lowercaseString }</pre></div><p class="calibre8">The following is<a id="id28" class="calibre1"/> what the Objective-C version of this code will look like:</p><div><pre class="programlisting">
<strong class="calibre9">//Person.h File</strong>
@import Foundation;

@interface Person : NSObject

@property (nonatomic) NSString *name;
@property (nonatomic) NSInteger age;

- (instancetype)initWithName:(NSString *)name age:(NSInteger)age;

@end

<strong class="calibre9">//Person.m File</strong>
#import "Person.h"

@implementation Person

- (instancetype)initWithName:(NSString *)name age:(NSInteger)age {
  self = [super init];
  if (!self) return nil;

  _name = name;
  _age = age;

  return self;
}

@end

NSArray *people = @[
    [[Person alloc] initWithName:@"Sam" age:10],
    [[Person alloc] initWithName:@"Sara" age:24],
    [[Person alloc] initWithName:@"Ola" age:42],
    [[Person alloc] initWithName:@"Jon" age:19]
];

NSArray *kids = [people filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@"age &lt; 18"]];

NSMutableArray *names = [NSMutableArray new];
for (Person *person in people) {
  [names addObject:person.name.lowercaseString];
}</pre></div><p class="calibre8">The results are<a id="id29" class="calibre1"/> quite astonishing. The Swift code has 14 lines, whereas the Objective-C code has 40 lines, with <code class="literal">.h</code> and <code class="literal">.m</code> files. Now you see the difference.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec09" class="calibre1"/>Safe</h2></div></div></div><p class="calibre8">Swift is a very safe programming language, and it does a lot of security checks at compile time. The goal is to catch as many issues as possible during compiling and not when you run an application.</p><p class="calibre8">Swift is a<a id="id30" class="calibre1"/> type-safe programming language. If you made any mistakes with a type, such as trying to add an <code class="literal">Int</code> and a <code class="literal">String</code> or passing the wrong argument to a function, you will get an error:</p><div><pre class="programlisting">let number = 10
let part = 1.5

number + part; // Error

let result = Double(number) + part</pre></div><p class="calibre8">Swift doesn't do any typecasting for you; you have to do it explicitly, and this makes Swift even safer. In this example, we had to cast an <code class="literal">Int</code> number to the <code class="literal">Double</code> type before adding it.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Optionals</h3></div></div></div><p class="calibre8">A very important<a id="id31" class="calibre1"/> safe type that was introduced in Swift is an <strong class="calibre9">optional</strong>. An <a id="id32" class="calibre1"/>optional is a way of representing the absence of a value—<code class="literal">nil</code>. You can't assign <code class="literal">nil</code> to a variable with the <code class="literal">String</code> type. Instead, you must declare that this variable can be <code class="literal">nil</code> by making it the optional <code class="literal">String?</code> type:</p><div><pre class="programlisting">var name: String = "Sara"
name = nil //Error. You can't assign nil to a non-optional type

var maybeName: String?
maybeName = "Sara"
maybeName = nil // This is allowed now</pre></div><p class="calibre8">To make a type an optional type, you must put a question mark (<code class="literal">?</code>) after the type, for example, <code class="literal">Int?</code>, <code class="literal">String?</code>, and <code class="literal">Person?</code>.</p><p class="calibre8">You can also declare an optional type using the <code class="literal">Optional</code> keyword, <code class="literal">Optional&lt;String&gt;</code>, but the shorter way with using <code class="literal">?</code> is preferred:</p><div><pre class="programlisting">var someName: Optional&lt;String&gt;</pre></div><p class="calibre8">Optionals are like<a id="id33" class="calibre1"/> a box that contains some value or nothing. Before using the value, you need to unwrap it first. This technique is called unwrapping optionals, or optional binding if you assign an unwrapped value to a constant:</p><div><pre class="programlisting">if let name = maybeName {
  var res = "Name - " + name
} else {
  print("No name")
}</pre></div><div><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">You must <a id="id34" class="calibre1"/>always check whether an optional has a value before accessing it.</p></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec06" class="calibre1"/>Error handling</h3></div></div></div><p class="calibre8">Swift 2.0 has powerful<a id="id35" class="calibre1"/> and very simple-to-use error handling. Its syntax is very similar to the exception handling syntax in other languages, but it works in a different way. It has the <code class="literal">throw</code>, <code class="literal">catch</code>, and <code class="literal">try</code> keywords. Swift error handling consists of a few components, explained as follows:</p><div><ul class="itemizedlist"><li class="listitem">An error object represents an error, and it must conform to the <code class="literal">ErrorType</code> protocol:<div><pre class="programlisting">enum MyErrors: ErrorType {
  case NotFound 
  case BadInstruction
}</pre></div><div><h3 class="title2"><a id="tip06" class="calibre1"/>Tip</h3><p class="calibre8">Swift enumerations fit best for representing a group of related error objects.</p></div></li><li class="listitem">Every function that can throw an error must be declared using the <code class="literal">throws</code> keyword after its parameters' list:<div><pre class="programlisting">func dangerous(x: Int) throws
func dangerousIncrease(x: Int) throws -&gt; Int</pre></div></li><li class="listitem">To throw an error, use the <code class="literal">throw</code> keyword:<div><pre class="programlisting">throw MyErrors.BadInstruction</pre></div></li><li class="listitem">When you are calling a function that can throw an error, you must use the <code class="literal">try</code> keyword. This indicates that a function can fail and further code will not be executed:<div><pre class="programlisting">  try dangerous(10)</pre></div></li><li class="listitem">If an error occurs, it must be caught and handled with the <code class="literal">do</code> and <code class="literal">try</code> keywords or thrown further by declaring that function <a id="id36" class="calibre1"/>with <code class="literal">throws</code>:<div><pre class="programlisting">do {
  try dangerous(10)
}
catch {
  print("error")
}</pre></div></li></ul></div><p class="calibre8">Let's take a look at a code example that shows how to work with exceptions in Swift:</p><div><pre class="programlisting">enum Error: ErrorType {
  case NotNumber(String)
  case Empty
}

func increase(x: String) throws -&gt; String {
  if x.isEmpty {
    throw Error.Empty
  }
  
  guard let num = Int(x) else {
    throw Error.NotNumber(x)
  }
  
  return String(num + 1)
}

do {
  try increase("10")
  try increase("Hi")
}
catch Error.Empty {
  print("Empty")
}
catch Error.NotNumber (let string) {
  print("\"\(string)\" is not a number")
}
catch {
  print(error)
}</pre></div><p class="calibre8">There are many other safety features in Swift:</p><div><ul class="itemizedlist"><li class="listitem">Memory safety ensures that values are initialized before use.</li><li class="listitem">Two-phase initialization process with security checks</li><li class="listitem">Required method overriding and many others</li></ul></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec10" class="calibre1"/>Rich type system</h2></div></div></div><p class="calibre8">Swift has the following <a id="id37" class="calibre1"/>powerful types:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Structures</strong> are flexible building blocks that can hold data and methods to manipulate that<a id="id38" class="calibre1"/> data. Structures are very similar to classes but<a id="id39" class="calibre1"/> they are value type:<div><pre class="programlisting">struct Person {
  let name: String
  let lastName: String

  func fullName() -&gt; String {
    return name + " " + lastName
  }
}

let sara = Person(name: "Sara", lastName: "Johan")
sara.fullName()</pre></div></li><li class="listitem"><strong class="calibre9">Tuples</strong> are a way of <a id="id40" class="calibre1"/>grouping multiple values into one type. Values inside a tuple can have different types. Tuples are very useful for returning multiple<a id="id41" class="calibre1"/> values from a function. You can access values inside a tuple by either index or name if the tuple has named elements; or you can assign each item in the tuple to a constant or a variable:<div><pre class="programlisting">let numbers = (1, 5.5)
numbers.0
numbers.1

let result: (code: Int, message: String) = (404, "Not fount")
result.code
result.message

let (code ,message) = (404, "Not fount")</pre></div></li><li class="listitem"><strong class="calibre9">Range</strong> represents a range of numbers from <em class="calibre10">x</em> to <em class="calibre10">y</em>. There are also two range operators that help <a id="id42" class="calibre1"/>create<a id="id43" class="calibre1"/> ranges: closed range operator and half-open<a id="id44" class="calibre1"/> range <a id="id45" class="calibre1"/>operator:<div><pre class="programlisting">let range = Range(start: 0, end: 100)
let ten = 1...10 //Closed range, include last value 10
let nine = 0..&lt;10 //half-open, not include 10</pre></div></li><li class="listitem"><strong class="calibre9">Enumeration</strong> represents a group of common related values. An enumeration's member <a id="id46" class="calibre1"/>can be empty, have a raw value, or have an associated value of any type. Enumerations are first-class types; they can have methods, computed properties, initializer, and other features. They are great for type-safe coding:<div><pre class="programlisting">enum Action: String {
  case TakePhoto
  case SendEmail
  case Delete
}

let sendEmail = Action.SendEmail
sendEmail.rawValue //"SendEmail"

let delete = Action(rawValue: "Delete")</pre></div></li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec11" class="calibre1"/>Powerful value types</h2></div></div></div><p class="calibre8">There are two <a id="id47" class="calibre1"/>very powerful value types in Swift: <code class="literal">struct</code> and <code class="literal">enum</code>. Almost all types in the Swift standard library are implemented as immutable value types using <code class="literal">struct</code> or <code class="literal">enum</code>, for example, <code class="literal">Range</code>, <code class="literal">String</code>, <code class="literal">Array</code>, <code class="literal">Int</code>, <code class="literal">Dictionary</code>, <code class="literal">Optionals</code>, and others.</p><p class="calibre8">Value types have<a id="id48" class="calibre1"/> four big advantages over reference types, they are:</p><div><ul class="itemizedlist"><li class="listitem">Immutable</li><li class="listitem">Thread safe</li><li class="listitem">Single owned</li><li class="listitem">Allocated on the stack memory</li></ul></div><p class="calibre8">Value types are immutable and only have a single owner. The value data is copied on assignment and when passing it as an argument to a function:</p><div><pre class="programlisting">var str = "Hello"
var str2 = str

str += " :)"</pre></div><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">Swift is smart enough to perform value copying only if the value is mutated. Value copying doesn't happen on an assignment, that is <code class="literal">str2 = str</code>, but on value mutation, that is <code class="literal">str += ":)"</code>. If you remove that line of code, <code class="literal">str</code> and <code class="literal">str2</code> would share the same immutable data.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec12" class="calibre1"/>A multiparadigm language</h2></div></div></div><p class="calibre8">Swift is a multiparadigm <a id="id49" class="calibre1"/>programming language. It supports many different programming styles, such as object-oriented, protocol-oriented, functional, generic, block-structured, imperative, and declarative programming. Let's take a look at a<a id="id50" class="calibre1"/> few of them in more detail here.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec07" class="calibre1"/>Object oriented</h3></div></div></div><p class="calibre8">Swift supports the<a id="id51" class="calibre1"/> object-oriented programming style. It has classes with the single inheritance model, the ability to conform to protocols, access control, nested types and initializers, properties with observers, and other features of OOP.</p></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec08" class="calibre1"/>Protocol oriented</h3></div></div></div><p class="calibre8">The concept of protocols<a id="id52" class="calibre1"/> and protocol-oriented programming is not new, but Swift protocols have some powerful features that make them special. The general idea of protocol-oriented programming is to use protocols instead of types. In this way, we can create a very flexible system with weak binding to concrete types.</p><p class="calibre8">In Swift, you can extend protocols and provide a method's default implementation:</p><div><pre class="programlisting">extension CollectionType {

  func findFirst (find: (Self.Generator.Element) -&gt; Bool) -&gt; Self.Generator.Element? {
    
    for x in self { 
      if find(x) {
        return x
      }
    }
    return nil
  }
}</pre></div><p class="calibre8">Now, every type that implements <code class="literal">CollectionType</code> has a <code class="literal">findFirst</code> method:</p><div><pre class="programlisting">let a = [1, 200, 400]
let r = a.findFirst { $0  &gt; 100 }</pre></div><p class="calibre8">One big advantage of using protocol-oriented programming is that we can add methods to related types and<a id="id53" class="calibre1"/> use the dot (<code class="literal">.</code>) syntax for method chaining instead of using free functions and passing arguments:</p><div><pre class="programlisting">let ar = [1, 200, 400]

//Old way
map(filter(map(ar) { $0 * 2 }) { $0 &gt; 50 }) { $0 + 10 } 

//New way
ar.map{ $0 * 2 } .filter{ $0 &gt; 50 } .map{ $0 + 10 }</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec09" class="calibre1"/>Functional</h3></div></div></div><p class="calibre8">Swift also supports the<a id="id54" class="calibre1"/> functional programming style. In functional languages, a function is a type and it is treated in the same way as other types, such as <code class="literal">Int</code>; also, it is called a<a id="id55" class="calibre1"/> <strong class="calibre9">first class function</strong>. Functions can be assigned to a variable and passed as an argument to other functions. This really helps to decouple your code and makes it more reusable.</p><p class="calibre8">A great example is a <code class="literal">filter</code> function <a id="id56" class="calibre1"/>of an array. It takes a function that performs the actual filtering logic, and it gives us so much flexibility:</p><div><pre class="programlisting">// Array filter function from Swift standard library
<strong class="calibre9">func filter(includeElement: (T) -&gt; Bool) -&gt; [T]</strong>

let numbers = [1, 2, 4]

func isEven (x: Int) -&gt; Bool {
    return x % 2 == 0
}
let res = numbers.filter(isEven)</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec10" class="calibre1"/>Generic purpose</h3></div></div></div><p class="calibre8">Swift has a very <a id="id57" class="calibre1"/>powerful feature called <strong class="calibre9">generics</strong>. Generics<a id="id58" class="calibre1"/> allow you to write generic code without mentioning a specific type that it should work with. Generics are very useful for building algorithms, reusable code, and frameworks. The best way to explain generics is by showing an example. Let's create a <code class="literal">minimum</code> function that will return a smaller value:</p><div><pre class="programlisting">func minimum(x: Int, _ y: Int) -&gt; Int {
  return (x &lt; y) ? x : y
}

minimum(10, 11)
minimum(11,5, 14.3) // error</pre></div><p class="calibre8">This function has a limitation; it will work only with integers. However, the logic of getting a smaller<a id="id59" class="calibre1"/> value is the same for all types—compare them and return the smaller value. This is <a id="id60" class="calibre1"/>very generic code.</p><p class="calibre8">Let's make our <code class="literal">minimum</code> function generic and work with different types:</p><div><pre class="programlisting">func minimum &lt;T : Comparable&gt;(x: T, _ y: T) -&gt; T {
  return (x &lt; y) ? x : y
}

minimum (10, 11)
minimum (10.5, 1.4)
minimum ("A", "ABC")</pre></div><div><h3 class="title2"><a id="tip07" class="calibre1"/>Tip</h3><p class="calibre8">The Swift standard library has already implemented a generic <code class="literal">min</code> function. Use that instead.</p></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec13" class="calibre1"/>Fast</h2></div></div></div><p class="calibre8">Swift is <a id="id61" class="calibre1"/>designed to be fast and have high performance, and this is achieved with the following techniques:</p><div><ul class="itemizedlist"><li class="listitem">Compile-time method binding</li><li class="listitem">Strong typing and compile time optimization</li><li class="listitem">Memory layout optimization</li></ul></div><p class="calibre8">Later, we will cover in more detail how Swift uses these techniques to improve performance.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Swift interoperability</h1></div></div></div><p class="calibre8">There are two <a id="id62" class="calibre1"/>main points that Apple thought of when introducing Swift:</p><div><ul class="itemizedlist"><li class="listitem">The usage of the Cocoa framework and established Cocoa patterns</li><li class="listitem">Easy to adopt and migrate</li></ul></div><p class="calibre8">Apple understood that and took it very seriously while working on Swift. They made Swift work seamlessly with Objective-C and Cocoa. You can use all Objective-C code in Swift, and you can even use Swift in Objective-C.</p><p class="calibre8">It's very crucial to be able to use the Cocoa framework. All of the code that is written in Objective-C is available for use in Swift, both Apple frameworks and third-party libraries as<a id="id63" class="calibre1"/> well.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec14" class="calibre1"/>Using Objective-C in Swift</h2></div></div></div><p class="calibre8">All the Cocoa <a id="id64" class="calibre1"/>frameworks written in Objective-C are available in Swift by default. You just need to import them and then use them. Swift doesn't have header<a id="id65" class="calibre1"/> files; instead, you need to use a module name. You can also include your own Swift frameworks in the same way:</p><div><pre class="programlisting">import Foundation
import UIKit
import Alamofire // Custom framework</pre></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec11" class="calibre1"/>Setup</h3></div></div></div><p class="calibre8">To include your <a id="id66" class="calibre1"/>own Objective-C source files, you need to do a small setup first. The process is a bit different for the application target and framework target. The main idea is the same—to import the Objective-C header files.</p><div><div><div><div><h4 class="title3"><a id="ch01lvl4sec01" class="calibre1"/>The application target</h4></div></div></div><p class="calibre8">For the application<a id="id67" class="calibre1"/> target, you need to create a bridging header. A bridging header is a plain Objective-C header file in which you specify the Objective-C <code class="literal">import</code> statements.</p><p class="calibre8">Xcode will show a popup, offering to create, and set up a bridging header for you when you add the Objective-C file to a Swift project, or vice versa for the first time. This is the best and the most convenient way to add it.</p><div><img src="img/00002.jpeg" alt="The application target" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">If you decline the Xcode help, you can create a bridging header yourself anytime. To do that, you need to follow these steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">Add a new header file to the project.</li><li class="listitem" value="2">Go to <strong class="calibre9">Target</strong> | <strong class="calibre9">Build Settings</strong>.</li><li class="listitem" value="3">Search for <code class="literal">Objective-C Bridging Header</code> and specify the path to the bridging header file created in step 1.<div><img src="img/00003.jpeg" alt="The application target" class="calibre11"/></div><p class="calibre25"> </p></li></ol><div></div><p class="calibre8">Once<strong class="calibre9"> </strong>you set up<a id="id68" class="calibre1"/> bridging header, the next step is to add <code class="literal">import</code> statements to it:</p><p class="calibre8">
<code class="literal">Bridging.h</code>
</p><div><pre class="programlisting">//
//  Use this file to import your target's public headers that you //  would like to expose to Swift.

#import "MyClass.h"</pre></div></div><div><div><div><div><h4 class="title3"><a id="ch01lvl4sec02" class="calibre1"/>The framework target</h4></div></div></div><p class="calibre8">For the framework<a id="id69" class="calibre1"/> target, you simply need to import the <code class="literal">.h</code> Objective-C header files to the framework's umbrella header. The Objective-C header files must be marked as public. The umbrella header is the header in which you specify your publicly available API. Usually, it looks like this—the <code class="literal">ExampleFramework.h</code> umbrella header:</p><div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;

//! Project version number for MySwiftKit.
FOUNDATION_EXPORT double MySwiftKitVersionNumber;

//! Project version string for MySwiftKit.
FOUNDATION_EXPORT const unsigned char MySwiftKitVersionString[];

<strong class="calibre9">// In this header, you should import all the public headers of your framework using statements like #import &lt;MySwiftKit/PublicHeader.h&gt;</strong>

#import &lt;SimpleFramework/MyClass.h&gt;</pre></div></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec12" class="calibre1"/>Calling Objective-C code</h3></div></div></div><p class="calibre8">Once you are done with the setup, you can use all Objective-C APIs in Swift. You can create instances, call methods, inherit from Objective-C classes, conform to protocols, and do other things<a id="id70" class="calibre1"/> that you can do in Objective-C. In this example, we will use the <code class="literal">Foundation</code> classes, but the rules are the same for third-party code as well:</p><div><pre class="programlisting">import UIKit
import Foundation

let date = NSDate()
date.timeIntervalSinceNow

UIColor.blackColor()
UIColor(red: 0.5, green: 1, blue: 1, alpha: 1)

class MyView: UIView {
    //custom implementation
}</pre></div><div><h3 class="title2"><a id="tip08" class="calibre1"/>Tip</h3><p class="calibre8">Inherit from Objective-C classes only if you need it. This can have a negative impact on performance.</p></div><p class="calibre8">There is free bridging between Swift types and Objective-C Foundation types. Automatic bridging happens on assignment and when you pass it as an argument to a function:</p><div><pre class="programlisting">let array = [1, 2, 3]

func takeArray(array: NSArray) { }

var objcArray: NSArray = array
takeArray(array)</pre></div><p class="calibre8">Converting from Objective-C to a Swift type requires explicit type casting. There are two types of casting: downcasting and upcasting. Casting is usually an unsafe operation, which could fail, and that's why it returns an optional type:</p><div><pre class="programlisting">//Upcasting or safe casting
let otherArray: [AnyObject] = objcArray as [AnyObject]

//Downcasting, unsafe casting
if let safeNums = objcArray as? [Int] {
  safeNums[0] + 10 //11
}

let string: NSString = "Hi"
let str: String = string as String</pre></div><p class="calibre8">The <code class="literal">String</code> type has gone one step even further. You can invoke the Objective-C foundation methods on the Swift <code class="literal">String</code> type without any type casting:</p><div><pre class="programlisting">var name: String = "Name"
name.stringByAppendingString(": Sara")</pre></div><p class="calibre8">Swift made a small<a id="id71" class="calibre1"/> improvement to Objective-C code so that it looks more Swift-style. The biggest change is made to instance creation and the style of the initialization code. The <code class="literal">init</code>, the <code class="literal">initWith</code>, and other factory methods are transformed into Swift initializers:</p><div><pre class="programlisting">//Objective-C

- (instancetype)initWithFrame:(CGRect)frame;
+ (UIColor *)colorWithWhite:(CGFloat)white alpha:(CGFloat)alpha;

// Swift 
init(frame: CGRect)
init(white: CGFloat, alpha: CGFloat)</pre></div><p class="calibre8">The other change is made to <code class="literal">NS_ENUM</code> and <code class="literal">NS_OPTIONS</code>. They become native Swift types: <code class="literal">enum</code> and <code class="literal">RawOptionSetType</code>.</p><p class="calibre8">As you can see, the API looks a bit different. Because Swift strives for cleanliness, it removes word duplications from the API nomenclature. The other method calls, properties, and names, are the same as they were in Objective-C, so it should be easy to find and understand them.</p><p class="calibre8">What is happening behind the scenes is that Swift is generating special interface files to interact with Objective-C. You can see these Swift interface files by holding down the <em class="calibre10">command</em> key and clicking on the type, <code class="literal">NSDate</code> and <code class="literal">UIColor</code> in our example.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec15" class="calibre1"/>Using Swift in Objective-C</h2></div></div></div><p class="calibre8">It is also possible to <a id="id72" class="calibre1"/>use Swift in Objective-C. It makes Swift very easy to adapt to an existing project. You can start by adding one Swift file, and move more<a id="id73" class="calibre1"/> functionality to Swift over time.</p><p class="calibre8">The setup process is much easier than that for including Objective-C in Swift. All you need to do is import Swift's autogenerated header to Objective-C. The naming convention of the files for application targets is <code class="literal">ProductModuleName + -Swift.h</code>, and for frameworks, it is <code class="literal">&lt;ProductName/ProductModuleName + -Swift.h&gt;</code>.</p><p class="calibre8">Take a look at the following examples:</p><div><pre class="programlisting">#import "SwiftApp-Swift.h"
#import &lt;MySwiftKit/MySwiftKit-Swift.h&gt;</pre></div><p class="calibre8">You can inspect the content of that autogenerated file by holding down the <em class="calibre10">command</em> key and clicking on it. By default, Swift classes aren't exposed for use in Objective-C. There are two ways of making Swift classes available in Objective-C:</p><div><ul class="itemizedlist"><li class="listitem">Mark the Swift<a id="id74" class="calibre1"/> class, protocol, or enumeration with the <code class="literal">@objc</code> attribute.<p class="calibre24">You can <a id="id75" class="calibre1"/>mark classes, methods, protocols, and enumerations with the <code class="literal">@objc</code> attribute. The <code class="literal">@objc</code> attribute also accepts the alternative name that is used for Objective-C. When you expose a Swift class by marking it with the <code class="literal">@objc</code> attribute, it has to inherit from the Objective-C class, and the enumeration must have a raw <code class="literal">Int</code> value:</p><div><pre class="programlisting">@objc(KOKPerson) class Person: NSObject {
  @objc(isMan) func man() -&gt; Bool {
    ...
  }
}
@objc enum Options: Int {
  case One
  case Two
}</pre></div><p class="calibre24">Now, the <code class="literal">KOKPerson</code> class with the <code class="literal">isMan</code> method is available for use in Objective-C.</p></li><li class="listitem">Inherit from an Objective-C class, <code class="literal">NSObject</code> for example:<p class="calibre24">When you inherit from an Objective-C class, your Swift class automatically becomes available in Objective-C. You don't need to perform any extra steps in such cases. You can also mark it with the <code class="literal">@objc</code> attribute and provide an alternative name:</p><div><pre class="programlisting">class Person: NSObject {
}</pre></div></li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec16" class="calibre1"/>Features of Swift that are not available in Objective-C</h2></div></div></div><p class="calibre8">There are some<a id="id76" class="calibre1"/> features of Swift that are not available in Objective-C, so if you plan to use Swift code from Objective-C, you should avoid using them. Here is the complete list of these features:</p><div><ul class="itemizedlist"><li class="listitem">Structures</li><li class="listitem">Generics</li><li class="listitem">Tuples</li><li class="listitem">Enumerations</li><li class="listitem">Type aliases</li><li class="listitem">Top-level functions</li><li class="listitem">Curried functions</li><li class="listitem">Global variables</li><li class="listitem">Swift-style variadic parameters</li><li class="listitem">Nested<a id="id77" class="calibre1"/> types</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Performance – meaning and key metrics</h1></div></div></div><p class="calibre8">There are two key characteristics of code:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Code quality</strong>: It has<a id="id78" class="calibre1"/> to be solid and flexible and have a good architecture</li><li class="listitem"><strong class="calibre9">Code performance</strong>: It has<a id="id79" class="calibre1"/> to be fast</li></ul></div><p class="calibre8">Making the code <a id="id80" class="calibre1"/>architecture very solid and stable is the most important task, but we shouldn't forget about making it fast as well. Achieving high performance can be a tricky and dangerous task. Here are a few things that you should keep in mind while working<a id="id81" class="calibre1"/> on performance improvement:</p><div><ul class="itemizedlist"><li class="listitem">Don't optimize your code upfront<p class="calibre24">There are many articles about this topic, why it's dangerous, and why you shouldn't do it. Just don't do it, and as Donald Knut says:</p><div><blockquote class="blockquote1"><p class="calibre23"><em class="calibre10">"Premature optimization is the root of all evil"</em></p></blockquote></div></li><li class="listitem">Measure first<p class="calibre24">Firstly, don't optimize upfront, and secondly, measure first. Measure the code's performance characteristics and optimize only those parts that are slow. Almost 95 percent of code doesn't require performance optimization.</p><p class="calibre24">I totally agree with these points, but there is another type of performance optimization that we should think of upfront.</p></li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec17" class="calibre1"/>Everyday code performance</h2></div></div></div><p class="calibre8">The small decisions<a id="id82" class="calibre1"/> that we make every day include the following:</p><div><ul class="itemizedlist"><li class="listitem">What type should it be, <code class="literal">Int</code> or <code class="literal">String</code>?</li><li class="listitem">Should I create a new class for a new functionality or add to an existing one?</li><li class="listitem">Use an array? Or maybe a set?</li></ul></div><p class="calibre8">It seems as if these don't have any impact on the application's performance, and in most cases, they don't. However, making the right decision not only improves an application's speed, but also makes it more stable. This gives higher performance in application development. The small changes that we make every day make a big impact at the end of the year.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec18" class="calibre1"/>The importance of performance</h2></div></div></div><p class="calibre8">High performance<a id="id83" class="calibre1"/> is very crucial. The performance of an app is directly related to user experience. Users want to get results immediately; they don't want to wait for the view to load, see a long <strong class="calibre9">Loading</strong> indicator, or see a lagging animation.</p><p class="calibre8">Every year, our computers and devices become more and more powerful, with more CPU speed, memory, storage, and storage speed. Performance problems could seem irrelevant because of this, but the software complexity increases as well. We have more complex data to store and process. We need to show animations and do a lot of other things.</p><p class="calibre8">The first way of solving a performance problem is by adding more power. We can add more servers to handle data, but we can't update our clients' PC and mobile devices. Also, adding more power doesn't solve the code performance issue itself, but just delays it for some time.</p><p class="calibre8">The second, and correct, solution is to remove the issue that causes the performance problem. For that, we need to identify the problem, the slow piece of the code, and improve it.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec19" class="calibre1"/>The key metrics</h2></div></div></div><p class="calibre8">There are many<a id="id84" class="calibre1"/> things that impact an application's performance and user experience. We will cover the following key metrics:</p><div><ul class="itemizedlist"><li class="listitem">Operations' performance speed</li><li class="listitem">Memory usage</li><li class="listitem">Disk space usage</li></ul></div><p class="calibre8">The most important of these and the one that has the biggest impact is the <strong class="calibre9">operations' performance speed</strong>. It<a id="id85" class="calibre1"/> tells us how fast a particular task can be performed, for example, creating a new user, reading from a file, downloading an image, searching for a person with a particular name, and so on.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Swift is a powerful and fast programming language. In this chapter, you learned about many powerful features of Swift and how easy it is to start coding in Swift and integrate it into existing projects. We also covered why performance is important and what you should be thinking about when working with it.</p><p class="calibre8">In the next chapter, we will do more coding in Swift, and you will learn how to use all the features of Swift to make a good application architecture.</p></div></body></html>