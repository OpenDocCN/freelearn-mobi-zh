- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Word Game (Part 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first part of our project, we put together a good portion of the interface
    and implemented much of the game’s functionality, so we currently have a working
    game that can list all the user’s entered words.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s continue here in the second part of the project, finishing off the settings
    screen so that the user can select the language of their choice, and adding more
    elements to the UI to help make it more polished – for example, adding user feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a settings screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling the UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing user feedback with alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a Footer View to display more information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding haptics and button sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can download the resources and finished project from the `Chapter 13` folder
    on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a settings screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can set the word length, let’s put together the settings view so
    that the user can click on the info button and actually change the language from
    there. We want to create three buttons – one for each language – and a fourth
    button, the **Done** button, which users can use to complete their selection and
    dismiss the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, inside `SettingsView`, we’ll first need a variable to access `DataModel`.
    Add this observed object variable at the top of the `SettingsView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add a title for this page called `Language Settings` in the `body`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply add the `Text` view with a little padding and bold font, all
    inside of `VStack`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s add a `Form` view and a `Section` header view inside `VStack` to
    group the buttons that we will be adding. Place this code just under the `padding`
    modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Form` view is a container that’s commonly used to group controls together,
    and the `Section` header will add some header text to each grouping. This is what
    `SettingsView` looks like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Styling the SettingsView using the Form and Section header views
    ](img/B18674_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Styling the SettingsView using the Form and Section header views'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will add buttons to let the user select a language.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the language buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The buttons we will create will be styled with a wood image background and some
    text applied to them. Let’s do the button styling in a separate struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following struct anywhere in the file, as long as it’s not inside the
    `SettingsView` struct (I usually create other structs just above the `Previews`
    struct):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We’re calling the `configureButton` struct, and inside it, we create a `string`
    variable that will hold the text for the button. Then, we’re using the background
    image in the Assets Catalog and setting its size and `cornerRadius` value. After
    that, we add a `Text` view with white color and shadow, all done inside of `ZStack`
    so that they overlay each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s proceed to add the first button, which will let the user play the game
    in the English language. Add the following code inside the `Section` header braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this code block, we added `VStack` with a center alignment and a spacing
    of 10 points. This will keep each button vertically spaced from each other by
    10 points.
  prefs: []
  type: TYPE_NORMAL
- en: Along with creating a button to select the English language, I want to add a
    flag for the chosen country’s language as well. We do this in `HStack` – the button
    will be on the left, and the flag will be on the right of the screen. Next, I
    call the `configureButton` struct in the button closure, which will set the button
    to the word **English** and give it the wood background image. For the flag, I
    added a small border around it with a 1.5-point width, so it has a nice defined
    edge, and since this is associated with the English button, we will use the American
    flag image.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can try it out; press the `ButtonStyle` protocol to control what flashes
    when the button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do that. Add the following code underneath the `configureButton` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This struct is called `ButtonFlash`, and it uses the `ButtonStyle` protocol.
    This is a protocol that applies interactive behavior and custom appearance to
    buttons. The `ButtonStyle` protocol requires that we use the `makeBody` method
    to configure the behavior and look for the button label.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we’re only calling two modifiers in the `makeBody` function – `shadow`
    and `opacity`. The `opacity` modifier will check the `isPressed` property to see
    whether it’s `true`. If it is `true`, that means the button has been pressed,
    so we can change the opacity to `.3`, which will make the button fade out slightly.
    Otherwise, if the button is not pressed, the button will remain at full opacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do next is call the `buttonFlash` structure on the button, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `buttonStyle` protocol automatically creates a new modifier for us, also
    using `buttonStyle`, which we can access like any other modifier by using dot
    syntax and then passing in the name of our new struct, `ButtonFlash`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the button has a new look. It has a shadow around its text that gives
    it a sort of 3D look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: The English language button ](img/B18674_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.2: The English language button'
  prefs: []
  type: TYPE_NORMAL
- en: When you press the button, the modifiers will help make it look like it’s actually
    being pushed down. Also, it will just look like the button is being pushed, rather
    than the whole row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with the configuring and styling of the button complete, let’s add two
    more buttons for the other languages. Add this code right after the closing brace
    of `HStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code starts with `Divider`, which is a very thin line that delineates the
    first button from the second one. Then, we use another `HStack`, similar to what
    we’ve just added for the `Divider` and then create our **Italian** button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the buttons are complete, but they don’t do anything when they’re pressed
    other than look nice. We need to make them functional and actually select the
    individual languages. This is simple – we just have to access our data model and
    change the language properties to the correct value, either `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the **English** button. Inside the body of the button, add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is accessing `DataModel` and changing `englishIsOnProperty`
    to `true` because the `false`. Now, if the **English** button is pressed, only
    that data file will be used to make a new random word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add similar logic inside the **Spanish** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For the `false`, and that the Spanish property is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let’s add the following code to the **Italian** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, all the buttons are complete, and they will implement the user’s chosen
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a checkmark
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, we can improve the design a little bit here. Currently, when the user
    presses the language buttons, there’s no indication that the button selected anything.
    How about we add a checkmark next to the flag for the selected language?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add another struct that will make checkmarks for the buttons. Add the
    following struct under the `ButtonFlash` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I’m calling the struct `addCheckmark` and then creating a Boolean to check which
    language has been selected. Inside the body of the struct, we create a small checkmark,
    color it green, and set the opacity of the checkmark to either fully visible or
    hidden, depending on whether the `isLanguageOn` property is `true` or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can call this struct inside each `HStack`, so a checkmark will be placed
    toward the flag side. For the sake of brevity, I will add the checkmark code to
    the first `HStack`, but you need to add it to all three `HStack` instances as
    well, in the same location that I use here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The code calls the `addCheckmark` struct, and a checkmark is added to each button
    when pressed.
  prefs: []
  type: TYPE_NORMAL
- en: If you now run the app from `ContentView`, you will see that you can press the
    information button to bring up the settings screen, select a language, and then
    dismiss the screen by sliding it down.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: The language buttons complete ](img/B18674_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.3: The language buttons complete'
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you stop the app and run it again, note that your selection choice
    will remain, as we store these settings internally in user defaults by using the
    `@AppStorage` property wrapper in the data model.
  prefs: []
  type: TYPE_NORMAL
- en: We’re just about done with the settings view, but I’d like to add one more modification
    here – how about giving the user another way of dismissing the settings screen
    by adding a dismiss button, instead of just sliding down from the top?
  prefs: []
  type: TYPE_NORMAL
- en: Adding a dismiss button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the dismiss button, we’ll need a property that can access the app’s environment.
    The environment is the part of the app that is generated automatically for us,
    and it’s where we can access system-wide settings such as the color scheme or
    layout direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s in this environment where we need to dismiss a screen, and to do so, we
    first need to create a variable using the `@Environment` wrapper. Add this underneath
    the `ObservedObject` property at the top of the `SettingsView` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will use this property to dismiss the view. Add this final `HStack`
    just after the closing brace of the last `HStack` in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we used two `Spacer` instances at the top and bottom of the code to
    align the button in the center of this `HStack`.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the button, the `presentationMode` property on the `wrappedValue` property
    will gain access to the setting screen data, and then a call to the `dismiss`
    function will close the settings screen.
  prefs: []
  type: TYPE_NORMAL
- en: The button is styled with a checkmark, and the text says `ButtonFlash` function
    so that it flashes like the other buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the app from `ContentView`, and you can see that the dismiss button
    works perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: The Done button ](img/B18674_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.4: The Done button'
  prefs: []
  type: TYPE_NORMAL
- en: This completes `SettingsView`. Let’s go back to `ContentView` and continue styling
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `ContentView`, let’s add some more features for the user; we’ll a background,
    some animations to the game, as well as a word count and language display label.
    Adding some more styling will help the UI come alive.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start by adding a background to the scene. We currently have a title
    and buttons that are styled with a wooden look, so let’s continue the wooden theme
    and use a wood image as a background. Add the following code after the closing
    brace of `VStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sets a wooden image as the background and uses the `edgesIgnoringSafeAreas`
    modifier to stretch the background out to fill the screen. Also, the aspect ratio
    is set to `fill`, and it sets a frame to size this background image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: A wooden background ](img/B18674_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.5: A wooden background'
  prefs: []
  type: TYPE_NORMAL
- en: 'The background looks good, but it does introduce a small problem – we need
    to change the color and size of the `wordToPlayFrom` property, as its black color
    makes it hard to see against the wood background. Let’s do that now. Just after
    the button code, we can style this `Text` view to make it look better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code adds a custom `Helvetica` font with a size of `38` points, while changing
    the color of the text to white and adding a shadow so that it stands out a little
    more. This is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: The styled base word ](img/B18674_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.6: The styled base word'
  prefs: []
  type: TYPE_NORMAL
- en: That looks much clearer now!
  prefs: []
  type: TYPE_NORMAL
- en: Adding animations to the game word
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How about we also add some animation to the new word? We can use the `scaleEffect`
    modifier to flip the word horizontally as it comes into view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first add a property to track this animation, right after the other properties
    in `ContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `WORD TO PLAY FROM` Pragma Mark, and right after the `shadow` modifier,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By calling the `scaleEffect` modifier twice, each call will flip the text horizontally
    by 180° so that it completely makes one revolution, horizontally, as it enters
    the screen. It also gets a `spring` animation applied to it, which will make it
    grow and shrink just a little bit; you can control the growth and shrinkage by
    setting the `dampingFraction` parameter to a lower or higher value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as this, we want the animation to start when the button is pressed
    because that’s when a new word appears on the screen, so let’s toggle the `horizontalFlip`
    Boolean inside the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we try it out, let’s go a bit further with the new incoming word – we’ll
    add pointing hands on each side of the new word and add a `spring` animation as
    well. Let’s put the `Text` view that is displaying `wordToPlayFrom` into `HStack`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s add some pointing hand images that will point to the word to play
    from. The first image is the system image called `hand.point.right`, and it goes
    inside `HStack` just above the `Text` view code, and the next image is called
    the `hand.point.left` image, which gets placed below the `Text` view code, again,
    all inside the `HStack` view we just added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code starts off with a system image of a hand that’s pointing right, setting
    the foreground color to black and setting the image size by using the `font` modifier.
    Then, we add the spring animation to it, which has a damping fraction of `.4`
    (again, the larger the value, the less spring animation there will be).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we go to the left-hand image and do the same thing, setting its size and
    color, as well as a little padding to position it a bit more to the left. Also,
    the `value` parameter in the `spring` animation will be the `horizontalFlip` Boolean
    property and toggled inside the button’s body, which is how the animation gets
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, give the app another go – you’ll see that every time you hit the button
    to add a new word, not only does the word flip horizontally, and stretch and shrink,
    but also the two hands bounce in and out as the word enters the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Animating the base word, plus the hand images ](img/B18674_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.7: Animating the base word, plus the hand images'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue with more enhancements, let’s fix one issue we have, which
    is that the `letterCount` string only appears on the UI when the button is pressed.
    It''s much better to always have it on the UI and just update it when the button
    is pressed. We can fix that with one line of code, a call to the `getRandomWord`
    function in `ContentView`. Let’s add that call down at the bottom of `VStack`,
    just after the `frame` modifier of the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onAppear` modifier will call the `getRandomWord` function and populate
    the `letterCount` string so that it always stays on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: The word length and flag string displayed ](img/B18674_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.8: The word length and flag string displayed'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to implement the alert system to give the user feedback about
    any words that don’t get accepted into the list.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing user feedback with alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The user can get a random word and try and make some words out of that word
    in the language of their choice, but there are certain checks that we’ve put in
    place that will stop those words from entering the list. Now, we need to let the
    user know why a certain word is not acceptable, using SwiftUI alerts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back into `DataModel` and fill out the `displayErrorMessage` function
    stub with the appropriate code to get a message alert. Add the following code
    right into the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code takes the `messageTitle` string and assigns it to the `errorTitle`
    property. Then, it takes the description string and assigns it to the `errorDescription`
    property. After that, the `errorMessagesIsShown` Boolean is set to `true` because
    at this point the function has been triggered, and we’ll need to have this property
    set to `true` in order to initiate the alert message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `displayErrorMessage` function needs to be called in the right place.
    If you remember from when we set up the `addWordToListist` method earlier and
    added the method stubs in the data model, we also made a call to the `displayErrorMessage`
    method. Here is a look at the complete `addWordToList` method that has a call
    to `displayErrorMessage`, so there is nothing for us to do there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a quick refresher on how the `addNewWord` function works.
  prefs: []
  type: TYPE_NORMAL
- en: First, the word is made lowercase – that’s because all the word files are lowercase,
    and it’s how we can compare words. Then, we trim out any whitespaces that they
    might have typed into the text field.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code guards against single-letter words – again, there is only
    a handful of those in any given language, and there’s no point in including them
    in the game here.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start to check the user’s word to see whether it’s a duplicate word.
    If it is, that means they added that word to the list already, so the `displayErrorMessage`
    function will display an error message of **You already used this word**, along
    with an instruction that says **Keep looking**.
  prefs: []
  type: TYPE_NORMAL
- en: The next `guard` statement checks whether the word is even possible to make,
    given the letters the user is working with. If it’s not possible, the `displayErrorMessage`
    function will be called and display the **This word is not possible** error, along
    with an instruction that says **Create only words from the letters in the** **given
    word**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `displayErrorMessage` function will be called if the word is not a
    real word in the chosen language, showing the user an alert that says **This is
    not a valid word**, along with an instruction that says **Use only** **real words**.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after the user’s word has been processed and gone through all those
    checks, it’s entered into `userEnteredWordsArray`. Remember, an array’s elements
    are indexed, starting from 0, which is the beginning of the array. The index is
    how we access different elements in an array, so in the `insert(at)` method, we
    pass in the “`0`” value, which means inserting the user’s word into the list at
    the beginning of the list, the top. This way, as the user enters words, they will
    always be placed at the top of the list so they are visible on the screen, and
    if there are many words, the user can scroll up through the list to see them.
  prefs: []
  type: TYPE_NORMAL
- en: The final line of code sets the user-entered word back to an empty string, ready
    to start the process again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the error alerts all set up, we just need to add the `alert`
    modifier to make it functional. We can add it right after the `onAppear` modifier
    in `ContentView`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `alert` modifier has a parameter called `isPresented`, and this will present
    an alert message when the `errorMessageIsShown` Boolean variable becomes `true`.
    When it does become `true`, the code in the alert body – this being the error
    title and description – gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try it out. Enter a word that is already in the list, and you should see
    a popup like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: An alert message for duplicate words ](img/B18674_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.9: An alert message for duplicate words'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you enter a word that is not possible given the letters you have, you will
    see this alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: An alert message for words that are not possible using the
    given word ](img/B18674_13_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.10: An alert message for words that are not possible using the given
    word'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, if you enter a word that does not exist in the chosen language’s
    dictionary, you will see this alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: An alert message for words that are not real ](img/B18674_13_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.11: An alert message for words that are not real'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have three different checks on the user’s words, just to give them feedback
    and let them know where they went wrong. The user can then press the **OK** button
    to dismiss the alert and continue playing.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now continue with the UI and add a footer view to display some more information
    about the user’s progress in the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Footer View to display more information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Footer view that we will add will contain two pieces of information – first,
    how many words the user has found so far, and second, what their letter average
    is for each found word.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, create a new `FooterView`. This will contain the `Text` views we
    need to display that information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s get to work and add some code. Add the following properties inside
    the `FooterView` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you recall, when we add a `Binding` variable to a struct, we need to include
    it in the `Previews` struct; otherwise, we will get an Xcode error. Modify the
    `Previews` struct as such to keep Xcode happy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we are now error-free, so let’s go back to the `FooterView` struct and
    review the code we just added there.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a `userEnteredWordsArray` property that we will use to bind to the `ContentView`
    struct later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a computed property called `foundWords`. A computed property is
    a property that has a body and runs code in its body when the property is accessed.
    The `foundWords` property displays how many words the user has found so far by
    using the `count` property, which will return the number of elements in `userEnteredWordsArray`.
    If there are no words in the array, it will return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, inside the `foundWords` computed property, we create a variable called
    `totalLetters` and use it to hold all the letters of the user’s word. To get all
    those letters, we use a `for in` loop to iterate through the array, storing the
    amount of letters from each word the user enters on the list back in the `totalLetters`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `foundWords` computed property returns all the letters from every
    word divided by the number of words entered, which returns the average amount
    of letters per word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go into the `body` property and start designing two text views that
    will display this information. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is style the background that the text will be placed over.
    We use the `background` image from Assets catalog and set its size to a width
    of `80` points and a height of `50` points. Then, we use the `clipShape` modifier
    to turn the rectangle into a capsule and add some shadow to the image. Note that
    we’re using the `shadow` modifier twice here – this gives the image a more defined
    border than just a single call would.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the text gets added, and by calling the `count` property on `textField`,
    we can show how many words the user has found so far. Then, we set the font size
    and add some padding and a foreground color of white.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re putting the images all inside three stacks:'
  prefs: []
  type: TYPE_NORMAL
- en: First, inside `VStack` to hold all of the views vertically on the screen and
    line them up accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, inside `HStack`, which will put the two `textField` instances we need
    side by side horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `ZStack` so that we can position the text directly over the background
    image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we add the `foundWords` image, size it up, and give it a little bit
    of shadow and some padding so that we can offset it downward from the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the other text, which will display the average amount of letters
    per word. Just after the closing bracket of the `ZStack`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code replicates the previous `Text` view we added, only this time we’re
    displaying the `foundWords` computed property, which will show the letter average
    from the `foundWords` array, and using the format specifier, it will format the
    text view to two decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can call `FooterView` inside `ContentView`. Let’s go back there and
    add a call to `FooterView` at the end of the code in the main `VStack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go ahead and try the app. Every word that you enter into the list will
    be counted on the bottom-left side of the screen, and the average amount of letters
    per word that you are getting will be displayed on the bottom-right side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: Displaying the found words and letter average ](img/B18674_13_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.12: Displaying the found words and letter average'
  prefs: []
  type: TYPE_NORMAL
- en: From the figure, we can see that the given random word is **cambering**, and
    I found 4 related words so far, so the footer view displays those **4** found
    words. The letter average for those words is also displayed, **4** letters per
    word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to more feedback, let’s just do one more check in the `addWordToList`
    function. I want to be able to stop the user from entering single-letter words,
    and that’s very easy to do. There are many single-letter words in any given language,
    so it’s not really a big deal, but we might as well prevent them anyway. Code
    inside the `addWordToList` function just after `userWord` is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We’re checking the count of `usersWord` to see whether it’s greater than 1;
    if not, we won’t allow single-letter words in the list and the function will just
    return right here. Give it a try and you’ll see that you cannot enter single-letter
    words.
  prefs: []
  type: TYPE_NORMAL
- en: Up next, in the spirit of giving the user feedback, we’ll continue and add haptics
    and audio to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding haptics and button sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haptics are a form of sensory feedback that works by accessing the internal
    vibration hardware on an iPhone, providing a physical response when the phone
    is being used. You are probably familiar with haptics, as it’s felt every time
    we set our phones to vibrate. We won’t use a full vibration but just a brief one
    that the user can feel every time they click on a button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best place to add such code is in the button itself, so let’s do that.
    We’re going to use the `UIImpactFeedbackGenerator` class for this, and it is actually
    quite simple to implement. First, inside `ContentView`, we need an instance of
    that class underneath all the properties that we already added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have set the `hapticImpact` variable style to `medium`, but you can set the
    vibration to `heavy`, `light`, `ridged`, or `soft`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to use this, we just simply call this variable inside the button like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it – every time the **New Word** button is pressed, the user will
    feel a slight vibration on their finger. In order to try this out, you actually
    have to run this on a device, as you cannot use haptics in the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ve implemented haptics here with the `ContentView` button, how about
    we also add it to the `SettingsView` language buttons? Let’s go into `SettingsView`
    and add the same code as we did here. First, create an instance of the `UIImpactFeedbackGenerator`
    class at the top of the file, in `SettingsView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in each of the three language buttons, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it – it’s very easy to implement tactile feedback for the user.
  prefs: []
  type: TYPE_NORMAL
- en: And how about one other form of feedback that we are already familiar with –
    audio? We can add a button click sound to the **New Word** button, so not only
    does the user feel the button being pressed but they also hear it.
  prefs: []
  type: TYPE_NORMAL
- en: We have already done this several times, so for the sake of brevity, I won’t
    go over the code; instead, you can simply refer back to many of the other projects
    in which we’ve added audio (such as our record player project).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we always do, we create a new `PlaySound` and add the following code to
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our sound file, all we need to do is use it inside the body
    of the **New** **Word** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: And that completes the sound.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the user has three forms of feedback when they press the **New Word** button
    – they see the button being pressed because, during the press, the button changes
    its form, they feel the impact with their finger because we accessed the internal
    vibration motor of the phone, and they hear a clicking sound. This feedback all
    comes together to give the user a more enriched and tactile experience when interacting
    with the app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we built a complete app from start to finish and included different
    animations along the way.
  prefs: []
  type: TYPE_NORMAL
- en: We organized properties and functions in a data model, created separate header
    and footer views, implemented a picker control, and created some specific functions
    that can process and check a word’s authenticity within three different languages.
    We also implemented user feedback in three different ways – in the form of pop-up
    alerts to the user, in the form of haptic feedback, and as audio. Plus, we’ve
    added three languages to the game to make it educational for users learning languages.
  prefs: []
  type: TYPE_NORMAL
- en: How about taking the gamer further by adding some more animations to it, by
    revisiting previous projects and using code that you already implemented into
    different areas of the game? For example, if the user gets a certain number of
    words in their list, they could be rewarded with points that get displayed in
    an animated label at the top. Alternatively, we could add another button that
    will ask the user to find only words that are palindromes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build another game – this time, a color-matching
    game.
  prefs: []
  type: TYPE_NORMAL
