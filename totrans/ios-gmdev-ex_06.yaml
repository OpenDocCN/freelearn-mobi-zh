- en: Chapter 6. Animating Sprites, Controls, and SceneKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about physics engine in detail. We discussed
    `SKPhysicsBody`, that is, edge-based and volume-based physics bodies. We also
    got to know about the various initialization methods and physics properties, which
    helped us in integrating physics into our *Platformer* game. Now we have a much
    clear idea about how to simulate physics in a Sprite Kit game.
  prefs: []
  type: TYPE_NORMAL
- en: It is always good to have nice animated features in our game to enhance the
    user experience; this Sprite Kit has the `SKAction` class, which helps us to apply
    actions on nodes such as moving of nodes, rotating of nodes, scaling of nodes,
    and so on. For example, using animations during player movement or depicting collisions
    using animations, and so on. It's time for us to discuss about the `SKAction`
    class and also about implementing animations in our *Platformer* game.
  prefs: []
  type: TYPE_NORMAL
- en: Along with animation, we are also going to discuss about how we can provide
    controls in our game, such as having a reaction when the user taps on the screen
    or using the accelerometer to respond to directions in a game. We will also implement
    controls in our *Platformer* game and add a jump button to make the player jump
    over the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Scene Kit is a 3D graphics framework provided by Apple, we can use SceneKit's
    3D elements in our Sprite Kit game to further enhance the gaming experience and
    have a better gameplay if required. We are going to discuss about how we can integrate
    SceneKit in a Sprite Kit game.
  prefs: []
  type: TYPE_NORMAL
- en: Animating nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animated pictures give a very dynamic and polished feel during a gameplay; it
    is always preferred to have animations in our game. To add animations in Sprite
    Nodes, we can use the `SKAction` class properties and methods, which add the animations
    to the Sprite Kit nodes. Let's discuss about the `SKAction` class in detail.
  prefs: []
  type: TYPE_NORMAL
- en: SKAction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properties and methods of the `SKAction` class help in providing the actions
    to the nodes in a scene. Actions are used to change the arrangement and appearance
    of the node to which they are attached. Actions in a node are executed when the
    scene runs its nodes.
  prefs: []
  type: TYPE_NORMAL
- en: To assign an action we can call the particular `SKAction` class method as required.
    Then, we can configure the properties of the actions. In the end, for the execution
    of the action, we call the node object's `runAction()` method and pass the action's
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a single action to a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two steps to add a single action to the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an action**: First of all, we create an action which can perform
    a particular activity such as rotating, scaling, moving, and so on, on the Sprite
    Kit node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Executing an action**: Finally, we run the action on the node by calling
    the `runAction()` method on that node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding multiple actions to a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three steps involved in the process of adding multiple actions to
    the node:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating actions**: Here, instead of creating a single action, we can create
    multiple actions to perform different behaviors on the Sprite Kit node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Creating action sequence**: Here, we are going to create the order of execution
    in which the actions should behave in the Sprite Kit node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Executing the action**: Finally, we are going to run the action by specifying
    the action sequence in the `runAction()` method on the node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various types of actions which can be applied on a node to make it
    behave differently, now we are going to study about most of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Moving nodes using actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKAction` class provides various action methods for moving nodes on a
    scene. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func moveByX( x: CGFloat, y : CGFloat, duration sec: NSTimeInterval)`: This
    will move the node to its new position. Here, Delta of `x`, Delta of `y`, and
    duration in seconds are passed as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func moveBy( delta: CGVector, duration sec: NSTimeInterval)`: This will move
    the node relative to its current position. Here, Delta vector pointing to a new
    position and duration in seconds are passed as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moveTo(location: CGPoint, duration sec: NSTimeInterval)`: This will move the
    node to a new position. Location of the new position and duration in seconds are
    passed as parameters. Here location is a `CGpoint` value whose default value is
    `(0,0)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func moveToX( x: CGFloat, duration sec: NSTimeInterval)`: This will move the
    node horizontally. In this, the `x` value and the duration of the action are passed
    as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func moveToY(y: CGFloat, duration sec: NSTimeInterval)`: This will move the
    node vertically along a relative path. In this, the `y` value and the duration
    of the action in seconds are passed as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func followPath( path: CGPath, duration sec: NSTimeInterval)`: This will move
    the node along a relative path. `path` and `sec` are taken as parameters, in which
    path is a `CGpath` value which is relative to the current position of the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func followPath( path: CGPath, speed: CGFloat)`: This will move the node along
    a relative path at a specified speed. The unit of speed is points per second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, duration
    : NSTimeInterval )`: This function will move the node along the path. In this
    function, we pass four parameters: one is the `path` on which the node will move;
    the second is the `offset` parameter, which is either `true` or `false`. `true`
    represents that the points in the path are relative offsets to the initial position
    of the node, and on the other hand `false` represents that the points are absolute
    in nature. `orientToPath` will be a Boolean property if the true node can follow
    the path along the `z` axis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func followPath( path: CGPath, asOffset : Bool, orientToPath : Bool, speed
    : CGFloat)`: This function will move the node along the path at a specified speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating nodes using actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKAction` class provides various action methods for rotating nodes on
    a scene. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func rotateByAngle( radians: CGFloat, duration sec: NSTimeInterval)`: This
    functions helps in rotating the node at a specified angle. It takes two parameters:
    one is the amount in which the node is to be rotated in `radians`, and the other
    is the duration of the rotation in `seconds`. This rotation is relative to the
    node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func rotateToAngle( radians: CGFloat, duration sec: NSTimeInterval)`: This
    function helps in rotating the node to an absolute angle, in the counterclockwise
    direction. It also takes two parameters: one is the angle to rotate the node,
    which is measured in `radians`, and the other is the duration of the animation
    in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func rotateToAngle(radians: CGFloat, duration sec: NSTimeInterval, shortestUnitArc
    shortestUnitArc: Bool)`: This function helps in rotating the node to an absolute
    angle. It takes three parameters: one is the angle to which the node is to be
    rotated, the second is the duration in seconds, and the third is a Boolean value
    to assign whether we want the smallest rotation path or not. If `true,` then the
    rotation will be in the shortest direction, otherwise the rotation will be interpolated
    within the discrete points.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the animation speed of a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKAction` class provides various action methods for changing a node''s
    animation speed. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func speedBy(speed: CGFloat, duration sec: NSTimeInterval)`: With this function,
    we can control the speed of a node''s actions. It takes two parameters: one is
    the amount of `speed` to be added in the node, and the other is the `duration`
    of the animation in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func speedTo(speed: CGFloat, duration sec: NSTimeInterval)`: With this function
    too, we can control the speed of the node''s actions. But instead of passing the
    parameter that adds its value to the previous speed, this function changes the
    `speed` to the set value. The other parameter passed is the `duration` of animation
    in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the scale position of a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKAction` class provides various action methods for scaling a node. They
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func scaleBy( scale: CGFloat, duration sec: NSTimeInterval)`: With this function,
    you can change the `xScale` and `yScale` values of a node. This function takes
    two parameters: one is the amount to be added in the `x` and `y` values of the
    node, and the other is the duration of the animation. This scaling applies to
    the current size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func scaleTo( scale: CGFloat, duration sec: NSTimeInterval)`: With this function
    too, you can change the `x` and `y` values of a node. It takes two parameters:
    one is the new value of the node''s `x` and `y` values, and the other is the duration
    of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func scaleXBy ( xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)`:
    With this function, you can change the `x` and `y` values of the node. Three parameters
    are passed in this function: first is the amount to be added in the node''s `x`
    value, second is the amount to be added in the node''s `y` value, and the third
    is the duration of the animation. This function is used when you have to scale
    the `x` and `y` of a node with different values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func scaleXTo( xScale: CGFloat, y yScale: CGFloat, duration sec: NSTimeInterval)`:
    With this function too, you can change the `x` and `y` values of the node differently.
    But instead of passing the value to add in the `x` and `y`, you can set the `x`
    and `y` scale to new values by passing the respective parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func scaleXTo( scale: CGFloat, duration sec: NSTimeInterval)`: With this function,
    you can only change the `x` value of a node to a new value. It takes two parameters:
    one is the node''s `x` value and the other is the `duration` of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func scaleYTo( scale: CGFloat, duration sec: NSTimeInterval)`: With this function,
    you can only change the `y` value of a node to a new value. It takes two parameters:
    one is the node''s `y` value and the other is the `duration` of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Showing or hiding a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `SKAction` class provides various action methods for hiding or showing
    a node on a scene. Let''s have a look at both of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func unhide()`: With this function, you can create an action to make a node
    visible. This function was introduced in iOS 8.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func hide()`: With this function, you can create an action to make a node
    hidden. This function was introduced in iOS 8.0 as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the transparency of a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the help of `SKAction`, you can also change the transparency of a node.
    The following functions help you achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func fadeInWithDuration( sec: NSTimeInterval)`: You can change the alpha value
    of a node to `1.0` with this function. Only one parameter is passed with this
    function, which is the duration of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func fadeOutWithDuration( sec: NSTimeInterval)`: You can change the alpha
    value of a node to `0.0` with this function. Only one parameter is passed with
    this function, which is the duration of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func fadeAlphaBy( factor: CGFloat, duration sec: NSTimeInterval)`: With this
    function, you can control the amount of alpha value to be added to the node. You
    pass two parameters in this function: one is the amount to be added to the alpha
    value of the node, and the other is the `duration` of the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func fadeAlphaTo(alpha: CGFloat, duration sec: NSTimeInterval)`: With this
    function, you can set a new alpha value for the node. Two parameters are passed
    in this function: one is the node''s new alpha value and the other is the `duration`
    of the node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the content of a sprite node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With some `SKAction` functions, you can create actions to change the content
    of a sprite node. Let''s have a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func resizeByWidth( width: CGFloat, height: CGFloat, duration: NSTimeInterval)`:
    This function creates an action which adjusts the size of a sprite node. This
    function takes three parameters: the first is the amount to be added to the sprite''s
    `width`, the second is the amount to be added to the sprite''s `height`, and the
    third is the `duration` of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func resizeToHeight( height: CGFloat, duration: NSTimeInterval)`: This function
    creates an action that changes the `height` of a sprite to a new value. One parameter
    passed is the new `height` of the sprite, and the second parameter is the `duration`
    of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func resizeToWidth(width: CGFloat, duration: NSTimeInterval)`: This function
    creates an action that changes the `width` of a sprite to a new value. One parameter
    passed is the new `width` of the sprite, and the second parameter is the `duration`
    of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func resizeToWidth( width: CGFloat, height: CGFloat, duration: NSTimeInterval)`:
    This function creates an action that changes the `width` and `height` of a sprite
    node to a new value. You can specify the new `height` and `width` separately in
    this function. It takes three parameters: one is the new `width` of the sprite,
    the second is the new `height` of the sprite, and the third is the `duration`
    of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func setTexture(texture: SKTexture)`: This function helps in creating an action
    that changes the sprite''s texture. Only one parameter is passed in this function,
    which is the sprite''s new `texture`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func setTexture( texture: SKTexture, resize: Bool)`: This function helps in
    creating an action that changes the sprite''s texture. Along with this, you can
    also control whether the sprite should be resized to match the new texture or
    not. The two parameters passed are the new `texture` to use on the sprite and
    the Boolean to control the resizing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func animateWithTextures(textures: [AnyObject], timePerFrame sec: NSTimeInterval)`:
    This function creates an action that animates changes in a sprite''s texture.
    When the action executes, the `texture` property animates the array of the `texture`,
    which is passed as a parameter. The action continues until all the textures in
    the array have finished animating. Two parameters are passed in this function:
    one is the array of `textures`, and the other is the time in which each texture
    in the array will be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func animateWithTextures( textures: [AnyObject], timePerFrame sec: NSTimeInterval,
    resize: Bool, restore: Bool)`: This function creates an action which animates
    changes to the sprite''s texture and can also resize the sprite to the new texture,
    if required. It takes four parameters: one is the array of `textures` that are
    used when animating the sprite, the second is the time in which each texture will
    be displayed, the third is a Boolean value to control the resizing of the sprite
    to match the new texture, and the fourth is the restoring of the size of the sprite
    to the original texture size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func colorizeWithColor(color: UIColor, colorBlendFactor: CGFloat, duration
    sec: NSTimeInterval)`: This function creates an animation that animates a sprite''s
    color and blend factor. Three parameters are passed in this function: one is `color`
    for the new sprite, the second is the new blend factor, and the third is the `duration`
    of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func colorizeWithColorBlendFactor( colorBlendFactor: CGFloat, duration sec:
    NSTimeInterval)`: This function will create an animation that animates the sprite''s
    blend factor. It takes two parameters: one is the new blend factor and the other
    is the `duration` of the animation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other important actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By now, we have discussed most of the important functions that are used to
    create actions on a node. Now, we are going to have a look at some other important
    functions used in creating actions on a node in Sprite Kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func runAction( action: SKAction, onChildWithName name: String)`: This function
    will create an `action` that will, in turn, run an `action` on a node''s child.
    You pass the `action` to execute and take the `name` of the child object as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func group( actions: [AnyObject])`: You can run a collection of `actions`
    in parallel, using this function''s action. It takes an array of `SKAction` objects
    as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func sequence( actions: [AnyObject])`: You can run a collection of actions
    sequentially, using this function''s action. It takes an array of `SKAction` objects
    as a parameter. The order of actions is the same as the order of actions passed
    in the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func repeatAction( action: SKAction, count count: Int)`: You can create an
    action to repeat an action that is specified to repeat a number of times. The
    `action` to repeat and the `count` of repetitions are passed as parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func repeatActionForever( action: SKAction)`: It creates an action that, in
    turn, repeats another action forever. It takes the `action` to repeat as a parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func reversedAction()`: With this action, you can reverse the behavior of
    another action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding controls in Sprite Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding controls in a Sprite Kit doesn''t need any external predefined framework;
    we can implement the controls in Sprite Kit using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Tapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gesture recognitions (swiping in any direction, pinching, rotating)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving sprites using the accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of the preceding controls in detail and also how we can implement
    them in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Node tapping and clicking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have four override methods for handling touch events with a `UIResponder`
    class, which is part of `UIKit` provided by Apple. Let''s learn about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func touchesBegan(touches:Set<NSObject>, withEvent event:UIEvent)`: This method
    is called whenever a user touches the view/window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func touchesMoved(touches:Set<NSObject>, withEvent event:UIEvent)`: This method
    is called whenever a user moves his finger on the view/window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func touchesEnded(touches:Set<NSObject>, withEvent event:UIEvent)`: This method
    is called whenever a user removes the finger from view/window'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func touchesCancelled(touches:Set<NSObject>!, withEvent event:UIEvent!)`:
    This method is called whenever system events, such as low memory warnings and
    so on, happen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement an action when someone taps on a node on the scene, we will first
    get the tapped location on the scene, and if the tapped location is within the
    node's co-ordinate axis points, then we can define the actions for that tap. This
    will be implemented in the `touchesBegan()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Kit includes a category in `UITouch`; this is one of its best features.
    `UITouch` comes with two methods, namely, `locationInNode()` and `previousLocationInNode()`.
    These methods find the coordinates of a touch within an `SKNode` object's coordinate
    system.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we will use it to find out where the touch happened within the
    scene's coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Gesture recognitions (swiping in any direction, pinching, or rotating)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to detect gestures in your game, such as taps, pinches, pans, or
    rotations, it's extremely easy with Swift and the built-in `UIGestureRecognizer`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Following is a code snippet for gesture recognitions in Swift; it will implement
    swiping left, right, top, and bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we set up four functions, one for each direction, to handle whatever
    we want to do when the user swipes the screen in those directions. Then, in the
    `didMoveToView` statement, we create the `UISwipeGestureRecognizer` variables
    for each direction and add them to the view. Notice the `action`: `selector` part
    of each, calls their respective functions in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the preceding code block, you can implement swipe control in a Sprite
    Kit game. When the user swipes in a particular direction, the `UISwipeGestureRecognizer`
    will recognize the direction of the user's swipe and the swipe gesture object
    will be added to the gesture through the `addGestureRecognizer()` method. So,
    the particular object will be sent for the function and the appropriate method
    will be called, and after that, the respective actions will be executed as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Moving sprites with an accelerometer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An accelerometer is a sensor that measures proper acceleration ("g-force").
    Proper acceleration is not the same as coordinate acceleration (rate of change
    of velocity). A lot of games use an accelerometer as a controller. We can also
    use it in our Sprite Kit game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how we can implement an accelerometer in a Sprite Kit game.
    We will not be using an accelerometer in our *Platformer* game, but it would be
    good to have knowledge of the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a primary point, we need to read values from the accelerometer, so we need
    to import the `CoreMotion` framework. Add the following line right after the `import
    SpriteKit` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CMMotionManager` object is the gateway to the motion services provided
    by iOS. In the `didMoveToView` method, the custom code is executed. Let''s have
    a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Please refer the comments in the preceding code to the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The image will be loaded and centered in the main view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `startAccelerometerUpdatesQueue` method reads input from the accelerometer
    and constantly gets new updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the acceleration value is negative, the value is subtracted from the `x`
    position, hence the airplane will move left. If the acceleration value is positive,
    the value will be added to the `x` position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The actual movement will be done on the update method, which will be called
    at each frame.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `moveToX` action is assigned to the airplane. This code will be a helpful
    reference if you want to implement accelerometer for controlling a game. Now,
    let's read about SceneKit.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to SceneKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SceneKit is a framework that can be used to implement the features of 3D graphic
    components into our iOS games. SceneKit provides a facility for integrating a
    high performance rendering engine at a greater level. It also offers a facility
    for importing, manipulating, and rendering 3D graphic assets.
  prefs: []
  type: TYPE_NORMAL
- en: It is fairly easy in iOS 8, to integrate SceneKit elements in a Sprite Kit game.
    First of all, you just have to import the SceneKit framework in the required Sprite
    Kit class. Then, you are all set to access all the methods and properties of SceneKit.
  prefs: []
  type: TYPE_NORMAL
- en: Adding animations and controls in our Platformer game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After discussing about the `SKAction` class and various methods to add controls
    in our game, it's time to revisit our *Platformer* game and implement some of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, it's time to add actions in our game. Let's start with adding animation
    to the player and block collision. Until the last chapter, there was no collision
    effect between the player and the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will add collision between the block and the player. Along with this,
    we can make the player die in an animated way. We can denote the animation after
    the player and block collision as a player death animation.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we will update the maximum size of the X-axis for the blocks,
    because currently, the blocks are being destroyed before the end of the running
    bar. Hence, we will replace the respective code with an updated one.
  prefs: []
  type: TYPE_NORMAL
- en: Replace `self.blockMaxX = 0 - self.block1.size.width / 2` with `self.blockMaxX
    = 0 - self.runningBar.size.width` in the `addBlocks()` method, in the `GameScene.swift`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will work on the part where the block and the player collides. For this,
    we will use a library method function, `didBeginContact()`, which is called when
    the collision happens, as we have already set all the required physics properties
    such as, `contactTestBitMask`, `categoryBitMask`, and `collisionBitMask` for the
    blocks and the player in the `addBlocks()` method, in the `GameScene.swift` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `didBeginContact()` method and add the following code, in which
    we are defining actions when the player and the block collide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we used `inOutWhenPlayerDied` for scaling a player
    by multiplying a float value of `0.5` and also specifying the `duration` as `0.5`
    seconds. In `upActionWhenPlayerDied`, we moved the player along the y-axis by
    multiplying the player's `height` with a float value `4`, with the duration of
    animation as `2` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: After these animations, we should also remove the player from the scene, and
    also from the node tree. This is taken care of by `removeFromParent`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the action in the desired sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice in the preceding function that we just added in our *Platformer*
    game, when calling the sequence, we have also reversed an action by using `reversedAction()`.
    We also call the `gotoMenuScreen` function in our sequence. Let''s discuss about
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our game will look after adding this action sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding actions](img/4201_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The animation for when the player collides with a block.
  prefs: []
  type: TYPE_NORMAL
- en: Transiting from GameScene to MenuScene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the player''s death, it is time to call the `gotoMenuScreen()` method
    for transiting to the `MenuScreen`. Add the following function in the `GameScene`
    class to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A slight glimpse of the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transiting from GameScene to MenuScene](img/4201_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The door close transition after the player's death.
  prefs: []
  type: TYPE_NORMAL
- en: Adding controls in our game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For controlling the player, we can make him jump over the blocks and save him
    from dying. Currently, this is being done by tapping on the player, but it is
    better to have a button for this action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the **JUMP** button in our game, first we need to create a sprite
    node for the **JUMP** button in the `GameScene.swift` file. Create a sprite node
    with the name, `btnjump`, and then assign the node with an image for the button;
    we can call the image `jump`. Add the following code for this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need to position our button on the `GameScene`. For this, we can add
    the following code before the `addBackground()` function call in the `didMoveToView()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And now your `didMoveToView()` function should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Till now, we have just added the **JUMP** button on scene but we didn''t define
    the action of when the button will be clicked. So, let''s write a block of code
    for performing this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the preceding block of code in the `touchesBegan` method of `GameScene.swift`.
    Now your `touchesBegan()` method function should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is how the `GameScene` will look after adding the **JUMP** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding controls in our game](img/4201_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JUMP button now appears on the screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the game, there will be two major changes: one is the animation
    of the player''s death during collision with the blocks, and the other is the
    **JUMP** button to make the player jump over the blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the `SKAction` class in detail; this class
    is responsible for creating actions for nodes. We also discussed about various
    types of controls by which a Sprite Kit game can be played (such as, tapping,
    gesture recognition, and accelerometer). We also read about SceneKit and how we
    can integrate SceneKit in a Sprite Kit game. Now, our *Platformer* game has two
    new features. One is the player's death animation and the other is the **JUMP**
    button to control the player's jump.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the particle system and shaders. Along
    with this, we will also add particle effects in our *Platformer* game, to enhance
    gameplay experience.
  prefs: []
  type: TYPE_NORMAL
