<html><head></head><body><div><div><div><h1 id="_idParaDest-213" class="chapter-number"><a id="_idTextAnchor307"/>9</h1>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor308"/>Event Sourcing and CQRS</h1>
			<p>The previous chapter, on <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>), laid the foundation for us to dive into two <a id="_idIndexMarker741"/>powerful architectural patterns that answer to the demand for<a id="_idIndexMarker742"/> scalable, responsive, and<a id="_idIndexMarker743"/> maintainable applications: <strong class="bold">Event Sourcing</strong> and <strong class="bold">Command-Query Responsibility </strong><strong class="bold">Segregation</strong> (<strong class="bold">CQRS</strong>).</p>
			<p>Firstly, we will explore the foundation of Event Sourcing. We will discuss how we can use Event Sourcing to model our domain, how to persist the state of your domain, and how to reconstruct the current state from the persisted events. We will explore the benefits of this approach.</p>
			<p>Next, we will turn our attention to CQRS, examining how it separates the responsibilities of commands (write) and queries (read). We will discuss the key components of a CQRS architecture, including the command and query handlers, the domain model, and the event store. We will delve into the benefits of this separation.</p>
			<p>As we delve deeper, we will examine the practical considerations of implementing CQRS and Event Sourcing together, including data modeling, event schema design, and handling eventual consistency. We will also discuss strategies for integrating these patterns into your existing software ecosystem, ensuring a seamless and scalable transition.</p>
			<p>Through real-world examples and best practices, you will gain a comprehensive understanding of how CQRS and Event Sourcing can transform the way you approach software design and development. By the end of this chapter, you will be equipped with the knowledge and tools to harness the power of these patterns and unlock the full potential of your applications.</p>
			<p>We will go through the main topics in the following order:</p>
			<ul>
				<li>Event Sourcing</li>
				<li>Command-Query Responsibility Segregation (CQRS)</li>
				<li>Combining CQRS and Event Sourcing</li>
			</ul>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor309"/>Technical requirements</h1>
			<p>You can find all the code files used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-9">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-9</a></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor310"/>Event Sourcing</h1>
			<p><strong class="bold">Event Sourcing</strong> is a data<a id="_idIndexMarker744"/> management pattern, and its origin can be traced back to the 1990s, when engineers recognized the limitations of traditional data <a id="_idIndexMarker745"/>storage <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>), particularly in the context of building complex and event-driven systems.</p>
			<p>Event Sourcing has its roots in the<a id="_idIndexMarker746"/> principles of <strong class="bold">Domain-Driven Design</strong> (<strong class="bold">DDD</strong>), as covered in <a href="B21737_08.xhtml#_idTextAnchor289"><em class="italic">Chapter 8</em></a>. DDD introduced the concept of an <strong class="bold">Aggregate</strong> as a<a id="_idIndexMarker747"/> fundamental building block of the domain model, and Aggregates usually need to be persisted in data storage.</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor311"/>The classic CRUD approach and its limitations</h2>
			<p>The classic CRUD <a id="_idIndexMarker748"/>approach is<a id="_idIndexMarker749"/> sufficient for capturing the latest snapshot of an Aggregate by CRUD operations, usually with the use of a relational database. There are, however, limitations to this approach:</p>
			<ul>
				<li><strong class="bold">History, auditability, and traceability</strong>: While the CRUD approach can capture the current snapshot of an Aggregate, its ability to keep audit trails of all changes made to the Aggregate over time is limited.<p class="list-inset">This is usually overcome by custom data persistence code to keep historical records, or with the assistance of database update triggers. This can make it challenging to track the history of changes, understand how the system reached a particular state, and comply with regulatory requirements.</p></li>
				<li><strong class="bold">Modeling complex domains</strong>: CRUD-based systems work well with simple and straightforward data models, but they can struggle to effectively represent and manage the evolution of complex domain models over time.<p class="list-inset">Traditionally, with the use of relational databases, a complex Aggregate object results in convoluted database schemas, complex data persistence operations, and difficulties in maintaining and evolving the system.</p></li>
				<li><strong class="bold">Event-driven capabilities</strong>: The CRUD approach has no support for event-driven architectures, where the system needs to react to and propagate changes in a decoupled, scalable manner.</li>
				<li><strong class="bold">Concurrency and consistency</strong>: CRUD-based systems often rely on traditional locking mechanisms to ensure data consistency, which often leads to performance bottlenecks in distributed, concurrent, and high-load environments.<p class="list-inset">Maintaining strong consistency in the face of concurrent updates can be a significant challenge in CRUD systems.</p></li>
				<li><strong class="bold">Versioning and evolution</strong>: Updating and evolving CRUD-based systems can be problematic, as changes to the data model or business logic may require complex migrations and data transformations.<p class="list-inset">Versioning and handling historical data can also be more complicated in a CRUD-centric approach.</p></li>
				<li><strong class="bold">Analytics and reporting</strong>: CRUD systems focus on the current snapshot of Aggregates, which can make it challenging to analyze, generate reports, or derive insights<a id="_idIndexMarker750"/> from the historical data of Aggregates.</li>
			</ul>
			<p>In the face of <a id="_idIndexMarker751"/>these challenges, the idea of capturing the full history of Aggregate changes began to gain traction.</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor312"/>Events as first-class citizens</h2>
			<p>Event Sourcing <a id="_idIndexMarker752"/>aims to solve these challenges by making events first-class citizens. The term <em class="italic">event</em> here entails the same concept as the <em class="italic">event</em> in DDD mentioned in <a href="B21737_08.xhtml#_idTextAnchor289"><em class="italic">Chapter 8</em></a>. An event captures the change in an aggregate, making it a key element in this framework.</p>
			<p>Event Sourcing persists all the events of aggregates in an event store. There are no update or delete operations to an event because an event represents a change that has already happened to an aggregate. In other words, events are immutable and are stored as a journal in chronological order. Event stores are often not relational databases; they can be NoSQL databases or persistent queues.</p>
			<p>In contrast to CRUD, in which the latest snapshot of an aggregate is a first-class citizen, Event Sourcing derives the latest snapshot of an aggregate by replaying the events from the aggregate from the first to the last event. As a result, the full history of an aggregate is preserved and no custom code is required to provide an audit trail of the aggregate.</p>
			<p>Moreover, the history of an aggregate is captured as a linear timeline and naturally eliminates the challenge of keeping strong consistency with concurrent updates. There should be, however, version validation before a request to mutate an aggregate is accepted and <a id="_idIndexMarker753"/>eventually generates an event. This is to <a id="_idIndexMarker754"/>prevent the <strong class="bold">Lost Update</strong> problem, where concurrent updates of the same aggregate overwrite each other unknowingly.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor313"/>Functional representations of Event Sourcing</h2>
			<p>The idea of<a id="_idIndexMarker755"/> representing the state of a system as a sequence of immutable events aligns well with the functional programming paradigm. Aggregates and events are immutable. Each change is performed by creating a new version of an aggregate from an event through stateless functions. This can be expressed through two basic functions written as Kotlin lambdas:</p>
			<pre class="source-code">
(CreatedEvent) -&gt; Aggregate
(UpdatedEvent, Aggregate) -&gt; Aggregate</pre>			<p>The first function creates an initial aggregate. Subsequently, the update functions take the current version of the aggregate and create a new version.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor314"/>An example of how a request is handled with Event Sourcing</h2>
			<p>Suppose there is <a id="_idIndexMarker756"/>a request to update an existing aggregate. The service that receives the request would need to get the latest version of the aggregate to validate the request. So, the service gets all the events for the aggregate from the event store.</p>
			<p>All the events are replayed to recreate the latest snapshot of the aggregate. Assuming the request is all good, the service creates a new event. The service then plays this event on the current aggregate and creates an updated version of the aggregate.</p>
			<p>The transaction is committed by appending the new event in the event store. The updated version of the aggregate can be used as a response to the original requester.</p>
			<p>The whole interaction is illustrated as a sequence diagram, as shown in <em class="italic">Figure 9</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/B21737_09_1.jpg" alt="Figure 9.1 – An example of Event Sourcing" width="1091" height="973"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – An example of Event Sourcing</p>
			<p>It is important to point out that the aggregate is not directly updated by the service. It is achieved by the <a id="_idIndexMarker757"/>handling of the new event. Also, the event store is responsible for distributing the new event to subscribers that are interested in these events.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor315"/>Benefits of Event Sourcing</h2>
			<p>The benefits of<a id="_idIndexMarker758"/> Event Sourcing come from the persistence of full audit trails of an Aggregate:</p>
			<ul>
				<li><strong class="bold">Full audit trails with intents</strong>: Not only are the full audit trails of an aggregate preserved, but also the intent of each change is captured. The name of each event of the aggregate ideally should come from the ubiquitous language so it becomes a business-aware and user-friendly history.</li>
				<li><strong class="bold">Time travel</strong>: With the full history captured as a linear sequence of events, it is possible to travel back in time to construct a historical representation of the aggregate. It helps engineers to reproduce a scenario that happened in the past for investigation and troubleshooting purposes. It also enables users to see the historical aggregate as a feature.</li>
				<li><strong class="bold">Creation of read models</strong>: Having multiple consumers of the same event of an Aggregate opens the door to multiple read models. Each read model consumes the same event but transforms it to meet its specific requirements. This approach<a id="_idIndexMarker759"/> provides diverse views tailored for particular business purposes.</li>
			</ul>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor316"/>Deciding whether Event Sourcing should be used</h2>
			<p>Choosing Event Sourcing <a id="_idIndexMarker760"/>as the way to store aggregates and their audit trails should not be taken lightly. It is a fundamental shift in how we reason about data, and it requires noticeable effort to make it work.</p>
			<p>From the <em class="italic">YAGNI</em> principle we covered in <a href="B21737_01.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a>, engineers should build the simplest things that work. When there is more than one solution, the simplest solution should be chosen.</p>
			<p class="callout-heading">A simple solution is different from an easy solution</p>
			<p class="callout">Simple solutions are not complicated or are straightforward to reason about. Easy solutions require less effort to make. Take the example of capturing a new field. If we believe that the field should belong to a new entity, then creating a new entity that has the field is the most intuitive and straightforward approach. However, a new entity may mean adding new database tables, new validations, and new exposed APIs. On the other hand, if we attach the new field to an existing entity, we only need to enhance the existing entity, database table, and APIs. There is less effort involved in coding and testing, even though the field does not belong to the existing entity. This is an easy solution as less effort is required, but it is not simple because it is not intuitive and is instead confusing to see the field in an entity to which it does not belong.</p>
			<p>An decision tree to determine if an aggregate should use Event Sourcing is shown in <em class="italic">Figure 9</em><em class="italic">.2</em>:</p>
			<div><div><img src="img/B21737_09_2.jpg" alt="Figure 9.2 – A decision tree whether to use Event Sourcing" width="1273" height="1035"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – A decision tree whether to use Event Sourcing</p>
			<p>The most <a id="_idIndexMarker761"/>decisive factor is whether the aggregate being considered to use Event Sourcing belongs to a Generic subdomain or not. In <a href="B21737_08.xhtml#_idTextAnchor289"><em class="italic">Chapter 8</em></a>, we identified Core domains, Supporting subdomains, and Generic subdomains. A Generic subdomain has a high likelihood of being fully replaced by off-the-shelf software products, which makes the benefits of using Event Sourcing not significant.</p>
			<p>If the aggregate involved belongs to either a Core domain or a Supporting subdomain, the next step in the consideration is whether it is required to keep the full audit trails of the aggregate. Full audit trails can be used for regulatory reporting, replaying events to get a particular historical state of the aggregate, or performing time-series data analysis. It is a powerful feature of Event Sourcing, but not all aggregates need such power.</p>
			<p>Another hint that helps when considering Event Sourcing is if there are multiple read models for the Aggregate. The definition of a read model here is the same as the read models that can be discovered <a id="_idIndexMarker762"/>during <strong class="bold">Event Storming</strong>, which was also covered in <a href="B21737_08.xhtml#_idTextAnchor289"><em class="italic">Chapter 8</em></a>.</p>
			<p>An aggregate that requires multiple read models can benefit from Event Sourcing. Each read model can consume the same event of the aggregate, but it transforms the data to its unique representation of the aggregate as a materialized view. Sometimes, a read model might even combine data from other aggregates or entities.</p>
			<p>Event Sourcing uses events extensively for each change in an aggregate, and events are often processed asynchronously. If the operations for the aggregate are predominately synchronous, it imposes challenges in implementing Event Sourcing for the aggregate. There are techniques to synchronously process events to update aggregates, and the implementation has a cost.</p>
			<p>It is important to <a id="_idIndexMarker763"/>reiterate that this is just an example decision tree. Each organization may have other factors in its decision-making. Sometimes, it may even make a different decision given the same question.</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor317"/>Usage of Event Sourcing with a real-life example</h2>
			<p>Let’s revisit <a id="_idIndexMarker764"/>the real-life example of villagers exchanging services, with the three bounded contexts identified in <a href="B21737_08.xhtml#_idTextAnchor289"><em class="italic">Chapter 8</em></a>:</p>
			<ul>
				<li>Core domains: <strong class="bold">Contract Service</strong></li>
				<li>Supporting subdomain: <strong class="bold">Household Service</strong></li>
				<li>Generic subdomain: <strong class="bold">Notification Service</strong></li>
			</ul>
			<p>Walking through the decision tree (see <em class="italic">Figure 9</em><em class="italic">.2</em>) mentioned in the previous section, Notification Service, as a Generic subdomain, can be safely ruled out from using Event Sourcing.</p>
			<p>Household as an aggregate in Household Service does not need to keep full audit trails because only the latest states of households are needed for business cases. The CRUD approach is sufficient.</p>
			<p>Contract as an aggregate in Contract Service may need to keep full audit trails because disputes are likely to arise between households on the agreements in the contract.</p>
			<p>There are also multiple read models involving contracts. The primary read model of a contract is the one that specifies the details of the contract between two households.</p>
			<p>There can also be a unilateral read model for each household. It contains a list of services that the household should provide and to which household. There is another list of services that the household expects to receive and from which household.</p>
			<p>In addition, there is potential read model that aims to highlight the most wanted services in the village and the most active households in exchanging services.</p>
			<p>The negotiation process of a contract involves multiple rounds of amendments until both households agree. When a contract is drafted by one household, an email is sent to another household <a id="_idIndexMarker765"/>asynchronously. During the negotiation process, any change made by one household results in an email notification to the other household involved. There are also multiple messages between two households in providing the services as per the contract. This asynchronous nature of communication suggests that a contract is a suitable candidate for using Event Sourcing in the Contract Service.</p>
			<p>In this example, we are going to focus on using Event Sourcing to capture the full history of the aggregate contract in Contract Service.</p>
			<p>Let’s revisit the aggregate contract as a data class:</p>
			<pre class="source-code">
data class Contract(
    val id: UUID,
    val draftedAt: Instant,
    val updatedAt: Instant? = null,
    val version: Int,
    val partyA: Party,
    val partyB: Party,
)
data class Party(
    val householdName: String,
    val serviceProvided: String,
    val agreedAt: Instant? = null
)</pre>			<p>The <code>Contract</code> data class contains an <code>id</code> field, which uniquely identifies this aggregate. There is also a field named <code>version</code>, which is a monotonic increasing integer that shows how many events have been played for this aggregate.</p>
			<p>The basic construct of a <code>ContractEvent</code> should have the unique identifier of the aggregate <a id="_idIndexMarker766"/>and the time when the event happened:</p>
			<pre class="source-code">
interface ContractEvent {
    val contractId: UUID
    val targetVersion: Int
    val time: Instant
}</pre>			<p>It also has a target version, which is the version of the aggregate after the event is applied.</p>
			<p>In this example, we are using a simple in-memory event store. It has two basic functions. The <code>append</code> function adds a new event at the tail of the sequence by the aggregate ID, and the <code>get</code> function returns a chronological sequence of events given the aggregate ID:</p>
			<pre class="source-code">
class EventStore&lt;KEY, AGGREGATE&gt; {
    private val aggregatesByKey = mutableMapOf&lt;KEY, List&lt;AGGREGATE&gt;&gt;()
    fun append(id: KEY, payload: AGGREGATE) {
        aggregatesByKey.merge(id, listOf(payload)) { t1, t2 -&gt; t1 + t2 }
    }
    fun get(id: KEY): List&lt;AGGREGATE&gt;? = aggregatesByKey[id]
}</pre>			<p>If this is a real system, reputable event store middleware should be used to make it durable, highly available, and resilient.</p>
			<p>The creation of the aggregate contract starts with a household that has drafted a contract, and it <a id="_idIndexMarker767"/>should contain all the information required to create the first version of the aggregate:</p>
			<pre class="source-code">
data class ContractDraftedEvent(
    override val contractId: UUID,
    override val targetVersion: Int = 0,
    override val time: Instant,
    val draftedByHousehold: String,
    val counterpartyHousehold: String,
    val serviceProvided: String,
    val serviceReceived: String,
) : ContractEvent</pre>			<p>The <code>Contract Drafted Event</code> class should provide a function to create the aggregate. It is a simple function that puts the values into the appropriate structure:</p>
			<pre class="source-code">
fun ContractDraftedEvent.play(): Contract = Contract(
    id = contractId,
    draftedAt = time,
    version = targetVersion,
    partyA = Party(
        householdName = draftedByHousehold,
        serviceProvided = serviceProvided
    ),
    partyB = Party(
        householdName = counterpartyHousehold,
        serviceProvided = serviceReceived
    )
)</pre>			<p>Any subsequent event must take a parameter of the current version of the aggregate to generate a new version. For instance, an event that captures when a household amends and agrees to<a id="_idIndexMarker768"/> a drafted contract could look like this:</p>
			<pre class="source-code">
data class ContractAmendedEvent(
    override val contractId: UUID,
    override val targetVersion: Int,
    override val time: Instant,
    val amendedByHousehold: String,
    val serviceProvidedUpdate: String?,
    val serviceReceivedUpdate: String?,
) : ContractEvent
data class ContractAgreedEvent(
    override val contractId: UUID,
    override val targetVersion: Int,
    override val time: Instant,
    val agreedByHousehold: String,
) : ContractEvent</pre>			<p>Note that this event does not necessarily follow the data structure of the aggregate. The key point is to keep the event lean and simple. So, this event only mentions one household, and it relies on the corresponding <code>play</code> function to apply the change correctly. Note that the <code>play</code> function takes a parameter of the current aggregate:</p>
			<pre class="source-code">
fun ContractAmendedEvent.play(current: Contract): Contract {
    validate(current, amendedByHousehold)
    return if (amendedByHousehold == current.partyA.householdName) {
        current.copy(
            version = targetVersion,
            updatedAt = time,
            partyA = current.partyA.copy(
                serviceProvided = serviceProvidedUpdate ?: current.partyA.serviceProvided
            ),
            partyB = current.partyB.copy(
                serviceProvided = serviceReceivedUpdate ?: current.partyB.serviceProvided
            )
        )
    } else {
        current.copy(
            version = targetVersion,
            updatedAt = time,
            partyA = current.partyA.copy(
                serviceProvided = serviceReceivedUpdate ?: current.partyA.serviceProvided
            ),
            partyB = current.partyB.copy(
                serviceProvided = serviceProvidedUpdate ?: current.partyB.serviceProvided
            )
        )
    }
}
fun ContractAgreedEvent.play(current: Contract): Contract {
    validate(current, agreedByHousehold)
    return if (agreedByHousehold == current.partyA.householdName) {
        current.copy(
            version = targetVersion,
            updatedAt = time,
            partyA = current.partyA.copy(agreedAt = time),
        )
    } else {
        current.copy(
            version = targetVersion,
            updatedAt = time,
            partyB = current.partyB.copy(agreedAt = time)
        )
    }
}</pre>			<p>You will notice<a id="_idIndexMarker769"/> there is a <code>validate</code> function, which is important for ensuring data integrity:</p>
			<pre class="source-code">
fun &lt;T : ContractEvent&gt; T.validate(current: Contract, expectedHouseholdName: String): T {
    require(contractId == current.id) {
        "Aggregate ID mismatch - expected: $contractId, was ${current.id}"
    }
    require(targetVersion == current.version + 1) {
        "Unexpected version - expected: ${targetVersion - 1}, was ${current.version}"
    }
    require(
        expectedHouseholdName == current.partyA.householdName ||
            expectedHouseholdName == current.partyB.householdName
    ) {
        "Unexpected household - expected: ${expectedHouseholdName}, was ${
            listOf(current.partyA.householdName, current.partyB.householdName)
        }"
    }
    return this
}</pre>			<p>This <code>validate</code> function asserts that the event refers to the aggregate in the parameter. Then, it asserts that the current aggregate is one version lower than the target version of<a id="_idIndexMarker770"/> the event. Finally, it asserts that the involved household is mentioned in the aggregate contract.</p>
			<p>There should be an iterative function that takes a list of <code>Contract Events</code> and eventually returns a <code>Contract</code> object:</p>
			<pre class="source-code">
fun List&lt;ContractEvent&gt;.play(): Contract? {
    if (isEmpty()) return null
    var current: Contract = (first() as ContractDraftedEvent).play()
    var index = 1
    while (index &lt; size) {
        val event = get(index++)
        current = when (event) {
            is ContractAmendedEvent -&gt; event.play(current)
            is ContractAgreedEvent -&gt; event.play((current))
            else -&gt; throw IllegalArgumentException("Unsupported event")
        }
    }
    return current
}</pre>			<p>The function uses a <code>List</code> of contract events as the receiver. The return type is nullable in the case of an empty list. It assumes the first event is <code>ContractCreatedEvent</code>, which sets up the initial snapshot of the <code>Contract</code>. It loops from the second event to the last, generates a new version of the <code>Contract</code>, sets it as <code>current</code> to pass to the next event, and at the end returns the <code>Contract</code> object. An example of its usage is as follows. A list <a id="_idIndexMarker771"/>of events of the same aggregate is ordered and is played sequentially:</p>
			<pre class="source-code">
    val contractId = UUID.randomUUID()
    val eventStore = EventStore&lt;UUID, ContractEvent&gt;()
    val createdEvent = ContractDraftedEvent(
        contractId = contractId,
        time = Instant.now(),
        draftedByHousehold = "HouseholdA",
        counterpartyHousehold = "HouseholdB",
        serviceProvided = "Cleaning",
        serviceReceived = "Babysitting"
    )
    val amendedEvent = ContractAmendedEvent(
        contractId = contractId,
        targetVersion = 1,
        time = Instant.now(),
        amendedByHousehold = "HouseholdB",
        serviceReceivedUpdate = "Dish washing",
        serviceProvidedUpdate = null
    )
    val agreedEventByHouseholdA = ContractAgreedEvent(
        contractId = contractId,
        targetVersion = 2,
        time = Instant.now(),
        agreedByHousehold = "HouseholdA"
    )
    val agreedEventByHouseholdB = ContractAgreedEvent(
        contractId = contractId,
        targetVersion = 3,
        time = Instant.now(),
        agreedByHousehold = "HouseholdB"
    )
    listOf(
        createdEvent,
        amendedEvent,
        agreedEventByHouseholdA,
        agreedEventByHouseholdB
    ).forEach { eventStore.append(contractId, it) }
    val aggregate = eventStore.get(contractId)?.play()
    println("Aggregate is of version: ${aggregate?.version}")</pre>			<p>The code does not directly update the aggregate. Instead, it creates a few events and lets them play through. Eventually, the version should be <code>3</code> because the first version is <code>0</code>. The following should be printed to the console when the previous code is executed:</p>
			<pre class="console">
Aggregate is of version: 3</pre>			<p>This example illustrates a simple form of Event Sourcing where each event generates a new version of the aggregate. These events should be persisted to an event store as permanent storage and be received by subscribers so other read models can be built upon.</p>
			<p>In complex systems, processing an event could produce a list of events as reactions, and that would require a recursive function to walk through the processing. It may also require grouping related events as one transaction due to the chained reactions.</p>
			<p>Although the <a id="_idIndexMarker772"/>example here is simple, there are many ways Event Sourcing can go wrong. We are going to discuss some best practices that should be considered in the implementation.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor318"/>Event Sourcing best practices</h2>
			<p>Event Sourcing <a id="_idIndexMarker773"/>is a different way to reason about an aggregate in a domain from the classic CRUD approach. It only works if we design and architect our system with the mindset of events being first-class citizens. Otherwise, it could become an anti-pattern and undo all the benefits that it brings. Here are some of the fundamental best practices.</p>
			<h3>Randomization and idempotence</h3>
			<p>It is important that <a id="_idIndexMarker774"/>replaying the same sequence of events for an aggregate generates the same snapshot of the aggregate every time. In other words, the processing of events must be idempotent. There are two major factors that could violate this behavior: time and randomization.</p>
			<p>If the event processing contains logic that makes use of the time the event is processed, then it will generate different results depending on the time of processing. For example, the following <code>expire</code> variable would have different Boolean values based on the system clock:</p>
			<pre class="source-code">
val expire = If (event.time &lt; System.currentMillis()) true else false</pre>			<p>Any information related to the system clock should be stamped on the event instead. In this way, the result has been determined and will not change over time. Any time-based trigger or schedule job should obtain the system time and have the value captured in the events.</p>
			<p>Any randomization at the time of event processing will also generate different outcomes for each iteration. Values generated from randomization should be captured in the event payload, and there is no randomization involved in the event processing. If identifiers must be generated during the processing, they can be unique values within the scope of the event. Externally, they are used together with the event identifiers as composite keys. Here is an example:</p>
			<pre class="source-code">
val externalValueId = "${event.id}-${event.value.id}"</pre>			<p>The value inside <a id="_idIndexMarker775"/>the event can be identified externally by concatenation of the event ID and the value ID inside the event, delimited by a hyphen.</p>
			<h3>Event design</h3>
			<p>An event should have <a id="_idIndexMarker776"/>one and only one aggregate. Mixing multiple aggregates, whether they are of the same or different types, results in unnecessary coupling between aggregates. The coupling created by mixed aggregates in one event makes it difficult to scale events and their topics.</p>
			<p>There could be business cases where multiple aggregates are affected. In this scenario, multiple events should be created as a result, and each event describes what happened to each aggregate.</p>
			<p>Each event should capture the intent of the change in an aggregate. For example, <code>ContractCreatedEvent</code> is a bad name because it does not describe why the aggregate contract is created. A better name would be in line with ubiquitous language, such as <code>ContractDraftedEvent</code>.</p>
			<h3>Event topologies</h3>
			<p>Events are published<a id="_idIndexMarker777"/> for subscribers to receive and can be <a id="_idIndexMarker778"/>logically grouped as <strong class="bold">topics</strong>. A topic here is not to be mistaken for the topic in traditional pub-sub messaging, in which messages are no longer in a topic once all subscribers acknowledge receipt. In Event Sourcing, events are meant to be kept permanently as an append-only and sequential log of events. For example, a Kafka topic with an infinite retention period can be used to keep events, and each topic represents a logical grouping of events.</p>
			<p>All events of one aggregate should only go to one topic only. This is to simplify creating and reading the linear history of an aggregate.</p>
			<p>Spreading the events of an aggregate to multiple topics imposes difficulties in recreating the full history of an aggregate. It is also more difficult to scale performance and increase throughput, which<a id="_idIndexMarker779"/> are separate concerns from the event design.</p>
			<h3>Event schema compatibility</h3>
			<p>As Event Sourcing<a id="_idIndexMarker780"/> intends to keep all historical events, it is important that all events are backward compatible; in other words, old events can still be read and processed when the event schema evolves.</p>
			<p>Maintaining backward compatibility is a big topic in itself. There are many things that can keep or break backward compatibility. Here are some examples:</p>
			<ul>
				<li><strong class="bold">Keep</strong>:<ul><li>Adding an optional field</li><li>Adding more enum values to a type</li><li>Reducing the constraints of a field</li></ul></li>
				<li><strong class="bold">Break</strong>:<ul><li>Adding a mandatory field</li><li>Renaming a field</li><li>Changing the data type of a field</li><li>Removing a field</li><li>Increasing the constraints of a field</li></ul></li>
			</ul>
			<p>In the context of Event Sourcing, a backward-compatible event schema ensures that the system can always <a id="_idIndexMarker781"/>read the full history of an aggregate to re-create the latest snapshot of the aggregate.</p>
			<p class="callout-heading">Forward and full compatibility</p>
			<p class="callout">Forward compatibility means that an old consumer can read and process events of a new schema. A fully compatible schema means it is both backward and forward compatible.</p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor319"/>Performance and Memento</h2>
			<p>While the current <a id="_idIndexMarker782"/>version of an aggregate can always be derived from all the events of that aggregate from the beginning of time, it is not always ideal to have to play these events if a current snapshot is requested.</p>
			<p>A performance optimization is to persist the latest version of the aggregate as a derived record. This pattern is<a id="_idIndexMarker783"/> called <strong class="bold">Memento</strong>. The usage of this pattern can be justified if current snapshots are frequently requested.</p>
			<p>In the case of using events to recover the latest state of an aggregate, it may also be justified to use the Memento pattern. The reason for this is that the number of events will keep growing, and therefore the total time to replay all events will become longer and longer. Applying the Memento pattern changes the total time used for recovery versus number of events from linear to constant for a given aggregate.</p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor320"/>Migration from CRUD</h2>
			<p>Migrating an aggregate<a id="_idIndexMarker784"/> from CRUD to Event Sourcing <a id="_idIndexMarker785"/>is interesting in that usually, CRUD does not have full audit trails to allow a complete history to be rebuilt as events. Instead, the latest snapshots of aggregates are treated as the first versions, and then subsequent events are persisted.</p>
			<p>In this case, something like <code>ContractMigratedEvent</code> would be the first event.</p>
			<p>Moreover, the mutation of an aggregate will be done through the playing of events, not a direct update to the aggregate. As a result, any code that directly updates the aggregate will need to be deprecated.</p>
			<p>We have covered the basics of Event Sourcing with a real-life example and source code. There is another architectural pattern that works with Event Sourcing and is also based on DDD. We <a id="_idIndexMarker786"/>are <a id="_idIndexMarker787"/>going to cover this pattern now.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor321"/>Command-Query Responsibility Segregation (CQRS)</h1>
			<p>The origin of <a id="_idIndexMarker788"/>CQRS can be traced back to another design pattern<a id="_idIndexMarker789"/> called <strong class="bold">Command Query Separation</strong> (<strong class="bold">CQS</strong>). CQS is the core concept that defines two types of operations handled in a system: a command that executes a task, and a query that returns information, and there should never be one function that does both jobs.</p>
			<p>The term CQS was created by Bertrand Meyer in his book <em class="italic">Object-Oriented Software Construction</em> in 1988. He created it as part of his work on the Eiffel programming language.</p>
			<p>CQRS takes the defining principle of CQS and extends it to specific objects within a system, one retrieving data and one modifying data. CQRS is a broader architectural pattern, and CQS is the general principle of behavior.</p>
			<p>The term CQRS was coined by Greg Young in 2010. Since then, CQRS has gained traction, and various frameworks and libraries have been developed to support the pattern’s implementation in popular languages such as Java and .NET.</p>
			<p>There are four basic elements in CQRS: <strong class="bold">aggregate</strong>, <strong class="bold">query</strong>, <strong class="bold">command</strong>, and <strong class="bold">event</strong>.</p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor322"/>Aggregate</h2>
			<p>Aggregate in <a id="_idIndexMarker790"/>CQRS has the same meaning as in Event Sourcing and DDD. It is an aggregated entity that represents the current state of the domain model. The aggregate contains a basket of other entities and value objects to represent a domain concept as defined in ubiquitous language.</p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor323"/>Query</h2>
			<p>A query is a request from <a id="_idIndexMarker791"/>clients to retrieve a representation of the state of the domain model. Handling queries is a read-only operation and does not change the state of any aggregate. However, queries may be targeted to a certain read model related to an aggregate.</p>
			<h2 id="_idParaDest-230"><a id="_idTextAnchor324"/>Command</h2>
			<p>A command is a<a id="_idIndexMarker792"/> request from clients intending to change the state of an aggregate in the domain model. The intention is handled to determine whether the state should be changed and how. A command may only contain the necessary information for the change, and not the whole aggregate in the request.</p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor325"/>Event</h2>
			<p>An event is a confirmed<a id="_idIndexMarker793"/> and immutable change of the state of an aggregate. An event can be created because of a command, or because of the handling of another event. This is the same as the concept of events in DDD and Event Sourcing.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor326"/>How CQRS breaks down CRUD</h2>
			<p>CQRS has broken down<a id="_idIndexMarker794"/> the classic CRUD into many small queries, commands, and events. Each of them carries a precise meaning of what is happening, to the point that it matches the ubiquitous language.</p>
			<p>Take the real-life example of the negotiation process of a service contract between two households. Both households can amend the contract and eventually agree to it.</p>
			<div><div><img src="img/B21737_09_3.jpg" alt="Figure 9.3 – CRUD versus CQRS – update versus command" width="1554" height="687"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – CRUD versus CQRS – update versus command</p>
			<p>In CRUD style, both amendments to and agreement of a contract result in a request to update the contract, and the difference is the content of the contract. In CQRS style, amendments and agreements have dedicated commands to capture not only what needs to be updated, but also the intent and business context of the update.</p>
			<p>The CQRS style <a id="_idIndexMarker795"/>results in the amendment and agreement operations being separated. This leads to a cleaner and more modular design. The separation also allows independent scaling and the optimization of commands.</p>
			<p>On the query side, as shown in the following figure, households A and B can get the contract between them by using a CRUD read request, and the responses will be the same for both households. However, the CQRS query allows multiple read models, and in this case, it can return a custom read model depending on which household makes the query.</p>
			<div><div><img src="img/B21737_09_4.jpg" alt="Figure 9.4 – CRUD versus CQRS – read versus query" width="1524" height="742"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – CRUD versus CQRS – read versus query</p>
			<p>The CQRS style can build a materialized view for each household as a read model by consuming the events produced when a command is accepted. In CRUD style, these custom views are typically implemented using SQL commands and the custom views do not materialize.</p>
			<p>A materialized read model can scale independently without concerns for commands. For example, if the read-write ratio of the aggregate contract heavily tilts towards reading, then it is sensible to consider materializing the corresponding read model in a separate data store infrastructure, so the writing is not affected even under a heavy load of query operations.</p>
			<p>As read models are materialized by consuming events via asynchronous messaging, changes in the aggregates may not be immediately reflected in the read models but will eventually be synchronized.</p>
			<p>It is important<a id="_idIndexMarker796"/> to point out that handling commands does need some existing information for validation, integrity checks, and concurrency control. These read operations are necessary for handling commands, but not for serving requests.</p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor327"/>When should CQRS be considered?</h2>
			<p>Like Event Sourcing, CQRS<a id="_idIndexMarker797"/> should be considered when a couple of prerequisites are met and there are legitimate problems that can be solved by CQRS. CQRS is a paradigm shift in how we reason about a system, and significant effort is required to implement it correctly. Applying CQRS to the wrong system increases the complexity with no benefits.</p>
			<p>CQRS is an architectural pattern built upon DDD. If the current system has no concept of DDD, bounded contexts, or aggregates, then it is a non-starter. Even if the system includes bounded contexts, using CQRS may not be necessary for generic subdomains due to their limited complexity. CQRS is most likely beneficial only for core domains, where the domain itself is complex enough to warrant its use.</p>
			<p>There are, however, a few signs that CQRS can be considered in the domain:</p>
			<ul>
				<li>Multiple actors working on the same aggregate. This usually means not all actors are concerned with everything in an aggregate. Some actors may work on a part of an aggregate but not all of it.</li>
				<li>Multiple use cases of updating the aggregate. There are specific use cases in which only a part of the aggregate should be updated.</li>
				<li>Multiple views of the same aggregate. There are alternate views of the same aggregate, and sometimes there may even be a view combining multiple entities that deviate from the aggregate.</li>
				<li>Imbalanced read-write ratio. If either read or write operations are significantly more frequent than the other, read and write would need to be scaled differently as their needs are different.</li>
			</ul>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor328"/>Benefits and costs of CQRS</h2>
			<p>CQRS separates the<a id="_idIndexMarker798"/> concerns of read (query) and write (command) operations so their requirements can be met in isolation. This leads to smaller code footprints per function or per class, but there will be more functions or classes due to the separation.</p>
			<p>This separation drives the code toward the <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>), as mentioned in <a href="B21737_02.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, where there should be one and only one reason to change a class. Each use case for each actor has its own class, either as a query or as a command.</p>
			<p>The separation of queries and commands enables independent performance optimization, resulting in improved system performance and scalability overall. For example, queries can be optimized for faster execution due to the dedicated read models, and commands can be optimized for high throughput and consistency. However, this also results in more moving parts in the system and thus increases its complexity.</p>
			<p>Queries and commands are broken down into their own functions or classes. This means that extending functionality is unlikely to need to change existing queries and commands, and therefore it is easier than in CRUD, where there is a big repository class that contains all the CRUD operations.</p>
			<p>Dedicated queries and commands for each business case eliminate the need for clients to deal with unrelated fields and details about an aggregate, or to create a CRUD-style update or read request. This is in line with the <strong class="bold">Interface Segregation Principle</strong> (<strong class="bold">ISP</strong>), as mentioned in <a href="B21737_02.xhtml#_idTextAnchor045"><em class="italic">Chapter 2</em></a>, where a client is not forced to depend on fields and functions it does not use.</p>
			<p>Supporting multiple <a id="_idIndexMarker799"/>read models using CRUD is challenging. It often requires complicated SQL statements to join relevant data together. Moreover, it is difficult to optimize performance as different read models have different needs. Quite often, compromises are made so that different read models have reasonably acceptable performance.</p>
			<p>Using CQRS, read models are materialized by consuming the events of aggregates. They have their own storage so they can scale and optimize performance that is unique to the non-functional requirements. This comes at the cost of the replication of data in various forms, and more storage is needed to keep these read models. Also, each read model requires its own code to transform the event and persist data that’s relevant to its data structure.</p>
			<p>You may recognize <a id="_idIndexMarker800"/>the synergy between CQRS and Event Sourcing at this point. We are going to illustrate how they work together with a concrete example.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor329"/>Combining CQRS and Event Sourcing</h1>
			<p>CQRS and Event Sourcing are <a id="_idIndexMarker801"/>complementary patterns that work well together in building robust, scalable, and maintainable distributed systems.</p>
			<p>The <strong class="bold">command handler</strong> in the CQRS<a id="_idIndexMarker802"/> architecture is responsible for validating write requests. If a command is valid, an event is persisted to an event store, which is the core of the Event Sourcing pattern. An example of how the CQRS command and Event Sourcing integrate is shown in <em class="italic">Figure 9</em><em class="italic">.5</em>:</p>
			<div><div><img src="img/B21737_09_5.jpg" alt="Figure 9.5 – CQRS command and Event Sourcing" width="1360" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – CQRS command and Event Sourcing</p>
			<p>The <strong class="bold">service</strong> receives a command from the <strong class="bold">requester</strong>. The <strong class="bold">service</strong> requires the current state of the aggregate, which is rebuilt by replaying events retrieved from the <strong class="bold">Event Store</strong>. The <strong class="bold">command</strong> passes the validation, so a new event is generated. The new event is played on the aggregate to generate a new state. The new event is appended to the <strong class="bold">Event Store</strong> and the updated aggregate is returned to the <strong class="bold">requester</strong>.</p>
			<p>Event Sourcing answered the question from CQRS of how to update an aggregate and inform subscribers of the changes to an aggregate. CQRS answered the question from Event Sourcing of how an event was created.</p>
			<p>The query, in turn, rebuilds the current state of the application by replaying the events stored in the event store. Also, multiple read models are rebuilt by transforming the event payloads to build their unique data structures. An example of how CQRS query and Event Sourcing <a id="_idIndexMarker803"/>integrate is shown in <em class="italic">Figure 9</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21737_09_6.jpg" alt="Figure 9.6 – CQRS query and Event Sourcing" width="1121" height="627"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – CQRS query and Event Sourcing</p>
			<p>Event Sourcing provides a way for a CQRS query to rebuild a snapshot of a given aggregate. It enables the query to build any given read model as per the request. It also permits building a historical view of the aggregate from a given timestamp.</p>
			<p>This separation of <a id="_idIndexMarker804"/>concerns between the command and query models, combined with the event-driven nature of Event Sourcing, allows highly scalable, flexible, and maintainable systems that can easily adapt to changing business requirements.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor330"/>Using CQRS and Event Sourcing together</h2>
			<p>Extending from the <a id="_idIndexMarker805"/>previous example of Event Sourcing, adding CQRS would require a couple of command and query classes to be created. We will need a class to capture the query of the current state of a contract among households and a class to capture the command for drafting a contract. The corresponding code is shown here:</p>
			<pre class="source-code">
data class CurrentContractQuery(
    val contractId: UUID
)
data class DraftContractCommand(
    val draftedByHousehold: String,
    val counterpartyHousehold: String,
    val serviceProvided: String,
    val serviceReceived: String,
)
data class AgreeContractCommand(
    val contractId: UUID,
    val agreedByHousehold: String,
)</pre>			<p>You will find these command classes look quite like the event classes. The differences are as follows:</p>
			<ul>
				<li>The command that creates the aggregate does not contain the aggregate ID</li>
				<li>The command does not contain the aggregate version or the timestamp</li>
			</ul>
			<p>This is because the aggregate ID, version, and timestamp are populated when handling the commands. In this example, command handling is not idempotent. It uses randomization for aggregate IDs and a system clock to stamp timestamps.</p>
			<p>There could be various implementations that supply random values and system timestamps to make command handling idempotent. Both approaches can be justified if they are consistent and well understood.</p>
			<p>In this example, the handling of every command has two potential outcomes. A successful outcome creates an event, and this event needs to be persisted. A failure outcome will inform the callers of the cause, and no event will be created. It is necessary to have a class to<a id="_idIndexMarker806"/> encapsulate the information for a failure outcome:</p>
			<pre class="source-code">
data class Failure&lt;T&gt;(
    val request: T,
    val message: String? = null,
    val error: Throwable? = null
)</pre>			<p>The <code>Failure</code> class contains the original request, an optional message, and an optional <code>Throwable</code> object.</p>
			<p>Each query and command requires a handler. Taking advantage of the <code>EventStore</code> class in the example of Event Sourcing, the query handler is straightforward with the use of Kotlin extensions and the event store as a parameter:</p>
			<pre class="source-code">
fun CurrentContractQuery.handle(
    eventStore: EventStore&lt;UUID, ContractEvent&gt;
): Contract? = eventStore.get(contractId)?.play()</pre>			<p>The query handler simply gets all the events for the given <code>contractId</code> and then plays all events to re-create the latest version of <code>Contract</code> as the return value.</p>
			<p>The command handler has two main styles: creating and updating. The handler for the creation command generates a <a id="_idIndexMarker807"/>random <strong class="bold">Universally unique identifier</strong> (<strong class="bold">UUID</strong>) and the timestamp. These fields are captured in the creation event:</p>
			<pre class="source-code">
fun DraftContractCommand.handle(
    eventStore: EventStore&lt;UUID, ContractEvent&gt;,
    onSuccess: (ContractDraftedEvent) -&gt; Unit,
    onFailure: (Failure&lt;DraftContractCommand&gt;) -&gt; Unit
) {
    if (draftedByHousehold == counterpartyHousehold) {
        onFailure(Failure(this, "Same household is not allowed: $draftedByHousehold"))
    } else {
        ContractDraftedEvent(
            contractId = UUID.randomUUID(),
            time = Instant.now(),
            draftedByHousehold = draftedByHousehold,
            counterpartyHousehold = counterpartyHousehold,
            serviceReceived = serviceReceived,
            serviceProvided = serviceProvided
        ).also{
            eventStore.append(it.contractId, it)
        }.also(onSuccess)
    }
}</pre>			<p>The command handler <a id="_idIndexMarker808"/>requires two callback functions, one for success and one for failure. Only one of the callback functions is invoked during the execution. If the command fails validation (in this case, when the same household is used for the draft contract), no event is created and the failure callback function is invoked. Otherwise, an event is created to capture the randomized contract ID, the time of the event, and the rest of the fields. The event is persisted to the event store. The event is then passed to the success callback function.</p>
			<p>The handler for the update command requires validation of whether the aggregate exists, and whether the same aggregate ID is retained. The rest of the implementation is the handler for the create command:</p>
			<pre class="source-code">
fun AgreeContractCommand.handle(
    eventStore: EventStore&lt;UUID, ContractEvent&gt;,
    onSuccess: (ContractAgreedEvent) -&gt; Unit,
    onFailure: (Failure&lt;AgreeContractCommand&gt;) -&gt; Unit) {
    validate(
        eventStore = eventStore,
        contractId = contractId,
        householdName = agreedByHousehold,
        onSuccess = { contract -&gt;
            ContractAgreedEvent(
                contractId = contractId,
                targetVersion = contract.version + 1,
                time = Instant.now(),
                agreedByHousehold
            ).also { eventStore.append(contractId, it)
            }.also(onSuccess)
        },
        onFailure = { onFailure(it)}
    )
}</pre>			<p>There is a <code>validate</code> function<a id="_idIndexMarker809"/> that is meant to be shared with other update command handlers:</p>
			<pre class="source-code">
fun &lt;T&gt; T.<strong class="bold">validate</strong>(
    eventStore: EventStore&lt;UUID, ContractEvent&gt;,
    contractId: UUID,
    householdName: String,
    onSuccess: (Contract) -&gt; Unit,
    onFailure: (Failure&lt;T&gt;) -&gt; Unit) {
    val events = eventStore.get(contractId)
    if (events == null) {
        onFailure(Failure(this, "Contract not found: $contractId"))
    } else {
        val contract = events.play()
        if (contract == null) {
            onFailure(Failure(this, "Failed to reconstruct Contract: $contractId"))
        } else if (contractId != contract.id) {
            onFailure(Failure(this, "Contract ID mismatched. Expected: $contractId, was: ${contract.id}"))
        } else if (householdName != contract.partyA.householdName
            &amp;&amp; householdName != contract.partyB.householdName) {
            onFailure(Failure(this, "Household not found in contract: $householdName"))
        } else {
            onSuccess(contract)
        }
    }
}</pre>			<p>The success callback <a id="_idIndexMarker810"/>function will have the <code>Contract</code> passed in because the latest version of the aggregate has been found and re-created. The failure callback function will have the <code>Failure</code> object passed in for delegation.</p>
			<p>Finally, when using this example of CQRS and Event Sourcing, the client only needs to create a command and pass it in the event store to start with. Then, the extension <code>handle</code> function is invoked:</p>
			<pre class="source-code">
    var contractId: UUID? = null
    val eventStore = EventStore&lt;UUID, ContractEvent&gt;()
    <strong class="bold">DraftContractCommand</strong>(
        draftedByHousehold = "HouseholdA",
        counterpartyHousehold = "HouseholdB",
        serviceProvided = "Cleaning",
        serviceReceived = "Babysitting"
    ).handle(
        eventStore = eventStore,
        onSuccess = { contractId = it.contractId
            println("Contract drafted: $contractId") },
        onFailure = { "Failed to draft contract: $it"}
    )
    <strong class="bold">AmendContractCommand</strong>(
        contractId = contractId!!,
        amendedByHousehold = "HouseholdB",
        serviceReceivedUpdate = "Dish washing",
        serviceProvidedUpdate = null
    ).handle(eventStore = eventStore,
        onSuccess = { println("Contract amended: $contractId") },
        onFailure = { println("Failed to amend contract: $contractId")}
    )</pre>			<p>The success<a id="_idIndexMarker811"/> callback function captures <code>contractId</code> for future updates. To update the aggregate, an update command needs to be created and the contract ID needs to be specified. Afterwards, the <code>handle</code> extension function is invoked:</p>
			<pre class="source-code">
    <strong class="bold">AgreeContractCommand</strong>(
        contractId = contractId!!,
        agreedByHousehold = "HouseholdA"
    ).handle(eventStore = eventStore,
        onSuccess = { println("Contract agreed: $contractId") },
        onFailure = { println("Failed to amend contract: $contractId")}
    )
    <strong class="bold">AgreeContractCommand</strong>(
        contractId = contractId!!,
        agreedByHousehold = "HouseholdB"
    ).handle(eventStore = eventStore,
        onSuccess = { println("Contract agreed: $contractId") },
        onFailure = { println("Failed to amend contract: $contractId")}
    )</pre>			<p>After all these updates, we can query the latest <code>Contract</code> and see if all these updates have <a id="_idIndexMarker812"/>accumulated. A query is created with the captured contract ID. The <code>handle</code> extension function is invoked, and the event store is passed in:</p>
			<pre class="source-code">
    val aggregate = CurrentContractQuery(contractId!!).handle(eventStore)
    println("Aggregate is of version: ${aggregate?.version}")</pre>			<p>Because the event store keeps on capturing events as commands are handled, it already has the full history of the aggregate. This is the console output you get after executing all the commands and queries:</p>
			<pre class="console">
Contract drafted: 3a25642c-fc9b-4024-b862-daf10fc645a6
Contract amended: 3a25642c-fc9b-4024-b862-daf10fc645a6
Contract agreed: 3a25642c-fc9b-4024-b862-daf10fc645a6
Contract agreed: 3a25642c-fc9b-4024-b862-daf10fc645a6
Aggregate is of version: 3</pre>			<p>This example has illustrated the powerful combination of CQRS and Event Sourcing at work. They complement each other and work together seamlessly. It has also demonstrated that each command and query has its own class and functions. This breaks down the traditional CRUD approach, where there are usually repository classes that contain all<a id="_idIndexMarker813"/> four types of operations in a big file.</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor331"/>Outbox pattern</h2>
			<p>It is worth pointing <a id="_idIndexMarker814"/>out that in real systems, there is a trend to<a id="_idIndexMarker815"/> also apply the <strong class="bold">Outbox</strong> pattern to manage the delivery of events in a reliable and fault-tolerant manner. This is implemented by having an outbox of messages in persistent storage, such as a relational database table.</p>
			<p>There is a separate process that reads the unsent outbox messages and delivers them to the target destinations. If a message is delivered, the corresponding record is considered sent and will be deleted.</p>
			<p>If the event store is unavailable, this delivery process will retry delivery automatically until the event store is operational again. The delivery process can also scale independently and potentially deliver messages to different destinations in parallel.</p>
			<p>A similar pattern to the Outbox <a id="_idIndexMarker816"/>pattern is the <strong class="bold">Change Data Capture</strong> (<strong class="bold">CDC</strong>) pattern. CDC detects changes to records by database triggers, transaction logs, or change trackers and creates an event. The created event eventually goes into the event stream or topic. While events are created before the Outbox process, events are retrospectively created in CDC. That means that CDC is less intuitive in capturing the intent of the event.</p>
			<p>Traditional relational databases provide strong consistency and transactional guarantees. This means we can have one transaction for normal database operations and event delivery as database records for either Outbox or CDC, achieving the all-or-none transactional behavior.</p>
			<p>By storing the Outbox messages in relational databases, the reliability, fault tolerance, consistency, and <a id="_idIndexMarker817"/>scalability <a id="_idIndexMarker818"/>of event sending are also improved.</p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor332"/>Popular frameworks and infrastructure for CQRS and Event Sourcing</h1>
			<p>CQRS and Event Sourcing are<a id="_idIndexMarker819"/> architecture concepts that do not rely on a particular technology or framework. They are also agnostic to programming languages. However, there are frameworks and infrastructure that aim to support CQRS or Event Sourcing.</p>
			<ul>
				<li>CQRS / Event Sourcing frameworks:<ul><li>Axon framework (<a href="https://www.axoniq.io/products/axon-framework">https://www.axoniq.io/products/axon-framework</a>)</li><li>Akka (<a href="https://akka.io/">https://akka.io/</a>)</li></ul></li>
				<li>Event stores:<ul><li>EventStore (<a href="https://www.eventstore.com/">https://www.eventstore.com/</a>)</li><li>Apache Cassandra (<a href="https://cassandra.apache.org/">https://cassandra.apache.org/</a>)</li><li>MongoDB (<a href="https://www.mongodb.com/">https://www.mongodb.com/</a>)</li></ul></li>
				<li>Messaging infrastructure:<ul><li>RabbitMQ streams (<a href="https://www.rabbitmq.com/docs/streams">https://www.rabbitmq.com/docs/streams</a>)</li><li>Apache Kafka (<a href="https://kafka.apache.org/">https://kafka.apache.org/</a>)</li></ul></li>
			</ul>
			<p>It is important to mention that using these tools does not automatically make CQRS or Event Sourcing work in your system. Your current framework and infrastructure may already be ready <a id="_idIndexMarker820"/>for these architecture styles, as long as the team implements the system using the semantics of CQRS and Event Sourcing.</p>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor333"/>Summary</h1>
			<p>We began by covering the classic CRUD architecture and its limitations. Then, we introduced Event Sourcing as an alternative approach to managing data and explored its history. We delved into how a team can decide whether Event Sourcing should be considered in their systems.</p>
			<p>We used the real-life example of villagers exchanging services to demonstrate how Event Sourcing can be implemented. We also briefly laid out a plan for how a CRUD system can migrate to Event Sourcing.</p>
			<p>Afterward, we moved to the topic of CQRS architecture. We discussed using commands as write operations and queries as read operations. We mentioned the basic constructs of CQRS and how they relate to the DDD and Event Sourcing architectures. We saw a side-by-side comparison of CRUD and CQRS in breaking down multiple update operations.</p>
			<p>We then discussed using both CQRS and Event Sourcing. We described how these two architectures complement each other with the extension of the real-life example.</p>
			<p>Lastly, we briefly covered using the Outbox pattern with CQRS and Event Sourcing.</p>
			<p>In the next chapter, we are going to discuss the idempotence, replication, and recovery aspects of distributed systems.</p>
		</div>
	</div></div></body></html>