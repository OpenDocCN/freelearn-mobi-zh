<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;User Interface"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. User Interface</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>While it may seem that we have created the bulk of our game, there is one very important thing that is still missing — the<span class="strong"><strong> User Interface</strong></span> (UI). Creating UIs is very important, as this is the real look and feel that your game will have for your users. If you have a generic interface, no matter how your models look, the game will feel generic. There are many ways that you can design a UI in Unity, but most of those are designed for desktop applications and will perform poorly on mobile devices. We will examine the standard Unity library facility for building our UI and we will build a UI with the Prime31 UIToolkit.<a id="id401" class="indexterm"/>
</p></blockquote></div><p>In this chapter we shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use the native Unity interface system</li><li class="listitem" style="list-style-type: disc">Explore the popular third-party Prime31 UIToolkit approach for generating interfaces<a id="id402" class="indexterm"/></li></ul></div><p>After we finish this chapter we will have all of the tools at our disposal to create almost any type of game we want to create.</p><p>So lets get on with it...</p><div class="section" title="Important preliminary points"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec01"/>Important preliminary points</h1></div></div></div><p>This chapter assumes that you understand the basic concepts of tools such as GIMP and Photoshop including layers, masks, and fills. While the screens in the chapter will be focussed primarily on Photoshop, all of the concepts utilized here are easily transferrable to other software.<a id="id403" class="indexterm"/>
</p></div></div>
<div class="section" title="Translating the design"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec02"/>Translating the design</h1></div></div></div><p>The design sketch of Battlecry's user interface design should be able to display some simple assets for displaying the player's current health, the score of the game, a joystick, and an action button.<a id="id404" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_1.jpg" alt="Translating the design"/></div><p>We covered the joystick and action button in the Input chapter so we can focus on the health display and showing the score. We need a nice font for displaying text and some images to show the health. In addition, we will want to build a main menu for the game that will consist of a button to start the game and one that will show the credits.</p><div class="section" title="Immediate mode game user interfaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec01"/>Immediate mode game user interfaces</h2></div></div></div><p>The Unity game engine provides developers with a complete integrated system for game user interface (GUI) development. These GUIs are built using an immediate mode approach to defining the GUI and responding to its events. For most games this will not be an issue and will be one of the easiest ways for you to put a HUD and simple controls on the screen. However, as it is an immediate mode API, the developer is very close to the mechanics of how the UI operates.<a id="id405" class="indexterm"/>
</p><p>As an example, we can look at how to construct a simple GUI that displays a button on the screen. As you might have guessed, since there are no tools, and as we're in immediate mode, we have to manually specify the layout for the components on the screen.</p><div class="informalexample"><pre class="programlisting">function OnGUI () {
if (GUI.Button (Rect (10,10,150,100), "I am a button")) {
print ("You clicked the button!");
}
}
</pre></div><p>Despite how different this may feel from hopping into Flash, Photoshop, Objective-C, or your favorite GUI framework, immediate mode GUIs are nothing new. In a traditional GUI framework, you setup your GUI components in a variety of classes and then setup callbacks and messaging systems so that the event loop can relay data from the components to the actual application logic that will handle the events. So what's wrong with this, you may ask. At the end of the day you will find that you have code all over your application — especially if you're really trying to be object-oriented and are designing your application for reuse.</p><p>While this is something that makes sense for a complex business application that may have to change its layout dynamically based on user-type, screen resolution, or the data being used, that is not the problem that we're trying to solve with our game. You will find that an immediate mode GUI is very compact, with all of the logic that makes your game work generally in a small number of places. Any state data necessary for the UI is made available to all of the interface components without the need for querying or passing data. This makes the application easier to follow and is very performance friendly.</p></div></div>
<div class="section" title="Time for action &#x2014; Creating the menu background"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec03"/>Time for action —  Creating the menu background</h1></div></div></div><p>The first thing we need to do is create a background for the main menu of our game. This will give us a chance to see how to setup Unity GUI components. To keep things simple, initially we will start with the main menu.<a id="id406" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new scene called<span class="strong"><strong> MainMenu</strong></span>.</li><li class="listitem">As this is a military style game we can use a simple camouflage texture for the background of our main menu.<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_2.jpg" alt="Time for action — Creating the menu background"/></div><p>On top of this we will display the buttons for our game. While it is possible for us
to modify our existing <span class="strong"><strong>GameIntro</strong></span> scene to handle a main menu, it is better from a
design perspective to create a standalone scene for the main menu. This will aid the
development workflow as content creators can work on this scene in isolation.
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_3.jpg" alt="Time for action — Creating the menu background"/></div></li><li class="listitem">After adding our<span class="strong"><strong> MainMenu</strong></span> scene we need to make a change to our<code class="literal"> PlayIntroMovie</code> script to have it load the<span class="strong"><strong> MainMenu</strong></span> scene instead of just dropping directly into the game.<a id="id407" class="indexterm"/><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class PlayIntroMovie : MonoBehaviour {
// Use this for initialization
IEnumerator Start () {
iPhoneUtils.PlayMovie("Snowpocalypse2011.m4v", Color.black, iPhoneMovieControlMode.CancelOnTouch, iPhoneMovieScalingMode.AspectFill );
yield return null;
<span class="strong"><strong>Application.LoadLevel("MainMenu");
</strong></span>
}
}
</pre></div></li><li class="listitem">The next step is to import the texture that we will be using for the background. In the project folder for this chapter you will find the asset<code class="literal"> army_camo.jpg</code>. If you drag this into Unity it will be imported and ready for use. However, there are a few settings we want to change for our iOS release. If you display the<span class="strong"><strong> Inspector</strong></span> settings for the asset you will find that it is imported at 1024x1024. However, for our iOS game, we don't want such a large texture simply as a background.</li><li class="listitem">Override the settings for this texture for our iOS device by selecting the iPhone icon and checking the box to override the settings for iPhone. Set the<span class="strong"><strong> Max Size</strong></span> for this texture to<span class="strong"><strong> 512</strong></span> and click on the<span class="strong"><strong> Apply</strong></span> button.<a id="id408" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_4.jpg" alt="Time for action — Creating the menu background"/></div><p>Now our texture for iOS will only be 512x512, while it can be 1024x1024 for other
platforms. From a workflow perspective this is important, as you will want to
override your assets for the platform you're deploying to, while not creating entirely
new assets for each platform.
</p></li><li class="listitem">Our next step is to make this image the background of the scene. Select the texture that we just imported in the<span class="strong"><strong> Project</strong></span> view and create a<span class="strong"><strong> GUI Texture</strong></span>.<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_5.jpg" alt="Time for action — Creating the menu background"/></div></li><li class="listitem">Change the scale of our background texture to (1,1,1) so that it is scaled to fill the screen. Since a<span class="strong"><strong> GUITexture</strong></span> is a Unity UI construct specifically for UI elements, all of its position and scale is done in screen space as opposed to world space. By setting this to<span class="strong"><strong> 1</strong></span> in all dimensions. We're telling Unity to fill the screen with our<span class="strong"><strong> GUITexture</strong></span>. The Z-axis in this case is the same as for prior chapters. If you need to draw other items in front of the background, they simply need to have a lower Z value than the background.<a id="id409" class="indexterm"/><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note12"/>Note</h3><p>We did not have to make the<span class="strong"><strong> GUITexture</strong></span> a child of the camera for this to happen.</p></div><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_6.jpg" alt="Time for action — Creating the menu background"/></div></li><li class="listitem">Run the project and you will see a camouflage texture that fills the entire screen.<a id="id410" class="indexterm"/></li></ol></div><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_7.jpg" alt="Time for action — Creating the menu background"/></div></div>
<div class="section" title="What just happened?"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec04"/>What just happened?</h1></div></div></div><p>We have just created a background for our main menu scene. As you have noticed, this item is not parented to any part of the scene and will display without respect to any other items in the scene. Now we can move on to adding buttons to our menu.<a id="id411" class="indexterm"/>
</p><div class="section" title="Putting the menu on the screen"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec02"/>Putting the menu on the screen</h2></div></div></div><p>To make the immediate mode GUI work with Unity we simply need to provide one function in a script,<code class="literal"> OnGUI</code>. Like any other script we will attach our UI script to a<span class="strong"><strong> GameObject</strong></span> that is located in the scene and Unity will call it every frame to ensure that any GUI events that have happened during that frame are processed. One obvious warning is that this means that your GUI loops should be tight loops and highly optimized; you shouldn't be performing complex time-consuming computations inside the GUI code.<a id="id412" class="indexterm"/>
</p><p>If we look back at our main menu example we know that we have two simple buttons that need to perform very specific actions when clicked. Thus, from a pseudo code perspective, we know that our application simply needs a basic if/else condition to examine the two controls that we're using.<a id="id413" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">// Use this for initialization
if ( MainMenuButton( control_x, control_y, width, height) )
{
loadMainGameScene();
}
else if ( CreditsMenuButton( control_x, control_y, width, height) )
{
loadCreditsScreen();
}
</pre></div><p>In this example<code class="literal"> MainMenuButton</code> and<code class="literal"> CreditsMenuButton</code> represent two GUI controls that we will define in our script that will cause the main scene or credits scene to be opened respectively.</p></div></div>
<div class="section" title="Time for action &#x2014; Adding buttons to the GUI"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec05"/>Time for action —  Adding buttons to the GUI</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Import the two textures from the assets folder<code class="literal"> BTN_StartGame</code> and<code class="literal"> BTN_Credits</code>. These will be used to build our main menu.<a id="id414" class="indexterm"/><p>You will also notice that these textures are somewhat larger than the buttons they
contain. This was done because by default Unity will expect that your textures are
some power of 2. We will address this limitation later.
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_8.jpg" alt="Time for action — Adding buttons to the GUI"/></div></li><li class="listitem">Create an empty game object called<span class="strong"><strong> Menu Object</strong></span>.<a id="id415" class="indexterm"/><p>Going back to our original foray into scripting, we know that we need some game
object in our scene in order for our script to run. Since this object doesn't need to be
displayed, or have any particular game functionality, we can simply insert an empty
game object into the scene and attach our script to that.
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_9.jpg" alt="Time for action — Adding buttons to the GUI"/></div></li><li class="listitem">As we are going to be building an immediate mode GUI, it follows that we're going to have some script that drives the display of our GUI. Create a script called<code class="literal"> MainMenu</code> and attach it to the<span class="strong"><strong> MenuObject</strong></span> game object.</li><li class="listitem">Define two public variables in the<code class="literal"> MainMenu</code> script, which will allow us to specify the button textures for the main menu commands.<p>When we originally imported the textures for our buttons Unity imported them as
Texture2Ds. If we configure our script to take in Texture2Ds we can use the Unity
GUI to configure the textures we want to display as opposed to having to hard code
this value in our code. We can accomplish this by defining public attributes on the
class which defines our script.
</p><div class="informalexample"><pre class="programlisting">public Texture2D mainMenuButton;
public Texture2D creditsMenuButton;
</pre></div></li><li class="listitem">Next we need to update our<code class="literal"> OnGUI</code> method to display the buttons for the main menu. We want the Texture2Ds we imported earlier to show up as buttons in our interface so we need to use the Unity GUI system to render them as buttons.<a id="id416" class="indexterm"/><p>
Unity has an easy to use <code class="literal">GUI.Button
</code> class that performs this function. <code class="literal">GUI. Button
</code> allows us to create a button on the interface with coordinates that are in
screen space. We do this by defining a rectangle <code class="literal">(Rect)</code> with the position on the
screen where this button will be drawn as the first two arguments and the width and
height as the second two components.
</p><div class="informalexample"><pre class="programlisting">Rect( x, y, width, height )
</pre></div><p>
When combined with the normal <code class="literal">GUI.Button()
</code> method call we get the following:
</p><div class="informalexample"><pre class="programlisting">
void OnGUI()
{
GUI.Button( new Rect ( 0, 0, 256, 256 ), mainMenuButton );
}
</pre><p>Here we are creating a new button at the upper left corner of the screen with a size
of 256x256 and defining the <code class="literal">mainMenuButton
</code> as the Texture2D that should be
drawn in this button.
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_13.jpg" alt="Time for action — Adding buttons to the GUI"/></div></div></li><li class="listitem">Next we need to tell the Unity GUI to perform an action in response to someone pressing that button. As in the pseudo code, this involves wrapping the button with an if statement — which will be evaluated in the<code class="literal"> OnGUI</code>.<a id="id417" class="indexterm"/></li><li class="listitem">Add the<code class="literal"> creditsMenuButton</code> and center the buttons on the screen by updating the Rects for the original<code class="literal"> GUI.Buttons</code>.<div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class MainMenu : MonoBehaviour {
public Texture2D mainMenuButton;
public Texture2D creditsMenuButton;
// Process the GUI
void OnGUI () {
int componentWidth = 256;
int componentHeight = 256;
int interfaceOrigin = 0;
if (GUI.Button( new Rect ( Screen.width / 2 - componentWidth/2, interfaceOrigin, componentWidth, componentHeight ), mainMenuButton) )
{
Debug.Log("You clicked the start button ");
}
else if (GUI.Button( new Rect ( Screen.width / 2 - componentWidth/2, interfaceOrigin + componentHeight, componentWidth, componentHeight ), creditsMenuButton) )
{
Debug.Log("You clicked the credits button ");
}
}
}
</pre><p>
While there are other ways to do this in Unity using GUI Groups, this will suit our
purposes better as an instructional tool. If we render our scene now, we will find
two buttons which contain our button textures:
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_10.jpg" alt="Time for action — Adding buttons to the GUI"/></div><p>Pressing these buttons will show some debug text in the console:
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_14.jpg" alt="Time for action — Adding buttons to the GUI"/></div></div><p>
While this allows our buttons to be rendered, there is more GUI Button being
rendered than we want. The Unity GUI has its own style engine defined in
<code class="literal">GUIStyle
</code>, which determines how a button should be drawn. As we have baked the
look and feel of our buttons into the textures themselves, we don't need Unity to
display any of this style.
</p></li><li class="listitem">Update the<code class="literal"> GUIStyle</code> of the<code class="literal"> GUI.Buttons</code> so that they have no associated style.<div class="informalexample"><pre class="programlisting">if (GUI.Button( new Rect ( Screen.width / 2 - componentWidth/2, interfaceOrigin, componentWidth, componentHeight ), startButton, GUIStyle.none) )
{
Debug.Log("You clicked the start button ");
}
</pre><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_11.jpg" alt="Time for action — Adding buttons to the GUI"/></div></div><p>By making this simple change we will get the GUI rendered exactly how we
intended.
</p></li><li class="listitem">Update the script to load the Unity levels when the buttons are pressed.<div class="informalexample"><pre class="programlisting">if (GUI.Button( new Rect ( Screen.width / 2 - componentWidth/2, interfaceOrigin, componentWidth, componentHeight ), startButton, GUIStyle.none) ))
{
Debug.Log("You clicked the start button ");
Application.LoadLevel("IntroCity");
}
</pre></div></li></ol></div><p>By making the call to<code class="literal"> Application.LoadLevel</code> as we have previously, we now have a mechanism for pressing a button in the interface and having Unity load a particular scene.<a id="id418" class="indexterm"/>
</p><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec03"/>What just happened?</h2></div></div></div><p>We have just constructed a simple immediate mode GUI to display the main menu for our game. We have accomplished this by using the Unity GUI system and building a script which renders our GUI. Under the covers, what Unity is doing is drawing our scene every frame, based upon the script. It is important to note that if you were to change the script so that, programmatically, it were to display certain things based upon some setting or every third frame, Unity will do that because it is processing the UI script each and every frame. Accordingly it is important to not perform any extremely complex operations in the<code class="literal"> OnGUI</code> method as it could result in a substantial performance slowdown.<a id="id419" class="indexterm"/>
</p></div><div class="section" title="A better way — UIToolkit"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec04"/>A better way — UIToolkit</h2></div></div></div><p>One of the issues with the current implementation of the Unity GUI library is that it was designed for PC users and doesn't take into account any of the limitations of mobile devices. While it performs well enough in some situations, in most situations the number of draw calls it generates are enough to wreck the performance of your game.<a id="id420" class="indexterm"/>
</p><p>In our previous example it is not possible to really see the impact of the performance slowdown because we aren't doing any rendering that is intense enough to impact the frame rate. As our scene is pretty static, one wouldn't be able to visually measure the result. However, if we look at our statistics we can see that even for this very modest GUI we're utilizing three draw calls — one for each GUI component.<a id="id421" class="indexterm"/>
</p><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_15.jpg" alt="A better way — UIToolkit"/></div><p>This may not seem like much now, but as you learn more in the chapter on optimization, this is a substantial amount of work that the iOS device is doing. So what if we could accomplish the same amount of work within a single draw call? What if we could have only one draw call regardless of the number of GUI elements we're drawing? Enter Prime31's UIToolkit.<a id="id422" class="indexterm"/>
</p></div></div>
<div class="section" title="Time for action &#x2014; Prime31 UIToolkit"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec06"/>Time for action —  Prime31 UIToolkit</h1></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Download<span class="strong"><strong> code'n'web TexturePackerPro</strong></span> essentials by visiting the website:<a id="id423" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_16.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Select the latest available version of TexturePacker from the download list and install TexturePacker:<a id="id424" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_17.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Next, drag the UI buttons for the credits menu and the start game menu into the interface. You can do this by dragging the images into the Sprites menu on the right-hand side of the interface:<a id="id425" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_18.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">We want to use the minimum amount of texture memory possible so set the<span class="strong"><strong> Max. width</strong></span> and<span class="strong"><strong> Max. height</strong></span> to the smallest power of 2 possible. Your texture will still need to be square so you're looking for the smallest number that box width and height can be set to simultaneously. In our case it is 512. If<span class="strong"><strong> TexturePacker</strong></span> cannot find a way to fit your textures into that size it will turn the text red.<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_19.jpg" alt="Time for action — Prime31 UIToolkit"/></div><p>
One benefit that you may not have noticed at this point is that before we were
creating textures as large power of 2 textures so that Unity would accept them.
Here TexturePacker is identifying the empty space in the textures and optimizing the
amount of space each texture takes. In this case we actually have additional space
where we could pack more textures if we needed to.
</p></li><li class="listitem">In the<span class="strong"><strong> Output settings</strong></span> (scroll the left pane to the bottom) set the<span class="strong"><strong> Data format</strong></span> to<span class="strong"><strong> JSON</strong></span> (Javascript Object Notation) and set the directory to your project's<code class="literal"> Assets</code> folder. Set the name of the file as<code class="literal"> gui</code> and change the extension of the<code class="literal"> .json</code> file to<code class="literal"> .txt</code>, as Unity expects text assets to end with a<code class="literal"> .txt</code> extension.<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_20.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Press the<span class="strong"><strong> Publish</strong></span> button in the toolbar and the appropriate files will be created in your<code class="literal"> Assets</code> folder.<a id="id426" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_21.jpg" alt="Time for action — Prime31 UIToolkit"/></div><p>We are now done with everything we need from TexturePacker.
</p></li><li class="listitem">Download the UIToolkit library from Prime31's github repository by visiting the website at<a class="ulink" href="http://https://github.com/prime31/UIToolkit"> https://github.com/prime31/UIToolkit:</a><a id="id427" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_22.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Select download and choose the .unitypackage option:<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_23.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">After it downloads, install the Unity package, importing all of the items in it:<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_24.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">So that we can examine the 2 different approaches to render GUIs separately, create a new scene for this approach, and name it UIToolkit.<a id="id428" class="indexterm"/></li><li class="listitem">To make sure that our UI components are segregated from the rest of our scene, we want to put them on a particular layer in Unity. Layers are collections of components that can be accessed or manipulated as a collection. If you are familiar with Photoshop, the concept is similar.</li><li class="listitem">In Unity, create a new Layer for our GUI to be drawn on by accessing the Layers through<span class="strong"><strong> Edit | Project Settings</strong></span> |<span class="strong"><strong> Tags:</strong></span><a id="id429" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_25.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Select<span class="strong"><strong> User Layer 8</strong></span> and set the Layer name to<span class="strong"><strong> UI Layer:</strong></span><a id="id430" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_26.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Create an empty game object, name it<span class="strong"><strong> GUIObject</strong></span> and set its position to 0,0,0:<a id="id431" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_27.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Expand the<code class="literal"> Plugins</code> folder in the<span class="strong"><strong> Project</strong></span> view and you will find the<span class="strong"><strong> UIToolkit library. Expand UIToolkit</strong></span> and drag the UI script onto the<span class="strong"><strong> GUIObject:</strong></span><a id="id432" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_28.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Select the<span class="strong"><strong> MainCamera</strong></span> object in the<span class="strong"><strong> Hierarchy</strong></span> view and remove the<span class="strong"><strong> UILayer</strong></span> from the<span class="strong"><strong> Culling Mask</strong></span> to ensure that the UI does not get drawn more than once:<a id="id433" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_29.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Once you select the<span class="strong"><strong> UILayer</strong></span> the<span class="strong"><strong> Culling Mask</strong></span> should be displayed as<span class="strong"><strong> Mixed</strong></span> as shown in the following screenshot:<a id="id434" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_30.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Create a new empty game object called<span class="strong"><strong> UIToolkit</strong></span> and make it a child of the<span class="strong"><strong> GUIObject</strong></span> we created earlier that contains the UI script:<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_31.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Drag the<span class="strong"><strong> UIToolkit</strong></span> script from the<code class="literal"> UIToolkit plugins</code> folder onto the UIToolkit game object in the<span class="strong"><strong> Hierarchy</strong></span> view:<div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_32.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">Select the<span class="strong"><strong> GUIObject</strong></span> node in the<span class="strong"><strong> Hierarchy</strong></span> view to bring up its inspector. Tell it we want the UI to be drawn on the<span class="strong"><strong> UILayer</strong></span> by selecting the drop-down next to the<span class="strong"><strong> UILayer</strong></span> entry and selecting the layer that the UI is to be drawn on — which we have also called<span class="strong"><strong> UILayer:</strong></span><a id="id435" class="indexterm"/><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_33.jpg" alt="Time for action — Prime31 UIToolkit"/></div></li><li class="listitem">To wrap up our configuration we need to tell<span class="strong"><strong> UIToolkit</strong></span> which TexturePacker config we're using. Select the<span class="strong"><strong> UIToolkit</strong></span> node in the<span class="strong"><strong> Hierarchy</strong></span> view to bring up its inspector. In the<span class="strong"><strong> Texture Packer Config Name</strong></span> enter the name of the config that we saved, in this case<span class="strong"><strong> gui:</strong></span><div class="mediaobject"><img src="graphics/978-1-84969-040-9_9_34.jpg" alt="Time for action — Prime31 UIToolkit"/></div><p>
Now we're ready to create our GUI using the textures we used in Texture Packer.
</p></li><li class="listitem">Create a Script called<code class="literal"> UIToolkitGUI</code> and let's add a button to the screen using this new approach:<a id="id436" class="indexterm"/><div class="informalexample"><pre class="programlisting">using UnityEngine;
using System.Collections;
public class UIToolkitGUI : MonoBehaviour {
// Use this for initialization
void Start () {
var mainMenuButton = UIButton.create("BTN_StartGame.png", "BTN_StartGame.png", 0 , 0 );
}
}
</pre></div><p>
Note that the UIToolkit button class takes a normal button state and a pressed
button state. As we didn't have both we just used the same texture for both. The
last two arguments are the position on the screen where we want this button to
show up.
</p></li><li class="listitem">Press play and our button will show up on the screen.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec05"/>What just happened?</h2></div></div></div><p>We just created our GUI using the open source and free library UIToolkit from Prime31. We have accomplished the same thing as our original menu, but with a single draw call. While we could have accomplished similar with UnityGUI, the performance would have gotten progressively worse the more complex the user interface became, as each control added and each GUIStyle rendered results in another draw call.</p><p>In addition, we've come up with a more optimal way to get textures into the UI. Unity, by default, will not allow you to use a non-power of 2 texture for rendering which will result in lots of wasted texture memory at each texture. With this approach we can pack a large number of textures into a single larger texture, which is in itself more efficient, and render textures of wildly different shapes without sacrificing much in texture memory efficiency.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec07"/>Summary</h1></div></div></div><p>In this chapter we have learned how to build a UI for our game. We have explored setting up a UI using the Unity GUI APIs, as well as setting up a UI using the leading third party plugin Prime31 UIToolkit.</p><p>Specifically, we covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to build an immediate mode GUI with the standard GUI library</li><li class="listitem" style="list-style-type: disc">How to build a GUI using the Prime31 UIToolkit</li><li class="listitem" style="list-style-type: disc">Some concerns about GUI performance</li></ul></div><p>Now that we are finished putting together the UI, we need to handle more complex gameplay scripting for our game — which is the focus of our next chapter.</p></div></body></html>