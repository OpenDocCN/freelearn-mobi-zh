<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Adding Services to Domains"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Adding Services to Domains</h1></div></div></div><p>In the previous chapter, we covered the process of getting file objects in the proper domain. In most cases, the file object is the target. However, in this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Emphasize labeling processes—notably Android services run and managed by init</li><li class="listitem" style="list-style-type: disc">Manage the ancillary associated objects created by init</li></ul></div><div class="section" title="Init – the king of daemons"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec49"/>Init – the king of daemons</h1></div></div></div><p>The init<a id="id264" class="indexterm"/> process is vital in a Linux system, and Android is not special in this case. However, Android has its own implementation of init. Init is the first process on<a id="id265" class="indexterm"/> the system, and thus has a <span class="strong"><strong>Process ID</strong></span> (<span class="strong"><strong>PID</strong></span>) of 1. All other processes are the result of a direct <code class="literal">fork()</code> from init, thus all processes eventually are parented under init, either directly or indirectly. Init is responsible for cleaning up and maintaining these processes. For instance, any child process whose parent dies is reparented under init by the kernel. In this way, init can call <code class="literal">wait()</code> (<code class="literal">man 2 wait</code> for more details) to clean up after the process when it exits.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>A process which has terminated but has not had <code class="literal">wait()</code> called is a <span class="strong"><strong>zombie</strong></span> process. The kernel must keep the process data structures around until this call. Failing to do so will consume memory indefinitely.</p></div></div><p>Since init is the root of all processes, it also provides a mechanism to declare and execute commands through its own scripting language. Files using this language to control init are referred to as init scripts, and we have already modified some of them. In the source tree, we used the <code class="literal">init.rc</code> file, which you can reach by navigating to <code class="literal">device/fsl/imx6/etc/init.rc</code>, but on the device, it is packaged with the ramdisk at <code class="literal">/init.rc</code>, and is made available to init, which is also packaged in the ramdisk at <code class="literal">/init</code>.</p><p>To add a service to the init script, you can modihe <code class="literal">init.r</code>e and add a declaration, as follows:</p><div class="informalexample"><pre class="programlisting">service &lt;name&gt; &lt;path&gt; [ &lt;argument&gt;... ]</pre></div><p>Here, <code class="literal">name</code> is the service name, <code class="literal">path</code> is the path to the executable, and <code class="literal">argument</code> are space delimited argument strings to be delivered to the executable in its <code class="literal">argv</code> array.</p><p>For <a id="id266" class="indexterm"/>example, here is the service declaration for <code class="literal">rild</code>, the <span class="strong"><strong>Radio Interface Layer Daemon</strong></span> (<span class="strong"><strong>RILD</strong></span>):</p><div class="informalexample"><pre class="programlisting">Service ril-daemon /system/bin/rild</pre></div><p>It is<a id="id267" class="indexterm"/> often the case that additional service options can and need to be added. The init script <code class="literal">service</code> statement supports a rich assortment of options. For the complete list, refer to the informational file located at <code class="literal">system/core/init/readme.txt</code>. Additionally, we covered the SE for Android-specific changes in <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <span class="emphasis"><em>Android Is Weird</em></span>.</p><p>Continuing to dissect <code class="literal">rild</code>, we see that the rest of the declaration in the UDOO <code class="literal">init.rc</code> is as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Service ril-daemon /system/bin/rild</strong></span>
<span class="strong"><strong>  class main</strong></span>
<span class="strong"><strong>  socket rild stream 660 root radio</strong></span>
<span class="strong"><strong>  socket rild-debug stream 660 radio system</strong></span>
<span class="strong"><strong>  socket rild-ppp stream 660 radio system</strong></span>
<span class="strong"><strong>  user root</strong></span>
<span class="strong"><strong>  group radio cache inet misc audio sdcard_rw log</strong></span>
</pre></div><p>The interesting thing to note here is that it creates quite a few sockets. The <code class="literal">socket</code> keyword in <code class="literal">init.rc</code> is described by the <code class="literal">readme.txt</code> file:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>From the source tree file <code class="literal">system/core/init/readme.txt</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>socket &lt;name&gt; &lt;type&gt; &lt;perm&gt; [ &lt;user&gt; [ &lt;group&gt; [ &lt;context&gt; ] ] ]</strong></span>
</pre></div><p>Create a Unix domain socket named <code class="literal">/dev/socket/&lt;name&gt;</code> and pass its <code class="literal">fd</code> to the launched process. The type must be <code class="literal">dgram</code>, <code class="literal">stream</code>, or <code class="literal">seqpacket</code>. The <code class="literal">user</code> and <code class="literal">group</code> IDs default to <code class="literal">0</code>. The SELinux security context for the socket is <code class="literal">context</code>. It defaults to the service security context, as specified by <code class="literal">seclabel</code>, or is computed based on the service executable file's security context.</p></div></div><p>Let's take a look at this directory and see what we've found.</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/dev/socket # ls -laZ | grep adb</strong></span>
<span class="strong"><strong>srw-rw---- system system u:object_r:adbd_socket:s0 adbd</strong></span>
</pre></div><p>This raises the question, "How did it get into that domain?" Using our knowledge from the previous chapter, we know that <span class="strong"><strong>/</strong></span>
<code class="literal">dev</code> is a <code class="literal">tmpfs</code>, so we know that it did not enter this domain through <code class="literal">xattrs</code>. It must be either a code modification or a type transition. Let's check whether it's a type transition. If it is, we would expect to see a statement in the expanded <code class="literal">policy.conf</code>. SELinux policy is based on the <code class="literal">m4</code> macro language. During builds, it is expanded into <code class="literal">policy.conf</code>, and then compiled. <a class="link" href="ch12.html" title="Chapter 12. Mastering the Tool Chain">Chapter 12</a>, <span class="emphasis"><em>Mastering the Tool Chain</em></span>, has more details on this.</p><p>We can<a id="id268" class="indexterm"/> discover this by using sesearch to find type transitions for <code class="literal">adbd_socket</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sesearch -T -t adbd_socket $OUT/sepolicy</strong></span>
</pre></div><p>As you can see from the empty output, there are zero such lines, so it's not the policy which is doing this but a code change.</p><p>In Linux, processes are created with <code class="literal">fork()</code> followed by <code class="literal">exec()</code>. Because of this, we are able to afford great keywords to search the init daemon. We suspect that the code to set up the socket is just after a call to <code class="literal">fork()</code> in the child processes and before a call to <code class="literal">exec()</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -n fork system/core/init/init.c </strong></span>
<span class="strong"><strong>235: pid = fork();</strong></span>
</pre></div><p>So, the fork we are searching for is on line 235 of <code class="literal">init.c</code>; let's open <code class="literal">init.c</code> in a text editor and take a look. We will find the following snippet to examine:</p><div class="informalexample"><pre class="programlisting">...
NOTICE("starting '%s'\n", svc-&gt;name);

  pid = fork();

  if (pid == 0) {
    struct socketinfo *si;
    struct svcenvinfo *ei;
    char tmp[32];
    int fd, sz;

    umask(077);
    if (properties_inited()) {
      get_property_workspace(&amp;fd, &amp;sz);
      sprintf(tmp, "%d,%d", dup(fd), sz);
      add_environment("ANDROID_PROPERTY_WORKSPACE", tmp);
    }

    for (ei = svc-&gt;envvars; ei; ei = ei-&gt;next)
      add_environment(ei-&gt;name, ei-&gt;value);

    for (si = svc-&gt;sockets; si; si = si-&gt;next) {
      int socket_type = (
        !strcmp(si-&gt;type, "stream") ? SOCK_STREAM :
          (!strcmp(si-&gt;type, "dgram") ? SOCK_DGRAM : SOCK_SEQPACKET));
      int s = create_socket(si-&gt;name, socket_type,
            si-&gt;perm, si-&gt;uid, si-&gt;gid, si-&gt;socketcon ?: scon);
      if (s &gt;= 0) {
        publish_socket(si-&gt;name, s);
      }
...</pre></div><p>According<a id="id269" class="indexterm"/> to <code class="literal">man 2 fork</code>, the return code of <code class="literal">fork()</code> in the child process is <code class="literal">0</code>. The child process executes within this <code class="literal">if</code> statement and the parent skips it. The function <code class="literal">create</code>
<span class="strong"><strong>_</strong></span>
<code class="literal">socket()</code> also seems interesting. It appears to take the name of the service, the type of socket, permissions flags, <code class="literal">uid</code>, <code class="literal">gid</code>, and <code class="literal">socketcon</code>. What is <code class="literal">socketcon</code>? Let's check whether we can trace back to where it is set.</p><p>If we look before <code class="literal">fork()</code>, we can see that the parent process gets its <code class="literal">scon</code> based on two factors:</p><div class="informalexample"><pre class="programlisting">...
    if (svc-&gt;seclabel) {
      scon = strdup(svc-&gt;seclabel);
      if (!scon) {
        ERROR("Out of memory while starting '%s'\n", svc-&gt;name);
        return;
      }
      } else {
...</pre></div><p>The first path through the <code class="literal">if</code> statement occurs when <code class="literal">svc-&gt;seclabel</code> is not null. This <code class="literal">svc</code> structure is populated with the options that can be associated with a service. As a refresher from <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <span class="emphasis"><em>Android Is Weird</em></span>, <code class="literal">seclabel</code> lets you explicitly set the context on a service, hardcoded to the value in <code class="literal">init.rc</code>. The <code class="literal">else</code> clause is a bit more involved and interesting.</p><p>In the <code class="literal">else</code> clause, we get the context of the current process by calling <code class="literal">getcon()</code>. This function, since we're running in init, should return <code class="literal">u:r:init:s0</code> and store it in <code class="literal">mycon</code>. The next function, <code class="literal">getfilecon()</code> is passed the path of the executable, and checks the context of the file itself. The third function is the workhorse here: <code class="literal">security_compute_create()</code>. This takes the <code class="literal">mycon</code>, <code class="literal">fcon</code>, and <code class="literal">target</code> class and computes the security context, <code class="literal">scon</code>. Given these inputs, it tries to determine, based on policy type transitions, what the resulting domain for the child should be. If no transitions are defined, <code class="literal">scon</code> will be the same as <code class="literal">mycon</code>.</p><p>A conditional expression within the <code class="literal">create_socket()</code> function additionally determines the socket context passed. The variable <code class="literal">si</code> is a structure that contains all the options to the socket statement in the init <code class="literal">service</code> section. As specified by the <code class="literal">readme.txt</code> file, <code class="literal">si-&gt;socketcon</code> is the socket context argument. In other words, the socket context can come from one of three places (in descending priority):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">socketcon</code> option on the socket option in the <code class="literal">service</code> declaration</li><li class="listitem" style="list-style-type: disc">The <code class="literal">seclabel</code> option on the <code class="literal">service</code> keyword</li><li class="listitem" style="list-style-type: disc">Dynamically computed from source and target contexts</li></ul></div><p>The socket<a id="id270" class="indexterm"/> context is passed to <code class="literal">create_socket()</code>. Now, let's look at <code class="literal">create_socket()</code>. This function is defined at <code class="literal">system/core/init/util.c:87</code>. The snippets of code around <code class="literal">socket()</code> seem interesting:</p><div class="informalexample"><pre class="programlisting">...
  if (socketcon)
    setsockcreatecon(socketcon);

  fd = socket(PF_UNIX, type, 0);
  if (fd &lt; 0) {
    ERROR("Failed to open socket '%s': %s\n", name, strerror(errno));
    return -1;
  }

  if (socketcon)
    setsockcreatecon(NULL);
...</pre></div><p>The <code class="literal">setsockcreatecon()</code> function sets the process' socket creation context. This means<a id="id271" class="indexterm"/> that the socket created by the <code class="literal">socket()</code> call will have the context set via <code class="literal">setsockcreatecon()</code>. After it's created, the process resets it to the original by using <code class="literal">setsockcreatecon(NULL)</code>.</p><p>The next bit of interesting code is around <code class="literal">bind()</code>:</p><div class="informalexample"><pre class="programlisting">...
  filecon = NULL;
  if (sehandle) {
    ret = selabel_lookup(sehandle, &amp;filecon, addr.sun_path, S_IFSOCK);
    if (ret == 0)
      setfscreatecon(filecon);
  }

  ret = bind(fd, (struct sockaddr *) &amp;addr, sizeof (addr));
  if (ret) {
    ERROR("Failed to bind socket '%s': %s\n", name, strerror(errno));
    goto out_unlink;
  }

  setfscreatecon(NULL);
  freecon(filecon);
...</pre></div><p>Here, we have set the file creation context. The functions are analogous to <code class="literal">setsock_creation()</code>, but work for filesystem objects. However, the <code class="literal">selabel_lookup()</code> function looks in <code class="literal">file_contexts</code> for the context of the file. The part you might be missing is that the call to <code class="literal">bind()</code>, for path-based sockets, creates a file at the path specified in <code class="literal">sockaddr_un struct</code>. So, the socket object and the filesystem node entry <a id="id272" class="indexterm"/>are distinctly separate things and can have different contexts. Typically, the socket belongs to the process' context, and the filesystem node is given some other context.</p></div></div>
<div class="section" title="Dynamic domain transitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec50"/>Dynamic domain transitions</h1></div></div></div><p>We<a id="id273" class="indexterm"/> saw init computing of the contexts for the init sockets, but we never encountered it while setting the domains for child processes. In this section, we will dive into the two techniques to do so: explicit setting with an init script and sepolicy dynamic domain transitions.</p><p>The first way to the domains for child processes is with the <code class="literal">seclabel</code> statement in the init script service declaration. Within the child processes execution after <code class="literal">fork()</code>, we find this statement:</p><div class="informalexample"><pre class="programlisting">if (svc-&gt;seclabel) {
if (is_selinux_enabled() &gt; 0 &amp;&amp; setexeccon(svc-&gt;seclabel) &lt; 0) {
ERROR("cannot setexeccon('%s'): %s\n", svc-&gt;seclabel, strerror(errno));
_exit(127);
}
}</pre></div><p>To clarify, the <code class="literal">svc</code> variable is the structure that contains the service options and arguments, so <code class="literal">svc-&gt;seclabel</code> is <code class="literal">seclabel</code>. If it's set, it calls <code class="literal">setexeccon()</code>, which sets the process' execution context for anything it executes via <code class="literal">exec()</code>. Further down, we see that the <code class="literal">exec()</code> function calls are made. The <code class="literal">exec()</code> syscall never returns on success; it only returns on failure.</p><p>The other way to set the domains for child processes, which is the preferred way, is by using sepolicy. It's preferred because the policy has no dependencies on anything else. By hardcoding a context into init, you're coupling a dependency between the init script and the sepolicy. For instance, if the sepolicy removes a type that was hardcoded in the init script, the init <code class="literal">setcon</code> will fail, but both systems will compile correctly. If you remove a type for a type transition and leave the transition statement, you can catch the error at compile time. Since we looked at the <code class="literal">rild</code> service statement, let's look at the <code class="literal">rild.te</code> policy file located in <code class="literal">sepolicy</code>. We should search for the <code class="literal">type_transition</code> keyword in this file using <code class="literal">grep</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -c type_transition rild.te </strong></span>
<span class="strong"><strong>0</strong></span>
</pre></div><p>No instances of <code class="literal">type_transition</code> are found, but this keyword must exist, similar to files. However, it can be hidden in an unexpanded macro. The SELinux policy files are in the m4 macro language, and they get expanded prior to being compiled. Let's look through <code class="literal">rild.te</code> and check whether we can find some macros. They are distinguished and look like<a id="id274" class="indexterm"/> functions with parameters. The first macro we come across is the <code class="literal">init_daemon_domain(rild)</code> macro. Now, we need to find this <a id="id275" class="indexterm"/>macro's definition in <code class="literal">sepolicy</code>. The m4 language uses the <code class="literal">define</code> keyword to declare macros, so we can search for that:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -n init_daemon_domain * | grep define</strong></span>
<span class="strong"><strong>te_macros:99:define(`init_daemon_domain', `</strong></span>
</pre></div><p>Our<a id="id276" class="indexterm"/> macro is declared in <code class="literal">te_macros</code>, which coincidentally holds all the macros related to <span class="strong"><strong>type enforcement</strong></span> (<span class="strong"><strong>TE</strong></span>). Let's take a look at what this macro does in more detail. First, its definition is:</p><div class="informalexample"><pre class="programlisting">...
#####################################
# init_daemon_domain(domain)
# Set up a transition from init to the daemon domain
# upon executing its binary.
define(`init_daemon_domain', `
domain_auto_trans(init, $1_exec, $1)
tmpfs_domain($1)
')
...</pre></div><p>The commented lines in the preceding code (lines starting with <code class="literal">#</code> in m4), state that it sets up a transition from init to the daemon domain. This sounds like something we want. However, both the encompassing statements are macros, and we need to recursively expand them. We will start with <code class="literal">domain_auto_trans()</code>:</p><div class="informalexample"><pre class="programlisting">...
#####################################
# domain_auto_trans(olddomain, type, newdomain)
# Automatically transition from olddomain to newdomain
# upon executing a file labeled with type.
#
define(`domain_auto_trans', `
# Allow the necessary permissions.
domain_trans($1,$2,$3)
# Make the transition occur by default.
type_transition $1 $2:process $3;
')
...</pre></div><p>The comment here indicates that we are headed in the proper direction; however, we need to keep expanding macros in our search. According to the comment, the <code class="literal">domain_trans()</code> macro allows just the transition to occur. Remember that almost everything in SELinux needs explicit permission from the policy in order to happen, including <a id="id277" class="indexterm"/>type transitions. The last statement in the macro is the one we were searching for:</p><div class="informalexample"><pre class="programlisting">type_transition $1 $2:process $3;</pre></div><p>If you expand this statement out, you'll get:</p><div class="informalexample"><pre class="programlisting">type_transition init rild_exec:process rild;</pre></div><p>What this statement conveys is that if you make an <code class="literal">exec()</code> syscall on a file with the type <code class="literal">rild_exec</code>, and the executing domain is init, then make the child process' domain <code class="literal">rild</code>.</p></div>
<div class="section" title="Explicit contexts via seclabel"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec51"/>Explicit contexts via seclabel</h1></div></div></div><p>The other<a id="id278" class="indexterm"/> option for setting contexts is very straightforward. It's hardcoding them with the init script in the <code class="literal">service</code> declaration. In the <code class="literal">service</code> declaration, as we saw in <a class="link" href="ch03.html" title="Chapter 3. Android Is Weird">Chapter 3</a>, <span class="emphasis"><em>Android Is Weird</em></span>, there were modifications to the init language. One of the additions is <code class="literal">seclabel</code>. This option just lets init explicitly change the context of the service to the argument given to <code class="literal">seclabel</code>. Here is an example of <code class="literal">adbd</code>:</p><div class="informalexample"><pre class="programlisting">Service adbd /sbin/adbd
  class core
  socket adbd stream 660 system system
  disabled
  seclabel u:r:adbd:s0</pre></div><p>So why use dynamic transitions on some and <code class="literal">seclabel</code> on others? The answer is dependent on where you're executing from. Things such as <code class="literal">adbd</code> execute early on from the ramdisk, and since the ramdisk really doesn't use per file labels, you can't set up transitions properly—the target has the same context.</p></div>
<div class="section" title="Relabeling processes"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec52"/>Relabeling processes</h1></div></div></div><p>Now that <a id="id279" class="indexterm"/>we are armed with dynamic process transitions, and the ability to set socket contexts from init scripts is needed. Let's attempt to relabel the services that are in improper contexts. We can tell if they're improper by checking them against the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No other process but init should be in the init context</li><li class="listitem" style="list-style-type: disc">No long running process should be in the <code class="literal">init_shell</code> domain</li><li class="listitem" style="list-style-type: disc">Nothing but zygote should be in the zygote domain</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>A more comprehensive test suite is part of CTS on AOSP. Refer to the Android CTS project<a id="id280" class="indexterm"/> for more details: (git clone) <a class="ulink" href="https://android.googlesource.com/platform/cts">https://android.googlesource.com/platform/cts</a>. Take note of the <code class="literal">./hostsidetests/security/src/android/cts/security/SELinuxHostTest.java</code> and <code class="literal">./tests/tests/security/src/android/security/cts/SELinux.*.java</code> tests.</p></div></div><p>Let's run <a id="id281" class="indexterm"/>some basic commands and evaluate the status of our UDOO over the <code class="literal">adb</code> connection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell ps -Z | grep init</strong></span>
<span class="strong"><strong>u:r:init:s0 root 1 0 /init</strong></span>
<span class="strong"><strong>u:r:init:s0 root 2267 1 /sbin/watchdogd</strong></span>
<span class="strong"><strong>u:r:init_shell:s0 root 2278 1 /system/bin/sh</strong></span>
<span class="strong"><strong>$ adb shell ps -Z | grep zygote</strong></span>
<span class="strong"><strong>u:r:zygote:s0 root 2285 1 zygote</strong></span>
</pre></div><p>We have two processes in the improper domains. The first is <code class="literal">watchdogd</code>, and the second is a <code class="literal">sh</code> process. We need to find these and correct them.</p><p>We will start with the mystery <code class="literal">sh</code> program. As you can recall from the previous chapter, our UDOO serial console process had the context of <code class="literal">init_shell</code>, so this is a good suspect. Let's check PIDs and find out. From a UDOO serial console execute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # echo $$ </strong></span>
<span class="strong"><strong>2278</strong></span>
</pre></div><p>We can compare this PID to the PID field in the <code class="literal">adb shell ps</code> output here (PID field is the third field, index 2), and as you can see, we have a match.</p><p>From there, we need to find the service declaration for this. We know that it is in <code class="literal">init.rc</code> since it's running in <code class="literal">init_shell</code>, a type that can only be transitioned to by init directly as per the SELinux policy. Also, init only starts processing things by service declarations, so in order to be in <code class="literal">init_shell</code>, you must start by init via a service declaration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>Use <code class="literal">sesearch</code> to find out such things on the compiled sepolicy binary:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sesearch -T -s init -t shell_exec -c process $OUT/root/sepolicy</strong></span>
</pre></div></div></div><p>If we search <code class="literal">init.rc</code> for the UDOO, which is in <code class="literal">udoo/device/fsl/imx6/etc</code>, we can <code class="literal">grep</code> its contents for <code class="literal">/system/bin/sh</code>, the command in question. If we do that, we will find:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ grep -n "/system/bin/sh" init.rc </strong></span>
<span class="strong"><strong>499:service console /system/bin/sh</strong></span>
<span class="strong"><strong>702:service wifi_mac /system/bin/sh /system/etc/check_wifi_mac.sh</strong></span>
</pre></div><p>Let's<a id="id282" class="indexterm"/> look at <code class="literal">499</code> since we don't have anything to do with Wi-Fi:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>service console /system/bin/sh</strong></span>
<span class="strong"><strong>  class core</strong></span>
<span class="strong"><strong>  console</strong></span>
<span class="strong"><strong>  user root</strong></span>
<span class="strong"><strong>  group root</strong></span>
</pre></div><p>If this is the service in question, we should be able to disable it, and verify that our serial connection no longer works:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell setprop ctl.stop console</strong></span>
</pre></div><p>My live serial connection died at:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # avc: denied { set } for property=ctl.console scontext=u:r:shell:s0 tcontext=u:e</strong></span>
</pre></div><p>Now that we have verified what it is, we can start it back up:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell setprop ctl.start console</strong></span>
</pre></div><p>With the system back in a working state, we now need to address the best way to correct the label on this service. We have two options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using an explicit <code class="literal">seclabel</code> entry in <code class="literal">init.rc</code></li><li class="listitem" style="list-style-type: disc">Using a type transition</li></ul></div><p>The option we will use here is the first. The reason is because init executes shell from time to time, and we don't want all of these in the console processes domain. We want least privilege to segregate the running processes. By using the explicit seclabel, we won't change any of the other shells that are executed along the way.</p><p>To do this, we need to modify the <code class="literal">init.rc</code> entry for console; add:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>service console /system/bin/sh</strong></span>
<span class="strong"><strong>  class core</strong></span>
<span class="strong"><strong>  console</strong></span>
<span class="strong"><strong>  user root</strong></span>
<span class="strong"><strong>  group root</strong></span>
<span class="strong"><strong>  seclabel u:r:shell:s0</strong></span>
</pre></div><p>The proper domain for this executable is <code class="literal">shell</code>, since it should have the same permission set as <code class="literal">adb shell</code>. After you make this change, recompile the bootimage, flash, and then reboot. We can see that it is now in a shell domain. To verify, execute the following from a UDOO serial connection:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # id -Z </strong></span>
<span class="strong"><strong>uid=0(root) gid=0(root) context=u:r:shell:s0</strong></span>
</pre></div><p>Alternatively, execute the following command using <code class="literal">adb</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell ps -Z | grep "system/bin/sh"</strong></span>
<span class="strong"><strong>u:r:shell:s0 root 2279 1 /system/bin/sh</strong></span>
</pre></div><p>The<a id="id283" class="indexterm"/> next one we need to take care of is <code class="literal">watchdogd</code>. The <code class="literal">watchdogd</code> process already has a domain and allows rules in <code class="literal">watchdog.te</code>; so we just need to add a <code class="literal">seclabel</code> statement and get it into this proper domain. Modify <code class="literal">init.rc</code>:</p><div class="informalexample"><pre class="programlisting"># Set watchdog timer to 30 seconds and pet it every 10 seconds to get a 20 second margin
service watchdogd /sbin/watchdogd 10 20
  class core
  seclabel u:r:watchdogd:s0</pre></div><p>To verify using <code class="literal">adb</code>, execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell ps -Z | grep watchdog</strong></span>
<span class="strong"><strong>u:r:watchdogd:s0 root 2267 1 /sbin/watchdogd</strong></span>
</pre></div><p>At this point, we have made actual policy corrections that the UDOO was in need of. However, we need to practice the use of dynamic domain transitions. A good teaching example would have subshells from a shell in their own domain. Let's start by defining a new domain and setting up the transition.</p><p>We will create a new <code class="literal">.te</code> file in <code class="literal">sepolicy</code> called <code class="literal">subshell.te</code>, and edit it so that its contents contain the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>type subshell, domain, shelldomain, mlstrustedsubject;</strong></span>
<span class="strong"><strong># domain_auto_trans(olddomain, type, newdomain)</strong></span>
<span class="strong"><strong># Automatically transition from olddomain to newdomain</strong></span>
<span class="strong"><strong># upon executing a file labeled with type.</strong></span>
<span class="strong"><strong>#</strong></span>
<span class="strong"><strong>domain_auto_trans(shell, shell_exec, subshell)</strong></span>
</pre></div><p>Now, the <code class="literal">mmm</code> trick used earlier in the book can be used to compile just the policy Also, use <code class="literal">adb push</code> command to push the new policy to <code class="literal">/data/security/current/sepolicy</code> and execute <code class="literal">setprop</code> to reload the policy, just as we did in <a class="link" href="ch08.html" title="Chapter 8. Applying Contexts to Files">Chapter 8</a>, <span class="emphasis"><em>Applying Contexts to Files</em></span>.</p><p>To test this, we should be able to type <code class="literal">sh</code>, and verify the domain transition. We will start by getting our current context:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # id -Z</strong></span>
<span class="strong"><strong>uid=0(root) gid=0(root) context=u:r:shell:s0</strong></span>
</pre></div><p>Then execute a shell by doing:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # sh</strong></span>
<span class="strong"><strong>root@udoo:/ # id -Z</strong></span>
<span class="strong"><strong>uid=0(root) gid=0(root) context=u:r:subshell:s0</strong></span>
</pre></div><p>We were able to use a dynamic type transition to get a new process in a domain. If you couple<a id="id284" class="indexterm"/> this with labeling files, as presented in <a class="link" href="ch08.html" title="Chapter 8. Applying Contexts to Files">Chapter 8</a>, <span class="emphasis"><em>Applying Contexts to Files,</em></span> you have a powerful tool to control process permissions.</p></div>
<div class="section" title="Limitations on app labeling"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec53"/>Limitations on app labeling</h1></div></div></div><p>A <a id="id285" class="indexterm"/>fundamental limitation of these dynamic process transitions is that they require an <code class="literal">exec()</code> system call to be made. Only then can SELinux compute the new domain, and trigger the context switch. The only other way to do this is by modifying the code, which essentially is what init is doing when you specify <code class="literal">seclabel()</code>. The init code sets the exec context for its process, causing the next <code class="literal">exec</code> to end up in the specified domain. In fact, we can see this in the <code class="literal">init.c</code> code:</p><div class="informalexample"><pre class="programlisting">if (svc-&gt;seclabel) {
if (is_selinux_enabled() &gt; 0 &amp;&amp; setexeccon(svc-&gt;seclabel) &lt; 0) {
ERROR("cannot setexeccon('%s'): %s\n", svc-&gt;seclabel, strerror(errno));
_exit(127);
}
}</pre></div><p>Here, the child process gets its execute context set by a call to <code class="literal">setexeccon()</code> before the <code class="literal">exec()</code> system call hands over control to a new binary image. In Android, applications are not spawned this way, and no <code class="literal">exec()</code> syscall exists in the process creation path; so a new mechanism will be needed.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Summary</h1></div></div></div><p>In this chapter, we learned how to label processes via type transitions as well as via the <code class="literal">seclabel</code> statements. We also investigated how init manages service sockets, and how to properly label them. We then corrected the process contexts for the serial console as well as the watchdog daemon.</p><p>Applications in Android never have an explicit call to <code class="literal">exec()</code> to start their program execution. Since there is no <code class="literal">exec()</code>, we have to label applications with a code change. In the next chapter, we will address how this happens, and how applications get labeled.</p></div></body></html>