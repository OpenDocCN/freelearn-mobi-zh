["```java\npackage com.gamecodeschool.c1tappydefender;\n\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class MainActivity extends Activity{\n\n    // This is the entry point to our game\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        //Here we set our UI layout as the view\n        setContentView(R.layout.activity_main);\n\n    }\n}\n```", "```java\n//Here we set our UI layout as the view\nsetContentView(R.layout.activity_main);\n\n// Get a reference to the button in our layout\nfinal Button buttonPlay =\n (Button)findViewById(R.id.buttonPlay);\n// Listen for clicks\nbuttonPlay.setOnClickListener(this);\n\n```", "```java\npublic class MainActivity extends Activity \n implements View.OnClickListener{\n\n```", "```java\n@Override\npublic void onClick(View v) {\n  //Our code goes here\n}\n```", "```java\n// must be the Play button.\n// Create a new Intent object\nIntent i = new Intent(this, GameActivity.class);\n// Start our GameActivity class via the Intent\nstartActivity(i);\n// Now shut this activity down\nfinish();    \n```", "```java\n    android:name=\".MainActivity\"\n    ```", "```java\n    android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\n    android:screenOrientation=\"landscape\"\n    ```", "```java\n    android:name=\".GameActivity\"\n    ```", "```java\n    android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\n    android:screenOrientation=\"landscape\"\n    ```", "```java\n    package com.gamecodeschool.c1tappydefender;\n\n    import android.view.SurfaceView;\n\n    public class TDView extends SurfaceView implements Runnable{\n\n    }\n    ```", "```java\npackage com.gamecodeschool.c1tappydefender;\n\nimport android.content.Context;\nimport android.view.SurfaceView;\n\npublic class TDView extends SurfaceView implements Runnable{\n\n    public TDView(Context context) {\n        super(context);\n    }\n}\n```", "```java\n@Override\n    public void run() {\n        while (playing) {\n            update();\n            draw();\n            control();\n        }\n    }\n```", "```java\nprivate void update(){\n\n}\n\nprivate void draw(){\n\n}\n\nprivate void control(){\n\n}\n```", "```java\nvolatile boolean playing;\n```", "```java\n// Clean up our thread if the game is interrupted or the player quits\npublic void pause() {\n        playing = false;\n        try {\n            gameThread.join();\n        } catch (InterruptedException e) {\n\n        }\n    }\n\n    // Make a new thread and start it\n    // Execution moves to our R\n    public void resume() {\n           playing = true;\n           gameThread = new Thread(this);\n           gameThread.start();\n    }\n```", "```java\nvolatile boolean playing;\nThread gameThread = null;\n\n```", "```java\npackage com.gamecodeschool.c1tappydefender;\n\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic class GameActivity extends Activity {\n\n    // This is where the \"Play\" button from HomeActivity sends us\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n    }\n\n    // If the Activity is paused make sure to pause our thread\n    @Override\n    protected void onPause() {\n        super.onPause();\n        gameView.pause();\n    }\n\n    // If the Activity is resumed make sure to resume our thread\n    @Override\n    protected void onResume() {\n        super.onResume();\n        gameView.resume();\n    }\n\n}\n```", "```java\n// Our object to handle the View\nprivate TDView gameView;\n```", "```java\n// Create an instance of our Tappy Defender View (TDView)\n// Also passing in \"this\" which is the Context of our app\ngameView = new TDView(this);\n\n// Make our gameView the view for the Activity\nsetContentView(gameView);\n```", "```java\nprivate Bitmap bitmap;\nprivate int x, y;\nprivate int speed = 0;\n```", "```java\n// Constructor\npublic PlayerShip(Context context) {\n        x = 50;\n        y = 50;\n        speed = 1;\n        bitmap = BitmapFactory.decodeResource \n        (context.getResources(), R.drawable.ship);\n\n    }\n```", "```java\npublic void update() {\n  x++;\n}\n```", "```java\n//Getters\npublic Bitmap getBitmap() {\n  return bitmap;\n}\n\npublic int getSpeed() {\n  return speed;\n}\n\npublic int getX() {\n  return x;\n}\n\npublic int getY() {\n  return y;\n}\n```", "```java\n//Game objects\nprivate PlayerShip player;\n```", "```java\n// For drawing\nprivate Paint paint;\nprivate Canvas canvas;\nprivate SurfaceHolder ourHolder;\n```", "```java\n// Initialize our drawing objects\nourHolder = getHolder();\npaint = new Paint();\n```", "```java\n// Initialize our player ship\nplayer = new PlayerShip(context);\n```", "```java\n// Update the player\nplayer.update();\n```", "```java\nif (ourHolder.getSurface().isValid()) {\n\n  //First we lock the area of memory we will be drawing to\n  canvas = ourHolder.lockCanvas();\n\n  // Rub out the last frame\n  canvas.drawColor(Color.argb(255, 0, 0, 0));\n\n  // Draw the player\n  canvas.drawBitmap(\n    player.getBitmap(), \n    player.getX(), \n    player.getY(), \n    paint);\n\n  // Unlock and draw the scene\n  ourHolder.unlockCanvasAndPost(canvas);\n}\n```", "```java\ntry {\n    gameThread.sleep(17);\n    } catch (InterruptedException e) {\n\n    }\n```", "```java\n// SurfaceView allows us to handle the onTouchEvent\n@Override\npublic boolean onTouchEvent(MotionEvent motionEvent) {\n\n    // There are many different events in MotionEvent\n    // We care about just 2 - for now.\n    switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n\n        // Has the player lifted their finger up?\n        case MotionEvent.ACTION_UP:\n // Do something here\n            break;\n\n        // Has the player touched the screen?\n        case MotionEvent.ACTION_DOWN:\n // Do something here\n           break;\n    }\n   return true;\n}\n```", "```java\nprivate boolean boosting;\n```", "```java\nboosting = false;\n```", "```java\npublic void setBoosting() {\n  boosting = true;\n}\n\npublic void stopBoosting() {\n  boosting = false;\n}\n```", "```java\n// Has the player lifted there finger up?\ncase MotionEvent.ACTION_UP:\n player.stopBoosting();\n  break;\n\n// Has the player touched the screen?\ncase MotionEvent.ACTION_DOWN:\n player.setBoosting();\n  break;\n```", "```java\nprivate final int GRAVITY = -12;\n\n// Stop ship leaving the screen\nprivate int maxY;\nprivate int minY;\n\n//Limit the bounds of the ship's speed\nprivate final int MIN_SPEED = 1;\nprivate final int MAX_SPEED = 20;\n```", "```java\npublic void update() {\n\n  // Are we boosting?\n  if (boosting) {\n    // Speed up\n    speed += 2;\n  } else {\n    // Slow down\n    speed -= 5;\n  }\n\n  // Constrain top speed\n  if (speed > MAX_SPEED) {\n    speed = MAX_SPEED;\n}\n\n  // Never stop completely\n  if (speed < MIN_SPEED) {\n    speed = MIN_SPEED;\n}\n\n  // move the ship up or down\n  y -= speed + GRAVITY;\n\n  // But don't let ship stray off screen\n  if (y < minY) {\n    y = minY;\n  }\n\n  if (y > maxY) {\n    y = maxY;\n  }\n\n}\n```", "```java\n// Get a Display object to access screen details\nDisplay display = getWindowManager().getDefaultDisplay();\n// Load the resolution into a Point object\nPoint size = new Point();\ndisplay.getSize(size);\n```", "```java\n// Create an instance of our Tappy Defender View\n// Also passing in this.\n// Also passing in the screen resolution to the constructor\ngameView = new TDView(this, size.x, size.y);\n\n```", "```java\nTDView(Context context, int x, int y) {\n```", "```java\nplayer = new PlayerShip(context, x, y);\n```", "```java\npublic PlayerShip(Context context, int screenX, int screenY) {\n```", "```java\nmaxY = screenY - bitmap.getHeight();\nminY = 0;\n```", "```java\npublic class EnemyShip{\n    private Bitmap bitmap;\n    private int x, y;\n    private int speed = 1;\n\n    // Detect enemies leaving the screen\n    private int maxX;\n    private int minX;\n\n    // Spawn enemies within screen bounds\n    private int maxY;\n    private int minY;\n}\n```", "```java\n//Getters and Setters\npublic Bitmap getBitmap(){\n  return bitmap;\n}\n\npublic int getX() {\n  return x;\n}\n\npublic int getY() {\n  return y;\n}\n```", "```java\n// Constructor\npublic EnemyShip(Context context, int screenX, int screenY){\n    bitmap = BitmapFactory.decodeResource \n    (context.getResources(), R.drawable.enemy);\n\n  maxX = screenX;\n  maxY = screenY;\n  minX = 0;\n  minY = 0;\n\n  Random generator = new Random();\n  speed = generator.nextInt(6)+10;\n\n  x = screenX;\n  y = generator.nextInt(maxY) - bitmap.getHeight();\n}\n```", "```java\npublic void update(int playerSpeed){\n\n  // Move to the left\n  x -= playerSpeed;\n  x -= speed;\n\n  //respawn when off screen\n  if(x < minX-bitmap.getWidth()){\n    Random generator = new Random();\n    speed = generator.nextInt(10)+10;\n    x = maxX;\n    y = generator.nextInt(maxY) - bitmap.getHeight();\n  }\n}\n```", "```java\n// Move to the left\nx -= playerSpeed;\nx -= speed;\n```", "```java\nif(x < minX-bitmap.getWidth()){\n```", "```java\n// Game objects\nprivate PlayerShip player;\npublic EnemyShip enemy1;\n\n```", "```java\npublic EnemyShip enemy2;\npublic EnemyShip enemy3;\n\n```", "```java\n// Initialize our player ship\nplayer = new PlayerShip(context, x, y);\nenemy1 = new EnemyShip(context, x, y);\nenemy2 = new EnemyShip(context, x, y);\nenemy3 = new EnemyShip(context, x, y);\n\n```", "```java\n// Update the player\nplayer.update();\n// Update the enemies\nenemy1.update(player.getSpeed());\nenemy2.update(player.getSpeed());\nenemy3.update(player.getSpeed());\n```", "```java\n// Draw the player\ncanvas.drawBitmap\n    (player.getBitmap(), player.getX(), player.getY(), paint);\n\ncanvas.drawBitmap\n (enemy1.getBitmap(), \n enemy1.getX(), \n enemy1.getY(), paint);\n\ncanvas.drawBitmap\n (enemy2.getBitmap(), \n enemy2.getX(), \n enemy2.getY(), paint);\n\ncanvas.drawBitmap\n (enemy3.getBitmap(), \n enemy3.getX(), \n enemy3.getY(), paint);\n\n```", "```java\npublic class SpaceDust {\n\n    private int x, y;\n    private int speed;\n\n    // Detect dust leaving the screen\n    private int maxX;\n    private int maxY;\n    private int minX;\n    private int minY;\n\n    // Constructor\n    public SpaceDust(int screenX, int screenY){\n\n        maxX = screenX;\n        maxY = screenY;\n        minX = 0;\n        minY = 0;\n\n        // Set a speed between  0 and 9\n        Random generator = new Random();\n        speed = generator.nextInt(10);\n\n        //  Set the starting coordinates\n        x = generator.nextInt(maxX);\n        y = generator.nextInt(maxY);\n    }\n\n    public void update(int playerSpeed){\n        // Speed up when the player does\n        x -= playerSpeed;\n        x -= speed;\n\n        //respawn space dust\n        if(x < 0){\n            x = maxX;\n            Random generator = new Random();\n            y = generator.nextInt(maxY);\n            speed = generator.nextInt(15);\n        }\n    }\n\n    // Getters and Setters\n    public int getX() {\n\n        return x;\n    }\n\n    public int getY() {\n\n        return y;\n    }\n}\n```", "```java\n// Make some random space dust\npublic ArrayList<SpaceDust> dustList = new\n  ArrayList<SpaceDust>();\n```", "```java\nint numSpecs = 40;\n\nfor (int i = 0; i < numSpecs; i++) {\n  // Where will the dust spawn?\n  SpaceDust spec = new SpaceDust(x, y);\n  dustList.add(spec);\n}\n```", "```java\nfor (SpaceDust sd : dustList) {\n  sd.update(player.getSpeed());\n}\n```", "```java\n// White specs of dust\npaint.setColor(Color.argb(255, 255, 255, 255));\n\n//Draw the dust from our arrayList\nfor (SpaceDust sd : dustList) {\n      canvas.drawPoint(sd.getX(), sd.getY(), paint);\n\n    // Draw the player\n    // ...\n}\n```", "```java\nif(ship.getHitbox().right > enemy.getHitbox().left  \n    && ship.getHitbox().left < enemy.getHitbox().right ){\n    // Ship is intersecting enemy on x axis\n    //But they could be at different heights\n\n    if(ship.getHitbox().top < enemy.getHitbox().bottom  \n        && ship.getHitbox().bottom > enemy.getHitbox().top ){\n        // Ship is intersecting enemy on y axis as well\n        // Crash\n    }\n}\n```", "```java\n// Get the distance of the two objects from \n// the edges of the circles on the x axis\ndistanceX = (ship.getHitBox.centerX + ship.getHitBox.radius) - \n  (enemy.getHitBox.centerX + enemy.getHitBox.radius;\n\n// Get the distance of the two objects from \n// the edges of the circles on the y axis\ndistanceY = (ship.getHitBox.centerY + ship.getHitBox.radius) -  \n  (enemy.getHitBox.centerY + enemy.getHitBox.radius;\n\n// Calculate the distance between the center of each circle\ndouble distance = Math.sqrt\n    (distanceX * distanceX + distanceY * distanceY);\n\n// Finally see if the two circles overlap\nif (distance < ship.getHitBox.radius + enemy.getHitBox.radius) {\n    // bump\n}\n```", "```java\n// A hit box for collision detection\nprivate Rect hitBox;\n```", "```java\npublic Rect getHitbox(){\n  return hitBox;\n}\n```", "```java\n// Initialize the hit box\nhitBox = new Rect(x, y, bitmap.getWidth(), bitmap.getHeight());\n```", "```java\n// Refresh hit box location\nhitBox.left = x;\nhitBox.top = y;\nhitBox.right = x + bitmap.getWidth();\nhitBox.bottom = y + bitmap.getHeight();\n```", "```java\n// This is used by the TDView update() method to\n// Make an enemy out of bounds and force a re-spawn\npublic void setX(int x) {\n  this.x = x;\n}\n```", "```java\n// Collision detection on new positions\n// Before move because we are testing last frames\n// position which has just been drawn\n\n// If you are using images in excess of 100 pixels\n// wide then increase the -100 value accordingly\nif(Rect.intersects\n  (player.getHitbox(), enemy1.getHitbox())){\n    enemy1.setX(-100);\n}\n\nif(Rect.intersects\n  (player.getHitbox(), enemy2.getHitbox())){\n    enemy2.setX(-100);\n}\n\nif(Rect.intersects\n  (player.getHitbox(), enemy3.getHitbox())){\n    enemy3.setX(-100);\n}\n```", "```java\n// Rub out the last frame\ncanvas.drawColor(Color.argb(255, 0, 0, 0));\n\n// For debugging\n// Switch to white pixels\npaint.setColor(Color.argb(255, 255, 255, 255));\n\n// Draw Hit boxes\ncanvas.drawRect(player.getHitbox().left, \n player.getHitbox().top, \n player.getHitbox().right, \n player.getHitbox().bottom, \n paint);\n\ncanvas.drawRect(enemy1.getHitbox().left, \n enemy1.getHitbox().top, \n enemy1.getHitbox().right, \n enemy1.getHitbox().bottom, \n paint);\n\ncanvas.drawRect(enemy2.getHitbox().left, \n enemy2.getHitbox().top, \n enemy2.getHitbox().right, \n enemy2.getHitbox().bottom, \n paint);\n\ncanvas.drawRect(enemy3.getHitbox().left, \n enemy3.getHitbox().top, \n enemy3.getHitbox().right, \n enemy3.getHitbox().bottom, \n paint);\n\n```", "```java\nprivate float distanceRemaining;\nprivate long timeTaken;\nprivate long timeStarted;\nprivate long fastestTime;\n```", "```java\n// Draw the hud\npaint.setTextAlign(Paint.Align.LEFT);\npaint.setColor(Color.argb(255, 255, 255, 255));\npaint.setTextSize(25);\ncanvas.drawText(\"Fastest:\"+ fastestTime + \"s\", 10, 20, paint);\ncanvas.drawText(\"Time:\" + timeTaken + \"s\", screenX / 2, 20, paint);\ncanvas.drawText(\"Distance:\" + \n distanceRemaining / 1000 + \n \" KM\", screenX / 3, screenY - 20, paint);\n\ncanvas.drawText(\"Shield:\" + \n player.getShieldStrength(), 10, screenY - 20, paint);\n\ncanvas.drawText(\"Speed:\" + \n player.getSpeed() * 60 + \n \" MPS\", (screenX /3 ) * 2, screenY - 20, paint);\n\n// Unlock and draw the scene\nourHolder.unlockCanvasAndPost(canvas);\n```", "```java\nprivate int shieldStrength;\n```", "```java\n shieldStrength = 2;\n```", "```java\npublic int getShieldStrength() {\n  return shieldStrength;\n}\n```", "```java\nprivate int screenX;\nprivate int screenY;\n```", "```java\nscreenX = x;\nscreenY = y;\n```", "```java\nprivate Context context;\n```", "```java\nsuper(context);\nthis.context  = context;\n\n```", "```java\nprivate void startGame(){\n    //Initialize game objects\n        player = new PlayerShip(context, screenX, screenY);\n        enemy1 = new EnemyShip(context, screenX, screenY);\n        enemy2 = new EnemyShip(context, screenX, screenY);\n        enemy3 = new EnemyShip(context, screenX, screenY);\n\n        int numSpecs = 40;\n        for (int i = 0; i < numSpecs; i++) {\n            // Where will the dust spawn?\n            SpaceDust spec = new SpaceDust(screenX, screenY);\n            dustList.add(spec);\n        }\n\n        // Reset time and distance\n        distanceRemaining = 10000;// 10 km\n        timeTaken = 0;\n\n        // Get start time\n        timeStarted = System.currentTimeMillis();\n}\n```", "```java\n// Initialize our player ship\n//player = new PlayerShip(context, x, y);\n//enemy1 = new EnemyShip(context, x, y);\n//enemy2 = new EnemyShip(context, x, y);\n//enemy3 = new EnemyShip(context, x, y);\n\n//int numSpecs = 40;\n\n//for (int i = 0; i < numSpecs; i++) {\n      // Where will the dust spawn?\n      //SpaceDust spec = new SpaceDust(x, y);\n      //dustList.add(spec);\n//}\n\nstartGame();\n\n```", "```java\npublic void reduceShieldStrength(){\n  shieldStrength --;\n}\n```", "```java\n// Collision detection on new positions\n// Before move because we are testing last frames\n// position which has just been drawn\nboolean hitDetected = false;\nif(Rect.intersects(player.getHitbox(), enemy1.getHitbox())){\n hitDetected = true;\n    enemy1.setX(-100);\n}\n\nif(Rect.intersects(player.getHitbox(), enemy2.getHitbox())){\n hitDetected = true;\n    enemy2.setX(-100);\n}\n\nif(Rect.intersects(player.getHitbox(), enemy3.getHitbox())){\n hitDetected = true;\n    enemy3.setX(-100);\n}\n\nif(hitDetected) {\n player.reduceShieldStrength();\n if (player.getShieldStrength() < 0) {\n //game over so do something\n }\n}\n\n```", "```java\nprivate boolean gameEnded;\n```", "```java\ngameEnded = false;\n```", "```java\nif(!gameEnded) {\n            //subtract distance to home planet based on current speed\n            distanceRemaining -= player.getSpeed();\n\n            //How long has the player been flying\n            timeTaken = System.currentTimeMillis() - timeStarted;\n}\n```", "```java\n//Completed the game!\nif(distanceRemaining < 0){\n  //check for new fastest time\n  if(timeTaken < fastestTime) {\n    fastestTime = timeTaken;\n  }\n\n  // avoid ugly negative numbers\n  // in the HUD\n  distanceRemaining = 0;\n\n  // Now end the game\n  gameEnded = true;\n}\n```", "```java\nif(hitDetected) {\n  player.reduceShieldStrength();\n  if (player.getShieldStrength() < 0) {\n gameEnded = true;\n }\n}\n```", "```java\n// Draw the HUD\npaint.setTextAlign(Paint.Align.LEFT);\npaint.setColor(Color.argb(255, 255, 255, 255));\npaint.setTextSize(25);\ncanvas.drawText(\"Fastest:\"+ fastestTime + \"s\", 10, 20, paint);\ncanvas.drawText(\"Time:\" + timeTaken + \"s\", screenX / 2, 20, paint);\n\ncanvas.drawText(\"Distance:\" + \n  distanceRemaining / 1000 + \n  \" KM\", screenX / 3, screenY - 20, paint);\n\ncanvas.drawText(\"Shield:\" + \n  player.getShieldStrength(), 10, screenY - 20, paint);\n\ncanvas.drawText(\"Speed:\" + \n  player.getSpeed() * 60 +\n  \" MPS\", (screenX /3 ) * 2, screenY - 20, paint);\n```", "```java\nif(!gameEnded){\n  // Draw the hud\n  paint.setTextAlign(Paint.Align.LEFT);\n  paint.setColor(Color.argb(255, 255, 255, 255));\n  paint.setTextSize(25);\n  canvas.drawText(\"Fastest:\"+ fastestTime + \"s\", 10, 20, paint);\n\n  canvas.drawText(\"Time:\" + \n    timeTaken + \n    \"s\", screenX / 2, 20,   paint);\n\n  canvas.drawText(\"Distance:\" + \n    distanceRemaining / 1000 + \n    \" KM\", screenX / 3, screenY - 20, paint);\n\n  canvas.drawText(\"Shield:\" + \n    player.getShieldStrength(), 10, screenY - 20, paint);\n\n  canvas.drawText(\"Speed:\" + \n    player.getSpeed() * 60 +\n    \" MPS\", (screenX /3 ) * 2, screenY - 20, paint);\n\n}else{\n //this happens when the game is ended\n}\n\n```", "```java\n// Show pause screen\npaint.setTextSize(80);\npaint.setTextAlign(Paint.Align.CENTER);\ncanvas.drawText(\"Game Over\", screenX/2, 100, paint);\npaint.setTextSize(25);\ncanvas.drawText(\"Fastest:\"+ \n  fastestTime + \"s\", screenX/2, 160, paint);\n\ncanvas.drawText(\"Time:\" + timeTaken + \n  \"s\", screenX / 2, 200, paint);\n\ncanvas.drawText(\"Distance remaining:\" + \n  distanceRemaining/1000 + \" KM\",screenX/2, 240, paint);\n\npaint.setTextSize(80);\ncanvas.drawText(\"Tap to replay!\", screenX/2, 350, paint);\n```", "```java\n// Has the player touched the screen?\ncase MotionEvent.ACTION_DOWN:\n    player.setBoosting();\n // If we are currently on the pause screen, start a new game\n if(gameEnded){\n startGame();\n }\n   break;\n```", "```java\nprivate SoundPool soundPool;\n    int start = -1;\n    int bump = -1;\n    int destroyed = -1;\n    int win = -1;\n```", "```java\nTDView(Context context, int x, int y) {\n  super(context);\n  this.context  = context;\n\n // This SoundPool is deprecated but don't worry\n soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);\n try{\n //Create objects of the 2 required classes\n AssetManager assetManager = context.getAssets();\n AssetFileDescriptor descriptor;\n\n //create our three fx in memory ready for use\n descriptor = assetManager.openFd(\"start.ogg\");\n start = soundPool.load(descriptor, 0);\n\n descriptor = assetManager.openFd(\"win.ogg\");\n win = soundPool.load(descriptor, 0);\n\n descriptor = assetManager.openFd(\"bump.ogg\");\n bump = soundPool.load(descriptor, 0);\n\n descriptor = assetManager.openFd(\"destroyed.ogg\");\n destroyed = soundPool.load(descriptor, 0);\n\n }catch(IOException e){\n //Print an error message to the console\n Log.e(\"error\", \"failed to load sound files\");\n }\n\n```", "```java\nsoundPool.play(start, 1, 1, 0, 0, 1);\n```", "```java\nif(hitDetected) {\n soundPool.play(bump, 1, 1, 0, 0, 1);\n  player.reduceShieldStrength();\n  if (player.getShieldStrength() < 0) {\n soundPool.play(destroyed, 1, 1, 0, 0, 1);\n      paused = true;\n  }\n}\n```", "```java\n//Completed the game!\nif(distanceRemaining < 0){\n soundPool.play(win, 1, 1, 0, 0, 1);\n     //check for new fastest time\n     if(timeTaken < fastestTime) {\n         fastestTime = timeTaken;\n     }\n\n     // avoid ugly negative numbers\n     // in the HUD\n     distanceRemaining = 0;\n\n     // Now end the game\n     gameEnded = true;\n}\n```", "```java\nprivate SharedPreferences prefs;\nprivate SharedPreferences.Editor editor;\n```", "```java\n// Get a reference to a file called HiScores. \n// If id doesn't exist one is created\nprefs = context.getSharedPreferences(\"HiScores\", \n  context.MODE_PRIVATE);\n\n// Initialize the editor ready\neditor = prefs.edit();\n\n// Load fastest time from a entry in the file\n//  labeled \"fastestTime\"\n// if not available highscore = 1000000\nfastestTime = prefs.getLong(\"fastestTime\", 1000000);\n```", "```java\n//Completed the game!\nif(distanceRemaining < 0){\n soundPool.play(win, 1, 1, 0, 0, 1);\n     //check for new fastest time\n     if(timeTaken < fastestTime) {\n         // Save high score\n         editor.putLong(\"fastestTime\", timeTaken);\n         editor.commit();\n         fastestTime = timeTaken;\n     }\n\n     // avoid ugly negative numbers\n     // in the HUD\n     distanceRemaining = 0;\n\n     // Now end the game\n     gameEnded = true;\n}\n```", "```java\n// This is the entry point to our game\n@Override\nprotected void onCreate(Bundle savedInstanceState) {\n  super.onCreate(savedInstanceState);\n\n  //Here we set our UI layout as the view\n  setContentView(R.layout.activity_main);\n\n // Prepare to load fastest time\n SharedPreferences prefs;\n SharedPreferences.Editor editor;\n prefs = getSharedPreferences(\"HiScores\", MODE_PRIVATE);\n\n  // Get a reference to the button in our layout\n  final Button buttonPlay =\n    (Button)findViewById(R.id.buttonPlay);\n\n // Get a reference to the TextView in our layout\n final TextView textFastestTime = \n (TextView)findViewById(R.id.textHighScore);\n\n  // Listen for clicks\n  buttonPlay.setOnClickListener(this);\n\n // Load fastest time\n // if not available our high score = 1000000\n long fastestTime = prefs.getLong(\"fastestTime\", 1000000);\n\n // Put the high score in our TextView\n textFastestTime.setText(\"Fastest Time:\" + fastestTime);\n\n}\n```", "```java\n// Constructor\npublic EnemyShip(Context context, int screenX, int screenY){\n Random generator = new Random();\n int whichBitmap = generator.nextInt(3);\n switch (whichBitmap){\n case 0:\n bitmap = BitmapFactory.decodeResource\n (context.getResources(), R.drawable.enemy3);\n break;\n\n case 1:\n bitmap = BitmapFactory.decodeResource\n (context.getResources(), R.drawable.enemy2);\n break;\n\n case 2:\n bitmap = BitmapFactory.decodeResource\n (context.getResources(), R.drawable.enemy);\n break;\n }\n\n    maxX = screenX;\n    maxY = screenY;\n    minX = 0;\n    minY = 0;\n\n    speed = generator.nextInt(6)+10;\n    x = screenX;\n    y = generator.nextInt(maxY) - bitmap.getHeight();\n\n    // Initialize the hit box\n    hitBox = new Rect(x, y, bitmap.getWidth(),  bitmap.getHeight());\n\n}\n```", "```java\nswitch (whichBitmap){\n    case 0:\n          bitmap = BitmapFactory.decodeResource(context.getResources(),           \n          R.drawable.enemy3);\n          break;\n\n    case 1:\n          bitmap = BitmapFactory.decodeResource(context.getResources(),           \n          R.drawable.enemy2);\n          break;\n\n   case 2:\n          bitmap = BitmapFactory.decodeResource(context.getResources(),           \n          R.drawable.enemy);\n          break;\n}\n\nscaleBitmap(screenX);\n\n```", "```java\npublic void scaleBitmap(int x){\n\n  if(x < 1000) {\n       bitmap = Bitmap.createScaledBitmap(bitmap,\n       bitmap.getWidth() / 3,\n       bitmap.getHeight() / 3,\n       false);\n  }else if(x < 1200){\n       bitmap = Bitmap.createScaledBitmap(bitmap,\n       bitmap.getWidth() / 2,\n       bitmap.getHeight() / 2,\n       false);\n   }\n}\n```", "```java\n// Game objects\nprivate PlayerShip player;\npublic EnemyShip enemy1;\npublic EnemyShip enemy2;\npublic EnemyShip enemy3;\npublic EnemyShip enemy4;\npublic EnemyShip enemy5;\n\n```", "```java\nenemy1 = new EnemyShip(context, screenX, screenY);\nenemy2 = new EnemyShip(context, screenX, screenY);\nenemy3 = new EnemyShip(context, screenX, screenY);\n\nif(screenX > 1000){\n enemy4 = new EnemyShip(context, screenX, screenY);\n}\n\nif(screenX > 1200){\n enemy5 = new EnemyShip(context, screenX, screenY);\n}\n\n```", "```java\n// Collision detection on new positions\n// Before move because we are testing last frames\n// position which has just been drawn\nboolean hitDetected = false;\nif(Rect.intersects(player.getHitbox(), enemy1.getHitbox())){\n  hitDetected = true;\n  enemy1.setX(-100);\n}\n\nif(Rect.intersects(player.getHitbox(), enemy2.getHitbox())){\n  hitDetected = true;\n  enemy2.setX(-100);        \n}\n\nif(Rect.intersects(player.getHitbox(), enemy3.getHitbox())){\n  hitDetected = true;\n  enemy3.setX(-100);       \n}\n\nif(screenX > 1000){\n if(Rect.intersects(player.getHitbox(), enemy4.getHitbox())){\n hitDetected = true;\n enemy4.setX(-100); \n }\n}\n\nif(screenX > 1200){\n if(Rect.intersects(player.getHitbox(), enemy5.getHitbox())){\n hitDetected = true;\n enemy5.setX(-100);\n }\n}\n\nif(hitDetected) {\nsoundPool.play(bump, 1, 1, 0, 0, 1);\n            player.reduceShieldStrength();\n            if (player.getShieldStrength() < 0) {\n                soundPool.play(destroyed, 1, 1, 0, 0, 1);\n                gameEnded = true;\n            }\n}\n\n// Update the player\nplayer.update();\n// Update the enemies\nenemy1.update(player.getSpeed());\nenemy2.update(player.getSpeed());\nenemy3.update(player.getSpeed());\n\nif(screenX > 1000) {\n enemy4.update(player.getSpeed());\n}\nif(screenX > 1200) {\n enemy5.update(player.getSpeed());\n}\n\n```", "```java\n// Draw the player\ncanvas.drawBitmap(player.getBitmap(), player.getX(), player.getY(), paint);\ncanvas.drawBitmap(enemy1.getBitmap(),\n  enemy1.getX(), enemy1.getY(), paint);\ncanvas.drawBitmap(enemy2.getBitmap(),\n  enemy2.getX(), enemy2.getY(), paint);\ncanvas.drawBitmap(enemy3.getBitmap(),\n  enemy3.getX(), enemy3.getY(), paint);\n\nif(screenX > 1000) {\n canvas.drawBitmap(enemy4.getBitmap(),\n enemy4.getX(), enemy4.getY(), paint);\n}\nif(screenX > 1200) {\n canvas.drawBitmap(enemy5.getBitmap(),\n enemy5.getX(), enemy5.getY(), paint);\n}\n\n```", "```java\nprivate String formatTime(long time){\n    long seconds = (time) / 1000;\n    long thousandths = (time) - (seconds * 1000);\n    String strThousandths = \"\" + thousandths;\n    if (thousandths < 100){strThousandths = \"0\" + thousandths;}\n    if (thousandths < 10){strThousandths = \"0\" + strThousandths;}\n    String stringTime = \"\" + seconds + \".\" + strThousandths;\n    return stringTime;\n}\n```", "```java\n//canvas.drawText(\"Time:\" + timeTaken + \"s\", screenX / 2, 20, paint);\ncanvas.drawText(\"Time:\" + \n formatTime(timeTaken) + \n \"s\", screenX / 2, 20, paint);\n\n```", "```java\n//canvas.drawText(\"Fastest:\" + fastestTime + \"s\", 10, 20, paint);\ncanvas.drawText(\"Fastest:\" + \n formatTime(fastestTime) + \n \"s\", 10, 20, paint);\n\n```", "```java\n// Show pause screen\npaint.setTextSize(80);\npaint.setTextAlign(Paint.Align.CENTER);\ncanvas.drawText(\"Game Over\", screenX/2, 100, paint);\npaint.setTextSize(25);\n\n// canvas.drawText(\"Fastest:\"\n  + fastestTime + \"s\", screenX/2, 160, paint);\ncanvas.drawText(\"Fastest:\"+ \n formatTime(fastestTime) + \"s\", screenX/2, 160, paint);\n\n// canvas.drawText(\"Time:\" + \n  timeTaken + \"s\", screenX / 2, 200, paint);\ncanvas.drawText(\"Time:\" \n + formatTime(timeTaken) + \"s\", screenX / 2, 200, paint);\n\ncanvas.drawText(\"Distance remaining:\" +\n  distanceRemaining/1000 + \" KM\",screenX/2, 240, paint);\npaint.setTextSize(80);\ncanvas.drawText(\"Tap to replay!\", screenX/2, 350, paint);\n```", "```java\n// If the player hits the back button, quit the app\npublic boolean onKeyDown(int keyCode, KeyEvent event) {\n  if (keyCode == KeyEvent.KEYCODE_BACK) {\n       finish();\n       return true;\n  }\n  return false;\n}\n```", "```java\npackage com.gamecodeschool.c5platformgame;\n```", "```java\nimport android.app.Activity;\nimport android.graphics.Point;\nimport android.os.Bundle;\nimport android.view.Display;\n\npublic class PlatformActivity extends Activity {\n\n    // Our object to handle the View\n    private PlatformView platformView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // Get a Display object to access screen details\n        Display display = getWindowManager().getDefaultDisplay();\n\n        // Load the resolution into a Point object\n        Point resolution = new Point();\n        display.getSize(resolution);\n\n        // And finally set the view for our game\n        // Also passing in the screen resolution\n        platformView = new PlatformView\n        (this, resolution.x, resolution.y);\n\n        // Make our platformView the view for the Activity\n        setContentView(platformView);\n\n    }\n\n    // If the Activity is paused make sure to pause our thread\n    @Override\n    protected void onPause() {\n        super.onPause();\n        platformView.pause();\n    }\n\n    // If the Activity is resumed make sure to resume our thread\n    @Override\n    protected void onResume() {\n        super.onResume();\n        platformView.resume();\n    }\n}\n```", "```java\n    android:name=\".PlatformActivity\"\n    ```", "```java\n    android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\n    android:screenOrientation=\"landscape\"\n    ```", "```java\nimport android.content.Context;\nimport android.graphics.Canvas;\nimport android.graphics.Color;\nimport android.graphics.Paint;\nimport android.graphics.Rect;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\npublic class PlatformView extends SurfaceView \n  implements Runnable {\n\n  private boolean debugging = true;\n  private volatile boolean running;\n  private Thread gameThread = null;\n\n  // For drawing\n  private Paint paint;\n  // Canvas could initially be local.\n  // But later we will use it outside of draw()\n  private Canvas canvas;\n  private SurfaceHolder ourHolder;\n\n  Context context;\n  long startFrameTime;\n  long timeThisFrame;\n  long fps;\n\n   // Our new engine classes\n   private LevelManager lm;\n   private Viewport vp;\n   InputController ic;\n```", "```java\nPlatformView(Context context, int screenWidth, \n    int screenHeight) {\n\n    super(context);\n    this.context = context;\n\n    // Initialize our drawing objects\n    ourHolder = getHolder();\n    paint = new Paint();\n}\n```", "```java\n@Override\npublic void run() {\n\n  while (running) {\n       startFrameTime = System.currentTimeMillis();\n\n       update();\n       draw();\n\n      // Calculate the fps this frame\n      // We can then use the result to\n      // time animations and movement.\n      timeThisFrame = System.currentTimeMillis() - startFrameTime;\n            if (timeThisFrame >= 1) {\n                fps = 1000 / timeThisFrame;\n            }\n     }\n}\n```", "```java\nprivate void update() {\n  // Our new update() code will go here\n}\n```", "```java\nprivate void draw() {\n\n     if (ourHolder.getSurface().isValid()){\n      //First we lock the area of memory we will be drawing to\n      canvas = ourHolder.lockCanvas();\n\n      // Rub out the last frame with arbitrary color\n      paint.setColor(Color.argb(255, 0, 0, 255));\n      canvas.drawColor(Color.argb(255, 0, 0, 255));\n\n      // New drawing code will go here\n\n      // Unlock and draw the scene\n      ourHolder.unlockCanvasAndPost(canvas);\n  }\n}\n```", "```java\n// Clean up our thread if the game is interrupted    \npublic void pause() {\n  running = false;\n   try {\n       gameThread.join();\n   } catch (InterruptedException e) {\n       Log.e(\"error\", \"failed to pause thread\");\n   }\n}\n\n// Make a new thread and start it\n// Execution moves to our run method\npublic void resume() {\n   running = true;\n   gameThread = new Thread(this);\n   gameThread.start();\n\n}\n\n}// End of PlatformView\n```", "```java\npublic class Vector2Point5D {\n\n    float x;\n    float y;\n    int z;\n}\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\n```", "```java\npublic abstract class GameObject {\n\n    private Vector2Point5D worldLocation;\n    private float width;\n    private float height;\n\n    private boolean active = true;\n    private boolean visible = true;\n    private int animFrameCount = 1;\n    private char type;\n\n    private String bitmapName;\n\n```", "```java\npublic abstract void update(long fps, float gravity);\n```", "```java\npublic String getBitmapName() {\n        return bitmapName;\n}\n\npublic Bitmap prepareBitmap(Context context, \n    String bitmapName, \n    int pixelsPerMetre) {\n\n   // Make a resource id from the bitmapName\n   int resID = context.getResources().\n        getIdentifier(bitmapName,\n        \"drawable\", context.getPackageName());\n\n    // Create the bitmap\n    Bitmap bitmap = BitmapFactory.\n        decodeResource(context.getResources(),\n        resID);\n\n    // Scale the bitmap based on the number of pixels per metre\n    // Multiply by the number of frames in the image\n    // Default 1 frame\n    bitmap = Bitmap.createScaledBitmap(bitmap,\n                (int) (width * animFrameCount * pixelsPerMetre),\n                (int) (height * pixelsPerMetre),\n                false);\n\n    return bitmap;\n}\n```", "```java\n    public Vector2Point5D getWorldLocation() {\n        return worldLocation;\n    }\n\n    public void setWorldLocation(float x, float y, int z) {\n        this.worldLocation = new Vector2Point5D();\n        this.worldLocation.x = x;\n        this.worldLocation.y = y;\n        this.worldLocation.z = z;\n    }\n```", "```java\n    public void setBitmapName(String bitmapName){\n        this.bitmapName = bitmapName;\n    }\n\n    public float getWidth() {\n        return width;\n    }\n\n    public void setWidth(float width) {\n        this.width = width;\n    }\n\n    public float getHeight() {\n        return height;\n    }\n\n    public void setHeight(float height) {\n        this.height = height;\n    }\n```", "```java\n    public boolean isActive() {\n        return active;\n    }\n\n    public boolean isVisible() {\n        return visible;\n    }\n\n    public void setVisible(boolean visible) {\n        this.visible = visible;\n    }\n```", "```java\n    public char getType() {\n        return type;\n    }\n\n    public void setType(char type) {\n        this.type = type;\n    }\n\n}// End of GameObject\n```", "```java\npublic class Grass extends GameObject {\n\n    Grass(float worldStartX, float worldStartY, char type) {\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n\n        setHeight(HEIGHT); // 1 metre tall\n        setWidth(WIDTH); // 1 metre wide\n\n        setType(type);\n\n        // Choose a Bitmap\n        setBitmapName(\"turf\");\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n    }\n\n    public void update(long fps, float gravity) {}\n}\n```", "```java\nimport android.content.Context;\n\npublic class Player extends GameObject {\n\n    Player(Context context, float worldStartX, \n        float worldStartY, int pixelsPerMetre) {\n\n        final float HEIGHT = 2;\n        final float WIDTH = 1;\n\n        setHeight(HEIGHT); // 2 metre tall\n        setWidth(WIDTH); // 1 metre wide\n\n        setType('p');\n\n        // Choose a Bitmap\n        // This is a sprite sheet with multiple frames\n        // of animation. So it will look silly until we animate it\n        // In chapter 6.\n\n        setBitmapName(\"player\");\n\n        // X and y locations from constructor parameters\n\n        setWorldLocation(worldStartX, worldStartY, 0);\n\n    }\n\n    public void update(long fps, float gravity) {\n\n    }\n}\n```", "```java\nimport android.graphics.Rect;\n\npublic class Viewport {\n    private Vector2Point5D currentViewportWorldCentre;\n    private Rect convertedRect;\n    private int pixelsPerMetreX;\n    private int pixelsPerMetreY;\n    private int screenXResolution;\n    private int screenYResolution;\n    private int screenCentreX;\n    private int screenCentreY;\n    private int metresToShowX;\n    private int metresToShowY;\n    private int numClipped;\n```", "```java\n Viewport(int x, int y){\n\n        screenXResolution = x;\n        screenYResolution = y;\n\n        screenCentreX = screenXResolution / 2;\n        screenCentreY = screenYResolution / 2;\n\n        pixelsPerMetreX = screenXResolution / 32;\n        pixelsPerMetreY = screenYResolution / 18;\n\n        metresToShowX = 34;\n        metresToShowY = 20;\n\n        convertedRect = new Rect();\n        currentViewportWorldCentre = new Vector2Point5D();\n\n}\n```", "```java\nvoid setWorldCentre(float x, float y){\n  currentViewportWorldCentre.x  = x;\n  currentViewportWorldCentre.y  = y;\n}\n```", "```java\npublic int getScreenWidth(){\n  return  screenXResolution;\n}\n\npublic int getScreenHeight(){\n  return  screenYResolution;\n}\n\npublic int getPixelsPerMetreX(){\n  return  pixelsPerMetreX;\n}\n```", "```java\n\npublic Rect worldToScreen(\n  float objectX, \n  float objectY, \n  float objectWidth, \n  float objectHeight){\n\n   int left = (int) (screenCentreX -               \n    ((currentViewportWorldCentre.x - objectX) \n    * pixelsPerMetreX));\n\n    int top =  (int) (screenCentreY -         \n    ((currentViewportWorldCentre.y - objectY) \n    * pixelsPerMetreY));\n\n   int right = (int) (left + \n    (objectWidth * \n    pixelsPerMetreX));\n\n  int bottom = (int) (top + \n    (objectHeight * \n    pixelsPerMetreY));\n\n  convertedRect.set(left, top, right, bottom);\n\n  return convertedRect;\n}\n```", "```java\n\npublic boolean clipObjects(float objectX, \n  float objectY, \n  float objectWidth, \n  float objectHeight) {\n\n  boolean clipped = true;\n\n   if (objectX - objectWidth < \n    currentViewportWorldCentre.x + (metresToShowX / 2)) {\n\n    if (objectX + objectWidth > \n      currentViewportWorldCentre.x - (metresToShowX / 2)) {\n\n      if (objectY - objectHeight <           \n        currentViewportWorldCentre.y + \n        (metresToShowY / 2)) {\n\n        if (objectY + objectHeight >       \n          currentViewportWorldCentre.y - \n          (metresToShowY / 2)){\n\n                 clipped = false;\n        }     \n      }\n\n    }\n\n  }\n\n   // For debugging\n   if(clipped){\n       numClipped++;\n   }\n\n   return clipped;\n}\n```", "```java\npublic int getNumClipped(){\n  return numClipped;    \n}\n\npublic void resetNumClipped(){\n  numClipped = 0;\n}\n\n}// End of Viewport\n```", "```java\n  // Initialize our drawing objects\n  ourHolder = getHolder();\n  paint = new Paint();\n\n // Initialize the viewport\n vp = new Viewport(screenWidth, screenHeight);\n\n}// End of constructor\n```", "```java\npublic class InputController {\n    InputController(int screenWidth, int screenHeight) {\n    }\n}\n```", "```java\nimport java.util.ArrayList;\n\npublic class LevelData {\n    ArrayList<String> tiles;\n\n    // This class will evolve along with the project\n\n    // Tile types\n    // . = no tile\n    // 1 = Grass\n\n}\n```", "```java\nimport java.util.ArrayList;\n\npublic class LevelCave extends LevelData{\n    LevelCave() {\n    tiles = new ArrayList<String>();\n    this.tiles.add(\"p.............................................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\".....................111111...................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"............111111............................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\".........1111111..............................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"..............................................\");\n    this.tiles.add(\"..............................11111111........\");\n    this.tiles.add(\"..............................................\");\n    }\n}\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Rect;\nimport java.util.ArrayList;\n```", "```java\npublic class LevelManager {\n\n    private String level;\n    int mapWidth;\n    int mapHeight;\n\n    Player player;\n    int playerIndex;\n\n    private boolean playing;\n    float gravity;\n\n    LevelData levelData;\n    ArrayList<GameObject> gameObjects;\n\n    ArrayList<Rect> currentButtons;\n    Bitmap[] bitmapsArray;\n```", "```java\npublic LevelManager(Context context, \n    int pixelsPerMetre, int screenWidth, \n    InputController ic, \n    String level, \n    float px, float py) {\n\n    this.level = level;\n\n    switch (level) {\n        case \"LevelCave\":\n        levelData = new LevelCave();\n        break;\n\n        // We can add extra levels here\n\n    }\n\n    // To hold all our GameObjects\n    gameObjects = new ArrayList<>();\n\n    // To hold 1 of every Bitmap\n    bitmapsArray = new Bitmap[25];\n\n    // Load all the GameObjects and Bitmaps\n    loadMapData(context, pixelsPerMetre, px, py);\n\n    // Ready to play\n    playing = true;\n}\n\npublic boolean isPlaying() {\n    return playing;\n}\n```", "```java\n    // Each index Corresponds to a bitmap\n    public Bitmap getBitmap(char blockType) {\n\n        int index;\n        switch (blockType) {\n            case '.':\n                index = 0;\n                break;\n\n            case '1':\n                index = 1;\n                break;\n\n            case 'p':\n                index = 2;\n                break;\n\n            default:\n                index = 0;\n                break;\n        }// End switch\n\n        return bitmapsArray[index];\n\n }// End getBitmap\n```", "```java\n// This method allows each GameObject which 'knows'\n// its type to get the correct index to its Bitmap\n// in the Bitmap array.\npublic int getBitmapIndex(char blockType) {\n\n    int index;\n        switch (blockType) {\n            case '.':\n                index = 0;\n                break;\n\n            case '1':\n                index = 1;\n                break;\n\n            case 'p':\n                index = 2;\n                break;\n\n            default:\n                index = 0;\n                break;\n\n        }// End switch\n\n        return index;\n    }// End getBitmapIndex()\n```", "```java\n// For now we just load all the grass tiles\n// and the player. Soon we will have many GameObjects\nprivate void loadMapData(Context context, \n  int pixelsPerMetre, \n  float px, float py) {\n\n   char c;\n\n   //Keep track of where we load our game objects\n   int currentIndex = -1;\n\n   // how wide and high is the map? Viewport needs to know\n   mapHeight = levelData.tiles.size();\n   mapWidth = levelData.tiles.get(0).length();\n```", "```java\nfor (int i = 0; i < levelData.tiles.size(); i++) {\n            for (int j = 0; j < \n                    levelData.tiles.get(i).length(); j++) {\n\n                c = levelData.tiles.get(i).charAt(j);\n\n                    // Don't want to load the empty spaces\n                    if (c != '.'){ \n                      currentIndex++;\n                      switch (c) {\n\n                        case '1':\n                            // Add grass to the gameObjects\n                            gameObjects.add(new Grass(j, i, c));\n                            break;\n\n                        case 'p':\n                            // Add a player to the gameObjects\n                            gameObjects.add(new Player\n                                (context, px, py, \n                                 pixelsPerMetre));\n\n                            // We want the index of the player\n                            playerIndex = currentIndex;\n                            // We want a reference to the player\n                            player = (Player)           \n                            gameObjects.get(playerIndex);\n\n                            break;\n\n            }// End switch\n```", "```java\n// If the bitmap isn't prepared yet\nif (bitmapsArray[getBitmapIndex(c)] == null) {\n\n    // Prepare it now and put it in the bitmapsArrayList\n    bitmapsArray[getBitmapIndex(c)] =\n        gameObjects.get(currentIndex).\n        prepareBitmap(context,                                                \n        gameObjects.get(currentIndex).                                                        \n        getBitmapName(),                                     \n        pixelsPerMetre);\n\n}// End if\n\n}// End if (c != '.'){ \n\n}// End for j\n\n}// End for i\n\n}// End loadMapData()\n\n}// End LevelManager\n```", "```java\n  // Initialize the viewport\n  vp = new Viewport(screenWidth, screenHeight);\n\n // Load the first level\n loadLevel(\"LevelCave\", 15, 2);\n\n}\n```", "```java\npublic void loadLevel(String level, float px, float py) {\n\n    lm = null;\n\n    // Create a new LevelManager\n    // Pass in a Context, screen details, level name \n    // and player location\n    lm = new LevelManager(context, \n        vp.getPixelsPerMetreX(), \n        vp.getScreenWidth(), \n        ic, level, px, py);\n\n    ic = new InputController(vp.getScreenWidth(),       \n        vp.getScreenHeight());\n\n    // Set the players location as the world centre     \n    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().x,\n        lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().y);\n    }\n```", "```java\nfor (GameObject go : lm.gameObjects) {\n        if (go.isActive()) {\n            // Clip anything off-screen\n            if (!vp.clipObjects(go.getWorldLocation().x,                                \n                go.getWorldLocation().y, \n                go.getWidth(), \n                go.getHeight())) {\n\n                // Set visible flag to true\n                go.setVisible(true);\n\n            } else {\n                // Set visible flag to false\n                go.setVisible(false);\n                // Now draw() can ignore them\n\n            }\n        }\n\n    }\n}\n```", "```java\nprivate void draw() {\n\n    if (ourHolder.getSurface().isValid()) {\n        //First we lock the area of memory we will be drawing to\n        canvas = ourHolder.lockCanvas();\n\n        // Rub out the last frame with arbitrary color\n        paint.setColor(Color.argb(255, 0, 0, 255));\n        canvas.drawColor(Color.argb(255, 0, 0, 255));\n // Draw all the GameObjects\n Rect toScreen2d = new Rect();\n\n // Draw a layer at a time\n for (int layer = -1; layer <= 1; layer++){\n for (GameObject go : lm.gameObjects) {\n //Only draw if visible and this layer\n if (go.isVisible() && go.getWorldLocation().z \n == layer) { \n\n toScreen2d.set(vp.worldToScreen\n (go.getWorldLocation().x,\n go.getWorldLocation().y,\n go.getWidth(),\n go.getHeight()));\n\n // Draw the appropriate bitmap\n canvas.drawBitmap(\n lm.bitmapsArray\n [lm.getBitmapIndex(go.getType())],\n toScreen2d.left,\n toScreen2d.top, paint);\n }\n }\n}\n\n```", "```java\n// Text for debugging\nif (debugging) {\n paint.setTextSize(16);\n paint.setTextAlign(Paint.Align.LEFT);\n paint.setColor(Color.argb(255, 255, 255, 255));\n canvas.drawText(\"fps:\" + fps, 10, 60, paint);\n\n canvas.drawText(\"num objects:\" + \n lm.gameObjects.size(), 10, 80, paint);\n\n canvas.drawText(\"num clipped:\" + \n vp.getNumClipped(), 10, 100, paint);\n\n canvas.drawText(\"playerX:\" + \n lm.gameObjects.get(lm.playerIndex).\n getWorldLocation().x,\n 10, 120, paint);\n\n canvas.drawText(\"playerY:\" + \n lm.gameObjects.get(lm.playerIndex).\n getWorldLocation().y, \n 10, 140, paint);\n\n //for reset the number of clipped objects each frame\n vp.resetNumClipped();\n\n}// End if(debugging)\n\n// Unlock and draw the scene\nourHolder.unlockCanvasAndPost(canvas);\n\n}// End (ourHolder.getSurface().isValid())\n}// End draw()\n```", "```java\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.content.res.AssetManager;\nimport android.media.AudioManager;\nimport android.media.SoundPool;\nimport android.util.Log;\n\nimport java.io.IOException;\n\npublic class SoundManager {\n    private SoundPool soundPool;\n    int shoot = -1;\n    int jump = -1;\n    int teleport = -1;\n    int coin_pickup = -1;\n    int gun_upgrade = -1;\n    int player_burn = -1;\n    int ricochet = -1;\n    int hit_guard = -1;\n    int explode = -1;\n    int extra_life = -1;\n```", "```java\npublic void loadSound(Context context){\n    soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);\n    try{\n        //Create objects of the 2 required classes\n        AssetManager assetManager = context.getAssets();\n        AssetFileDescriptor descriptor;\n\n        //create our fx\n        descriptor = assetManager.openFd(\"shoot.ogg\");\n        shoot = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"jump.ogg\");\n        jump = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"teleport.ogg\");\n        teleport = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"coin_pickup.ogg\");\n        coin_pickup = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"gun_upgrade.ogg\");\n        gun_upgrade = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"player_burn.ogg\");\n        player_burn = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"ricochet.ogg\");\n        ricochet = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"hit_guard.ogg\");\n        hit_guard = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"explode.ogg\");\n        explode = soundPool.load(descriptor, 0);\n\n        descriptor = assetManager.openFd(\"extra_life.ogg\");\n        extra_life = soundPool.load(descriptor, 0);\n\n    }catch(IOException e){\n        //Print an error message to the console\n        Log.e(\"error\", \"failed to load sound files\");\n\n    }\n\n}\n```", "```java\npublic void playSound(String sound){\n        switch (sound){\n            case \"shoot\":\n                soundPool.play(shoot, 1, 1, 0, 0, 1);\n                break;\n\n            case \"jump\":\n                soundPool.play(jump, 1, 1, 0, 0, 1);\n                break;\n\n            case \"teleport\":\n                soundPool.play(teleport, 1, 1, 0, 0, 1);\n                break;\n\n            case \"coin_pickup\":\n                soundPool.play(coin_pickup, 1, 1, 0, 0, 1);\n                break;\n\n            case \"gun_upgrade\":\n                soundPool.play(gun_upgrade, 1, 1, 0, 0, 1);\n                break;\n\n            case \"player_burn\":\n                soundPool.play(player_burn, 1, 1, 0, 0, 1);\n                break;\n\n            case \"ricochet\":\n                soundPool.play(ricochet, 1, 1, 0, 0, 1);\n                break;\n\n            case \"hit_guard\":\n                soundPool.play(hit_guard, 1, 1, 0, 0, 1);\n                break;\n\n            case \"explode\":\n                soundPool.play(explode, 1, 1, 0, 0, 1);\n                break;\n\n            case \"extra_life\":\n                soundPool.play(extra_life, 1, 1, 0, 0, 1);\n                break;\n\n        }\n\n    }\n}// End SoundManager\n```", "```java\n// Our new engine classes\nprivate LevelManager lm;\nprivate Viewport vp;\nInputController ic;\nSoundManager sm;\n\n```", "```java\n// Initialize the viewport\nvp = new Viewport(screenWidth, screenHeight);\n\nsm = new SoundManager();\nsm.loadSound(context);\n\nloadLevel(\"LevelCave\", 15, 2);\n```", "```java\npublic class Player extends GameObject {\n\n final float MAX_X_VELOCITY = 10;\n boolean isPressingRight = false;\n boolean isPressingLeft = false;\n\n public boolean isFalling;\n private boolean isJumping;\n private long jumpTime;\n private long maxJumpTime = 700;// jump 7 10ths of second\n\n```", "```java\nprivate float xVelocity;\nprivate float yVelocity;\nfinal int LEFT = -1;\nfinal int RIGHT = 1;\nprivate int facing;\nprivate boolean moves = false;\n```", "```java\nvoid move(long fps){\n        if(xVelocity != 0) {\n            this.worldLocation.x += xVelocity / fps;\n        }\n\n        if(yVelocity != 0) {\n            this.worldLocation.y += yVelocity / fps;\n        }\n    }\n```", "```java\npublic int getFacing() {\n  return facing;\n}\n\npublic void setFacing(int facing) {\n  this.facing = facing;\n}\n\npublic float getxVelocity() {\n  return xVelocity;\n}\n\npublic void setxVelocity(float xVelocity) {\n  // Only allow for objects that can move\n  if(moves) {\n    this.xVelocity = xVelocity;\n  }\n}\n\npublic float getyVelocity() {\n  return yVelocity;\n}\n\npublic void setyVelocity(float yVelocity) {\n  // Only allow for objects that can move\n  if(moves) {\n    this.yVelocity = yVelocity;\n  }\n}\n\npublic boolean isMoves() {\n  return moves;\n}\n\npublic void setMoves(boolean moves) {\n  this.moves = moves;\n}\n\npublic void setActive(boolean active) {\n  this.active = active;\n}\n```", "```java\nsetHeight(HEIGHT); // 2 metre tall\nsetWidth(WIDTH); // 1 metre wide\n\n// Standing still to start with\nsetxVelocity(0);\nsetyVelocity(0);\nsetFacing(LEFT);\nisFalling = false;\n\n// Now for the player's other attributes\n// Our game engine will use these\nsetMoves(true);\nsetActive(true);\nsetVisible(true);\n//...\n\n```", "```java\npublic void update(long fps, float gravity) {\n if (isPressingRight) {\n this.setxVelocity(MAX_X_VELOCITY);\n } else if (isPressingLeft) {\n this.setxVelocity(-MAX_X_VELOCITY);\n } else {\n this.setxVelocity(0);\n }\n\n```", "```java\n//which way is player facing?\nif (this.getxVelocity() > 0) {\n  //facing right\n  setFacing(RIGHT);\n} else if (this.getxVelocity() < 0) {\n  //facing left\n  setFacing(LEFT);\n}//if 0 then unchanged\n```", "```java\n// Jumping and gravity\nif (isJumping) {\n  long timeJumping = System.currentTimeMillis() - jumpTime;\n  if (timeJumping < maxJumpTime) {\n    if (timeJumping < maxJumpTime / 2) {\n      this.setyVelocity(-gravity);//on the way up\n       } else if (timeJumping > maxJumpTime / 2) {\n          this.setyVelocity(gravity);//going down\n       }\n  } else {\n    isJumping = false;\n  }\n} else {\n      this.setyVelocity(gravity);\n      // Read Me!\n      // Remove this next line to make the game easier\n      // it means the long jumps are less punishing\n      // because the player can take off just after the platform\n      // They will also be able to cheat by jumping in thin air\n      isFalling = true;\n}\n```", "```java\n // Let's go!\n this.move(fps);\n}// end update()\n```", "```java\n// Set visible flag to true\ngo.setVisible(true);\n\nif (lm.isPlaying()) {\n // Run any un-clipped updates\n go.update(fps, lm.gravity);\n}\n\n} else {\n  // Set visible flag to false\n  //...\n```", "```java\ncanvas.drawText(\"playerY:\" +   lm.gameObjects.get(lm.playerIndex).getWorldLocation().y,\n  10, 140, paint);\n\ncanvas.drawText(\"Gravity:\" + \n lm.gravity, 10, 160, paint);\n\ncanvas.drawText(\"X velocity:\" +   lm.gameObjects.get(lm.playerIndex).getxVelocity(), \n 10, 180, paint);\n\ncanvas.drawText(\"Y velocity:\" +   lm.gameObjects.get(lm.playerIndex).getyVelocity(), \n 10, 200, paint);\n\n//for reset the number of clipped objects each frame\n```", "```java\npublic void switchPlayingStatus() {\n        playing = !playing;\n        if (playing) {\n            gravity = 6;\n        } else {\n            gravity = 0;\n        }\n    }\n```", "```java\n// Load all the GameObjects and Bitmaps\nloadMapData(context, pixelsPerMetre, px, py);\n\n//playing = true;\n//..\n```", "```java\n@Override\npublic boolean onTouchEvent(MotionEvent motionEvent) {\n  switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n    case MotionEvent.ACTION_DOWN:\n         lm.switchPlayingStatus();\n         break;\n   }\nreturn true;\n}\n```", "```java\nif (lm.isPlaying()) {\n    //Reset the players location as the centre of the viewport\n    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().x,\n        lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().y);}\n}// End of update()\n```", "```java\npublic class RectHitbox {\n    float top;\n    float left;\n    float bottom;\n    float right;\n    float height;\n\n    boolean intersects(RectHitbox rectHitbox){\n        boolean hit = false;\n\n        if(this.right > rectHitbox.left\n                && this.left < rectHitbox.right ){\n            // Intersecting on x axis\n\n            if(this.top < rectHitbox.bottom\n                    && this.bottom > rectHitbox.top ){\n                // Intersecting on y as well\n                // Collision\n                hit = true;\n            }\n        }\n\n        return hit;\n    }\n\n    public void setTop(float top) {\n        this.top = top;\n    }\n\n    public float getLeft() {\n        return left;\n    }\n\n    public void setLeft(float left) {\n        this.left = left;\n    }\n\n    public void setBottom(float bottom) {\n        this.bottom = bottom;\n    }\n\n    public float getRight() {\n        return right;\n    }\n\n    public void setRight(float right) {\n        this.right = right;\n    }\n\n    public float getHeight() {\n        return height;\n    }\n\n    public void setHeight(float height) {\n        this.height = height;\n    }\n}\n```", "```java\nprivate RectHitbox rectHitbox = new RectHitbox();\n```", "```java\npublic void setRectHitbox() {\n   rectHitbox.setTop(worldLocation.y);\n   rectHitbox.setLeft(worldLocation.x);\n   rectHitbox.setBottom(worldLocation.y + height);\n   rectHitbox.setRight(worldLocation.x + width);\n}\n\nRectHitbox getHitbox(){\n  return rectHitbox;\n}\n```", "```java\n// Where does the tile start\n// X and y locations from constructor parameters\nsetWorldLocation(worldStartX, worldStartY, 0);\nsetRectHitbox();\n}// End of Grass constructor\n```", "```java\nRectHitbox rectHitboxFeet;\nRectHitbox rectHitboxHead;\nRectHitbox rectHitboxLeft;\nRectHitbox rectHitboxRight;\n```", "```java\nrectHitboxFeet = new RectHitbox();\nrectHitboxHead = new RectHitbox();\nrectHitboxLeft = new RectHitbox();\nrectHitboxRight = new RectHitbox();\n```", "```java\n// Let's go!\nthis.move(fps);\n\n// Update all the hitboxes to the new location\n// Get the current world location of the player\n// and save them as local variables we will use next\nVector2Point5D location = getWorldLocation();\nfloat lx = location.x;\nfloat ly = location.y;\n\n//update the player feet hitbox\nrectHitboxFeet.top = ly + getHeight() * .95f;\nrectHitboxFeet.left = lx + getWidth() * .2f;\nrectHitboxFeet.bottom = ly + getHeight() * .98f;\nrectHitboxFeet.right = lx + getWidth() * .8f;\n\n// Update player head hitbox\nrectHitboxHead.top = ly;\nrectHitboxHead.left = lx + getWidth() * .4f;\nrectHitboxHead.bottom = ly + getHeight() * .2f;\nrectHitboxHead.right = lx + getWidth() * .6f;\n\n// Update player left hitbox\nrectHitboxLeft.top = ly + getHeight() * .2f;\nrectHitboxLeft.left = lx + getWidth() * .2f;\nrectHitboxLeft.bottom = ly + getHeight() * .8f;\nrectHitboxLeft.right = lx + getWidth() * .3f;\n\n// Update player right hitbox\nrectHitboxRight.top = ly + getHeight() * .2f;\nrectHitboxRight.left = lx + getWidth() * .8f;\nrectHitboxRight.bottom = ly + getHeight() * .8f;\nrectHitboxRight.right = lx + getWidth() * .7f;\n\n}// End update()\n```", "```java\npublic int checkCollisions(RectHitbox rectHitbox) {\n    int collided = 0;// No collision\n\n    // The left\n    if (this.rectHitboxLeft.intersects(rectHitbox)) {\n        // Left has collided\n        // Move player just to right of current hitbox\n        this.setWorldLocationX(rectHitbox.right - getWidth() * .2f);\n        collided = 1;\n    }\n\n    // The right\n    if (this.rectHitboxRight.intersects(rectHitbox)) {\n        // Right has collided\n        // Move player just to left of current hitbox\n        this.setWorldLocationX(rectHitbox.left - getWidth() * .8f);\n        collided = 1;\n    }\n\n    // The feet\n    if (this.rectHitboxFeet.intersects(rectHitbox)) {\n        // Feet have collided\n        // Move feet to just above current hitbox\n        this.setWorldLocationY(rectHitbox.top - getHeight());\n        collided = 2;\n    }\n\n    // Now the head\n    if (this.rectHitboxHead.intersects(rectHitbox)) {\n        // Head has collided. Ouch!\n        // Move head to just below current hitbox bottom\n        this.setWorldLocationY(rectHitbox.bottom);\n        collided = 3;\n    }\n\n    return collided;\n}\n```", "```java\npublic void setWorldLocationY(float y) {\n  this.worldLocation.y = y;\n}\n\npublic void setWorldLocationX(float x) {\n  this.worldLocation.x = x;\n}\n```", "```java\n// Set visible flag to true\ngo.setVisible(true);\n\n// check collisions with player\nint hit = lm.player.checkCollisions(go.getHitbox());\nif (hit > 0) {\n //collision! Now deal with different types\n switch (go.getType()) {\n\n default:// Probably a regular tile\n if (hit == 1) {// Left or right\n lm.player.setxVelocity(0);\n lm.player.setPressingRight(false);\n }\n\n if (hit == 2) {// Feet\n lm.player.isFalling = false;\n }\n\n break;\n }\n}\n\n```", "```java\npublic void setPressingRight(boolean isPressingRight) {\n        this.isPressingRight = isPressingRight;\n    }\n\n    public void setPressingLeft(boolean isPressingLeft) {\n        this.isPressingLeft = isPressingLeft;\n    }\n\n    public void startJump(SoundManager sm) {\n        if (!isFalling) {//can't jump if falling\n            if (!isJumping) {//not already jumping\n                isJumping = true;\n                jumpTime = System.currentTimeMillis();\n                sm.playSound(\"jump\");\n            }\n        }\n    }\n```", "```java\n@Override\n    public boolean onTouchEvent(MotionEvent motionEvent) {\n        if (lm != null) {\n            ic.handleInput(motionEvent, lm, sm, vp);\n        }\n        //invalidate();\n        return true;\n    }\n```", "```java\nimport android.graphics.Rect;\nimport android.view.MotionEvent;\nimport java.util.ArrayList;\n\npublic class InputController {\n\n    Rect left;\n    Rect right;\n    Rect jump;\n    Rect shoot;\n    Rect pause;\n\n    InputController(int screenWidth, int screenHeight) {\n\n        //Configure the player buttons\n        int buttonWidth = screenWidth / 8;\n        int buttonHeight = screenHeight / 7;\n        int buttonPadding = screenWidth / 80;\n\n        left = new Rect(buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth,\n            screenHeight - buttonPadding);\n\n        right = new Rect(buttonWidth + buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth + buttonPadding + buttonWidth,\n            screenHeight - buttonPadding);\n\n        jump = new Rect(screenWidth - buttonWidth - buttonPadding,\n            screenHeight - buttonHeight - buttonPadding -                           \n            buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding - buttonHeight -                           \n            buttonPadding);\n\n        shoot = new Rect(screenWidth - buttonWidth - buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding);\n\n        pause = new Rect(screenWidth - buttonPadding -                          \n            buttonWidth,\n            buttonPadding,\n            screenWidth - buttonPadding,\n            buttonPadding + buttonHeight);\n\n    }\n```", "```java\npublic ArrayList getButtons(){\n   //create an array of buttons for the draw method\n   ArrayList<Rect> currentButtonList = new ArrayList<>();\n   currentButtonList.add(left);\n   currentButtonList.add(right);\n   currentButtonList.add(jump);\n   currentButtonList.add(shoot);\n   currentButtonList.add(pause);\n   return  currentButtonList;\n}\n```", "```java\npublic void handleInput(MotionEvent motionEvent,LevelManager l,     \n  SoundManager sound, Viewport vp){\n\n    int pointerCount = motionEvent.getPointerCount();\n\n    for (int i = 0; i < pointerCount; i++) {\n\n        int x = (int) motionEvent.getX(i);\n        int y = (int) motionEvent.getY(i);\n\n        if(l.isPlaying()) {\n            switch  (motionEvent.getAction() &\n            MotionEvent.ACTION_MASK) {\n\n            case MotionEvent.ACTION_DOWN:\n                    if (right.contains(x, y)) {\n                    l.player.setPressingRight(true);\n                    l.player.setPressingLeft(false);\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(true);\n                    l.player.setPressingRight(false);\n\n                    } else if (jump.contains(x, y)) {\n                    l.player.startJump(sound);\n\n                    } else if (shoot.contains(x, y)) {\n\n                    } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                    }\n\n                break;\n\n                case MotionEvent.ACTION_UP:\n                    if (right.contains(x, y)) {\n                    l.player.setPressingRight(false);\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(false);\n                }\n\n                break;\n\n                case MotionEvent.ACTION_POINTER_DOWN:\n                if (right.contains(x, y)) {\n                    l.player.setPressingRight(true);\n                    l.player.setPressingLeft(false);\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(true);\n                        l.player.setPressingRight(false);\n\n                    } else if (jump.contains(x, y)) {\n                    l.player.startJump(sound);\n\n                    } else if (shoot.contains(x, y)) {\n                    //Handle shooting here\n\n                    } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                }\n\n                    break;\n\n                case MotionEvent.ACTION_POINTER_UP:\n                    if (right.contains(x, y)) {\n                    l.player.setPressingRight(false);\n                   //Log.w(\"rightP:\", \"up\" );\n\n                    } else if (left.contains(x, y)) {\n                    l.player.setPressingLeft(false);\n                   //Log.w(\"leftP:\", \"up\" );\n\n                    } else if (shoot.contains(x, y)) {\n                    //Handle shooting here\n                    } else if (jump.contains(x, y)) {\n                   //Handle more jumping stuff here later\n                }\n\n                break;\n}// End if(l.playing)\n\n}else {// Not playing\n    //Move the viewport around to explore the map\n    switch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n\n    case MotionEvent.ACTION_DOWN:\n\n        if (pause.contains(x, y)) {\n            l.switchPlayingStatus();\n            //Log.w(\"pause:\", \"DOWN\" );\n        }\n\n      break;\n            }\n        }\n    }\n}\n}\n```", "```java\n//draw buttons\npaint.setColor(Color.argb(80, 255, 255, 255));\nArrayList<Rect> buttonsToDraw;\nbuttonsToDraw = ic.getButtons();\n\nfor (Rect rect : buttonsToDraw) {\n  RectF rf = new RectF(rect.left, rect.top, \n    rect.right, rect.bottom);\n\n    canvas.drawRoundRect(rf, 15f, 15f, paint);\n}\n```", "```java\n//draw paused text\nif (!this.lm.isPlaying()) {\n    paint.setTextAlign(Paint.Align.CENTER);\n    paint.setColor(Color.argb(255, 255, 255, 255));\n\n    paint.setTextSize(120);\n    canvas.drawText(\"Paused\", vp.getScreenWidth() / 2,                       \n    vp.getScreenHeight() / 2, paint);\n}\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.Rect;\n\npublic class Animation {\n    Bitmap bitmapSheet;\n    String bitmapName;\n    private Rect sourceRect;\n    private int frameCount;\n    private int currentFrame;\n    private long frameTicker;\n    private int framePeriod;\n    private int frameWidth;\n    private int frameHeight;\n    int pixelsPerMetre;\n```", "```java\nAnimation(Context context, \n  String bitmapName, float frameHeight, \n  float frameWidth, int animFps, \n  int frameCount, int pixelsPerMetre){\n\n   this.currentFrame = 0;\n   this.frameCount = frameCount;\n   this.frameWidth = (int)frameWidth * pixelsPerMetre;\n   this.frameHeight = (int)frameHeight * pixelsPerMetre;\n   sourceRect = new Rect(0, 0, this.frameWidth, this.frameHeight);\n\n   framePeriod = 1000 / animFps;\n   frameTicker = 0l;\n   this.bitmapName = \"\" + bitmapName;\n   this.pixelsPerMetre = pixelsPerMetre;\n}\n```", "```java\npublic Rect getCurrentFrame(long time, \n    float xVelocity, boolean moves){\n\n    if(xVelocity!=0 || moves == false) {\n    // Only animate if the object is moving \n    // or it is an object which doesn't move\n    // but is still animated (like fire)\n\n        if (time > frameTicker + framePeriod) {\n            frameTicker = time;\n            currentFrame++;\n            if (currentFrame >= frameCount) {\n                currentFrame = 0;\n            }\n        }\n    }\n\n    //update the left and right values of the source of\n    //the next frame on the spritesheet\n    this.sourceRect.left = currentFrame * frameWidth;\n    this.sourceRect.right = this.sourceRect.left + frameWidth;\n\n    return sourceRect;\n\n}\n\n}// End of Animation class\n```", "```java\n// Most objects only have 1 frame\n// And don't need to bother with these\nprivate Animation anim = null;\nprivate boolean animated;\nprivate int animFps = 1;\n```", "```java\npublic void setAnimFps(int animFps) {\n  this.animFps = animFps;\n}\n\npublic void setAnimFrameCount(int animFrameCount) {\n  this.animFrameCount = animFrameCount;\n}\n\npublic boolean isAnimated() {\n  return animated;\n}\n```", "```java\npublic void setAnimated(Context context, int pixelsPerMetre,  \n  boolean animated){\n\n this.animated = animated;\n this.anim = new Animation(context, bitmapName,\n     height,\n     width,\n     animFps,\n     animFrameCount,\n     pixelsPerMetre );\n}\n```", "```java\npublic Rect getRectToDraw(long deltaTime){\n  return anim.getCurrentFrame(\n    deltaTime, \n    xVelocity, \n    isMoves());\n}\n```", "```java\nsetBitmapName(\"player\");\n\nfinal int ANIMATION_FPS = 16;\nfinal int ANIMATION_FRAME_COUNT = 5;\n\n// Set this object up to be animated\nsetAnimFps(ANIMATION_FPS);\nsetAnimFrameCount(ANIMATION_FRAME_COUNT);\nsetAnimated(context, pixelsPerMetre, true);\n\n// X and y locations from constructor parameters\nsetWorldLocation(worldStartX, worldStartY, 0);\n```", "```java\ntoScreen2d.set(vp.worldToScreen\n  go.getWorldLocation().x,\n  go.getWorldLocation().y,\n  go.getWidth(),\n  go.getHeight()));\n\nif (go.isAnimated()) {\n // Get the next frame of the bitmap\n // Rotate if necessary\n if (go.getFacing() == 1) {\n // Rotate\n Matrix flipper = new Matrix();\n flipper.preScale(-1, 1);\n Rect r = go.getRectToDraw(System.currentTimeMillis());\n Bitmap b = Bitmap.createBitmap(\n lm.bitmapsArray[lm.getBitmapIndex(go.getType())],\n r.left,\n r.top,\n r.width(),\n r.height(),\n flipper,\n true);\n canvas.drawBitmap(b, toScreen2d.left, toScreen2d.top, paint);\n} else {\n // draw it the regular way round\n canvas.drawBitmap(\n lm.bitmapsArray[lm.getBitmapIndex(go.getType())],\n go.getRectToDraw(System.currentTimeMillis()),\n toScreen2d, paint);\n}\n} else { // Just draw the whole bitmap\n canvas.drawBitmap(\n lm.bitmapsArray[lm.getBitmapIndex(go.getType())],\n toScreen2d.left,\n toScreen2d.top, paint);\n}\n\n```", "```java\npublic class Bullet  {\n\n    private float x;\n    private float y;\n    private float xVelocity;\n    private int direction;\n\n    Bullet(float x, float y, int speed, int direction){\n        this.direction = direction;\n        this.x = x;\n        this.y = y;\n        this.xVelocity = speed * direction;\n    }\n\n    public int getDirection(){\n        return direction;\n    }\n\n    public void update(long fps, float gravity){\n        x += xVelocity / fps;\n    }\n\n    public void hideBullet(){\n        this.x = -100;\n        this.xVelocity = 0;\n    }\n\n    public float getX(){\n        return x;\n    }\n\n    public float getY(){\n        return y;\n    }\n\n}\n```", "```java\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic class MachineGun extends GameObject{\n    private int maxBullets = 10;\n    private int numBullets;\n    private int nextBullet;\n    private int rateOfFire = 1;//bullets per second\n    private long lastShotTime;\n\n    private CopyOnWriteArrayList<Bullet> bullets;\n\n    int speed = 25;\n```", "```java\nMachineGun(){\n   bullets = new CopyOnWriteArrayList<Bullet>();\n   lastShotTime = -1;\n   nextBullet = -1;\n}\n```", "```java\npublic void update(long fps, float gravity){\n        //update all the bullets\n        for(Bullet bullet: bullets){\n            bullet.update(fps, gravity);\n        }\n    }\n```", "```java\npublic int getRateOfFire(){\n  return rateOfFire;\n}\n\npublic void setFireRate(int rate){\n  rateOfFire = rate;\n}\n\npublic int getNumBullets(){\n  //tell the view how many bullets there are\n  return numBullets;\n}\n\npublic float getBulletX(int bulletIndex){\n  if(bullets != null && bulletIndex < numBullets) {\n       return bullets.get(bulletIndex).getX();\n    }\n\n  return -1f;\n}\n\npublic float getBulletY(int bulletIndex){\n  if(bullets != null) {\n       return bullets.get(bulletIndex).getY();\n     }\n     return -1f;\n}\n```", "```java\npublic void hideBullet(int index){\n  bullets.get(index).hideBullet();\n}\n```", "```java\npublic int getDirection(int index){\n  return bullets.get(index).getDirection();\n}\n```", "```java\npublic boolean shoot(float ownerX, float ownerY, \n    int ownerFacing, float ownerHeight){\n\n    boolean shotFired = false;\n    if(System.currentTimeMillis() - lastShotTime  >                          \n      1000/rateOfFire){\n\n        //spawn another bullet;\n        nextBullet ++;\n\n        if(numBullets >= maxBullets){\n            numBullets = maxBullets;\n        }\n\n        if(nextBullet == maxBullets){\n            nextBullet = 0;\n        }\n\n        lastShotTime = System.currentTimeMillis();\n        bullets.add(nextBullet, \n                new Bullet(ownerX, \n                (ownerY+ ownerHeight/3), speed, ownerFacing));\n\n        shotFired = true;\n        numBullets++;\n    }\n    return shotFired;\n}\n```", "```java\npublic void upgradeRateOfFire(){\n  rateOfFire += 2;\n}\n}// End of MachineGun class\n```", "```java\npublic MachineGun bfg;\n```", "```java\nbfg = new MachineGun();\n```", "```java\nbfg.update(fps, gravity);\n\n// Let's go!\nthis.move(fps);\n```", "```java\npublic boolean pullTrigger() {\n        //Try and fire a shot\n        return bfg.shoot(this.getWorldLocation().x,  \n           this.getWorldLocation().y, \n           getFacing(), getHeight());\n}\n```", "```java\n} else if (jump.contains(x, y)) {\n  l.player.startJump(sound);\n\n} else if (shoot.contains(x, y)) {\n if (l.player.pullTrigger()) {\n sound.playSound(\"shoot\");\n }\n\n} else if (pause.contains(x, y)) {\n  l.switchPlayingStatus();\n\n}\n```", "```java\n} else if (jump.contains(x, y)) {\n  l.player.startJump(sound);\n\n} else if (shoot.contains(x, y)) {\n if (l.player.pullTrigger()) {\n sound.playSound(\"shoot\");\n}\n\n} else if (pause.contains(x, y)) {\n  l.switchPlayingStatus();\n}\n```", "```java\n//draw the bullets\npaint.setColor(Color.argb(255, 255, 255, 255));\nfor (int i = 0; i < lm.player.bfg.getNumBullets(); i++) {\n   // Pass in the x and y coords as usual\n   // then .25 and .05 for the bullet width and height\n   toScreen2d.set(vp.worldToScreen\n            (lm.player.bfg.getBulletX(i),\n            lm.player.bfg.getBulletY(i),\n            .25f,\n            .05f));\n\n        canvas.drawRect(toScreen2d, paint);\n}\n\n// Text for debugging\nif (debugging) {\n// etc\n```", "```java\nimport android.graphics.PointF;\n\npublic class PlayerState {\n\n    private int numCredits;\n    private int mgFireRate;\n    private int lives;\n    private float restartX;\n    private float restartY;\n\n    PlayerState() {\n        lives = 3;\n        mgFireRate = 1;\n        numCredits = 0;\n    }\n```", "```java\npublic void saveLocation(PointF location) {\n   // The location saves each time the player uses a teleport\n     restartX = location.x;\n     restartY = location.y;\n}\n\npublic PointF loadLocation() {\n   // Used every time the player loses a life\n   return new PointF(restartX, restartY);\n}\n```", "```java\npublic int getLives(){\n  return lives;\n}\n\npublic int getFireRate(){\n  return mgFireRate;\n}\n\npublic void increaseFireRate(){\n  mgFireRate += 2;\n}\n\npublic void gotCredit(){\n  numCredits ++;\n}\n\npublic int getCredits(){\n  return numCredits;\n}\n\npublic void loseLife(){\n  lives--;\n}\n\npublic void addLife(){\n  lives++;\n}\n\npublic void resetLives(){\n  lives = 3;\n}\npublic void resetCredits(){\n  lives = 0;\n}\n\n}// End PlayerState class\n```", "```java\n// Our new engine classes\nprivate LevelManager lm;\nprivate Viewport vp;\nInputController ic;\nSoundManager sm;\nprivate PlayerState ps;\n\n```", "```java\nvp = new Viewport(screenWidth, screenHeight);\nsm = new SoundManager();\nsm.loadSound(context);\nps = new PlayerState();\n\nloadLevel(\"LevelCave\", 10, 2);\n```", "```java\nic = new InputController(vp.getScreenWidth(), vp.getScreenHeight());\n\nPointF location = new PointF(px, py);\nps.saveLocation(location);\n\n//set the players location as the world centre of the viewport\n```", "```java\npublic class Coin extends GameObject{\n\n    Coin(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = .5f;\n        final float WIDTH = .5f;\n\n        setHeight(HEIGHT); \n        setWidth(WIDTH); \n\n        setType(type);\n\n        // Choose a Bitmap\n        setBitmapName(\"coin\");\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity){}\n}\n```", "```java\npublic class ExtraLife extends GameObject{\n\n    ExtraLife(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = .8f;\n        final float WIDTH = .65f;\n\n        setHeight(HEIGHT); \n        setWidth(WIDTH); \n\n        setType(type);\n\n        // Choose a Bitmap\n\n        setBitmapName(\"life\");\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity){}\n}\n```", "```java\npublic class MachineGunUpgrade extends GameObject{\n    MachineGunUpgrade(float worldStartX, \n        float worldStartY, \n        char type) {\n\n        final float HEIGHT = .5f;\n        final float WIDTH = .5f;\n\n        setHeight(HEIGHT); \n        setWidth(WIDTH); \n\n        setType(type);\n\n        // Choose a Bitmap\n\n        setBitmapName(\"clip\");\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity){}\n}\n```", "```java\ncase 'p':\n  index = 2;\n  break;\n\ncase 'c':\n index = 3;\n break;\n\ncase 'u':\n index = 4;\n break;\n\ncase 'e':\n index = 5;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'p':\n  index = 2;\n  break;\n\ncase 'c':\n index = 3;\n break;\n\ncase 'u':\n index = 4;\n break;\n\ncase 'e':\n index = 5;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'p':// a player\n    // Add a player to the gameObjects\n    gameObjects.add(new Player(context, px, py, pixelsPerMetre));\n    // We want the index of the player\n    playerIndex = currentIndex;\n    // We want a reference to the player object\n    player = (Player) gameObjects.get(playerIndex);\n    break;\n\ncase 'c':\n // Add a coin to the gameObjects\n gameObjects.add(new Coin(j, i, c));\n break;\n\ncase 'u':\n // Add a machine gun upgrade to the gameObjects\n gameObjects.add(new MachineGunUpgrade(j, i, c));\n break;\n\ncase 'e':\n // Add an extra life to the gameObjects\n gameObjects.add(new ExtraLife(j, i, c));\n break;\n}\n\n```", "```java\n// Tile types\n// . = no tile\n// 1 = Grass\n// 2 = Snow\n// 3 = Brick\n// 4 = Coal\n// 5 = Concrete\n// 6 = Scorched\n// 7 = Stone\n\n//Active objects\n// g = guard\n// d = drone\n// t = teleport\n// c = coin\n// u = upgrade\n// f = fire\n// e  = extra life\n\n//Inactive objects\n// w = tree\n// x = tree2 (snowy)\n// l = lampost\n// r = stalactite\n// s = stalacmite\n// m = mine cart\n// z = boulders\n\n```", "```java\npublic void restorePreviousVelocity() {\n  if (!isJumping && !isFalling) {\n       if (getFacing() == LEFT) {\n           isPressingLeft = true;\n           setxVelocity(-MAX_X_VELOCITY);\n         } else {\n           isPressingRight = true;\n                     setxVelocity(MAX_X_VELOCITY);\n       }\n    }\n}\n```", "```java\nswitch (go.getType()) {\n case 'c':\n sm.playSound(\"coin_pickup\");\n go.setActive(false);\n go.setVisible(false);\n ps.gotCredit();\n\n // Now restore state that was \n // removed by collision detection\n if (hit != 2) {// Any hit except feet\n lm.player.restorePreviousVelocity();\n }\n break;\n\ncase 'u':\n sm.playSound(\"gun_upgrade\");\n go.setActive(false);\n go.setVisible(false);\n lm.player.bfg.upgradeRateOfFire();\n ps.increaseFireRate();\n if (hit != 2) {// Any hit except feet\n lm.player.restorePreviousVelocity();\n }\n break;\n\ncase 'e':\n //extralife\n go.setActive(false);\n go.setVisible(false);\n sm.playSound(\"extra_life\");\n ps.addLife();\n\n if (hit != 2) {\n lm.player.restorePreviousVelocity();\n }\n break;\n\ndefault:// Probably a regular tile\n    if (hit == 1) {// Left or right\n        lm.player.setxVelocity(0);\n        lm.player.setPressingRight(false);\n    }\n\n    if (hit == 2) {// Feet\n        lm.player.isFalling = false;\n    }\n    break;\n}\n```", "```java\npublic class LevelCave extends LevelData{\n  LevelCave() {\n    tiles = new ArrayList<String>();\n this.tiles.add(\"p.............................................\");\n this.tiles.add(\"..............................................\");\n this.tiles.add(\"..............................................\");\n this.tiles.add(\"..............................................\");\n this.tiles.add(\"....................c.........................\");\n this.tiles.add(\"....................1........u................\");\n this.tiles.add(\".................c..........u1................\");\n this.tiles.add(\".................1.........u1.................\");\n this.tiles.add(\"..............c...........u1..................\");\n this.tiles.add(\"..............1..........u1...................\");\n this.tiles.add(\"......................e..1....e.....e.........\");\n this.tiles.add(\"....11111111111111111111111111111111111111....\");\n}\n\n```", "```java\nimport android.graphics.PointF;\n\npublic class Drone extends GameObject {\n\n    long lastWaypointSetTime;\n    PointF currentWaypoint;\n\n    final float MAX_X_VELOCITY = 3;\n    final float MAX_Y_VELOCITY = 3;\n```", "```java\nDrone(float worldStartX, float worldStartY, char type) {\n    final float HEIGHT = 1;\n    final float WIDTH = 1;\n    setHeight(HEIGHT); // 1 metre tall\n    setWidth(WIDTH); // 1 metres wide\n\n    setType(type);\n\n    setBitmapName(\"drone\");\n    setMoves(true);\n    setActive(true);\n    setVisible(true);\n\n    currentWaypoint = new PointF();\n\n    // Where does the drone start\n    // X and y locations from constructor parameters\n    setWorldLocation(worldStartX, worldStartY, 0);\n    setRectHitbox();\n    setFacing(RIGHT);\n}\n```", "```java\npublic void update(long fps, float gravity) {\n  if (currentWaypoint.x > getWorldLocation().x) {\n       setxVelocity(MAX_X_VELOCITY);\n   } else if (currentWaypoint.x < getWorldLocation().x) {\n       setxVelocity(-MAX_X_VELOCITY);\n   } else {\n       setxVelocity(0);\n   }\n\n    if (currentWaypoint.y >= getWorldLocation().y) {\n       setyVelocity(MAX_Y_VELOCITY);\n     } else if (currentWaypoint.y < getWorldLocation().y) {\n       setyVelocity(-MAX_Y_VELOCITY);\n     } else {\n       setyVelocity(0);\n  }\n\n  move(fps);\n\n  // update the drone hitbox\n   setRectHitbox();\n\n}\n```", "```java\npublic void setWaypoint(Vector2Point5D playerLocation) {\n  if (System.currentTimeMillis() > lastWaypointSetTime + 2000) {//Has 2 seconds passed\n        lastWaypointSetTime = System.currentTimeMillis();\n        currentWaypoint.x = playerLocation.x;\n        currentWaypoint.y = playerLocation.y;\n     }\n}\n}// End Drone class\n```", "```java\ncase 'e':\n  index = 5;\n  break;\n\ncase 'd':\n index = 6;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'e':\n  index = 5;\n  break;\n\ncase 'd':\n index = 6;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'e':\n   // Add an extra life to the gameObjects\n   gameObjects.add(new ExtraLife(j, i, c));\n   break;\n\ncase 'd':\n // Add a drone to the gameObjects\n gameObjects.add(new Drone(j, i, c));\n break;\n\n```", "```java\nif (lm.isPlaying()) {\n   // Run any un-clipped updates\n   go.update(fps, lm.gravity);\n\n if (go.getType() == 'd') {\n // Let any near by drones know where the player is\n Drone d = (Drone) go;\n d.setWaypoint(lm.player.getWorldLocation());\n }\n}\n```", "```java\ncase 'e':\n  //extralife\n   go.setActive(false);\n   go.setVisible(false);\n   sm.playSound(\"extra_life\");\n   ps.addLife();\n   if (hit != 2) {// Any hit except feet\n       lm.player.restorePreviousVelocity();\n   }\n   break;\n\ncase 'd':\n PointF location;\n //hit by drone\n sm.playSound(\"player_burn\");\n ps.loseLife();\n location = new PointF(ps.loadLocation().x, \n ps.loadLocation().y);\n lm.player.setWorldLocationX(location.x);\n lm.player.setWorldLocationY(location.y);\n lm.player.setxVelocity(0);\n break;\n\ndefault:// Probably a regular tile\n  if (hit == 1) {// Left or right\n       lm.player.setxVelocity(0);\n       lm.player.setPressingRight(false);\n  }\n\n   if (hit == 2) {// Feet\n       lm.player.isFalling = false;\n   }\n```", "```java\nimport android.content.Context;\n\npublic class Guard extends GameObject {\n\n    // Guards just move on x axis between 2 waypoints\n\n    private float waypointX1;// always on left\n    private float waypointX2;// always on right\n    private int currentWaypoint;\n    final float MAX_X_VELOCITY = 3;\n```", "```java\nGuard(Context context, float worldStartX, \n  float worldStartY, char type, \n  int pixelsPerMetre) {\n\n        final int ANIMATION_FPS = 8;\n        final int ANIMATION_FRAME_COUNT = 5;\n        final String BITMAP_NAME = \"guard\";\n        final float HEIGHT = 2f;\n        final float WIDTH = 1;\n\n        setHeight(HEIGHT); // 2 metre tall\n        setWidth(WIDTH); // 1 metres wide\n\n        setType(type);\n\n        setBitmapName(\"guard\");\n        // Now for the player's other attributes\n        // Our game engine will use these\n        setMoves(true);\n        setActive(true);\n        setVisible(true);\n\n        // Set this object up to be animated\n        setAnimFps(ANIMATION_FPS);\n        setAnimFrameCount(ANIMATION_FRAME_COUNT);\n        setBitmapName(BITMAP_NAME);\n        setAnimated(context, pixelsPerMetre, true);\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setxVelocity(-MAX_X_VELOCITY);\n        currentWaypoint = 1;\n}\n```", "```java\npublic void setWaypoints(float x1, float x2){\n  waypointX1 = x1;\n  waypointX2 = x2;\n}\n```", "```java\npublic void update(long fps, float gravity) {\n  if(currentWaypoint == 1) {// Heading left\n       if (getWorldLocation().x <= waypointX1) {\n          // Arrived at waypoint 1\n           currentWaypoint = 2;\n           setxVelocity(MAX_X_VELOCITY);\n           setFacing(RIGHT);\n      }\n  }\n\n  if(currentWaypoint == 2){\n    if (getWorldLocation().x >= waypointX2) {\n         // Arrived at waypoint 2\n          currentWaypoint = 1;\n          setxVelocity(-MAX_X_VELOCITY);\n          setFacing(LEFT);\n      }\n  }\n\n  move(fps);\n   // update the guards hitbox\n   setRectHitbox();\n}\n}// End Guard class\n```", "```java\ncase 'd':\n  index = 6;\n  break;\n\ncase 'g':\n index = 7;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'd':\n  index = 6;\n  break;\n\ncase 'g':\n index = 7;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'd':\n     // Add a drone to the gameObjects\n     gameObjects.add(new Drone(j, i, c));\n     break;\ncase 'g':\n // Add a guard to the gameObjects\n gameObjects.add(new Guard(context, j, i, c, pixelsPerMetre));\n break;\n\n```", "```java\nprivate boolean traversable = false;\n```", "```java\npublic void setTraversable(){\n  traversable = true;\n}\n\npublic boolean isTraversable(){\n  return traversable;\n}\n```", "```java\nsetTraversable();\n```", "```java\npublic void setWaypoints() {\n  // Loop through all game objects looking for Guards\n    for (GameObject guard : this.gameObjects) {\n       if (guard.getType() == 'g') {\n```", "```java\n// Set waypoints for this guard\n// find the tile beneath the guard\n// this relies on the designer putting \n// the guard in sensible location\n\nint startTileIndex = -1;\nint startGuardIndex = 0;\nfloat waypointX1 = -1;\nfloat waypointX2 = -1;\n\nfor (GameObject tile : this.gameObjects) {\n    startTileIndex++;\n    if (tile.getWorldLocation().y == \n            guard.getWorldLocation().y + 2) {\n\n        // Tile is two spaces below current guard\n        // Now see if has same x coordinate\n        if (tile.getWorldLocation().x == \n            guard.getWorldLocation().x) {\n\n            // Found the tile the guard is \"standing\" on\n            // Now go left as far as possible \n            // before non travers-able tile is found\n            // Either on guards row or tile row\n            // upto a maximum of 5 tiles. \n            //  5 is an arbitrary value you can\n            // change it to suit\n\n            for (int i = 0; i < 5; i++) {// left for loop\n                if (!gameObjects.get(startTileIndex -\n                    i).isTraversable()) {\n\n                    //set the left waypoint\n                    waypointX1 = gameObjects.get(startTileIndex - \n                        (i + 1)).getWorldLocation().x;\n\n                     break;// Leave left for loop\n                     } else {\n                    // Set to max 5 tiles as \n                    // no non traversible tile found\n                    waypointX1 = gameObjects.get(startTileIndex -\n                        5).getWorldLocation().x;\n               }\n                }// end get left waypoint\n\n                for (int i = 0; i < 5; i++) {// right for loop\n                    if (!gameObjects.get(startTileIndex +\n                        i).isTraversable()) {\n\n                        //set the right waypoint\n                        waypointX2 = gameObjects.get(startTileIndex +\n                            (i - 1)).getWorldLocation().x;\n\n                    break;// Leave right for loop\n                    } else {\n                    //set to max 5 tiles away\n                    waypointX2 = gameObjects.get(startTileIndex +\n                       5).getWorldLocation().x;\n                }\n\n                }// end get right waypoint\n\n        Guard g = (Guard) guard;\n        g.setWaypoints(waypointX1, waypointX2);\n    }\n}\n}\n}\n}\n}// End setWaypoints()\n```", "```java\n// Load all the GameObjects and Bitmaps\nloadMapData(context, pixelsPerMetre, px, py);\n// Set waypoints for our guards\nsetWaypoints();\n\n```", "```java\ncase 'd':\n    PointF location;\n    //hit by drone\n    sm.playSound(\"player_burn\");\n    ps.loseLife();\n    location = new PointF(ps.loadLocation().x, \n        ps.loadLocation().y);\n\n    lm.player.setWorldLocationX(location.x);\n    lm.player.setWorldLocationY(location.y);\n    lm.player.setxVelocity(0);\n    break;\n\ncase 'g':\n // Hit by guard\n sm.playSound(\"player_burn\");\n ps.loseLife();\n location = new PointF(ps.loadLocation().x,\n ps.loadLocation().y);\n\n lm.player.setWorldLocationX(location.x);\n lm.player.setWorldLocationY(location.y);\n lm.player.setxVelocity(0);\n break;\n\ndefault:// Probably a regular tile\n    if (hit == 1) {// Left or right\n        lm.player.setxVelocity(0);\n        lm.player.setPressingRight(false);\n    }\n    if (hit == 2) {// Feet\n        lm.player.isFalling = false;\n    }\n```", "```java\n................g............................\n...........................d.................\n111111111111111111111111111111111111111111111\n```", "```java\ndefault:// Probably a regular tile\n    if (hit == 1) {// Left or right\n        lm.player.setxVelocity(0);\n        lm.player.setPressingRight(false);\n    }\n\n   if (hit == 2) {// Feet\n        lm.player.isFalling = false;\n    }\n    break;\n}\n}\n\n//Check bullet collisions\nfor (int i = 0; i < lm.player.bfg.getNumBullets(); i++) {\n //Make a hitbox out of the the current bullet\n RectHitbox r = new RectHitbox();\n r.setLeft(lm.player.bfg.getBulletX(i));\n r.setTop(lm.player.bfg.getBulletY(i));\n r.setRight(lm.player.bfg.getBulletX(i) + .1f);\n r.setBottom(lm.player.bfg.getBulletY(i) + .1f);\n\n if (go.getHitbox().intersects(r)) {\n // Collision detected\n // make bullet disappear until it \n // is respawned as a new bullet\n lm.player.bfg.hideBullet(i);\n\n //Now respond depending upon the type of object hit\n if (go.getType() != 'g' && go.getType() != 'd') {\n sm.playSound(\"ricochet\");\n\n } else if (go.getType() == 'g') {\n // Knock the guard back\n go.setWorldLocationX(go.getWorldLocation().x +\n 2 * (lm.player.bfg.getDirection(i)));\n\n sm.playSound(\"hit_guard\");\n\n } else if (go.getType() == 'd') {\n //destroy the droid\n sm.playSound(\"explode\");\n //permanently clip this drone\n go.setWorldLocation(-100, -100, 0);\n }\n }\n}\n\nif (lm.isPlaying()) {\n    // Run any un-clipped updates\n    go.update(fps, lm.gravity);\n        //...\n```", "```java\nimport android.content.Context;\n\npublic class Fire extends GameObject{\n\n    Fire(Context context, float worldStartX, \n    float worldStartY, char type, int pixelsPerMetre) {\n\n        final int ANIMATION_FPS = 3;\n        final int ANIMATION_FRAME_COUNT = 3;\n        final String BITMAP_NAME = \"fire\";\n\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n\n        setHeight(HEIGHT); // 1 metre tall\n        setWidth(WIDTH); // 1 metre wide\n\n        setType(type);\n        // Now for the player's other attributes\n        // Our game engine will use these\n        setMoves(false);\n        setActive(true);\n        setVisible(true);\n\n        // Choose a Bitmap\n        setBitmapName(BITMAP_NAME);\n        // Set this object up to be animated\n        setAnimFps(ANIMATION_FPS);\n        setAnimFrameCount(ANIMATION_FRAME_COUNT);\n        setBitmapName(BITMAP_NAME);\n        setAnimated(context, pixelsPerMetre, true);\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n public void update(long fps, float gravity) {\n }\n}\n```", "```java\ncase 'g':\n    index = 7;\n    break;\n\ncase 'f':\n index = 8;\n break;\n\ndefault:\n    index = 0;\n    break;\n```", "```java\ncase 'g':\n    index = 7;\n    break;\n\ncase 'f':\n index = 8;\n break;\n\ndefault:\n    index = 0;\n    break;\n```", "```java\ncase 'g':\n     // Add a guard to the gameObjects\n     gameObjects.add(new Guard(context, j, i, c, pixelsPerMetre));\n     break;\n\n case 'f':\n // Add a fire tile the gameObjects\n gameObjects.add(new Fire\n (context, j, i, c, pixelsPerMetre));\n\n break;\n\n```", "```java\ncase 'g':\n    //hit by guard\n    sm.playSound(\"player_burn\");\n    ps.loseLife();\n    location = new PointF(ps.loadLocation().x,\n        ps.loadLocation().y);\n    lm.player.setWorldLocationX(location.x);\n    lm.player.setWorldLocationY(location.y);\n    lm.player.setxVelocity(0);\n    break;\n\ncase 'f':\n sm.playSound(\"player_burn\");\n ps.loseLife();\n location = new PointF(ps.loadLocation().x,\n ps.loadLocation().y);\n lm.player.setWorldLocationX(location.x);\n lm.player.setWorldLocationY(location.y);\n lm.player.setxVelocity(0);\n break;\n\ndefault:// Probably a regular tile\n    if (hit == 1) {// Left or right\n        lm.player.setxVelocity(0);\n        lm.player.setPressingRight(false);\n    }\n\n    if (hit == 2) {// Feet\n        lm.player.isFalling = false;\n    }\n    break;\n```", "```java\npublic class Brick extends GameObject {\n\n    Brick(float worldStartX, float worldStartY, char type) {\n        setTraversable();\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n        setHeight(HEIGHT); \n        setWidth(WIDTH); \n        setType(type);\n        setBitmapName(\"brick\");\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\npublic class Coal extends GameObject {\n\n    Coal(float worldStartX, float worldStartY, char type) {\n        setTraversable();\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n        setHeight(HEIGHT); \n        setWidth(WIDTH);\n        setType(type);\n        setBitmapName(\"coal\");\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\npublic class Concrete extends GameObject {\n\n    Concrete(float worldStartX, float worldStartY, char type) {\n        setTraversable();\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n        setHeight(HEIGHT);\n        setWidth(WIDTH);\n        setType(type);\n        setBitmapName(\"concrete\");\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\npublic class Scorched extends GameObject {\n\n    Scorched(float worldStartX, float worldStartY, char type) {\n        setTraversable();\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n        setHeight(HEIGHT);\n        setWidth(WIDTH);\n        setType(type);\n        setBitmapName(\"scorched\");\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\npublic class Snow extends GameObject {\n\n    Snow(float worldStartX, float worldStartY, char type) {\n        setTraversable();\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n        setHeight(HEIGHT);\n        setWidth(WIDTH);\n        setType(type);\n        setBitmapName(\"snow\");\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\npublic class Stone extends GameObject {\n\n    Stone(float worldStartX, float worldStartY, char type) {\n        setTraversable();\n        final float HEIGHT = 1;\n        final float WIDTH = 1;\n        setHeight(HEIGHT);\n        setWidth(WIDTH); \n        setType(type);\n        setBitmapName(\"stone\");\n        setWorldLocation(worldStartX, worldStartY, 0);\n        setRectHitbox();\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\ncase 'f':\n    index = 8;\n    break;\n\ncase '2':\n index = 9;\n break;\n\ncase '3':\n index = 10;\n break;\n\ncase '4':\n index = 11;\n break;\n\ncase '5':\n index = 12;\n break;\n\ncase '6':\n index = 13;\n break;\n\ncase '7':\n index = 14;\n break;\n\ndefault:\n    index = 0;\n    break;\n```", "```java\ncase 'f':\n    index = 8;\n    break;\n\ncase '2':\n index = 9;\n break;\n\ncase '3':\n index = 10;\n break;\n\ncase '4':\n index = 11;\n break;\n\ncase '5':\n index = 12;\n break;\n\ncase '6':\n index = 13;\n break;\n\ncase '7':\n index = 14;\n break;\n\ndefault:\n    index = 0;\n    break;\n```", "```java\ncase 'f':\n    // Add a fire tile the gameObjects\n    gameObjects.add(new Fire(context, j, i, c, pixelsPerMetre));\n    break;\n\ncase '2':\n // Add a tile to the gameObjects\n gameObjects.add(new Snow(j, i, c));\n break;\n\ncase '3':\n // Add a tile to the gameObjects\n gameObjects.add(new Brick(j, i, c));\n break;\n\ncase '4':\n // Add a tile to the gameObjects\n gameObjects.add(new Coal(j, i, c));\n break;\n\ncase '5':\n // Add a tile to the gameObjects\n gameObjects.add(new Concrete(j, i, c));\n break;\n\ncase '6':\n // Add a tile to the gameObjects\n gameObjects.add(new Scorched(j, i, c));\n break;\n\ncase '7':\n // Add a tile to the gameObjects\n gameObjects.add(new Stone(j, i, c));\n break;\n\n```", "```java\npublic class Boulders extends GameObject {\n\n    Boulders(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = 1;\n        final float WIDTH = 3;\n\n        setHeight(HEIGHT); // 1 metre tall\n        setWidth(WIDTH); // 1 metre wide\n\n        setType(type);\n\n        // Choose a Bitmap\n        setBitmapName(\"boulder\");\n        setActive(false);//don't check for collisions etc\n\n        // Randomly set the tree either just in front or just \n        //behind the player -1 or 1\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n            setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n            setWorldLocation(worldStartX, worldStartY, 1);//\n        }\n        //No hitbox!!\n\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\npublic class Cart extends GameObject {\n\n  Cart(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = 2;\n        final float WIDTH = 3;\n        setWidth(WIDTH);\n        setHeight(HEIGHT);\n        setType(type);\n        setBitmapName(\"cart\");\n        setActive(false);\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n          setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n          setWorldLocation(worldStartX, worldStartY, 1);\n        }\n     }\n\n  public void update(long fps, float gravity) {\n     }\n}\n```", "```java\npublic class Lampost extends GameObject {\n\n  Lampost(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = 3;\n        final float WIDTH = 1;\n        setHeight(HEIGHT);\n        setWidth(WIDTH); \n        setType(type);\n        setBitmapName(\"lampost\");\n        setActive(false);\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n          setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n          setWorldLocation(worldStartX, worldStartY, 1);\n        }\n  }\n\n    public void update(long fps, float gravity) {\n   }\n}\n```", "```java\nimport java.util.Random;\n\npublic class Stalagmite extends GameObject {\n\n  Stalagmite(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = 3;\n        final float WIDTH = 2;\n        setHeight(HEIGHT);\n        setWidth(WIDTH);\n        setType(type);\n        setBitmapName(\"stalacmite\");\n        setActive(false);\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n         setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n         setWorldLocation(worldStartX, worldStartY, 1);\n        }\n    }\n\n    public void update(long fps, float gravity) {\n    }\n}\n```", "```java\nimport java.util.Random;\n\npublic class Stalactite extends GameObject {\n\n  Stalactite(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = 3;\n        final float WIDTH = 2;\n        setHeight(HEIGHT);\n        setWidth(WIDTH);\n        setType(type);\n        setBitmapName(\"stalactite\");\n        setActive(false);\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n          setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n          setWorldLocation(worldStartX, worldStartY, 1);\n        }\n  }\n\n     public void update(long fps, float gravity) {\n     }\n}\n```", "```java\nimport java.util.Random;\n\npublic class Tree extends GameObject {\n\n  Tree(float worldStartX, float worldStartY, char type) {\n\n       final float HEIGHT = 4;\n       final float WIDTH = 2;\n       setWidth(WIDTH);\n        setHeight(HEIGHT);\n        setType(type);\n        setBitmapName(\"tree1\");\n        setActive(false);\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n          setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n          setWorldLocation(worldStartX, worldStartY, 1);\n        }\n     }\n\n     public void update(long fps, float gravity) {\n     }\n}\n```", "```java\nimport java.util.Random;\n\npublic class Tree2 extends GameObject {\n\n  Tree2(float worldStartX, float worldStartY, char type) {\n\n        final float HEIGHT = 4;\n        final float WIDTH = 2;\n        setWidth(WIDTH);\n        setHeight(HEIGHT);\n        setType(type);\n        setBitmapName(\"tree2\");\n        setActive(false);\n        Random rand = new Random();\n        if(rand.nextInt(2)==0) {\n          setWorldLocation(worldStartX, worldStartY, -1);\n        }else{\n          setWorldLocation(worldStartX, worldStartY, 1);\n        }\n  }\n\n     public void update(long fps, float gravity) {\n     }\n}\n```", "```java\ncase '7':\n    index = 14;\n    break;\n\ncase 'w':\n index = 15;\n break;\n\ncase 'x':\n index = 16;\n break;\n\ncase 'l':\n index = 17;\n break;\n\ncase 'r':\n index = 18;\n break;\n\ncase 's':\n index = 19;\n break;\n\ncase 'm':\n index = 20;\n break;\n\ncase 'z':\n index = 21;\n break;\n\ndefault:\n    index = 0;\n    break;\n```", "```java\ncase '7':\n    index = 14;\n    break;\n\ncase 'w':\n index = 15;\n break;\n\ncase 'x':\n index = 16;\n break;\n\ncase 'l':\n index = 17;\n break;\n\ncase 'r':\n index = 18;\n break;\n\ncase 's':\n index = 19;\n break;\n\ncase 'm':\n index = 20;\n break;\n\ncase 'z':\n index = 21;\n break;\n\ndefault:\n    index = 0;\n    break;\n```", "```java\ncase '7':\n    // Add a tile to the gameObjects\n    gameObjects.add(new Stone(j, i, c));\n    break;\n\ncase 'w':\n // Add a tree to the gameObjects\n gameObjects.add(new Tree(j, i, c));\n break;\n\ncase 'x':\n // Add a tree2 to the gameObjects\n gameObjects.add(new Tree2(j, i, c));\n break;\n\ncase 'l':\n // Add a tree to the gameObjects\n gameObjects.add(new Lampost(j, i, c));\n break;\n\ncase 'r':\n // Add a stalactite to the gameObjects\n gameObjects.add(new Stalactite(j, i, c));\n break;\n\ncase 's':\n // Add a stalagmite to the gameObjects\n gameObjects.add(new Stalagmite(j, i, c));\n break;\n\ncase 'm':\n // Add a cart to the gameObjects\n gameObjects.add(new Cart(j, i, c));\n break;\n\ncase 'z':\n // Add a boulders to the gameObjects\n gameObjects.add(new Boulders(j, i, c));\n break;\n\n```", "```java\npublic class BackgroundData {\n  String bitmapName;\n     boolean isParallax;\n     //layer 0 is the map\n     int layer;\n     float startY;\n     float endY;\n     float speed;\n     int height;\n     int width;\n\n     BackgroundData(String bitmap, boolean isParallax, \n     int layer, float startY, float endY, \n     float speed, int height){\n\n      this.bitmapName = bitmap;\n      this.isParallax = isParallax;\n      this.layer = layer;\n      this.startY = startY;\n      this.endY = endY;\n      this.speed = speed;\n      this.height = height;\n  }\n}\n```", "```java\nArrayList<String> tiles;\nArrayList<BackgroundData> backgroundDataList;\n\n// This class will evolve along with the project\n```", "```java\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.Matrix;\n\npublic class Background {\n\n     Bitmap bitmap;\n     Bitmap bitmapReversed;\n\n     int width;\n     int height;\n\n     boolean reversedFirst;\n     int xClip;// controls where we clip the bitmaps each frame\n     float y;\n     float endY;\n     int z;\n\n     float speed;\n     boolean isParallax;//Not currently used\n```", "```java\n  Background(Context context, int yPixelsPerMetre, \n    int screenWidth, BackgroundData data){\n\n      int resID =   context.getResources().getIdentifier\n      (data.bitmapName, \"drawable\", \n      context.getPackageName());\n\n          bitmap = BitmapFactory.decodeResource\n          (context.getResources(), resID);\n\n          // Which version of background (reversed or regular) is // currently drawn first (on left)\n          reversedFirst = false;\n\n          //Initialize animation variables.\n          xClip = 0;  //always start at zero\n          y = data.startY;\n          endY = data.endY;\n          z = data.layer;\n          isParallax = data.isParallax;\n          speed = data.speed; //Scrolling background speed\n\n          //Scale background to fit the screen.\n          bitmap = Bitmap.createScaledBitmap(bitmap, screenWidth,\n                data.height * yPixelsPerMetre\n                , true); \n\n          width = bitmap.getWidth();\n          height = bitmap.getHeight();\n\n          // Create a mirror image of the background\n          Matrix matrix = new Matrix();  \n          matrix.setScale(-1, 1); //Horizontal mirror effect.\n          bitmapReversed = Bitmap.createBitmap(\n          bitmap, 0, 0, width, height, matrix, true);\n\n    }\n}\n```", "```java\nbackgroundDataList = new ArrayList<BackgroundData>();\n// note that speeds less than 2 cause problems\nthis.backgroundDataList.add(\n  new BackgroundData(\"skyline\", true, -1, 3, 18, 10, 15 ));\n\nthis.backgroundDataList.add(\n  new BackgroundData(\"grass\", true, 1, 20, 24, 24, 4 ));\n```", "```java\nLevelData levelData;\nArrayList<GameObject> gameObjects;\nArrayList<Background> backgrounds;\n\n```", "```java\nprivate void loadBackgrounds(Context context, \n  int pixelsPerMetre, int screenWidth) {\n\n  backgrounds = new ArrayList<Background>();\n     //load the background data into the Background objects and\n     // place them in our GameObject arraylist\n     for (BackgroundData bgData : levelData.backgroundDataList) {\n            backgrounds.add(new Background(context,       \n            pixelsPerMetre, screenWidth, bgData));\n     }\n}\n```", "```java\n// Load all the GameObjects and Bitmaps\nloadMapData(context, pixelsPerMetre, px, py);\nloadBackgrounds(context, pixelsPerMetre, screenWidth);\n\n```", "```java\npublic int getPixelsPerMetreY(){\n  return  pixelsPerMetreY;\n}\n\npublic int getyCentre(){\n  return screenCentreY;\n}\n\npublic float getViewportWorldCentreY(){\n  return currentViewportWorldCentre.y;\n}\n```", "```java\nprivate void drawBackground(int start, int stop) {\n\n     Rect fromRect1 = new Rect();\n     Rect toRect1 = new Rect();\n     Rect fromRect2 = new Rect();\n     Rect toRect2 = new Rect();\n```", "```java\n     for (Background bg : lm.backgrounds) {\n     if (bg.z < start && bg.z > stop) {\n\n```", "```java\n          // Is this layer in the viewport?\n            // Clip anything off-screen\n            if (!vp.clipObjects(-1, bg.y, 1000, bg.height)) {\n                float floatstartY = ((vp.getyCentre() -                     \n                    ((vp.getViewportWorldCentreY() - bg.y) * \n                    vp.getPixelsPerMetreY())));\n\n                int startY = (int) floatstartY;\n\n                float floatendY = ((vp.getyCentre() -           \n                    ((vp.getViewportWorldCentreY() - bg.endY) *                                 \n                    vp.getPixelsPerMetreY())));\n\n                int endY = (int) floatendY;\n```", "```java\n        // Define what portion of bitmaps to capture \n        // and what coordinates to draw them at\n        fromRect1 = new Rect(0, 0, bg.width - bg.xClip,     \n          bg.height);\n\n        toRect1 = new Rect(bg.xClip, startY, bg.width, endY);\n             fromRect2 = new Rect(bg.width - bg.xClip, 0, bg.width, bg.height);\n\n        toRect2 = new Rect(0, startY, bg.xClip, endY);\n        }// End if (!vp.clipObjects...\n```", "```java\n          //draw backgrounds\n            if (!bg.reversedFirst) {\n\n                canvas.drawBitmap(bg.bitmap,\n                    fromRect1, toRect1, paint);\n                canvas.drawBitmap(bg.bitmapReversed, \n                    fromRect2, toRect2, paint);\n\n            } else {\n                canvas.drawBitmap(bg.bitmap, \n                    fromRect2, toRect2, paint);\n\n                canvas.drawBitmap(bg.bitmapReversed, \n                    fromRect1, toRect1, paint);\n            }\n```", "```java\n          // Calculate the next value for the background's\n            // clipping position by modifying xClip\n            // and switching which background is drawn first,\n            // if necessary.\n            bg.xClip -= lm.player.getxVelocity() / (20 / bg.speed);\n            if (bg.xClip >= bg.width) {\n                bg.xClip = 0;\n                bg.reversedFirst = !bg.reversedFirst;\n            } \n            else if (bg.xClip <= 0) {\n                bg.xClip = bg.width;\n                bg.reversedFirst = !bg.reversedFirst;\n\n            }\n        }\n    }\n}\n```", "```java\n// Rub out the last frame with arbitrary color\npaint.setColor(Color.argb(255, 0, 0, 255));\ncanvas.drawColor(Color.argb(255, 0, 0, 255));\n\n// Draw parallax backgrounds from -1 to -3\ndrawBackground(0, -3);\n\n// Draw all the GameObjects\nRect toScreen2d = new Rect();\n```", "```java\n// Draw parallax backgrounds from layer 1 to 3\ndrawBackground(4, 0);\n\n// Text for debugging\n```", "```java\npublic void moveViewportRight(int maxWidth){\n  if(currentViewportWorldCentre.x < maxWidth -       \n    (metresToShowX/2)+3) {\n\n     currentViewportWorldCentre.x += 1;\n  }\n}\n\npublic void moveViewportLeft(){\n  if(currentViewportWorldCentre.x > (metresToShowX/2)-3){\n    currentViewportWorldCentre.x -= 1;\n     }\n}\n\npublic void moveViewportUp(){\n  if(currentViewportWorldCentre.y > (metresToShowY /2)-3) {\n        currentViewportWorldCentre.y -= 1;\n   }\n}\n\npublic void moveViewportDown(int maxHeight){\n  if(currentViewportWorldCentre.y < \n    maxHeight - (metresToShowY / 2)+3) {\n\n    currentViewportWorldCentre.y += 1;\n  }\n}\n```", "```java\n//Move the viewport around to explore the map\nswitch (motionEvent.getAction() & MotionEvent.ACTION_MASK) {\n  case MotionEvent.ACTION_DOWN:\n if (right.contains(x, y)) {\n vp.moveViewportRight(l.mapWidth);\n } else if (left.contains(x, y)) {\n vp.moveViewportLeft();\n } else if (jump.contains(x, y)) {\n vp.moveViewportUp();\n } else if (shoot.contains(x, y)) {\n vp.moveViewportDown(l.mapHeight);\n } else if (pause.contains(x, y)) {\n l.switchPlayingStatus();\n }\n      break;\n}\n```", "```java\nswitch (level) {\n  case \"LevelCave\":\n     levelData = new LevelCave();\n     break;\n\n// We can add extra levels here\ncase \"LevelCity\": \n levelData = new LevelCity(); \n break; \n\ncase \"LevelForest\": \n levelData = new LevelForest(); \n break;\n\ncase \"LevelMountain\": \n levelData = new LevelMountain(); \n break;\n}\n```", "```java\nloadLevel(\"LevelCave\", 1, 16);\n```", "```java\nif (lm.isPlaying()) {\n    // Reset the players location as \n    // the world centre of the viewport\n    //if game is playing\n    vp.setWorldCentre(lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().x,\n        lm.gameObjects.get(lm.playerIndex)\n        .getWorldLocation().y);\n\n //Has player fallen out of the map?\n if (lm.player.getWorldLocation().x < 0 ||\n lm.player.getWorldLocation().x > lm.mapWidth ||\n lm.player.getWorldLocation().y > lm.mapHeight) {\n\n sm.playSound(\"player_burn\");\n ps.loseLife();\n PointF location = new PointF(ps.loadLocation().x,\n ps.loadLocation().y);\n\n lm.player.setWorldLocationX(location.x);\n lm.player.setWorldLocationY(location.y);\n lm.player.setxVelocity(0);\n }\n\n // Check if game is over\n if (ps.getLives() == 0) {\n ps = new PlayerState();\n loadLevel(\"LevelCave\", 1, 16);\n }\n}\n```", "```java\npublic class Location {\n     String level;\n     float x;\n     float y;\n\n     Location(String level, float x, float y){\n        this.level = level;\n        this.x = x;\n        this.y = y;\n     }\n}\n```", "```java\npublic class Teleport extends GameObject {\n\n    Location target;\n\n    Teleport(float worldStartX, float worldStartY, \n        char type, Location target) {\n\n        final float HEIGHT = 2;\n        final float WIDTH = 2;\n        setHeight(HEIGHT); // 2 metres tall\n        setWidth(WIDTH); // 1 metre wide\n        setType(type);\n        setBitmapName(\"door\");\n\n        this.target = new Location(target.level, \n            target.x, target.y);\n\n        // Where does the tile start\n        // X and y locations from constructor parameters\n        setWorldLocation(worldStartX, worldStartY, 0);\n\n        setRectHitbox();\n    }\n\n    public Location getTarget(){\n        return target;\n    }\n\n    public void update(long fps, float gravity){\n    }\n}\n```", "```java\nArrayList<String> tiles;\nArrayList<BackgroundData> backgroundDataList;\nArrayList<Location> locations;\n\n// This class will evolve along with the project\n```", "```java\n// Declare the values for the teleports in order of appearance\nlocations = new ArrayList<Location>();\nthis.locations.add(new Location(\"LevelCity\", 118f, 18f));\n```", "```java\ncase 'z':\n  index = 21;\n  break;\n\ncase 't':\n index = 22;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\ncase 'z':\n  index = 21;\n     break;\n\ncase 't':\n index = 22;\n break;\n\ndefault:\n  index = 0;\n  break;\n```", "```java\n//Keep track of where we load our game objects\nint currentIndex = -1;\nint teleportIndex = -1;\n// how wide and high is the map? Viewport needs to know\n```", "```java\ncase 'z':\n    // Add a boulders to the gameObjects\n    gameObjects.add(new Boulders(j, i, c));\n    break;\n\n case 't':\n // Add a teleport to the gameObjects\n teleportIndex++;\n gameObjects.add(new Teleport(j, i, c,\n levelData.locations.get(teleportIndex)));\n\n break;\n\n```", "```java\ncase 'f':\n    sm.playSound(\"player_burn\");\n    ps.loseLife();\n    location = new PointF(ps.loadLocation().x,\n      ps.loadLocation().y); \n    lm.player.setWorldLocationX(location.x);\n    lm.player.setWorldLocationY(location.y);\n    lm.player.setxVelocity(0);\n    break;\n\ncase 't':\n Teleport teleport = (Teleport) go;\n Location t = teleport.getTarget();\n loadLevel(t.level, t.x, t.y);\n sm.playSound(\"teleport\");\n break;\n\ndefault:// Probably a regular tile\n    if (hit == 1) {// Left or right\n        lm.player.setxVelocity(0);\n        lm.player.setPressingRight(false);\n    }\n    if (hit == 2) {// Feet\n        lm.player.isFalling = false;\n    }\n    break;\n```", "```java\nps.saveLocation(location);\n\n// Reload the players current fire rate from the player state\nlm.player.bfg.setFireRate(ps.getFireRate());\n\n```", "```java\nloadLevel(\"LevelMountain\", 118, 17);\nloadLevel(\"LevelForest\", 1, 17);\nloadLevel(\"LevelCity\", 118, 18);\nloadLevel(\"LevelCave\", 1, 16);\n```", "```java\n// Draw the HUD\n// This code needs bitmaps: extra life, upgrade and coin\n// Therefore there must be at least one of each in the level\n\nint topSpace = vp.getPixelsPerMetreY() / 4;\nint iconSize = vp.getPixelsPerMetreX();\nint padding = vp.getPixelsPerMetreX() / 5;\nint centring = vp.getPixelsPerMetreY() / 6;\npaint.setTextSize(vp.getPixelsPerMetreY()/2);\npaint.setTextAlign(Paint.Align.CENTER);\n\npaint.setColor(Color.argb(100, 0, 0, 0));\ncanvas.drawRect(0,0,iconSize * 7.0f, topSpace*2 + iconSize,paint);\npaint.setColor(Color.argb(255, 255, 255, 0));\n\ncanvas.drawBitmap(lm.getBitmap('e'), 0, topSpace, paint);\ncanvas.drawText(\"\" + ps.getLives(), (iconSize * 1) + padding, \n  (iconSize) - centring, paint);\n\ncanvas.drawBitmap(lm.getBitmap('c'), (iconSize * 2.5f) + padding, \n  topSpace, paint);\n\ncanvas.drawText(\"\" + ps.getCredits(), (iconSize * 3.5f) + padding * 2, (iconSize) - centring, paint);\n\ncanvas.drawBitmap(lm.getBitmap('u'), (iconSize * 5.0f) + padding, \n  topSpace, paint);\n\ncanvas.drawText(\"\" + ps.getFireRate(), (iconSize * 6.0f) + padding * 2, (iconSize) - centring, paint);\n```", "```java\n    android:name=\".AsteroidsActivity\"\n    ```", "```java\n    android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\"\n    android:screenOrientation=\"landscape\"\n    ```", "```java\npackage com.gamecodeschool.c9asteroids;\n\nimport android.app.Activity;\nimport android.graphics.Point;\nimport android.opengl.GLSurfaceView;\nimport android.os.Bundle;\nimport android.view.Display;\n\npublic class AsteroidsActivity extends Activity {\n\n    private GLSurfaceView asteroidsView;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // Get a Display object to access screen details\n        Display display = getWindowManager().getDefaultDisplay();\n\n        // Load the resolution into a Point object\n        Point resolution = new Point();\n        display.getSize(resolution);\n\n        asteroidsView = new AsteroidsView \n          (this, resolution.x, resolution.y); \n\n        setContentView(asteroidsView);\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        asteroidsView.onPause();\n\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        asteroidsView.onResume();\n\n    }\n}\n```", "```java\nimport android.content.Context;\nimport android.opengl.GLSurfaceView;\n\npublic class AsteroidsView extends GLSurfaceView{\n\n    GameManager gm;\n\n    public AsteroidsView(Context context, int screenX, int screenY) {\n        super(context);\n\n        gm = new GameManager(screenX, screenY);\n\n        // Which version of OpenGl we are using\n        setEGLContextClientVersion(2);\n\n        // Attach our renderer to the GLSurfaceView\n        setRenderer(new AsteroidsRenderer(gm));\n\n    }\n\n}\n```", "```java\npublic class GameManager {\n\n    int mapWidth = 600;\n    int mapHeight = 600;\n    private boolean playing = false;\n\n    // Our first game object\n    SpaceShip ship;\n\n    int screenWidth;\n    int screenHeight;\n\n    // How many metres of our virtual world\n    // we will show on screen at any time.\n    int metresToShowX = 390;\n    int metresToShowY = 220;\n\n    public GameManager(int x, int y){\n\n        screenWidth = x;\n        screenHeight = y;\n\n    }\n\n    public void switchPlayingStatus() {\n        playing = !playing;\n\n    }\n\n    public boolean isPlaying(){\n        return playing;\n    }\n}\n```", "```java\nimport static android.opengl.GLES20.GL_FRAGMENT_SHADER;\nimport static android.opengl.GLES20.GL_VERTEX_SHADER;\nimport static android.opengl.GLES20.glAttachShader;\nimport static android.opengl.GLES20.glCompileShader;\nimport static android.opengl.GLES20.glCreateProgram;\nimport static android.opengl.GLES20.glCreateShader;\nimport static android.opengl.GLES20.glLinkProgram;\nimport static android.opengl.GLES20.glShaderSource;\n```", "```java\npublic class GLManager {\n\n     // Some constants to help count the number of bytes between\n     // elements of our vertex data arrays\n     public static final int COMPONENTS_PER_VERTEX = 3;\n     public  static final int FLOAT_SIZE = 4;\n     public static final int STRIDE =\n       (COMPONENTS_PER_VERTEX)\n        * FLOAT_SIZE;\n\n     public static final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n```", "```java\n// Some constants to represent GLSL types in our shaders\npublic static final String U_MATRIX = \"u_Matrix\";\npublic static final String A_POSITION = \"a_Position\";\npublic static final String U_COLOR = \"u_Color\";\n\n// Each of the above constants also has a matching int\n// which will represent its location in the open GL glProgram\npublic static int uMatrixLocation;\npublic static int aPositionLocation;\npublic static int uColorLocation;\n```", "```java\n// A very simple vertexShader glProgram\n// that we can define with a String\n\nprivate static String vertexShader =\n     \"uniform mat4 u_Matrix;\" +\n     \"attribute vec4 a_Position;\" +\n\n     \"void main()\" +\n     \"{\" +\n       \"gl_Position = u_Matrix * a_Position;\" +\n       \"gl_PointSize = 3.0;\"+\n  \"}\";\n```", "```java\n// A very simple fragment Shader\n// that we can define with a String\n\nprivate static String fragmentShader = \n    \"precision mediump float;\" + \n    \"uniform vec4 u_Color;\" + \n    \"void main()\" + \n    \"{\" + \n        \"gl_FragColor = u_Color;\" + \n    \"}\";\n\n// A handle to the GL glProgram public static int program; \n```", "```java\npublic static int program;\npublic static int getGLProgram(){\nreturn program;\n}\n```", "```java\npublic static int buildProgram(){\n    // Compile and link our shaders into a GL glProgram object\n    return linkProgram(compileVertexShader(),compileFragmentShader());\n\n}\n\nprivate static int compileVertexShader() {\n    return compileShader(GL_VERTEX_SHADER, vertexShader);\n}\n\nprivate static int compileFragmentShader() {\n    return compileShader(GL_FRAGMENT_SHADER, fragmentShader);\n}\n```", "```java\nprivate static int compileShader(int type, String shaderCode) {\n\n    // Create a shader object and store its ID\n    final int shader = glCreateShader(type);\n\n    // Pass in the code then compile the shader\n    glShaderSource(shader, shaderCode);\n    glCompileShader(shader);\n\n    return shader;\n}\n```", "```java\nprivate static int linkProgram(int vertexShader, int fragmentShader) {\n\n  // A handle to the GL glProgram -\n  // the compiled and linked shaders\n     program = glCreateProgram();\n\n     // Attach the vertex shader to the glProgram.\n     glAttachShader(program, vertexShader);\n\n     // Attach the fragment shader to the glProgram.\n     glAttachShader(program, fragmentShader);\n\n     // Link the two shaders together into a glProgram.\n     glLinkProgram(program);\n\n     return program;\n}\n}// End GLManager\n```", "```java\nimport android.graphics.PointF;\nimport android.opengl.GLSurfaceView.Renderer;\nimport android.util.Log;\nimport javax.microedition.khronos.egl.EGLConfig;\nimport javax.microedition.khronos.opengles.GL10;\nimport static android.opengl.GLES20.GL_COLOR_BUFFER_BIT;\nimport static android.opengl.GLES20.glClear;\nimport static android.opengl.GLES20.glClearColor;\nimport static android.opengl.GLES20.glViewport;\nimport static android.opengl.Matrix.orthoM;\n```", "```java\npublic class AsteroidsRenderer implements Renderer {\n\n// Are we debugging at the moment\n\nboolean debugging = true;\n\n// For monitoring and controlling the frames per second\n\nlong frameCounter = 0;\nlong averageFPS = 0;\nprivate long fps;\n\n// For converting each game world coordinate\n// into a GL space coordinate (-1,-1 to 1,1)\n// for drawing on the screen\n\nprivate final float[] viewportMatrix = new float[16];\n\n// A class to help manage our game objects\n// current state.\n\nprivate GameManager gm;\n\n// For capturing various PointF details without\n// creating new objects in the speed critical areas\n\nPointF handyPointF;\nPointF handyPointF2;\n```", "```java\npublic AsteroidsRenderer(GameManager gameManager) {\n\n     gm = gameManager;\n\n     handyPointF = new PointF();\n     handyPointF2 = new PointF();\n\n}\n```", "```java\n@Override\npublic void onSurfaceCreated(GL10 glUnused, EGLConfig config) {\n\n   // The color that will be used to clear the\n   // screen each frame in onDrawFrame()\n   glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\n   // Get GLManager to compile and link the shaders into an object\n   GLManager.buildProgram();\n\n   createObjects();\n\n}\n```", "```java\n@Override\n    public void onSurfaceChanged(GL10 glUnused, int width, int height) {\n\n        // Make full screen\n        glViewport(0, 0, width, height);\n\n        /*\n            Initialize our viewport matrix by passing in the starting\n            range of the game world that will be mapped, by OpenGL to\n            the screen. We will dynamically amend this as the player\n            moves around.\n\n            The arguments to setup the viewport matrix:\n            our array,\n            starting index in array,\n            min x, max x,\n            min y, max y,\n            min z, max z)\n        */\n\n            orthoM(viewportMatrix, 0, 0, \n        gm.metresToShowX, 0, \n        gm.metresToShowY, 0f, 1f);\n}\n```", "```java\n    private void createObjects() {\n        // Create our game objects\n\n        // First the ship in the center of the map\n        gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);\n    }\n```", "```java\n@Override\npublic void onDrawFrame(GL10 glUnused) {\n\n        long startFrameTime = System.currentTimeMillis();\n\n        if (gm.isPlaying()) {\n            update(fps);\n        }\n\n        draw();\n\n        // Calculate the fps this frame\n        // We can then use the result to\n        // time animations and more.\n        long timeThisFrame = System.currentTimeMillis() - startFrameTime;\n        if (timeThisFrame >= 1) {\n            fps = 1000 / timeThisFrame;\n        }\n\n        // Output the average frames per second to the console\n        if (debugging) {\n            frameCounter++;\n            averageFPS = averageFPS + fps;\n            if (frameCounter > 100) {\n                averageFPS = averageFPS / frameCounter;\n                frameCounter = 0;\n                Log.e(\"averageFPS:\", \"\" + averageFPS);\n            }\n        }\n    }\n```", "```java\n    private void update(long fps) {\n\n    }\n```", "```java\nprivate void draw() {\n\n    // Where is the ship?\n    handyPointF = gm.ship.getWorldLocation();\n\n    // Modify the viewport matrix orthographic projection\n    // based on the ship location\n    orthoM(viewportMatrix, 0,\n        handyPointF.x - gm.metresToShowX / 2,\n        handyPointF.x + gm.metresToShowX / 2,\n        handyPointF.y - gm.metresToShowY / 2,\n        handyPointF.y + gm.metresToShowY / 2,\n        0f, 1f);\n\n    // Clear the screen\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Start drawing!\n\n    // Draw the ship\n    gm.ship.draw(viewportMatrix);\n}\n}\n```", "```java\nimport android.graphics.PointF;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\nimport static android.opengl.GLES20.GL_FLOAT;\nimport static android.opengl.GLES20.GL_LINES;\nimport static android.opengl.GLES20.GL_POINTS;\nimport static android.opengl.GLES20.GL_TRIANGLES;\nimport static android.opengl.GLES20.glDrawArrays;\nimport static android.opengl.GLES20.glEnableVertexAttribArray;\nimport static android.opengl.GLES20.glGetAttribLocation;\nimport static android.opengl.GLES20.glGetUniformLocation;\nimport static android.opengl.GLES20.glUniform4f;\nimport static android.opengl.GLES20.glUniformMatrix4fv;\nimport static android.opengl.GLES20.glUseProgram;\nimport static android.opengl.Matrix.multiplyMM;\nimport static android.opengl.Matrix.setIdentityM;\nimport static android.opengl.Matrix.setRotateM;\nimport static android.opengl.Matrix.translateM;\nimport static android.opengl.GLES20.glVertexAttribPointer;\nimport static com.gamecodeschool.c9asteroids.GLManager.*;\n```", "```java\npublic class GameObject {\n\n    boolean isActive;\n\n    public enum Type {SHIP, ASTEROID, BORDER, BULLET, STAR}\n\n    private Type type;\n\n    private static int glProgram =-1;\n\n    // How many vertices does it take to make\n    // this particular game object?\n    private int numElements;\n    private int numVertices;\n\n    // To hold the coordinates of the vertices that\n    // define our GameObject model\n    private float[] modelVertices;\n\n    // Which way is the object moving and how fast?\n    private float xVelocity = 0f;\n    private float yVelocity = 0f;\n    private float speed = 0;\n    private float maxSpeed = 200;\n\n    // Where is the object centre in the game world?\n    private PointF worldLocation = new PointF();\n```", "```java\n    // This will hold our vertex data that is\n    // passed into the openGL glProgram\n    // OPenGL likes FloatBuffer\n    private FloatBuffer vertices;\n\n    // For translating each point from the model (ship, asteroid etc)\n    // to its game world coordinates\n    private final float[] modelMatrix = new float[16];\n\n    // Some more matrices for Open GL transformations\n    float[] viewportModelMatrix = new float[16];\n    float[] rotateViewportModelMatrix = new float[16];\n\n    // Where is the GameObject facing?\n    private float facingAngle = 90f;\n\n    // How fast is it rotating?\n    private float rotationRate = 0f;\n\n    // Which direction is it heading?\n    private float travellingAngle = 0f;\n\n    // How long and wide is the GameObject?\n    private float length;\n    private float width;\n```", "```java\npublic GameObject(){\n    // Only compile shaders once\n    if (glProgram == -1){\n        setGLProgram();\n\n        // tell OpenGl to use the glProgram\n        glUseProgram(glProgram);\n\n        // Now we have a glProgram we need the locations\n        // of our three GLSL variables.\n        // We will use these when we call draw on the object.\n        uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);\n        aPositionLocation = glGetAttribLocation(glProgram, A_POSITION);\n        uColorLocation = glGetUniformLocation(glProgram, U_COLOR);\n    }\n\n    // Set the object as active\n    isActive = true;\n\n}\n```", "```java\npublic boolean isActive() {\n  return isActive;\n}\n\npublic void setActive(boolean isActive) {\n  this.isActive = isActive;\n}\n\npublic void setGLProgram(){\n  glProgram = GLManager.getGLProgram();\n}\n\npublic Type getType() {\n  return type;\n}\n\npublic void setType(Type t) {\n  this.type = t;\n}\n\npublic void setSize(float w, float l){\n  width = w;\n  length = l;\n\n}\n\npublic PointF getWorldLocation() {\n  return worldLocation;\n}\n\npublic void setWorldLocation(float x, float y) {\n  this.worldLocation.x = x;\n  this.worldLocation.y = y;\n}\n```", "```java\npublic void setVertices(float[] objectVertices){\n\n    modelVertices = new float[objectVertices.length];\n    modelVertices = objectVertices;\n\n    // Store how many vertices and elements there is for future use\n    numElements = modelVertices.length;\n\n    numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n    // Initialize the vertices ByteBuffer object based on the\n    // number of vertices in the ship design and the number of\n    // bytes there are in the float type\n    vertices = ByteBuffer.allocateDirect(\n            numElements\n            * FLOAT_SIZE)\n            .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n    // Add the ship into the ByteBuffer object\n    vertices.put(modelVertices);\n\n}\n```", "```java\n    public void draw(float[] viewportMatrix){\n\n        // tell OpenGl to use the glProgram\n        glUseProgram(glProgram);\n\n        // Set vertices to the first byte\n        vertices.position(0);\n\n        glVertexAttribPointer(\n              aPositionLocation,\n              COMPONENTS_PER_VERTEX,\n              GL_FLOAT,\n              false,\n              STRIDE,\n              vertices);\n\n        glEnableVertexAttribArray(aPositionLocation);\n```", "```java\n    // Translate model coordinates into world coordinates\n    // Make an identity matrix to base our future calculations on\n    // Or we will get very strange results\n    setIdentityM(modelMatrix, 0);\n    // Make a translation matrix\n\n    /*\n        Parameters:\n        m   matrix\n        mOffset index into m where the matrix starts\n        x   translation factor x\n        y   translation factor y\n        z   translation factor z\n    */\n    translateM(modelMatrix, 0, worldLocation.x, worldLocation.y, 0);\n```", "```java\n   // Combine the model with the viewport\n   // into a new matrix\n   multiplyMM(viewportModelMatrix, 0, \n      viewportMatrix, 0, modelMatrix, 0);\n```", "```java\n   /*\n        Now rotate the model - just the ship model\n\n        Parameters\n        rm  returns the result\n        rmOffset    index into rm where the result matrix starts\n        a   angle to rotate in degrees\n        x   X axis component\n        y   Y axis component\n        z   Z axis component\n    */\n    setRotateM(modelMatrix, 0, facingAngle, 0, 0, 1.0f);\n\n    // And multiply the rotation matrix into the model-viewport \n    // matrix\n    multiplyMM(rotateViewportModelMatrix, 0, \n      viewportModelMatrix, 0, modelMatrix, 0);\n```", "```java\n   // Give the matrix to OpenGL\n\n    glUniformMatrix4fv(uMatrixLocation, 1, false,                                        \n    rotateViewportModelMatrix, 0);\n\n    // Assign a color to the fragment shader\n    glUniform4f(uColorLocation, 1.0f, 1.0f, 1.0f, 1.0f);\n```", "```java\n   // Draw the point, lines or triangle\n    switch (type){\n        case SHIP:\n        glDrawArrays(GL_TRIANGLES, 0, numVertices);\n        break;\n\n        case ASTEROID:\n        glDrawArrays(GL_LINES, 0, numVertices);\n        break;\n\n        case BORDER:\n        glDrawArrays(GL_LINES, 0, numVertices);\n        break;\n\n       case STAR:\n        glDrawArrays(GL_POINTS, 0, numVertices);\n        break;\n\n        case BULLET:\n        glDrawArrays(GL_POINTS, 0, numVertices);\n        break;\n    }\n\n} // End draw()\n\n}// End class\n```", "```java\npublic class SpaceShip extends GameObject{\n\n  public SpaceShip(float worldLocationX, float worldLocationY){\n       super();\n\n        // Make sure we know this object is a ship\n        // So the draw() method knows what type\n        // of primitive to construct from the vertices\n\n        setType(Type.SHIP);\n\n        setWorldLocation(worldLocationX,worldLocationY);\n\n        float width = 15;\n        float length = 20;\n\n        setSize(width, length);\n\n        // It will be useful to have a copy of the\n        // length and width/2 so we don't have to keep dividing by 2\n        float halfW = width / 2;\n        float halfL = length / 2;\n\n        // Define the space ship shape\n        // as a triangle from point to point\n        // in anti clockwise order\n        float [] shipVertices = new float[]{\n\n               - halfW, - halfL, 0,\n               halfW, - halfL, 0,\n               0, 0 + halfL, 0\n\n      };\n\n       setVertices(shipVertices);\n\n     }\n\n}\n```", "```java\n    private boolean playing = false;\n\n     // Our first game object\n     SpaceShip ship;\n\n         int screenWidth;\n    ```", "```java\n    private void createObjects() {\n\n      // Create our game objects\n     // First the ship in the center of the map\n     gm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);\n    }\n    ```", "```java\n    // Start drawing!\n    // Draw the ship\n    gm.ship.draw(viewportMatrix);\n\n    ```", "```java\npublic class Border extends GameObject{\n\n  public Border(float mapWidth, float mapHeight){\n\n        setType(Type.BORDER);\n        //border center is the exact center of map\n        setWorldLocation(mapWidth/2,mapHeight/2);\n\n        float w = mapWidth;\n        float h = mapHeight;\n        setSize(w, h);\n\n       // The vertices of the border represent four lines\n       // that create a border of a size passed into the constructor\n       float[] borderVertices = new float[]{\n           // A line from point 1 to point 2\n            - w/2, -h/2, 0,\n            w/2, -h/2, 0,\n            // Point 2 to point 3\n            w/2, -h/2, 0,\n            w/2, h/2, 0,\n            // Point 3 to point 4\n            w/2, h/2, 0,\n            -w/2, h/2, 0,\n            // Point 4 to point 1\n            -w/2, h/2, 0,\n            - w/2, -h/2, 0,\n    };\n\n        setVertices(borderVertices);\n\n  }\n\n}\n```", "```java\n// Our game objects\nSpaceShip ship;\nBorder border;\n\n```", "```java\n// Create our game objects\n\n// First the ship in the center of the map\ngm.ship = new SpaceShip(gm.mapWidth / 2, gm.mapHeight / 2);\n\n// The deadly border\ngm.border = new Border(gm.mapWidth, gm.mapHeight);\n\n```", "```java\ngm.ship.draw(viewportMatrix);\ngm.border.draw(viewportMatrix);\n\n```", "```java\nsetWorldLocation(10,10);\n```", "```java\nsetWorldLocation(worldLocationX,worldLocationY);\n```", "```java\npublic class Star extends GameObject{\n\n    // Declare a random object here because\n    // we will use it in the update() method\n    // and we don't want GC to have to keep clearing it up\n    Random r;\n\n    public Star(int mapWidth, int mapHeight){\n    setType(Type.STAR);\n    r = new Random();\n    setWorldLocation(r.nextInt(mapWidth),r.nextInt(mapHeight));\n\n    // Define the star\n    // as a single point\n    // in exactly the coordinates as its world location\n    float[] starVertices = new float[]{\n\n                0,\n                0,\n                0\n\n    };\n\n    setVertices(starVertices);\n\n    }\n```", "```java\npublic void update(){\n\n  // Randomly twinkle the stars\n     int n = r.nextInt(1000);\n     if(n == 0){\n       // Switch on or off\n       if(isActive()){\n         setActive(false);\n        }else{\n          setActive(true);\n        }\n   }\n\n}\n```", "```java\n// Our game objects\nSpaceShip ship;\nBorder border;\nStar[] stars;\nint numStars = 200;\n\n```", "```java\n// The deadly border\ngm.border = new Border(gm.mapWidth, gm.mapHeight);\n\n// Some stars\ngm.stars = new Star[gm.numStars];\nfor (int i = 0; i < gm.numStars; i++) {\n\n // Pass in the map size so the stars no where to spawn\n gm.stars[i] = new Star(gm.mapWidth, gm.mapHeight);\n}\n\n```", "```java\n// Start drawing!\n\n// Some stars\nfor (int i = 0; i < gm.numStars; i++) {\n\n // Draw the star if it is active\n if(gm.stars[i].isActive()) {\n gm.stars[i].draw(viewportMatrix);\n }\n}\n\ngm.ship.draw(viewportMatrix);\ngm.border.draw(viewportMatrix);\n```", "```java\nprivate void update(long fps) {\n\n // Update (twinkle) the stars\n for (int i = 0; i < gm.numStars; i++) {\n gm.stars[i].update();\n }\n\n}\n```", "```java\npublic void setRotationRate(float rotationRate) {\n  this.rotationRate = rotationRate;\n}\n\npublic float getTravellingAngle() {\n  return travellingAngle;\n}\n\npublic void setTravellingAngle(float travellingAngle) {\n  this.travellingAngle = travellingAngle;\n}\n\npublic float getFacingAngle() {\n  return facingAngle;\n}\n\npublic void setFacingAngle(float facingAngle) {\n  this.facingAngle = facingAngle;\n}\n```", "```java\nvoid move(float fps){\n  if(xVelocity != 0) {\n       worldLocation.x += xVelocity / fps;\n    }\n\n     if(yVelocity != 0) {\n       worldLocation.y += yVelocity / fps;\n    }\n\n     // Rotate\n     if(rotationRate != 0) {\n       facingAngle = facingAngle + rotationRate / fps;\n    }\n\n}\n```", "```java\npublic float getxVelocity() {\n  return xVelocity;\n}\n\npublic void setxVelocity(float xVelocity) {\n  this.xVelocity = xVelocity;\n}\n\npublic float getyVelocity() {\n  return yVelocity;\n}\n\npublic void setyVelocity(float yVelocity) {\n  this.yVelocity = yVelocity;\n}\n\npublic float getSpeed() {\n  return speed;\n}\n\npublic void setSpeed(float speed) {\n  this.speed = speed;\n}\n\npublic float getMaxSpeed() {\n  return maxSpeed;\n}\n\npublic void setMaxSpeed(float maxSpeed) {\n  this.maxSpeed = maxSpeed;\n}\n```", "```java\nboolean isThrusting;\nprivate boolean isPressingRight = false;\nprivate boolean isPressingLeft = false;\n```", "```java\nsetSize(width, length);\n\nsetMaxSpeed(150);\n\n// It will be useful to have a copy of the\n```", "```java\npublic void update(long fps){\n\nfloat speed = getSpeed();\nif(isThrusting) {\n  if (speed < getMaxSpeed()){\n       setSpeed(speed + 5);\n     }\n\n     }else{\n       if(speed > 0) {\n         setSpeed(speed - 3);\n        }else {\n         setSpeed(0);\n        }\n}\n```", "```java\nsetxVelocity((float) \n  (speed* Math.cos(Math.toRadians(getFacingAngle() + 90))));\n\nsetyVelocity((float) \n  (speed* Math.sin(Math.toRadians(getFacingAngle() + 90))));\n\n```", "```java\nif(isPressingLeft){\n  setRotationRate(360);\n}\n\nelse if(isPressingRight){\n  setRotationRate(-360);\n     }else{\n       setRotationRate(0);\n    }\n\n     move(fps);\n}\n```", "```java\npublic boolean pullTrigger() {\n  //Try and fire a shot\n  // We could control rate of fire from here\n  // But lets just return true for unrestricted rapid fire\n  // You could remove this method and any code which calls it\n\n   return true;\n}\n\npublic void setPressingRight(boolean pressingRight) {\n  isPressingRight = pressingRight;\n}\n\npublic void setPressingLeft(boolean pressingLeft) {\n  isPressingLeft = pressingLeft;\n}\n\npublic void toggleThrust() {\n  isThrusting = ! isThrusting;\n}\n```", "```java\n// Update (twinkle) the stars\nfor (int i = 0; i < gm.numStars; i++) {\n  gm.stars[i].update();\n}\n\n// Run the ship,s update() method\ngm.ship.update(fps);\n\n```", "```java\npublic class Bullet extends GameObject {\n\n  private boolean inFlight = false;\n\n  public Bullet(float shipX, float shipY) {\n       super();\n\n       setType(Type.BULLET);\n\n       setWorldLocation(shipX, shipY);\n\n       // Define the bullet\n       // as a single point\n       // in exactly the coordinates as its world location\n       float[] bulletVertices = new float[]{\n\n                0,\n                0,\n                0\n\n       };\n\n    setVertices(bulletVertices);\n\n}\n```", "```java\npublic void shoot(float shipFacingAngle){\n\n     setFacingAngle(shipFacingAngle);\n     inFlight = true;\n     setSpeed (300);\n}\n\npublic void resetBullet(PointF shipLocation){\n\n     // Stop moving if bullet out of bounds\n     inFlight = false;\n     setxVelocity(0);\n     setyVelocity(0);\n     setSpeed(0);\n     setWorldLocation(shipLocation.x, shipLocation.y);\n\n}\n\npublic boolean isInFlight(){\n  return  inFlight;\n}\n```", "```java\npublic void update(long fps, PointF shipLocation){\n        // Set the velocity if bullet in flight\n        if(inFlight){\n            setxVelocity((float)(getSpeed()* \n               Math.cos(Math.toRadians(getFacingAngle() + 90))));\n            setyVelocity((float)(getSpeed()* \n               Math.sin(Math.toRadians(getFacingAngle() + 90))));\n        }else{\n            // Have it sit inside the ship\n            setWorldLocation(shipLocation.x, shipLocation.y);\n        }\n\n        move(fps);\n    }\n}\n```", "```java\nint numStars = 200;\nBullet [] bullets;\nint numBullets = 20;\n\n```", "```java\n// Some bullets\ngm.bullets = new Bullet[gm.numBullets];\nfor (int i = 0; i < gm.numBullets; i++) {\n  gm.bullets[i] = new Bullet(\n     gm.ship.getWorldLocation().x,\n     gm.ship.getWorldLocation().y);\n}\n```", "```java\n// Update all the bullets\nfor (int i = 0; i < gm.numBullets; i++) {\n\n    // If not in flight they will need the ships location\n    gm.bullets[i].update(fps, gm.ship.getWorldLocation());\n\n}\n```", "```java\nfor (int i = 0; i < gm.numBullets; i++) {\n  gm.bullets[i].draw(viewportMatrix);\n}\n```", "```java\nprivate InputController ic;\nprivate SoundManager sm;\n```", "```java\npublic AsteroidsView(Context context, int screenX, int screenY) {\n  super(context);\n\n sm = new SoundManager();\n sm.loadSound(context);\n ic = new InputController(screenX, screenY);\n     gm = new GameManager(screenX, screenY);\n```", "```java\nsetEGLContextClientVersion(2);\nsetRenderer(new AsteroidsRenderer(gm,sm,ic));\n\n```", "```java\npublic AsteroidsRenderer(GameManager gameManager,\n SoundManager soundManager, InputController inputController) {\n\n        gm = gameManager;\n sm = soundManager;\n ic = inputController;\n\n       handyPointF = new PointF();\n       handyPointF2 = new PointF();\n\n}\n```", "```java\npublic class SoundManager {\n    private SoundPool soundPool;\n    private int shoot = -1;\n    private int thrust = -1;\n    private int explode = -1;\n    private int shipexplode = -1;\n    private int ricochet = -1;\n    private int blip = -1;\n    private int nextlevel = -1;\n    private int gameover = -1;\n\n    public void loadSound(Context context){\n        soundPool = new SoundPool(10, AudioManager.STREAM_MUSIC,0);\n        try{\n            //Create objects of the 2 required classes\n            AssetManager assetManager = context.getAssets();\n            AssetFileDescriptor descriptor;\n\n            //create our fx\n            descriptor = assetManager.openFd(\"shoot.ogg\");\n            shoot = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"thrust.ogg\");\n            thrust = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"explode.ogg\");\n            explode = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"shipexplode.ogg\");\n            shipexplode = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"ricochet.ogg\");\n            ricochet = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"blip.ogg\");\n            blip = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"nextlevel.ogg\");\n            nextlevel = soundPool.load(descriptor, 0);\n\n            descriptor = assetManager.openFd(\"gameover.ogg\");\n            gameover = soundPool.load(descriptor, 0);\n\n        }catch(IOException e){\n            //Print an error message to the console\n            Log.e(\"error\", \"failed to load sound files\");\n        }\n    }\n\n    public void playSound(String sound){\n        switch (sound){\n            case \"shoot\":\n                soundPool.play(shoot, 1, 1, 0, 0, 1);\n                break;\n\n            case \"thrust\":\n                soundPool.play(thrust, 1, 1, 0, 0, 1);\n                break;\n\n            case \"explode\":\n                soundPool.play(explode, 1, 1, 0, 0, 1);\n                break;\n\n            case \"shipexplode\":\n                soundPool.play(shipexplode, 1, 1, 0, 0, 1);\n                break;\n\n            case \"ricochet\":\n                soundPool.play(ricochet, 1, 1, 0, 0, 1);\n                break;\n\n            case \"blip\":\n                soundPool.play(blip, 1, 1, 0, 0, 1);\n                break;\n\n            case \"nextlevel\":\n                soundPool.play(nextlevel, 1, 1, 0, 0, 1);\n                break;\n\n            case \"gameover\":\n                soundPool.play(gameover, 1, 1, 0, 0, 1);\n                break;\n\n        }\n\n    }\n}\n```", "```java\n@Override\n    public boolean onTouchEvent(MotionEvent motionEvent) {\n        ic.handleInput(motionEvent, gm, sm);\n        return true;\n    }\n```", "```java\npublic class InputController {\n\n    private int currentBullet;\n\n    Rect left;\n    Rect right;\n    Rect thrust;\n    Rect shoot;\n    Rect pause;\n\n    InputController(int screenWidth, int screenHeight) {\n\n        //Configure the player buttons\n        int buttonWidth = screenWidth / 8;\n        int buttonHeight = screenHeight / 7;\n        int buttonPadding = screenWidth / 80;\n\n        left = new Rect(buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth,\n            screenHeight - buttonPadding);\n\n        right = new Rect(buttonWidth + buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            buttonWidth + buttonPadding + buttonWidth,\n            screenHeight - buttonPadding);\n\n        thrust = new Rect(screenWidth - buttonWidth - \n            buttonPadding,\n            screenHeight - buttonHeight - buttonPadding - \n            buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding - buttonHeight - \n            buttonPadding);\n\n        shoot = new Rect(screenWidth - buttonWidth - \n            buttonPadding,\n            screenHeight - buttonHeight - buttonPadding,\n            screenWidth - buttonPadding,\n            screenHeight - buttonPadding);\n\n        pause = new Rect(screenWidth - buttonPadding - \n            buttonWidth,\n            buttonPadding,\n            screenWidth - buttonPadding,\n            buttonPadding + buttonHeight);\n```", "```java\n    }    \n    public ArrayList getButtons(){\n\n        //create an array of buttons for the draw method\n        ArrayList<Rect> currentButtonList = new ArrayList<>();\n        currentButtonList.add(left);\n        currentButtonList.add(right);\n        currentButtonList.add(thrust);\n        currentButtonList.add(shoot);\n        currentButtonList.add(pause);\n        return  currentButtonList;\n    }\n```", "```java\npublic void handleInput(MotionEvent motionEvent,GameManager l,                                      \n  SoundManager sound){\n\n        int pointerCount = motionEvent.getPointerCount();\n\n        for (int i = 0; i < pointerCount; i++) {\n        int x = (int) motionEvent.getX(i);\n        int y = (int) motionEvent.getY(i);\n\n          switch (motionEvent.getAction() & \n             MotionEvent.ACTION_MASK) {\n\n            case MotionEvent.ACTION_DOWN:\n                    if (right.contains(x, y)) {\n                    l.ship.setPressingRight(true);\n                    l.ship.setPressingLeft(false);\n                 } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(true);\n                    l.ship.setPressingRight(false);\n                    } else if (thrust.contains(x, y)) {\n                    l.ship.toggleThrust();\n                    } else if (shoot.contains(x, y)) {\n                        if (l.ship.pullTrigger()) {\n                        l.bullets[currentBullet].shoot\n                                (l.ship.getFacingAngle());\n\n                            currentBullet++;\n                       // If we are on the last bullet restart\n                       // from the first one again\n                       if(currentBullet == l.numBullets){\n                            currentBullet = 0;\n                        }\n\n                           sound.playSound(\"shoot\");\n                    }\n\n                    } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                    }\n                    break;\n\n            case MotionEvent.ACTION_UP:\n            if (right.contains(x, y)) {\n                    l.ship.setPressingRight(false);\n                } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(false);\n                }\n\n                break;\n\n            case MotionEvent.ACTION_POINTER_DOWN:\n            if (right.contains(x, y)) {\n                    l.ship.setPressingRight(true);\n                    l.ship.setPressingLeft(false);\n                } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(true);\n                 l.ship.setPressingRight(false);\n                } else if (thrust.contains(x, y)) {\n                    l.ship.toggleThrust();\n                } else if (shoot.contains(x, y)) {\n                    if (l.ship.pullTrigger()) {\n                    l.bullets[currentBullet].shoot\n                            (l.ship.getFacingAngle());\n\n                        currentBullet++;\n                    // If we are on the last bullet restart\n                    // from the first one again\n                    if(currentBullet == l.numBullets){\n                        currentBullet = 0;\n                    }\n                    sound.playSound(\"shoot\");\n                    }\n                } else if (pause.contains(x, y)) {\n                    l.switchPlayingStatus();\n                }\n                break;\n\n            case MotionEvent.ACTION_POINTER_UP:\n            if (right.contains(x, y)) {\n                    l.ship.setPressingRight(false);\n                } else if (left.contains(x, y)) {\n                    l.ship.setPressingLeft(false);\n                }\n\n                break;\n            }\n         }\n\n    }\n}\n```", "```java\npublic class Asteroid extends GameObject{\n\n    PointF[] points;\n\n    public Asteroid(int levelNumber, int mapWidth, int mapHeight){\n        super();\n\n        // set a random rotation rate in degrees per second\n        Random r = new Random();\n        setRotationRate(r.nextInt(50 * levelNumber) + 10);\n\n        // travel at any random angle\n        setTravellingAngle(r.nextInt(360));\n\n        // Spawn asteroids between 50 and 550 on x and y\n        // And avoid the extreme edges of map\n        int x = r.nextInt(mapWidth - 100)+50;\n        int y = r.nextInt(mapHeight - 100)+50;\n\n        // Avoid the center where the player spawns\n        if(x > 250 && x < 350){ x = x + 100;}\n        if(y > 250 && y < 350){ y = y + 100;}\n\n        // Set the location\n        setWorldLocation(x,y);\n\n        // Make them a random speed with the maximum\n        // being appropriate to the level number\n        setSpeed(r.nextInt(25 * levelNumber)+1);\n\n        setMaxSpeed(140);\n\n        // Cap the speed\n        if (getSpeed() > getMaxSpeed()){\n            setSpeed(getMaxSpeed());\n        }\n\n        // Make sure we know this object is a ship\n        setType(Type.ASTEROID);\n\n        // Define a random asteroid shape\n        // Then call the parent setVertices()\n        generatePoints();\n\n    }\n```", "```java\npublic void update(float fps){\n\n  setxVelocity ((float) (getSpeed() * Math.cos(Math.toRadians  (getTravellingAngle() + 90))));\n\n  setyVelocity ((float) (getSpeed() * Math.sin(Math.toRadians(getTravellingAngle() + 90))));\n\n     move(fps);\n\n}\n```", "```java\n// Create a random asteroid shape\npublic void generatePoints(){\n  points = new PointF[7];\n\n   Random r = new Random();\n   int i;\n\n     // First a point roughly centre below 0\n     points[0] = new PointF();\n     i = (r.nextInt(10))+1;\n     if(i % 2 == 0){i = -i;}\n     points[0].x = i;\n     i = -(r.nextInt(20)+5);\n     points[0].y = i;\n\n     // Now a point still below centre but to the right and up a bit\n     points[1] = new PointF();\n     i = r.nextInt(14)+11;\n     points[1].x = i;\n     i = -(r.nextInt(12)+1);\n     points[1].y =  i;\n\n     // Above 0 to the right\n     points[2] = new PointF();\n     i = r.nextInt(14)+11;\n     points[1].x = i;\n     i = r.nextInt(12)+1;\n     points[2].y = i;\n\n     // A point roughly centre above 0\n     points[3] = new PointF();\n     i = (r.nextInt(10))+1;\n     if(i % 2 == 0){i = -i;}\n     points[3].x = i;\n     i = r.nextInt(20)+5;\n     points[3].y =  i;\n\n     // left above 0\n     points[4] = new PointF();\n     i = -(r.nextInt(14)+11);\n     points[4].x = i;\n     i = r.nextInt(12)+1;\n     points[4].y = i ;\n\n     // left below 0\n     points[5] = new PointF();\n     i = -(r.nextInt(14)+11);\n     points[5].x =  i;\n     i = -(r.nextInt(12)+1);\n\n     points[5].y = i;\n```", "```java\n  // Now use these points to draw our asteroid\n  float[] asteroidVertices = new float[]{\n     // First point to second point\n     points[0].x, points[0].y, 0,\n     points[1].x, points[1].y, 0,\n\n     // 2nd to 3rd\n     points[1].x, points[1].y, 0,\n     points[2].x, points[2].y, 0,\n\n     // 3 to 4\n     points[2].x, points[2].y, 0,\n     points[3].x, points[3].y, 0,\n\n     // 4 to 5\n     points[3].x, points[3].y, 0,\n     points[4].x, points[4].y, 0,\n\n     // 5 to 6\n     points[4].x, points[4].y, 0,\n     points[5].x, points[5].y, 0,\n\n     // 6 back to 1\n     points[5].x, points[5].y, 0,\n     points[0].x, points[0].y, 0,\n};\n\nsetVertices(asteroidVertices);\n\n}// End method\n\n}// End class\n```", "```java\nAsteroid [] asteroids;\nint numAsteroids;\nint numAsteroidsRemaining;\nint baseNumAsteroids = 10;\nint levelNumber = 1;\n```", "```java\n// For all our asteroids\nasteroids = new Asteroid[500];\n```", "```java\n// Determine the number of asteroids\ngm.numAsteroids = gm.baseNumAsteroids * gm.levelNumber;\n// Set how many asteroids need to be destroyed by player\ngm.numAsteroidsRemaining = gm.numAsteroids;\n// Spawn the asteroids\n\nfor (int i = 0; i < gm.numAsteroids * gm.levelNumber; i++) {\n     // Create a new asteroid\n     // Pass in level number so they can be made\n     // appropriately dangerous.\n     gm.asteroids[i] = new Asteroid\n      (gm.levelNumber, gm.mapWidth, gm.mapHeight);\n\n}\n```", "```java\n// Update all the asteroids\nfor (int i = 0; i < gm.numAsteroids; i++) {\n  if (gm.asteroids[i].isActive()) {\n    gm.asteroids[i].update(fps);\n  }\n}\n```", "```java\n// The bullets\nfor (int i = 0; i < gm.numBullets; i++) {\n  gm.bullets[i].draw(viewportMatrix);\n}\n\nfor (int i = 0; i < gm.numAsteroids; i++) {\n if (gm.asteroids[i].isActive()) {\n gm.asteroids[i].draw(viewportMatrix);\n }\n\n}\n\n```", "```java\nimport android.graphics.PointF;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.FloatBuffer;\nimport static android.opengl.GLES20.GL_FLOAT;\nimport static android.opengl.GLES20.GL_LINES;\nimport static android.opengl.GLES20.glDrawArrays;\nimport static android.opengl.GLES20.glEnableVertexAttribArray;\nimport static android.opengl.GLES20.glGetAttribLocation;\nimport static android.opengl.GLES20.glGetUniformLocation;\nimport static android.opengl.GLES20.glUniform4f;\nimport static android.opengl.GLES20.glUniformMatrix4fv;\nimport static android.opengl.GLES20.glUseProgram;\nimport static android.opengl.Matrix.orthoM;\nimport static android.opengl.GLES20.glVertexAttribPointer;\nimport static com.gamecodeschool.c10asteroids.GLManager.A_POSITION;\nimport static com.gamecodeschool.c10asteroids.GLManager.COMPONENTS_PER_VERTEX;\nimport static com.gamecodeschool.c10asteroids.GLManager.FLOAT_SIZE;\nimport static com.gamecodeschool.c10asteroids.GLManager.STRIDE;\nimport static com.gamecodeschool.c10asteroids.GLManager.U_COLOR;\nimport static com.gamecodeschool.c10asteroids.GLManager.U_MATRIX;\n```", "```java\npublic class GameButton {\n\n    // For button coordinate\n    // into a GL space coordinate (-1,-1 to 1,1)\n    // for drawing on the screen\n    private final float[] viewportMatrix = new float[16];\n\n    // A handle to the GL glProgram -\n    // the compiled and linked shaders\n    private static int glProgram;\n\n    // How many vertices does it take to make\n    // our button\n    private int numVertices;\n\n    // This will hold our vertex data that is\n    // passed into openGL glProgram\n    private FloatBuffer vertices;\n```", "```java\npublic GameButton(int top, int left, \n    int bottom, int right, GameManager gm){\n\n    //The HUD needs its own viewport\n    // notice we set the screen height in pixels as the\n    // starting y coordinates because\n    // OpenGL is upside down world :-)\n    orthoM(viewportMatrix, 0, 0, \n        gm.screenWidth, gm.screenHeight, 0, 0, 1f);\n\n        // Shrink the button visuals to make\n        // them less obtrusive while leaving\n        // the screen area they represent the same.\n        int width = (right - left) / 2;\n        int height = (top - bottom) / 2;\n        left = left + width / 2;\n        right = right - width / 2;\n        top = top - height / 2;\n        bottom = bottom + height / 2;\n\n        PointF p1 = new PointF();\n        p1.x = left;\n        p1.y = top;\n\n        PointF p2 = new PointF();\n        p2.x = right;\n        p2.y = top;\n\n        PointF p3 = new PointF();\n        p3.x = right;\n        p3.y = bottom;\n\n        PointF p4 = new PointF();\n        p4.x = left;\n        p4.y = bottom;\n\n        // Add the four points to an array of vertices\n        // This time, because we don't need to animate the border\n        // we can just declare the world space coordinates, the\n        // same as above.\n        float[] modelVertices = new float[]{\n                // A line from point 1 to point 2\n                p1.x, p1.y, 0,\n                p2.x, p2.y, 0,\n                // Point 2 to point 3\n                p2.x, p2.y, 0,\n                p3.x, p3.y, 0,\n                // Point 3 to point 4\n                p3.x, p3.y, 0,\n                p4.x, p4.y, 0,\n                // Point 4 to point 1\n                p4.x, p4.y, 0,\n                p1.x, p1.y, 0\n        };\n```", "```java\n       // Store how many vertices and \n       // elements there is for future use\n       final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n       int numElements = modelVertices.length;\n       numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n       // Initialize the vertices ByteBuffer object based on the\n       // number of vertices in the button and the number of\n       // bytes there are in the float type\n       vertices = ByteBuffer.allocateDirect(\n                numElements\n                * FLOAT_SIZE)\n                .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n       // Add the button into the ByteBuffer object\n       vertices.put(modelVertices);\n\n       glProgram = GLManager.getGLProgram();\n\n}\n```", "```java\npublic void draw(){\n\n    // And tell OpenGl to use the glProgram\n    glUseProgram(glProgram);\n\n    // Now we have a glProgram we need the locations\n    // of our three GLSL variables\n    int uMatrixLocation = glGetUniformLocation(glProgram, U_MATRIX);\n\n    int aPositionLocation = \n        glGetAttribLocation(glProgram, A_POSITION);\n\n    int uColorLocation = glGetUniformLocation(glProgram, U_COLOR);\n\n    vertices.position(0);\n\n    glVertexAttribPointer(\n        aPositionLocation,\n        COMPONENTS_PER_VERTEX,\n        GL_FLOAT,\n        false,\n        STRIDE,\n        vertices);\n\n    glEnableVertexAttribArray(aPositionLocation);\n\n    // give the new matrix to OpenGL\n    glUniformMatrix4fv(uMatrixLocation, 1, false, viewportMatrix, 0);\n\n    // Assign a different color to the fragment shader\n    glUniform4f(uColorLocation, 0.0f, 0.0f, 1.0f, 1.0f);\n\n    // Draw the lines\n    // start at the first element of the\n    // vertices array and read in all vertices\n    glDrawArrays(GL_LINES, 0, numVertices);\n\n}\n}// End class\n```", "```java\npublic class TallyIcon {\n\n    // For button coordinate\n    // into a GL space coordinate (-1,-1 to 1,1)\n    // for drawing on the screen\n    private final float[] viewportMatrix = new float[16];\n\n    // A handle to the GL glProgram -\n    // the compiled and linked shaders\n    private static int glProgram;\n\n    // How many vertices does it take to make\n    // our button\n    private int numVertices;\n\n    // This will hold our vertex data that is\n    // passed into openGL glProgram\n    //private final FloatBuffer vertices;\n    private FloatBuffer vertices;\n\n    public TallyIcon(GameManager gm, int nthIcon){\n\n        // The HUD needs its own viewport\n        // notice we set the screen height in pixels as the\n        // starting y coordinates because\n        // OpenGL is upside down world :-)\n        orthoM(viewportMatrix, 0, 0,\n          gm.screenWidth, gm.screenHeight, 0, 0f, 1f);\n\n        float padding = gm.screenWidth / 160;\n        float iconHeight = gm.screenHeight / 15;\n        float iconWidth = 1; // square icons\n        float startX = 10 + (padding + iconWidth)* nthIcon;\n        float startY = iconHeight * 2 + padding;\n\n        PointF p1 = new PointF();\n        p1.x = startX;\n        p1.y = startY;\n\n        PointF p2 = new PointF();\n        p2.x = startX;\n        p2.y = startY - iconHeight;\n\n        // Add the four points to an array of vertices\n        // This time, because we don't need to animate the border\n        // we can just declare the world space coordinates, the\n        // same as above.\n        float[] modelVertices = new float[]{\n                // A line from point 1 to point 2\n                p1.x, p1.y, 0,\n                p2.x, p2.y, 0,\n\n        };\n\n        // Store how many vertices and \n        //elements there is for future use\n        final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n        int numElements = modelVertices.length;\n        numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n        // Initialize the vertices ByteBuffer object based on the\n        // number of vertices in the button and the number of\n        // bytes there are in the float type\n        vertices = ByteBuffer.allocateDirect(\n                numElements\n                * FLOAT_SIZE)\n                .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n        // Add the button into the ByteBuffer object\n        vertices.put(modelVertices);\n\n        glProgram = GLManager.getGLProgram();\n    }\n```", "```java\n    public void draw(){\n\n        // And tell OpenGl to use the glProgram\n        glUseProgram(glProgram);\n\n        // Now we have a glProgram we need the locations\n        // of our three GLSL variables\n        int uMatrixLocation = \n        glGetUniformLocation(glProgram, U_MATRIX);\n\n        int aPositionLocation = \n        glGetAttribLocation(glProgram, A_POSITION);\n\n        int uColorLocation = \n        glGetUniformLocation(glProgram, U_COLOR);\n\n        vertices.position(0);\n\n        glVertexAttribPointer(\n                aPositionLocation,\n                COMPONENTS_PER_VERTEX,\n                GL_FLOAT,\n                false,\n                STRIDE,\n                vertices);\n\n        glEnableVertexAttribArray(aPositionLocation);\n\n        // Just give the passed in matrix to OpenGL\n        glUniformMatrix4fv(uMatrixLocation, 1, \n          false, viewportMatrix, 0);\n\n        // Assign a color to the fragment shader\n        glUniform4f(uColorLocation, 1.0f, 1.0f, 0.0f, 1.0f);\n\n        // Draw the lines\n        // start at the first element of the vertices array and read in all vertices\n        glDrawArrays(GL_LINES, 0, numVertices);\n    }\n```", "```java\npublic class LifeIcon {\n\n     // Remember the static import for GLManager\n\n     // For button coordinate\n     // into a GL space coordinate (-1,-1 to 1,1)\n     // for drawing on the screen\n     private final float[] viewportMatrix = new float[16];\n\n     // A handle to the GL glProgram -\n     // the compiled and linked shaders\n     private static int glProgram;\n\n     // Each of the above constants also has a matching int\n     // which will represent its location in the open GL glProgram\n     // In GameButton they are declared as local variables\n\n     // How many vertices does it take to make\n     // our button\n     private int numVertices;\n\n     // This will hold our vertex data that is\n     // passed into openGL glProgram\n     //private final FloatBuffer vertices;\n     private FloatBuffer vertices;\n\n     public LifeIcon(GameManager gm, int nthIcon){\n\n     // The HUD needs its own viewport\n     // notice we set the screen height in pixels as the\n     // starting y coordinates because\n     // OpenGL is upside down world :-)\n     orthoM(viewportMatrix, 0, 0,\n       gm.screenWidth, gm.screenHeight, 0, 0f, 1f);\n\n     float padding = gm.screenWidth / 160;\n     float iconHeight = gm.screenHeight / 15;\n     float iconWidth = gm.screenWidth / 30;\n     float startX = 10 + (padding + iconWidth)* nthIcon;\n     float startY = iconHeight;\n\n     PointF p1 = new PointF();\n     p1.x = startX;\n     p1.y = startY;\n\n     PointF p2 = new PointF();\n     p2.x = startX + iconWidth;\n     p2.y = startY;\n\n     PointF p3 = new PointF();\n     p3.x = startX + iconWidth/2;\n     p3.y = startY - iconHeight;\n\n     // Add the four points to an array of vertices\n     // This time, because we don't need to animate the border\n     // we can just declare the world space coordinates, the\n     // same as above.\n     float[] modelVertices = new float[]{\n               // A line from point 1 to point 2\n               p1.x, p1.y, 0,\n               p2.x, p2.y, 0,\n               // Point 2 to point 3\n               p2.x, p2.y, 0,\n               p3.x, p3.y, 0,\n               // Point 3 to point 1\n               p3.x, p3.y, 0,\n               p1.x, p1.y, 0,\n\n  };\n\n     // Store how many vertices and elements there is for future \n     // use\n     final int ELEMENTS_PER_VERTEX = 3;// x,y,z\n     int numElements = modelVertices.length;\n     numVertices = numElements/ELEMENTS_PER_VERTEX;\n\n     // Initialize the vertices ByteBuffer object based on the\n     // number of vertices in the button and the number of\n     // bytes there are in the float type\n     vertices = ByteBuffer.allocateDirect(\n              numElements\n              * FLOAT_SIZE)\n              .order(ByteOrder.nativeOrder()).asFloatBuffer();\n\n     // Add the button into the ByteBuffer object\n     vertices.put(modelVertices);\n\n       glProgram = GLManager.getGLProgram();\n     }\n```", "```java\n    public void draw(){\n\n            // And tell OpenGl to use the glProgram\n            glUseProgram(glProgram);\n\n            // Now we have a glProgram we need the locations\n            // of our three GLSL variables\n            int uMatrixLocation = glGetUniformLocation \n              (glProgram, U_MATRIX);\n            int aPositionLocation = glGetAttribLocation \n              (glProgram, A_POSITION);\n            int uColorLocation = glGetUniformLocation \n               (glProgram, U_COLOR);\n\n            vertices.position(0);\n\n            glVertexAttribPointer(\n                    aPositionLocation,\n                    COMPONENTS_PER_VERTEX,\n                    GL_FLOAT,\n                    false,\n                    STRIDE,\n                    vertices);\n\n            glEnableVertexAttribArray(aPositionLocation);\n\n            // Just give the passed in matrix to OpenGL\n            glUniformMatrix4fv(uMatrixLocation, 1, \n              false, viewportMatrix, 0);\n            // Assign a color to the fragment shader\n            glUniform4f(uColorLocation, 1.0f, \n              1.0f, 0.0f, 1.0f);\n            // Draw the lines\n            // start at the first element of \n            // the vertices array and read in all vertices\n            glDrawArrays(GL_LINES, 0, numVertices);\n        }\n\n}\n```", "```java\nTallyIcon[] tallyIcons;\nint numLives = 3;\nLifeIcon[] lifeIcons;\n```", "```java\nlifeIcons = new LifeIcon[50];\ntallyIcons = new TallyIcon[500];\n```", "```java\n// This will hold our game buttons\nprivate final GameButton[] gameButtons = new GameButton[5];\n```", "```java\n// Now for the HUD objects\n// First the life icons\nfor(int i = 0; i < gm.numLives; i++) {\n    // Notice we send in which icon this represents\n    // from left to right so padding and positioning is correct.\n    gm.lifeIcons[i] = new LifeIcon(gm, i);\n}\n\n// Now the tally icons (1 at the start)\nfor(int i = 0; i < gm.numAsteroidsRemaining; i++) {\n    // Notice we send in which icon this represents\n    // from left to right so padding and positioning is correct.\n    gm.tallyIcons[i] = new TallyIcon(gm, i);\n}\n\n// Now the buttons\nArrayList<Rect> buttonsToDraw = ic.getButtons();\nint i = 0;\nfor (Rect rect : buttonsToDraw) {\n    gameButtons[i] = new GameButton(rect.top, rect.left, \n        rect.bottom, rect.right, gm);\n\n    i++;\n\n}\n```", "```java\n// the buttons\nfor (int i = 0; i < gameButtons.length; i++) {\n  gameButtons[i].draw();\n}\n\n// Draw the life icons\nfor(int i = 0; i < gm.numLives; i++) {\n     // Notice we send in which icon this represents\n     // from left to right so padding and positioning is correct.\n     gm.lifeIcons[i].draw();\n}\n\n// Draw the level icons\nfor(int i = 0; i < gm.numAsteroidsRemaining; i++) {\n  // Notice we send in which icon this represents\n  // from left to right so padding and positioning is correct.\n  gm.tallyIcons[i].draw();\n}\n```", "```java\nif (any point falls outside the border){collision has occurred}\n```", "```java\n// All objects which can collide have a collision package.\n// Asteroids, ship, bullets. The structure seems like slight\n// overkill for bullets but it keeps the code generic,\n// and the use of vertexListLength means there isn't any\n// actual speed overhead. Also if we wanted line, triangle or\n// even spinning bullets the code wouldn't need to change.\n\npublic class CollisionPackage {\n\n    // All the members are public to avoid multiple calls\n    // to getters and setters.\n\n    // The facing angle allows us to calculate the\n    // current world coordinates of each vertex using\n    // the model-space coordinates in vertexList.\n    public float facingAngle;\n\n    // The model-space coordinates\n    public PointF[] vertexList;\n\n    /* \n    The number of vertices in vertexList\n    is kept in this next int because it is pre-calculated\n    and we can use it in our loops instead of\n    continually calling vertexList.length.\n   */\n    public int vertexListLength;\n\n    // Where is the centre of the object?\n    public PointF worldLocation;\n\n    /* \n    This next float will be used to detect if the circle shaped\n    hitboxes collide. It represents the furthest point\n    from the centre of any given object.\n    Each object will set this slightly differently.\n    The ship will use height/2 an asteroid will use 25\n    To allow for a max length rotated coordinate.\n   */\n    public float radius;\n\n    // A couple of points to store results and avoid creating new\n    // objects during intensive collision detection\n    public PointF currentPoint = new PointF();\n    public PointF currentPoint2 = new PointF();\n```", "```java\npublic CollisionPackage(PointF[] vertexList, PointF worldLocation, \n  float radius, float facingAngle){ \n\n        vertexListLength = vertexList.length;\n        this.vertexList = new PointF[vertexListLength];\n        // Make a copy of the array\n\n        for (int i = 0; i < vertexListLength; i++) {\n            this.vertexList[i] = new PointF();\n            this.vertexList[i].x = vertexList[i].x;\n            this.vertexList[i].y = vertexList[i].y;\n        }\n\n        this.worldLocation = new PointF();\n        this.worldLocation = worldLocation;\n\n        this.radius = radius;\n\n        this.facingAngle = facingAngle;\n\n    }\n\n}\n```", "```java\nCollisionPackage cp;\n```", "```java\n// Initialize the collision package\n// (the object space vertex list, x any world location\n// the largest possible radius, facingAngle)\n\n// First, build a one element array\nPointF point = new PointF(0,0);\nPointF[] points = new PointF[1];\npoints[0] = point;\n\n// 1.0f is an approximate representation \n//of the size of a bullet\ncp = new CollisionPackage(points, getWorldLocation(),\n1.0f, getFacingAngle());\n```", "```java\n        move(fps);\n\n // Update the collision package\n cp.facingAngle = getFacingAngle();\n cp.worldLocation = getWorldLocation();\n\n```", "```java\nCollisionPackage cp;\n\n// Next, a 2d representation using PointF of\n// the vertices. Used to build shipVertices\n// and to pass to the CollisionPackage constructor\nPointF[] points;\n```", "```java\nsetVertices(shipVertices);\n\n// Initialize the collision package\n// (the object space vertex list, x any world location\n// the largest possible radius, facingAngle)\n\npoints = new PointF[6];\npoints[0] = new PointF(- halfW, - halfL);\n\npoints[2] = new PointF(halfW, - halfL);\npoints[4] = new PointF(0, 0 + halfL);\n\n// To make collision detection more accurate we will define some\n// more points on the midpoints of all our sides.\n// It is possible that the point of an asteroid will pass through\n// the side of the ship and we do not test for this!\n// We only test for the point of a ship \n// passing through the side of an asteroid!!\n// This is computationally cheaper than running both tests.\n// Although not as accurate we will see it is very close.\n// We can think of this visually as \n// adding extra sensors on the sides of our ship\n// Here we use an equation to find the midpoint \n// of a line which you can find an explanation of\n// on most good high school math web sites.\n\npoints[1] = new PointF(points[0].x + \n points[2].x/2,(points[0].y + points[2].y)/2);\n\npoints[3] = new PointF((points[2].x + points[4].x)/2,\n (points[2].y + points[4].y)/2);\n\npoints[5] = new PointF((points[4].x + points[0].x)/2,\n (points[4].y + points[0].y)/2);\n\ncp = new CollisionPackage(points, getWorldLocation(), \n length/2, getFacingAngle());\n\n}// End SpaceShip constructor\n```", "```java\nmove(fps);\n\n // Update the collision package\n cp.facingAngle = getFacingAngle();\n cp.worldLocation = getWorldLocation();\n\n}// End SpaceShip update()\n```", "```java\nCollisionPackage cp;\n```", "```java\n// Define a random asteroid shape\n// Then call the parent setVertices()\ngeneratePoints();\n\n// Initialize the collision package\n// (the object space vertex list, x any world location\n// the largest possible radius, facingAngle)\ncp = new CollisionPackage\n (points, getWorldLocation(), 25, getFacingAngle());\n\n```", "```java\npublic void bounce(){\n\n  // Reverse the travelling angle\n    if(getTravellingAngle() >= 180){\n      setTravellingAngle(getTravellingAngle()-180);\n     }else{\n      setTravellingAngle(getTravellingAngle() + 180);\n    }\n\n    // Reverse velocity because occasionally they get stuck\n    setWorldLocation((getWorldLocation().x + -getxVelocity()/3), (getWorldLocation().y + -getyVelocity()/3));\n\n    // Speed up by 10%\n    setSpeed(getSpeed() * 1.1f);\n\n    // Not too fast though\n    if(getSpeed() > getMaxSpeed()){\n      setSpeed(getMaxSpeed());\n\n}\n```", "```java\nmove(fps);\n\n// Update the collision package\ncp.facingAngle = getFacingAngle();\ncp.worldLocation = getWorldLocation();\n\n}\n```", "```java\n// left below 0\npoints[5] = new PointF();\ni = -(r.nextInt(14)+11);\npoints[5].x =  i;\ni = -(r.nextInt(12)+1);\n\npoints[5].y = i;\n\n// We add on an extra point that we won't use in asteroidVertices[].\n// The point is the same as the first. \n// This is because the last vertex\n// links back to the first to create a line. \n// This line will need to be\n// used in calculations when we do our collision detection.\n\n// Here is the extra vertex- same as the first.\npoints[6] = new PointF();\npoints[6].x = points[0].x;\npoints[6].x = points[0].x;\n\n// Now use these points to draw our asteroid\nfloat[] asteroidVertices = new float[]{\n// First point to second point\npoints[0].x, points[0].y, 0,\npoints[1].x, points[1].y, 0,\n```", "```java\nprivate static PointF rotatedPoint = new PointF();\n```", "```java\npublic static boolean detect(CollisionPackage cp1, \n    CollisionPackage cp2) {\n\n    boolean collided = false;\n\n   // Check circle collision between the two objects\n\n   // Get the distance of the two objects from\n   // the centre of the circles on the x axis\n   float distanceX = (cp1.worldLocation.x)\n        - (cp2.worldLocation.x);\n\n   // Get the distance of the two objects from\n   // the centre of the circles on the y axis\n   float distanceY = (cp1.worldLocation.y)\n        - (cp2.worldLocation.y);\n\n        // Calculate the distance between the center of each circle\n        double distance = Math.sqrt\n            (distanceX * distanceX + distanceY * distanceY);\n\n        // Finally see if the two circles overlap\n        // If they do it is worth doing the more intensive\n        // and accurate check.\n        if (distance < cp1.radius + cp2.radius) {\n\n         // Log.e(\"Circle collision:\",\"true\");\n         // todo  Eventually we will add the \n         // more accurate code here\n         // todo and delete the line below.\n\n            collided = true;\n        }\n\n        return collided;\n    }\n```", "```java\n// Check if anything hits the border\npublic static boolean contain(float mapWidth, float mapHeight,                                              \n  CollisionPackage cp) {\n\n   boolean possibleCollision = false;\n\n    // Check if any corner of a virtual rectangle\n    // around the centre of the object is out of bounds.\n    // Rectangle is best because we are testing \n    // against straight sides (the border)\n    // If it is we have a possible collision.\n\n    if (cp.worldLocation.x - cp.radius < 0) {\n            possibleCollision = true;\n        } else if (cp.worldLocation.x + cp.radius > mapWidth) {\n            possibleCollision = true;\n        } else if (cp.worldLocation.y - cp.radius < 0) {\n            possibleCollision = true;\n        } else if (cp.worldLocation.y + cp.radius > mapHeight) {\n            possibleCollision = true;\n        }\n\n        if (possibleCollision) {\n            // todo For now we return true\n            return true;\n        }\n\n        return false; // No collision\n}\n```", "```java\npublic void lifeLost(){\n        // Reset the ship to the center\n        gm.ship.setWorldLocation(gm.mapWidth/2, gm.mapHeight/2);\n        // Play a sound\n        sm.playSound(\"shipexplode\");\n\n        // Deduct a life\n        gm.numLives = gm.numLives -1;\n\n        if(gm.numLives == 0){\n            gm.levelNumber = 1;\n            gm.numLives = 3;\n            createObjects();\n            gm.switchPlayingStatus();\n            sm.playSound(\"gameover\");\n        }\n    }\n```", "```java\npublic void destroyAsteroid(int asteroidIndex){\n\n  gm.asteroids[asteroidIndex].setActive(false);\n     // Play a sound\n     sm.playSound(\"explode\");\n     // Reduce the number of active asteroids\n     gm.numAsteroidsRemaining --;\n\n     // Has the player cleared them all?\n     if(gm.numAsteroidsRemaining == 0){\n     // Play a victory sound\n\n     // Increment the level number\n     gm.levelNumber ++;\n\n     // Extra life\n     gm.numLives ++;\n\n     sm.playSound(\"nextlevel\");\n     // Respawn everything\n     // With more asteroids\n     createObjects();\n\n}\n}\n}// End class\n```", "```java\n// End of all updates!!\n\n// All objects are in their new locations\n// Start collision detection\n\n// Check if the ship needs containing\nif (CD.contain(gm.mapWidth, gm.mapHeight, gm.ship.cp)) {\n\n  lifeLost();\n\n}\n```", "```java\n// Check if an asteroid needs containing\nfor (int i = 0; i < gm.numAsteroids; i++) {\n  if (gm.asteroids[i].isActive()) {\n       if (CD.contain(gm.mapWidth, gm.mapHeight, \n       gm.asteroids[i].cp)) {\n\n          // Bounce the asteroid back into the game\n          gm.asteroids[i].bounce();\n\n          // Play a sound\n          sm.playSound(\"blip\");\n\n       }\n    }\n\n}\n```", "```java\n// Check if bullet needs containing\n// But first see if the bullet is out of sight\n// If it is reset it to make game harder\nfor (int i = 0; i < gm.numBullets; i++) {\n\n    // Is the bullet in flight?\n    if (gm.bullets[i].isInFlight()) {\n\n   // Comment the next block to make the game easier!!!\n   // It will allow the bullets to go all the way from\n   // ship to border without being reset. \n   // These lines reset the bullet when\n   // shortly after they leave the players view.\n   // This forces the player to go 'hunting' for the\n   // asteroids instead of spinning round spamming the\n   // fire button...\n   // This code would be better with a viewport.clip() method\n   // like in project 2 but seems a bit excessive just for these\n   // few 15ish lines of code.\n\n   // Start comment out to make easier\n   handyPointF = gm.bullets[i].getWorldLocation();\n   handyPointF2 = gm.ship.getWorldLocation();\n\n   if(handyPointF.x > handyPointF2.x + gm.metresToShowX / 2){\n        // Reset the bullet\n        gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n\n    }else\n        if(handyPointF.x < handyPointF2.x - gm.metresToShowX / 2){\n            // Reset the bullet\n            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n\n        }else\n        if(handyPointF.y > handyPointF2.y + gm.metresToShowY/ 2){\n            // Reset the bullet\n            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n       }else\n        if(handyPointF.y < handyPointF2.y - gm.metresToShowY / 2){\n            // Reset the bullet\n            gm.bullets[i].resetBullet(gm.ship.getWorldLocation());\n                }\n            // End comment out to make easier\n\n            // Does bullet need containing?\n            if (CD.contain(gm.mapWidth, gm.mapHeight,      \n                gm.bullets[i].cp)) {\n\n                 // Reset the bullet\n                 gm.bullets[i].resetBullet\n                    (gm.ship.getWorldLocation());\n                 // Play a sound\n                 sm.playSound(\"ricochet\");\n          }\n\n     }\n\n}\n```", "```java\n// Now we see if anything has hit an asteroid\n\n// Check collisions between asteroids and bullets\n// Loop through each bullet and asteroid in turn\n\nfor (int bulletNum = 0; bulletNum < gm.numBullets; bulletNum++) {\n    for (int asteroidNum = 0; asteroidNum < gm.numAsteroids;                            \n        asteroidNum++) {\n\n        // Check that the current bullet is in flight\n        // and the current asteroid is \n        // active before proceeding\n        if (gm.bullets[bulletNum].isInFlight() &&                                           \n            gm.asteroids[asteroidNum].isActive())\n\n            // Perform the collision checks by \n            // passing in the collision packages\n\n            // A Bullet only has one vertex. \n            // Our collision detection works on vertex pairs\n\n          if (CD.detect(gm.bullets[bulletNum].cp,                                           \n              gm.asteroids[asteroidNum].cp)) {\n\n                // If we get a hit...\n                destroyAsteroid(asteroidNum);\n\n                // Reset the bullet\n                gm.bullets[bulletNum].resetBullet\n                    (gm.ship.getWorldLocation());\n           }\n\n    }\n}\n```", "```java\n// Check collisions between asteroids and ship\n// Loop through each asteroid in turn\n\nfor (int asteroidNum = 0; asteroidNum < gm.numAsteroids;                            \n     asteroidNum++) {\n\n    // Is the current asteroid active before proceeding\n    if (gm.asteroids[asteroidNum].isActive()) {\n\n        // Perform the collision checks by\n        // passing in the collision packages\n        if (CD.detect(gm.ship.cp, gm.asteroids[asteroidNum].cp)) {\n\n        // hit!\n        destroyAsteroid(asteroidNum);\n        lifeLost();\n       }\n    }\n}\n```", "```java\nif (possibleCollision) {\n\n double radianAngle = ((cp.facingAngle/180)*Math.PI);\n double cosAngle = Math.cos(radianAngle);\n double sinAngle = Math.sin(radianAngle);\n\n```", "```java\n    //Rotate each and every vertex then check for a collision\n    // If just one is then we have a collision.\n    // Once we have a collision no need to check further\n    for (int i = 0 ; i < cp.vertexListLength; i++){\n        // First update the regular un-rotated model space coordinates\n        // relative to the current world location (centre of object)\n        float worldUnrotatedX = \n                cp.worldLocation.x + cp.vertexList[i].x;\n\n        float worldUnrotatedY =  \n                cp.worldLocation.y + cp.vertexList[i].y;\n\n        // Now rotate the newly updated point, stored in currentPoint\n        // around the centre point of the object (worldLocation)\n        cp.currentPoint.x = cp.worldLocation.x + (int)                                   \n            ((worldUnrotatedX - cp.worldLocation.x)\n            * cosAngle - (worldUnrotatedY - cp.worldLocation.y)\n            * sinAngle);\n\n        cp.currentPoint.y = cp.worldLocation.y + (int)                                   \n            ((worldUnrotatedX - cp.worldLocation.x)\n            * sinAngle+(worldUnrotatedY - cp.worldLocation.y)\n            * cosAngle);\n```", "```java\n     // Check the rotated vertex for a collision\n     if (cp.currentPoint.x < 0) {\n\n       return true;\n     } else if (cp.currentPoint.x > mapWidth) {\n\n       return true;\n     } else if (cp.currentPoint.y < 0) {\n\n       return true;\n     } else if (cp.currentPoint.y > mapHeight) {\n\n       return true;\n   }\n\n}\n```", "```java\n     if (distance < cp1.radius + cp2.radius) {\n\n            double radianAngle1 = ((cp1.facingAngle / 180) * Math.PI);\n            double cosAngle1 = Math.cos(radianAngle1);\n            double sinAngle1 = Math.sin(radianAngle1);\n\n            double radianAngle2 = ((cp2.facingAngle / 180) * Math.PI);\n            double cosAngle2 = Math.cos(radianAngle2);\n            double sinAngle2 = Math.sin(radianAngle2);\n\n            int numCrosses = 0;    // The number of times we cross a side\n\n            float worldUnrotatedX;\n            float worldUnrotatedY;\n```", "```java\nfor (int i = 0; i < cp1.vertexListLength; i++) {\n\n    worldUnrotatedX = cp1.worldLocation.x + cp1.vertexList[i].x;\n    worldUnrotatedY = cp1.worldLocation.y + cp1.vertexList[i].y;\n\n    // Now rotate the newly updated point, stored in currentPoint\n    // around the centre point of the object (worldLocation)\n    cp1.currentPoint.x = cp1.worldLocation.x +\n        (int) ((worldUnrotatedX - cp1.worldLocation.x)\n        * cosAngle1 - (worldUnrotatedY - cp1.worldLocation.y) *\n        sinAngle1);\n\n    cp1.currentPoint.y = cp1.worldLocation.y + \n        (int) ((worldUnrotatedX - cp1.worldLocation.x)\n        * sinAngle1 + (worldUnrotatedY - cp1.worldLocation.y) *                   \n         cosAngle1);\n\n    // cp1.currentPoint now hold the x/y \n    // world coordinates of the first point to test\n```", "```java\n// Use two vertices at a time to represent the line we are testing\n// We don't test the last vertex because we are testing pairs\n// and the last vertex of cp2 is the padded extra vertex.\n// It will form part of the last side when we test vertexList[5]\n\nfor (int j = 0; j < cp2.vertexListLength - 1; j++) {\n\n    // Now we get the rotated coordinates of \n    // BOTH the current 2 points being\n    // used to form a side from cp2 (the asteroid)\n    // First we need to rotate the model-space \n    // coordinate we are testing\n    // to its current world position\n    // First update the regular un-rotated model space coordinates\n    // relative to the current world location (centre of object)\n\n    worldUnrotatedX = cp2.worldLocation.x + cp2.vertexList[j].x;\n    worldUnrotatedY = cp2.worldLocation.y + cp2.vertexList[j].y;\n\n    // Now rotate the newly updated point, stored in worldUnrotatedX/y\n    // around the centre point of the object (worldLocation)\n\n    cp2.currentPoint.x = cp2.worldLocation.x + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * cosAngle2 - (worldUnrotatedY - cp2.worldLocation.y) *                   \n          sinAngle2);\n\n    cp2.currentPoint.y = cp2.worldLocation.y + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * sinAngle2 + (worldUnrotatedY - cp2.worldLocation.y) *                   \n          cosAngle2);\n\n    // cp2.currentPoint now hold the x/y world coordinates\n    // of the first point that\n    // will represent a line from the asteroid\n\n    // Now we can do exactly the same for the \n    // second vertex and store it in\n    // currentPoint2\\. We will then have a point and a line (two \n    // vertices)we can use the\n    // crossing number algorithm on.\n\n    worldUnrotatedX = cp2.worldLocation.x + cp2.vertexList[i + 1].x;\n    worldUnrotatedY = cp2.worldLocation.y + cp2.vertexList[i + 1].y;\n\n    // Now rotate the newly updated point, stored in worldUnrotatedX/Y\n    // around the centre point of the object (worldLocation)\n    cp2.currentPoint2.x = cp2.worldLocation.x + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * cosAngle2 - (worldUnrotatedY - cp2.worldLocation.y) *                   \n          sinAngle2);\n\n    cp2.currentPoint2.y = cp2.worldLocation.y + \n          (int) ((worldUnrotatedX - cp2.worldLocation.x)\n          * sinAngle2 + (worldUnrotatedY - cp2.worldLocation.y) *                   \n           cosAngle2);\n```", "```java\n// And now we can test the rotated point from cp1 against the\n// rotated points which form a side from cp2\n\nif (((cp2.currentPoint.y > cp1.currentPoint.y) !=                               \n       (cp2.currentPoint2.y > cp1.currentPoint.y)) &&\n       (cp1.currentPoint.x < (cp2.currentPoint2.x -                                \n     cp2.currentPoint2.x)    *(cp1.currentPoint.y - \n        cp2.currentPoint.y) / (cp2.currentPoint2.y  -                               \n  cp2.currentPoint.y) + cp2.currentPoint.x)){\n\n        numCrosses++;\n\n}\n```", "```java\n            }\n            }\n            // So do we have a collision?\n            if (numCrosses % 2 == 0) {\n                // even number of crosses(outside asteroid)\n                collided = false;\n            } else {\n                // odd number of crosses(inside asteroid)\n                collided = true;\n            }\n\n        }// end if\n```", "```java\n<uses-feature android:glEsVersion=\"0x00020000\" android:required=\"true\" />\n```"]