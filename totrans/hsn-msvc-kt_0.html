<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Best Practices</h1>
                
            
            <article>
                
<p class="calibre2">During the course of this book, we have learned a vast set of technologies and tools that allowed us to create microservices with Kotlin using the Spring Framework; however, this is not a simple task. When we apply what we have learned in our own project, there will always be an infinite amount of approaches that we could choose, and some may work better than others.</p>
<p class="calibre2">In this chapter, we will try to learn industry best practices, which will allow us to improve the overall quality of our microservices. In this chapter, you will learn more about:</p>
<ul class="calibre7">
<li class="calibre8">Kotlin idioms</li>
<li class="calibre8">Spring Context</li>
<li class="calibre8">Layering</li>
<li class="calibre8">Testing</li>
<li class="calibre8">Continuous Integration</li>
<li class="calibre8">Continuous Delivery</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Kotlin idioms</h1>
                
            
            <article>
                
<p class="calibre2">Kotlin provides a set of idioms that allows us to drastically reduce the amount of boilerplate code. Boilerplate refers to sections of code that have to be included in many places with little or no alteration. In this section, we will learn some of the most used idioms.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inferred types</h1>
                
            
            <article>
                
<p class="calibre2">We may have a function written that returns a value, such as:</p>
<pre class="calibre20"><span>fun </span><span>lower</span>(name : String) : String {<br class="title-page-name"/>  <span>val </span>lower : String = name.<span>toLowerCase</span>()<br class="title-page-name"/>  <span>return </span><span>"</span><span>$</span>name<span> in lower case is: </span><span>$</span>lower<span>"<br class="title-page-name"/></span>}</pre>
<p class="calibre2">Here, we are explicitly indicating the type of the result of the function and the internal variable that we use inside.</p>
<p class="calibre2">In Kotlin, we could infer the type of the variable:</p>
<pre class="calibre20"><span>fun </span><span>lower</span>(name : String): String {<br class="title-page-name"/>  <span>val </span>lower = name.<span>toLowerCase</span>()<br class="title-page-name"/>  <span>return </span><span>"</span><span>$</span>name<span> in lower case is: </span><span>$</span>lower<span>"<br class="title-page-name"/></span>}</pre>
<p class="calibre2">And even the return type of our function could be inferred:</p>
<pre class="calibre20"><span>fun </span><span>lower</span>(name : String) = <span>"</span><span>$</span>name<span> in lower case is: </span><span>${</span>name.<span>toLowerCase</span>()<span>}</span><span>"</span></pre>
<p class="calibre2">This will be extremely useful as the code that we created with the inferred type did not need to change if we change the type it uses. Let's clarify this with an example:</p>
<pre class="calibre20"><span>fun </span><span>foo</span>() : String {<br class="title-page-name"/>  <span>return </span><span>"14"<br class="title-page-name"/></span>}<br class="title-page-name"/><br class="title-page-name"/><span>fun </span><span>bar</span>() : String {<br class="title-page-name"/>  <span>val </span>value : String = <span>foo</span>()<br class="title-page-name"/>  <span>return </span>value<br class="title-page-name"/>}</pre>
<p class="calibre2">If we change our <kbd class="calibre11">foo</kbd> method to:</p>
<pre class="calibre20"><span>fun </span><span>foo</span>() : Int {<br class="title-page-name"/>  <span>return </span><span>14<br class="title-page-name"/></span>}</pre>
<p class="calibre2">Our <kbd class="calibre11">bar</kbd> method needs to be changed to:</p>
<pre class="calibre20"><span>fun </span><span>bar</span>() : Int {<br class="title-page-name"/>  <span>val </span>value : Int = <span>foo</span>()<br class="title-page-name"/>  <span>return </span>value<br class="title-page-name"/>}</pre>
<p class="calibre2">However, if our methods were declared like:</p>
<pre class="calibre20"><span>fun </span><span>foo</span>() = <span>"14"<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>fun </span><span>bar</span>() = <span>foo</span>()</pre>
<p class="calibre2">Then we could simply change the result of <kbd class="calibre11">foo</kbd> without affecting <kbd class="calibre11">bar</kbd>:</p>
<pre class="calibre20"><span>fun </span><span>foo</span>() = <span>14<br class="title-page-name"/></span><span><br class="title-page-name"/></span><span>fun </span><span>bar</span>() = <span>foo</span>()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Expressions</h1>
                
            
            <article>
                
<p class="calibre2">Considering that we have a simple function to return some value:</p>
<pre class="calibre20"><span>fun </span><span>oddOrEven</span>(number: Int): String {<br class="title-page-name"/>  <span>if</span>(number % <span>2 </span>== <span>0</span>)<br class="title-page-name"/>    <span>return </span><span>"odd"<br class="title-page-name"/></span><span>  </span><span>else<br class="title-page-name"/></span><span>    return </span><span>"even"<br class="title-page-name"/></span>}</pre>
<p class="calibre2">It could be used as an expression:</p>
<pre class="calibre20"><span>fun </span><span>oddOrEven</span>(number: Int): String {<br class="title-page-name"/>  <span>return if</span>(number % <span>2 </span>== <span>0</span>)<br class="title-page-name"/>    <span>"odd"<br class="title-page-name"/></span><span>  </span><span>else<br class="title-page-name"/></span><span>    </span><span>"even"<br class="title-page-name"/></span>}</pre>
<p class="calibre2">And, of course, we could infer the type:</p>
<pre class="calibre20"><span>fun </span><span>oddOrEven</span>(number: Int) =<br class="title-page-name"/>    <span>if </span>(number % <span>2 </span>== <span>0</span>)<br class="title-page-name"/>      <span>"odd"<br class="title-page-name"/></span><span>    </span><span>else<br class="title-page-name"/></span><span>      </span><span>"even"</span></pre>
<p class="calibre2">Other statements could be used as an expression, for example, if we have this function:</p>
<pre class="calibre20"><span>fun </span><span>fizzBuzz</span>(number: Int): String {<br class="title-page-name"/>  <span>if </span>(number % <span>15 </span>== <span>0</span>) {<br class="title-page-name"/>    <span>return </span><span>"FizzBuzz"<br class="title-page-name"/></span><span>  </span>} <span>else if </span>(number % <span>3 </span>== <span>0</span>) {<br class="title-page-name"/>    <span>return </span><span>"Fizz"<br class="title-page-name"/></span><span>  </span>} <span>else if </span>(number % <span>5 </span>== <span>0</span>) {<br class="title-page-name"/>    <span>return </span><span>"Buzz"<br class="title-page-name"/></span><span>  </span>} <span>else </span>{<br class="title-page-name"/>    <span>return </span>number.toString()<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">We could convert it into an expression:</p>
<pre class="calibre20"><span>fun </span><span>fizzBuzz</span>(number: Int) =<br class="title-page-name"/>    <span>if </span>(number % <span>15 </span>== <span>0</span>) {<br class="title-page-name"/>      <span>"FizzBuzz"<br class="title-page-name"/></span><span>    </span>} <span>else if </span>(number % <span>3 </span>== <span>0</span>) {<br class="title-page-name"/>      <span>"Fizz"<br class="title-page-name"/></span><span>    </span>} <span>else if </span>(number % <span>5 </span>== <span>0</span>) {<br class="title-page-name"/>      <span>"Buzz"<br class="title-page-name"/></span><span>    </span>} <span>else </span>{<br class="title-page-name"/>      number.toString()<br class="title-page-name"/>    }</pre>
<p class="calibre2">But Kotlin has the <kbd class="calibre11">when</kbd> expression that could be used in the same way as Java <kbd class="calibre11">switch</kbd>/<kbd class="calibre11">case</kbd>:</p>
<pre class="calibre20">fun fizzBuzz(number: Int) =<br class="title-page-name"/>    when {<br class="title-page-name"/>      number % 15 == 0 -&gt; "FizzBuzz"<br class="title-page-name"/>      number % 3 == 0 -&gt; "Fizz"<br class="title-page-name"/>      number % 5 == 0 -&gt; "Buzz"<br class="title-page-name"/>      else -&gt; number.toString()<br class="title-page-name"/>    }</pre>
<p class="calibre2">This could be applied to other expressions such as <kbd class="calibre11">try</kbd>/<kbd class="calibre11">catch</kbd>:</p>
<pre class="calibre20"><span>fun </span><span>calculate</span>(number1: Int<span>, </span>number2: Int) =<br class="title-page-name"/>    <span>try </span>{<br class="title-page-name"/>      number1 / number2<br class="title-page-name"/>    } <span>catch </span>(ex: Exception) {<br class="title-page-name"/>      <span>0<br class="title-page-name"/></span><span>    </span>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Default parameters</h1>
                
            
            <article>
                
<p class="calibre2">Kotlin allows us to specify default parameters when declaring functions:</p>
<pre class="calibre20"><span>fun </span><span>compute</span>(number1: Int<span>, </span>number2: Int = <span>2</span><span>, </span>number3: Int = <span>5</span>) = number1 * number2 * number3</pre>
<p class="calibre2">This could be used as:</p>
<pre class="calibre20"><span>println</span>(<span>compute</span>(<span>7</span>))<br class="title-page-name"/><span>println</span>(<span>compute</span>(<span>7</span><span>, </span><span>2</span>))<br class="title-page-name"/><span>println</span>(<span>compute</span>(<span>7</span><span>, </span><span>2</span><span>, </span><span>8</span>))<br class="title-page-name"/><span>println</span>(<span>compute</span>(<span>number1 = </span><span>8</span><span>, </span><span>number3 = </span><span>4</span>))</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Lambda</h1>
                
            
            <article>
                
<p class="calibre2">Considering that we just use a range of numbers that we cycle in a loop:</p>
<pre class="calibre20"><span>fun </span><span>printNumbers</span>(){<br class="title-page-name"/>  <span>val </span>range = <span>1</span>..<span>10<br class="title-page-name"/></span><span>  </span><span>for</span>(i <span>in </span>range){<br class="title-page-name"/>    <span>println</span>(i)<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2"><span>We could use a lambda to access them:</span></p>
<pre class="calibre20"><span>fun </span><span>printNumbers</span>(){<br class="title-page-name"/>  <span>val </span>range = <span>1</span>..<span>10<br class="title-page-name"/></span><span>  </span>range.<span>forEach </span><span>{ </span>i <span>-&gt; </span><span>println</span>(i) <span>}<br class="title-page-name"/></span>}</pre>
<p class="calibre2">But lambda could be easily shortened with the inferred <kbd class="calibre11">it</kbd> object:</p>
<pre class="calibre20"><span>fun </span><span>printNumbers</span>(){<br class="title-page-name"/>  <span>val </span>range = <span>1</span>..<span>10<br class="title-page-name"/></span><span>  </span>range.<span>forEach </span><span>{ </span><span>println</span>(<span>it</span>) <span>}<br class="title-page-name"/></span>}</pre>
<p class="calibre2">And we don't really need a variable for <kbd class="calibre11">it</kbd>, so we could simplify it with:</p>
<pre class="calibre20"><span>fun </span><span>printNumbers</span>() {<br class="title-page-name"/>  (<span>1</span>..<span>10</span>).<span>forEach </span><span>{ </span><span>println</span>(<span>it</span>) <span>}<br class="title-page-name"/></span>}</pre>
<p class="calibre2">But since we just print the elements of <kbd class="calibre11">forEach</kbd>, we could just use a method reference instead of the lambda:</p>
<pre class="calibre20"><span>fun </span><span>printNumbers</span>() {<br class="title-page-name"/>  (<span>1</span>..<span>10</span>).<span>forEach</span>(::println)<br class="title-page-name"/>}</pre>
<div class="packt_tip">These were just some examples of some of the Kotlin idioms, but there are dozens more, and we strongly recommend you check the official Kotlin documentation to review them all to keep you up to date with new additions that appear as the language evolves: <a href="https://kotlinlang.org/docs/reference/idioms.html" class="calibre31">https://kotlinlang.org/docs/reference/idioms.html</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing the Spring context</h1>
                
            
            <article>
                
<p class="calibre2">The Spring application context is where our beans are referenced to be used in our application, and managing it correctly is not a simple task. When we have dozens of beans created, where and how we access them is important, and we could end up in a situation that we refer to as an incorrect bean.</p>
<p class="calibre2">In this section, we will discuss ways to handle this complexity.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Constructor injection</h1>
                
            
            <article>
                
<p class="calibre2">In this book, we have used <kbd class="calibre11">@Autowired</kbd> in our examples to illustrate how we ask Spring to inject a bean into our application.</p>
<p class="calibre2">Consider this example of two services and a controller that uses them:</p>
<pre class="calibre20">import org.springframework.beans.factory.annotation.Autowired<br class="title-page-name"/>import org.springframework.stereotype.Service<br class="title-page-name"/>import org.springframework.web.bind.annotation.*<br class="title-page-name"/><br class="title-page-name"/>@Service<br class="title-page-name"/>class AccountService {<br class="title-page-name"/>  fun getAccountsByCustomer(customerId: Int): List&lt;Account&gt;<br class="title-page-name"/>      = listOf(Account(1, 125F), Account(2, 500F))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Service<br class="title-page-name"/>class CustomerService {<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  private lateinit var accountService: AccountService<br class="title-page-name"/><br class="title-page-name"/>  fun getCustomer(id: Int): Customer {<br class="title-page-name"/>    val accounts = accountService.getAccountsByCustomer(id)<br class="title-page-name"/>    return Customer(id, "customer$id", accounts)<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@RestController<br class="title-page-name"/>class CustomerController {<br class="title-page-name"/>  @Autowired<br class="title-page-name"/>  private lateinit var customerService: CustomerService<br class="title-page-name"/><br class="title-page-name"/>  @GetMapping("/customer/{id}")<br class="title-page-name"/>  fun getCustomer(@PathVariable id: Int) = customerService.getCustomer(1)<br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre11">CustomerController</kbd> injects the <kbd class="calibre11">CustomerService</kbd> bean using the <kbd class="calibre11">@AutoWired</kbd> annotation, and <kbd class="calibre11">CustomerService</kbd> injects the <kbd class="calibre11">AccountService</kbd> using the <kbd class="calibre11">@Autowired</kbd> annotation as well.</p>
<p class="calibre2">These services use a couple of data classes that we created for this example:</p>
<pre class="calibre20">data class Account(val id : Int, val balance : Float)<br class="title-page-name"/>data class Customer(val id : Int, val name : String, val accounts: List&lt;Account&gt;)</pre>
<p class="calibre2">Instead of using <kbd class="calibre11">@AutoWired</kbd>, we could inject our services as part of the constructor of the classes:</p>
<pre class="calibre20">import org.springframework.stereotype.Service<br class="title-page-name"/>import org.springframework.web.bind.annotation.*<br class="title-page-name"/><br class="title-page-name"/>@Service<br class="title-page-name"/>class AccountService {<br class="title-page-name"/>  fun getAccountsByCustomer(customerId: Int): List&lt;Account&gt;<br class="title-page-name"/>      = listOf(Account(1, 125F), Account(2, 500F))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Service<br class="title-page-name"/>class CustomerService(<strong class="calibre1">val accountService: AccountService</strong>) {<br class="title-page-name"/>  fun getCustomer(id: Int): Customer {<br class="title-page-name"/>    val accounts = accountService.getAccountsByCustomer(id)<br class="title-page-name"/>    return Customer(id, "customer$id", accounts)<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@RestController<br class="title-page-name"/>class CustomerController(<strong class="calibre1">val customerService: CustomerService</strong>) {<br class="title-page-name"/>  @GetMapping("/customer/{id}")<br class="title-page-name"/>  fun getCustomer(@PathVariable id: Int) = customerService.getCustomer(1)<br class="title-page-name"/>}</pre>
<p class="calibre2">When Spring is creating our <kbd class="calibre11">CustomerController</kbd>, it will detect that the parameter in the constructor, <kbd class="calibre11">CustomerService</kbd>, is actually a bean that exists in the context so it will inject while creating the <kbd class="calibre11">CustomerController</kbd>. Exactly the same will happen when the <kbd class="calibre11">CustomerService</kbd> is created with the <kbd class="calibre11">AccountService</kbd> being injected.</p>
<p class="calibre2">This will improve a couple of things; first, it will become clearer what is required in our components just by looking at the constructor, the second autowired required a <kbd class="calibre11">var</kbd>, a mutable object, with constructor injection we could use <kbd class="calibre11">val</kbd>, an immutable object that could not be changed later on.</p>
<div class="packt_tip">Having our objects as immutable allows us to prevent problems when creating concurrent applications such as microservices. They could also have a positive impact on performance.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Explicit context configuration</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have used <kbd class="calibre11">@Component</kbd> or <kbd class="calibre11">@Service</kbd> to declare our beans that later on, when the SpringBoot application starts, will add to the Spring context by the component scan. However, we may want to explicitly declare our beans using a <kbd class="calibre11">Configuration</kbd> class:</p>
<pre class="calibre20"><span>import org.springframework.context.annotation.Bean<br class="title-page-name"/>import org.springframework.context.annotation.Configuration<br class="title-page-name"/><br class="title-page-name"/>@Configuration<br class="title-page-name"/></span><span>class </span>ContextConfiguration {<br class="title-page-name"/>  <span>@Bean<br class="title-page-name"/></span><span>  fun </span><span>accountService</span>() = AccountService()<br class="title-page-name"/><br class="title-page-name"/>  <span>@Bean<br class="title-page-name"/></span><span>  fun </span><span>customerService</span>(accountService: AccountService) = CustomerService(accountService)<br class="title-page-name"/><br class="title-page-name"/>  <span>@Bean<br class="title-page-name"/></span><span>  fun </span><span>customerController</span>(customerService: CustomerService) = CustomerController(customerService)<br class="title-page-name"/>}</pre>
<p class="calibre2">Since we now have a constructor injection, we need to specify our bean declaration to receive as a parameter the bean that we need, so we could send it to the constructor of the method. Then, we could remove the <kbd class="calibre11">@Service</kbd> from our service since we don't need the component scan created then:</p>
<pre class="calibre20">class AccountService {<br class="title-page-name"/>  fun getAccountsByCustomer(customerId: Int): List&lt;Account&gt;<br class="title-page-name"/>      = listOf(Account(1, 125F), Account(2, 500F))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class CustomerService(val accountService: AccountService) {<br class="title-page-name"/>  fun getCustomer(id: Int): Customer {<br class="title-page-name"/>    val accounts = accountService.getAccountsByCustomer(id)<br class="title-page-name"/>    return Customer(id, "customer$id", accounts)<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Finally, we could move the <kbd class="calibre11">application</kbd> class and the <kbd class="calibre11">ContextConfiguration</kbd> class to a separate package, which will prevent the component scan from picking any other annotated class and adding it as a bean, and to do this, we have an explicit context configuration that tells us exactly what we need in our context:</p>
<div class="mce-root4"><img src="../images/00069.gif" class="calibre77"/></div>
<div class="mce-root3">Application package</div>
<p class="calibre2"><span>In this example, the component scan loads our <kbd class="calibre11">ContextConfiguration</kbd> class when the application is launched and then we will create our beans.</span></p>
<div class="packt_tip">Having an explicit context allows us to avoid situations that could be very complicated to handle, such as getting the right bean when we have a large number of classes. We are not saying that we need to avoid the component scan completely, but we need to use it cautiously.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Decouple services</h1>
                
            
            <article>
                
<p class="calibre2">One thing that we may overlook is that our controller and service have a dependency on the actual implementation. This means that if we have an implementation change tomorrow, for example, moving from a database into a different mechanism, we need to change who uses it, so to avoid that, we will create interfaces for them.</p>
<p class="calibre2">First, we will rename our <kbd class="calibre11">CustomerService</kbd> to <kbd class="calibre11">CustomerServiceImpl</kbd>, and our <kbd class="calibre11">AccountService</kbd> to <kbd class="calibre11">AccountServiceImpl</kbd>; then, we will create our interfaces:</p>
<pre class="calibre20">interface AccountService {<br class="title-page-name"/>  fun getAccountsByCustomer(customerId: Int): List&lt;Account&gt;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class AccountServiceImpl : AccountService {<br class="title-page-name"/>  override fun getAccountsByCustomer(customerId: Int): List&lt;Account&gt;<br class="title-page-name"/>      = listOf(Account(1, 125F), Account(2, 500F))<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>interface CustomerService {<br class="title-page-name"/>  fun getCustomer(id: Int): Customer<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>class CustomerServiceImpl(val accountService: AccountService) : CustomerService {<br class="title-page-name"/>  override fun getCustomer(id: Int): Customer {<br class="title-page-name"/>    val accounts = accountService.getAccountsByCustomer(id)<br class="title-page-name"/>    return Customer(id, "customer$id", accounts)<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we have to change our <kbd class="calibre11">CustomerController</kbd> and <kbd class="calibre11">ContextConfiguration</kbd> to refer to the interfaces:</p>
<pre class="calibre20">import org.springframework.context.annotation.Bean<br class="title-page-name"/>import org.springframework.context.annotation.Configuration<br class="title-page-name"/>import org.springframework.web.bind.annotation.*<br class="title-page-name"/><br class="title-page-name"/>@RestController<br class="title-page-name"/>class CustomerController(val customerService: CustomerService) {<br class="title-page-name"/>  @GetMapping("/customer/{id}")<br class="title-page-name"/>  fun getCustomer(@PathVariable id: Int) = customerService.getCustomer(1)<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>@Configuration<br class="title-page-name"/>class ContextConfiguration {<br class="title-page-name"/>  @Bean<br class="title-page-name"/>  fun accountService() : AccountService = AccountServiceImpl()<br class="title-page-name"/><br class="title-page-name"/>  @Bean<br class="title-page-name"/>  fun customerService(accountService: AccountService) : CustomerService =<br class="title-page-name"/>    CustomerServiceImpl(accountService)<br class="title-page-name"/><br class="title-page-name"/>  @Bean<br class="title-page-name"/>  fun customerController(customerService: CustomerService) = CustomerController(customerService)<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, if we need to change our implementation of the services, we only need to change our context configuration; the rest of the application will be unchanged. Another effect on this change is that now our services may not have any Spring dependent code, and this could be great as if tomorrow we need to move them to a different framework, we may do it seamlessly.</p>
<div class="packt_tip">Remember that avoiding coupling should be one of our principles when we create microservices, as it is in any software that we build.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Layering the application</h1>
                
            
            <article>
                
<p class="calibre2">When our application grows, it is going to be more complex to manage the large number of classes that we may end up with. And if we haven't taken care of our application structure, we may end in a situation that may not find the class that we need when we are looking for it.</p>
<p class="calibre2">In this section, we will propose a structure for layering our application and packaging the classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding our classes</h1>
                
            
            <article>
                
<p class="calibre2">Let's first look at our current classes in our project:</p>
<div class="mce-root4"><img src="../images/00070.gif" class="calibre78"/></div>
<div class="mce-root3">Current application structure</div>
<p class="calibre2">Currently, if we look at the preceding image of our classes to understand what domain they may refer to, we could divide them into two domains:</p>
<ul class="calibre7">
<li class="calibre8">Customer-related classes</li>
<li class="calibre8">Account-related classes</li>
</ul>
<p class="calibre2">But if we look at the same image to understand what our classes are, we can classify them into various groups:</p>
<ul class="calibre7">
<li class="calibre8">Application classes</li>
<li class="calibre8">Context configuration classes</li>
<li class="calibre8">Data classes</li>
<li class="calibre8">Services interfaces</li>
<li class="calibre8">Services implementation classes</li>
<li class="calibre8">Controllers classes</li>
</ul>
<p class="calibre2">Let's think how we can arrange them using those groups and domains.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Domains</h1>
                
            
            <article>
                
<p class="calibre2">We can create two domains and place our classes inside, and we already have an <kbd class="calibre11">application</kbd> package that we could use to store our application classes that don't belong to a particular domain:</p>
<div class="mce-root4"><img src="../images/00071.gif" class="calibre79"/></div>
<p class="calibre2">This does look better, however, we may not need to have a <kbd class="calibre11">domains</kbd> package, though it may be handy if we have more things to add to our structure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Splitting</h1>
                
            
            <article>
                
<p class="calibre2">Now, we could split them into the domain based on what they are used for:</p>
<div class="mce-root4"><img src="../images/00072.gif" class="calibre80"/></div>
<div class="mce-root3">final packages</div>
<p class="calibre2">We have created separate packages for:</p>
<ul class="calibre7">
<li class="calibre8"><kbd class="calibre11">model</kbd>: Our domain model objects such as our data classes</li>
<li class="calibre8"><kbd class="calibre11">services</kbd>: Our services with the business logic on that domain, we may want to split the implementation</li>
<li class="calibre8"><kbd class="calibre11">controllers</kbd>: Our controllers that expose our model and use the services</li>
</ul>
<p class="calibre2">Each of these packages could grow if there are more model, services, or controllers classes to add.</p>
<div class="packt_tip">Having our application layered in a way that we can understand is key for our microservice, however, no structure is perfect and you should decide which way you want to structure yours. It may differ from this structure, but remember that it is not only for you, anyone in your project should understand the used structure and if you are thinking about making your project or application <strong class="calibre22">Open Source Software</strong> (<strong class="calibre22">OSS</strong>), you may want to add this to your contributing documentation.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing effectively</h1>
                
            
            <article>
                
<p class="calibre2">Testing is one of the most important elements of modern software development, and you should take care of it right at the beginning when you start to design your microservice. In this section, we will try to guide you with some suggestions on how to effectively test your microservice, however, really understanding testing requires a deeper look that you should cover eventually.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding type of tests</h1>
                
            
            <article>
                
<p class="calibre2">There are several kinds of tests that you can carry out on microservices, but here are some of the most common ones that you should understand:</p>
<ul class="calibre7">
<li class="calibre8">Unit tests</li>
<li class="calibre8">Integration tests</li>
<li class="calibre8">E2E tests</li>
</ul>
<p class="calibre2">This is important to us because we should name our test according to what they are, either by naming the test class with the name of the type of test or classifying the package that refers to that type of test.</p>
<p class="calibre2">For example, if we have one Integration test for our controller that is named <kbd class="calibre11">CustomerControllerTest</kbd>, we could name it <kbd class="calibre11">CustomerControlIntegrationTest</kbd>, <kbd class="calibre11">CustomerControllerIT</kbd>, or leave it in the package <kbd class="calibre11">com.microservices.test.integration</kbd>.</p>
<div class="packt_tip">Classifying our test correctly allows us to easily understand <span class="calibre27">what kind of test it is</span> <span class="calibre27">when a test fails.</span></div>
<p class="calibre2">Let's review the different types of test so we have a clear understanding of how to name or place ours.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unit tests</h1>
                
            
            <article>
                
<p class="calibre2">They should focus on testing small units (typically a class or a complex algorithm). They should be tested in isolation and independent of other units. They should be fast, not more than a few seconds to provide immediate feedback. With these tests, we could refactor our code with confidence, making small changes and running the tests constantly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Integration tests</h1>
                
            
            <article>
                
<p class="calibre2">Integration tests test different components of our software to test if they work correctly in combination. Our classes may work in isolation, but they may fail when tested together.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">E2E tests</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre1">End-to-End</strong> (<strong class="calibre1">E2E</strong>) tests try to prove that each complete functionality works, from an end-user perspective. If we are running a microservice that exposes an API, we may test the different methods as we would do with an external application that was invoking us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Other tests</h1>
                
            
            <article>
                
<p class="calibre2">There are many other types of tests, but they maybe be a subcategorization of the previously defined types. Here are some examples:</p>
<ul class="calibre7">
<li class="calibre8"><strong class="calibre1">System test</strong>: An Integration test that tries to check if the integration with another system actually works</li>
<li class="calibre8"><strong class="calibre1">Acceptance or functional test</strong>: These are usually E2E tests that we use to validate that our software is working as the user specified</li>
<li class="calibre8"><strong class="calibre1">Smoke or sanity test</strong>: Usually an Integration or E2E test, created to verify that the most important parts of our application are still working before releasing the software</li>
<li class="calibre8"><strong class="calibre1">Security tests</strong>: Usually an E2E or Integration test that tries to prove how secure our software is</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Testing pyramid</h1>
                
            
            <article>
                
<p class="calibre2">When we test our microservices, we may choose to use a different kind of test, but many parts of the software could be tested in different kinds of tests. For example, when we create a customer, we may test this using a <strong class="calibre1">Unit</strong> test on the service that creates them, however, we could also test it using an <strong class="calibre1">Integration</strong> test or even an <strong class="calibre1">E2E</strong> test. It is a common understanding in the industry that we should approach testing using the test pyramid that indicates how many tests of each type we should have:</p>
<div class="mce-root4"><img src="../images/00073.jpeg" class="calibre81"/></div>
<div class="mce-root3">Test pyramid</div>
<p class="calibre2">The overall idea is that we should do as much testing as we can using a Unit test, this will provide more immediate feedback. Unit tests are easy to develop and maintain and we can go there with all different kinds of conditions and scenarios that our unit allows us. However, we may also need to test how our units are integrated, so we need an Integration test that only tests that integration, and all the logic that is already tested in the unit should be retested.</p>
<p class="calibre2">For example, if you do a Unit test for a service covering all the different business rules that return just a result of an error, in an Integration test, for a component that uses the service, you should only test that result or error from the service and not duplicate all the tests done previously in the Unit tests. Finally, we should carry out our E2E test covering the complete scenarios, not just those defined in our requirements, regardless of how they are implemented.</p>
<div class="packt_tip">The Google Testing blog suggests a 70/20/10 split: 70% Unit tests, 20% Integration tests, and 10% End-to-End tests, you may consider these numbers when doing testing for your microservices. Refer to the following site for more details: <a href="https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html" class="calibre31">https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Test Driven Development</h1>
                
            
            <article>
                
<p class="calibre2">We should try to do <strong class="calibre1">Test Driven Development</strong> (<strong class="calibre1">TDD</strong>) when we create our microservices. TDD will not only help us to ensure that our microservices are tested correctly, it will guide the design of our microservices to a better implementation. The overall idea for doing TDD is that you start writing a test first that will fail since there is no code for it yet, this test will be red. Then you move to implement just the minimum code to make the test pass, the test will be green. Then you refactor your code to improve it and rerun the test to check that it is working again, and if not, fix it. You then write another test, for example, to make another change in your code and repeat the cycle as before. These short cycles of red-green-refactor are what makes a TDD great.</p>
<p class="calibre2">For a microservice, you may start doing a test for a controller that may not exist, then implement the controller to return just the data, then you may create a test for a service that will do what the controller needs, and implement the service. Next, you could move to modify your controller and you would still have the test originally created to verify that everything works as defined.</p>
<p class="calibre2">Other great advantages of this are that whatever you need in your application, it will become apparent when you need it rather than creating a service (and related components) before they are required; this is a great way to do lean software development.</p>
<div class="packt_infobox">Unfortunately, we could not cover the full scope of TDD during this book, but we encourage you to find out more about it and try to bring this discipline when you write your own microservices. You could look at this small article from Martin Fowler's blog to get you started, <a href="https://martinfowler.com/bliki/TestDrivenDevelopment.html" class="calibre31">https://martinfowler.com/bliki/TestDrivenDevelopment.html</a>, but we really recommend that you read Kent Beck's book, <em class="calibre25">Test-Driven Development</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Behavior-Driven Development</h1>
                
            
            <article>
                
<p class="calibre2">You can also use <strong class="calibre1">Behavior-Driven Development</strong> (<strong class="calibre1">BDD</strong>) when you carry out tests on your microservices. BDD is a software development process that emerged from TDD, with ideas from domain-driven design and object-oriented analysis and design to provide software development and management teams with shared tools and a shared process to collaborate on software development.</p>
<p class="calibre2">The idea is that the requirements from your software are created by the team, including the domain experts defining how the application should behave. This is done using a behavioral specification that uses the ubiquitous language from our domain model.</p>
<p class="calibre2">This is an example of such a specification:</p>
<pre class="calibre20">Story: Get a customer from the API<br class="title-page-name"/><br class="title-page-name"/>As a user of the API<br class="title-page-name"/>In order to been able to get customers<br class="title-page-name"/>I want to query them<br class="title-page-name"/><br class="title-page-name"/>Scenario 1: Get a customer that does exist<br class="title-page-name"/>Given that I've the id from a customer<br class="title-page-name"/>and the customer exists<br class="title-page-name"/>When I query the customers API<br class="title-page-name"/>and I use the customer id<br class="title-page-name"/>Then I should get the customer details.<br class="title-page-name"/><br class="title-page-name"/>Scenario 2: Get a customer that does not exist<br class="title-page-name"/>Given that I've the id from a customer<br class="title-page-name"/>and the customer doest not exists<br class="title-page-name"/>When I query the customers API<br class="title-page-name"/>and I use the customer id<br class="title-page-name"/>Then I should get a not found response</pre>
<p class="calibre2">This describes our requirements that it will be written before we build our microservices, and since we will use our ubiquitous language, the whole team could work together defining the specification. Then, we can use tools such as <strong class="calibre1">Cucumber</strong> to literally read that specification and create a test that validates it. Finally, we can use TDD for the code that makes those test pass and do our red-green-refactor cycles. Making tests like this will be great as we will have tests that everyone can contribute to, including our domain experts and the team as a whole.</p>
<div class="packt_infobox">Cucumber–JVM provides an excellent framework for doing BDD tests, and since they run in the JVM, we could create them in Kotlin. Refer to the following website for more details: <a href="https://cucumber.io/docs/reference/jvm" class="calibre31">https://cucumber.io/docs/reference/jvm.</a></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Handling CI and CD</h1>
                
            
            <article>
                
<p class="calibre2">Adding Continuous Integration and Continuous Delivery to our microservice will allow us to deliver our application at the fastest pace with great quality and is something that we should look for when we create our microservices. In this section, we will discuss some practices that you should consider when doing Continuous Integration and Continuous Delivery.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Continuous Integration</h1>
                
            
            <article>
                
<p class="calibre2">Maintaining your software working is not always easy, especially when you have several developers working on the same code base. <strong class="calibre1">Continuous Integration</strong> (<strong class="calibre1">CI</strong>) allows us to minimize the problems when working with our software. The main idea behind CI is that every single time that we push code to our repository, our tests runs, and this allows us to know if the change that we just made has broken our application, even if what is broken was not actually in the code that was modified.</p>
<p class="calibre2">This minimizes the problems of integrating software in a code base if someone pushes a piece of software that is faulty, we can fix it and get it back working. And this is something that we should target to do all the time, as having a working software on our repository allows us to release as often as we can to get feedback, and feedback is what makes software better.</p>
<p class="calibre2">We may think that we shouldn't commit software until everything is ready, and that has been proved to be a painful approach which pushes dozen of changes to our code base to find out that it could not integrate with the rest. This is something that we should avoid. CI allows us to integrate the software while we are writing it, so we never end up in the situation where we have software completed that actually is not, because it is not working with the rest of our code base.</p>
<div class="packt_tip">Try to commit small, and try to commit often; this allows you to go back and fix things until they are integrated without too much effort.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Continuous Delivery</h1>
                
            
            <article>
                
<p class="calibre2">If we have CI working, we are only one step away from <strong class="calibre1">Continuous Delivery</strong> (<strong class="calibre1">CD</strong>), but sometimes that step is not a short step. However, we should always try to move in that direction regardless. We could have a working software in our integration environment, but if it takes weeks to be available at our end, we are not giving the users the value that our application should give.</p>
<p class="calibre2">In CD, we will try to automate the whole process to get our software from our code base into a live application, with all the steps that we could need. This could go from having our infrastructure created and configured, to our application being tested, deployed, or even verified and a range of things in-between, with the minimum, or non-manual intervention. The goal is simple from a developer pushing a change in our repository to getting the application live to end users.</p>
<div class="packt_tip">Nothing is really done until it is available to end users. This is how we give value to our applications, and we like to do it often, and for the best quality, we must do CD.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Pipeline</h1>
                
            
            <article>
                
<p class="calibre2">To do proper CI and CD, we need a pipeline tool that allows us to handle this process, something that enables us to pick up our changes, build our software, run the test, deploy the application, or any steps that we require in-between. And if something fails, our pipeline could notify us, so we can react and correct the problem.</p>
<p class="calibre2">There is a huge range of tools to do pipelines, but we recommend you look at tools such as Jenkins (probably the most popular tool), or others such as Concourse, Bamboo Gitlab CI, Travis CI, Drone, and many more.</p>
<div class="packt_tip">Do not just go to Jenkins because it is what everyone else does. There are many tools and many of them as good or even better than Jenkins; try some of them.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dashboard</h1>
                
            
            <article>
                
<p class="calibre2">Having a pipeline running is great, but if our build is not working, or our tests aren't running, we need to know about it and react. Most pipelines provide systems which give notifications, for example, sending emails or posting in programs like Slack, but most of them provide tools to create a dashboard as well.</p>
<p class="calibre2">A dashboard from a pipeline should visualize the different stages that we do, from building our software to launching our test or deployments, and usually are color coded with the standard work green, broken red. If we have a dashboard, we could just display it somewhere that the team could use to see if the pipeline is working and fix it where needed. Our pipeline dashboard could also be easily integrated with our application monitoring to have a centralized view of what is going on with our application.</p>
<div class="packt_tip">It is a whole team responsibility to fix broken builds, and we need to encourage them to understand why. It is in our application's best interest to have a pipeline working so that we can deliver often and with confidence to our end users.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2"><span>During the course of this book, we have covered what microservices are, and the benefits that they bring to our applications.</span> Now we can design them with the best principles in the industry that allow us to have an architecture that evolves as our products do. We learned how the Spring Framework could easily be integrated with Kotlin, providing excellent tools to build microservices. <span>During this process, we realized the advantages of using a modern programming language such as Kotlin to deliver high-quality software.</span> And remember that we have just started creating some RESTFul APIs that eventually can become reactive microservices used in a NoSQL database such as MongoDB with the best performance of non-blocking operations. Then, we learned how to create containers and clouds, and how we can scale our applications when required.</p>
<p class="calibre2">But we need software that gives us confidence, so we learned how our tests not only give a guarantee that our requirements are met, but they act as a live documentation that anyone in our team can use to understand our applications. And when our application reaches production, we can use what we have learned to have production-ready alerts and monitoring that could be used to control and manage our microservices, even in the worst scenarios. Finally, we learned how we can use industry best practices when creating microservices in Kotlin to provide the best value to our end users.</p>
<p class="calibre2"><span>At this point, you should be more than ready to start building your own microservices with Kotlin and the Spring Framework with the best techniques available to you.</span></p>


            </article>

            
        </section>
    </body></html>