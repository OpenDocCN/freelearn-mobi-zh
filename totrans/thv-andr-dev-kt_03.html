<html><head></head><body>
<div id="_idContainer024" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor037" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-38" class="calibre5"><a id="_idTextAnchor038" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Setting Up WhatsPackt’s Messaging Abilities</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In the previous chapter, we created the structure and UI needed for our messaging </span><span><span class="kobospan" id="kobo.4.1">app, WhatsPackt.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">One of the core features of any messaging app is the ability to facilitate 1:1 conversations between two users, so in this chapter, we will delve into the process of connecting our messaging app to a backend server using WebSockets, handling messages within </span><strong class="source-inline"><span class="kobospan" id="kobo.6.1">ViewModel</span></strong><span class="kobospan" id="kobo.7.1"> instances, and managing synchronization, error handling, and </span><span><span class="kobospan" id="kobo.8.1">push notifications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">We will begin </span><a id="_idIndexMarker126" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.10.1">by exploring </span><strong class="bold"><span class="kobospan" id="kobo.11.1">WebSockets</span></strong><span class="kobospan" id="kobo.12.1">, a powerful technology that enables bidirectional communication between client and server, providing a solid foundation for real-time messaging in your app. </span><span class="kobospan" id="kobo.12.2">You will learn how to establish a WebSocket connection, send messages, and handle incoming messages from </span><span><span class="kobospan" id="kobo.13.1">the server.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">Next, we will </span><a id="_idIndexMarker127" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.15.1">demonstrate how to receive messages in your </span><strong class="bold"><span class="kobospan" id="kobo.16.1">ViewModel</span></strong><span class="kobospan" id="kobo.17.1">. </span><span class="kobospan" id="kobo.17.2">We will discuss best practices for updating the UI, managing message storage, and handling user interactions, ensuring a smooth and responsive messaging experience for </span><span><span class="kobospan" id="kobo.18.1">your users.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.19.1">The chapter will also cover the essential aspects of synchronization and error handling. </span><span class="kobospan" id="kobo.19.2">You will learn how to manage message delivery status, handle intermittent connectivity issues, and gracefully recover from errors, resulting in a resilient and reliable </span><span><span class="kobospan" id="kobo.20.1">messaging system.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">Finally, we will dig into the topic of push notifications, which are vital for alerting users of new messages even when the app is not in </span><span><span class="kobospan" id="kobo.22.1">the foreground.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.23.1">By the end of this chapter, you will have gained a comprehensive understanding of the key components and technologies involved in creating a modern messaging app that supports 1:1 conversations using WebSockets and </span><span><span class="kobospan" id="kobo.24.1">push notifications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.25.1">So, in this chapter, we will cover the </span><span><span class="kobospan" id="kobo.26.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.27.1">Using a </span><span><span class="kobospan" id="kobo.28.1">WebSocket connection</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.29.1">Receiving messages in </span><span><span class="kobospan" id="kobo.30.1">our </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.31.1">ViewModel</span></strong></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.32.1">Handling synchronization </span><span><span class="kobospan" id="kobo.33.1">and errors</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.34.1">Adding </span><span><span class="kobospan" id="kobo.35.1">push notifications</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.36.1">Replacing the WebSocket </span><span><span class="kobospan" id="kobo.37.1">with Firestore</span></span></li>
</ul>
<h1 id="_idParaDest-39" class="calibre5"><a id="_idTextAnchor039" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.38.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">As in the previous chapter, you will need to have installed Android Studio (or another editor of </span><span><span class="kobospan" id="kobo.40.1">your preference).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">We are also going to assume that you followed along with the previous chapter. </span><span class="kobospan" id="kobo.41.2">If you haven’t, you can download the previous chapter’s complete code from </span><span><span class="kobospan" id="kobo.42.1">here: </span></span><a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.43.1">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt</span></span></a><span><span class="kobospan" id="kobo.44.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.45.1">The code completed in this chapter can also be found at this </span><span><span class="kobospan" id="kobo.46.1">link: </span></span><a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.47.1">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt</span></span></a><span><span class="kobospan" id="kobo.48.1">.</span></span></p>
<h1 id="_idParaDest-40" class="calibre5"><a id="_idTextAnchor040" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.49.1">Using a WebSocket connection</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.50.1">As mentioned, WebSockets is a powerful technology that enables bidirectional communication </span><a id="_idIndexMarker128" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.51.1">between client and server. </span><span class="kobospan" id="kobo.51.2">In this section, we are going to use a WebSocket connection to connect with our server to obtain and send messages. </span><span class="kobospan" id="kobo.51.3">But before we do that, it is essential to understand the alternatives and the rationale behind choosing WebSockets for our </span><span><span class="kobospan" id="kobo.52.1">messaging app.</span></span></p>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor041" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.53.1">Why WebSockets?</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">There are </span><a id="_idIndexMarker129" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.55.1">several options for enabling real-time communication between clients and servers, including </span><span><span class="kobospan" id="kobo.56.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.57.1">Long polling</span></strong><span class="kobospan" id="kobo.58.1">: This is when the client sends a request to the server, and the server holds the request until new data is available. </span><span class="kobospan" id="kobo.58.2">Once the server responds with the new data, the client sends another request, and the </span><span><span class="kobospan" id="kobo.59.1">process repeats.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.60.1">Server-Sent Events (SSE)</span></strong><span class="kobospan" id="kobo.61.1">: SSE is a unidirectional communication method where the server pushes updates to the client over a single </span><span><span class="kobospan" id="kobo.62.1">HTTP connection.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.63.1">Real-time cloud databases</span></strong><span class="kobospan" id="kobo.64.1"> (for example, Firebase Firestore): Real-time cloud databases </span><a id="_idIndexMarker130" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.65.1">provide an easy-to-use, scalable solution for real-time data synchronization. </span><span class="kobospan" id="kobo.65.2">They automatically push updates to clients whenever data changes, making them suitable for </span><span><span class="kobospan" id="kobo.66.1">messaging apps.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.67.1">WebSockets</span></strong><span class="kobospan" id="kobo.68.1">: WebSockets provide full-duplex, bidirectional communication between clients and servers over a single, long-lived connection. </span><span class="kobospan" id="kobo.68.2">They are widely supported across platforms and are an ideal choice for real-time communication in </span><span><span class="kobospan" id="kobo.69.1">messaging apps.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">Considering these alternatives, we choose to use WebSockets for our messaging app because they offer the </span><span><span class="kobospan" id="kobo.71.1">following advantages:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.72.1">Bidirectional communication</span></strong><span class="kobospan" id="kobo.73.1">: WebSockets enable simultaneous data transmission </span><a id="_idIndexMarker131" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.74.1">between clients and servers, allowing for faster message exchanges and a more responsive </span><span><span class="kobospan" id="kobo.75.1">user experience</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.76.1">Low latency</span></strong><span class="kobospan" id="kobo.77.1">: Unlike long polling, SSE, and some real-time cloud databases, WebSockets provide low-latency communication, which is crucial for a real-time </span><span><span class="kobospan" id="kobo.78.1">messaging app</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.79.1">Efficient use of resources</span></strong><span class="kobospan" id="kobo.80.1">: WebSockets maintain a single connection per client, reducing the overhead on both client and server compared to </span><span><span class="kobospan" id="kobo.81.1">long polling</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.82.1">Flexibility and control</span></strong><span class="kobospan" id="kobo.83.1">: Implementing custom WebSocket communication allows for more fine-grained control over the messaging infrastructure, avoiding potential limitations or constraints imposed by real-time </span><span><span class="kobospan" id="kobo.84.1">cloud databases</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.85.1">For sure, WebSockets also have their disadvantages that we must take into account, such as </span><span><span class="kobospan" id="kobo.86.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.87.1">Battery and data usage</span></strong><span class="kobospan" id="kobo.88.1">: Maintaining a persistent connection can lead to increased battery drain and data usage, which may be a concern for </span><span><span class="kobospan" id="kobo.89.1">mobile users.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.90.1">Complexity</span></strong><span class="kobospan" id="kobo.91.1">: Implementing WebSocket communication is typically more complex than </span><a id="_idIndexMarker132" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.92.1">using RESTful services. </span><span class="kobospan" id="kobo.92.2">You have to handle various scenarios such as reconnection on network changes, which are common in </span><span><span class="kobospan" id="kobo.93.1">mobile environments.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.94.1">Scalability</span></strong><span class="kobospan" id="kobo.95.1">: If your application scales to a large number of users, maintaining WebSocket connections for all of them can be resource-intensive on the </span><span><span class="kobospan" id="kobo.96.1">server side.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.97.1">Although there are some disadvantages, the advantages of using WebSockets — such as real-time bidirectional communication and lower overheads compared to traditional HTTP polling — significantly outweigh these issues, making them a powerful choice for </span><span><span class="kobospan" id="kobo.98.1">interactive applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">Let’s start learning how we can </span><span><span class="kobospan" id="kobo.100.1">integrate WebSockets.</span></span></p>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor042" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.101.1">Integrating WebSockets</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">There are </span><a id="_idIndexMarker133" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1">several libraries available for integrating WebSockets in Android applications. </span><span class="kobospan" id="kobo.103.2">Some popular options include </span><span><span class="kobospan" id="kobo.104.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.105.1">OkHttp</span></strong><span class="kobospan" id="kobo.106.1">: A popular HTTP client for Android and Java applications that also supports </span><span><span class="kobospan" id="kobo.107.1">WebSocket communication</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.108.1">Scarlet</span></strong><span class="kobospan" id="kobo.109.1">: A declarative WebSocket library for Kotlin and Java applications, built on top </span><span><span class="kobospan" id="kobo.110.1">of OkHttp</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.111.1">Ktor</span></strong><span class="kobospan" id="kobo.112.1">: A modern, Kotlin-based framework for building asynchronous servers and clients, including </span><span><span class="kobospan" id="kobo.113.1">WebSocket support</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.114.1">For our app, we will use Ktor due to its ease of use, native support for Kotlin, and </span><span><span class="kobospan" id="kobo.115.1">extensive documentation.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.116.1">What is Ktor?</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">Ktor stands out for its coroutine-based architecture, which allows for non-blocking asynchronous </span><a id="_idIndexMarker134" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.118.1">operations, making it particularly suitable for I/O-intensive tasks such as network communication. </span><span class="kobospan" id="kobo.118.2">It’s lightweight and modular, allowing developers to pick and choose only the features they need, thereby avoiding the overhead of </span><span><span class="kobospan" id="kobo.119.1">unnecessary functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">The framework </span><a id="_idIndexMarker135" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.121.1">is built on top of coroutines, a feature in Kotlin that makes your code cleaner and more readable, and simplifies asynchronous programming by allowing functions to be paused and resumed at later times. </span><span class="kobospan" id="kobo.121.2">This provides a powerful way to handle concurrency with a more straightforward and expressive syntax compared to traditional </span><span><span class="kobospan" id="kobo.122.1">callback mechanisms.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.123.1">Ktor is versatile, supporting both server-side and client-side development. </span><span class="kobospan" id="kobo.123.2">On the server side, it can be used to build robust and scalable web applications and services. </span><span class="kobospan" id="kobo.123.3">On the client side, it provides a multiplatform HTTP client that can be used on Android, allowing for seamless interaction with </span><span><span class="kobospan" id="kobo.124.1">web services.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.125.1">Ktor’s WebSocket </span><a id="_idIndexMarker136" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.126.1">client allows for easy setup and management of WebSocket connections, handling complexities such as connection lifecycle, error handling, and message processing. </span><span class="kobospan" id="kobo.126.2">Its </span><strong class="bold"><span class="kobospan" id="kobo.127.1">domain-specific language</span></strong><span class="kobospan" id="kobo.128.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.129.1">DSL</span></strong><span class="kobospan" id="kobo.130.1">) provides a concise and expressive way to define the behavior of WebSocket interactions, making the code more readable </span><span><span class="kobospan" id="kobo.131.1">and maintainable.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.132.1">Integrating WebSockets with Ktor</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.133.1">To integrate </span><a id="_idIndexMarker137" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.134.1">Ktor in our Android app, follow </span><span><span class="kobospan" id="kobo.135.1">these steps:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.136.1">In our </span><a id="_idIndexMarker138" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.137.1">app’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.138.1">build.gradle</span></strong><span class="kobospan" id="kobo.139.1"> file of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.140.1">:feature:chat</span></strong><span class="kobospan" id="kobo.141.1"> module, add the following Ktor dependencies for the WebSocket client. </span><span class="kobospan" id="kobo.141.2">Make sure to replace </span><strong class="source-inline1"><span class="kobospan" id="kobo.142.1">$ktor_version</span></strong><span class="kobospan" id="kobo.143.1"> with the latest version available (for the examples in this book, we are using </span><span><span class="kobospan" id="kobo.144.1">version 2.2.4):</span></span><pre class="source-code"><span class="kobospan1" id="kobo.145.1">
dependencies {
    implementation "io.ktor:ktor-client-
        websockets:2.2.4"
    implementation "io.ktor:ktor-client-okhttp:2.2.4"
}</span></pre><p class="calibre3"><span class="kobospan" id="kobo.146.1">Each dependency serves a </span><span><span class="kobospan" id="kobo.147.1">distinct purpose:</span></span></p><ul class="calibre16"><li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.148.1">io.ktor:ktor-client-websockets</span></strong><span class="kobospan" id="kobo.149.1">: This dependency provides the necessary functionality to manage WebSocket connections in our application. </span><span class="kobospan" id="kobo.149.2">It includes high-level abstractions for opening, sending messages to, and receiving messages from WebSocket servers, facilitating real-time data exchange in a seamless manner. </span><span class="kobospan" id="kobo.149.3">By using this library, we can easily implement WebSocket communication without handling the complex underlying protocols and </span><span><span class="kobospan" id="kobo.150.1">handshakes manually.</span></span></li><li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.151.1">io.ktor:ktor-client-okhttp</span></strong><span class="kobospan" id="kobo.152.1">: While Ktor is a multiplatform framework, it requires an engine to handle network requests. </span><span class="kobospan" id="kobo.152.2">This dependency integrates OkHttp as the underlying engine for handling HTTP requests and responses in Android applications. </span><span class="kobospan" id="kobo.152.3">OkHttp supports WebSockets along with its robust HTTP client features, providing efficient network operations, connection pooling, and a powerful interface for making and </span><span><span class="kobospan" id="kobo.153.1">intercepting requests.</span></span></li></ul><p class="calibre3"><span class="kobospan" id="kobo.154.1">Together, these </span><a id="_idIndexMarker139" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.155.1">dependencies allow our app to </span><a id="_idIndexMarker140" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.156.1">utilize WebSockets for real-time communication and leverage OkHttp’s efficient networking capabilities. </span><span class="kobospan" id="kobo.156.2">This combination is particularly powerful for applications needing to maintain persistent connections and manage high-frequency data exchange, such as messaging apps or live </span><span><span class="kobospan" id="kobo.157.1">data feeds.</span></span></p></li> <li class="calibre14"><span class="kobospan" id="kobo.158.1">In your </span><strong class="source-inline1"><span class="kobospan" id="kobo.159.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.160.1"> file, add the required permission to access the internet as we will need it to connect our WebSocket and </span><span><span class="kobospan" id="kobo.161.1">receive/send messages:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.162.1">
&lt;uses-permission android:name=
    "android.permission.INTERNET" /&gt;</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.163.1">We now have the library included in our project. </span><span class="kobospan" id="kobo.163.2">As we will be using Ktor with Kotlin Flow, let’s introduce it before diving into our </span><span><span class="kobospan" id="kobo.164.1">WebSocket implementation.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.165.1">Getting to know Kotlin Flow</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.166.1">Flow is part of Kotlin’s coroutines library, and it’s a type that can emit multiple values sequentially, as opposed to suspend functions that return only a single value. </span><span class="kobospan" id="kobo.166.2">Flow builds upon </span><a id="_idIndexMarker141" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.167.1">the foundational concepts of coroutines to offer a declarative way to work with asynchronous streams </span><span><span class="kobospan" id="kobo.168.1">of data.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.169.1">Unlike sequences in Kotlin, which are synchronous and blocking, Flow is asynchronous and non-blocking. </span><span class="kobospan" id="kobo.169.2">This makes Flow ideal for handling a continuous stream of data that can be observed </span><a id="_idIndexMarker142" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.170.1">and collected asynchronously, such as real-time messages from </span><span><span class="kobospan" id="kobo.171.1">a WebSocket.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.172.1">When integrating Flow with Ktor WebSockets, we can create a powerful combination where the WebSocket messages are emitted as a stream of data that can be processed using all the Flow operators. </span><span class="kobospan" id="kobo.172.2">It allows for a clean, reactive-style approach to handling incoming and outgoing messages </span><span><span class="kobospan" id="kobo.173.1">with WebSockets.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">For example, in a chat application, incoming messages from a WebSocket can be represented as a flow of strings. </span><span class="kobospan" id="kobo.174.2">The app can collect this flow to update the UI accordingly. </span><span class="kobospan" id="kobo.174.3">Similarly, user actions that generate outgoing messages can be collected and sent through the </span><span><span class="kobospan" id="kobo.175.1">WebSocket connection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.176.1">The Flow API is really simple and easy to use. </span><span class="kobospan" id="kobo.176.2">As another example, imagine that we have a flow that emits </span><span><span class="kobospan" id="kobo.177.1">three strings:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.178.1">
fun main() = runBlocking {
    // Define a simple flow that emits three strings
    val helloFlow = flow {
        emit("Hello")
        emit("from")
        emit("Flow!")
    }
    // Collect and print each value emitted by the flow
    helloFlow.collect { value -&gt;
        println(value)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.179.1">In this code </span><a id="_idIndexMarker143" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.180.1">block, </span><strong class="source-inline"><span class="kobospan" id="kobo.181.1">helloFlow</span></strong><span class="kobospan" id="kobo.182.1"> is defined, using the </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">flow</span></strong><span class="kobospan" id="kobo.184.1"> builder to emit three </span><a id="_idIndexMarker144" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.185.1">strings one </span><span><span class="kobospan" id="kobo.186.1">after another.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.187.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.188.1">There are several other builders apart from </span><strong class="source-inline1"><span class="kobospan" id="kobo.189.1">flow</span></strong><span class="kobospan" id="kobo.190.1">, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.191.1">flowOf</span></strong><span class="kobospan" id="kobo.192.1">, which creates a flow from a set of values, or </span><strong class="source-inline1"><span class="kobospan" id="kobo.193.1">toFlow()</span></strong><span class="kobospan" id="kobo.194.1">, which creates a flow from </span><span><span class="kobospan" id="kobo.195.1">a collection.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.196.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">collect()</span></strong><span class="kobospan" id="kobo.198.1"> function is </span><a id="_idIndexMarker145" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.199.1">then called on </span><strong class="source-inline"><span class="kobospan" id="kobo.200.1">helloFlow</span></strong><span class="kobospan" id="kobo.201.1">. </span><span class="kobospan" id="kobo.201.2">It acts as a subscriber that reacts to each emitted value by </span><span><span class="kobospan" id="kobo.202.1">printing it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">If you run this code, you should see the </span><span><span class="kobospan" id="kobo.204.1">following output:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.205.1">
Hello
from
Flow!</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.206.1">Now that we are a bit familiar with Kotlin Flow, we are ready to do the next step: build our implementation of a WebSocket using Ktor and Flow. </span><span class="kobospan" id="kobo.206.2">As it is going to be one of the data sources that will provide messages to our app, we will call </span><span><span class="kobospan" id="kobo.207.1">it </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.208.1">WebsocketDataSource</span></strong></span><span><span class="kobospan" id="kobo.209.1">.</span></span></p>
<h2 id="_idParaDest-43" class="calibre7"><a id="_idTextAnchor043" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.210.1">Implementing WebSocketDataSource</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">To implement </span><a id="_idIndexMarker146" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.212.1">the WebSocket data source, we are first going to create an </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">HttpClient</span></strong><span class="kobospan" id="kobo.214.1"> instance. </span><strong class="source-inline"><span class="kobospan" id="kobo.215.1">HttpClient</span></strong><span class="kobospan" id="kobo.216.1"> is a Ktor class that allows you to make HTTP requests and manage network connections. </span><span class="kobospan" id="kobo.216.2">In the case of WebSockets, it is responsible for establishing and maintaining the connection between the client </span><span><span class="kobospan" id="kobo.217.1">and server.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.218.1">To create an </span><strong class="source-inline"><span class="kobospan" id="kobo.219.1">HttpClient</span></strong><span class="kobospan" id="kobo.220.1"> instance with WebSocket support, we are going to create a new file called </span><strong class="source-inline"><span class="kobospan" id="kobo.221.1">WebSocketClient</span></strong><span class="kobospan" id="kobo.222.1"> in the </span><strong class="source-inline"><span class="kobospan" id="kobo.223.1">feature.chat.data.network</span></strong><span class="kobospan" id="kobo.224.1"> package (you will need to create the data and network packages as they don’t exist yet) and include the </span><span><span class="kobospan" id="kobo.225.1">following code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.226.1">
object WebsocketClient {
    val client = HttpClient(OkHttp) {
        install(WebSockets)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.227.1">Here, we’re </span><a id="_idIndexMarker147" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.228.1">using the </span><strong class="source-inline"><span class="kobospan" id="kobo.229.1">OkHttp</span></strong><span class="kobospan" id="kobo.230.1"> engine to create an </span><strong class="source-inline"><span class="kobospan" id="kobo.231.1">HttpClient</span></strong><span class="kobospan" id="kobo.232.1"> instance, and then we’re installing the </span><strong class="source-inline"><span class="kobospan" id="kobo.233.1">WebSockets</span></strong><span class="kobospan" id="kobo.234.1"> plugin to enable </span><span><span class="kobospan" id="kobo.235.1">WebSocket support.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.236.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.237.1">In Ktor, </span><strong class="bold"><span class="kobospan" id="kobo.238.1">plugins</span></strong><span class="kobospan" id="kobo.239.1"> (also called features) are modular components that extend the functionality </span><a id="_idIndexMarker148" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.240.1">of Ktor applications. </span><span class="kobospan" id="kobo.240.2">Plugins can be installed on both the client and server sides to provide additional features, such as authentication, logging, serialization, or custom </span><a id="_idIndexMarker149" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.241.1">behavior. </span><span class="kobospan" id="kobo.241.2">Ktor’s plugin-based architecture encourages a lightweight and modular approach, allowing you to include only the necessary components in </span><span><span class="kobospan" id="kobo.242.1">your application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.243.1">Then, we will create our </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.245.1"> class (in the </span><span><span class="kobospan" id="kobo.246.1">same package).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.247.1">To start creating our WebSocket, we will need a </span><strong class="source-inline"><span class="kobospan" id="kobo.248.1">WebSocketSession</span></strong><span class="kobospan" id="kobo.249.1"> instance. </span><strong class="source-inline"><span class="kobospan" id="kobo.250.1">WebSocketSession</span></strong><span class="kobospan" id="kobo.251.1"> represents a single WebSocket connection between the client and server, providing methods for sending and receiving messages, as well as managing the connection’s lifecycle. </span><span class="kobospan" id="kobo.251.2">In our implementation, we will create a </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">WebSocketSession</span></strong><span class="kobospan" id="kobo.253.1"> instance when we call the </span><strong class="source-inline"><span class="kobospan" id="kobo.254.1">connect()</span></strong><span class="kobospan" id="kobo.255.1"> method, </span><span><span class="kobospan" id="kobo.256.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.257.1">
class MessagesSocketDataSource @Inject constructor(
    private val httpClient: HttpClient,
) {
    private lateinit var webSocketSession:
        DefaultClientWebSocketSession
    suspend fun connect(url: String): Flow&lt;Message&gt;{
        return httpClient.webSocketSession { url(url) }
            .apply { webSocketSession = this }
            .incoming
            .receiveAsFlow()
            .map{ frame -&gt;
                webSocketSession.handleMessage(frame) }
            .filterNotNull()
            .map { it.toDomain() }
    }
//...
</span><span class="kobospan1" id="kobo.257.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.258.1">Let’s </span><a id="_idIndexMarker150" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.259.1">break down what this code is going </span><span><span class="kobospan" id="kobo.260.1">to do:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.261.1">suspend fun connect(url: String): Flow&lt;Message&gt;</span></strong><span class="kobospan" id="kobo.262.1">: The </span><strong class="source-inline1"><span class="kobospan" id="kobo.263.1">connect</span></strong><span class="kobospan" id="kobo.264.1"> function is defined as a suspending (</span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">suspend</span></strong><span class="kobospan" id="kobo.266.1">) function that takes a </span><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">url</span></strong><span class="kobospan" id="kobo.268.1"> parameter of type </span><strong class="source-inline1"><span class="kobospan" id="kobo.269.1">String</span></strong><span class="kobospan" id="kobo.270.1"> and returns a </span><strong class="source-inline1"><span class="kobospan" id="kobo.271.1">Flow&lt;Message&gt;</span></strong><span class="kobospan" id="kobo.272.1"> instance. </span><strong class="source-inline1"><span class="kobospan" id="kobo.273.1">Flow</span></strong><span class="kobospan" id="kobo.274.1"> is a cold asynchronous stream used for processing data in a reactive way in Kotlin (a cold stream is one that will only emit messages when there is a </span><span><span class="kobospan" id="kobo.275.1">consumer connected).</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.276.1">httpClient.webSocketSession { url(url) }</span></strong><span class="kobospan" id="kobo.277.1">: This line uses </span><strong class="source-inline1"><span class="kobospan" id="kobo.278.1">httpClient</span></strong><span class="kobospan" id="kobo.279.1"> to create a WebSocket session by calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.280.1">webSocketSession</span></strong><span class="kobospan" id="kobo.281.1"> function and passing a lambda that sets the session’s URL to the </span><span><span class="kobospan" id="kobo.282.1">provided URL.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.283.1">.apply { webSocketSession = this }</span></strong><span class="kobospan" id="kobo.284.1">: This line stores the newly created WebSocket session using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">apply</span></strong><span class="kobospan" id="kobo.286.1"> function in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">webSocketSession</span></strong><span class="kobospan" id="kobo.288.1"> property. </span><span class="kobospan" id="kobo.288.2">We also need to store it as we will need the session later for </span><span><span class="kobospan" id="kobo.289.1">sending messages.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.290.1">.incoming</span></strong><span class="kobospan" id="kobo.291.1">: This line accesses the incoming property of </span><strong class="source-inline1"><span class="kobospan" id="kobo.292.1">webSocketSession</span></strong><span class="kobospan" id="kobo.293.1">. </span><span class="kobospan" id="kobo.293.2">The incoming property is a channel that receives incoming </span><strong class="source-inline1"><span class="kobospan" id="kobo.294.1">Frame</span></strong><span class="kobospan" id="kobo.295.1"> objects from the </span><span><span class="kobospan" id="kobo.296.1">WebSocket server.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.297.1">.receiveAsFlow()</span></strong><span class="kobospan" id="kobo.298.1">: This line converts the incoming channel to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.299.1">Flow&lt;Frame&gt;</span></strong><span class="kobospan" id="kobo.300.1"> instance so that it can be processed using the </span><span><span class="kobospan" id="kobo.301.1">Flow API.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.302.1">.map { frame -&gt; webSocketSession.handleMessage(frame) }</span></strong><span class="kobospan" id="kobo.303.1">: This line </span><a id="_idIndexMarker151" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.304.1">maps each incoming </span><strong class="source-inline1"><span class="kobospan" id="kobo.305.1">Frame</span></strong><span class="kobospan" id="kobo.306.1"> object to the result of calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.307.1">handleMessage</span></strong><span class="kobospan" id="kobo.308.1"> function. </span><span class="kobospan" id="kobo.308.2">We will define the </span><strong class="source-inline1"><span class="kobospan" id="kobo.309.1">handleMessage</span></strong> <span><span class="kobospan" id="kobo.310.1">function later.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.311.1">.filterNotNull</span></strong><strong class="source-inline1"><span class="kobospan" id="kobo.312.1">()</span></strong><span class="kobospan" id="kobo.313.1">: This line filters out any </span><strong class="source-inline1"><span class="kobospan" id="kobo.314.1">null</span></strong><span class="kobospan" id="kobo.315.1"> values from the stream, ensuring that only non-</span><strong class="source-inline1"><span class="kobospan" id="kobo.316.1">null</span></strong><span class="kobospan" id="kobo.317.1"> values are </span><span><span class="kobospan" id="kobo.318.1">processed further.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.319.1">.map { it.toDomain() }</span></strong><span class="kobospan" id="kobo.320.1">: This line maps each non-</span><strong class="source-inline1"><span class="kobospan" id="kobo.321.1">null</span></strong><span class="kobospan" id="kobo.322.1"> value to the result of calling the </span><strong class="source-inline1"><span class="kobospan" id="kobo.323.1">toDomain()</span></strong><span class="kobospan" id="kobo.324.1"> function. </span><span class="kobospan" id="kobo.324.2">This function will map the current data-related object to the domain </span><strong class="source-inline1"><span class="kobospan" id="kobo.325.1">Message</span></strong><span class="kobospan" id="kobo.326.1"> model that we will </span><span><span class="kobospan" id="kobo.327.1">create soon.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.328.1">Before processing and handling the messages, we will also want to add two more functions to our WebSocket </span><span><span class="kobospan" id="kobo.329.1">data source:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.330.1">We want one function to send messages, as we want our users to be able to send messages to their </span><span><span class="kobospan" id="kobo.331.1">WhatsPackt friends</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.332.1">We want another function to disconnect the WebSocket, as we should disconnect it from the server when it is not </span><span><span class="kobospan" id="kobo.333.1">in use</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.334.1">We can add these </span><span><span class="kobospan" id="kobo.335.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.336.1">
suspend fun sendMessage(message: String) {
    webSocketSession.send(Frame.Text(message))
}
suspend fun disconnect() {
    webSocketSession.close(CloseReason(
        CloseReason.Codes.NORMAL, "Disconnect"))
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.337.1">When a WebSocket connection is closed, it’s accompanied by a </span><strong class="source-inline"><span class="kobospan" id="kobo.338.1">CloseReason</span></strong><span class="kobospan" id="kobo.339.1"> class, which contains </span><a id="_idIndexMarker152" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.340.1">a code and an optional descriptive text. </span><span class="kobospan" id="kobo.340.2">The code indicates the reason for the connection closure, such as normal closure, protocol error, or unsupported data. </span><span class="kobospan" id="kobo.340.3">In our implementation, we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.341.1">CloseReason</span></strong><span class="kobospan" id="kobo.342.1"> class to close the </span><strong class="source-inline"><span class="kobospan" id="kobo.343.1">WebSocketSession</span></strong><span class="kobospan" id="kobo.344.1"> with a </span><span><span class="kobospan" id="kobo.345.1">normal closure.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.346.1">Some common </span><strong class="source-inline"><span class="kobospan" id="kobo.347.1">CloseReason</span></strong><span class="kobospan" id="kobo.348.1"> codes include </span><span><span class="kobospan" id="kobo.349.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.350.1">CloseReason.Codes.NORMAL</span></strong><span class="kobospan" id="kobo.351.1">: Indicates a normal closure of the connection. </span><span class="kobospan" id="kobo.351.2">This is the reason that will be provided when the user is no longer using the </span><span><span class="kobospan" id="kobo.352.1">chat screen.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.353.1">CloseReason.Codes.GOING_AWAY</span></strong><span class="kobospan" id="kobo.354.1">: Indicates that the server is going away or </span><span><span class="kobospan" id="kobo.355.1">shutting down.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.356.1">CloseReason.Codes.PROTOCOL_ERROR</span></strong><span class="kobospan" id="kobo.357.1">: Indicates that an error in the WebSocket </span><span><span class="kobospan" id="kobo.358.1">protocol occurred.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.359.1">CloseReason.Codes.UNSUPPORTED_DATA</span></strong><span class="kobospan" id="kobo.360.1">: Indicates that the received data type is </span><span><span class="kobospan" id="kobo.361.1">not supported.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.362.1">Now that we know how to close our WebSocket connection, we need to define the </span><strong class="source-inline"><span class="kobospan" id="kobo.363.1">handleMessages</span></strong><span class="kobospan" id="kobo.364.1"> extension function to process all the messages while the connection </span><span><span class="kobospan" id="kobo.365.1">is alive:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.366.1">
private suspend fun
DefaultClientWebSocketSession.handleMessage(frame: Frame):
WebsocketMessageModel? </span><span class="kobospan1" id="kobo.366.2">{
    return when (frame) {
        is Frame.Text -&gt; converter?.deserialize(frame)
        is Frame.Close -&gt; {
            disconnect()
            null
        }
        else -&gt; null
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.367.1">In the WebSocket protocol, data is transmitted in discrete units called frames. </span><span class="kobospan" id="kobo.367.2">Ktor provides a </span><strong class="source-inline"><span class="kobospan" id="kobo.368.1">Frame</span></strong><span class="kobospan" id="kobo.369.1"> class to represent these units, with different subclasses for each frame type, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.370.1">Frame.Text</span></strong><span class="kobospan" id="kobo.371.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.372.1">Frame.Binary</span></strong><span class="kobospan" id="kobo.373.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.374.1">Frame.Ping</span></strong><span class="kobospan" id="kobo.375.1">, </span><span><span class="kobospan" id="kobo.376.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.377.1">Frame.Close</span></strong></span><span><span class="kobospan" id="kobo.378.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.379.1">In our case, we are only processing </span><strong class="source-inline"><span class="kobospan" id="kobo.380.1">Frame.Text</span></strong><span class="kobospan" id="kobo.381.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.382.1">Frame.Close</span></strong><span class="kobospan" id="kobo.383.1"> messages. </span><span class="kobospan" id="kobo.383.2">To receive a </span><strong class="source-inline"><span class="kobospan" id="kobo.384.1">Frame.Close</span></strong><span class="kobospan" id="kobo.385.1"> message, we will close the WebSocket (for now – in the future, maybe we would want to do a retry here or give feedback about the problem to the user). </span><span class="kobospan" id="kobo.385.2">Then, to receive the </span><strong class="source-inline"><span class="kobospan" id="kobo.386.1">Frame.Text</span></strong><span class="kobospan" id="kobo.387.1"> messages, we are going to </span><strong class="bold"><span class="kobospan" id="kobo.388.1">deserialize</span></strong><span class="kobospan" id="kobo.389.1"> them from JSON (a lightweight data-interchange format that is commonly used for communication between systems) to the object we are going to work with. </span><span class="kobospan" id="kobo.389.2">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.390.1">deserialize</span></strong><span class="kobospan" id="kobo.391.1"> just describes </span><span><span class="kobospan" id="kobo.392.1">this conversion.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.393.1">We can configure </span><a id="_idIndexMarker153" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.394.1">a converter in our WebSocket that allows us to easily deserialize our messages. </span><span class="kobospan" id="kobo.394.2">First, we need to add new dependencies to our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.395.1">build.gradle</span></strong></span><span><span class="kobospan" id="kobo.396.1"> file:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.397.1">
implementation("io.ktor:ktor-serialization-kotlinx-json:2.2.4)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.398.1">Then, we are ready to set </span><strong class="source-inline"><span class="kobospan" id="kobo.399.1">contentConverter</span></strong><span class="kobospan" id="kobo.400.1"> in our </span><span><span class="kobospan" id="kobo.401.1">WebSocket plugin:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.402.1">
object WebsocketClient {
    val client = HttpClient(OkHttp) {
        install(WebSockets) {
            contentConverter =
               KotlinxWebsocketSerializationConverter(Json)
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.403.1">In this case, we are configuring the </span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">kotlinx.serialization</span></strong><span class="kobospan" id="kobo.405.1"> converter for the JSON format (there are also converters available for other standards, such as XML, Protobuf, </span><span><span class="kobospan" id="kobo.406.1">and CBOR).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.407.1">In addition, we must add the </span><strong class="source-inline"><span class="kobospan" id="kobo.408.1">@Serializable</span></strong><span class="kobospan" id="kobo.409.1"> annotation to those data classes that we want </span><a id="_idIndexMarker154" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.410.1">to be deserialized by the converter. </span><span class="kobospan" id="kobo.410.2">In our case, we will create a </span><strong class="source-inline"><span class="kobospan" id="kobo.411.1">WebsocketMessageModel</span></strong><span class="kobospan" id="kobo.412.1"> class </span><span><span class="kobospan" id="kobo.413.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.414.1">
@Serializable
class WebsocketMessageModel(
    val id: String,
    val message: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val messageType: String,
    val messageDescription: String
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.415.1">The last step in our flow chain is to convert the </span><strong class="source-inline"><span class="kobospan" id="kobo.416.1">WebsocketMessageModel</span></strong><span class="kobospan" id="kobo.417.1"> class to a domain. </span><span class="kobospan" id="kobo.417.2">As we still don’t have a domain model, we should create </span><span><span class="kobospan" id="kobo.418.1">it first:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.419.1">
data class Message(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val contentType: ContentType,
    val content: String,
    val contentDescription: String
) {
    enum class ContentType {
        TEXT, IMAGE
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.420.1">Now, we can </span><a id="_idIndexMarker155" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.421.1">implement the mapper as a function of the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.422.1">WebsocketMessageModel</span></strong></span><span><span class="kobospan" id="kobo.423.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.424.1">
@Serializable
class WebsocketMessageModel(
    val id: String,
    val message: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val messageType: String,
    val messageDescription: String
) {
    companion object {
        const val TYPE_TEXT = "TEXT"
        const val TYPE_IMAGE = "IMAGE"
    }
    fun toDomain(): Message {
        return Message(
            id = id,
            content = message,
            senderAvatar = senderAvatar,
            senderName = senderName,
            timestamp = timestamp,
            isMine = isMine,
            contentDescription = messageDescription,
            contentType = toContentType()
        )
    }
    fun toContentType(): Message.ContentType {
        return when(messageType) {
            TYPE_IMAGE -&gt; Message.ContentType.IMAGE
            else -&gt; Message.ContentType.TEXT
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.425.1">Here, we are </span><a id="_idIndexMarker156" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.426.1">adding the </span><strong class="source-inline"><span class="kobospan" id="kobo.427.1">toDomain()</span></strong><span class="kobospan" id="kobo.428.1"> function that maps the current </span><strong class="source-inline"><span class="kobospan" id="kobo.429.1">WebsocketMessageModel</span></strong><span class="kobospan" id="kobo.430.1"> class to the </span><strong class="source-inline"><span class="kobospan" id="kobo.431.1">Message</span></strong><span class="kobospan" id="kobo.432.1"> model. </span><span class="kobospan" id="kobo.432.2">Note that almost all fields in the data model are similar to those in our domain </span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">Message</span></strong><span class="kobospan" id="kobo.434.1"> model. </span><span class="kobospan" id="kobo.434.2">The key exception is the </span><strong class="source-inline"><span class="kobospan" id="kobo.435.1">messageType</span></strong><span class="kobospan" id="kobo.436.1"> field, which we must convert to the enum we are using in the domain </span><strong class="source-inline"><span class="kobospan" id="kobo.437.1">Message</span></strong><span class="kobospan" id="kobo.438.1"> model. </span><span class="kobospan" id="kobo.438.2">To simplify this conversion, we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">toContentType()</span></strong><span class="kobospan" id="kobo.440.1"> function, which specifically transforms </span><strong class="source-inline"><span class="kobospan" id="kobo.441.1">messageType</span></strong><span class="kobospan" id="kobo.442.1"> from a </span><strong class="source-inline"><span class="kobospan" id="kobo.443.1">String</span></strong><span class="kobospan" id="kobo.444.1"> object to a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.445.1">ContentType</span></strong></span><span><span class="kobospan" id="kobo.446.1"> enum.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.447.1">We also </span><a id="_idIndexMarker157" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.448.1">would need to convert the domain </span><strong class="source-inline"><span class="kobospan" id="kobo.449.1">Message</span></strong><span class="kobospan" id="kobo.450.1"> object to the </span><strong class="source-inline"><span class="kobospan" id="kobo.451.1">WebsocketMessageModel</span></strong><span class="kobospan" id="kobo.452.1"> class. </span><span class="kobospan" id="kobo.452.2">To do that, we need to add a new function to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.453.1">WebsocketMessageModel</span></strong></span><span><span class="kobospan" id="kobo.454.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.455.1">
companion object {
    const val TYPE_TEXT = "TEXT"
    const val TYPE_IMAGE = "IMAGE"
    fun fromDomain(message: Message): WebsocketMessageModel {
        return WebsocketMessageModel(
            id = message.id,
            message = message.content,
            senderAvatar = message.senderAvatar,
            senderName = message.senderName,
            timestamp = message.timestamp,
            isMine = message.isMine,
            messageType = message.fromContentType(),
            messageDescription = message.contentDescription
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.456.1">Here, we are converting the </span><strong class="source-inline"><span class="kobospan" id="kobo.457.1">Message</span></strong><span class="kobospan" id="kobo.458.1"> domain object into a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.459.1">WebsocketMessageModel</span></strong></span><span><span class="kobospan" id="kobo.460.1"> class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.461.1">Then, in the </span><strong class="source-inline"><span class="kobospan" id="kobo.462.1">send</span></strong><span class="kobospan" id="kobo.463.1"> function, we will proceed </span><span><span class="kobospan" id="kobo.464.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.465.1">
suspend fun sendMessage(message: Message) {
    val websocketMessage =
        WebsocketMessageModel.fromDomain(message)
    webSocketSession.converter?
</span><span class="kobospan1" id="kobo.465.2">        .serialize(websocketMessage)?.let
    {
        webSocketSession.send(it)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.466.1">With these </span><a id="_idIndexMarker158" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.467.1">changes to the </span><strong class="source-inline"><span class="kobospan" id="kobo.468.1">sendMessage</span></strong><span class="kobospan" id="kobo.469.1"> function, we are now receiving a domain model object, converting it to </span><strong class="source-inline"><span class="kobospan" id="kobo.470.1">WebsocketMessageModel</span></strong><span class="kobospan" id="kobo.471.1">, and finally serializing it into a </span><strong class="source-inline"><span class="kobospan" id="kobo.472.1">Frame</span></strong><span class="kobospan" id="kobo.473.1"> object and sending it through </span><span><span class="kobospan" id="kobo.474.1">our WebSocket.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.475.1">The next step is to connect this component (</span><strong class="source-inline"><span class="kobospan" id="kobo.476.1">MessagesWebsocketDataSource</span></strong><span class="kobospan" id="kobo.477.1">) with </span><strong class="source-inline"><span class="kobospan" id="kobo.478.1">ViewModel</span></strong><span class="kobospan" id="kobo.479.1">, which will be responsible for providing the view state to the view so that it can </span><span><span class="kobospan" id="kobo.480.1">render accordingly.</span></span></p>
<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor044" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.481.1">Receiving messages in our ViewModel</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.482.1">Our app is ready to receive and send messages using a WebSocket. </span><span class="kobospan" id="kobo.482.2">Now, we need to make them </span><a id="_idIndexMarker159" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.483.1">reach the UI we created in the previous chapter. </span><span class="kobospan" id="kobo.483.2">We will do that in this section, but first, we need to think about the architecture and components needed to </span><span><span class="kobospan" id="kobo.484.1">do that.</span></span></p>
<h2 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor045" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.485.1">Understanding Clean Architecture implementation</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.486.1">In the </span><a id="_idIndexMarker160" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.487.1">previous chapter, we modularized </span><a id="_idIndexMarker161" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.488.1">our app and talked about using a Clean Architecture-based structure to organize our common and feature modules. </span><span class="kobospan" id="kobo.488.2">We have already created our first component of this architecture, </span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">MessagesWebsocketDataSource</span></strong><span class="kobospan" id="kobo.490.1">, but it is important to understand the reasons behind this organization and which role every component plays in </span><span><span class="kobospan" id="kobo.491.1">the architecture.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.492.1">There are extensive books, articles, and videos about why and how to apply Clean Architecture </span><a id="_idIndexMarker162" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.493.1">principles to an Android app, even </span><a id="_idIndexMarker163" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.494.1">from official documentation by Google. </span><span class="kobospan" id="kobo.494.2">Here, we are going to give you a short description and then break down into </span><span><span class="kobospan" id="kobo.495.1">its layers.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.496.1">Clean Architecture</span></strong><span class="kobospan" id="kobo.497.1"> is an </span><a id="_idIndexMarker164" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.498.1">architectural pattern that promotes the organization of code into layers with well-defined responsibilities, making the application more modular, maintainable, testable, and scalable. </span><span class="kobospan" id="kobo.498.2">The key benefits of using Clean Architecture are </span><span><span class="kobospan" id="kobo.499.1">as follows:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.500.1">Separation of concerns (SoC)</span></strong><span class="kobospan" id="kobo.501.1">: Clean Architecture organizes code into distinct </span><a id="_idIndexMarker165" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.502.1">layers with specific responsibilities, ensuring that each layer handles a separate aspect of the application. </span><span class="kobospan" id="kobo.502.2">This SoC leads to a more modular and maintainable code base, making it easier to understand, modify, </span><span><span class="kobospan" id="kobo.503.1">and extend.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.504.1">Testability</span></strong><span class="kobospan" id="kobo.505.1">: By separating the different concerns into independent layers, it becomes </span><a id="_idIndexMarker166" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.506.1">easier to test each layer in isolation. </span><span class="kobospan" id="kobo.506.2">This allows developers to write comprehensive unit and integration tests, ensuring that the application behaves correctly and is less prone </span><span><span class="kobospan" id="kobo.507.1">to bugs.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.508.1">Reusability</span></strong><span class="kobospan" id="kobo.509.1">: The modular structure of Clean Architecture promotes reusability by encouraging </span><a id="_idIndexMarker167" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.510.1">the creation of components that can be easily shared across different parts of the application or even between different projects. </span><span class="kobospan" id="kobo.510.2">This reduces code duplication and improves the overall efficiency of the </span><span><span class="kobospan" id="kobo.511.1">development process.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.512.1">Flexibility</span></strong><span class="kobospan" id="kobo.513.1">: Clean </span><a id="_idIndexMarker168" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.514.1">Architecture decouples the various layers of the application, making it easier to change or update any of these layers independently without affecting the others. </span><span class="kobospan" id="kobo.514.2">This provides more flexibility when refactoring, making changes to the application, or adapting to </span><span><span class="kobospan" id="kobo.515.1">new requirements.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.516.1">Scalability</span></strong><span class="kobospan" id="kobo.517.1">: The modular nature of Clean Architecture makes it easier to scale the application </span><a id="_idIndexMarker169" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.518.1">as it grows in complexity or size. </span><span class="kobospan" id="kobo.518.2">By organizing code into well-defined layers and components, developers can more easily add new features, update existing functionality, or improve performance without introducing unintended side effects or making the code </span><span><span class="kobospan" id="kobo.519.1">base unmanageable.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.520.1">Easier collaboration</span></strong><span class="kobospan" id="kobo.521.1">: Clean Architecture helps teams work more effectively by providing </span><a id="_idIndexMarker170" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.522.1">a clear structure and guidelines for organizing code. </span><span class="kobospan" id="kobo.522.2">This makes it easier for developers to understand the code base, find the components they need, and contribute to the project </span><span><span class="kobospan" id="kobo.523.1">more efficiently.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.524.1">Future-proofing</span></strong><span class="kobospan" id="kobo.525.1">: By adhering to the principles of Clean Architecture, you ensure that </span><a id="_idIndexMarker171" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.526.1">the application is built on a solid foundation that can evolve and adapt over time. </span><span class="kobospan" id="kobo.526.2">This makes it more resilient to changes in technology, requirements, or team members, improving the long-term viability of </span><span><span class="kobospan" id="kobo.527.1">the project.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.528.1">In summary, using Clean Architecture in your projects leads to better-organized, more maintainable, and scalable code bases. </span><span class="kobospan" id="kobo.528.2">It improves the overall quality of the application, reduces technical debt, and makes it easier for teams to work </span><span><span class="kobospan" id="kobo.529.1">together effectively.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.530.1">Now, with the benefits of Clean Architecture firmly in mind, let’s delve into the specifics. </span><span class="kobospan" id="kobo.530.2">What follows are the layers and the components of code that we will incorporate within </span><span><span class="kobospan" id="kobo.531.1">each layer:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.532.1">Presentation layer</span></strong></span><span><span class="kobospan" id="kobo.533.1">:</span></span><ul class="calibre16"><li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.534.1">View</span></strong><span class="kobospan" id="kobo.535.1">: This </span><a id="_idIndexMarker172" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.536.1">consists of UI </span><a id="_idIndexMarker173" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.537.1">components, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.538.1">Activity</span></strong><span class="kobospan" id="kobo.539.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.540.1">Fragment</span></strong><span class="kobospan" id="kobo.541.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.542.1">View</span></strong><span class="kobospan" id="kobo.543.1">, and, in </span><a id="_idIndexMarker174" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.544.1">our case, </span><strong class="source-inline1"><span class="kobospan" id="kobo.545.1">Composable</span></strong><span class="kobospan" id="kobo.546.1"> components. </span><span class="kobospan" id="kobo.546.2">The view is responsible for displaying data and capturing </span><span><span class="kobospan" id="kobo.547.1">user input.</span></span></li><li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.548.1">ViewModel</span></strong><span class="kobospan" id="kobo.549.1">: The </span><strong class="source-inline1"><span class="kobospan" id="kobo.550.1">ViewModel</span></strong><span class="kobospan" id="kobo.551.1"> serves </span><a id="_idIndexMarker175" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.552.1">as a bridge between the </span><strong class="source-inline1"><span class="kobospan" id="kobo.553.1">View</span></strong><span class="kobospan" id="kobo.554.1"> components and the data layers. </span><span class="kobospan" id="kobo.554.2">It handles the UI logic, exposes </span><strong class="source-inline1"><span class="kobospan" id="kobo.555.1">LiveData</span></strong><span class="kobospan" id="kobo.556.1"> or </span><strong class="source-inline1"><span class="kobospan" id="kobo.557.1">StateFlow</span></strong><span class="kobospan" id="kobo.558.1"> objects for data binding, and communicates with </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.559.1">UseCase</span></strong></span><span><span class="kobospan" id="kobo.560.1"> classes.</span></span></li></ul></li>
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.561.1">Domain layer</span></strong></span><span><span class="kobospan" id="kobo.562.1">:</span></span><ul class="calibre16"><li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.563.1">UseCase</span></strong><span class="kobospan" id="kobo.564.1">: This </span><a id="_idIndexMarker176" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.565.1">layer contains the business logic and coordinates </span><a id="_idIndexMarker177" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.566.1">the flow of data between the data layer </span><a id="_idIndexMarker178" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.567.1">and the presentation layer. </span><strong class="source-inline1"><span class="kobospan" id="kobo.568.1">UseCase</span></strong><span class="kobospan" id="kobo.569.1"> implementations encapsulate specific actions that can be performed within the app, such as sending a message, fetching chat history, or updating </span><span><span class="kobospan" id="kobo.570.1">user settings.</span></span></li></ul></li>
<li class="calibre14"><span><strong class="bold"><span class="kobospan" id="kobo.571.1">Data layer</span></strong></span><span><span class="kobospan" id="kobo.572.1">:</span></span><ul class="calibre16"><li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.573.1">Repository</span></strong><span class="kobospan" id="kobo.574.1">: The </span><strong class="source-inline1"><span class="kobospan" id="kobo.575.1">Repository</span></strong><span class="kobospan" id="kobo.576.1"> component is responsible for managing the data </span><a id="_idIndexMarker179" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.577.1">flow and providing a clean API to </span><a id="_idIndexMarker180" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.578.1">request data from different sources (local database, remote </span><a id="_idIndexMarker181" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.579.1">API, and so on). </span><span class="kobospan" id="kobo.579.2">It abstracts the underlying data sources and handles caching, synchronization, and </span><span><span class="kobospan" id="kobo.580.1">data merging.</span></span></li><li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.581.1">Data source</span></strong><span class="kobospan" id="kobo.582.1">: This </span><a id="_idIndexMarker182" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.583.1">layer contains the implementations for accessing specific data sources such as local databases (using </span><a id="_idIndexMarker183" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.584.1">Room or another </span><strong class="bold"><span class="kobospan" id="kobo.585.1">object-relational mapper</span></strong><span class="kobospan" id="kobo.586.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.587.1">ORM</span></strong><span class="kobospan" id="kobo.588.1">)) and remote APIs (using Retrofit or another networking library, as in our case where we are </span><span><span class="kobospan" id="kobo.589.1">using Ktor).</span></span></li></ul></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.590.1">In the following diagram, we can see the relationships between the different layers and the typical components every </span><span><span class="kobospan" id="kobo.591.1">layer includes:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer022">
<span class="kobospan" id="kobo.592.1"><img alt="Figure 2.1: Clean Architecture in Android with the typical components per layer" src="image/B19443_02_001.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.593.1">Figure 2.1: Clean Architecture in Android with the typical components per layer</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.594.1">Having this </span><a id="_idIndexMarker184" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.595.1">clear understanding of Clean Architecture’s benefits and structure, let’s now put these principles </span><span><span class="kobospan" id="kobo.596.1">into practice.</span></span></p>
<h2 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor046" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.597.1">Creating our Clean Architecture components</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.598.1">We </span><a id="_idIndexMarker185" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.599.1">have started building the data layer components, where </span><a id="_idIndexMarker186" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.600.1">we have created </span><span><span class="kobospan" id="kobo.601.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.602.1">MessagesWebsocket</span></strong></span><strong class="source-inline"><span class="kobospan" id="kobo.603.1">
DataSource</span></strong><span class="kobospan" id="kobo.604.1"> component. </span><span class="kobospan" id="kobo.604.2">Now, it is time we build the rest of our Clean Architecture layers and components to reach the </span><span><span class="kobospan" id="kobo.605.1">presentation layer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.606.1">In the end, this is what our app’s Clean Architecture layers and components should </span><span><span class="kobospan" id="kobo.607.1">look like:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer023">
<span class="kobospan" id="kobo.608.1"><img alt="Figure 2.2: Layers and components that we will build in our project, following Clean Architecture principles" src="image/B19443_02_002.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.609.1">Figure 2.2: Layers and components that we will build in our project, following Clean Architecture principles</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.610.1">As we </span><a id="_idIndexMarker187" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.611.1">have already built the </span><strong class="source-inline"><span class="kobospan" id="kobo.612.1">MessagesWebsocketDataSource</span></strong><span class="kobospan" id="kobo.613.1"> component, the next component is the repository. </span><span class="kobospan" id="kobo.613.2">The </span><a id="_idIndexMarker188" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.614.1">repository component will only connect with </span><strong class="source-inline"><span class="kobospan" id="kobo.615.1">MessagesWebsocketDataSource</span></strong><span class="kobospan" id="kobo.616.1"> (for now; we have bigger plans for it in the next chapter). </span><span class="kobospan" id="kobo.616.2">We are going to call it </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">MessagesRepository</span></strong><span class="kobospan" id="kobo.618.1">. </span><span class="kobospan" id="kobo.618.2">Let’s start </span><span><span class="kobospan" id="kobo.619.1">building it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.620.1">
class MessagesRepository @Inject constructor(
    private val dataSource: MessagesSocketDataSource
) {
    suspend fun getMessages(): Flow&lt;Message&gt; {
        return dataSource.connect()
    }
    suspend fun sendMessage(message: Message) {
        dataSource.sendMessage(message)
    }
    suspend fun disconnect() {
        dataSource.disconnect()
    }
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.621.1">MessagesRepository</span></strong><span class="kobospan" id="kobo.622.1"> will just have one dependency (</span><strong class="source-inline"><span class="kobospan" id="kobo.623.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.624.1">) and will implement the functionality to connect to messages (the </span><strong class="source-inline"><span class="kobospan" id="kobo.625.1">getMessages</span></strong><span class="kobospan" id="kobo.626.1"> function), send messages (the </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">sendMessage</span></strong><span class="kobospan" id="kobo.628.1"> function), and disconnect from the WebSocket (the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">disconnect</span></strong></span><span><span class="kobospan" id="kobo.630.1"> function).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.631.1">Now, we </span><a id="_idIndexMarker189" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.632.1">need to do a little modification to </span><strong class="source-inline"><span class="kobospan" id="kobo.633.1">MessagesRepository</span></strong><span class="kobospan" id="kobo.634.1">: we need to create an interface in the domain </span><a id="_idIndexMarker190" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.635.1">layer with the </span><strong class="source-inline"><span class="kobospan" id="kobo.636.1">MessagesRepository</span></strong><span class="kobospan" id="kobo.637.1"> functionality. </span><span class="kobospan" id="kobo.637.2">Creating an interface for the repository in the domain </span><a id="_idIndexMarker191" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.638.1">layer and implementing it in the data layer is a technique that follows the </span><strong class="bold"><span class="kobospan" id="kobo.639.1">Dependency Inversion Principle</span></strong><span class="kobospan" id="kobo.640.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.641.1">DIP</span></strong><span class="kobospan" id="kobo.642.1">) from the </span><a id="_idIndexMarker192" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.643.1">SOLID principles of </span><strong class="bold"><span class="kobospan" id="kobo.644.1">object-oriented </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.645.1">programming</span></strong></span><span><span class="kobospan" id="kobo.646.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.647.1">OOP</span></strong></span><span><span class="kobospan" id="kobo.648.1">).</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.649.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.650.1">DIP is one of the five principles of OOP and design known as SOLID. </span><span class="kobospan" id="kobo.650.2">DIP states that high-level modules should not depend on low-level modules and both should depend on abstractions. </span><span class="kobospan" id="kobo.650.3">Similarly, abstractions should not depend on details; details should depend on abstractions. </span><span class="kobospan" id="kobo.650.4">The main idea behind DIP is to decouple modules, classes, or components in a software system, promoting flexibility, reusability, and maintainability. </span><span class="kobospan" id="kobo.650.5">By depending on abstractions rather than concrete implementations, the system becomes more adaptable to changes and easier to test </span><span><span class="kobospan" id="kobo.651.1">and maintain.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.652.1">Let’s create our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.653.1">IMessagesRepository</span></strong></span><span><span class="kobospan" id="kobo.654.1"> interface:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.655.1">
interface IMessagesRepository {
    suspend fun getMessages(): Flow&lt;Message&gt;
    suspend fun sendMessage(message: Message)
    suspend fun disconnect()
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.656.1">Then, we will </span><a id="_idIndexMarker193" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.657.1">change our </span><strong class="source-inline"><span class="kobospan" id="kobo.658.1">MessagesRepository</span></strong><span class="kobospan" id="kobo.659.1"> class </span><a id="_idIndexMarker194" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.660.1">to implement this interface, adding the override in </span><span><span class="kobospan" id="kobo.661.1">its functions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.662.1">
class MessagesRepository @Inject constructor(
    private val dataSource: MessagesSocketDataSource
): IMessagesRepository {
    override suspend fun getMessages(): Flow&lt;Message&gt; {
        return dataSource.connect()
    }
    override suspend fun sendMessage(message: Message) {
        dataSource.sendMessage(message)
    }
    override suspend fun disconnect() {
        dataSource.disconnect()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.663.1">Now, we will continue in our journey to the presentation layer, implementing the </span><span><span class="kobospan" id="kobo.664.1">domain layer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.665.1">The domain layer is not strictly mandatory, but it is highly recommended. </span><span class="kobospan" id="kobo.665.2">While you can eliminate the domain layer and directly use repositories in your </span><strong class="source-inline"><span class="kobospan" id="kobo.666.1">ViewModel</span></strong><span class="kobospan" id="kobo.667.1"> instances, doing so </span><a id="_idIndexMarker195" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.668.1">would mix the responsibilities of the </span><a id="_idIndexMarker196" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.669.1">layers, which can lead to more complex and harder-to-maintain code. </span><span class="kobospan" id="kobo.669.2">There may be cases where not implementing </span><a id="_idIndexMarker197" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.670.1">it could be considered; for example, if you are doing a </span><strong class="bold"><span class="kobospan" id="kobo.671.1">proof of concept</span></strong><span class="kobospan" id="kobo.672.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.673.1">PoC</span></strong><span class="kobospan" id="kobo.674.1">) or a simple app. </span><span class="kobospan" id="kobo.674.2">Therefore, it is recommended to include the </span><strong class="source-inline"><span class="kobospan" id="kobo.675.1">UseCase</span></strong><span class="kobospan" id="kobo.676.1"> layer to maintain a clean and </span><span><span class="kobospan" id="kobo.677.1">scalable architecture.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.678.1">Following </span><a id="_idIndexMarker198" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.679.1">the </span><strong class="bold"><span class="kobospan" id="kobo.680.1">Single Responsibility Principle</span></strong><span class="kobospan" id="kobo.681.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.682.1">SRP</span></strong><span class="kobospan" id="kobo.683.1">), in this layer, we will create as many </span><strong class="source-inline"><span class="kobospan" id="kobo.684.1">UseCase</span></strong><span class="kobospan" id="kobo.685.1"> instances as different functions/responsibilities in our business logic. </span><span class="kobospan" id="kobo.685.2">So, in our case, we will create three </span><strong class="source-inline"><span class="kobospan" id="kobo.686.1">UseCase</span></strong><span class="kobospan" id="kobo.687.1"> instances: one for retrieving messages, one for sending messages, and one for disconnecting or stopping </span><span><span class="kobospan" id="kobo.688.1">message retrieval.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.689.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.690.1">SRP is one of the five principles of OOP and design known as SOLID. </span><span class="kobospan" id="kobo.690.2">It states that a class, module, or function should have only one reason to change, meaning it should have only one responsibility. </span><span class="kobospan" id="kobo.690.3">The principle aims to promote SoC by encouraging developers to break down their code into smaller, more focused components that handle a single task or aspect of the application. </span><span class="kobospan" id="kobo.690.4">This leads to a more modular, maintainable, and easier-to-understand </span><span><span class="kobospan" id="kobo.691.1">code base.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.692.1">First, we will implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.693.1">RetrieveMessages</span></strong> <span><span class="kobospan" id="kobo.694.1">use case:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.695.1">
class RetrieveMessages @Inject constructor(
    private val repository: IMessagesRepository
) {
    suspend operator fun invoke(): Flow&lt;Message&gt; {
        return repository.getMessages()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.696.1">Here, we have just one dependency: the repository. </span><span class="kobospan" id="kobo.696.2">Note that we are declaring it using its interface. </span><span class="kobospan" id="kobo.696.3">It is relevant because, as we detailed before, the domain shouldn’t know anything about the </span><span><span class="kobospan" id="kobo.697.1">data layer.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.698.1">RetrieveMessages</span></strong><span class="kobospan" id="kobo.699.1"> will have one function that will return a </span><strong class="source-inline"><span class="kobospan" id="kobo.700.1">Flow</span></strong><span class="kobospan" id="kobo.701.1"> instance with </span><strong class="source-inline"><span class="kobospan" id="kobo.702.1">Message</span></strong><span class="kobospan" id="kobo.703.1"> objects. </span><span class="kobospan" id="kobo.703.2">For doing that, it will return </span><strong class="source-inline"><span class="kobospan" id="kobo.704.1">repository.getMessages()</span></strong><span class="kobospan" id="kobo.705.1">. </span><span class="kobospan" id="kobo.705.2">No mapping </span><a id="_idIndexMarker199" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.706.1">or alteration is needed as this function </span><a id="_idIndexMarker200" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.707.1">already returned a </span><strong class="source-inline"><span class="kobospan" id="kobo.708.1">Flow</span></strong><span class="kobospan" id="kobo.709.1"> instance of </span><span><strong class="source-inline"><span class="kobospan" id="kobo.710.1">Message</span></strong></span><span><span class="kobospan" id="kobo.711.1"> objects.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.712.1">Second, we are going to implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.713.1">SendMessage</span></strong> <span><span class="kobospan" id="kobo.714.1">use case:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.715.1">
class SendMessage @Inject constructor(
    private val repository: IMessagesRepository
) {
    suspend operator fun invoke(message: Message) {
        repository.sendMessage(message)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.716.1">Again, this use case will depend only on the </span><strong class="source-inline"><span class="kobospan" id="kobo.717.1">IMessagesRepository</span></strong><span class="kobospan" id="kobo.718.1"> interface. </span><span class="kobospan" id="kobo.718.2">It will call its </span><span><strong class="source-inline"><span class="kobospan" id="kobo.719.1">sendMessage</span></strong></span><span><span class="kobospan" id="kobo.720.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.721.1">And finally, we will code the </span><strong class="source-inline"><span class="kobospan" id="kobo.722.1">DisconnectMessages</span></strong> <span><span class="kobospan" id="kobo.723.1">use case:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.724.1">
class DisconnectMessages @Inject constructor(
    private val repository: IMessagesRepository
) {
    suspend operator fun invoke() {
        repository.disconnect()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.725.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.726.1">DisconnectMessages</span></strong><span class="kobospan" id="kobo.727.1"> use case, as with the previous use cases implemented, depends on the </span><strong class="source-inline"><span class="kobospan" id="kobo.728.1">IMessagesRepository</span></strong><span class="kobospan" id="kobo.729.1"> interface and will call its </span><span><strong class="source-inline"><span class="kobospan" id="kobo.730.1">disconnect</span></strong></span><span><span class="kobospan" id="kobo.731.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.732.1">We are </span><a id="_idIndexMarker201" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.733.1">now done with the domain layer. </span><span class="kobospan" id="kobo.733.2">Now, it’s </span><a id="_idIndexMarker202" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.734.1">time to implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.735.1">ViewModel</span></strong><span class="kobospan" id="kobo.736.1"> component that we will connect to the </span><strong class="source-inline"><span class="kobospan" id="kobo.737.1">ChatScreen</span></strong><span class="kobospan" id="kobo.738.1"> component, </span><span><span class="kobospan" id="kobo.739.1">using </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.740.1">ChatViewModel</span></strong></span><span><span class="kobospan" id="kobo.741.1">.</span></span></p>
</div>


<div id="_idContainer024" class="calibre2">
<h2 id="_idParaDest-47" class="calibre7"><a id="_idTextAnchor047" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.742.1">Implementing ChatViewModel</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.743.1">In Android, </span><strong class="source-inline"><span class="kobospan" id="kobo.744.1">ViewModel</span></strong><span class="kobospan" id="kobo.745.1"> is an architectural component introduced as part of the </span><strong class="bold"><span class="kobospan" id="kobo.746.1">Android Architecture Components</span></strong><span class="kobospan" id="kobo.747.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.748.1">AAC</span></strong><span class="kobospan" id="kobo.749.1">) library. </span><span class="kobospan" id="kobo.749.2">It is designed to store and manage </span><a id="_idIndexMarker203" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.750.1">UI-related data in a lifecycle-conscious way. </span><span class="kobospan" id="kobo.750.2">The primary responsibility of a </span><strong class="source-inline"><span class="kobospan" id="kobo.751.1">ViewModel</span></strong><span class="kobospan" id="kobo.752.1"> component is to hold and process the </span><a id="_idIndexMarker204" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.753.1">data required for a UI component (such as an </span><strong class="source-inline"><span class="kobospan" id="kobo.754.1">Activity</span></strong><span class="kobospan" id="kobo.755.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">Fragment</span></strong><span class="kobospan" id="kobo.757.1">, or </span><strong class="source-inline"><span class="kobospan" id="kobo.758.1">Composable</span></strong><span class="kobospan" id="kobo.759.1"> component) while properly handling configuration changes (such as device rotations) and surviving the lifecycle of the associated </span><span><span class="kobospan" id="kobo.760.1">UI component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.761.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">ChatViewModel</span></strong><span class="kobospan" id="kobo.763.1"> class will be responsible for handling the data required in our </span><strong class="source-inline"><span class="kobospan" id="kobo.764.1">ChatScreen</span></strong><span class="kobospan" id="kobo.765.1"> component (which we previously built in </span><a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.766.1">Chapter 1</span></em></span></a><span class="kobospan" id="kobo.767.1">). </span><span class="kobospan" id="kobo.767.2">This data will come and change from the use cases we have just created. </span><span class="kobospan" id="kobo.767.3">So first, our </span><strong class="source-inline"><span class="kobospan" id="kobo.768.1">ChatViewModel</span></strong><span class="kobospan" id="kobo.769.1"> class will have those use cases </span><span><span class="kobospan" id="kobo.770.1">as dependencies:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.771.1">
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val retrieveMessages: RetrieveMessages,
    private val sendMessage: SendMessage,
    private val disconnectMessages: DisconnectMessages
) : ViewModel() {
// ....
</span><span class="kobospan1" id="kobo.771.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.772.1">Then, we will need a property to hold the state. </span><span class="kobospan" id="kobo.772.2">This property needs to be observable from the view but read-only (so that the view shouldn’t be able to modify it). </span><span class="kobospan" id="kobo.772.3">We will solve this by creating two different properties. </span><span class="kobospan" id="kobo.772.4">The first property </span><span><span class="kobospan" id="kobo.773.1">is </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.774.1">_messages</span></strong></span><span><span class="kobospan" id="kobo.775.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.776.1">
private val _messages =
MutableStateFlow&lt;List&lt;Message&gt;&gt;(emptyList())</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.777.1">This line creates a private mutable state flow that holds a list of </span><strong class="source-inline"><span class="kobospan" id="kobo.778.1">Message</span></strong><span class="kobospan" id="kobo.779.1"> objects. </span><span class="kobospan" id="kobo.779.2">We will use it to manage and update messages internally within </span><span><span class="kobospan" id="kobo.780.1">the </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.781.1">ViewModel</span></strong></span><span><span class="kobospan" id="kobo.782.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.783.1">The second property will </span><span><span class="kobospan" id="kobo.784.1">be </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">messages</span></strong></span><span><span class="kobospan" id="kobo.786.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.787.1">
val messages: StateFlow&lt;List&lt;Message&gt;&gt; = _messages</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.788.1">This line </span><a id="_idIndexMarker205" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.789.1">exposes the private mutable state flow as a public </span><a id="_idIndexMarker206" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.790.1">read-only state flow. </span><span class="kobospan" id="kobo.790.2">This allows the UI components to observe messages without being able to modify </span><span><span class="kobospan" id="kobo.791.1">them directly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.792.1">Now, we need to implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.793.1">loadAndUpdateMessages</span></strong><span class="kobospan" id="kobo.794.1"> function that will call the </span><strong class="source-inline"><span class="kobospan" id="kobo.795.1">RetrieveMessages</span></strong> <span><span class="kobospan" id="kobo.796.1">use case:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.797.1">
private var messageCollectionJob: Job? </span><span class="kobospan1" id="kobo.797.2">= null
fun loadAndUpdateMessages() {
    messageCollectionJob =
    viewModelScope.launch(Dispatchers.IO) {
        retrieveMessages()
            .map { it.toUI() }
            .collect { message -&gt;
                withContext(Dispatchers.Main) {
                    _messages.value = _messages.value +
                    message
                }
            }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.798.1">In the previous code block, it can be seen that we need to declare a </span><strong class="source-inline"><span class="kobospan" id="kobo.799.1">messageCollectionJob</span></strong><span class="kobospan" id="kobo.800.1"> variable. </span><span class="kobospan" id="kobo.800.2">This variable is used to cancel the </span><strong class="source-inline"><span class="kobospan" id="kobo.801.1">messages</span></strong><span class="kobospan" id="kobo.802.1"> collection job when the </span><strong class="source-inline"><span class="kobospan" id="kobo.803.1">ViewModel</span></strong> <span><span class="kobospan" id="kobo.804.1">is cleared.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.805.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.806.1">loadAndUpdateMessages</span></strong><span class="kobospan" id="kobo.807.1"> function is responsible for fetching and updating messages. </span><span class="kobospan" id="kobo.807.2">It </span><a id="_idIndexMarker207" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.808.1">launches a coroutine with the </span><strong class="source-inline"><span class="kobospan" id="kobo.809.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.810.1"> context for performing network or </span><span><span class="kobospan" id="kobo.811.1">disk operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.812.1">Inside the </span><a id="_idIndexMarker208" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.813.1">coroutine, the </span><strong class="source-inline"><span class="kobospan" id="kobo.814.1">retrieveMessages</span></strong><span class="kobospan" id="kobo.815.1"> function is called, and the resulting messages are mapped into the </span><strong class="source-inline"><span class="kobospan" id="kobo.816.1">Message</span></strong><span class="kobospan" id="kobo.817.1"> UI object and then collected using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.818.1">collect</span></strong></span><span><span class="kobospan" id="kobo.819.1"> function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.820.1">For each </span><a id="_idIndexMarker209" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.821.1">collected message, the </span><strong class="source-inline"><span class="kobospan" id="kobo.822.1">_messages state</span></strong><span class="kobospan" id="kobo.823.1"> flow is </span><a id="_idIndexMarker210" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.824.1">updated with the new message by switching the coroutine context </span><span><span class="kobospan" id="kobo.825.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.826.1">Dispatchers.Main</span></strong></span><span><span class="kobospan" id="kobo.827.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.828.1">Next, to make the mapping more readable, we are going to create two </span><span><span class="kobospan" id="kobo.829.1">extension functions:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.830.1">
private fun DomainMessage.toUI(): Message {
    return Message(
        id = id,
        senderName = senderName,
        senderAvatar = senderAvatar,
        timestamp = timestamp,
        isMine = isMine,
        messageContent = getMessageContent()
    )
}
private fun DomainMessage.getMessageContent():
MessageContent {
    return when (contentType) {
        DomainMessage.ContentType.TEXT -&gt;
            MessageContent.TextMessage(content)
        DomainMessage.ContentType.IMAGE -&gt;
            MessageContent.ImageMessage(content,
            contentDescription)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.831.1">So, when </span><a id="_idIndexMarker211" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.832.1">retrieving and mapping messages, we just have to call </span><span><span class="kobospan" id="kobo.833.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.834.1">
retrieveMessages()
    .map { it.toUI() }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.835.1">Then, we continue </span><a id="_idIndexMarker212" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.836.1">to process the </span><strong class="source-inline"><span class="kobospan" id="kobo.837.1">messages</span></strong> <span><span class="kobospan" id="kobo.838.1">collection job.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.839.1">Then, we should add a function to send a new message. </span><span class="kobospan" id="kobo.839.2">Basically, the idea is to launch the coroutine in the </span><strong class="source-inline"><span class="kobospan" id="kobo.840.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.841.1"> context to send the message. </span><span class="kobospan" id="kobo.841.2">As it is a network operation, it is recommended to use the I/O dispatcher and map the </span><strong class="source-inline"><span class="kobospan" id="kobo.842.1">String</span></strong><span class="kobospan" id="kobo.843.1"> object we are getting from the user to the domain object, as you can see in the following </span><span><span class="kobospan" id="kobo.844.1">code block:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.845.1">
fun onSendMessage(messageText: String) {
    viewModelScope.launch(Dispatchers.IO) {
        val message = Message(messageText) // We will add
                                              here the rest
                                              of the fields
        sendMessage(message)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.846.1">Note that, to create the domain object, we are going to lack some information because, for example, we have no way to obtain the </span><strong class="source-inline"><span class="kobospan" id="kobo.847.1">senderImage</span></strong><span class="kobospan" id="kobo.848.1"> or the </span><strong class="source-inline"><span class="kobospan" id="kobo.849.1">senderName</span></strong><span class="kobospan" id="kobo.850.1"> properties that are mandatory to send a message. </span><span class="kobospan" id="kobo.850.2">So, this function is not going to compile for now, but we will solve this problem in the </span><span><span class="kobospan" id="kobo.851.1">following section.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.852.1">Finally, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.853.1">onCleared</span></strong><span class="kobospan" id="kobo.854.1"> function to disconnect from the </span><span><span class="kobospan" id="kobo.855.1">message’s retrieval:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.856.1">
override fun onCleared() {
    messageCollectionJob?.cancel()
    viewModelScope.launch(Dispatchers.IO) {
        disconnectMessages()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.857.1">This function </span><a id="_idIndexMarker213" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.858.1">is called when the </span><strong class="source-inline"><span class="kobospan" id="kobo.859.1">ViewModel</span></strong><span class="kobospan" id="kobo.860.1"> is no longer in use and will be disposed of by the system. </span><span class="kobospan" id="kobo.860.2">This involves canceling </span><a id="_idIndexMarker214" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.861.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.862.1">messageCollectionJob</span></strong><span class="kobospan" id="kobo.863.1"> variable, provided it’s not </span><strong class="source-inline"><span class="kobospan" id="kobo.864.1">null</span></strong><span class="kobospan" id="kobo.865.1">, effectively halting the </span><strong class="source-inline"><span class="kobospan" id="kobo.866.1">messages</span></strong><span class="kobospan" id="kobo.867.1"> collection coroutine. </span><span class="kobospan" id="kobo.867.2">Concurrently, in the context of </span><strong class="source-inline"><span class="kobospan" id="kobo.868.1">Dispatchers.IO</span></strong><span class="kobospan" id="kobo.869.1">, a new coroutine is launched to execute the </span><strong class="source-inline"><span class="kobospan" id="kobo.870.1">disconnectMessages</span></strong><span class="kobospan" id="kobo.871.1"> function. </span><span class="kobospan" id="kobo.871.2">This guarantees that any essential cleanup associated with disconnecting from the message source is carried </span><span><span class="kobospan" id="kobo.872.1">out properly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.873.1">This is how the </span><strong class="source-inline"><span class="kobospan" id="kobo.874.1">ChatViewModel</span></strong><span class="kobospan" id="kobo.875.1"> component will look (</span><span><span class="kobospan" id="kobo.876.1">for now):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.877.1">
import com.packt.feature.chat.domain.models.Message as
DomainMessage
// We are using this import with an alias to make it easier
   to identify the Message class from the domain layer
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val retrieveMessages: RetrieveMessages,
    private val sendMessage: SendMessage,
    private val disconnectMessages: DisconnectMessages
) : ViewModel() {
    private val _messages =
        MutableStateFlow&lt;List&lt;Message&gt;&gt;(emptyList())
    val messages: StateFlow&lt;List&lt;Message&gt;&gt; = _messages
    private var messageCollectionJob: Job? </span><span class="kobospan1" id="kobo.877.2">= null
    fun loadAndUpdateMessages() {
        messageCollectionJob =
        viewModelScope.launch(Dispatchers.IO) {
            retrieveMessages()
                .map { it.toUI() }
                .collect { message -&gt;
                    withContext(Dispatchers.Main) {
                        _messages.value = _messages.value +
                        message
                }
            }
        }
    }
    private fun DomainMessage.toUI(): Message {
        return Message(
            id = id,
            senderName = senderName,
            senderAvatar = senderAvatar,
            timestamp = timestamp,
            isMine = isMine,
            messageContent = getMessageContent()
        )
    }
    private fun DomainMessage.getMessageContent():
    MessageContent {
        return when (contentType) {
            DomainMessage.ContentType.TEXT -&gt;
                MessageContent.TextMessage(content)
            DomainMessage.ContentType.IMAGE -&gt;
                MessageContent.ImageMessage(content,
                contentDescription)
        }
    }
    fun onSendMessage(messageText: String) {
        viewModelScope.launch(Dispatchers.IO) {
            val message = Message(messageText)
            sendMessage(message)
        }
    }
    override fun onCleared() {
        messageCollectionJob?.cancel()
        viewModelScope.launch(Dispatchers.IO) {
            disconnectMessages()
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.878.1">Now that </span><a id="_idIndexMarker215" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.879.1">we have our </span><strong class="source-inline"><span class="kobospan" id="kobo.880.1">ChatViewModel</span></strong><span class="kobospan" id="kobo.881.1"> component ready, we need to connect it to the view. </span><span class="kobospan" id="kobo.881.2">We will make the changes </span><a id="_idIndexMarker216" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.882.1">needed in the </span><strong class="source-inline"><span class="kobospan" id="kobo.883.1">ChatScreen</span></strong><span class="kobospan" id="kobo.884.1"> component so that it connects to our </span><strong class="source-inline"><span class="kobospan" id="kobo.885.1">ChatViewModel</span></strong><span class="kobospan" id="kobo.886.1"> component. </span><span class="kobospan" id="kobo.886.2">As the first step, we have added the </span><strong class="source-inline"><span class="kobospan" id="kobo.887.1">ViewModel</span></strong><span class="kobospan" id="kobo.888.1"> to </span><span><span class="kobospan" id="kobo.889.1">the arguments:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.890.1">
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel(),
    chatId: String?,
    onBack: () -&gt; Unit
) {
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.891.1">Then, we will also add a </span><strong class="source-inline"><span class="kobospan" id="kobo.892.1">LaunchEffect</span></strong><span class="kobospan" id="kobo.893.1"> composable that will start the </span><span><span class="kobospan" id="kobo.894.1">messages’ load:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.895.1">
LaunchedEffect(Unit) {
    viewModel.loadAndUpdateMessages()
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.896.1">Next, the </span><strong class="source-inline"><span class="kobospan" id="kobo.897.1">SendMessageBox</span></strong><span class="kobospan" id="kobo.898.1"> composable takes a lambda parameter, where we are going to send the message using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.899.1">ViewModel</span></strong></span><span><span class="kobospan" id="kobo.900.1"> function:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.901.1">
SendMessageBox { viewModel.onSendMessage(it) }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.902.1">After that, we add </span><a id="_idIndexMarker217" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.903.1">the following new parameter </span><a id="_idIndexMarker218" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.904.1">to the </span><strong class="source-inline"><span class="kobospan" id="kobo.905.1">SendMessageBox</span></strong><span class="kobospan" id="kobo.906.1"> composable definition and call it in its </span><strong class="source-inline"><span class="kobospan" id="kobo.907.1">IconButton</span></strong> <span><strong class="source-inline"><span class="kobospan" id="kobo.908.1">onClick</span></strong></span><span><span class="kobospan" id="kobo.909.1"> property:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.910.1">
@Composable
fun SendMessageBox(sendMessage: (String)-&gt;Unit) {
    Box(modifier = Modifier
        .defaultMinSize()
        .padding(top = 0.dp, start = 16.dp, end = 16.dp,
            bottom = 16.dp)
        .fillMaxWidth()
    ) {
        var text by remember { mutableStateOf("") }
        OutlinedTextField(
            value = text,
            onValueChange = { newText -&gt; text = newText },
            modifier = Modifier
                .fillMaxWidth(0.85f)
                .align(Alignment.CenterStart)
                .height(56.dp),
        )
        IconButton(
            modifier = Modifier
                .align(Alignment.CenterEnd)
                .height(56.dp),
            onClick = {
                sendMessage(text)
                text = ""
            }
        ) {
            Icon(
                imageVector = Icons.Default.Send,
                tint = MaterialTheme.colors.primary,
                contentDescription = "Send message"
            )
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.911.1">Finally, we will </span><a id="_idIndexMarker219" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.912.1">inject the </span><strong class="source-inline"><span class="kobospan" id="kobo.913.1">messages</span></strong><span class="kobospan" id="kobo.914.1"> property </span><a id="_idIndexMarker220" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.915.1">to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.916.1">ListOfMessages</span></strong></span><span><span class="kobospan" id="kobo.917.1"> composable:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.918.1">
ListOfMessages(paddingValues = paddingValues, messages = messages)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.919.1">This, of course, will also require a change in the composable definition </span><span><span class="kobospan" id="kobo.920.1">and code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.921.1">
@Composable
fun ListOfMessages(messages: List&lt;Message&gt;, paddingValues: PaddingValues) {
    Box(modifier = Modifier
        .fillMaxSize()
        .padding(paddingValues)) {
        Row(modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
        ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize(),
                verticalArrangement =
                    Arrangement.spacedBy(8.dp),
            ) {
                items(messages) { message -&gt;
                    MessageItem(message = message)
                }
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.922.1">Instead </span><a id="_idIndexMarker221" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.923.1">of using the </span><strong class="source-inline"><span class="kobospan" id="kobo.924.1">getFakeMessages()</span></strong><span class="kobospan" id="kobo.925.1"> function </span><a id="_idIndexMarker222" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.926.1">we were using when we built the </span><strong class="source-inline"><span class="kobospan" id="kobo.927.1">ListOfMessages</span></strong><span class="kobospan" id="kobo.928.1"> composable, we will use the </span><strong class="source-inline"><span class="kobospan" id="kobo.929.1">messages</span></strong><span class="kobospan" id="kobo.930.1"> list that we are now obtaining </span><span><span class="kobospan" id="kobo.931.1">via properties.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.932.1">And with that, we’ve covered almost everything, but there remain some challenges to address. </span><span class="kobospan" id="kobo.932.2">For instance, we don’t have the necessary information to display the correct avatar and name of the chat members or the necessary information to fill in the required properties for sending a message. </span><span class="kobospan" id="kobo.932.3">While we will receive new messages once we connect to the WebSocket, the question of how to get historical messages remains. </span><span class="kobospan" id="kobo.932.4">We will tackle these issues, along with other concerns related to error handling and synchronization, in the </span><span><span class="kobospan" id="kobo.933.1">upcoming section.</span></span></p>
<h1 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor048" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.934.1">Handling synchronization and errors</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.935.1">To make the </span><a id="_idIndexMarker223" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.936.1">chat messages functionality complete, we still have some issues </span><a id="_idIndexMarker224" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.937.1">we have to take into account: getting historical messages and receiver information and handling possible errors. </span><span class="kobospan" id="kobo.937.2">We will go through them in </span><span><span class="kobospan" id="kobo.938.1">this section.</span></span></p>
<h2 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor049" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.939.1">Obtaining chat screen initialization data</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.940.1">Apart from </span><a id="_idIndexMarker225" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.941.1">the messages that we are going to be receiving or sending via the data source, we still need to get some additional information. </span><span class="kobospan" id="kobo.941.2">This includes </span><span><span class="kobospan" id="kobo.942.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.943.1">Messages that have been sent and received before the WebSocket was connected (not all of them, though, because the conversation could have many messages, and it would take a long time to gather/load all of the information; instead we should prioritize fetching a certain number of the most </span><span><span class="kobospan" id="kobo.944.1">recent messages)</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.945.1">Receiver information, such as their name or </span><span><span class="kobospan" id="kobo.946.1">avatar URL</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.947.1">There are several options to solve this – for example, we could have a different type of message with all this information when the WebSocket connection is established, or we could have a specific API call to retrieve this information. </span><span class="kobospan" id="kobo.947.2">As we have already played with the Ktor WebSocket for the chat feature, we are going to use it to implement an API call to retrieve </span><span><span class="kobospan" id="kobo.948.1">this information.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.949.1">When we built </span><strong class="source-inline"><span class="kobospan" id="kobo.950.1">WebsocketMessagesDataSource</span></strong><span class="kobospan" id="kobo.951.1">, we had to provide an </span><strong class="source-inline"><span class="kobospan" id="kobo.952.1">HttpClient</span></strong><span class="kobospan" id="kobo.953.1"> instance. </span><span class="kobospan" id="kobo.953.2">Usually, these clients are shared within the same application, but we should create a new one to be used for our API requests. </span><span class="kobospan" id="kobo.953.3">For that, we would need to add a </span><span><span class="kobospan" id="kobo.954.1">new dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.955.1">
implementation "io.ktor:ktor-client-content-negotiation:
$ktor_version"</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.956.1">Then, we can create the client like so (we can do it in the same file we defined the </span><span><span class="kobospan" id="kobo.957.1">WebSocket client):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.958.1">
object RestClient {
    val client = HttpClient{
        install(ContentNegotiation) {
            json()
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.959.1">Next, we are </span><a id="_idIndexMarker226" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.960.1">going to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.961.1">ChatRoomDataSource</span></strong><span class="kobospan" id="kobo.962.1"> class that will be in charge of handling this </span><span><span class="kobospan" id="kobo.963.1">data retrieval:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.964.1">
class ChatRoomDataSource @Inject constructor(
    private val client: HttpClient,
    private val url: String
) {
    suspend fun getInitialChatRoom(id: String):
    ChatRoomModel {
        return client.get(url.format(id)).body()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.965.1">As seen here, we are going to inject the client and the URL as dependencies. </span><span class="kobospan" id="kobo.965.2">Then, in the </span><strong class="source-inline"><span class="kobospan" id="kobo.966.1">getInitialChatRoom</span></strong><span class="kobospan" id="kobo.967.1"> function, we will call the </span><strong class="source-inline"><span class="kobospan" id="kobo.968.1">client.get(url)</span></strong><span class="kobospan" id="kobo.969.1"> function in order to make a request to </span><span><span class="kobospan" id="kobo.970.1">the endpoint.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.971.1">Using the Ktor client, you can use various HTTP methods. </span><span class="kobospan" id="kobo.971.2">Here’s a list of </span><span><span class="kobospan" id="kobo.972.1">common ones:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.973.1">GET</span></strong><span class="kobospan" id="kobo.974.1">: Retrieves </span><a id="_idIndexMarker227" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.975.1">data from the specified endpoint. </span><span class="kobospan" id="kobo.975.2">To use this method in Ktor, you can call the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.976.1">get</span></strong></span><span><span class="kobospan" id="kobo.977.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.978.1">
val response: HttpResponse =
client.get("https://api.example.com/data")</span></pre></li> <li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.979.1">POST</span></strong><span class="kobospan" id="kobo.980.1">: Sends data </span><a id="_idIndexMarker228" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.981.1">to the specified endpoint, usually for creating a new resource. </span><span class="kobospan" id="kobo.981.2">To use this method in Ktor, you can call the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.982.1">post</span></strong></span><span><span class="kobospan" id="kobo.983.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.984.1">
val response: HttpResponse =
client.post("https://api.example.com/data") {
body = yourData }</span></pre></li> <li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.985.1">PUT</span></strong><span class="kobospan" id="kobo.986.1">: Sends data </span><a id="_idIndexMarker229" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.987.1">to the specified endpoint, usually for updating an existing resource. </span><span class="kobospan" id="kobo.987.2">To use this method in Ktor, you can call the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.988.1">put</span></strong></span><span><span class="kobospan" id="kobo.989.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.990.1">
val response: HttpResponse =
client.put("https://api.example.com/data") {
body = yourUpdatedData }</span></pre></li> <li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.991.1">DELETE</span></strong><span class="kobospan" id="kobo.992.1">: Deletes </span><a id="_idIndexMarker230" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.993.1">a specified resource. </span><span class="kobospan" id="kobo.993.2">To use this method in Ktor, you can call the </span><strong class="source-inline1"><span class="kobospan" id="kobo.994.1">delete</span></strong> <span><span class="kobospan" id="kobo.995.1">function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.996.1">
val response: HttpResponse =
client.delete("https://api.example.com/data/ID")</span></pre></li> <li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.997.1">PATCH</span></strong><span class="kobospan" id="kobo.998.1">: Applies </span><a id="_idIndexMarker231" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.999.1">partial modifications to a resource. </span><span class="kobospan" id="kobo.999.2">To use this method in Ktor, you can call the </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1000.1">patch</span></strong></span><span><span class="kobospan" id="kobo.1001.1"> function:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1002.1">
val response: HttpResponse =
client.patch("https://api.example.com/data") {
body = yourPartialData }</span></pre></li> </ul>
<p class="calibre3"><span class="kobospan" id="kobo.1003.1">In the </span><a id="_idIndexMarker232" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1004.1">case of our </span><strong class="source-inline"><span class="kobospan" id="kobo.1005.1">getInitialChatRoom</span></strong><span class="kobospan" id="kobo.1006.1"> function, we are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1007.1">client.get(URL)</span></strong><span class="kobospan" id="kobo.1008.1"> function (note that we have to provide the URL in a format such that we can then replace the ID of </span><strong class="source-inline"><span class="kobospan" id="kobo.1009.1">ChatRoom</span></strong><span class="kobospan" id="kobo.1010.1">). </span><span class="kobospan" id="kobo.1010.2">We also need to return a new </span><span><span class="kobospan" id="kobo.1011.1">model, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1012.1">ChatRoomModel</span></strong></span><span><span class="kobospan" id="kobo.1013.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1014.1">
@kotlinx.serialization.Serializable
data class ChatRoomModel(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val lastMessages: List&lt;WebsocketMessageModel&gt;
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1015.1">Now, in order </span><a id="_idIndexMarker233" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1016.1">to provide the dependencies that </span><strong class="source-inline"><span class="kobospan" id="kobo.1017.1">ChatRoomDataSource</span></strong><span class="kobospan" id="kobo.1018.1"> needs, we have to set our </span><strong class="source-inline"><span class="kobospan" id="kobo.1019.1">ChatModule</span></strong><span class="kobospan" id="kobo.1020.1"> class in the </span><span><span class="kobospan" id="kobo.1021.1">following way:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1022.1">
@InstallIn(SingletonComponent::class)
@Module
abstract class ChatModule {
    companion object {
        const val WEBSOCKET_URL =
            "ws://whatspackt.com/chat/%s"
        const val WEBSOCKET_URL_NAME = "WEBSOCKET_URL"
        const val WEBSOCKET_CLIENT = "WEBSOCKET_CLIENT"
        const val API_CHAT_ROOM_URL =
            "http://whatspackt.com/chats/%s"
        const val API_CHAT_ROOM_URL_NAME = "CHATROOM_URL"
        const val API_CLIENT = "API_CLIENT"
    }
    @Provides
    @Named(WEBSOCKET_CLIENT)
    fun providesWebsocketHttpClient(): HttpClient {
        return WebsocketClient.client
    }
    @Provides
    @Named(WEBSOCKET_URL_NAME)
    fun providesWebsocketURL(): String {
        return WEBSOCKET_URL
    }
    @Binds
    abstract fun providesMessagesRepository(
        messagesRepository: MessagesRepository
    ): IMessagesRepository
    @Provides
    @Named(API_CLIENT)
    fun providesAPIHttpClient(): HttpClient {
        return RestClient.client
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1023.1">As both </span><a id="_idIndexMarker234" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1024.1">the </span><strong class="source-inline"><span class="kobospan" id="kobo.1025.1">providesWebsocketClient</span></strong><span class="kobospan" id="kobo.1026.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.1027.1">providesApiHttpClient</span></strong><span class="kobospan" id="kobo.1028.1"> functions are returning the same type (</span><strong class="source-inline"><span class="kobospan" id="kobo.1029.1">HttpClient</span></strong><span class="kobospan" id="kobo.1030.1">), we need them to be identifiable so that we can indicate to Hilt which dependency it should provide to </span><strong class="source-inline"><span class="kobospan" id="kobo.1031.1">WebsocketDataSource</span></strong><span class="kobospan" id="kobo.1032.1"> and which one goes to </span><strong class="source-inline"><span class="kobospan" id="kobo.1033.1">ChatRoomDataSource</span></strong><span class="kobospan" id="kobo.1034.1">. </span><span class="kobospan" id="kobo.1034.2">That’s the reason we are </span><span><span class="kobospan" id="kobo.1035.1">using qualifiers.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1036.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1037.1">Using qualifiers </span><a id="_idIndexMarker235" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1038.1">allows the </span><strong class="bold"><span class="kobospan" id="kobo.1039.1">dependency injection</span></strong><span class="kobospan" id="kobo.1040.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1041.1">DI</span></strong><span class="kobospan" id="kobo.1042.1">) framework to determine the correct instance of a dependency to inject when there are multiple instances available of the same type. </span><span class="kobospan" id="kobo.1042.2">This ensures that the right instance is provided, preventing conflicts or ambiguity in your </span><span><span class="kobospan" id="kobo.1043.1">dependency management.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1044.1">In the </span><a id="_idIndexMarker236" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1045.1">next code block, we are using a </span><strong class="source-inline"><span class="kobospan" id="kobo.1046.1">WEBSOCKET_CLIENT</span></strong><span class="kobospan" id="kobo.1047.1"> constant as the qualifier for the WebSocket </span><strong class="source-inline"><span class="kobospan" id="kobo.1048.1">HttpClient</span></strong><span class="kobospan" id="kobo.1049.1"> instance and </span><strong class="source-inline"><span class="kobospan" id="kobo.1050.1">API_CLIENT</span></strong><span class="kobospan" id="kobo.1051.1"> for the REST API </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1052.1">HttpClient</span></strong></span><span><span class="kobospan" id="kobo.1053.1"> instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1054.1">
@Provides
@Named(WEBSOCKET_CLIENT)
fun providesWebsocketHttpClient(): HttpClient {
    return WebsocketClient.client
}
@Provides
@Named(API_CLIENT)
fun providesAPIHttpClient(): HttpClient {
    return RestClient.client
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1055.1">We should also use qualifiers to provide URLs for the WebSocket and for the API. </span><span class="kobospan" id="kobo.1055.2">Also, it is important to note that these URL values are now being provided by a companion object in </span><strong class="source-inline"><span class="kobospan" id="kobo.1056.1">ChatModule</span></strong><span class="kobospan" id="kobo.1057.1"> for simplification, but a better approach would be to have them defined as part of our Gradle file. </span><span class="kobospan" id="kobo.1057.2">That way, we will be able to override them depending on the build variant (release, debug, test, and so on) </span><span><span class="kobospan" id="kobo.1058.1">or flavor.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1059.1">Regarding the qualifiers, we also need to indicate in the consumers of these dependencies which one should be injected. </span><span class="kobospan" id="kobo.1059.2">This will be done using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1060.1">@Named</span></strong><span class="kobospan" id="kobo.1061.1"> annotation in the affected dependencies </span><span><span class="kobospan" id="kobo.1062.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1063.1">
class ChatRoomDataSource @Inject constructor(
    @Named(API_CLIENT) private val client: HttpClient,
    @Named(API_CHAT_ROOM_URL_NAME) private val url: String
) {
    suspend fun getInitialChatRoom(id: String):
    ChatRoomModel {
        return client.get(url.format(id)).body()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1064.1">Also, we have </span><a id="_idIndexMarker237" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1065.1">to modify the constructor in </span><strong class="source-inline"><span class="kobospan" id="kobo.1066.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.1067.1"> so that Hilt knows which one it has </span><span><span class="kobospan" id="kobo.1068.1">to inject:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1069.1">
class MessagesSocketDataSource @Inject constructor(
    @Named(WEBSOCKET_CLIENT) private val httpClient:
        HttpClient,
    @Named(WEBSOCKET_URL_NAME) private val websocketUrl:
        String
) { ... </span><span class="kobospan1" id="kobo.1069.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1070.1">Now that we have everything ready for our dependencies to be injected the correct way, it is time to implement the </span><strong class="source-inline"><span class="kobospan" id="kobo.1071.1">ChatRoomRepository</span></strong><span class="kobospan" id="kobo.1072.1"> component. </span><span class="kobospan" id="kobo.1072.2">We will implement it in a similar way that we implemented the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1073.1">MessagesRepository</span></strong></span><span><span class="kobospan" id="kobo.1074.1"> component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1075.1">First, we want to create an interface in our </span><span><span class="kobospan" id="kobo.1076.1">domain package:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1077.1">
package com.packt.feature.chat.domain
import com.packt.feature.chat.domain.models.ChatRoom
interface IChatRoomRepository {
    suspend fun getInitialChatRoom(id: String): ChatRoom
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1078.1">Then, we will </span><a id="_idIndexMarker238" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1079.1">create the actual implementation in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1080.1">data.repository</span></strong></span><span><span class="kobospan" id="kobo.1081.1"> package:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1082.1">
package com.packt.feature.chat.data.network.repository
import com.packt.feature.chat.data.network.datasource
.ChatRoomDataSource
import com.packt.feature.chat.domain.IChatRoomRepository
import com.packt.feature.chat.domain.models.ChatRoom
import javax.inject.Inject
class ChatRoomRepository @Inject constructor(
    private val dataSource: ChatRoomDataSource
): IChatRoomRepository {
    override suspend fun getInitialChatRoom(id: String):
    ChatRoom {
        val chatRoomApiModel =
            dataSource.getInitialChatRoom(id)
        return chatRoomApiModel.toDomain()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1083.1">Here, we are obtaining the initial chat room information from the data source, and then we will map the obtained data model into the </span><span><span class="kobospan" id="kobo.1084.1">domain model.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1085.1">Of course, this will not work unless we create the domain </span><span><span class="kobospan" id="kobo.1086.1">model, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1087.1">ChatRoom</span></strong></span><span><span class="kobospan" id="kobo.1088.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1089.1">
package com.packt.feature.chat.domain.models
data class ChatRoom(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val lastMessages: List&lt;Message&gt;
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1090.1">Then, we </span><a id="_idIndexMarker239" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1091.1">should create the mapping </span><span><span class="kobospan" id="kobo.1092.1">from </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1093.1">ChatRoomModel</span></strong></span><span><span class="kobospan" id="kobo.1094.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1095.1">
@Serializable
data class ChatRoomModel(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val lastMessages: List&lt;WebsocketMessageModel&gt;
) {
    fun toDomain(): ChatRoom {
        return ChatRoom(
            id = id,
            senderName = senderName,
            senderAvatar = senderAvatar,
            lastMessages = lastMessages.map { it.toDomain() }
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1096.1">Here, we have just added the </span><strong class="source-inline"><span class="kobospan" id="kobo.1097.1">toDomain()</span></strong><span class="kobospan" id="kobo.1098.1"> function, which will map the data object (</span><strong class="source-inline"><span class="kobospan" id="kobo.1099.1">ChatRoomModel</span></strong><span class="kobospan" id="kobo.1100.1">) to the domain </span><span><span class="kobospan" id="kobo.1101.1">object (</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1102.1">ChatRoom</span></strong></span><span><span class="kobospan" id="kobo.1103.1">).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1104.1">Now, we need </span><a id="_idIndexMarker240" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1105.1">to bind the repository interface to its implementation. </span><span class="kobospan" id="kobo.1105.2">For that, we should add a binding declaration to our </span><span><span class="kobospan" id="kobo.1106.1">Hilt module:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1107.1">
@Binds
abstract fun providesChatRoomRepository(
    chatRoomRepository: ChatRoomRepository
): IChatRoomRepository</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1108.1">Here, we are saying to Hilt that every time it needs to provide an </span><strong class="source-inline"><span class="kobospan" id="kobo.1109.1">IChatRoomRepository</span></strong><span class="kobospan" id="kobo.1110.1"> dependency, it should </span><span><span class="kobospan" id="kobo.1111.1">provide </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1112.1">ChatRoomRepository</span></strong></span><span><span class="kobospan" id="kobo.1113.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1114.1">Now, we have the data source and the repository ready. </span><span class="kobospan" id="kobo.1114.2">We will need to implement a new use case whose responsibility will be to provide this </span><span><span class="kobospan" id="kobo.1115.1">initial information:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1116.1">
package com.packt.feature.chat.domain.usecases
import com.packt.feature.chat.domain.IChatRoomRepository
import com.packt.feature.chat.domain.models.ChatRoom
import javax.inject.Inject
class GetInitialChatRoomInformation @Inject constructor(
    private val repository: IChatRoomRepository
) {
    suspend operator fun invoke(id: String): ChatRoom {
        return repository.getInitialChatRoom(id)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1117.1">Here, we will be calling the repository </span><strong class="source-inline"><span class="kobospan" id="kobo.1118.1">getInitialChatRoom()</span></strong><span class="kobospan" id="kobo.1119.1"> function, to obtain it in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1120.1">ChatRoom</span></strong></span><span><span class="kobospan" id="kobo.1121.1"> model.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1122.1">We are </span><a id="_idIndexMarker241" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1123.1">now arriving at our destination: the </span><strong class="source-inline"><span class="kobospan" id="kobo.1124.1">ViewModel</span></strong><span class="kobospan" id="kobo.1125.1">. </span><span class="kobospan" id="kobo.1125.2">We need to </span><span><span class="kobospan" id="kobo.1126.1">include </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1127.1">GetInitial</span></strong></span><strong class="source-inline"><span class="kobospan" id="kobo.1128.1">
ChatRoomInformation</span></strong><span class="kobospan" id="kobo.1129.1"> as a dependency on the </span><strong class="source-inline"><span class="kobospan" id="kobo.1130.1">ViewModel</span></strong><span class="kobospan" id="kobo.1131.1">, obtain this information when it is initialized, and make it available for the UI to </span><span><span class="kobospan" id="kobo.1132.1">observe it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1133.1">
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val retrieveMessages: RetrieveMessages,
    private val sendMessage: SendMessage,
    private val disconnectMessages: DisconnectMessages,
    private val getInitialChatRoomInformation:
        GetInitialChatRoomInformation
) : ViewModel() {...}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1134.1">Next, we need to create a new </span><strong class="source-inline"><span class="kobospan" id="kobo.1135.1">StateFlow</span></strong><span class="kobospan" id="kobo.1136.1"> instance to be consumed by the UI. </span><span class="kobospan" id="kobo.1136.2">As it is going to hold the state of almost all the UI (except the messages; we will talk about this later), we are going to call </span><span><span class="kobospan" id="kobo.1137.1">it </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1138.1">uiState</span></strong></span><span><span class="kobospan" id="kobo.1139.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1140.1">
private val _uiState = MutableStateFlow(Chat())
val uiState: StateFlow&lt;Chat&gt; = _uiState</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1141.1">Now, we are going to add a new function to be called upon </span><span><span class="kobospan" id="kobo.1142.1">view initialization:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1143.1">
fun loadChatInformation(id: String) {
    messageCollectionJob =
    viewModelScope.launch(Dispatchers.IO) {
        val chatRoom = getInitialChatRoomInformation(id)
        withContext(Dispatchers.Main) {
            _uiState.value = chatRoom.toUI()
            _messages.value = chatRoom.lastMessages.map {
                it.toUI()}
            updateMessages()
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1144.1">Here, we are using </span><strong class="source-inline"><span class="kobospan" id="kobo.1145.1">messagesCollectionJob</span></strong><span class="kobospan" id="kobo.1146.1"> (we could change its name to make it more </span><a id="_idIndexMarker242" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1147.1">generic as now it is going to be used by the </span><strong class="source-inline"><span class="kobospan" id="kobo.1148.1">messages</span></strong><span class="kobospan" id="kobo.1149.1"> collection job and the initial </span><span><span class="kobospan" id="kobo.1150.1">data retrieval).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1151.1">Then, we retrieve the initial chat room information, update the </span><strong class="source-inline"><span class="kobospan" id="kobo.1152.1">uiState</span></strong><span class="kobospan" id="kobo.1153.1"> value, and set the messages we are receiving as the first messages in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1154.1">messages</span></strong> <strong class="source-inline"><span class="kobospan" id="kobo.1155.1">StateFlow</span></strong><span class="kobospan" id="kobo.1156.1"> object (so that the chat will show the </span><span><span class="kobospan" id="kobo.1157.1">old messages).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1158.1">Finally, we call the </span><strong class="source-inline"><span class="kobospan" id="kobo.1159.1">updateMessages()</span></strong><span class="kobospan" id="kobo.1160.1"> function, where we will connect to the WebSocket and start getting </span><span><span class="kobospan" id="kobo.1161.1">asynchronous messages.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1162.1">Note that we will also need a </span><strong class="source-inline"><span class="kobospan" id="kobo.1163.1">Chat</span></strong><span class="kobospan" id="kobo.1164.1"> model that will be our </span><strong class="source-inline"><span class="kobospan" id="kobo.1165.1">uiState</span></strong><span class="kobospan" id="kobo.1166.1"> instance; this model is important as it will be the object consumed from the UI to configure it. </span><span class="kobospan" id="kobo.1166.2">Add this </span><span><span class="kobospan" id="kobo.1167.1">like so:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1168.1">
data class Chat(
    val id: String? </span><span class="kobospan1" id="kobo.1168.2">= null,
    val name: String? </span><span class="kobospan1" id="kobo.1168.3">= null,
    val avatar: String? </span><span class="kobospan1" id="kobo.1168.4">= null
)
fun ChatRoom.toUI() = run {
    Chat(
        id = id,
        name = senderName,
        avatar = senderAvatar
    )
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1169.1">Now, we need </span><a id="_idIndexMarker243" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1170.1">to listen to this </span><strong class="source-inline"><span class="kobospan" id="kobo.1171.1">uiState</span></strong><span class="kobospan" id="kobo.1172.1"> instance from our screen composable and update the UI </span><span><span class="kobospan" id="kobo.1173.1">accordingly:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1174.1">
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel(),
    chatId: String?,
    onBack: () -&gt; Unit
) {
    val messages by viewModel.messages.collectAsState()
</span><strong class="bold1"><span class="kobospan1" id="kobo.1175.1">    val uiState by viewModel.uiState.collectAsState()</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1176.1">    LaunchedEffect(Unit) {</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1177.1">        viewModel.loadChatInformation(chatId.orEmpty())</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1178.1">    }</span></strong><span class="kobospan1" id="kobo.1179.1">
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
</span><strong class="bold1"><span class="kobospan1" id="kobo.1180.1">                   Text(stringResource(R.string.chat_title,</span></strong>
<strong class="bold1"><span class="kobospan1" id="kobo.1181.1">                   uiState.name.orEmpty()))</span></strong><span class="kobospan1" id="kobo.1182.1">
                }
            )
        },
        bottomBar = {
            SendMessageBox { viewModel.onSendMessage(it) }
        }
    ) { paddingValues-&gt;
        ListOfMessages(paddingValues = paddingValues,
        messages = messages)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1183.1">Here, we can see that we are calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.1184.1">loadChatInformation</span></strong><span class="kobospan" id="kobo.1185.1"> function as soon as the </span><strong class="source-inline"><span class="kobospan" id="kobo.1186.1">Composable</span></strong><span class="kobospan" id="kobo.1187.1"> component is started. </span><span class="kobospan" id="kobo.1187.2">Then, once this information is obtained, we would show the name of the participant of the chat in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1188.1">TopAppBar</span></strong><span class="kobospan" id="kobo.1189.1"> component, obtaining </span><a id="_idIndexMarker244" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1190.1">this info from the chat initialization. </span><span class="kobospan" id="kobo.1190.2">At the same time, the list of messages will be updated with the </span><span><span class="kobospan" id="kobo.1191.1">last messages.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1192.1">Usually, it is desirable to encapsulate all the </span><strong class="source-inline"><span class="kobospan" id="kobo.1193.1">uiState</span></strong><span class="kobospan" id="kobo.1194.1"> properties in a single observable value as one of the advantages of Jetpack Compose is that it will handle the recomposition when it detects that the values related to a </span><strong class="source-inline"><span class="kobospan" id="kobo.1195.1">Composable</span></strong><span class="kobospan" id="kobo.1196.1"> component have changed. </span><span class="kobospan" id="kobo.1196.2">In this case, the criteria followed have been to separate them because in reality, the frequency of changes is very different between the </span><span><span class="kobospan" id="kobo.1197.1">two values:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.1198.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1199.1">uiState</span></strong><span class="kobospan" id="kobo.1200.1"> properties are not going to change for the </span><span><span class="kobospan" id="kobo.1201.1">same chat</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1202.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.1203.1">messages</span></strong><span class="kobospan" id="kobo.1204.1"> list is likely to change with a high frequency (every time we send and receive </span><span><span class="kobospan" id="kobo.1205.1">a message)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1206.1">During this section, we have set up our chat initialization, including all the components needed for the architecture, from the data source to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1207.1">ViewModel</span></strong><span class="kobospan" id="kobo.1208.1"> changes. </span><span class="kobospan" id="kobo.1208.2">Now, it is time we take care of possible errors we could encounter and give some resilience to our </span><span><span class="kobospan" id="kobo.1209.1">chat screen.</span></span></p>
<h2 id="_idParaDest-50" class="calibre7"><a id="_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1210.1">Handling errors in the WebSocket</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1211.1">Errors are not unusual, especially in a long-lived connection such as a WebSocket, and in such a </span><a id="_idIndexMarker245" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1212.1">sensitive environment as a mobile one, it is important to take care of these errors because otherwise, our users could stop being able to send </span><a id="_idIndexMarker246" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1213.1">or receive messages and, in the worst case, have a fatal error that crashes </span><span><span class="kobospan" id="kobo.1214.1">the application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1215.1">There are several ways we can control these errors. </span><span class="kobospan" id="kobo.1215.2">One of them is to make every layer responsible for errors that could happen in its scope and only propagate to the UI (or the user knowledge) when the app cannot recover itself </span><span><span class="kobospan" id="kobo.1216.1">from them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1217.1">Here, we could have </span><span><span class="kobospan" id="kobo.1218.1">several errors:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.1219.1">Connection errors that are recuperable errors and will be handled by </span><span><span class="kobospan" id="kobo.1220.1">a retry</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1221.1">Parsing errors that are likely not recuperable as several retries will not change the way the app or the backend are formatting the messages (we cannot do much with these kinds of errors, apart from detecting them before deploying the app or having analytics tools to </span><span><span class="kobospan" id="kobo.1222.1">detect them)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1223.1">In this section, we are going to focus on </span><strong class="source-inline"><span class="kobospan" id="kobo.1224.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.1225.1">. </span><span class="kobospan" id="kobo.1225.2">If we take a look at our </span><strong class="source-inline"><span class="kobospan" id="kobo.1226.1">connect</span></strong><span class="kobospan" id="kobo.1227.1"> function, we can see it could have some points of failure (for example, when initiating the session or when the message received is handled). </span><span class="kobospan" id="kobo.1227.2">The simplest way to solve this is to wrap those points with </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1228.1">try</span></strong></span><span><span class="kobospan" id="kobo.1229.1">-</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1230.1">catch</span></strong></span><span><span class="kobospan" id="kobo.1231.1"> blocks:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1232.1">
suspend fun connect(): Flow&lt;Message&gt; {
    return flow {
        // Wrap the connection attempt with a try-catch
           block
        try {
            httpClient.webSocketSession { url(websocketUrl) }
                .apply { webSocketSession = this }
                .incoming
                .receiveAsFlow()
                .collect { frame -&gt;
                    try {
                        // Handle errors while processing
                           the message
                        val message =
                            webSocketSession.handleMessage(
                                frame)?.toDomain()
                        if (message != null) {
                            emit(message)
                        }
                    } catch (e: Exception) {
                        // Log or handle the error
                           gracefully
                        Log.e(TAG, "Error handling
                            WebSocket frame", e)
                    }
                }
        } catch (e: Exception) {
            // Log or handle the connection error
               gracefully
            Log.e(TAG, "Error connecting to WebSocket", e)
        }
    }.retryWhen { cause, attempt -&gt;
        // Implement a retry strategy based on the cause
           and/or the number of attempts
        if (cause is IOException &amp;&amp; attempt &lt; MAX_RETRIES)
        {
            delay(RETRY_DELAY)
            true
        } else {
            false
        }
    }.catch { e -&gt;
        // Handle exceptions from the Flow
        Log.e(TAG, "Error in WebSocket Flow", e)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1233.1">We need </span><a id="_idIndexMarker247" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1234.1">to define also as constants </span><strong class="source-inline"><span class="kobospan" id="kobo.1235.1">TAG</span></strong><span class="kobospan" id="kobo.1236.1"> (to log messages in Logcat), </span><strong class="source-inline"><span class="kobospan" id="kobo.1237.1">MAX_RETRIES</span></strong><span class="kobospan" id="kobo.1238.1">, which will be the number of retries we are going to use (because we cannot be eternally retrying), and </span><strong class="source-inline"><span class="kobospan" id="kobo.1239.1">RETRY_DELAY</span></strong><span class="kobospan" id="kobo.1240.1"> (the milliseconds we are </span><a id="_idIndexMarker248" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1241.1">going to wait </span><span><span class="kobospan" id="kobo.1242.1">between retries):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1243.1">
companion object {
    const val TAG = "MessagesSocketDataSource"
    const val RETRY_DELAY = 30000
    const val MAX_RETRIES = 5
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1244.1">Here, we are defining these values as constants, so if the WebSocket connection fails, we will retry the connection in another 30 seconds (</span><strong class="source-inline"><span class="kobospan" id="kobo.1245.1">30000</span></strong><span class="kobospan" id="kobo.1246.1"> milliseconds). </span><span class="kobospan" id="kobo.1246.2">This will occur </span><strong class="source-inline"><span class="kobospan" id="kobo.1247.1">5</span></strong><span class="kobospan" id="kobo.1248.1"> times before giving up if it doesn’t </span><span><span class="kobospan" id="kobo.1249.1">successfully connect.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1250.1">Now that our users are receiving messages while using the app, we still need to provide a way of notifying them when they receive a new message but are not using the app. </span><span class="kobospan" id="kobo.1250.2">We can solve this problem by using </span><span><span class="kobospan" id="kobo.1251.1">push notifications.</span></span></p>
<h1 id="_idParaDest-51" class="calibre5"><a id="_idTextAnchor051" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1252.1">Adding push notifications</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1253.1">Push notifications are messages that are sent to a user’s device from a server, even when the </span><a id="_idIndexMarker249" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1254.1">user is not actively using the app. </span><span class="kobospan" id="kobo.1254.2">These messages appear as system notifications outside of the app and can be used to provide updates, alerts, or other relevant information </span><span><span class="kobospan" id="kobo.1255.1">to users.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1256.1">To send push notifications, we need to decide which of the available options we want to use. </span><span class="kobospan" id="kobo.1256.2">The </span><a id="_idIndexMarker250" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1257.1">most popular is </span><strong class="bold"><span class="kobospan" id="kobo.1258.1">Firebase Cloud Messaging</span></strong><span class="kobospan" id="kobo.1259.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1260.1">FCM</span></strong><span class="kobospan" id="kobo.1261.1">), but there are more push notification services such as OneSignal, Pusher, or </span><strong class="bold"><span class="kobospan" id="kobo.1262.1">Amazon Simple Notification Service</span></strong><span class="kobospan" id="kobo.1263.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1264.1">SNS</span></strong><span class="kobospan" id="kobo.1265.1">). </span><span class="kobospan" id="kobo.1265.2">In our case, we are going to take </span><a id="_idIndexMarker251" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1266.1">the popular route and </span><span><span class="kobospan" id="kobo.1267.1">use FCM.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1268.1">Firebase</span></strong><span class="kobospan" id="kobo.1269.1"> is a mobile </span><a id="_idIndexMarker252" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1270.1">and web application development platform provided by Google. </span><span class="kobospan" id="kobo.1270.2">It offers a suite of tools, services, and infrastructure designed to help developers build, improve, and grow their apps. </span><span class="kobospan" id="kobo.1270.3">Some of its features include authentication, push notifications, cloud databases, and so on. </span><span class="kobospan" id="kobo.1270.4">We are going to use it for the last two sections of </span><span><span class="kobospan" id="kobo.1271.1">this chapter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1272.1">To accomplish that, we first need to set up Firebase in </span><span><span class="kobospan" id="kobo.1273.1">our project.</span></span></p>
<h2 id="_idParaDest-52" class="calibre7"><a id="_idTextAnchor052" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1274.1">Setting up Firebase</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1275.1">To set </span><a id="_idIndexMarker253" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1276.1">up Firebase in our project, we need to follow </span><span><span class="kobospan" id="kobo.1277.1">these steps:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.1278.1">Go to the Firebase console (</span><a href="https://console.firebase.google.com/" class="calibre6 pcalibre1 pcalibre"><span class="kobospan" id="kobo.1279.1">https://console.firebase.google.com/</span></a><span class="kobospan" id="kobo.1280.1">) and click </span><strong class="bold"><span class="kobospan" id="kobo.1281.1">Add project</span></strong><span class="kobospan" id="kobo.1282.1">. </span><span class="kobospan" id="kobo.1282.2">Then, follow the onscreen instructions to set up </span><span><span class="kobospan" id="kobo.1283.1">your project.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1284.1">In the Firebase console, click on the Android icon to register your app. </span><span class="kobospan" id="kobo.1284.2">Enter your app’s package name, and optionally, provide the SHA-1 fingerprint for Google Sign-In and other authentication features. </span><span class="kobospan" id="kobo.1284.3">Click </span><strong class="bold"><span class="kobospan" id="kobo.1285.1">Register app</span></strong> <span><span class="kobospan" id="kobo.1286.1">to proceed.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1287.1">After registering our app, we’ll be prompted to download a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1288.1">google-services.json</span></strong><span class="kobospan" id="kobo.1289.1"> file. </span><span class="kobospan" id="kobo.1289.2">Download it and place it in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1290.1">app</span></strong><span class="kobospan" id="kobo.1291.1"> module of our Android project, at the </span><span><span class="kobospan" id="kobo.1292.1">root level.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1293.1">Add Firebase SDK dependencies to your project’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.1294.1">build.gradle</span></strong><span class="kobospan" id="kobo.1295.1"> files, </span><span><span class="kobospan" id="kobo.1296.1">like so:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1297.1">
classpath 'com.google.gms:google-services:
$latest_version'</span></pre></li> <li class="calibre14"><span class="kobospan" id="kobo.1298.1">Then in </span><a id="_idIndexMarker254" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1299.1">the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1300.1">app</span></strong><span class="kobospan" id="kobo.1301.1"> module’s </span><strong class="source-inline1"><span class="kobospan" id="kobo.1302.1">build.gradle</span></strong><span class="kobospan" id="kobo.1303.1"> file where we are going to use it (in our case, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1304.1">:common:data</span></strong><span class="kobospan" id="kobo.1305.1">), we should add these dependencies for the following specific </span><span><span class="kobospan" id="kobo.1306.1">Firebase services:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1307.1">
implementation platform('com.google.firebase:
    firebase-bom:$latest_version')
implementation 'com.google.firebase:firebase-auth'
implementation 'com.google.firebase:
    firebase-firestore'
implementation 'com.google.firebase:
    firebase-messaging'</span></pre><p class="calibre3"><span class="kobospan" id="kobo.1308.1">Note that, as we </span><a id="_idIndexMarker255" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1309.1">did with Jetpack Compose dependencies, here we are going to use the </span><strong class="bold"><span class="kobospan" id="kobo.1310.1">Bill of Materials</span></strong><span class="kobospan" id="kobo.1311.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1312.1">BoM</span></strong><span class="kobospan" id="kobo.1313.1">). </span><span class="kobospan" id="kobo.1313.2">The advantage is that we don’t need to specify the version of every dependency because the compatible ones will be provided by </span><span><span class="kobospan" id="kobo.1314.1">the BoM.</span></span></p></li> </ol>
<p class="callout-heading"><span class="kobospan" id="kobo.1315.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1316.1">A BoM is a mechanism used in dependency management systems to specify and manage the versions of multiple libraries and their transitive dependencies as a single entity. </span><span class="kobospan" id="kobo.1316.2">It helps simplify dependency management and ensures compatibility between different libraries that are part of the same ecosystem </span><span><span class="kobospan" id="kobo.1317.1">or suite.</span></span></p>
<ol class="calibre13">
<li value="6" class="calibre14"><span class="kobospan" id="kobo.1318.1">Also, in order to facilitate the use of coroutines to handle Firebase tasks, we are going to add this </span><span><span class="kobospan" id="kobo.1319.1">extra dependency:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1320.1">
implementation 'org.jetbrains.kotlinx:
kotlinx-coroutines-play-services:$latest_version'</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1321.1">Now, before we can receive a push notification, we need to identify our user. </span><span class="kobospan" id="kobo.1321.2">We do that by sending their token </span><span><span class="kobospan" id="kobo.1322.1">to Firebase.</span></span></p>
<h2 id="_idParaDest-53" class="calibre7"><a id="_idTextAnchor053" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1323.1">Sending the FCM token to Firebase</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1324.1">To identify </span><a id="_idIndexMarker256" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1325.1">our users and send notifications </span><a id="_idIndexMarker257" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1326.1">specifically to them using FCM, we need to use FCM </span><strong class="bold"><span class="kobospan" id="kobo.1327.1">tokens</span></strong><span class="kobospan" id="kobo.1328.1">. </span><span class="kobospan" id="kobo.1328.2">Each user is assigned a unique FCM token, which is used to send </span><a id="_idIndexMarker258" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1329.1">notifications to their devices. </span><span class="kobospan" id="kobo.1329.2">This token should be obtained and updated every time the user signs in or when the </span><span><span class="kobospan" id="kobo.1330.1">app starts.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1331.1">We can obtain the FCM token by calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.1332.1">getToken()</span></strong><span class="kobospan" id="kobo.1333.1"> method from the </span><strong class="source-inline"><span class="kobospan" id="kobo.1334.1">FirebaseMessaging</span></strong><span class="kobospan" id="kobo.1335.1"> class. </span><span class="kobospan" id="kobo.1335.2">To do that, we are going first to create a data source that will wrap the </span><span><span class="kobospan" id="kobo.1336.1">token-handling functionality:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1337.1">
package com.packt.data
import com.google.firebase.messaging.FirebaseMessaging
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
class FCMTokenDataSource @Inject constructor(
    private val firebaseMessaging: FirebaseMessaging =
    FirebaseMessaging.getInstance()
) {
    suspend fun getFcmToken(): String? </span><span class="kobospan1" id="kobo.1337.2">{
        return try {
            FirebaseMessaging.getInstance().token.await()
        } catch (e: Exception) {
            null
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1338.1">Here, we are injecting the </span><strong class="source-inline"><span class="kobospan" id="kobo.1339.1">FirebaseMessaging</span></strong><span class="kobospan" id="kobo.1340.1"> instance and obtaining the FCM token </span><span><span class="kobospan" id="kobo.1341.1">from Firebase.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1342.1">Now, we need this FCM to be stored somewhere so that when a new message is sent to our users, we know which token is associated with them. </span><span class="kobospan" id="kobo.1342.2">There is no standard way to store it. </span><span class="kobospan" id="kobo.1342.3">Usually, this will be handled in the backend, which is far from the scope of this book. </span><span class="kobospan" id="kobo.1342.4">But we </span><a id="_idIndexMarker259" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1343.1">can prepare the app components needed. </span><span class="kobospan" id="kobo.1343.2">We </span><a id="_idIndexMarker260" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1344.1">are going to create a use case that would be </span><a id="_idIndexMarker261" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1345.1">the orchestrator of obtaining and then sending the FCM to be stored in the backend. </span><span class="kobospan" id="kobo.1345.2">This use case will need a repository to do both tasks: obtaining the token and storing it in </span><span><span class="kobospan" id="kobo.1346.1">our systems.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1347.1">As always, create the interface for our repository in the domain layer (in this case, in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1348.1">:</span></strong><span><strong class="source-inline"><span class="kobospan" id="kobo.1349.1">common:domain</span></strong></span><span><span class="kobospan" id="kobo.1350.1"> module):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1351.1">
interface IFCMTokenRepository {
    suspend fun getFCMToken(): String
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1352.1">Then, we will create the repository implementation in the data </span><span><span class="kobospan" id="kobo.1353.1">layer (</span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1354.1">:common:data</span></strong></span><span><span class="kobospan" id="kobo.1355.1">):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1356.1">
class FCMTokenRepository @Inject constructor(
    private val tokenDataSource: FCMTokenDataSource
) {
    suspend fun getToken(): String? </span><span class="kobospan1" id="kobo.1356.2">{
        return tokenDataSource.getFcmToken()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1357.1">We will use this repository to obtain the token from Firebase. </span><span class="kobospan" id="kobo.1357.2">As said before, we also need to store the token somewhere, so we will create another repository </span><span><span class="kobospan" id="kobo.1358.1">for that:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1359.1">
interface IInternalTokenRepository {
    suspend fun storeToken(userId: String, token: String)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1360.1">We will again leave the implementation empty as it is outside our scope. </span><span class="kobospan" id="kobo.1360.2">The relevant bit to understand here is that the token should be stored so that later, when our user receives a message, we can identify the token and send a push notification to the </span><span><span class="kobospan" id="kobo.1361.1">related device.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1362.1">In the </span><a id="_idIndexMarker262" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1363.1">next code block, we can see how </span><a id="_idIndexMarker263" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1364.1">we are implementing the aforementioned interface, where </span><a id="_idIndexMarker264" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1365.1">you will provide the means to store the data source of </span><span><span class="kobospan" id="kobo.1366.1">your preference:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1367.1">
class InternalTokenRepository(): IInternalTokenRepository {
    override suspend fun storeToken(userId: String, token:
    String) {
        // Store in the data source of your choosing
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1368.1">Now that we have the token sorted, we need to prepare our app to receive </span><span><span class="kobospan" id="kobo.1369.1">push notifications.</span></span></p>
<h2 id="_idParaDest-54" class="calibre7"><a id="_idTextAnchor054" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1370.1">Preparing the app to receive push notifications</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1371.1">Push notifications are messages that pop up on a mobile device. </span><span class="kobospan" id="kobo.1371.2">They are especially useful </span><a id="_idIndexMarker265" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1372.1">when the user is not actively using the application and we need to call their attention. </span><span class="kobospan" id="kobo.1372.2">In this section, we are going to make our app capable of receiving them when a new message </span><span><span class="kobospan" id="kobo.1373.1">is received.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1374.1">To start receiving push notifications, we need to make some modifications to our existing code first. </span><span class="kobospan" id="kobo.1374.2">For example, we have to think about what would we expect to happen if the user clicks on a notification: we may want it to open the </span><strong class="source-inline"><span class="kobospan" id="kobo.1375.1">ChatScreen</span></strong><span class="kobospan" id="kobo.1376.1"> component related to the message notification. </span><span class="kobospan" id="kobo.1376.2">Let’s start with </span><span><span class="kobospan" id="kobo.1377.1">those changes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1378.1">To open the </span><strong class="source-inline"><span class="kobospan" id="kobo.1379.1">ChatScreen</span></strong><span class="kobospan" id="kobo.1380.1"> component directly, we will need to create a link that tells the system that it should open our application showing the </span><strong class="source-inline"><span class="kobospan" id="kobo.1381.1">ChatScreen</span></strong><span class="kobospan" id="kobo.1382.1"> component. </span><span class="kobospan" id="kobo.1382.2">This link is called a </span><span><span class="kobospan" id="kobo.1383.1">deep link.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1384.1">A </span><strong class="bold"><span class="kobospan" id="kobo.1385.1">deep link</span></strong><span class="kobospan" id="kobo.1386.1"> is a type </span><a id="_idIndexMarker266" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1387.1">of link that directs a user to a specific piece of content or page within an Android application rather than just launching the application. </span><span class="kobospan" id="kobo.1387.2">Deep links are used to provide a more seamless user experience by allowing users to jump directly to a particular function, feature, or piece of content within an app from a website, another app, or even a simple text message </span><span><span class="kobospan" id="kobo.1388.1">or email.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1389.1">To create </span><a id="_idIndexMarker267" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1390.1">our deep link, we are going to create an object called </span><strong class="source-inline"><span class="kobospan" id="kobo.1391.1">DeepLinks</span></strong><span class="kobospan" id="kobo.1392.1"> in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1393.1">:common:framework</span></strong><span class="kobospan" id="kobo.1394.1"> module to organize all the deep links we are going to use in </span><span><span class="kobospan" id="kobo.1395.1">our application:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1396.1">
package com.packt.framework.navigation
object DeepLinks {
    const val chatRoute =
        "https://whatspackt.com/chat?chatId={chatId}"
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1397.1">Then, we need to modify our </span><strong class="source-inline"><span class="kobospan" id="kobo.1398.1">NavHost</span></strong><span class="kobospan" id="kobo.1399.1"> component– once the application receives an intent with this deep comlink, the app should navigate to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1400.1">ChatScreen</span></strong><span class="kobospan" id="kobo.1401.1"> component. </span><span class="kobospan" id="kobo.1401.2">To accomplish that, we need to add a </span><strong class="source-inline"><span class="kobospan" id="kobo.1402.1">Deeplink</span></strong><span class="kobospan" id="kobo.1403.1"> instance as an option for the </span><strong class="source-inline"><span class="kobospan" id="kobo.1404.1">ChatScreen</span></strong><span class="kobospan" id="kobo.1405.1"> navigation graph </span><span><span class="kobospan" id="kobo.1406.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1407.1">WhatsPacktNavigation</span></strong></span><span><span class="kobospan" id="kobo.1408.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1409.1">
private fun NavGraphBuilder.addChat(navController:
NavHostController) {
    composable(
        route = NavRoutes.Chat,
        arguments = listOf(
            navArgument(NavRoutes.ChatArgs.ChatId) {
                type = NavType.StringType }),
        deepLinks = listOf(
            navDeepLink {
                uriPattern = DeepLinks.chatRoute
            }
        )
    ) { backStackEntry -&gt;
        val chatId = backStackEntry.arguments?.getString(
            NavRoutes.ChatArgs.ChatId)
        ChatScreen(chatId = chatId, onBack = {
            navController.popBackStack() })
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1410.1">Here, we are adding the deep link pattern that we have in our </span><strong class="source-inline"><span class="kobospan" id="kobo.1411.1">DeepLinks</span></strong><span class="kobospan" id="kobo.1412.1"> object to be included as one of the route options for our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1413.1">ChatScreen</span></strong></span><span><span class="kobospan" id="kobo.1414.1"> component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1415.1">Then, we need to implement a </span><strong class="source-inline"><span class="kobospan" id="kobo.1416.1">FirebaseMessagingService</span></strong><span class="kobospan" id="kobo.1417.1"> function that will catch all the </span><a id="_idIndexMarker268" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1418.1">push notifications that we receive and will allow us to define a channel where notifications will be posted and handled by the Android system, ultimately showing them to the user (if the user has given our app permissions to </span><span><span class="kobospan" id="kobo.1419.1">do that):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1420.1">
class WhatsPacktMessagingService:
FirebaseMessagingService() {
    companion object {
        const val CHANNEL_ID = "Chat_message"
        const val CHANNEL_DESCRIPTION = "Receive a
            notification when a chat message is received"
        const val CHANNEL_TITLE = "New chat message
            notification"
    }
    override fun onMessageReceived(remoteMessage:
    RemoteMessage) {
        super.onMessageReceived(remoteMessage)
        if (remoteMessage.data.isNotEmpty()) {
            // We can extract information such as the
               sender, message content, or chat ID
            val senderName =
                remoteMessage.data["senderName"]
            val messageContent =
                remoteMessage.data["message"]
            val chatId = remoteMessage.data["chatId"]
            val messageId = remoteMessage.data["messageId"]
            // Create and show a notification for the
               received message
            if (chatId != null &amp;&amp; messageId != null) {
                showNotification(senderName, messageId,
                messageContent, chatId)
            }
        }
    }
    private fun showNotification(senderName: String?,
    messageId: String, messageContent: String?,
    chatId: String) {
        // Implement here the notification
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1421.1">Here, we are extracting some information from the message received, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.1422.1">senderName</span></strong><span class="kobospan" id="kobo.1423.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1424.1">messageContent</span></strong><span class="kobospan" id="kobo.1425.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1426.1">chatId</span></strong><span class="kobospan" id="kobo.1427.1">, and so on. </span><span class="kobospan" id="kobo.1427.2">Ideally, we could obtain the information we want to show in </span><span><span class="kobospan" id="kobo.1428.1">the notification.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1429.1">This is just </span><a id="_idIndexMarker269" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1430.1">an example, though – the information structure would depend on the payload contract we already defined with the </span><span><span class="kobospan" id="kobo.1431.1">backend implementation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1432.1">Once we have extracted this information, we need to show </span><span><span class="kobospan" id="kobo.1433.1">the notification:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1434.1">
private fun showNotification(senderName: String?,
messageId: String, messageContent: String?, chatId: String)
{
    val notificationManager = getSystemService(
       Context.NOTIFICATION_SERVICE) as NotificationManager
    // Create a notification channel
    // (if you want to support versions lower than Android
       Oreo, you will have to check the version here)
    val channel = NotificationChannel(
        CHANNEL_ID,
        CHANNEL_TITLE,
        NotificationManager.IMPORTANCE_DEFAULT
    ).apply {
        description = CHANNEL_DESCRIPTION
    }
    notificationManager.createNotificationChannel(channel)
    // Create an Intent to open the chat when the
       notification is clicked. </span><span class="kobospan1" id="kobo.1434.2">Here is where we are going
       to use our newly created deeplink
    val deepLinkUrl =
        DeepLinks.chatRoute.replace("{chatId}", chatId)
    val intent = Intent(Intent.ACTION_VIEW,
    Uri.parse(deepLinkUrl)).apply {
        flags = Intent.FLAG_ACTIVITY_NEW_TASK or
        Intent.FLAG_ACTIVITY_CLEAR_TASK
    }
    // Create a PendingIntent for the Intent
    val pendingIntent = PendingIntent.getActivity(this, 0,
        intent, PendingIntent.FLAG_IMMUTABLE)
    // Build the notification
    val notification = NotificationCompat.Builder(this,
        CHANNEL_ID)
        .setSmallIcon(R.drawable.our_notification_icon_for_
            whatspackt)
        .setContentTitle(senderName)
        .setContentText(messageContent)
        .setContentIntent(pendingIntent)
        .setAutoCancel(true)
        .build()
    // Show the notification
    notificationManager.notify(messageId.toInt(),
        notification)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1435.1">First, we create a </span><strong class="source-inline"><span class="kobospan" id="kobo.1436.1">NotificationChannel</span></strong><span class="kobospan" id="kobo.1437.1"> instance, then the elements we need for our notification (such as </span><strong class="source-inline"><span class="kobospan" id="kobo.1438.1">PendingIntent</span></strong><span class="kobospan" id="kobo.1439.1">, which will be used when the user clicks on the notification), and then </span><a id="_idIndexMarker270" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1440.1">the notification itself (using </span><strong class="source-inline"><span class="kobospan" id="kobo.1441.1">NotificationCompat</span></strong><span class="kobospan" id="kobo.1442.1">). </span><span class="kobospan" id="kobo.1442.2">Finally, we use </span><strong class="source-inline"><span class="kobospan" id="kobo.1443.1">NotificationManager</span></strong><span class="kobospan" id="kobo.1444.1"> to notify our notification to </span><span><span class="kobospan" id="kobo.1445.1">the system.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1446.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1447.1">Creating a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1448.1">NotificationChannel</span></strong><span class="kobospan" id="kobo.1449.1"> instance is necessary for Android 8.0 (API level 26) and higher, as it provides users with better control over the app’s notifications. </span><span class="kobospan" id="kobo.1449.2">Each </span><strong class="source-inline1"><span class="kobospan" id="kobo.1450.1">NotificationChannel</span></strong><span class="kobospan" id="kobo.1451.1"> instance represents a unique category of notifications that an app can display, and users can modify the settings for each channel independently. </span><span class="kobospan" id="kobo.1451.2">This enables users to customize the behavior of your app’s notifications based on </span><span><span class="kobospan" id="kobo.1452.1">their preferences.</span></span></p>
<p class="callout"><span class="kobospan" id="kobo.1453.1">For example, users can set the importance level, enable/disable sound, or set a custom vibration pattern for each channel. </span><span class="kobospan" id="kobo.1453.2">They can also block an entire channel so that they no longer receive notifications from that </span><span><span class="kobospan" id="kobo.1454.1">specific category.</span></span></p>
<p class="callout"><span class="kobospan" id="kobo.1455.1">When you create a </span><strong class="source-inline1"><span class="kobospan" id="kobo.1456.1">NotificationChannel</span></strong><span class="kobospan" id="kobo.1457.1"> instance, you need to set an importance level, which determines how the system presents notifications from that channel to the user. </span><span class="kobospan" id="kobo.1457.2">The importance levels range from high (urgent and makes a sound) to low (no sound or </span><span><span class="kobospan" id="kobo.1458.1">visual interruption).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1459.1">The last </span><a id="_idIndexMarker271" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1460.1">step is to add our service to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1461.1">AndroidManifest.xml</span></strong><span class="kobospan" id="kobo.1462.1"> file, inside the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1463.1">application</span></strong></span><span><span class="kobospan" id="kobo.1464.1"> tag:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1465.1">
&lt;application
    android:allowBackup = "true"
    android:dataExtractionRules =
        "@xml/data_extraction_rules"
    android:fullBackupContent = "@xml/backup_rules"
    android:icon = "@mipmap/ic_launcher"
    android:label = "@string/app_name"
    android:supportsRtl = "true"
    android:theme = "@style/Theme.WhatsPackt"
    tools:targetApi = "31"&gt;
    &lt;activity
        android:name = ".MainActivity"
        android:exported = "true"
        android:label = "@string/app_name"
        android:theme = "@style/Theme.WhatsPackt"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=
                "android.intent.action.MAIN" /&gt;
            &lt;category android:name =
                "android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;service
        android:name =
            "com.packt.data.WhatsPacktMessagingService"
        android:exported = "false"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name =
                "com.google.firebase.MESSAGING_EVENT" /&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;
&lt;/application&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1466.1">And with </span><a id="_idIndexMarker272" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1467.1">that, we have our app ready to receive </span><span><span class="kobospan" id="kobo.1468.1">push notifications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1469.1">In the next section, we are going to see how after all the work we have done to keep our code scalable and decoupled, we can easily use Firebase instead of the WebSocket to send and </span><span><span class="kobospan" id="kobo.1470.1">receive messages.</span></span></p>
<h1 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor055" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1471.1">Replacing the Websocket with Firestore</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1472.1">As we </span><a id="_idIndexMarker273" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1473.1">saw in the previous section, Firebase is a powerful </span><a id="_idIndexMarker274" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1474.1">product that simplifies the implementation of the backend for our apps. </span><span class="kobospan" id="kobo.1474.2">Now, we are going to see how we can use it also to simplify the chat </span><span><span class="kobospan" id="kobo.1475.1">messages feature.</span></span></p>
<h2 id="_idParaDest-56" class="calibre7"><a id="_idTextAnchor056" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1476.1">What is Firestore?</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1477.1">Firestore</span></strong><span class="kobospan" id="kobo.1478.1">, more formally </span><a id="_idIndexMarker275" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1479.1">known as Cloud </span><a id="_idIndexMarker276" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1480.1">Firestore, is a flexible, scalable, and real-time NoSQL database provided by Firebase. </span><span class="kobospan" id="kobo.1480.2">Firestore is designed to store and sync data for client-side applications, making it an ideal choice for building modern, </span><span><span class="kobospan" id="kobo.1481.1">data-driven applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1482.1">One of its most important features is the real-time data synchronization. </span><span class="kobospan" id="kobo.1482.2">Firestore automatically synchronizes data in real time across all connected clients, ensuring that your application’s data is always up to date. </span><span class="kobospan" id="kobo.1482.3">This is especially useful for applications requiring real-time collaboration or live updates, such as our </span><span><span class="kobospan" id="kobo.1483.1">chat app.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1484.1">It is important to note that as a NoSQL database, we would have first to define the data structure. </span><span class="kobospan" id="kobo.1484.2">How are we to structure our documents? </span><span class="kobospan" id="kobo.1484.3">Well, let’s start </span><span><span class="kobospan" id="kobo.1485.1">with that.</span></span></p>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor057" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1486.1">Chat data structure</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1487.1">To handle </span><a id="_idIndexMarker277" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1488.1">chat messages in Firestore NoSQL, we can use the </span><span><span class="kobospan" id="kobo.1489.1">following structure:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.1490.1">Create a collection called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1491.1">chats</span></strong><span class="kobospan" id="kobo.1492.1">. </span><span class="kobospan" id="kobo.1492.2">Each document in this collection will represent a chat room or conversation between users. </span><span class="kobospan" id="kobo.1492.3">The document ID can be generated automatically by Firestore or created using a custom method (for example, a combination of user IDs). </span><span class="kobospan" id="kobo.1492.4">Here, we can include common data that we need for the conversation (think about our </span><strong class="source-inline1"><span class="kobospan" id="kobo.1493.1">ChatRoom</span></strong><span class="kobospan" id="kobo.1494.1"> model), such as the user’s name, avatars, and </span><span><span class="kobospan" id="kobo.1495.1">so on...</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1496.1">For each chat document, create a subcollection called </span><strong class="source-inline1"><span class="kobospan" id="kobo.1497.1">messages</span></strong><span class="kobospan" id="kobo.1498.1">. </span><span class="kobospan" id="kobo.1498.2">This subcollection will store the individual messages for that chat room </span><span><span class="kobospan" id="kobo.1499.1">or conversation.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1500.1">Each document in the </span><strong class="source-inline1"><span class="kobospan" id="kobo.1501.1">messages</span></strong><span class="kobospan" id="kobo.1502.1"> subcollection will represent a single message. </span><span class="kobospan" id="kobo.1502.2">The structure of a message document might include fields such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.1503.1">senderId</span></strong><span class="kobospan" id="kobo.1504.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1505.1">senderName</span></strong><span class="kobospan" id="kobo.1506.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.1507.1">content</span></strong><span class="kobospan" id="kobo.1508.1">, </span><span><span class="kobospan" id="kobo.1509.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.1510.1">timestamp</span></strong></span><span><span class="kobospan" id="kobo.1511.1">.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1512.1">Following that, our structure will look </span><span><span class="kobospan" id="kobo.1513.1">like this:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1514.1">
chats (collection)
  |
  └── chatId1 (document)
        |
        ├── users (subcollection)
        │   |
        │   ├── userId1 (document)
        │   │   ├── userId: "user1"
        │   │   ├── avatarUrl:
                      "https://example.com/avatar1.jpg"
        │   │   └── name: "John Doe"
        │   │
        │   └── userId2 (document)
        │       ├── userId: "user2"
        │       ├── avatarUrl:
                      "https://example.com/avatar2.jpg"
        │       └── name: "Jane Smith"
        │
        └── messages (subcollection)
              |
              ├── messageId1 (document)
              │   ├── senderId: "user1"
              │   ├── senderName: "John Doe"
              │   ├── content: "Hello, how are you?"
</span><span class="kobospan1" id="kobo.1514.2">              │   └── timestamp: 1648749123
              |
              └── messageId2 (document)
                    ├── senderId: "user2"
                    ├── senderName: "Jane Smith"
                    ├── content: "I'm doing great! </span><span class="kobospan1" id="kobo.1514.3">How
                                 about you?"
</span><span class="kobospan1" id="kobo.1514.4">                    └── timestamp: 1648749156</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1515.1">One important aspect is that, ideally, we should have authentication set up to identify our users. </span><span class="kobospan" id="kobo.1515.2">We will learn how to build it in </span><a href="B19443_07.xhtml#_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"><span><em class="italic"><span class="kobospan" id="kobo.1516.1">Chapter 7</span></em></span></a><span class="kobospan" id="kobo.1517.1">, but for now, we are assuming that our users will be authenticated </span><span><span class="kobospan" id="kobo.1518.1">in Firebase.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1519.1">Assuming that </span><a id="_idIndexMarker278" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1520.1">our chat will be used by authenticated users, we can limit and restrict access to the chat collection for modifications only for users who have already been authenticated. </span><span class="kobospan" id="kobo.1520.2">To accomplish that, we can define a set of rules in Firestore, using the Firebase console. </span><span class="kobospan" id="kobo.1520.3">Here is </span><span><span class="kobospan" id="kobo.1521.1">an example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1522.1">
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow authenticated users to create chat documents,
       but not modify or delete them
    match /chats/{chatId} {
      allow create: if request.auth != null;
      allow read, update, delete: if false;
    }
    // Allow chat participants to read the chat's user data
    match /chats/{chatId}/users/{userId} {
      allow read: if request.auth != null &amp;&amp;
        request.auth.uid in resource.data.userId;
      allow write: if false;
    }
    // Allow authenticated users to create/modify messages
       in a chat they are participating in
    match /chats/{chatId}/messages/{messageId} {
      // Get chat participants
      function isChatParticipant() {
        let chatUsersDoc = get(
            /databases/$(database)/documents/chats/
                $(chatId)/users/$(request.auth.uid));
        return chatUsersDoc.exists();
      }
      // Check if the sender is the authenticated user
      function isSender() {
        return request.auth != null &amp;&amp; request.auth.uid ==
          request.resource.data.senderId;
      }
      allow create: if isChatParticipant() &amp;&amp; isSender();
      allow read: if isChatParticipant();
      allow update, delete: if false;
    }
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1523.1">Now that we have defined these rules, we can switch to our Android app code and create a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1524.1">FirestoreMessagesDataSource</span></strong></span><span><span class="kobospan" id="kobo.1525.1"> class.</span></span></p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1526.1">Creating a FirestoreMessagesDataSource class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1527.1">The first step to creating the </span><strong class="source-inline"><span class="kobospan" id="kobo.1528.1">FirestoreMessagesDataSource</span></strong><span class="kobospan" id="kobo.1529.1"> class is to create the model </span><a id="_idIndexMarker279" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1530.1">that we are going to use to serialize the documents. </span><span class="kobospan" id="kobo.1530.2">This model has to include the same fields we included when we designed the </span><strong class="source-inline"><span class="kobospan" id="kobo.1531.1">Message</span></strong> <span><span class="kobospan" id="kobo.1532.1">document structure:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1533.1">
import com.google.firebase.Timestamp
import com.google.firebase.firestore.PropertyName
import com.packt.feature.chat.domain.models.Message
import java.text.SimpleDateFormat
import java.util.*
data class FirestoreMessageModel(
    @Transient
    val id: String = "",
    @get:PropertyName("senderId")
    @set:PropertyName("senderId")
    var senderId: String = "",
    @get:PropertyName("senderName")
    @set:PropertyName("senderName")
    var senderName: String = "",
    @get:PropertyName("senderAvatar")
    @set:PropertyName("senderAvatar")
    var senderAvatar: String = "",
    @get:PropertyName("content")
    @set:PropertyName("content")
    var content: String = "",
    @get:PropertyName("timestamp")
    @set:PropertyName("timestamp")
    var timestamp: Timestamp = Timestamp.now()
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1534.1">Note that we are including a field called </span><strong class="source-inline"><span class="kobospan" id="kobo.1535.1">id</span></strong><span class="kobospan" id="kobo.1536.1"> that has the </span><strong class="source-inline"><span class="kobospan" id="kobo.1537.1">@Transient</span></strong><span class="kobospan" id="kobo.1538.1"> annotation – this field </span><a id="_idIndexMarker280" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1539.1">will store the document </span><strong class="source-inline"><span class="kobospan" id="kobo.1540.1">id</span></strong><span class="kobospan" id="kobo.1541.1"> value (that for us will be the unique identification for the message as every message has its own document). </span><span class="kobospan" id="kobo.1541.2">The reason we have to put the </span><strong class="source-inline"><span class="kobospan" id="kobo.1542.1">@Transient</span></strong><span class="kobospan" id="kobo.1543.1"> annotation is to avoid this </span><strong class="source-inline"><span class="kobospan" id="kobo.1544.1">id</span></strong><span class="kobospan" id="kobo.1545.1"> field being stored in the document itself when writing </span><span><span class="kobospan" id="kobo.1546.1">in Firestore.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1547.1">Now, as we did with the </span><strong class="source-inline"><span class="kobospan" id="kobo.1548.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.1549.1"> class, we need to convert this data model into the domain model. </span><span class="kobospan" id="kobo.1549.2">We already have the </span><strong class="source-inline"><span class="kobospan" id="kobo.1550.1">messages</span></strong><span class="kobospan" id="kobo.1551.1"> domain model, so, in this case, we only have to implement the function to convert the </span><strong class="source-inline"><span class="kobospan" id="kobo.1552.1">FirestoreMessageModel</span></strong><span class="kobospan" id="kobo.1553.1"> data class into our </span><strong class="source-inline"><span class="kobospan" id="kobo.1554.1">Message</span></strong> <span><span class="kobospan" id="kobo.1555.1">domain model:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1556.1">
fun toDomain(userId: String): Message {
    return Message(
        id = id,
        senderName = senderName,
        senderAvatar = senderAvatar,
        isMine = userId == senderId,
        contentType = Message.ContentType.TEXT,
        content = content,
        contentDescription = "",
        timestamp = timestamp.toDateString()
    )
}
private fun Timestamp.toDateString(): String {
    // Create a SimpleDateFormat instance with the desired
       format and the default Locale
    val formatter = SimpleDateFormat("dd/MM/yyyy HH:mm:ss",
        Locale.getDefault())
    // Convert the Timestamp to a Date object
    val date = toDate()
    // Format the Date object using the SimpleDateFormat
       instance
    return formatter.format(date)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1557.1">In this </span><a id="_idIndexMarker281" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1558.1">case, we are supposing we are only going to have text messages (no images) for simplification. </span><span class="kobospan" id="kobo.1558.2">However, it could have been easily done by including a field in the </span><strong class="source-inline"><span class="kobospan" id="kobo.1559.1">Firestore</span></strong><span class="kobospan" id="kobo.1560.1"> model indicating the type of message. </span><span class="kobospan" id="kobo.1560.2">Almost all the mapping between properties is straightforward, with the exception of the timestamp. </span><span class="kobospan" id="kobo.1560.3">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.1561.1">Message</span></strong><span class="kobospan" id="kobo.1562.1"> model, we are expecting a </span><strong class="source-inline"><span class="kobospan" id="kobo.1563.1">String</span></strong><span class="kobospan" id="kobo.1564.1"> object with the date and time, and we are getting a </span><strong class="source-inline"><span class="kobospan" id="kobo.1565.1">Timestamp</span></strong><span class="kobospan" id="kobo.1566.1"> object from Firestore. </span><span class="kobospan" id="kobo.1566.2">So, we are using the </span><strong class="source-inline"><span class="kobospan" id="kobo.1567.1">Timestamp.toDateString()</span></strong><span class="kobospan" id="kobo.1568.1"> extension to obtain the formatted </span><strong class="source-inline"><span class="kobospan" id="kobo.1569.1">String</span></strong><span class="kobospan" id="kobo.1570.1"> object from the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1571.1">Timestamp</span></strong></span><span><span class="kobospan" id="kobo.1572.1"> object.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1573.1">Also, as we would want to send messages too, we need to convert a domain </span><strong class="source-inline"><span class="kobospan" id="kobo.1574.1">Message</span></strong><span class="kobospan" id="kobo.1575.1"> object into the </span><span><span class="kobospan" id="kobo.1576.1">data object:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1577.1">
companion object {
    fun fromDomain(message: Message): FirestoreMessageModel
    {
        return FirestoreMessageModel(
            id = "",
            senderName = message.senderName,
            senderAvatar = message.senderAvatar,
            content = message.content
        )
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1578.1">Note that </span><a id="_idIndexMarker282" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1579.1">we are not setting the timestamp (it will be created when the object is created), and the </span><strong class="source-inline"><span class="kobospan" id="kobo.1580.1">id</span></strong><span class="kobospan" id="kobo.1581.1"> field doesn’t have a real value (as it won’t be stored </span><span><span class="kobospan" id="kobo.1582.1">in Firestore).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1583.1">Now, we can proceed with the </span><strong class="source-inline"><span class="kobospan" id="kobo.1584.1">FirestoreMessagesDataSource</span></strong><span class="kobospan" id="kobo.1585.1"> implementation. </span><span class="kobospan" id="kobo.1585.2">First, we define the class and </span><span><span class="kobospan" id="kobo.1586.1">its dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1587.1">
class FirestoreMessagesDataSource @Inject constructor(
    private val firestore: FirebaseFirestore =
        FirebaseFirestore.getInstance()
) {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1588.1">Then, we are going to add a </span><strong class="source-inline"><span class="kobospan" id="kobo.1589.1">getMessages</span></strong><span class="kobospan" id="kobo.1590.1"> function, to obtain </span><span><span class="kobospan" id="kobo.1591.1">chat messages:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1592.1">
    fun getMessages(chatId: String, userId: String):
    Flow&lt;Message&gt; = callbackFlow {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1593.1">Inside this function, we will get a reference to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1594.1">messages</span></strong><span class="kobospan" id="kobo.1595.1"> subcollection inside the </span><span><span class="kobospan" id="kobo.1596.1">specified chat:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1597.1">
        val chatRef =
            firestore.collection("chats").document(chatId)
                .collection("messages")</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1598.1">Now, we will create a query to get the messages ordered by </span><span><span class="kobospan" id="kobo.1599.1">timestamp (ascending):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1600.1">
        val query = chatRef.orderBy("timestamp",
            Query.Direction.ASCENDING)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1601.1">In the </span><a id="_idIndexMarker283" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1602.1">next step, we add a snapshot listener to the query to listen for real-time updates. </span><span class="kobospan" id="kobo.1602.2">Every time a document in the messages is added, we will get a snapshot of the changed document there so that we can emit it through the flow to the consumers connected (in our </span><span><span class="kobospan" id="kobo.1603.1">case, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1604.1">MessagesRepository</span></strong></span><span><span class="kobospan" id="kobo.1605.1">):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1606.1">
        val listenerRegistration =
        query.addSnapshotListener { snapshot, exception -&gt;
            // If there's an exception, close the Flow with
               the exception
            if (exception != null) {
                close(exception)
                return@addSnapshotListener
            }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1607.1">Just before sending the new messages through the flow, we need to map them to their domain counterpart and provide their ID. </span><span class="kobospan" id="kobo.1607.2">Also, </span><strong class="source-inline"><span class="kobospan" id="kobo.1608.1">userId</span></strong><span class="kobospan" id="kobo.1609.1"> will be needed to identify if the user has written the new message or if it is written by the other user in </span><span><span class="kobospan" id="kobo.1610.1">the conversation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1611.1">
            val messages = snapshot?.documents?.mapNotNull
            { doc -&gt;
                val message =
                    doc.toObject(FirestoreMessageModel::
                    class.java)
                message?.copy(id = doc.id) // Copy the
                                              message with
                                              the document
                                              ID
            } ?: emptyList()
            val domainMessages = messages.map {
                it.toDomain(userId) }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1612.1">Finally, we </span><a id="_idIndexMarker284" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1613.1">can send the list of messages </span><span><span class="kobospan" id="kobo.1614.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1615.1">Flow</span></strong></span><span><span class="kobospan" id="kobo.1616.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1617.1">
            domainMessages.forEach {
                try {
                    trySend(it).isSuccess
                } catch (e: Exception) {
                    close(e)
                }
            }
        }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1618.1">In the case </span><strong class="source-inline"><span class="kobospan" id="kobo.1619.1">Flow</span></strong><span class="kobospan" id="kobo.1620.1"> is no longer needed, we should remove the </span><span><span class="kobospan" id="kobo.1621.1">snapshot listener:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1622.1">
        awaitClose { listenerRegistration.remove() }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1623.1">We also need to add a function to send messages. </span><span class="kobospan" id="kobo.1623.2">To send a message, we will simply add it to the </span><strong class="source-inline"><span class="kobospan" id="kobo.1624.1">messages</span></strong><span class="kobospan" id="kobo.1625.1"> collection in the document with the </span><strong class="source-inline"><span class="kobospan" id="kobo.1626.1">chatId</span></strong><span class="kobospan" id="kobo.1627.1"> value of the </span><span><span class="kobospan" id="kobo.1628.1">related conversation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1629.1">
    fun sendMessage(chatId: String, message: Message) {
        val chatRef =
            firestore.collection("chats").document(chatId)
                .collection("messages")
        chatRef.add(FirestoreMessageModel
            .fromDomain(message))
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1630.1">Next, we </span><a id="_idIndexMarker285" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1631.1">need to replace our previous </span><strong class="source-inline"><span class="kobospan" id="kobo.1632.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.1633.1"> instance in </span><strong class="source-inline"><span class="kobospan" id="kobo.1634.1">MessagesRepository</span></strong> <span><span class="kobospan" id="kobo.1635.1">with </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1636.1">FirestoreMessagesDataSource</span></strong></span><span><span class="kobospan" id="kobo.1637.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1638.1">
class MessagesRepository @Inject constructor(
    //private val dataSource: MessagesSocketDataSource
    private val dataSource: FirestoreMessagesDataSource
): IMessagesRepository {
    override suspend fun getMessages(chatId: String,
    userId: String): Flow&lt;Message&gt; {
        return dataSource.getMessages(chatId, userId)
    }
    override suspend fun sendMessage(chatId: String,
    message: Message) {
        dataSource.sendMessage(chatId, message)
    }
    override suspend fun disconnect() {
        // do nothing, Firestore data source is
           disconnected as soon as the flow has no
           subscribers
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1639.1">And with </span><a id="_idIndexMarker286" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1640.1">some minor changes, we will have integrated this new provider. </span><span class="kobospan" id="kobo.1640.2">The good thing is that, as we have been working following a Clean Architecture, with mappings between layers, we don’t have to change anything in other layers; for example, in </span><strong class="source-inline"><span class="kobospan" id="kobo.1641.1">Usecases</span></strong><span class="kobospan" id="kobo.1642.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1643.1">ViewModel</span></strong><span class="kobospan" id="kobo.1644.1">, or the UI (apart from providing the </span><strong class="source-inline"><span class="kobospan" id="kobo.1645.1">chatId</span></strong><span class="kobospan" id="kobo.1646.1"> value and the </span><strong class="source-inline"><span class="kobospan" id="kobo.1647.1">userId</span></strong><span class="kobospan" id="kobo.1648.1"> value when calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.1649.1">getMessages</span></strong><span class="kobospan" id="kobo.1650.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1651.1">sendMessage</span></strong></span><span><span class="kobospan" id="kobo.1652.1"> methods).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1653.1">We could also have the two data sources living together in the same app (one as a fallback of the other), as the role of the repository is to serve as an orchestrator of the different data sources for a certain entity (in this case, the messages). </span><span class="kobospan" id="kobo.1653.2">We will see more about this in the next chapter as we will want to add local storage to </span><span><span class="kobospan" id="kobo.1654.1">our messages.</span></span></p>
<h1 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor059" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1655.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1656.1">In this chapter, we explored various aspects of building a messaging app for Android. </span><span class="kobospan" id="kobo.1656.2">We discussed different approaches for sending and receiving messages, such as using WebSockets with Ktor or Firebase Firestore. </span><span class="kobospan" id="kobo.1656.3">We also covered how to structure the app using Clean Architecture principles, with separate layers for data, domain, and presentation, to ensure a well-organized and maintainable code base, and saw how easy is to introduce changes (for example, a change in the messages provider) if our architecture components are </span><span><span class="kobospan" id="kobo.1657.1">well decoupled.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1658.1">Then, we delved into handling connection errors and synchronization issues using Kotlin coroutines and Flow, implementing error handling and retry mechanisms for a seamless user experience. </span><span class="kobospan" id="kobo.1658.2">Additionally, we examined the importance of push notifications in messaging apps and demonstrated their implementation using FCM, from setting up FCM in a project to handling </span><span><span class="kobospan" id="kobo.1659.1">incoming notifications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1660.1">By the end of this chapter, you should have a comprehensive understanding of the components and techniques required to build a robust real-time messaging app </span><span><span class="kobospan" id="kobo.1661.1">on Android.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1662.1">Now, let’s move on to learn how we can optimize our WhatsPackt app so that we can back </span><span><span class="kobospan" id="kobo.1663.1">up messages.</span></span></p>
</div>
</body></html>