<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor037" class="calibre6 pcalibre1 pcalibre"/>2</h1>
<h1 id="_idParaDest-38" class="calibre5"><a id="_idTextAnchor038" class="calibre6 pcalibre1 pcalibre"/>Setting Up WhatsPackt’s Messaging Abilities</h1>
<p class="calibre3">In the previous chapter, we created the structure and UI needed for our messaging app, WhatsPackt.</p>
<p class="calibre3">One of the core features of any messaging app is the ability to facilitate 1:1 conversations between two users, so in this chapter, we will delve into the process of connecting our messaging app to a backend server using WebSockets, handling messages within <code>ViewModel</code> instances, and managing synchronization, error handling, and push notifications.</p>
<p class="calibre3">We will begin <a id="_idIndexMarker126" class="calibre6 pcalibre1 pcalibre"/>by exploring <strong class="bold">WebSockets</strong>, a powerful technology that enables bidirectional communication between client and server, providing a solid foundation for real-time messaging in your app. You will learn how to establish a WebSocket connection, send messages, and handle incoming messages from the server.</p>
<p class="calibre3">Next, we will <a id="_idIndexMarker127" class="calibre6 pcalibre1 pcalibre"/>demonstrate how to receive messages in your <strong class="bold">ViewModel</strong>. We will discuss best practices for updating the UI, managing message storage, and handling user interactions, ensuring a smooth and responsive messaging experience for your users.</p>
<p class="calibre3">The chapter will also cover the essential aspects of synchronization and error handling. You will learn how to manage message delivery status, handle intermittent connectivity issues, and gracefully recover from errors, resulting in a resilient and reliable messaging system.</p>
<p class="calibre3">Finally, we will dig into the topic of push notifications, which are vital for alerting users of new messages even when the app is not in the foreground.</p>
<p class="calibre3">By the end of this chapter, you will have gained a comprehensive understanding of the key components and technologies involved in creating a modern messaging app that supports 1:1 conversations using WebSockets and push notifications.</p>
<p class="calibre3">So, in this chapter, we will cover the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Using a WebSocket connection</li>
<li class="calibre14">Receiving messages in our <strong class="source-inline1">ViewModel</strong></li>
<li class="calibre14">Handling synchronization and errors</li>
<li class="calibre14">Adding push notifications</li>
<li class="calibre14">Replacing the WebSocket with Firestore</li>
</ul>
<h1 id="_idParaDest-39" class="calibre5"><a id="_idTextAnchor039" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">As in the previous chapter, you will need to have installed Android Studio (or another editor of your preference).</p>
<p class="calibre3">We are also going to assume that you followed along with the previous chapter. If you haven’t, you can download the previous chapter’s complete code from here: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-1/WhatsPackt</a>.</p>
<p class="calibre3">The code completed in this chapter can also be found at this link: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-2/WhatsPackt</a>.</p>
<h1 id="_idParaDest-40" class="calibre5"><a id="_idTextAnchor040" class="calibre6 pcalibre1 pcalibre"/>Using a WebSocket connection</h1>
<p class="calibre3">As mentioned, WebSockets is a powerful technology that enables bidirectional communication <a id="_idIndexMarker128" class="calibre6 pcalibre1 pcalibre"/>between client and server. In this section, we are going to use a WebSocket connection to connect with our server to obtain and send messages. But before we do that, it is essential to understand the alternatives and the rationale behind choosing WebSockets for our messaging app.</p>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor041" class="calibre6 pcalibre1 pcalibre"/>Why WebSockets?</h2>
<p class="calibre3">There are <a id="_idIndexMarker129" class="calibre6 pcalibre1 pcalibre"/>several options for enabling real-time communication between clients and servers, including the following:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Long polling</strong>: This is when the client sends a request to the server, and the server holds the request until new data is available. Once the server responds with the new data, the client sends another request, and the process repeats.</li>
<li class="calibre14"><strong class="bold">Server-Sent Events (SSE)</strong>: SSE is a unidirectional communication method where the server pushes updates to the client over a single HTTP connection.</li>
<li class="calibre14"><strong class="bold">Real-time cloud databases</strong> (for example, Firebase Firestore): Real-time cloud databases <a id="_idIndexMarker130" class="calibre6 pcalibre1 pcalibre"/>provide an easy-to-use, scalable solution for real-time data synchronization. They automatically push updates to clients whenever data changes, making them suitable for messaging apps.</li>
<li class="calibre14"><strong class="bold">WebSockets</strong>: WebSockets provide full-duplex, bidirectional communication between clients and servers over a single, long-lived connection. They are widely supported across platforms and are an ideal choice for real-time communication in messaging apps.</li>
</ul>
<p class="calibre3">Considering these alternatives, we choose to use WebSockets for our messaging app because they offer the following advantages:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Bidirectional communication</strong>: WebSockets enable simultaneous data transmission <a id="_idIndexMarker131" class="calibre6 pcalibre1 pcalibre"/>between clients and servers, allowing for faster message exchanges and a more responsive user experience</li>
<li class="calibre14"><strong class="bold">Low latency</strong>: Unlike long polling, SSE, and some real-time cloud databases, WebSockets provide low-latency communication, which is crucial for a real-time messaging app</li>
<li class="calibre14"><strong class="bold">Efficient use of resources</strong>: WebSockets maintain a single connection per client, reducing the overhead on both client and server compared to long polling</li>
<li class="calibre14"><strong class="bold">Flexibility and control</strong>: Implementing custom WebSocket communication allows for more fine-grained control over the messaging infrastructure, avoiding potential limitations or constraints imposed by real-time cloud databases</li>
</ul>
<p class="calibre3">For sure, WebSockets also have their disadvantages that we must take into account, such as the following:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Battery and data usage</strong>: Maintaining a persistent connection can lead to increased battery drain and data usage, which may be a concern for mobile users.</li>
<li class="calibre14"><strong class="bold">Complexity</strong>: Implementing WebSocket communication is typically more complex than <a id="_idIndexMarker132" class="calibre6 pcalibre1 pcalibre"/>using RESTful services. You have to handle various scenarios such as reconnection on network changes, which are common in mobile environments.</li>
<li class="calibre14"><strong class="bold">Scalability</strong>: If your application scales to a large number of users, maintaining WebSocket connections for all of them can be resource-intensive on the server side.</li>
</ul>
<p class="calibre3">Although there are some disadvantages, the advantages of using WebSockets — such as real-time bidirectional communication and lower overheads compared to traditional HTTP polling — significantly outweigh these issues, making them a powerful choice for interactive applications.</p>
<p class="calibre3">Let’s start learning how we can integrate WebSockets.</p>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor042" class="calibre6 pcalibre1 pcalibre"/>Integrating WebSockets</h2>
<p class="calibre3">There are <a id="_idIndexMarker133" class="calibre6 pcalibre1 pcalibre"/>several libraries available for integrating WebSockets in Android applications. Some popular options include the following:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">OkHttp</strong>: A popular HTTP client for Android and Java applications that also supports WebSocket communication</li>
<li class="calibre14"><strong class="bold">Scarlet</strong>: A declarative WebSocket library for Kotlin and Java applications, built on top of OkHttp</li>
<li class="calibre14"><strong class="bold">Ktor</strong>: A modern, Kotlin-based framework for building asynchronous servers and clients, including WebSocket support</li>
</ul>
<p class="calibre3">For our app, we will use Ktor due to its ease of use, native support for Kotlin, and extensive documentation.</p>
<h3 class="calibre9">What is Ktor?</h3>
<p class="calibre3">Ktor stands out for its coroutine-based architecture, which allows for non-blocking asynchronous <a id="_idIndexMarker134" class="calibre6 pcalibre1 pcalibre"/>operations, making it particularly suitable for I/O-intensive tasks such as network communication. It’s lightweight and modular, allowing developers to pick and choose only the features they need, thereby avoiding the overhead of unnecessary functionality.</p>
<p class="calibre3">The framework <a id="_idIndexMarker135" class="calibre6 pcalibre1 pcalibre"/>is built on top of coroutines, a feature in Kotlin that makes your code cleaner and more readable, and simplifies asynchronous programming by allowing functions to be paused and resumed at later times. This provides a powerful way to handle concurrency with a more straightforward and expressive syntax compared to traditional callback mechanisms.</p>
<p class="calibre3">Ktor is versatile, supporting both server-side and client-side development. On the server side, it can be used to build robust and scalable web applications and services. On the client side, it provides a multiplatform HTTP client that can be used on Android, allowing for seamless interaction with web services.</p>
<p class="calibre3">Ktor’s WebSocket <a id="_idIndexMarker136" class="calibre6 pcalibre1 pcalibre"/>client allows for easy setup and management of WebSocket connections, handling complexities such as connection lifecycle, error handling, and message processing. Its <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) provides a concise and expressive way to define the behavior of WebSocket interactions, making the code more readable and maintainable.</p>
<h3 class="calibre9">Integrating WebSockets with Ktor</h3>
<p class="calibre3">To integrate <a id="_idIndexMarker137" class="calibre6 pcalibre1 pcalibre"/>Ktor in our Android app, follow these steps:</p>
<ol class="calibre13">
<li class="calibre14">In our <a id="_idIndexMarker138" class="calibre6 pcalibre1 pcalibre"/>app’s <strong class="source-inline1">build.gradle</strong> file of the <strong class="source-inline1">:feature:chat</strong> module, add the following Ktor dependencies for the WebSocket client. Make sure to replace <strong class="source-inline1">$ktor_version</strong> with the latest version available (for the examples in this book, we are using version 2.2.4):<pre class="source-code">
dependencies {
    implementation "io.ktor:ktor-client-
        websockets:2.2.4"
    implementation "io.ktor:ktor-client-okhttp:2.2.4"
}</pre><p class="calibre3">Each dependency serves a distinct purpose:</p><ul class="calibre16"><li class="calibre14"><strong class="source-inline1">io.ktor:ktor-client-websockets</strong>: This dependency provides the necessary functionality to manage WebSocket connections in our application. It includes high-level abstractions for opening, sending messages to, and receiving messages from WebSocket servers, facilitating real-time data exchange in a seamless manner. By using this library, we can easily implement WebSocket communication without handling the complex underlying protocols and handshakes manually.</li><li class="calibre14"><strong class="source-inline1">io.ktor:ktor-client-okhttp</strong>: While Ktor is a multiplatform framework, it requires an engine to handle network requests. This dependency integrates OkHttp as the underlying engine for handling HTTP requests and responses in Android applications. OkHttp supports WebSockets along with its robust HTTP client features, providing efficient network operations, connection pooling, and a powerful interface for making and intercepting requests.</li></ul><p class="calibre3">Together, these <a id="_idIndexMarker139" class="calibre6 pcalibre1 pcalibre"/>dependencies allow our app to <a id="_idIndexMarker140" class="calibre6 pcalibre1 pcalibre"/>utilize WebSockets for real-time communication and leverage OkHttp’s efficient networking capabilities. This combination is particularly powerful for applications needing to maintain persistent connections and manage high-frequency data exchange, such as messaging apps or live data feeds.</p></li> <li class="calibre14">In your <strong class="source-inline1">AndroidManifest.xml</strong> file, add the required permission to access the internet as we will need it to connect our WebSocket and receive/send messages:<pre class="source-code">
&lt;uses-permission android:name=
    "android.permission.INTERNET" /&gt;</pre></li> </ol>
<p class="calibre3">We now have the library included in our project. As we will be using Ktor with Kotlin Flow, let’s introduce it before diving into our WebSocket implementation.</p>
<h3 class="calibre9">Getting to know Kotlin Flow</h3>
<p class="calibre3">Flow is part of Kotlin’s coroutines library, and it’s a type that can emit multiple values sequentially, as opposed to suspend functions that return only a single value. Flow builds upon <a id="_idIndexMarker141" class="calibre6 pcalibre1 pcalibre"/>the foundational concepts of coroutines to offer a declarative way to work with asynchronous streams of data.</p>
<p class="calibre3">Unlike sequences in Kotlin, which are synchronous and blocking, Flow is asynchronous and non-blocking. This makes Flow ideal for handling a continuous stream of data that can be observed <a id="_idIndexMarker142" class="calibre6 pcalibre1 pcalibre"/>and collected asynchronously, such as real-time messages from a WebSocket.</p>
<p class="calibre3">When integrating Flow with Ktor WebSockets, we can create a powerful combination where the WebSocket messages are emitted as a stream of data that can be processed using all the Flow operators. It allows for a clean, reactive-style approach to handling incoming and outgoing messages with WebSockets.</p>
<p class="calibre3">For example, in a chat application, incoming messages from a WebSocket can be represented as a flow of strings. The app can collect this flow to update the UI accordingly. Similarly, user actions that generate outgoing messages can be collected and sent through the WebSocket connection.</p>
<p class="calibre3">The Flow API is really simple and easy to use. As another example, imagine that we have a flow that emits three strings:</p>
<pre class="source-code">
fun main() = runBlocking {
    // Define a simple flow that emits three strings
    val helloFlow = flow {
        emit("Hello")
        emit("from")
        emit("Flow!")
    }
    // Collect and print each value emitted by the flow
    helloFlow.collect { value -&gt;
        println(value)
    }
}</pre> <p class="calibre3">In this code <a id="_idIndexMarker143" class="calibre6 pcalibre1 pcalibre"/>block, <code>helloFlow</code> is defined, using the <code>flow</code> builder to emit three <a id="_idIndexMarker144" class="calibre6 pcalibre1 pcalibre"/>strings one after another.</p>
<p class="callout-heading">Note</p>
<p class="callout">There are several other builders apart from <strong class="source-inline1">flow</strong>, such as <strong class="source-inline1">flowOf</strong>, which creates a flow from a set of values, or <strong class="source-inline1">toFlow()</strong>, which creates a flow from a collection.</p>
<p class="calibre3">The <code>collect()</code> function is <a id="_idIndexMarker145" class="calibre6 pcalibre1 pcalibre"/>then called on <code>helloFlow</code>. It acts as a subscriber that reacts to each emitted value by printing it.</p>
<p class="calibre3">If you run this code, you should see the following output:</p>
<pre class="source-code">
Hello
from
Flow!</pre> <p class="calibre3">Now that we are a bit familiar with Kotlin Flow, we are ready to do the next step: build our implementation of a WebSocket using Ktor and Flow. As it is going to be one of the data sources that will provide messages to our app, we will call it <code>WebsocketDataSource</code>.</p>
<h2 id="_idParaDest-43" class="calibre7"><a id="_idTextAnchor043" class="calibre6 pcalibre1 pcalibre"/>Implementing WebSocketDataSource</h2>
<p class="calibre3">To implement <a id="_idIndexMarker146" class="calibre6 pcalibre1 pcalibre"/>the WebSocket data source, we are first going to create an <code>HttpClient</code> instance. <code>HttpClient</code> is a Ktor class that allows you to make HTTP requests and manage network connections. In the case of WebSockets, it is responsible for establishing and maintaining the connection between the client and server.</p>
<p class="calibre3">To create an <code>HttpClient</code> instance with WebSocket support, we are going to create a new file called <code>WebSocketClient</code> in the <code>feature.chat.data.network</code> package (you will need to create the data and network packages as they don’t exist yet) and include the following code:</p>
<pre class="source-code">
object WebsocketClient {
    val client = HttpClient(OkHttp) {
        install(WebSockets)
    }
}</pre> <p class="calibre3">Here, we’re <a id="_idIndexMarker147" class="calibre6 pcalibre1 pcalibre"/>using the <code>OkHttp</code> engine to create an <code>HttpClient</code> instance, and then we’re installing the <code>WebSockets</code> plugin to enable WebSocket support.</p>
<p class="callout-heading">Note</p>
<p class="callout">In Ktor, <strong class="bold">plugins</strong> (also called features) are modular components that extend the functionality <a id="_idIndexMarker148" class="calibre6 pcalibre1 pcalibre"/>of Ktor applications. Plugins can be installed on both the client and server sides to provide additional features, such as authentication, logging, serialization, or custom <a id="_idIndexMarker149" class="calibre6 pcalibre1 pcalibre"/>behavior. Ktor’s plugin-based architecture encourages a lightweight and modular approach, allowing you to include only the necessary components in your application.</p>
<p class="calibre3">Then, we will create our <code>MessagesSocketDataSource</code> class (in the same package).</p>
<p class="calibre3">To start creating our WebSocket, we will need a <code>WebSocketSession</code> instance. <code>WebSocketSession</code> represents a single WebSocket connection between the client and server, providing methods for sending and receiving messages, as well as managing the connection’s lifecycle. In our implementation, we will create a <code>WebSocketSession</code> instance when we call the <code>connect()</code> method, like so:</p>
<pre class="source-code">
class MessagesSocketDataSource @Inject constructor(
    private val httpClient: HttpClient,
) {
    private lateinit var webSocketSession:
        DefaultClientWebSocketSession
    suspend fun connect(url: String): Flow&lt;Message&gt;{
        return httpClient.webSocketSession { url(url) }
            .apply { webSocketSession = this }
            .incoming
            .receiveAsFlow()
            .map{ frame -&gt;
                webSocketSession.handleMessage(frame) }
            .filterNotNull()
            .map { it.toDomain() }
    }
//...
}</pre> <p class="calibre3">Let’s <a id="_idIndexMarker150" class="calibre6 pcalibre1 pcalibre"/>break down what this code is going to do:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">suspend fun connect(url: String): Flow&lt;Message&gt;</strong>: The <strong class="source-inline1">connect</strong> function is defined as a suspending (<strong class="source-inline1">suspend</strong>) function that takes a <strong class="source-inline1">url</strong> parameter of type <strong class="source-inline1">String</strong> and returns a <strong class="source-inline1">Flow&lt;Message&gt;</strong> instance. <strong class="source-inline1">Flow</strong> is a cold asynchronous stream used for processing data in a reactive way in Kotlin (a cold stream is one that will only emit messages when there is a consumer connected).</li>
<li class="calibre14"><strong class="source-inline1">httpClient.webSocketSession { url(url) }</strong>: This line uses <strong class="source-inline1">httpClient</strong> to create a WebSocket session by calling the <strong class="source-inline1">webSocketSession</strong> function and passing a lambda that sets the session’s URL to the provided URL.</li>
<li class="calibre14"><strong class="source-inline1">.apply { webSocketSession = this }</strong>: This line stores the newly created WebSocket session using the <strong class="source-inline1">apply</strong> function in the <strong class="source-inline1">webSocketSession</strong> property. We also need to store it as we will need the session later for sending messages.</li>
<li class="calibre14"><strong class="source-inline1">.incoming</strong>: This line accesses the incoming property of <strong class="source-inline1">webSocketSession</strong>. The incoming property is a channel that receives incoming <strong class="source-inline1">Frame</strong> objects from the WebSocket server.</li>
<li class="calibre14"><strong class="source-inline1">.receiveAsFlow()</strong>: This line converts the incoming channel to a <strong class="source-inline1">Flow&lt;Frame&gt;</strong> instance so that it can be processed using the Flow API.</li>
<li class="calibre14"><strong class="source-inline1">.map { frame -&gt; webSocketSession.handleMessage(frame) }</strong>: This line <a id="_idIndexMarker151" class="calibre6 pcalibre1 pcalibre"/>maps each incoming <strong class="source-inline1">Frame</strong> object to the result of calling the <strong class="source-inline1">handleMessage</strong> function. We will define the <strong class="source-inline1">handleMessage</strong> function later.</li>
<li class="calibre14"><strong class="source-inline1">.filterNotNull</strong><strong class="source-inline1">()</strong>: This line filters out any <strong class="source-inline1">null</strong> values from the stream, ensuring that only non-<strong class="source-inline1">null</strong> values are processed further.</li>
<li class="calibre14"><strong class="source-inline1">.map { it.toDomain() }</strong>: This line maps each non-<strong class="source-inline1">null</strong> value to the result of calling the <strong class="source-inline1">toDomain()</strong> function. This function will map the current data-related object to the domain <strong class="source-inline1">Message</strong> model that we will create soon.</li>
</ul>
<p class="calibre3">Before processing and handling the messages, we will also want to add two more functions to our WebSocket data source:</p>
<ul class="calibre15">
<li class="calibre14">We want one function to send messages, as we want our users to be able to send messages to their WhatsPackt friends</li>
<li class="calibre14">We want another function to disconnect the WebSocket, as we should disconnect it from the server when it is not in use</li>
</ul>
<p class="calibre3">We can add these like so:</p>
<pre class="source-code">
suspend fun sendMessage(message: String) {
    webSocketSession.send(Frame.Text(message))
}
suspend fun disconnect() {
    webSocketSession.close(CloseReason(
        CloseReason.Codes.NORMAL, "Disconnect"))
}</pre> <p class="calibre3">When a WebSocket connection is closed, it’s accompanied by a <code>CloseReason</code> class, which contains <a id="_idIndexMarker152" class="calibre6 pcalibre1 pcalibre"/>a code and an optional descriptive text. The code indicates the reason for the connection closure, such as normal closure, protocol error, or unsupported data. In our implementation, we use the <code>CloseReason</code> class to close the <code>WebSocketSession</code> with a normal closure.</p>
<p class="calibre3">Some common <code>CloseReason</code> codes include the following:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">CloseReason.Codes.NORMAL</strong>: Indicates a normal closure of the connection. This is the reason that will be provided when the user is no longer using the chat screen.</li>
<li class="calibre14"><strong class="source-inline1">CloseReason.Codes.GOING_AWAY</strong>: Indicates that the server is going away or shutting down.</li>
<li class="calibre14"><strong class="source-inline1">CloseReason.Codes.PROTOCOL_ERROR</strong>: Indicates that an error in the WebSocket protocol occurred.</li>
<li class="calibre14"><strong class="source-inline1">CloseReason.Codes.UNSUPPORTED_DATA</strong>: Indicates that the received data type is not supported.</li>
</ul>
<p class="calibre3">Now that we know how to close our WebSocket connection, we need to define the <code>handleMessages</code> extension function to process all the messages while the connection is alive:</p>
<pre class="source-code">
private suspend fun
DefaultClientWebSocketSession.handleMessage(frame: Frame):
WebsocketMessageModel? {
    return when (frame) {
        is Frame.Text -&gt; converter?.deserialize(frame)
        is Frame.Close -&gt; {
            disconnect()
            null
        }
        else -&gt; null
    }
}</pre> <p class="calibre3">In the WebSocket protocol, data is transmitted in discrete units called frames. Ktor provides a <code>Frame</code> class to represent these units, with different subclasses for each frame type, such as <code>Frame.Text</code>, <code>Frame.Binary</code>, <code>Frame.Ping</code>, and <code>Frame.Close</code>.</p>
<p class="calibre3">In our case, we are only processing <code>Frame.Text</code> and <code>Frame.Close</code> messages. To receive a <code>Frame.Close</code> message, we will close the WebSocket (for now – in the future, maybe we would want to do a retry here or give feedback about the problem to the user). Then, to receive the <code>Frame.Text</code> messages, we are going to <code>deserialize</code> just describes this conversion.</p>
<p class="calibre3">We can configure <a id="_idIndexMarker153" class="calibre6 pcalibre1 pcalibre"/>a converter in our WebSocket that allows us to easily deserialize our messages. First, we need to add new dependencies to our <code>build.gradle</code> file:</p>
<pre class="console">
implementation("io.ktor:ktor-serialization-kotlinx-json:2.2.4)</pre> <p class="calibre3">Then, we are ready to set <code>contentConverter</code> in our WebSocket plugin:</p>
<pre class="source-code">
object WebsocketClient {
    val client = HttpClient(OkHttp) {
        install(WebSockets) {
            contentConverter =
               KotlinxWebsocketSerializationConverter(Json)
        }
    }
}</pre> <p class="calibre3">In this case, we are configuring the <code>kotlinx.serialization</code> converter for the JSON format (there are also converters available for other standards, such as XML, Protobuf, and CBOR).</p>
<p class="calibre3">In addition, we must add the <code>@Serializable</code> annotation to those data classes that we want <a id="_idIndexMarker154" class="calibre6 pcalibre1 pcalibre"/>to be deserialized by the converter. In our case, we will create a <code>WebsocketMessageModel</code> class as follows:</p>
<pre class="source-code">
@Serializable
class WebsocketMessageModel(
    val id: String,
    val message: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val messageType: String,
    val messageDescription: String
)</pre> <p class="calibre3">The last step in our flow chain is to convert the <code>WebsocketMessageModel</code> class to a domain. As we still don’t have a domain model, we should create it first:</p>
<pre class="source-code">
data class Message(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val contentType: ContentType,
    val content: String,
    val contentDescription: String
) {
    enum class ContentType {
        TEXT, IMAGE
    }
}</pre> <p class="calibre3">Now, we can <a id="_idIndexMarker155" class="calibre6 pcalibre1 pcalibre"/>implement the mapper as a function of the <code>WebsocketMessageModel</code> class:</p>
<pre class="source-code">
@Serializable
class WebsocketMessageModel(
    val id: String,
    val message: String,
    val senderName: String,
    val senderAvatar: String,
    val timestamp: String,
    val isMine: Boolean,
    val messageType: String,
    val messageDescription: String
) {
    companion object {
        const val TYPE_TEXT = "TEXT"
        const val TYPE_IMAGE = "IMAGE"
    }
    fun toDomain(): Message {
        return Message(
            id = id,
            content = message,
            senderAvatar = senderAvatar,
            senderName = senderName,
            timestamp = timestamp,
            isMine = isMine,
            contentDescription = messageDescription,
            contentType = toContentType()
        )
    }
    fun toContentType(): Message.ContentType {
        return when(messageType) {
            TYPE_IMAGE -&gt; Message.ContentType.IMAGE
            else -&gt; Message.ContentType.TEXT
        }
    }
}</pre> <p class="calibre3">Here, we are <a id="_idIndexMarker156" class="calibre6 pcalibre1 pcalibre"/>adding the <code>toDomain()</code> function that maps the current <code>WebsocketMessageModel</code> class to the <code>Message</code> model. Note that almost all fields in the data model are similar to those in our domain <code>Message</code> model. The key exception is the <code>messageType</code> field, which we must convert to the enum we are using in the domain <code>Message</code> model. To simplify this conversion, we use the <code>toContentType()</code> function, which specifically transforms <code>messageType</code> from a <code>String</code> object to a <code>ContentType</code> enum.</p>
<p class="calibre3">We also <a id="_idIndexMarker157" class="calibre6 pcalibre1 pcalibre"/>would need to convert the domain <code>Message</code> object to the <code>WebsocketMessageModel</code> class. To do that, we need to add a new function to the <code>WebsocketMessageModel</code> class:</p>
<pre class="source-code">
companion object {
    const val TYPE_TEXT = "TEXT"
    const val TYPE_IMAGE = "IMAGE"
    fun fromDomain(message: Message): WebsocketMessageModel {
        return WebsocketMessageModel(
            id = message.id,
            message = message.content,
            senderAvatar = message.senderAvatar,
            senderName = message.senderName,
            timestamp = message.timestamp,
            isMine = message.isMine,
            messageType = message.fromContentType(),
            messageDescription = message.contentDescription
        )
    }
}</pre> <p class="calibre3">Here, we are converting the <code>Message</code> domain object into a <code>WebsocketMessageModel</code> class.</p>
<p class="calibre3">Then, in the <code>send</code> function, we will proceed as follows:</p>
<pre class="source-code">
suspend fun sendMessage(message: Message) {
    val websocketMessage =
        WebsocketMessageModel.fromDomain(message)
    webSocketSession.converter?
        .serialize(websocketMessage)?.let
    {
        webSocketSession.send(it)
    }
}</pre> <p class="calibre3">With these <a id="_idIndexMarker158" class="calibre6 pcalibre1 pcalibre"/>changes to the <code>sendMessage</code> function, we are now receiving a domain model object, converting it to <code>WebsocketMessageModel</code>, and finally serializing it into a <code>Frame</code> object and sending it through our WebSocket.</p>
<p class="calibre3">The next step is to connect this component (<code>MessagesWebsocketDataSource</code>) with <code>ViewModel</code>, which will be responsible for providing the view state to the view so that it can render accordingly.</p>
<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor044" class="calibre6 pcalibre1 pcalibre"/>Receiving messages in our ViewModel</h1>
<p class="calibre3">Our app is ready to receive and send messages using a WebSocket. Now, we need to make them <a id="_idIndexMarker159" class="calibre6 pcalibre1 pcalibre"/>reach the UI we created in the previous chapter. We will do that in this section, but first, we need to think about the architecture and components needed to do that.</p>
<h2 id="_idParaDest-45" class="calibre7"><a id="_idTextAnchor045" class="calibre6 pcalibre1 pcalibre"/>Understanding Clean Architecture implementation</h2>
<p class="calibre3">In the <a id="_idIndexMarker160" class="calibre6 pcalibre1 pcalibre"/>previous chapter, we modularized <a id="_idIndexMarker161" class="calibre6 pcalibre1 pcalibre"/>our app and talked about using a Clean Architecture-based structure to organize our common and feature modules. We have already created our first component of this architecture, <code>MessagesWebsocketDataSource</code>, but it is important to understand the reasons behind this organization and which role every component plays in the architecture.</p>
<p class="calibre3">There are extensive books, articles, and videos about why and how to apply Clean Architecture <a id="_idIndexMarker162" class="calibre6 pcalibre1 pcalibre"/>principles to an Android app, even <a id="_idIndexMarker163" class="calibre6 pcalibre1 pcalibre"/>from official documentation by Google. Here, we are going to give you a short description and then break down into its layers.</p>
<p class="calibre3"><strong class="bold">Clean Architecture</strong> is an <a id="_idIndexMarker164" class="calibre6 pcalibre1 pcalibre"/>architectural pattern that promotes the organization of code into layers with well-defined responsibilities, making the application more modular, maintainable, testable, and scalable. The key benefits of using Clean Architecture are as follows:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Separation of concerns (SoC)</strong>: Clean Architecture organizes code into distinct <a id="_idIndexMarker165" class="calibre6 pcalibre1 pcalibre"/>layers with specific responsibilities, ensuring that each layer handles a separate aspect of the application. This SoC leads to a more modular and maintainable code base, making it easier to understand, modify, and extend.</li>
<li class="calibre14"><strong class="bold">Testability</strong>: By separating the different concerns into independent layers, it becomes <a id="_idIndexMarker166" class="calibre6 pcalibre1 pcalibre"/>easier to test each layer in isolation. This allows developers to write comprehensive unit and integration tests, ensuring that the application behaves correctly and is less prone to bugs.</li>
<li class="calibre14"><strong class="bold">Reusability</strong>: The modular structure of Clean Architecture promotes reusability by encouraging <a id="_idIndexMarker167" class="calibre6 pcalibre1 pcalibre"/>the creation of components that can be easily shared across different parts of the application or even between different projects. This reduces code duplication and improves the overall efficiency of the development process.</li>
<li class="calibre14"><strong class="bold">Flexibility</strong>: Clean <a id="_idIndexMarker168" class="calibre6 pcalibre1 pcalibre"/>Architecture decouples the various layers of the application, making it easier to change or update any of these layers independently without affecting the others. This provides more flexibility when refactoring, making changes to the application, or adapting to new requirements.</li>
<li class="calibre14"><strong class="bold">Scalability</strong>: The modular nature of Clean Architecture makes it easier to scale the application <a id="_idIndexMarker169" class="calibre6 pcalibre1 pcalibre"/>as it grows in complexity or size. By organizing code into well-defined layers and components, developers can more easily add new features, update existing functionality, or improve performance without introducing unintended side effects or making the code base unmanageable.</li>
<li class="calibre14"><strong class="bold">Easier collaboration</strong>: Clean Architecture helps teams work more effectively by providing <a id="_idIndexMarker170" class="calibre6 pcalibre1 pcalibre"/>a clear structure and guidelines for organizing code. This makes it easier for developers to understand the code base, find the components they need, and contribute to the project more efficiently.</li>
<li class="calibre14"><strong class="bold">Future-proofing</strong>: By adhering to the principles of Clean Architecture, you ensure that <a id="_idIndexMarker171" class="calibre6 pcalibre1 pcalibre"/>the application is built on a solid foundation that can evolve and adapt over time. This makes it more resilient to changes in technology, requirements, or team members, improving the long-term viability of the project.</li>
</ul>
<p class="calibre3">In summary, using Clean Architecture in your projects leads to better-organized, more maintainable, and scalable code bases. It improves the overall quality of the application, reduces technical debt, and makes it easier for teams to work together effectively.</p>
<p class="calibre3">Now, with the benefits of Clean Architecture firmly in mind, let’s delve into the specifics. What follows are the layers and the components of code that we will incorporate within each layer:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Presentation layer</strong>:<ul class="calibre16"><li class="calibre14"><strong class="bold">View</strong>: This <a id="_idIndexMarker172" class="calibre6 pcalibre1 pcalibre"/>consists of UI <a id="_idIndexMarker173" class="calibre6 pcalibre1 pcalibre"/>components, such as <strong class="source-inline1">Activity</strong>, <strong class="source-inline1">Fragment</strong>, <strong class="source-inline1">View</strong>, and, in <a id="_idIndexMarker174" class="calibre6 pcalibre1 pcalibre"/>our case, <strong class="source-inline1">Composable</strong> components. The view is responsible for displaying data and capturing user input.</li><li class="calibre14"><strong class="bold">ViewModel</strong>: The <strong class="source-inline1">ViewModel</strong> serves <a id="_idIndexMarker175" class="calibre6 pcalibre1 pcalibre"/>as a bridge between the <strong class="source-inline1">View</strong> components and the data layers. It handles the UI logic, exposes <strong class="source-inline1">LiveData</strong> or <strong class="source-inline1">StateFlow</strong> objects for data binding, and communicates with <strong class="source-inline1">UseCase</strong> classes.</li></ul></li>
<li class="calibre14"><strong class="bold">Domain layer</strong>:<ul class="calibre16"><li class="calibre14"><strong class="bold">UseCase</strong>: This <a id="_idIndexMarker176" class="calibre6 pcalibre1 pcalibre"/>layer contains the business logic and coordinates <a id="_idIndexMarker177" class="calibre6 pcalibre1 pcalibre"/>the flow of data between the data layer <a id="_idIndexMarker178" class="calibre6 pcalibre1 pcalibre"/>and the presentation layer. <strong class="source-inline1">UseCase</strong> implementations encapsulate specific actions that can be performed within the app, such as sending a message, fetching chat history, or updating user settings.</li></ul></li>
<li class="calibre14"><strong class="bold">Data layer</strong>:<ul class="calibre16"><li class="calibre14"><strong class="bold">Repository</strong>: The <strong class="source-inline1">Repository</strong> component is responsible for managing the data <a id="_idIndexMarker179" class="calibre6 pcalibre1 pcalibre"/>flow and providing a clean API to <a id="_idIndexMarker180" class="calibre6 pcalibre1 pcalibre"/>request data from different sources (local database, remote <a id="_idIndexMarker181" class="calibre6 pcalibre1 pcalibre"/>API, and so on). It abstracts the underlying data sources and handles caching, synchronization, and data merging.</li><li class="calibre14"><strong class="bold">Data source</strong>: This <a id="_idIndexMarker182" class="calibre6 pcalibre1 pcalibre"/>layer contains the implementations for accessing specific data sources such as local databases (using <a id="_idIndexMarker183" class="calibre6 pcalibre1 pcalibre"/>Room or another <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>)) and remote APIs (using Retrofit or another networking library, as in our case where we are using Ktor).</li></ul></li>
</ul>
<p class="calibre3">In the following diagram, we can see the relationships between the different layers and the typical components every layer includes:</p>
<div><div><img alt="Figure 2.1: Clean Architecture in Android with the typical components per layer" src="img/B19443_02_001.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1: Clean Architecture in Android with the typical components per layer</p>
<p class="calibre3">Having this <a id="_idIndexMarker184" class="calibre6 pcalibre1 pcalibre"/>clear understanding of Clean Architecture’s benefits and structure, let’s now put these principles into practice.</p>
<h2 id="_idParaDest-46" class="calibre7"><a id="_idTextAnchor046" class="calibre6 pcalibre1 pcalibre"/>Creating our Clean Architecture components</h2>
<p class="calibre3">We <a id="_idIndexMarker185" class="calibre6 pcalibre1 pcalibre"/>have started building the data layer components, where <a id="_idIndexMarker186" class="calibre6 pcalibre1 pcalibre"/>we have created the <code>MessagesWebsocket</code><strong class="source-inline">
DataSource</strong> component. Now, it is time we build the rest of our Clean Architecture layers and components to reach the presentation layer.</p>
<p class="calibre3">In the end, this is what our app’s Clean Architecture layers and components should look like:</p>
<div><div><img alt="Figure 2.2: Layers and components that we will build in our project, following Clean Architecture principles" src="img/B19443_02_002.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.2: Layers and components that we will build in our project, following Clean Architecture principles</p>
<p class="calibre3">As we <a id="_idIndexMarker187" class="calibre6 pcalibre1 pcalibre"/>have already built the <code>MessagesWebsocketDataSource</code> component, the next component is the repository. The <a id="_idIndexMarker188" class="calibre6 pcalibre1 pcalibre"/>repository component will only connect with <code>MessagesWebsocketDataSource</code> (for now; we have bigger plans for it in the next chapter). We are going to call it <code>MessagesRepository</code>. Let’s start building it:</p>
<pre class="source-code">
class MessagesRepository @Inject constructor(
    private val dataSource: MessagesSocketDataSource
) {
    suspend fun getMessages(): Flow&lt;Message&gt; {
        return dataSource.connect()
    }
    suspend fun sendMessage(message: Message) {
        dataSource.sendMessage(message)
    }
    suspend fun disconnect() {
        dataSource.disconnect()
    }
}</pre> <p class="calibre3"><code>MessagesRepository</code> will just have one dependency (<code>MessagesSocketDataSource</code>) and will implement the functionality to connect to messages (the <code>getMessages</code> function), send messages (the <code>sendMessage</code> function), and disconnect from the WebSocket (the <code>disconnect</code> function).</p>
<p class="calibre3">Now, we <a id="_idIndexMarker189" class="calibre6 pcalibre1 pcalibre"/>need to do a little modification to <code>MessagesRepository</code>: we need to create an interface in the domain <a id="_idIndexMarker190" class="calibre6 pcalibre1 pcalibre"/>layer with the <code>MessagesRepository</code> functionality. Creating an interface for the repository in the domain <a id="_idIndexMarker191" class="calibre6 pcalibre1 pcalibre"/>layer and implementing it in the data layer is a technique that follows the <strong class="bold">Dependency Inversion Principle</strong> (<strong class="bold">DIP</strong>) from the <a id="_idIndexMarker192" class="calibre6 pcalibre1 pcalibre"/>SOLID principles of <strong class="bold">object-oriented </strong><strong class="bold">programming</strong> (<strong class="bold">OOP</strong>).</p>
<p class="callout-heading">Note</p>
<p class="callout">DIP is one of the five principles of OOP and design known as SOLID. DIP states that high-level modules should not depend on low-level modules and both should depend on abstractions. Similarly, abstractions should not depend on details; details should depend on abstractions. The main idea behind DIP is to decouple modules, classes, or components in a software system, promoting flexibility, reusability, and maintainability. By depending on abstractions rather than concrete implementations, the system becomes more adaptable to changes and easier to test and maintain.</p>
<p class="calibre3">Let’s create our <code>IMessagesRepository</code> interface:</p>
<pre class="source-code">
interface IMessagesRepository {
    suspend fun getMessages(): Flow&lt;Message&gt;
    suspend fun sendMessage(message: Message)
    suspend fun disconnect()
}</pre> <p class="calibre3">Then, we will <a id="_idIndexMarker193" class="calibre6 pcalibre1 pcalibre"/>change our <code>MessagesRepository</code> class <a id="_idIndexMarker194" class="calibre6 pcalibre1 pcalibre"/>to implement this interface, adding the override in its functions:</p>
<pre class="source-code">
class MessagesRepository @Inject constructor(
    private val dataSource: MessagesSocketDataSource
): IMessagesRepository {
    override suspend fun getMessages(): Flow&lt;Message&gt; {
        return dataSource.connect()
    }
    override suspend fun sendMessage(message: Message) {
        dataSource.sendMessage(message)
    }
    override suspend fun disconnect() {
        dataSource.disconnect()
    }
}</pre> <p class="calibre3">Now, we will continue in our journey to the presentation layer, implementing the domain layer.</p>
<p class="calibre3">The domain layer is not strictly mandatory, but it is highly recommended. While you can eliminate the domain layer and directly use repositories in your <code>ViewModel</code> instances, doing so <a id="_idIndexMarker195" class="calibre6 pcalibre1 pcalibre"/>would mix the responsibilities of the <a id="_idIndexMarker196" class="calibre6 pcalibre1 pcalibre"/>layers, which can lead to more complex and harder-to-maintain code. There may be cases where not implementing <a id="_idIndexMarker197" class="calibre6 pcalibre1 pcalibre"/>it could be considered; for example, if you are doing a <code>UseCase</code> layer to maintain a clean and scalable architecture.</p>
<p class="calibre3">Following <a id="_idIndexMarker198" class="calibre6 pcalibre1 pcalibre"/>the <code>UseCase</code> instances as different functions/responsibilities in our business logic. So, in our case, we will create three <code>UseCase</code> instances: one for retrieving messages, one for sending messages, and one for disconnecting or stopping message retrieval.</p>
<p class="callout-heading">Note</p>
<p class="callout">SRP is one of the five principles of OOP and design known as SOLID. It states that a class, module, or function should have only one reason to change, meaning it should have only one responsibility. The principle aims to promote SoC by encouraging developers to break down their code into smaller, more focused components that handle a single task or aspect of the application. This leads to a more modular, maintainable, and easier-to-understand code base.</p>
<p class="calibre3">First, we will implement the <code>RetrieveMessages</code> use case:</p>
<pre class="source-code">
class RetrieveMessages @Inject constructor(
    private val repository: IMessagesRepository
) {
    suspend operator fun invoke(): Flow&lt;Message&gt; {
        return repository.getMessages()
    }
}</pre> <p class="calibre3">Here, we have just one dependency: the repository. Note that we are declaring it using its interface. It is relevant because, as we detailed before, the domain shouldn’t know anything about the data layer.</p>
<p class="calibre3"><code>RetrieveMessages</code> will have one function that will return a <code>Flow</code> instance with <code>Message</code> objects. For doing that, it will return <code>repository.getMessages()</code>. No mapping <a id="_idIndexMarker199" class="calibre6 pcalibre1 pcalibre"/>or alteration is needed as this function <a id="_idIndexMarker200" class="calibre6 pcalibre1 pcalibre"/>already returned a <code>Flow</code> instance of <code>Message</code> objects.</p>
<p class="calibre3">Second, we are going to implement the <code>SendMessage</code> use case:</p>
<pre class="source-code">
class SendMessage @Inject constructor(
    private val repository: IMessagesRepository
) {
    suspend operator fun invoke(message: Message) {
        repository.sendMessage(message)
    }
}</pre> <p class="calibre3">Again, this use case will depend only on the <code>IMessagesRepository</code> interface. It will call its <code>sendMessage</code> function.</p>
<p class="calibre3">And finally, we will code the <code>DisconnectMessages</code> use case:</p>
<pre class="source-code">
class DisconnectMessages @Inject constructor(
    private val repository: IMessagesRepository
) {
    suspend operator fun invoke() {
        repository.disconnect()
    }
}</pre> <p class="calibre3">The <code>DisconnectMessages</code> use case, as with the previous use cases implemented, depends on the <code>IMessagesRepository</code> interface and will call its <code>disconnect</code> function.</p>
<p class="calibre3">We are <a id="_idIndexMarker201" class="calibre6 pcalibre1 pcalibre"/>now done with the domain layer. Now, it’s <a id="_idIndexMarker202" class="calibre6 pcalibre1 pcalibre"/>time to implement the <code>ViewModel</code> component that we will connect to the <code>ChatScreen</code> component, using <code>ChatViewModel</code>.</p>
</div>


<div><h2 id="_idParaDest-47" class="calibre7"><a id="_idTextAnchor047" class="calibre6 pcalibre1 pcalibre"/>Implementing ChatViewModel</h2>
<p class="calibre3">In Android, <code>ViewModel</code> is an architectural component introduced as part of the <code>ViewModel</code> component is to hold and process the <a id="_idIndexMarker204" class="calibre6 pcalibre1 pcalibre"/>data required for a UI component (such as an <code>Activity</code>, <code>Fragment</code>, or <code>Composable</code> component) while properly handling configuration changes (such as device rotations) and surviving the lifecycle of the associated UI component.</p>
<p class="calibre3">Our <code>ChatViewModel</code> class will be responsible for handling the data required in our <code>ChatScreen</code> component (which we previously built in <a href="B19443_01.xhtml#_idTextAnchor015" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 1</em></a>). This data will come and change from the use cases we have just created. So first, our <code>ChatViewModel</code> class will have those use cases as dependencies:</p>
<pre class="source-code">
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val retrieveMessages: RetrieveMessages,
    private val sendMessage: SendMessage,
    private val disconnectMessages: DisconnectMessages
) : ViewModel() {
// ....
}</pre> <p class="calibre3">Then, we will need a property to hold the state. This property needs to be observable from the view but read-only (so that the view shouldn’t be able to modify it). We will solve this by creating two different properties. The first property is <code>_messages</code>:</p>
<pre class="source-code">
private val _messages =
MutableStateFlow&lt;List&lt;Message&gt;&gt;(emptyList())</pre> <p class="calibre3">This line creates a private mutable state flow that holds a list of <code>Message</code> objects. We will use it to manage and update messages internally within the <code>ViewModel</code>.</p>
<p class="calibre3">The second property will be <code>messages</code>:</p>
<pre class="source-code">
val messages: StateFlow&lt;List&lt;Message&gt;&gt; = _messages</pre> <p class="calibre3">This line <a id="_idIndexMarker205" class="calibre6 pcalibre1 pcalibre"/>exposes the private mutable state flow as a public <a id="_idIndexMarker206" class="calibre6 pcalibre1 pcalibre"/>read-only state flow. This allows the UI components to observe messages without being able to modify them directly.</p>
<p class="calibre3">Now, we need to implement the <code>loadAndUpdateMessages</code> function that will call the <code>RetrieveMessages</code> use case:</p>
<pre class="source-code">
private var messageCollectionJob: Job? = null
fun loadAndUpdateMessages() {
    messageCollectionJob =
    viewModelScope.launch(Dispatchers.IO) {
        retrieveMessages()
            .map { it.toUI() }
            .collect { message -&gt;
                withContext(Dispatchers.Main) {
                    _messages.value = _messages.value +
                    message
                }
            }
    }
}</pre> <p class="calibre3">In the previous code block, it can be seen that we need to declare a <code>messageCollectionJob</code> variable. This variable is used to cancel the <code>messages</code> collection job when the <code>ViewModel</code> is cleared.</p>
<p class="calibre3">The <code>loadAndUpdateMessages</code> function is responsible for fetching and updating messages. It <a id="_idIndexMarker207" class="calibre6 pcalibre1 pcalibre"/>launches a coroutine with the <code>Dispatchers.IO</code> context for performing network or disk operations.</p>
<p class="calibre3">Inside the <a id="_idIndexMarker208" class="calibre6 pcalibre1 pcalibre"/>coroutine, the <code>retrieveMessages</code> function is called, and the resulting messages are mapped into the <code>Message</code> UI object and then collected using the <code>collect</code> function.</p>
<p class="calibre3">For each <a id="_idIndexMarker209" class="calibre6 pcalibre1 pcalibre"/>collected message, the <code>_messages state</code> flow is <a id="_idIndexMarker210" class="calibre6 pcalibre1 pcalibre"/>updated with the new message by switching the coroutine context to <code>Dispatchers.Main</code>.</p>
<p class="calibre3">Next, to make the mapping more readable, we are going to create two extension functions:</p>
<pre class="source-code">
private fun DomainMessage.toUI(): Message {
    return Message(
        id = id,
        senderName = senderName,
        senderAvatar = senderAvatar,
        timestamp = timestamp,
        isMine = isMine,
        messageContent = getMessageContent()
    )
}
private fun DomainMessage.getMessageContent():
MessageContent {
    return when (contentType) {
        DomainMessage.ContentType.TEXT -&gt;
            MessageContent.TextMessage(content)
        DomainMessage.ContentType.IMAGE -&gt;
            MessageContent.ImageMessage(content,
            contentDescription)
    }
}</pre> <p class="calibre3">So, when <a id="_idIndexMarker211" class="calibre6 pcalibre1 pcalibre"/>retrieving and mapping messages, we just have to call the following:</p>
<pre class="source-code">
retrieveMessages()
    .map { it.toUI() }</pre> <p class="calibre3">Then, we continue <a id="_idIndexMarker212" class="calibre6 pcalibre1 pcalibre"/>to process the <code>messages</code> collection job.</p>
<p class="calibre3">Then, we should add a function to send a new message. Basically, the idea is to launch the coroutine in the <code>Dispatchers.IO</code> context to send the message. As it is a network operation, it is recommended to use the I/O dispatcher and map the <code>String</code> object we are getting from the user to the domain object, as you can see in the following code block:</p>
<pre class="source-code">
fun onSendMessage(messageText: String) {
    viewModelScope.launch(Dispatchers.IO) {
        val message = Message(messageText) // We will add
                                              here the rest
                                              of the fields
        sendMessage(message)
    }
}</pre> <p class="calibre3">Note that, to create the domain object, we are going to lack some information because, for example, we have no way to obtain the <code>senderImage</code> or the <code>senderName</code> properties that are mandatory to send a message. So, this function is not going to compile for now, but we will solve this problem in the following section.</p>
<p class="calibre3">Finally, we can use the <code>onCleared</code> function to disconnect from the message’s retrieval:</p>
<pre class="source-code">
override fun onCleared() {
    messageCollectionJob?.cancel()
    viewModelScope.launch(Dispatchers.IO) {
        disconnectMessages()
    }
}</pre> <p class="calibre3">This function <a id="_idIndexMarker213" class="calibre6 pcalibre1 pcalibre"/>is called when the <code>ViewModel</code> is no longer in use and will be disposed of by the system. This involves canceling <a id="_idIndexMarker214" class="calibre6 pcalibre1 pcalibre"/>the <code>messageCollectionJob</code> variable, provided it’s not <code>null</code>, effectively halting the <code>messages</code> collection coroutine. Concurrently, in the context of <code>Dispatchers.IO</code>, a new coroutine is launched to execute the <code>disconnectMessages</code> function. This guarantees that any essential cleanup associated with disconnecting from the message source is carried out properly.</p>
<p class="calibre3">This is how the <code>ChatViewModel</code> component will look (for now):</p>
<pre class="source-code">
import com.packt.feature.chat.domain.models.Message as
DomainMessage
// We are using this import with an alias to make it easier
   to identify the Message class from the domain layer
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val retrieveMessages: RetrieveMessages,
    private val sendMessage: SendMessage,
    private val disconnectMessages: DisconnectMessages
) : ViewModel() {
    private val _messages =
        MutableStateFlow&lt;List&lt;Message&gt;&gt;(emptyList())
    val messages: StateFlow&lt;List&lt;Message&gt;&gt; = _messages
    private var messageCollectionJob: Job? = null
    fun loadAndUpdateMessages() {
        messageCollectionJob =
        viewModelScope.launch(Dispatchers.IO) {
            retrieveMessages()
                .map { it.toUI() }
                .collect { message -&gt;
                    withContext(Dispatchers.Main) {
                        _messages.value = _messages.value +
                        message
                }
            }
        }
    }
    private fun DomainMessage.toUI(): Message {
        return Message(
            id = id,
            senderName = senderName,
            senderAvatar = senderAvatar,
            timestamp = timestamp,
            isMine = isMine,
            messageContent = getMessageContent()
        )
    }
    private fun DomainMessage.getMessageContent():
    MessageContent {
        return when (contentType) {
            DomainMessage.ContentType.TEXT -&gt;
                MessageContent.TextMessage(content)
            DomainMessage.ContentType.IMAGE -&gt;
                MessageContent.ImageMessage(content,
                contentDescription)
        }
    }
    fun onSendMessage(messageText: String) {
        viewModelScope.launch(Dispatchers.IO) {
            val message = Message(messageText)
            sendMessage(message)
        }
    }
    override fun onCleared() {
        messageCollectionJob?.cancel()
        viewModelScope.launch(Dispatchers.IO) {
            disconnectMessages()
        }
    }
}</pre> <p class="calibre3">Now that <a id="_idIndexMarker215" class="calibre6 pcalibre1 pcalibre"/>we have our <code>ChatViewModel</code> component ready, we need to connect it to the view. We will make the changes <a id="_idIndexMarker216" class="calibre6 pcalibre1 pcalibre"/>needed in the <code>ChatScreen</code> component so that it connects to our <code>ChatViewModel</code> component. As the first step, we have added the <code>ViewModel</code> to the arguments:</p>
<pre class="source-code">
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel(),
    chatId: String?,
    onBack: () -&gt; Unit
) {
}</pre> <p class="calibre3">Then, we will also add a <code>LaunchEffect</code> composable that will start the messages’ load:</p>
<pre class="source-code">
LaunchedEffect(Unit) {
    viewModel.loadAndUpdateMessages()
}</pre> <p class="calibre3">Next, the <code>SendMessageBox</code> composable takes a lambda parameter, where we are going to send the message using the <code>ViewModel</code> function:</p>
<pre class="source-code">
SendMessageBox { viewModel.onSendMessage(it) }</pre> <p class="calibre3">After that, we add <a id="_idIndexMarker217" class="calibre6 pcalibre1 pcalibre"/>the following new parameter <a id="_idIndexMarker218" class="calibre6 pcalibre1 pcalibre"/>to the <code>SendMessageBox</code> composable definition and call it in its <code>IconButton</code> <code>onClick</code> property:</p>
<pre class="source-code">
@Composable
fun SendMessageBox(sendMessage: (String)-&gt;Unit) {
    Box(modifier = Modifier
        .defaultMinSize()
        .padding(top = 0.dp, start = 16.dp, end = 16.dp,
            bottom = 16.dp)
        .fillMaxWidth()
    ) {
        var text by remember { mutableStateOf("") }
        OutlinedTextField(
            value = text,
            onValueChange = { newText -&gt; text = newText },
            modifier = Modifier
                .fillMaxWidth(0.85f)
                .align(Alignment.CenterStart)
                .height(56.dp),
        )
        IconButton(
            modifier = Modifier
                .align(Alignment.CenterEnd)
                .height(56.dp),
            onClick = {
                sendMessage(text)
                text = ""
            }
        ) {
            Icon(
                imageVector = Icons.Default.Send,
                tint = MaterialTheme.colors.primary,
                contentDescription = "Send message"
            )
        }
    }
}</pre> <p class="calibre3">Finally, we will <a id="_idIndexMarker219" class="calibre6 pcalibre1 pcalibre"/>inject the <code>messages</code> property <a id="_idIndexMarker220" class="calibre6 pcalibre1 pcalibre"/>to the <code>ListOfMessages</code> composable:</p>
<pre class="source-code">
ListOfMessages(paddingValues = paddingValues, messages = messages)</pre> <p class="calibre3">This, of course, will also require a change in the composable definition and code:</p>
<pre class="source-code">
@Composable
fun ListOfMessages(messages: List&lt;Message&gt;, paddingValues: PaddingValues) {
    Box(modifier = Modifier
        .fillMaxSize()
        .padding(paddingValues)) {
        Row(modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
        ) {
            LazyColumn(
                modifier = Modifier
                    .fillMaxSize(),
                verticalArrangement =
                    Arrangement.spacedBy(8.dp),
            ) {
                items(messages) { message -&gt;
                    MessageItem(message = message)
                }
            }
        }
    }
}</pre> <p class="calibre3">Instead <a id="_idIndexMarker221" class="calibre6 pcalibre1 pcalibre"/>of using the <code>getFakeMessages()</code> function <a id="_idIndexMarker222" class="calibre6 pcalibre1 pcalibre"/>we were using when we built the <code>ListOfMessages</code> composable, we will use the <code>messages</code> list that we are now obtaining via properties.</p>
<p class="calibre3">And with that, we’ve covered almost everything, but there remain some challenges to address. For instance, we don’t have the necessary information to display the correct avatar and name of the chat members or the necessary information to fill in the required properties for sending a message. While we will receive new messages once we connect to the WebSocket, the question of how to get historical messages remains. We will tackle these issues, along with other concerns related to error handling and synchronization, in the upcoming section.</p>
<h1 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor048" class="calibre6 pcalibre1 pcalibre"/>Handling synchronization and errors</h1>
<p class="calibre3">To make the <a id="_idIndexMarker223" class="calibre6 pcalibre1 pcalibre"/>chat messages functionality complete, we still have some issues <a id="_idIndexMarker224" class="calibre6 pcalibre1 pcalibre"/>we have to take into account: getting historical messages and receiver information and handling possible errors. We will go through them in this section.</p>
<h2 id="_idParaDest-49" class="calibre7"><a id="_idTextAnchor049" class="calibre6 pcalibre1 pcalibre"/>Obtaining chat screen initialization data</h2>
<p class="calibre3">Apart from <a id="_idIndexMarker225" class="calibre6 pcalibre1 pcalibre"/>the messages that we are going to be receiving or sending via the data source, we still need to get some additional information. This includes the following:</p>
<ul class="calibre15">
<li class="calibre14">Messages that have been sent and received before the WebSocket was connected (not all of them, though, because the conversation could have many messages, and it would take a long time to gather/load all of the information; instead we should prioritize fetching a certain number of the most recent messages)</li>
<li class="calibre14">Receiver information, such as their name or avatar URL</li>
</ul>
<p class="calibre3">There are several options to solve this – for example, we could have a different type of message with all this information when the WebSocket connection is established, or we could have a specific API call to retrieve this information. As we have already played with the Ktor WebSocket for the chat feature, we are going to use it to implement an API call to retrieve this information.</p>
<p class="calibre3">When we built <code>WebsocketMessagesDataSource</code>, we had to provide an <code>HttpClient</code> instance. Usually, these clients are shared within the same application, but we should create a new one to be used for our API requests. For that, we would need to add a new dependency:</p>
<pre class="source-code">
implementation "io.ktor:ktor-client-content-negotiation:
$ktor_version"</pre> <p class="calibre3">Then, we can create the client like so (we can do it in the same file we defined the WebSocket client):</p>
<pre class="source-code">
object RestClient {
    val client = HttpClient{
        install(ContentNegotiation) {
            json()
        }
    }
}</pre> <p class="calibre3">Next, we are <a id="_idIndexMarker226" class="calibre6 pcalibre1 pcalibre"/>going to create a <code>ChatRoomDataSource</code> class that will be in charge of handling this data retrieval:</p>
<pre class="source-code">
class ChatRoomDataSource @Inject constructor(
    private val client: HttpClient,
    private val url: String
) {
    suspend fun getInitialChatRoom(id: String):
    ChatRoomModel {
        return client.get(url.format(id)).body()
    }
}</pre> <p class="calibre3">As seen here, we are going to inject the client and the URL as dependencies. Then, in the <code>getInitialChatRoom</code> function, we will call the <code>client.get(url)</code> function in order to make a request to the endpoint.</p>
<p class="calibre3">Using the Ktor client, you can use various HTTP methods. Here’s a list of common ones:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">GET</strong>: Retrieves <a id="_idIndexMarker227" class="calibre6 pcalibre1 pcalibre"/>data from the specified endpoint. To use this method in Ktor, you can call the <strong class="source-inline1">get</strong> function:<pre class="source-code">
val response: HttpResponse =
client.get("https://api.example.com/data")</pre></li> <li class="calibre14"><strong class="source-inline1">POST</strong>: Sends data <a id="_idIndexMarker228" class="calibre6 pcalibre1 pcalibre"/>to the specified endpoint, usually for creating a new resource. To use this method in Ktor, you can call the <strong class="source-inline1">post</strong> function:<pre class="source-code">
val response: HttpResponse =
client.post("https://api.example.com/data") {
body = yourData }</pre></li> <li class="calibre14"><strong class="source-inline1">PUT</strong>: Sends data <a id="_idIndexMarker229" class="calibre6 pcalibre1 pcalibre"/>to the specified endpoint, usually for updating an existing resource. To use this method in Ktor, you can call the <strong class="source-inline1">put</strong> function:<pre class="source-code">
val response: HttpResponse =
client.put("https://api.example.com/data") {
body = yourUpdatedData }</pre></li> <li class="calibre14"><strong class="source-inline1">DELETE</strong>: Deletes <a id="_idIndexMarker230" class="calibre6 pcalibre1 pcalibre"/>a specified resource. To use this method in Ktor, you can call the <strong class="source-inline1">delete</strong> function:<pre class="source-code">
val response: HttpResponse =
client.delete("https://api.example.com/data/ID")</pre></li> <li class="calibre14"><strong class="source-inline1">PATCH</strong>: Applies <a id="_idIndexMarker231" class="calibre6 pcalibre1 pcalibre"/>partial modifications to a resource. To use this method in Ktor, you can call the <strong class="source-inline1">patch</strong> function:<pre class="source-code">
val response: HttpResponse =
client.patch("https://api.example.com/data") {
body = yourPartialData }</pre></li> </ul>
<p class="calibre3">In the <a id="_idIndexMarker232" class="calibre6 pcalibre1 pcalibre"/>case of our <code>getInitialChatRoom</code> function, we are using the <code>client.get(URL)</code> function (note that we have to provide the URL in a format such that we can then replace the ID of <code>ChatRoom</code>). We also need to return a new model, <code>ChatRoomModel</code>:</p>
<pre class="source-code">
@kotlinx.serialization.Serializable
data class ChatRoomModel(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val lastMessages: List&lt;WebsocketMessageModel&gt;
)</pre> <p class="calibre3">Now, in order <a id="_idIndexMarker233" class="calibre6 pcalibre1 pcalibre"/>to provide the dependencies that <code>ChatRoomDataSource</code> needs, we have to set our <code>ChatModule</code> class in the following way:</p>
<pre class="source-code">
@InstallIn(SingletonComponent::class)
@Module
abstract class ChatModule {
    companion object {
        const val WEBSOCKET_URL =
            "ws://whatspackt.com/chat/%s"
        const val WEBSOCKET_URL_NAME = "WEBSOCKET_URL"
        const val WEBSOCKET_CLIENT = "WEBSOCKET_CLIENT"
        const val API_CHAT_ROOM_URL =
            "http://whatspackt.com/chats/%s"
        const val API_CHAT_ROOM_URL_NAME = "CHATROOM_URL"
        const val API_CLIENT = "API_CLIENT"
    }
    @Provides
    @Named(WEBSOCKET_CLIENT)
    fun providesWebsocketHttpClient(): HttpClient {
        return WebsocketClient.client
    }
    @Provides
    @Named(WEBSOCKET_URL_NAME)
    fun providesWebsocketURL(): String {
        return WEBSOCKET_URL
    }
    @Binds
    abstract fun providesMessagesRepository(
        messagesRepository: MessagesRepository
    ): IMessagesRepository
    @Provides
    @Named(API_CLIENT)
    fun providesAPIHttpClient(): HttpClient {
        return RestClient.client
    }
}</pre> <p class="calibre3">As both <a id="_idIndexMarker234" class="calibre6 pcalibre1 pcalibre"/>the <code>providesWebsocketClient</code> and <code>providesApiHttpClient</code> functions are returning the same type (<code>HttpClient</code>), we need them to be identifiable so that we can indicate to Hilt which dependency it should provide to <code>WebsocketDataSource</code> and which one goes to <code>ChatRoomDataSource</code>. That’s the reason we are using qualifiers.</p>
<p class="callout-heading">Note</p>
<p class="callout">Using qualifiers <a id="_idIndexMarker235" class="calibre6 pcalibre1 pcalibre"/>allows the <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>) framework to determine the correct instance of a dependency to inject when there are multiple instances available of the same type. This ensures that the right instance is provided, preventing conflicts or ambiguity in your dependency management.</p>
<p class="calibre3">In the <a id="_idIndexMarker236" class="calibre6 pcalibre1 pcalibre"/>next code block, we are using a <code>WEBSOCKET_CLIENT</code> constant as the qualifier for the WebSocket <code>HttpClient</code> instance and <code>API_CLIENT</code> for the REST API <code>HttpClient</code> instance:</p>
<pre class="source-code">
@Provides
@Named(WEBSOCKET_CLIENT)
fun providesWebsocketHttpClient(): HttpClient {
    return WebsocketClient.client
}
@Provides
@Named(API_CLIENT)
fun providesAPIHttpClient(): HttpClient {
    return RestClient.client
}</pre> <p class="calibre3">We should also use qualifiers to provide URLs for the WebSocket and for the API. Also, it is important to note that these URL values are now being provided by a companion object in <code>ChatModule</code> for simplification, but a better approach would be to have them defined as part of our Gradle file. That way, we will be able to override them depending on the build variant (release, debug, test, and so on) or flavor.</p>
<p class="calibre3">Regarding the qualifiers, we also need to indicate in the consumers of these dependencies which one should be injected. This will be done using the <code>@Named</code> annotation in the affected dependencies as follows:</p>
<pre class="source-code">
class ChatRoomDataSource @Inject constructor(
    @Named(API_CLIENT) private val client: HttpClient,
    @Named(API_CHAT_ROOM_URL_NAME) private val url: String
) {
    suspend fun getInitialChatRoom(id: String):
    ChatRoomModel {
        return client.get(url.format(id)).body()
    }
}</pre> <p class="calibre3">Also, we have <a id="_idIndexMarker237" class="calibre6 pcalibre1 pcalibre"/>to modify the constructor in <code>MessagesSocketDataSource</code> so that Hilt knows which one it has to inject:</p>
<pre class="source-code">
class MessagesSocketDataSource @Inject constructor(
    @Named(WEBSOCKET_CLIENT) private val httpClient:
        HttpClient,
    @Named(WEBSOCKET_URL_NAME) private val websocketUrl:
        String
) { ... }</pre> <p class="calibre3">Now that we have everything ready for our dependencies to be injected the correct way, it is time to implement the <code>ChatRoomRepository</code> component. We will implement it in a similar way that we implemented the <code>MessagesRepository</code> component.</p>
<p class="calibre3">First, we want to create an interface in our domain package:</p>
<pre class="source-code">
package com.packt.feature.chat.domain
import com.packt.feature.chat.domain.models.ChatRoom
interface IChatRoomRepository {
    suspend fun getInitialChatRoom(id: String): ChatRoom
}</pre> <p class="calibre3">Then, we will <a id="_idIndexMarker238" class="calibre6 pcalibre1 pcalibre"/>create the actual implementation in the <code>data.repository</code> package:</p>
<pre class="source-code">
package com.packt.feature.chat.data.network.repository
import com.packt.feature.chat.data.network.datasource
.ChatRoomDataSource
import com.packt.feature.chat.domain.IChatRoomRepository
import com.packt.feature.chat.domain.models.ChatRoom
import javax.inject.Inject
class ChatRoomRepository @Inject constructor(
    private val dataSource: ChatRoomDataSource
): IChatRoomRepository {
    override suspend fun getInitialChatRoom(id: String):
    ChatRoom {
        val chatRoomApiModel =
            dataSource.getInitialChatRoom(id)
        return chatRoomApiModel.toDomain()
    }
}</pre> <p class="calibre3">Here, we are obtaining the initial chat room information from the data source, and then we will map the obtained data model into the domain model.</p>
<p class="calibre3">Of course, this will not work unless we create the domain model, <code>ChatRoom</code>:</p>
<pre class="source-code">
package com.packt.feature.chat.domain.models
data class ChatRoom(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val lastMessages: List&lt;Message&gt;
)</pre> <p class="calibre3">Then, we <a id="_idIndexMarker239" class="calibre6 pcalibre1 pcalibre"/>should create the mapping from <code>ChatRoomModel</code>:</p>
<pre class="source-code">
@Serializable
data class ChatRoomModel(
    val id: String,
    val senderName: String,
    val senderAvatar: String,
    val lastMessages: List&lt;WebsocketMessageModel&gt;
) {
    fun toDomain(): ChatRoom {
        return ChatRoom(
            id = id,
            senderName = senderName,
            senderAvatar = senderAvatar,
            lastMessages = lastMessages.map { it.toDomain() }
        )
    }
}</pre> <p class="calibre3">Here, we have just added the <code>toDomain()</code> function, which will map the data object (<code>ChatRoomModel</code>) to the domain object (<code>ChatRoom</code>).</p>
<p class="calibre3">Now, we need <a id="_idIndexMarker240" class="calibre6 pcalibre1 pcalibre"/>to bind the repository interface to its implementation. For that, we should add a binding declaration to our Hilt module:</p>
<pre class="source-code">
@Binds
abstract fun providesChatRoomRepository(
    chatRoomRepository: ChatRoomRepository
): IChatRoomRepository</pre> <p class="calibre3">Here, we are saying to Hilt that every time it needs to provide an <code>IChatRoomRepository</code> dependency, it should provide <code>ChatRoomRepository</code>.</p>
<p class="calibre3">Now, we have the data source and the repository ready. We will need to implement a new use case whose responsibility will be to provide this initial information:</p>
<pre class="source-code">
package com.packt.feature.chat.domain.usecases
import com.packt.feature.chat.domain.IChatRoomRepository
import com.packt.feature.chat.domain.models.ChatRoom
import javax.inject.Inject
class GetInitialChatRoomInformation @Inject constructor(
    private val repository: IChatRoomRepository
) {
    suspend operator fun invoke(id: String): ChatRoom {
        return repository.getInitialChatRoom(id)
    }
}</pre> <p class="calibre3">Here, we will be calling the repository <code>getInitialChatRoom()</code> function, to obtain it in the <code>ChatRoom</code> model.</p>
<p class="calibre3">We are <a id="_idIndexMarker241" class="calibre6 pcalibre1 pcalibre"/>now arriving at our destination: the <code>ViewModel</code>. We need to include <code>GetInitial</code><strong class="source-inline">
ChatRoomInformation</strong> as a dependency on the <code>ViewModel</code>, obtain this information when it is initialized, and make it available for the UI to observe it:</p>
<pre class="source-code">
@HiltViewModel
class ChatViewModel @Inject constructor(
    private val retrieveMessages: RetrieveMessages,
    private val sendMessage: SendMessage,
    private val disconnectMessages: DisconnectMessages,
    private val getInitialChatRoomInformation:
        GetInitialChatRoomInformation
) : ViewModel() {...}</pre> <p class="calibre3">Next, we need to create a new <code>StateFlow</code> instance to be consumed by the UI. As it is going to hold the state of almost all the UI (except the messages; we will talk about this later), we are going to call it <code>uiState</code>:</p>
<pre class="source-code">
private val _uiState = MutableStateFlow(Chat())
val uiState: StateFlow&lt;Chat&gt; = _uiState</pre> <p class="calibre3">Now, we are going to add a new function to be called upon view initialization:</p>
<pre class="source-code">
fun loadChatInformation(id: String) {
    messageCollectionJob =
    viewModelScope.launch(Dispatchers.IO) {
        val chatRoom = getInitialChatRoomInformation(id)
        withContext(Dispatchers.Main) {
            _uiState.value = chatRoom.toUI()
            _messages.value = chatRoom.lastMessages.map {
                it.toUI()}
            updateMessages()
        }
    }
}</pre> <p class="calibre3">Here, we are using <code>messagesCollectionJob</code> (we could change its name to make it more <a id="_idIndexMarker242" class="calibre6 pcalibre1 pcalibre"/>generic as now it is going to be used by the <code>messages</code> collection job and the initial data retrieval).</p>
<p class="calibre3">Then, we retrieve the initial chat room information, update the <code>uiState</code> value, and set the messages we are receiving as the first messages in the <code>messages</code> <code>StateFlow</code> object (so that the chat will show the old messages).</p>
<p class="calibre3">Finally, we call the <code>updateMessages()</code> function, where we will connect to the WebSocket and start getting asynchronous messages.</p>
<p class="calibre3">Note that we will also need a <code>Chat</code> model that will be our <code>uiState</code> instance; this model is important as it will be the object consumed from the UI to configure it. Add this like so:</p>
<pre class="source-code">
data class Chat(
    val id: String? = null,
    val name: String? = null,
    val avatar: String? = null
)
fun ChatRoom.toUI() = run {
    Chat(
        id = id,
        name = senderName,
        avatar = senderAvatar
    )
}</pre> <p class="calibre3">Now, we need <a id="_idIndexMarker243" class="calibre6 pcalibre1 pcalibre"/>to listen to this <code>uiState</code> instance from our screen composable and update the UI accordingly:</p>
<pre class="source-code">
@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel(),
    chatId: String?,
    onBack: () -&gt; Unit
) {
    val messages by viewModel.messages.collectAsState()
<strong class="bold1">    val uiState by viewModel.uiState.collectAsState()</strong>
<strong class="bold1">    LaunchedEffect(Unit) {</strong>
<strong class="bold1">        viewModel.loadChatInformation(chatId.orEmpty())</strong>
<strong class="bold1">    }</strong>
    Scaffold(
        topBar = {
            TopAppBar(
                title = {
<strong class="bold1">                   Text(stringResource(R.string.chat_title,</strong>
<strong class="bold1">                   uiState.name.orEmpty()))</strong>
                }
            )
        },
        bottomBar = {
            SendMessageBox { viewModel.onSendMessage(it) }
        }
    ) { paddingValues-&gt;
        ListOfMessages(paddingValues = paddingValues,
        messages = messages)
    }
}</pre> <p class="calibre3">Here, we can see that we are calling the <code>loadChatInformation</code> function as soon as the <code>Composable</code> component is started. Then, once this information is obtained, we would show the name of the participant of the chat in the <code>TopAppBar</code> component, obtaining <a id="_idIndexMarker244" class="calibre6 pcalibre1 pcalibre"/>this info from the chat initialization. At the same time, the list of messages will be updated with the last messages.</p>
<p class="calibre3">Usually, it is desirable to encapsulate all the <code>uiState</code> properties in a single observable value as one of the advantages of Jetpack Compose is that it will handle the recomposition when it detects that the values related to a <code>Composable</code> component have changed. In this case, the criteria followed have been to separate them because in reality, the frequency of changes is very different between the two values:</p>
<ul class="calibre15">
<li class="calibre14">The <strong class="source-inline1">uiState</strong> properties are not going to change for the same chat</li>
<li class="calibre14">The <strong class="source-inline1">messages</strong> list is likely to change with a high frequency (every time we send and receive a message)</li>
</ul>
<p class="calibre3">During this section, we have set up our chat initialization, including all the components needed for the architecture, from the data source to the <code>ViewModel</code> changes. Now, it is time we take care of possible errors we could encounter and give some resilience to our chat screen.</p>
<h2 id="_idParaDest-50" class="calibre7"><a id="_idTextAnchor050" class="calibre6 pcalibre1 pcalibre"/>Handling errors in the WebSocket</h2>
<p class="calibre3">Errors are not unusual, especially in a long-lived connection such as a WebSocket, and in such a <a id="_idIndexMarker245" class="calibre6 pcalibre1 pcalibre"/>sensitive environment as a mobile one, it is important to take care of these errors because otherwise, our users could stop being able to send <a id="_idIndexMarker246" class="calibre6 pcalibre1 pcalibre"/>or receive messages and, in the worst case, have a fatal error that crashes the application.</p>
<p class="calibre3">There are several ways we can control these errors. One of them is to make every layer responsible for errors that could happen in its scope and only propagate to the UI (or the user knowledge) when the app cannot recover itself from them.</p>
<p class="calibre3">Here, we could have several errors:</p>
<ul class="calibre15">
<li class="calibre14">Connection errors that are recuperable errors and will be handled by a retry</li>
<li class="calibre14">Parsing errors that are likely not recuperable as several retries will not change the way the app or the backend are formatting the messages (we cannot do much with these kinds of errors, apart from detecting them before deploying the app or having analytics tools to detect them)</li>
</ul>
<p class="calibre3">In this section, we are going to focus on <code>MessagesSocketDataSource</code>. If we take a look at our <code>connect</code> function, we can see it could have some points of failure (for example, when initiating the session or when the message received is handled). The simplest way to solve this is to wrap those points with <code>try</code>-<code>catch</code> blocks:</p>
<pre class="source-code">
suspend fun connect(): Flow&lt;Message&gt; {
    return flow {
        // Wrap the connection attempt with a try-catch
           block
        try {
            httpClient.webSocketSession { url(websocketUrl) }
                .apply { webSocketSession = this }
                .incoming
                .receiveAsFlow()
                .collect { frame -&gt;
                    try {
                        // Handle errors while processing
                           the message
                        val message =
                            webSocketSession.handleMessage(
                                frame)?.toDomain()
                        if (message != null) {
                            emit(message)
                        }
                    } catch (e: Exception) {
                        // Log or handle the error
                           gracefully
                        Log.e(TAG, "Error handling
                            WebSocket frame", e)
                    }
                }
        } catch (e: Exception) {
            // Log or handle the connection error
               gracefully
            Log.e(TAG, "Error connecting to WebSocket", e)
        }
    }.retryWhen { cause, attempt -&gt;
        // Implement a retry strategy based on the cause
           and/or the number of attempts
        if (cause is IOException &amp;&amp; attempt &lt; MAX_RETRIES)
        {
            delay(RETRY_DELAY)
            true
        } else {
            false
        }
    }.catch { e -&gt;
        // Handle exceptions from the Flow
        Log.e(TAG, "Error in WebSocket Flow", e)
    }
}</pre> <p class="calibre3">We need <a id="_idIndexMarker247" class="calibre6 pcalibre1 pcalibre"/>to define also as constants <code>TAG</code> (to log messages in Logcat), <code>MAX_RETRIES</code>, which will be the number of retries we are going to use (because we cannot be eternally retrying), and <code>RETRY_DELAY</code> (the milliseconds we are <a id="_idIndexMarker248" class="calibre6 pcalibre1 pcalibre"/>going to wait between retries):</p>
<pre class="source-code">
companion object {
    const val TAG = "MessagesSocketDataSource"
    const val RETRY_DELAY = 30000
    const val MAX_RETRIES = 5
}</pre> <p class="calibre3">Here, we are defining these values as constants, so if the WebSocket connection fails, we will retry the connection in another 30 seconds (<code>30000</code> milliseconds). This will occur <code>5</code> times before giving up if it doesn’t successfully connect.</p>
<p class="calibre3">Now that our users are receiving messages while using the app, we still need to provide a way of notifying them when they receive a new message but are not using the app. We can solve this problem by using push notifications.</p>
<h1 id="_idParaDest-51" class="calibre5"><a id="_idTextAnchor051" class="calibre6 pcalibre1 pcalibre"/>Adding push notifications</h1>
<p class="calibre3">Push notifications are messages that are sent to a user’s device from a server, even when the <a id="_idIndexMarker249" class="calibre6 pcalibre1 pcalibre"/>user is not actively using the app. These messages appear as system notifications outside of the app and can be used to provide updates, alerts, or other relevant information to users.</p>
<p class="calibre3">To send push notifications, we need to decide which of the available options we want to use. The <a id="_idIndexMarker250" class="calibre6 pcalibre1 pcalibre"/>most popular is <strong class="bold">Firebase Cloud Messaging</strong> (<strong class="bold">FCM</strong>), but there are more push notification services such as OneSignal, Pusher, or <strong class="bold">Amazon Simple Notification Service</strong> (<strong class="bold">SNS</strong>). In our case, we are going to take <a id="_idIndexMarker251" class="calibre6 pcalibre1 pcalibre"/>the popular route and use FCM.</p>
<p class="calibre3"><strong class="bold">Firebase</strong> is a mobile <a id="_idIndexMarker252" class="calibre6 pcalibre1 pcalibre"/>and web application development platform provided by Google. It offers a suite of tools, services, and infrastructure designed to help developers build, improve, and grow their apps. Some of its features include authentication, push notifications, cloud databases, and so on. We are going to use it for the last two sections of this chapter.</p>
<p class="calibre3">To accomplish that, we first need to set up Firebase in our project.</p>
<h2 id="_idParaDest-52" class="calibre7"><a id="_idTextAnchor052" class="calibre6 pcalibre1 pcalibre"/>Setting up Firebase</h2>
<p class="calibre3">To set <a id="_idIndexMarker253" class="calibre6 pcalibre1 pcalibre"/>up Firebase in our project, we need to follow these steps:</p>
<ol class="calibre13">
<li class="calibre14">Go to the Firebase console (<a href="https://console.firebase.google.com/" class="calibre6 pcalibre1 pcalibre">https://console.firebase.google.com/</a>) and click <strong class="bold">Add project</strong>. Then, follow the onscreen instructions to set up your project.</li>
<li class="calibre14">In the Firebase console, click on the Android icon to register your app. Enter your app’s package name, and optionally, provide the SHA-1 fingerprint for Google Sign-In and other authentication features. Click <strong class="bold">Register app</strong> to proceed.</li>
<li class="calibre14">After registering our app, we’ll be prompted to download a <strong class="source-inline1">google-services.json</strong> file. Download it and place it in the <strong class="source-inline1">app</strong> module of our Android project, at the root level.</li>
<li class="calibre14">Add Firebase SDK dependencies to your project’s <strong class="source-inline1">build.gradle</strong> files, like so:<pre class="source-code">
classpath 'com.google.gms:google-services:
$latest_version'</pre></li> <li class="calibre14">Then in <a id="_idIndexMarker254" class="calibre6 pcalibre1 pcalibre"/>the <strong class="source-inline1">app</strong> module’s <strong class="source-inline1">build.gradle</strong> file where we are going to use it (in our case, <strong class="source-inline1">:common:data</strong>), we should add these dependencies for the following specific Firebase services:<pre class="source-code">
implementation platform('com.google.firebase:
    firebase-bom:$latest_version')
implementation 'com.google.firebase:firebase-auth'
implementation 'com.google.firebase:
    firebase-firestore'
implementation 'com.google.firebase:
    firebase-messaging'</pre><p class="calibre3">Note that, as we <a id="_idIndexMarker255" class="calibre6 pcalibre1 pcalibre"/>did with Jetpack Compose dependencies, here we are going to use the <strong class="bold">Bill of Materials</strong> (<strong class="bold">BoM</strong>). The advantage is that we don’t need to specify the version of every dependency because the compatible ones will be provided by the BoM.</p></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">A BoM is a mechanism used in dependency management systems to specify and manage the versions of multiple libraries and their transitive dependencies as a single entity. It helps simplify dependency management and ensures compatibility between different libraries that are part of the same ecosystem or suite.</p>
<ol class="calibre13">
<li value="6" class="calibre14">Also, in order to facilitate the use of coroutines to handle Firebase tasks, we are going to add this extra dependency:<pre class="source-code">
implementation 'org.jetbrains.kotlinx:
kotlinx-coroutines-play-services:$latest_version'</pre></li> </ol>
<p class="calibre3">Now, before we can receive a push notification, we need to identify our user. We do that by sending their token to Firebase.</p>
<h2 id="_idParaDest-53" class="calibre7"><a id="_idTextAnchor053" class="calibre6 pcalibre1 pcalibre"/>Sending the FCM token to Firebase</h2>
<p class="calibre3">To identify <a id="_idIndexMarker256" class="calibre6 pcalibre1 pcalibre"/>our users and send notifications <a id="_idIndexMarker257" class="calibre6 pcalibre1 pcalibre"/>specifically to them using FCM, we need to use FCM <strong class="bold">tokens</strong>. Each user is assigned a unique FCM token, which is used to send <a id="_idIndexMarker258" class="calibre6 pcalibre1 pcalibre"/>notifications to their devices. This token should be obtained and updated every time the user signs in or when the app starts.</p>
<p class="calibre3">We can obtain the FCM token by calling the <code>getToken()</code> method from the <code>FirebaseMessaging</code> class. To do that, we are going first to create a data source that will wrap the token-handling functionality:</p>
<pre class="source-code">
package com.packt.data
import com.google.firebase.messaging.FirebaseMessaging
import kotlinx.coroutines.tasks.await
import javax.inject.Inject
class FCMTokenDataSource @Inject constructor(
    private val firebaseMessaging: FirebaseMessaging =
    FirebaseMessaging.getInstance()
) {
    suspend fun getFcmToken(): String? {
        return try {
            FirebaseMessaging.getInstance().token.await()
        } catch (e: Exception) {
            null
        }
    }
}</pre> <p class="calibre3">Here, we are injecting the <code>FirebaseMessaging</code> instance and obtaining the FCM token from Firebase.</p>
<p class="calibre3">Now, we need this FCM to be stored somewhere so that when a new message is sent to our users, we know which token is associated with them. There is no standard way to store it. Usually, this will be handled in the backend, which is far from the scope of this book. But we <a id="_idIndexMarker259" class="calibre6 pcalibre1 pcalibre"/>can prepare the app components needed. We <a id="_idIndexMarker260" class="calibre6 pcalibre1 pcalibre"/>are going to create a use case that would be <a id="_idIndexMarker261" class="calibre6 pcalibre1 pcalibre"/>the orchestrator of obtaining and then sending the FCM to be stored in the backend. This use case will need a repository to do both tasks: obtaining the token and storing it in our systems.</p>
<p class="calibre3">As always, create the interface for our repository in the domain layer (in this case, in the <code>:</code><code>common:domain</code> module):</p>
<pre class="source-code">
interface IFCMTokenRepository {
    suspend fun getFCMToken(): String
}</pre> <p class="calibre3">Then, we will create the repository implementation in the data layer (<code>:common:data</code>):</p>
<pre class="source-code">
class FCMTokenRepository @Inject constructor(
    private val tokenDataSource: FCMTokenDataSource
) {
    suspend fun getToken(): String? {
        return tokenDataSource.getFcmToken()
    }
}</pre> <p class="calibre3">We will use this repository to obtain the token from Firebase. As said before, we also need to store the token somewhere, so we will create another repository for that:</p>
<pre class="source-code">
interface IInternalTokenRepository {
    suspend fun storeToken(userId: String, token: String)
}</pre> <p class="calibre3">We will again leave the implementation empty as it is outside our scope. The relevant bit to understand here is that the token should be stored so that later, when our user receives a message, we can identify the token and send a push notification to the related device.</p>
<p class="calibre3">In the <a id="_idIndexMarker262" class="calibre6 pcalibre1 pcalibre"/>next code block, we can see how <a id="_idIndexMarker263" class="calibre6 pcalibre1 pcalibre"/>we are implementing the aforementioned interface, where <a id="_idIndexMarker264" class="calibre6 pcalibre1 pcalibre"/>you will provide the means to store the data source of your preference:</p>
<pre class="source-code">
class InternalTokenRepository(): IInternalTokenRepository {
    override suspend fun storeToken(userId: String, token:
    String) {
        // Store in the data source of your choosing
    }
}</pre> <p class="calibre3">Now that we have the token sorted, we need to prepare our app to receive push notifications.</p>
<h2 id="_idParaDest-54" class="calibre7"><a id="_idTextAnchor054" class="calibre6 pcalibre1 pcalibre"/>Preparing the app to receive push notifications</h2>
<p class="calibre3">Push notifications are messages that pop up on a mobile device. They are especially useful <a id="_idIndexMarker265" class="calibre6 pcalibre1 pcalibre"/>when the user is not actively using the application and we need to call their attention. In this section, we are going to make our app capable of receiving them when a new message is received.</p>
<p class="calibre3">To start receiving push notifications, we need to make some modifications to our existing code first. For example, we have to think about what would we expect to happen if the user clicks on a notification: we may want it to open the <code>ChatScreen</code> component related to the message notification. Let’s start with those changes.</p>
<p class="calibre3">To open the <code>ChatScreen</code> component directly, we will need to create a link that tells the system that it should open our application showing the <code>ChatScreen</code> component. This link is called a deep link.</p>
<p class="calibre3">A <strong class="bold">deep link</strong> is a type <a id="_idIndexMarker266" class="calibre6 pcalibre1 pcalibre"/>of link that directs a user to a specific piece of content or page within an Android application rather than just launching the application. Deep links are used to provide a more seamless user experience by allowing users to jump directly to a particular function, feature, or piece of content within an app from a website, another app, or even a simple text message or email.</p>
<p class="calibre3">To create <a id="_idIndexMarker267" class="calibre6 pcalibre1 pcalibre"/>our deep link, we are going to create an object called <code>DeepLinks</code> in the <code>:common:framework</code> module to organize all the deep links we are going to use in our application:</p>
<pre class="source-code">
package com.packt.framework.navigation
object DeepLinks {
    const val chatRoute =
        "https://whatspackt.com/chat?chatId={chatId}"
}</pre> <p class="calibre3">Then, we need to modify our <code>NavHost</code> component– once the application receives an intent with this deep comlink, the app should navigate to the <code>ChatScreen</code> component. To accomplish that, we need to add a <code>Deeplink</code> instance as an option for the <code>ChatScreen</code> navigation graph in <code>WhatsPacktNavigation</code>:</p>
<pre class="source-code">
private fun NavGraphBuilder.addChat(navController:
NavHostController) {
    composable(
        route = NavRoutes.Chat,
        arguments = listOf(
            navArgument(NavRoutes.ChatArgs.ChatId) {
                type = NavType.StringType }),
        deepLinks = listOf(
            navDeepLink {
                uriPattern = DeepLinks.chatRoute
            }
        )
    ) { backStackEntry -&gt;
        val chatId = backStackEntry.arguments?.getString(
            NavRoutes.ChatArgs.ChatId)
        ChatScreen(chatId = chatId, onBack = {
            navController.popBackStack() })
    }
}</pre> <p class="calibre3">Here, we are adding the deep link pattern that we have in our <code>DeepLinks</code> object to be included as one of the route options for our <code>ChatScreen</code> component.</p>
<p class="calibre3">Then, we need to implement a <code>FirebaseMessagingService</code> function that will catch all the <a id="_idIndexMarker268" class="calibre6 pcalibre1 pcalibre"/>push notifications that we receive and will allow us to define a channel where notifications will be posted and handled by the Android system, ultimately showing them to the user (if the user has given our app permissions to do that):</p>
<pre class="source-code">
class WhatsPacktMessagingService:
FirebaseMessagingService() {
    companion object {
        const val CHANNEL_ID = "Chat_message"
        const val CHANNEL_DESCRIPTION = "Receive a
            notification when a chat message is received"
        const val CHANNEL_TITLE = "New chat message
            notification"
    }
    override fun onMessageReceived(remoteMessage:
    RemoteMessage) {
        super.onMessageReceived(remoteMessage)
        if (remoteMessage.data.isNotEmpty()) {
            // We can extract information such as the
               sender, message content, or chat ID
            val senderName =
                remoteMessage.data["senderName"]
            val messageContent =
                remoteMessage.data["message"]
            val chatId = remoteMessage.data["chatId"]
            val messageId = remoteMessage.data["messageId"]
            // Create and show a notification for the
               received message
            if (chatId != null &amp;&amp; messageId != null) {
                showNotification(senderName, messageId,
                messageContent, chatId)
            }
        }
    }
    private fun showNotification(senderName: String?,
    messageId: String, messageContent: String?,
    chatId: String) {
        // Implement here the notification
    }
}</pre> <p class="calibre3">Here, we are extracting some information from the message received, such as <code>senderName</code>, <code>messageContent</code>, <code>chatId</code>, and so on. Ideally, we could obtain the information we want to show in the notification.</p>
<p class="calibre3">This is just <a id="_idIndexMarker269" class="calibre6 pcalibre1 pcalibre"/>an example, though – the information structure would depend on the payload contract we already defined with the backend implementation.</p>
<p class="calibre3">Once we have extracted this information, we need to show the notification:</p>
<pre class="source-code">
private fun showNotification(senderName: String?,
messageId: String, messageContent: String?, chatId: String)
{
    val notificationManager = getSystemService(
       Context.NOTIFICATION_SERVICE) as NotificationManager
    // Create a notification channel
    // (if you want to support versions lower than Android
       Oreo, you will have to check the version here)
    val channel = NotificationChannel(
        CHANNEL_ID,
        CHANNEL_TITLE,
        NotificationManager.IMPORTANCE_DEFAULT
    ).apply {
        description = CHANNEL_DESCRIPTION
    }
    notificationManager.createNotificationChannel(channel)
    // Create an Intent to open the chat when the
       notification is clicked. Here is where we are going
       to use our newly created deeplink
    val deepLinkUrl =
        DeepLinks.chatRoute.replace("{chatId}", chatId)
    val intent = Intent(Intent.ACTION_VIEW,
    Uri.parse(deepLinkUrl)).apply {
        flags = Intent.FLAG_ACTIVITY_NEW_TASK or
        Intent.FLAG_ACTIVITY_CLEAR_TASK
    }
    // Create a PendingIntent for the Intent
    val pendingIntent = PendingIntent.getActivity(this, 0,
        intent, PendingIntent.FLAG_IMMUTABLE)
    // Build the notification
    val notification = NotificationCompat.Builder(this,
        CHANNEL_ID)
        .setSmallIcon(R.drawable.our_notification_icon_for_
            whatspackt)
        .setContentTitle(senderName)
        .setContentText(messageContent)
        .setContentIntent(pendingIntent)
        .setAutoCancel(true)
        .build()
    // Show the notification
    notificationManager.notify(messageId.toInt(),
        notification)
}</pre> <p class="calibre3">First, we create a <code>NotificationChannel</code> instance, then the elements we need for our notification (such as <code>PendingIntent</code>, which will be used when the user clicks on the notification), and then <a id="_idIndexMarker270" class="calibre6 pcalibre1 pcalibre"/>the notification itself (using <code>NotificationCompat</code>). Finally, we use <code>NotificationManager</code> to notify our notification to the system.</p>
<p class="callout-heading">Note</p>
<p class="callout">Creating a <strong class="source-inline1">NotificationChannel</strong> instance is necessary for Android 8.0 (API level 26) and higher, as it provides users with better control over the app’s notifications. Each <strong class="source-inline1">NotificationChannel</strong> instance represents a unique category of notifications that an app can display, and users can modify the settings for each channel independently. This enables users to customize the behavior of your app’s notifications based on their preferences.</p>
<p class="callout">For example, users can set the importance level, enable/disable sound, or set a custom vibration pattern for each channel. They can also block an entire channel so that they no longer receive notifications from that specific category.</p>
<p class="callout">When you create a <strong class="source-inline1">NotificationChannel</strong> instance, you need to set an importance level, which determines how the system presents notifications from that channel to the user. The importance levels range from high (urgent and makes a sound) to low (no sound or visual interruption).</p>
<p class="calibre3">The last <a id="_idIndexMarker271" class="calibre6 pcalibre1 pcalibre"/>step is to add our service to the <code>AndroidManifest.xml</code> file, inside the <code>application</code> tag:</p>
<pre class="source-code">
&lt;application
    android:allowBackup = "true"
    android:dataExtractionRules =
        "@xml/data_extraction_rules"
    android:fullBackupContent = "@xml/backup_rules"
    android:icon = "@mipmap/ic_launcher"
    android:label = "@string/app_name"
    android:supportsRtl = "true"
    android:theme = "@style/Theme.WhatsPackt"
    tools:targetApi = "31"&gt;
    &lt;activity
        android:name = ".MainActivity"
        android:exported = "true"
        android:label = "@string/app_name"
        android:theme = "@style/Theme.WhatsPackt"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=
                "android.intent.action.MAIN" /&gt;
            &lt;category android:name =
                "android.intent.category.LAUNCHER" /&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
    &lt;service
        android:name =
            "com.packt.data.WhatsPacktMessagingService"
        android:exported = "false"&gt;
        &lt;intent-filter&gt;
            &lt;action android:name =
                "com.google.firebase.MESSAGING_EVENT" /&gt;
        &lt;/intent-filter&gt;
    &lt;/service&gt;
&lt;/application&gt;</pre> <p class="calibre3">And with <a id="_idIndexMarker272" class="calibre6 pcalibre1 pcalibre"/>that, we have our app ready to receive push notifications.</p>
<p class="calibre3">In the next section, we are going to see how after all the work we have done to keep our code scalable and decoupled, we can easily use Firebase instead of the WebSocket to send and receive messages.</p>
<h1 id="_idParaDest-55" class="calibre5"><a id="_idTextAnchor055" class="calibre6 pcalibre1 pcalibre"/>Replacing the Websocket with Firestore</h1>
<p class="calibre3">As we <a id="_idIndexMarker273" class="calibre6 pcalibre1 pcalibre"/>saw in the previous section, Firebase is a powerful <a id="_idIndexMarker274" class="calibre6 pcalibre1 pcalibre"/>product that simplifies the implementation of the backend for our apps. Now, we are going to see how we can use it also to simplify the chat messages feature.</p>
<h2 id="_idParaDest-56" class="calibre7"><a id="_idTextAnchor056" class="calibre6 pcalibre1 pcalibre"/>What is Firestore?</h2>
<p class="calibre3"><strong class="bold">Firestore</strong>, more formally <a id="_idIndexMarker275" class="calibre6 pcalibre1 pcalibre"/>known as Cloud <a id="_idIndexMarker276" class="calibre6 pcalibre1 pcalibre"/>Firestore, is a flexible, scalable, and real-time NoSQL database provided by Firebase. Firestore is designed to store and sync data for client-side applications, making it an ideal choice for building modern, data-driven applications.</p>
<p class="calibre3">One of its most important features is the real-time data synchronization. Firestore automatically synchronizes data in real time across all connected clients, ensuring that your application’s data is always up to date. This is especially useful for applications requiring real-time collaboration or live updates, such as our chat app.</p>
<p class="calibre3">It is important to note that as a NoSQL database, we would have first to define the data structure. How are we to structure our documents? Well, let’s start with that.</p>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor057" class="calibre6 pcalibre1 pcalibre"/>Chat data structure</h2>
<p class="calibre3">To handle <a id="_idIndexMarker277" class="calibre6 pcalibre1 pcalibre"/>chat messages in Firestore NoSQL, we can use the following structure:</p>
<ul class="calibre15">
<li class="calibre14">Create a collection called <strong class="source-inline1">chats</strong>. Each document in this collection will represent a chat room or conversation between users. The document ID can be generated automatically by Firestore or created using a custom method (for example, a combination of user IDs). Here, we can include common data that we need for the conversation (think about our <strong class="source-inline1">ChatRoom</strong> model), such as the user’s name, avatars, and so on...</li>
<li class="calibre14">For each chat document, create a subcollection called <strong class="source-inline1">messages</strong>. This subcollection will store the individual messages for that chat room or conversation.</li>
<li class="calibre14">Each document in the <strong class="source-inline1">messages</strong> subcollection will represent a single message. The structure of a message document might include fields such as <strong class="source-inline1">senderId</strong>, <strong class="source-inline1">senderName</strong>, <strong class="source-inline1">content</strong>, and <strong class="source-inline1">timestamp</strong>.</li>
</ul>
<p class="calibre3">Following that, our structure will look like this:</p>
<pre class="source-code">
chats (collection)
  |
  └── chatId1 (document)
        |
        ├── users (subcollection)
        │   |
        │   ├── userId1 (document)
        │   │   ├── userId: "user1"
        │   │   ├── avatarUrl:
                      "https://example.com/avatar1.jpg"
        │   │   └── name: "John Doe"
        │   │
        │   └── userId2 (document)
        │       ├── userId: "user2"
        │       ├── avatarUrl:
                      "https://example.com/avatar2.jpg"
        │       └── name: "Jane Smith"
        │
        └── messages (subcollection)
              |
              ├── messageId1 (document)
              │   ├── senderId: "user1"
              │   ├── senderName: "John Doe"
              │   ├── content: "Hello, how are you?"
              │   └── timestamp: 1648749123
              |
              └── messageId2 (document)
                    ├── senderId: "user2"
                    ├── senderName: "Jane Smith"
                    ├── content: "I'm doing great! How
                                 about you?"
                    └── timestamp: 1648749156</pre> <p class="calibre3">One important aspect is that, ideally, we should have authentication set up to identify our users. We will learn how to build it in <a href="B19443_07.xhtml#_idTextAnchor142" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 7</em></a>, but for now, we are assuming that our users will be authenticated in Firebase.</p>
<p class="calibre3">Assuming that <a id="_idIndexMarker278" class="calibre6 pcalibre1 pcalibre"/>our chat will be used by authenticated users, we can limit and restrict access to the chat collection for modifications only for users who have already been authenticated. To accomplish that, we can define a set of rules in Firestore, using the Firebase console. Here is an example:</p>
<pre class="source-code">
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow authenticated users to create chat documents,
       but not modify or delete them
    match /chats/{chatId} {
      allow create: if request.auth != null;
      allow read, update, delete: if false;
    }
    // Allow chat participants to read the chat's user data
    match /chats/{chatId}/users/{userId} {
      allow read: if request.auth != null &amp;&amp;
        request.auth.uid in resource.data.userId;
      allow write: if false;
    }
    // Allow authenticated users to create/modify messages
       in a chat they are participating in
    match /chats/{chatId}/messages/{messageId} {
      // Get chat participants
      function isChatParticipant() {
        let chatUsersDoc = get(
            /databases/$(database)/documents/chats/
                $(chatId)/users/$(request.auth.uid));
        return chatUsersDoc.exists();
      }
      // Check if the sender is the authenticated user
      function isSender() {
        return request.auth != null &amp;&amp; request.auth.uid ==
          request.resource.data.senderId;
      }
      allow create: if isChatParticipant() &amp;&amp; isSender();
      allow read: if isChatParticipant();
      allow update, delete: if false;
    }
  }
}</pre> <p class="calibre3">Now that we have defined these rules, we can switch to our Android app code and create a <code>FirestoreMessagesDataSource</code> class.</p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor058" class="calibre6 pcalibre1 pcalibre"/>Creating a FirestoreMessagesDataSource class</h2>
<p class="calibre3">The first step to creating the <code>FirestoreMessagesDataSource</code> class is to create the model <a id="_idIndexMarker279" class="calibre6 pcalibre1 pcalibre"/>that we are going to use to serialize the documents. This model has to include the same fields we included when we designed the <code>Message</code> document structure:</p>
<pre class="source-code">
import com.google.firebase.Timestamp
import com.google.firebase.firestore.PropertyName
import com.packt.feature.chat.domain.models.Message
import java.text.SimpleDateFormat
import java.util.*
data class FirestoreMessageModel(
    @Transient
    val id: String = "",
    @get:PropertyName("senderId")
    @set:PropertyName("senderId")
    var senderId: String = "",
    @get:PropertyName("senderName")
    @set:PropertyName("senderName")
    var senderName: String = "",
    @get:PropertyName("senderAvatar")
    @set:PropertyName("senderAvatar")
    var senderAvatar: String = "",
    @get:PropertyName("content")
    @set:PropertyName("content")
    var content: String = "",
    @get:PropertyName("timestamp")
    @set:PropertyName("timestamp")
    var timestamp: Timestamp = Timestamp.now()
)</pre> <p class="calibre3">Note that we are including a field called <code>id</code> that has the <code>@Transient</code> annotation – this field <a id="_idIndexMarker280" class="calibre6 pcalibre1 pcalibre"/>will store the document <code>id</code> value (that for us will be the unique identification for the message as every message has its own document). The reason we have to put the <code>@Transient</code> annotation is to avoid this <code>id</code> field being stored in the document itself when writing in Firestore.</p>
<p class="calibre3">Now, as we did with the <code>MessagesSocketDataSource</code> class, we need to convert this data model into the domain model. We already have the <code>messages</code> domain model, so, in this case, we only have to implement the function to convert the <code>FirestoreMessageModel</code> data class into our <code>Message</code> domain model:</p>
<pre class="source-code">
fun toDomain(userId: String): Message {
    return Message(
        id = id,
        senderName = senderName,
        senderAvatar = senderAvatar,
        isMine = userId == senderId,
        contentType = Message.ContentType.TEXT,
        content = content,
        contentDescription = "",
        timestamp = timestamp.toDateString()
    )
}
private fun Timestamp.toDateString(): String {
    // Create a SimpleDateFormat instance with the desired
       format and the default Locale
    val formatter = SimpleDateFormat("dd/MM/yyyy HH:mm:ss",
        Locale.getDefault())
    // Convert the Timestamp to a Date object
    val date = toDate()
    // Format the Date object using the SimpleDateFormat
       instance
    return formatter.format(date)
}</pre> <p class="calibre3">In this <a id="_idIndexMarker281" class="calibre6 pcalibre1 pcalibre"/>case, we are supposing we are only going to have text messages (no images) for simplification. However, it could have been easily done by including a field in the <code>Firestore</code> model indicating the type of message. Almost all the mapping between properties is straightforward, with the exception of the timestamp. In the <code>Message</code> model, we are expecting a <code>String</code> object with the date and time, and we are getting a <code>Timestamp</code> object from Firestore. So, we are using the <code>Timestamp.toDateString()</code> extension to obtain the formatted <code>String</code> object from the <code>Timestamp</code> object.</p>
<p class="calibre3">Also, as we would want to send messages too, we need to convert a domain <code>Message</code> object into the data object:</p>
<pre class="source-code">
companion object {
    fun fromDomain(message: Message): FirestoreMessageModel
    {
        return FirestoreMessageModel(
            id = "",
            senderName = message.senderName,
            senderAvatar = message.senderAvatar,
            content = message.content
        )
    }
}</pre> <p class="calibre3">Note that <a id="_idIndexMarker282" class="calibre6 pcalibre1 pcalibre"/>we are not setting the timestamp (it will be created when the object is created), and the <code>id</code> field doesn’t have a real value (as it won’t be stored in Firestore).</p>
<p class="calibre3">Now, we can proceed with the <code>FirestoreMessagesDataSource</code> implementation. First, we define the class and its dependency:</p>
<pre class="source-code">
class FirestoreMessagesDataSource @Inject constructor(
    private val firestore: FirebaseFirestore =
        FirebaseFirestore.getInstance()
) {</pre> <p class="calibre3">Then, we are going to add a <code>getMessages</code> function, to obtain chat messages:</p>
<pre class="source-code">
    fun getMessages(chatId: String, userId: String):
    Flow&lt;Message&gt; = callbackFlow {</pre> <p class="calibre3">Inside this function, we will get a reference to the <code>messages</code> subcollection inside the specified chat:</p>
<pre class="source-code">
        val chatRef =
            firestore.collection("chats").document(chatId)
                .collection("messages")</pre> <p class="calibre3">Now, we will create a query to get the messages ordered by timestamp (ascending):</p>
<pre class="source-code">
        val query = chatRef.orderBy("timestamp",
            Query.Direction.ASCENDING)</pre> <p class="calibre3">In the <a id="_idIndexMarker283" class="calibre6 pcalibre1 pcalibre"/>next step, we add a snapshot listener to the query to listen for real-time updates. Every time a document in the messages is added, we will get a snapshot of the changed document there so that we can emit it through the flow to the consumers connected (in our case, <code>MessagesRepository</code>):</p>
<pre class="source-code">
        val listenerRegistration =
        query.addSnapshotListener { snapshot, exception -&gt;
            // If there's an exception, close the Flow with
               the exception
            if (exception != null) {
                close(exception)
                return@addSnapshotListener
            }</pre> <p class="calibre3">Just before sending the new messages through the flow, we need to map them to their domain counterpart and provide their ID. Also, <code>userId</code> will be needed to identify if the user has written the new message or if it is written by the other user in the conversation:</p>
<pre class="source-code">
            val messages = snapshot?.documents?.mapNotNull
            { doc -&gt;
                val message =
                    doc.toObject(FirestoreMessageModel::
                    class.java)
                message?.copy(id = doc.id) // Copy the
                                              message with
                                              the document
                                              ID
            } ?: emptyList()
            val domainMessages = messages.map {
                it.toDomain(userId) }</pre> <p class="calibre3">Finally, we <a id="_idIndexMarker284" class="calibre6 pcalibre1 pcalibre"/>can send the list of messages to <code>Flow</code>:</p>
<pre class="source-code">
            domainMessages.forEach {
                try {
                    trySend(it).isSuccess
                } catch (e: Exception) {
                    close(e)
                }
            }
        }</pre> <p class="calibre3">In the case <code>Flow</code> is no longer needed, we should remove the snapshot listener:</p>
<pre class="source-code">
        awaitClose { listenerRegistration.remove() }
    }</pre> <p class="calibre3">We also need to add a function to send messages. To send a message, we will simply add it to the <code>messages</code> collection in the document with the <code>chatId</code> value of the related conversation:</p>
<pre class="source-code">
    fun sendMessage(chatId: String, message: Message) {
        val chatRef =
            firestore.collection("chats").document(chatId)
                .collection("messages")
        chatRef.add(FirestoreMessageModel
            .fromDomain(message))
    }
}</pre> <p class="calibre3">Next, we <a id="_idIndexMarker285" class="calibre6 pcalibre1 pcalibre"/>need to replace our previous <code>MessagesSocketDataSource</code> instance in <code>MessagesRepository</code> with <code>FirestoreMessagesDataSource</code>:</p>
<pre class="source-code">
class MessagesRepository @Inject constructor(
    //private val dataSource: MessagesSocketDataSource
    private val dataSource: FirestoreMessagesDataSource
): IMessagesRepository {
    override suspend fun getMessages(chatId: String,
    userId: String): Flow&lt;Message&gt; {
        return dataSource.getMessages(chatId, userId)
    }
    override suspend fun sendMessage(chatId: String,
    message: Message) {
        dataSource.sendMessage(chatId, message)
    }
    override suspend fun disconnect() {
        // do nothing, Firestore data source is
           disconnected as soon as the flow has no
           subscribers
    }
}</pre> <p class="calibre3">And with <a id="_idIndexMarker286" class="calibre6 pcalibre1 pcalibre"/>some minor changes, we will have integrated this new provider. The good thing is that, as we have been working following a Clean Architecture, with mappings between layers, we don’t have to change anything in other layers; for example, in <code>Usecases</code>, <code>ViewModel</code>, or the UI (apart from providing the <code>chatId</code> value and the <code>userId</code> value when calling the <code>getMessages</code> and <code>sendMessage</code> methods).</p>
<p class="calibre3">We could also have the two data sources living together in the same app (one as a fallback of the other), as the role of the repository is to serve as an orchestrator of the different data sources for a certain entity (in this case, the messages). We will see more about this in the next chapter as we will want to add local storage to our messages.</p>
<h1 id="_idParaDest-59" class="calibre5"><a id="_idTextAnchor059" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we explored various aspects of building a messaging app for Android. We discussed different approaches for sending and receiving messages, such as using WebSockets with Ktor or Firebase Firestore. We also covered how to structure the app using Clean Architecture principles, with separate layers for data, domain, and presentation, to ensure a well-organized and maintainable code base, and saw how easy is to introduce changes (for example, a change in the messages provider) if our architecture components are well decoupled.</p>
<p class="calibre3">Then, we delved into handling connection errors and synchronization issues using Kotlin coroutines and Flow, implementing error handling and retry mechanisms for a seamless user experience. Additionally, we examined the importance of push notifications in messaging apps and demonstrated their implementation using FCM, from setting up FCM in a project to handling incoming notifications.</p>
<p class="calibre3">By the end of this chapter, you should have a comprehensive understanding of the components and techniques required to build a robust real-time messaging app on Android.</p>
<p class="calibre3">Now, let’s move on to learn how we can optimize our WhatsPackt app so that we can back up messages.</p>
</div>
</body></html>