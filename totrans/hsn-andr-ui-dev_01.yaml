- en: Creating Android Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Android布局
- en: Mobile App user interfaces have come a long way from the early days, and while
    users have more devices to choose from than ever, they all expect consistently
    high-quality experiences from their apps. Apps are expected to run fast and the
    user interfaces are expected to be smooth; all this while running on a massive
    array of devices of varied capabilities. Your app needs to run on devices with
    screens as big as televisions on the one end of the scale, and smartwatches with
    screens as small as 2.5 cm or even smaller on the other end of the scale. At first
    glance, this may seem like a nightmare, but there are simple tricks to make building
    responsive Android apps easy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 移动应用的用户界面已经从早期发展了很多，尽管用户可以选择的设备比以往任何时候都多，但他们都期望从应用中获得一致的高质量体验。应用需要运行得快，用户界面需要流畅；所有这些同时还要在功能各异的庞大设备群上运行。您的应用需要在屏幕大小从电视那么大的一端，到另一端只有2.5厘米或更小的智能手表屏幕上运行。乍一看，这似乎是一场噩梦，但有一些简单的技巧可以使构建响应式Android应用变得容易。
- en: In this book, you'll learn a diverse set of skills as well as some theoretical
    knowledge that you can apply to build fast, responsive, and great-looking Android
    applications. You'll learn how to go about designing the screens that your application
    will actually need, and then how to build them for maximum flexibility and performance
    while keeping your code easy to read and avoiding bugs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，你将学习一系列的技能以及一些可以应用于构建快速、响应式且外观出色的Android应用程序的理论知识。你将学习如何设计应用程序实际需要的屏幕，然后如何构建它们以实现最大限度的灵活性和性能，同时保持代码易于阅读并避免错误。
- en: 'In this chapter, we will look at the basic principles used to build user interfaces
    for Android applications. You''ll need to be familiar with concepts to build even
    the simplest Android application, so in this chapter, we''ll cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨用于构建Android应用程序用户界面的基本原理。你需要熟悉这些概念才能构建甚至是最简单的Android应用程序，因此在本章中，我们将涵盖以下主题：
- en: The basic structure of an Android application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序的基本结构
- en: Creating a simple Activity and layout files using Android Studio
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Android Studio创建简单的Activity和布局文件
- en: Where to find the most useful parts of the Android Studio layout editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Studio布局编辑器中找到最有用部分的技巧
- en: How a well-organized project is structured
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组织良好的项目的结构
- en: Material Design
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Material Design
- en: Since Android was first introduced in 2008, the user interface design has changed
    radically, from the first early versions of the grey, black, and orange theme,
    to the **Holo theme**, which was more of a stylistic change than a fundamental
    shift in the design language, and eventually culminating in material design. **Material
    Design** is more than just a style; it's a design language complete with concepts
    for navigation, and overall application flow. Central to this idea is the notion
    of paper and card, the idea that the items on the screen are not simply next to
    each other but may also be above and below in the third dimension (although this
    is virtual). This is achieved using the elevation property that is common to all
    widgets in Android. Along with this basic principle, material design offers some
    common patterns to help the user identify which components are likely to take
    which actions, even the first time they are used in the application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Android在2008年首次推出以来，用户界面设计已经发生了根本性的变化，从最初的灰色、黑色和橙色主题的早期版本，到**Holo主题**，这更多的是一种风格上的变化，而不是设计语言的根本转变，最终
    culminating in material design。**Material Design**不仅仅是一种风格；它是一种包含导航和整体应用流程概念的设计语言。这一理念的核心是纸张和卡片的概念，即屏幕上的项目不仅彼此相邻，还可能在三维空间中的上方和下方（尽管这是虚拟的）。这是通过Android中所有小部件都通用的elevation属性实现的。除了这一基本原理外，material
    design还提供了一些常见的模式，以帮助用户识别哪些组件可能执行哪些操作，即使是在应用程序中首次使用时。
- en: 'If you look at the original Android theme alongside the Holo Light theme, you
    can see that while the style changed dramatically, many elements stayed similar
    or the same. The grey tones flattened, but are very similar, and many of the borders
    were removed, but the spacing remains very close to the original theme. The material
    design language is often very similar in its basic styling and design to Holo:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将原始的Android主题与Holo Light主题进行比较，你可以看到，尽管风格发生了巨大的变化，但许多元素保持相似或相同。灰色调被扁平化，但非常相似，许多边框被移除，但间距仍然非常接近原始主题。Material
    Design语言在基本风格和设计上通常与Holo非常相似：
- en: '![](img/fe37817c-7769-4bbd-a061-ee72965f49a8.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe37817c-7769-4bbd-a061-ee72965f49a8.png)'
- en: The design language is an essential part of modern user interface design and
    development. It not only defines the look and feel of your widget toolkit, but
    also defines how the application should behave on different devices and in different
    circumstances. For example, on Android, it is common to have a navigation drawer
    since the slides are from the left, while this would not feel natural to the user
    on other platforms. Material design defines much more than the look and feel of
    navigation, it also includes guidelines for motion and animation, how to display
    various types of errors, and how to guide your users through an application for
    the first time. As a developer or designer, you may feel like this limits your
    creative freedom, and to some degree it actually does, but it also creates a clear
    message for your users on how your app expects to be used. This means that your
    users can use your app more easily, and it requires less cognitive load.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 设计语言是现代用户界面设计和开发的一个基本组成部分。它不仅定义了你的小部件工具包的外观和感觉，还定义了应用程序在不同设备和不同情况下应该如何表现。例如，在Android上，由于滑动是从左侧开始的，因此通常会有一个导航抽屉，而在其他平台上这样做可能对用户来说并不自然。Material设计定义的不仅仅是导航的外观和感觉，还包括运动和动画的指南，如何显示各种类型的错误，以及如何引导用户第一次使用应用程序。作为开发者或设计师，你可能觉得这限制了你的创意自由，实际上在某种程度上确实如此，但它也为你用户如何使用你的应用程序提供了一个清晰的信息。这意味着你的用户可以更轻松地使用你的应用程序，并且需要更少的认知负荷。
- en: Another aspect of application development, which is of vital importance in any
    modern mobile application, is its performance. Users have come to expect that
    applications will always run smoothly, no matter the actual load on the system.
    The benchmark for all modern applications is 60 frames per second, that is, a
    full render event delivered to the user every 16.6 milliseconds.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发的一个方面，这在任何现代移动应用程序中都至关重要，是其性能。用户已经期待应用程序始终运行顺畅，无论系统实际负载如何。所有现代应用程序的基准是每秒60帧，即每16.6毫秒向用户交付一个完整的渲染事件。
- en: Users don't just expect an application to perform well, they expect it to react
    instantly to external changes. When data is changed on the server side, users
    expect to see it on their device instantly. This makes the challenges of developing
    a mobile application, especially one with good performance, become even more difficult.
    Fortunately, Android comes with a fantastic toolset and an enormous ecosystem
    for dealing with these problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户不仅期望应用程序表现良好，还期望它能够即时对外部变化做出反应。当服务器端的数据发生变化时，用户期望立即在他们的设备上看到它。这使得开发移动应用程序的挑战，尤其是性能良好的应用程序，变得更加困难。幸运的是，Android提供了一套出色的工具和庞大的生态系统来处理这些问题。
- en: Android attempts to enforce good threading and performance behavior by timing
    each event that happens on the main thread and ensures that none of them take
    too long (and producing an **Application Not Responding** (**ANR**) error if they
    do). It further requires that no form of networking is conducted on the main thread,
    since these will invariably affect the application's performance. However, where
    this approach gets hard to work with is--any code related to the user interface
    must happen on the main thread, where all the input events are processed, and
    where all the graphics rendering code is run. This helps the user interface framework
    by avoiding any need for thread locks in what is very performance-centric code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Android通过计时主线程上发生的每个事件来尝试强制执行良好的线程和性能行为，并确保它们中的任何一个都不会花费太长时间（如果它们确实如此，则会产生一个**应用程序无响应**（**ANR**）错误）。它进一步要求不要在主线程上进行任何形式的网络操作，因为这些肯定会影响应用程序的性能。然而，这种方法难以处理的地方在于——任何与用户界面相关的代码都必须在主线程上执行，那里处理所有输入事件，并且所有图形渲染代码都在那里运行。这有助于用户界面框架，因为它避免了在非常注重性能的代码中需要线程锁的任何需求。
- en: The Android Platform is a complete alternative to the Java Platform. While at
    a high level, the Android platform APIs are a form of Java framework; there are
    noticeable differences. The most obvious is that Android does not run Java bytecode,
    and does not include most of the Java standard APIs. Instead, most of the classes
    and structures you'll use are specific to Android. From this perspective, the
    Android platform is a bit like a large opinionated Java Framework. It attempts
    to reduce the amount of boilerplate code you write by providing you with skeleton
    structures to develop your applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台是 Java 平台的完整替代品。虽然在高层面上，Android 平台 API 是一种 Java 框架的形式；但存在一些明显的差异。最明显的是，Android
    不运行 Java 字节码，也不包含大多数 Java 标准API。相反，你将使用的多数类和结构都是针对 Android 定制的。从这个角度来看，Android
    平台有点像一个大型的有偏见的 Java 框架。它通过为你提供骨架结构来开发应用程序，试图减少你编写的样板代码量。
- en: The most common way to build user interfaces for Android is to do it declaratively
    in the layout XML files. You can also write user interfaces using pure Java code,
    but while potentially faster, it's not commonly used and carries some critical
    pitfalls. Most notably, the Java code is much more complex when handling multiple
    screen sizes. Instead of simply being able to reference a different layout file
    and have the resource system link in the best fit for the device, you have to
    handle these differences in your code. While parsing XML may seem a crazy idea
    on a mobile device, it's not nearly that bad; the XML is parsed and validated
    at compile time, and turned into a binary format which is what is actually **read
    at runtime** by your application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Android 构建用户界面的最常见方式是在布局 XML 文件中进行声明性操作。你也可以使用纯 Java 代码编写用户界面，但尽管可能更快，但并不常用，并且存在一些关键缺陷。最值得注意的是，当处理多个屏幕尺寸时，Java
    代码变得更加复杂。你无法简单地引用不同的布局文件，让资源系统链接到最适合设备的布局，而必须在代码中处理这些差异。虽然在一个移动设备上解析 XML 可能看起来是个疯狂的想法，但实际上并没有那么糟糕；XML
    在编译时被解析和验证，并转换为二进制格式，这是你的应用程序在运行时实际**读取**的格式。
- en: Another reason it's really nice to write Android layouts in XML is the **Android
    Studio layout editor**. This gives you a real-time preview of what your layout
    will look like on a real device, and the blueprint view helps enormously when
    debugging issues like spacing and styling. There is also an excellent linting
    support in Android Studio that helps you avoid common problems before you're even
    finished writing your layout files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是在 XML 中编写 Android 布局非常方便的是 **Android Studio 布局编辑器**。这让你能够实时预览你的布局在真实设备上的外观，蓝图视图在调试诸如间距和样式等问题时非常有帮助。Android
    Studio 还提供了出色的 linting 支持，帮助你避免在完成编写布局文件之前就出现常见问题。
- en: Android Studio
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Studio
- en: Android Studio is a fully-featured IDE built on top of the **IntelliJ** platform,
    designed specifically for developing Android applications. It has a huge suite
    of built-in tools that will make your life better, and help you write better applications
    more rapidly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 是基于 **IntelliJ** 平台构建的具有全部功能的 IDE，专门用于开发 Android 应用程序。它拥有庞大的内置工具套件，这将使你的生活更加美好，并帮助你更快地编写更好的应用程序。
- en: You can download Android Studio for your favorite **Operating System** (**OS**)
    from [https://developer.android.com/studio/](https://developer.android.com/studio/).
    The setup instructions for each operating system vary slightly, and are available
    on the website. This book has been written assuming an Android Studio version
    of at least 3.0.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 [https://developer.android.com/studio/](https://developer.android.com/studio/)
    下载你喜欢的 **操作系统**（**OS**）的 Android Studio。每个操作系统的设置说明略有不同，可在网站上找到。本书假定至少使用 Android
    Studio 版本 3.0。
- en: Once installed, Android Studio will also need to download and install an Android
    SDK for you to develop your applications on. There are platform options for virtually
    every version of Android ever released, including emulated hardware, which allows
    you to test how your application will run on different hardware and Android releases.
    It's best to download the latest Android SDK, and one of the older versions as
    well to check backward compatibility (4.1 or 4.4 are good options).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，Android Studio 还需要为你下载和安装 Android SDK，以便你可以在其上开发应用程序。几乎每个 Android 版本都有平台选项，包括模拟硬件，这允许你测试你的应用程序在不同硬件和
    Android 版本上的运行情况。最好下载最新的 Android SDK，以及一个较旧的版本，以检查向后兼容性（4.1 或 4.4 是不错的选择）。
- en: Android application structure
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 应用程序结构
- en: 'An Android application is very different in its internal structure when compared
    to applications on other platforms, in even the simplest details. Most platforms
    see their applications as monolithic systems with a fixed entry point. When the
    entry point returns or exits, the platform assumes that the application has finished
    running. On Android, an application may have several different entry points for
    the user, and others for the system. Each entry point has a different type, and
    different ways for the system to reach it (called **intent filters**). The most
    important part of an application from the user perspective is its activities.
    These (as the name suggests) are supposed to represent an action that the user
    will take with the application, such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他平台上的应用相比，Android应用在其内部结构上非常不同，甚至在最简单的细节上也是如此。大多数平台将它们的应用视为具有固定入口点的单体系统。当入口点返回或退出时，平台假设应用已经完成运行。在Android上，一个应用可能有几个不同的入口点供用户使用，还有几个供系统使用。每个入口点都有不同的类型，以及不同的系统到达它的方式（称为**意图过滤器**）。从用户的角度来看，应用最重要的部分是其活动。这些（正如其名称所暗示的）应该代表用户将对应用采取的操作，例如以下操作：
- en: List my emails
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出我的电子邮件
- en: Compose an email
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一封电子邮件
- en: Edit a contact
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑联系人
- en: 'Each `Activity` is a non-abstract class extending the `Activity` class (or
    any descendant of `Activity`), and registers itself and its intent filters in
    the application manifest file. Here''s an example of how the manifest entry for
    an `Activity` that can view and edit contacts might look:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Activity`都是一个非抽象类，它扩展了`Activity`类（或任何`Activity`的子类），并在应用程序清单文件中注册自己及其意图过滤器。以下是一个可以查看和编辑联系人的`Activity`的清单条目示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The application manifest file (always named as `AndroidManifest.xml`) is how
    the Android system knows what components your application has, and how to reach
    each of them. It also contains information such as the permissions your application
    will need from the user, and which versions of the Android system the application
    will run on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单文件（始终命名为`AndroidManifest.xml`）是Android系统了解应用有哪些组件以及如何到达每个组件的方式。它还包含有关应用将需要从用户那里获取的权限以及应用将在哪些Android系统版本上运行的信息。
- en: 'Each `Activity` is typically intended to do a single thing from the user''s
    perspective, but this is not always the case. In the preceding case, there are
    three possible intent filters, each of which telling the system something different
    about the `ContactActivity` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，每个`Activity`通常旨在执行单一的操作，但这并不总是如此。在前面的例子中，有三个可能的意图过滤器，每个过滤器都向系统传达关于`ContactActivity`类的不同信息：
- en: The first one tells the system that `ContactActivity` should have its icon displayed
    on the launcher screens, effectively making it the main entry point of the application
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个意图告诉系统`ContactActivity`的图标应该显示在启动器屏幕上，从而使其成为应用的主要入口点
- en: The second tells the system that `ContactActivity` can be used to `VIEW` content
    with a mime-type of `"data/contact"`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个意图告诉系统`ContactActivity`可以使用MIME类型为`"data/contact"`的`VIEW`内容
- en: The third tells the system that `ContactActivity` can also be used to `EDIT`
    content with the `"data/contact"` mime-type
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个意图告诉系统`ContactActivity`也可以用于使用`"data/contact"`MIME类型`EDIT`内容
- en: The system resolves `Activity` classes through Intents. Each Intent specifies
    how and what the application would like to do on behalf of the user, and the system
    uses the information to find a matching intent-filter somewhere in the system.
    However, you won't typically add intent-filters to all of your `Activity` entries;
    you'll launch most by specifying the class directly within your application. Intent-filters
    are normally used to implement abstract inter-application interactions for example,
    when an application needs to "open a web page for browsing," the system can automatically
    launch the user's preferred web browser.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 系统通过意图（Intents）解析`Activity`类。每个意图指定了应用代表用户如何以及想要做什么，系统使用这些信息在系统中的某个地方找到匹配的意图过滤器。然而，你通常不会为所有的`Activity`条目添加意图过滤器；你将通过在应用内部直接指定类来启动大多数。意图过滤器通常用于实现抽象的跨应用交互，例如，当一个应用需要“打开网页进行浏览”时，系统可以自动启动用户首选的网页浏览器。
- en: An `Activity` will generally have a primary layout file defined as an XML resource.
    These layout resource files are generally not standalone, but will make use of
    other resources and even other layout files.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`通常有一个主要布局文件，定义为XML资源。这些布局资源文件通常不是独立的，但会使用其他资源，甚至其他布局文件。'
- en: Keep your activities simple! Avoid loading too much behavior into a single `Activity`
    class, and try and keep it bound to a single layout (and its variants, such as
    "landscape"). At worst, allow multiple behaviors with common layout widgets (for
    example, a single `Activity` to view, or edit a single contact). We'll go through
    some techniques for this in [Chapter 4](1799a69f-adfc-4439-883c-f2db5e4ad199.xhtml),
    *Composing User Interfaces*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 保持你的活动简单！避免在一个`Activity`类中加载过多的行为，并尽量保持它与单个布局（及其变体，如“横向”）相关联。最坏的情况下，允许使用具有共同布局小部件的多个行为（例如，单个`Activity`用于查看或编辑单个联系人）。我们将在[第4章](1799a69f-adfc-4439-883c-f2db5e4ad199.xhtml)，*组合用户界面*中介绍一些此类技术。
- en: 'The resource system in Android needs some special attention, as it allows for
    multiple files to collaborate together to create complex behavior out of simple
    components. At its heart, the resource system selects the most appropriate of
    each resource when it is requested (including from inside other resources). This
    not only allows you to create screen layouts for portrait and landscape mode,
    but allows you to do the same for dimensions, text, colors, or any other resource.
    Consider the following example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的资源系统需要特别注意，因为它允许多个文件协作，从简单的组件中创建出复杂的行为。在核心上，资源系统在请求时（包括从其他资源内部）选择最合适的每个资源。这不仅允许你为纵向和横向模式创建屏幕布局，还允许你为尺寸、文本、颜色或其他任何资源做同样的事情。考虑以下示例：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above dimension resource can now be used in layout resource files by name:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 上述尺寸资源现在可以通过名称在布局资源文件中使用：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using this sort of technique, you can adjust layouts for different screen sizes
    by simply changing the distance measurements used to space and size the widgets,
    rather than having to define completely new screen layouts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，你可以通过简单地更改用于定位和尺寸小部件的距离测量值来调整不同屏幕尺寸的布局，而不是必须定义全新的屏幕布局。
- en: It's a good idea to try and be generic with resources such as dimensions and
    colors. This will help keep your user interface consistent for your users.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于资源如尺寸和颜色等，尝试保持通用性是个好主意。这有助于保持用户界面对用户的一致性。
- en: Consistent user interfaces are often more important than trying to innovate.
    The less mental effort your user needs to understand your application, the more
    they can engage with it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一致的用户界面通常比尝试创新更重要。用户需要理解你的应用程序时所需的认知努力越少，他们就越能与之互动。
- en: Creating SimpleLayout
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SimpleLayout
- en: 'Now that we''ve gone over the basics of an Android application structure, let''s
    create a simple screen and see how things all fit together. We''ll use Android
    Studio and one of its wonderful template activities. Just follow these easy steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Android应用程序结构的基本知识，让我们创建一个简单的屏幕，看看所有东西是如何结合在一起的。我们将使用Android Studio及其出色的模板活动之一。只需按照以下简单步骤操作：
- en: Start by opening Android Studio on your computer.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在你的计算机上打开Android Studio。
- en: Start a new project using the File menu, or the quickstart dialog (depending
    on which one shows up for you).
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文件菜单或快速启动对话框（取决于哪个对你显示）启动一个新项目。
- en: 'Name the project as `SimpleLayout`, and leave any additional support (C++,
    Kotlin) off:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`SimpleLayout`，并取消任何额外的支持（C++、Kotlin）：
- en: '![](img/67d7ea81-c568-4fe9-a5d1-eb48dd7f7213.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67d7ea81-c568-4fe9-a5d1-eb48dd7f7213.png)'
- en: 'On the next screen of the New Project wizard, ensure that you support Android
    4.1 or higher, but leave only Phone and Tablet checked for this task:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新项目向导的下一屏，确保你支持Android 4.1或更高版本，但只为这个任务勾选电话和平板：
- en: '![](img/8f5d6dac-2b11-427d-9486-3207f4df48c8.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8f5d6dac-2b11-427d-9486-3207f4df48c8.png)'
- en: 'Android Studio comes with a fantastic selection of **Activity templates** available
    on the next screen. This will be the first `Activity` generated to get you started
    with your project. For this example, you''ll want to scroll down the list and
    find Navigation Drawer Activity. Select it and click on Next:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android Studio在下一屏提供了丰富的**活动模板**选择。这将是你项目生成的第一个`Activity`，以帮助你开始。对于这个示例，你想要滚动列表并找到导航抽屉活动。选择它并点击下一步：
- en: '![](img/c766b9af-4690-45e2-83a1-78534dd03116.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c766b9af-4690-45e2-83a1-78534dd03116.png)'
- en: Leave the `Activity` details as their defaults (MainActivity, and so on) and
    click on Finish to complete the New Project wizard. Android Studio now creates
    your project and runs a first build-sync over to get everything working.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 保持`Activity`的详细信息为默认值（MainActivity等），然后点击完成以完成新项目向导。Android Studio现在创建你的项目并运行第一次构建同步，以确保一切正常工作。
- en: 'Once your project has finished being generated, you''ll be presented with the
    Android Studio layout editor, looking something like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的项目生成完成，您将看到Android Studio布局编辑器，看起来可能像这样：
- en: '![](img/6c79041b-cad1-496f-b447-f0631939dc72.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c79041b-cad1-496f-b447-f0631939dc72.png)'
- en: Congratulations, this template provides an excellent starting point to explore
    how Android applications and their user interfaces are built and fit together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，这个模板提供了一个极好的起点，用于探索Android应用程序及其用户界面是如何构建和组合在一起的。
- en: 'If you ever want to get back to the Activity templates screen, you can use
    the Gallery... option in the Android Studio File | New | Activity menu:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想回到活动模板屏幕，您可以使用Android Studio文件 | 新建 | 活动菜单中的“图库...”选项：
- en: '![](img/fa7e26cc-d8c0-4623-8ce5-ecf7fe482fc9.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa7e26cc-d8c0-4623-8ce5-ecf7fe482fc9.png)'
- en: Discovering the layout editor
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现布局编辑器
- en: At first glance, the layout editor in Android Studio is a standard WYSIWYG editor;
    however, it has several important features that you need to be aware of. Most
    importantly, it actually runs the code for the widgets in order to render them
    within the editor. This means that if you write a custom layout or widget, it
    will look and behave as it will on the emulator or on a device. This is fantastically
    useful for rapidly prototyping screens, and can drastically cut down on development
    time when used properly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，Android Studio中的布局编辑器是一个标准的所见即所得编辑器；然而，它有几个重要的特性您需要了解。最重要的是，它实际上会运行小部件的代码，以便在编辑器中渲染它们。这意味着如果您编写了自定义布局或小部件，它们的外观和行为将与在模拟器或设备上一样。这对于快速原型设计屏幕非常有用，并且在使用得当的情况下可以大幅减少开发时间。
- en: 'To ensure that your layout is being rendered correctly, you''ll sometimes need
    to ensure that the layout editor is configured correctly. From the toolbar at
    the top of the layout editor, you can select the virtual device configuration
    you would like it to emulate. This includes whether the layout is being viewed
    in portrait or landscape mode, and even what language settings to use for the
    layout rendering and resource selection:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的布局被正确渲染，有时您需要确保布局编辑器配置正确。从布局编辑器顶部的工具栏中，您可以选择要模拟的虚拟设备配置。这包括布局是否以纵向或横向模式查看，甚至用于布局渲染和资源选择的语言设置：
- en: '![](img/282ce336-7ee4-41d1-897e-60e63b6ac387.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/282ce336-7ee4-41d1-897e-60e63b6ac387.png)'
- en: It's important to keep in mind that the list of available Android platform versions
    that the layout editor can emulate is limited, and it is not connected to the
    list that you have installed as virtual devices (so you cannot add new versions
    to the layout editor by installing additional platform versions). If you want
    to see how your user interfaces of versions that Android Studio doesn't directly
    support look, the only way to do it is to run the application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要牢记的是，布局编辑器可以模拟的可用Android平台版本列表是有限的，并且它与您安装为虚拟设备（因此您不能通过安装额外的平台版本来向布局编辑器添加新版本）的列表不相连。如果您想查看Android
    Studio不直接支持的版本的用户界面，唯一的方法是运行应用程序。
- en: 'The next really important thing to note is the attributes panel, which is docked
    to the right of the layout editor by default. When you select a component in the
    design area, the attributes panel allows tweaking of all the attributes that can
    be changed in XML, and of course, you get to see the results of any changes live
    in the layout editor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的下一件非常重要的事情是属性面板，它默认停靠在布局编辑器的右侧。当您在设计区域中选择一个组件时，属性面板允许调整所有可以在XML中更改的属性，并且当然，您可以在布局编辑器中实时看到任何更改的结果：
- en: '![](img/9652094a-1ede-4dba-afd8-769cb201035d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9652094a-1ede-4dba-afd8-769cb201035d.png)'
- en: The number of attributes is generally kept well under control by Android Studio.
    The default panel only shows the most commonly used attributes for the selected
    widget. To toggle between this shortlist and the list of all the available attributes
    (something you'll do more often than you think), you'll want to use the toggle
    button (![](img/8f88af53-b0c3-47e5-8673-b93c11621472.png)) at the top of the attributes
    panel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio通常会很好地控制属性的数量。默认面板仅显示所选小部件最常用的属性。为了在简短列表和所有可用属性列表（您会比想象的更频繁地这样做）之间切换，您需要使用属性面板顶部的切换按钮（![](img/8f88af53-b0c3-47e5-8673-b93c11621472.png)）。
- en: However, when you look at the All Attributes view, you'll note that their sheer
    number makes the view rather difficult to use. The easiest way to solve this is
    to use the search button (![](img/e65cb86f-59b8-41f9-ba83-6592c6137084.png)) to
    find the attribute you're looking for. This will allow you to search for attributes
    by name, and is the quickest way to filter the list and get to the attribute,
    or group of attributes, that you're looking for (that is, `scroll` will give you
    all the attributes containing the word `scroll`, including `scrollIndicators`,
    `scrollbarSize`, `scrollbarStyle`, and so on).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你查看所有属性视图时，你会注意到它们的数量众多使得视图相当难以使用。解决这个问题的最简单方法是使用搜索按钮（![图片](img/e65cb86f-59b8-41f9-ba83-6592c6137084.png)）来找到你想要的属性。这将允许你通过名称搜索属性，并且这是过滤列表并找到你想要的属性或属性组（即`scroll`会给你所有包含单词`scroll`的属性，包括`scrollIndicators`、`scrollbarSize`、`scrollbarStyle`等等）的最快方式。
- en: Organizing project files
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织项目文件
- en: 'Android Studio gives you a fairly standard Java project structure, that is,
    you have your main source sets, tests, a resources directory, and so on, but that
    doesn''t really cover all of your organizational needs. If you check the project
    structure we created, you might note some patterns:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio为你提供了一个相当标准的Java项目结构，即你有你的主要源集、测试、资源目录等等，但这并不真正涵盖你所有的组织需求。如果你检查我们创建的项目结构，你可能会注意到一些模式：
- en: '![](img/88fd2f46-1a82-46bd-993f-2579cb999563.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/88fd2f46-1a82-46bd-993f-2579cb999563.png)'
- en: You'll first note that only a single `Activity` was created--`MainActivity`,
    but this `Activity` template has generated four layout files.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先会注意到只创建了一个`Activity`——`MainActivity`，但这个`Activity`模板已经生成了四个布局文件。
- en: Only `activity_main.xml` is actually referenced by `MainActivity`; all the other
    files are included via the resource system.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有`activity_main.xml`被`MainActivity`实际引用；所有其他文件都是通过资源系统包含的。
- en: The next thing to note is that the layout file referenced by `MainActivity`
    is named as `actvitity_main.xml`; this is a standard naming pattern that Android
    Studio will actually suggest when creating new `Activity` classes. It's a good
    idea, because it helps separate layouts used for `Activity` classes from those
    used elsewhere.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要注意的是，由`MainActivity`引用的布局文件命名为`actvitity_main.xml`；这是一个标准的命名模式，Android Studio在创建新的`Activity`类时实际上会建议使用。这是一个好主意，因为它有助于将用于`Activity`类的布局与用于其他地方的布局区分开来。
- en: Next, take a look at the names of the other layout files. Each of them is also
    prefixed with `nav`, `app_bar`, and `content`. These prefixes help group the layout
    files logically in a file manager and in the IDE.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，看看其他布局文件的名称。每个文件也都是以`nav`、`app_bar`和`content`为前缀。这些前缀有助于在文件管理器和IDE中逻辑上分组布局文件。
- en: Finally, you'll note that the `values` directory has several XML files in it.
    The entire `values` directory is actually treated as one big XML file by the resource
    compiler, but it helps keep it organized by the type of resources being declared.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你会注意到`values`目录中包含几个XML文件。整个`values`目录实际上被资源编译器当作一个大的XML文件来处理，但它通过资源声明的类型来帮助保持组织有序。
- en: Use filename prefixes in the resources directories (especially layouts) to keep
    things organized. You cannot break things down into subdirectories, so a prefix
    is the only way to group files together logically. Common prefixes are "activity",
    "fragment", "content", and "item", which are commonly used to prefix layouts that
    are used to render list items and so on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源目录（尤其是布局）中使用文件名前缀（以保持组织有序）。你不能将它们分解到子目录中，所以前缀是唯一一种将文件逻辑上分组的方法。常见的前缀有“activity”、“fragment”、“content”和“item”，这些通常用于前缀用于渲染列表项等的布局。
- en: 'If you open the `MainActivity` class now, you''ll see how the layout is loaded
    and bound. The first thing `MainActivity` does when it''s created is to call `onCreate`
    to its parent class (which is a mandatory step, and failure to do so will result
    in an exception). Then, it loads its layout file using the `setContentView` method.
    This method call does two things at once: it loads the layout XML file, and adds
    its root widget as the root of the `Activity` (replacing any widgets that were
    already there). The `R` class is defined by the resource compiler, and kept in
    sync for you by Android Studio. Every file and value resource will have its own
    unique identifier, which allows you to keep things tightly bound together. Rename
    a resource file, and its corresponding field will change:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在打开`MainActivity`类，你会看到布局是如何加载和绑定的。`MainActivity`在创建时首先会调用其父类的`onCreate`方法（这是一个强制步骤，如果不这样做将会引发异常）。然后，它使用`setContentView`方法加载其布局文件。这个方法调用同时做两件事：它加载布局XML文件，并将根小部件作为`Activity`的根（替换掉之前已经存在的任何小部件）。`R`类是由资源编译器定义的，并由Android
    Studio为你保持同步。每个文件和值资源都将有一个唯一的标识符，这允许你将事物紧密地绑定在一起。重命名资源文件，其对应的字段也会改变：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You''ll then note that `MainActivity` retrieves various widgets that were included
    in the layout files by their own IDs (also defined in the `R` class). The `findViewById`
    method searches through the `Activity` layout for a widget with the corresponding
    `id`, and then returns it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你会注意到`MainActivity`通过它们自己的ID（也在`R`类中定义）检索布局文件中包含的各种小部件。`findViewById`方法在`Activity`布局中搜索具有相应`id`的小部件，然后返回它：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `findviewById` method works by traversing all of the widgets in an `Activity`
    in a series of loops. There is no lookup table or optimize this process. As such,
    you should call the `findViewById` method in `onCreate` and keep a class-field
    reference to each of the `View` objects you'll need.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`findviewById`方法通过一系列循环遍历`Activity`中的所有小部件。没有查找表或优化这个过程。因此，你应该在`onCreate`中调用`findViewById`方法，并为每个所需的`View`对象保留一个类字段引用。'
- en: 'The preceding code snippet will return the `Toolbar` object declared in the
    `app_bar_main.xml` layout resource file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码片段将返回在`app_bar_main.xml`布局资源文件中声明的`Toolbar`对象：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`findViewById` can also be found on the `View` class, but it''s a relatively
    expensive operation, so when you have widgets that will be used again in an `Activity`,
    they should be assigned to fields in the class.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`findViewById`也可以在`View`类中找到，但它是一个相对昂贵的操作，所以当你有在`Activity`中再次使用的小部件时，应该将它们分配给类中的字段。'
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you saw, an Android application comprises of more modular components, which
    assemble in layers, and are often directly accessible from the platform. The resource
    management system is your greatest ally and should be leveraged to provide your
    users with a consistent experience, and keep your user interface consistent. When
    it comes to arranging your application, Android Studio has a variety of tools
    and features that it will use to help you keep things organized and within commonly
    understood patterns. However, it's also important to stick to your own patterns
    and keep things organized. The Android toolkits have their own requirements, and
    you'll need to obey their rules if you want to benefit from them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Android应用程序由更多模块化组件组成，它们以层的形式组装，并且通常可以直接从平台访问。资源管理系统是你的最大盟友，应该利用它为用户提供一致的经验，并保持用户界面的一致性。当涉及到安排你的应用程序时，Android
    Studio提供了一系列工具和功能，它将使用这些工具和功能来帮助你保持事物组织有序，并符合通常理解的模式。然而，坚持你自己的模式并保持事物有序也同样重要。Android工具包有自己的要求，如果你想从中受益，你需要遵守它们的规则。
- en: Android Studio also has an excellent collection of template projects and Activities,
    and they should be used to get your projects kick-started. They can also often
    serve with explanations for how common user interface design patterns are implemented
    in Android.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio还拥有一个优秀的模板项目和活动集合，应该使用它们来启动你的项目。它们还经常提供关于如何在Android中实现常见的用户界面设计模式的说明。
- en: In the next chapter, we'll take a look at starting a layout from scratch and
    how to approach designing a form screen.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨从头开始创建布局以及如何设计表单屏幕的方法。
