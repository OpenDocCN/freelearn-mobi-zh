- en: Chapter 5. Dependency Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features of any software is managing dependencies.
    As we know, no software works in isolation and we usually depend on third-party
    or open source libraries. The libraries are required during the compile and runtime
    execution and they have to be available in the classpath. Gradle has excellent
    support for dependency management. We just need to write few lines of code in
    the build file and Gradle internally does all the heavy lifting of managing configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go into details of **dependency management** of Gradle.
    We will discuss the different features such as how to manage project dependencies,
    resolving conflicts, and resolution strategies. We will also discuss how to publish
    artifacts in different repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency management is one of the most the important features of any build
    tool. It helps to manage software dependencies in a better way. If you are using
    **Ant**, which initially did not support any dependency management, you need to
    write the name of each and every dependent jar file and its location to `build.xml`.
    For small applications that do not have many dependencies, this approach might
    work well. However, for enterprise applications, where software depends on hundreds
    of other libraries, which internally can depend on some other libraries (transitive
    dependencies), this approach of configuring each and every jar file in your `build.xml`
    could work but it requires huge effort to maintain it. Also, managing their version
    conflicts would be really a big pain for any developer and could turn the build
    process into a nightmare. To resolve these drawbacks in Ant, Maven came with an
    internal dependency management solution.
  prefs: []
  type: TYPE_NORMAL
- en: Later, Ant also integrated with Apache Ivy (a dependency management solution)
    to provide the same feature. Gradle came with its own dependency management implementation.
    It helps to define first-level dependencies, logically group them into different
    configurations, define multiple repositories and also provide tasks to publish
    assets after the execution of the build file. It also supports Ivy, Maven, and
    flat file repositories. In this chapter, along with dependency management, we
    will also look into repositories configurations and asset publications, that is,
    how to configure different repositories and upload assets to repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting with dependency configuration, let''s discuss how to publish
    packaged software in Java. You package and publish either in `.jar` or `.war`
    or `.ear` file formats to a repository. The goal is to share these assets within
    the teams in an organization or with open source developers. Consider a scenario
    where you are publishing a utility project (`messageutil.jar`) to a repository.
    Although the publication process mostly depends on an organization''s policy,
    the common practice is, all the assets that you plan to publish should be **versioned**
    and stored in a central repository, so that all other teams can share it. This
    versioning helps to track different versions of libraries. With versioned libraries,
    you can also revert to old versions in case of any functionality issues. Whenever
    you publish any asset to the repositories, always make sure it is versioned. To
    know more about versioning look at this link: [http://semver.org/](http://semver.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other than internal or external JAR files, a project can also depend on:'
  prefs: []
  type: TYPE_NORMAL
- en: The files located on the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other projects (in case of a multiproject build) in the same build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Gradle API (for custom tasks and plugins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Groovy version used by Gradle (for custom tasks and plugins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We saw an example of the Gradle API and the Groovy version used in the previous
    chapters when we developed custom tasks and plugins. Project dependency will be
    discussed in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"), *Working
    with Gradle*. In this chapter, we will discuss other module dependencies on global
    and local repositories, and file dependencies on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: We will start dependency management with a simple example. Consider you are
    building a project, `SampleProject`, which depends on a third-party library `log4j-1.2.16.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the project, you need this jar file at compile time. Gradle provides
    a very easy and systematic way to define dependencies of the project using the
    **dependencies** closure in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Gradle groups dependencies to different configurations. If you apply **Java
    Plugin** to a project, it provides six different configurations, which are listed
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Names | Details |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `compile` | The dependencies mentioned here are added to the classpath during
    compilation of the source code (`src/main/java`) |'
  prefs: []
  type: TYPE_TB
- en: '| `runtime` | The dependencies mentioned here are required at runtime during
    execution of the source code (`src/main/java`) |'
  prefs: []
  type: TYPE_TB
- en: '| `testCompile` | The dependencies mentioned here are added to the classpath
    during compilation of the test code (`src/main/test`) |'
  prefs: []
  type: TYPE_TB
- en: '| `testRuntime` | The dependencies mentioned here are required at runtime during
    execution of the test code (`src/main/test`) |'
  prefs: []
  type: TYPE_TB
- en: '| `archives` | This is used to tell the build file about the artifacts generated
    by the project |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | This contains the artifacts and dependencies used at runtime
    |'
  prefs: []
  type: TYPE_TB
- en: 'To define the preceding dependencies, you need to pass the following details
    to Gradle''s dependency manager:'
  prefs: []
  type: TYPE_NORMAL
- en: JAR file group (or namespace)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAR filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAR file version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: classifier (in case JAR has classifier-like-specific JDK version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The dependencies can be defined in one of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An individual dependency:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Dependency as an Arraylist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Dependency as a Configuration Closure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A Dependency as a Configuration Closure with key-value format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In case of a flat directory (local or remote filesystem), the dependency group
    name is not required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To configure project dependencies, you need to mention all the libraries in
    the `dependencies` closure. So the build file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Do not get confused with the `repositories` closure we have added in the example.
    We will discuss about this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The job is half done when we say dependencies are identified and defined. How
    Gradle will know where to get these dependencies from? Here comes the concept
    of `repositories`. Gradle provides the `repositories` closure to define repositories
    from where dependencies can be downloaded. You can configure any number of repositories
    and also any type of repositories in your project. For dependencies listed in
    the `dependencies` closure, Gradle searches repositories in sequential order.
    If it finds a library or a dependency in one of the repositories (if multiple
    repositories are configured), it skips searching other repositories. In the next
    section, we will learn how to configure different repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the following methods to configure repositories. Gradle allows you
    to use more than one configuration in a build file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Maven Central repository**: This configuration is used to directly download
    your dependencies from the **Maven Central repository**. You do not need to remember
    the repository URL. You can directly add `mavenCentral()` to the `repositories`
    closure as mentioned here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Maven JCenter repository**: Gradle also connects directly to the `jCenter`
    repository by using `jcenter()` inside the repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Maven local Repository**: There might be a scenario where the local Maven
    cache contains all the required dependencies and you do not want to connect to
    the Maven central repository. Instead, you will need to use jars from Maven''s
    local cache. In this scenario, you can use `mavenLocal()` in the `repositories`
    closure. By default, Maven''s local cache path would be `<USER_HOME>/.m2/repository`.
    If you want to change it to another location, you can configure the path in `settings.xml`
    under `<USER_HOME>/.m2` or `<USER_HOME>/.m2/conf`. Having this configuration makes
    it easy to build a "SNAPSHOT" version of another project locally and include that
    version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Ivy repository**: If you want to refer to the Ivy repository, you can define
    it as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also define the custom layout for your Ivy repository. There is not
    an equivalent `ivyLocal()` because Ivy does not allow local publishing of artifacts
    such as Maven.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Organization repository**: No matter how many open source repositories are
    there, you will always need a private repository for software development as you
    are the owner of this repository and changes can be tracked and managed better
    by private repositories. To use your organization''s private repository, you can
    configure the `Repositories` location in the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If your private repository needs authentication, you can provide the credentials
    as well. You can add the credentials to `~/.gradle/gradle.properties` as well
    and use it from there, because it is not a good practice to add credentials directly
    to the build file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For Maven''s format repositories, there is always metadata attached with the
    jar as `pom.xml`. There might be a scenario in which POM file and JAR file are
    located at two different locations. In such cases, you can mention both locations
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If the URL mentioned earlier contains the JAR file, Gradle will download the
    JAR file from that location; otherwise, it will search in `artifactUrls`. You
    can mention more than one `artifactUrls`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Flat directory repository**: There might be a case when you refer a repository
    in the local filesystem (not the `mavenLocal()` location). This situation could
    arise when some other projects or teams are creating jars at a different location
    and publishing those jars to a central location. You want your project to refer
    to these local directories only for dependency. This can be achieved by using
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is not the recommended approach as this will result in inconsistencies.
    The recommended approach is to always use the private or global repository.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dependency resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the standard way of defining dependency and repository, which can
    help you to quick start with the concepts. It's time for a deep dive, and understand
    how to customize the standard configuration, which can suit your specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Transitive dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose your application depends on `commons-httpclient-3.1.jar`, which is a
    first-level dependency. However, this JAR again depends on the following other
    JARs, `commons-codec-1.2.jar` and `commons-logging-1.0.4.jar`.And if we try to
    find more details, `commons-logging jar` again depends on some other JARs.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `commons-httpclient-3.1` is a first-level dependency; the two previously
    mentioned JARs are second-level dependencies, and so on. However, with Gradle,
    you do not need to manage all these levels of dependencies. Imagine the complexity,
    if you have to figure out and mention each level of dependency in the build file.
    This can be very tedious and time consuming. And it becomes more painful if you
    encounter some version conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: With Gradle, you do not need to bother about any such dependency-related issues.
    Gradle provides complete automation for the dependency management. You just define
    the first-level dependency and Gradle will take care of all the transitive dependencies.
    By default, it will download all the transitive dependencies until the last level.
  prefs: []
  type: TYPE_NORMAL
- en: Exclude transitiveness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For some scenarios, you might not want to depend on Gradle to fetch all transitive
    dependencies. Rather, you want to have complete control to download only the libraries
    that you have mentioned in the build file. To switch off a transitive feature,
    you can set the transitive flag `off` in the build file (`build_transitive.gradle`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Clean the Gradle cache (`~/.gradle/caches`) and try to build the project again.
    This time it will download only one JAR that is `commons-httpclient-3.1.jar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This feature could be useful if you need some other version of second-level
    dependencies, or the second-level dependency is missing in the repository and
    you want to manually copy that.
  prefs: []
  type: TYPE_NORMAL
- en: Selective exclude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There might be a scenario when you want to partially use transitive feature,
    that is, you do not want to stop Gradle from getting transitive dependencies,
    but you know it might result in a version conflict. So, you might want some specific
    jars to be excluded from the second or next-level of dependencies. To selectively
    exclude dependencies from the second-level onwards, you can use the following
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exclude criteria requires group as the mandatory field, but the module can
    be optional.
  prefs: []
  type: TYPE_NORMAL
- en: Version conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Version conflict is a very common scenario in which the project depends on
    a specific JAR but of different versions. For example, your project depends on
    `commons-httpclient-3.1` JAR and `commons-codec-1.1` JAR. The `commons-httpclient-3.1`
    JAR has a transitive dependency on the `commons-codec-1.2` JAR. During the build
    process, Gradle will find the dependency on two different versions of the same
    JAR. Your build file (`build_versionconflict.gradle`) will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Issues due to version conflicts take a considerable amount of time even to get
    noticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle supports different strategies to resolve the version conflicts scenarios,
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Latest version**: By default Gradle applies the **get latest** strategy to
    resolve version conflicts issues if it finds different versions of the same JAR
    file. In the preceding scenario, it will skip version 1.1 and download the `commons-codec`
    JAR of version 1.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After executing the `gradle –b build_versionconflict.gradle clean build` command,
    the output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**fail on conflict**: The Get latest strategy might not work always. Sometimes,
    rather than getting the latest version, you might want the build to fail for further
    investigation. To enable this, you apply the `failOnVersionConflict()` configuration
    by adding the following closure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can update your build file with the preceding configuration. If you want
    this strategy for all the builds, you can add this to your `init` script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Force specific version**: In conflict situations, another alternative could
    be, rather than failing the build, you can download specific version of a JAR.
    This can be achieved by using **force flag**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, try to execute the `gradle -b build_versionconflict.gradle build` and
    observe the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Dynamic dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the build flexible on the jar version, you can use the `latest.integration`
    placeholder, or you can define a version range such as `1.+`. With this option,
    you do not have to stick to a specific version. With the `1.+` or `2.+` format,
    it will fix the major version to 1 or 2 (it could be any number) and it will pick
    the latest of the minor version (for example, 1.9 or 2.9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can use either one to get the latest dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever Gradle searches for dependencies in the repository, first it searches
    for a module descriptor file (for example, `pom.xml` or `ivy.xml`). Gradle parses
    this file and downloads the actual JAR file and its dependencies mentioned in
    the module descriptor. There might be a case when a module descriptor file is
    not present. In this case, Gradle directly looks for the JAR file and downloads
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle enables you to play with your dependencies in different ways. Not only
    you can download other file formats such as ZIP and WAR, you can also mention
    different classifiers, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Download file other than JAR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, Gradle downloads file with the `.jar` extension. Sometimes, you
    might need to download either a ZIP file or a WAR file, which does not have any
    module descriptor. In this scenario, you can explicitly mention the extension
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Dependency on files with classifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you release the artifacts with special notation (known as classifiers)
    such as `sampleWeb-1.0-dev.war` or `sampleWeb-1.0-qa.jar`. To download artifacts
    with classifiers, Gradle provides the `classifier` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Replacing transitive dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you do not want to download the existing transitive dependencies and want
    to replace them with your customized transitive dependencies, Gradle provides
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here we have used `@jar`, which can be used as a replacement for the `ext` tag
    that is used in the preceding example. This code snippet will not download the
    existing transitive dependencies of `commons-httpclient`, but it will download
    the JAR mentioned inside the curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: Custom configuration for dependency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we apply the Java plugin, Gradle automatically gives you some default
    configurations such as compile and runtime. We can extend this feature and use
    our own configuration for dependencies. This is an excellent way to group dependencies
    only needed at build time to achieve particular tasks such as code generators
    (depending on a templating library), xjc, cxf wsdl to Java, and so on. We can
    group them under our user-defined configurations. Before using custom configurations
    under the dependency closure, we need to define it inside the configuration closure.
    The following is the code snippet of the `build_customconf.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Dependency reports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle provides a very convenient way to list out all of the project dependencies
    from the first level to the *n*th level. It includes all your **transitive dependencies**,
    including manually changed, overridden, and forced dependencies. The dependency
    tree groups dependencies by configurations such as compile, testCompile, and so
    on. The following is the code snippet from the `build_depreport.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show until the child level of all the dependencies for all configurations.
    You might be surprised to see why other configurations such as runtime and testRuntime
    are being displayed, though only compile configuration was defined. The following
    table shows the relationship between different configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Dependency | Extends |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| compile | - |'
  prefs: []
  type: TYPE_TB
- en: '| runtime | compile |'
  prefs: []
  type: TYPE_TB
- en: '| testCompile | compile |'
  prefs: []
  type: TYPE_TB
- en: '| testRuntime | runtime, testCompile |'
  prefs: []
  type: TYPE_TB
- en: '| default | runtime |'
  prefs: []
  type: TYPE_TB
- en: 'If you want to list out dependencies for only one configuration, you can mention
    that using `–configuration <configuration name>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Dependency-specific details
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you might get issues while downloading some transitive dependencies
    and you do not know which dependency is downloading that JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose while executing the preceding `build_depreport.gradle` script, you
    are getting issues while fetching the `commons-logging` JAR file. It is not the
    first-level dependency and you do not know which first-level dependency is responsible
    for this. To get that detail, use the `dependencyInsight` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify the `–configuration` option, it will apply the `compile`
    configuration by default. The other options are `runtime`, `testCompile`, and
    so on, as mentioned in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have discussed a lot about dependencies. How we can define project
    dependencies, customize them, and configure repositories to download libraries.
    Now, let's try to build the artifacts (JAR, WAR, and so on) and publish it to
    **Artifact repositories** (could be a local filesystem, remote location, or Maven
    repository) to make it available to all the other teams to share.
  prefs: []
  type: TYPE_NORMAL
- en: Default artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we apply the Java plugin, Gradle adds some default configuration to the
    project such as compile, runtime, testCompile. The Java plugin also adds one more
    configuration `archive`, which is used to define the artifacts of your project.
    Gradle provides the default artifact with some of the plugins. For example, Java,
    Groovy plugin publishes JAR as a default artifact, `war plugin` publish WAR as
    a default artifact. This JAR can be uploaded or published to a repository using
    the `uploadArchives` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to configure the repository to upload
    archives using the `build_uploadarchives.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the Maven repository, we can also use the flat directory as a repository.
    In the preceding example, replace the Maven closure with flatDir (`flatDir {dirs
    "./temp1" }`) configuration. Now, if you execute the `gradle uploadArchives` command,
    you will find the JAR file published in the `temp1` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Custom artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each configuration, Gradle provides `Upload<configuration name>`, by default,
    which assembles and uploads the artifacts in the specified configuration. The
    `UploadArchives` task provided by the Java plugin uploads the default artifact
    (`jar`) to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you might need to generate some additional artifacts with the JAR
    file such as the ZIP and XML files. This can be done by archive task to define
    an artifact.
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom artifacts](img/B02000_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the **assemble** task depends on the **jar** task,
    which is nothing but the default artifact of your Java plugin project. You can
    configure additional artifacts using the `archives` configuration. The input to
    the archive configuration can be an artifact itself or a task which creates an
    artifact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate additional XML file along with your JAR file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this example, we will generate additional XML file with the JAR file and
    upload it to the repository. The following is the content of the `CustomArtifact`/`build.gradle`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added `configurations.xml` as a separate XML file to the archive
    so that we can upload the file, along with the the JAR file, to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing Gradle''s `uploadArchives` command, you will find the following
    files in the `tempRepo` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generate additional XML file along with your JAR file](img/B02000_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2
  prefs: []
  type: TYPE_NORMAL
- en: Gradle also generates checksum and a deployment descriptor (here, `ivy-1.0.xml`)
    along with the artifact.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will learn how to upload a ZIP file as an artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Generate an additional ZIP file along with your JAR file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to upload an additional ZIP file along with the JAR file, then
    you can mention the additional archives in the `artifacts` closure. The following
    is the `CustomArtifact/build_zip.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing the `gradle -b build_zip.gradle uploadArchives` command, verify
    the files in the `temp1` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generate an additional ZIP file along with your JAR file](img/B02000_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Here, an additional `MySample-1.0.zip` is generated with the JAR file. You may
    have noticed that we did not make any additional call to the `zipSrc` task, which
    is required to create the ZIP file. Gradle applies a declarative approach here.
    Whatever archives you have configured in the `artifacts` closure, Gradle will
    create those artifacts. Within this closure, you can assign different type of
    tasks, such as JAR, ZIP, TAR (`org.gradle.api.tasks.building.AbstractArchiveTask`),
    or any file to be archived.
  prefs: []
  type: TYPE_NORMAL
- en: Custom configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the same way as custom dependency, you can also define custom configurations
    for your artifacts. Consider the following example (`CustomArtifacts/build_customconf.gradle`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute the `gradle –b build_customconf.gradle uploadZipAsset` command
    to create and upload files to the repository. In the example, we have defined
    a custom configuration `zipAsset`. We used that configuration inside the artifacts
    closure. As mentioned in the preceding example, Gradle automatically provides
    the `upload<configname>` task for each configuration. Thus, we have the `cuploadZipAsset`
    task available to upload the required ZIP file to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The maven-publish plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we discussed the Maven plugin and other repositories
    configuration. Here, we will discuss the new plugin (`maven-publish plugin`) introduced
    by Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have more control over the publication process, Gradle provides the `''maven-publish''`
    plugin. With the help of the following examples, you will see how it can help
    us in publication using the `MavenPublish`/`build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure publications by using following closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The following is the file `MavenPublish/build.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This plugin adds the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`publish`: This publishes all the publications produced by this project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publishToMavenLocal`: This publishes all the Maven publications produced by
    this project to the local Maven cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you add the preceding mentioned `publications` closure inside `publishing`,
    it will add two additional tasks, `generatePomFileFor<publicationName>Publication`
    and `public<publicationName>PublicationToMavenLocal`. You can find additional
    tasks in task list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generatePomFileForPluginPublication`: This generates the Maven POM file for
    publication ''plugin'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publishPluginPublicationToMavenLocal`: This publishes Maven publication ''plugin''
    to the local Maven repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To publish the artifacts in the local Maven repository, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If you browse the local Maven repository, you will also find that the POM file
    has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: By default, it produces the JAR file for the Java project. If you want to add
    additional artifact along with JAR, you can customize the preceding configuration
    by adding additional artifact declaration in the following format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sample code for `MavenPublish/build_zip.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the local repository, along with the JAR file, you will also find an
    additional ZIP file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that for each additional artifact that you are publishing, you will
    need to mention a classifier. Gradle allows only one artifact without a classifier.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing to the local-hosted repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To publish artifacts to the local-hosted repository with help of the `maven-publish`
    plugin, we can use the same configuration, which we discussed in the Maven plugin.
    The repositories closure is exactly the same as before, but it has to be surrounded
    by a publishing closure. You can define the closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You can even publish to a local file repository by mentioning the URL `./localrepo`.
    Maven will automatically create a directory structure for you and you can find
    artifacts under `localrepo/<group>/<version>/artifact-<version>.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you mention the name attribute in the `maven { ….}` closure, Gradle will
    automatically create a new task with the name `publishPluginPublicationTo<name>Repository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now, you will be able to use the `publishMavenJavaPublicationToLocalRepoRepository`
    task or simply the `publish` task to publish to the repository; such as `gradle
    -b build_localrepo.gradle publish`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom POM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Gradle generates the POM file for the artifact with default parameters.
    If you want to modify POM with additional details, you can utilize the `pom.withXml`
    closure. You can add any number of new nodes to the XML file and also update some
    of the existing details. Remember that `groupId`, `artifactId` and `version` are
    read only. You cannot modify these details. Consider the file `build_custompom.gradle`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, execute the `publishToMavenLocal` task and you will find `pom.xml` generated
    in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered details of dependency management provided by Gradle. We
    looked into dependency configuration, strategies involved in dependency resolution,
    and configuring transitive dependencies. We also learned different versions of
    conflict strategies provided by Gradle and how we can configure it to get the
    most out of it.
  prefs: []
  type: TYPE_NORMAL
- en: We also talked about repositories. We covered how you can use different repositories
    such as flat file, local **Maven Repository**, and remote repositories hosted
    on the HTTPS server. Finally, we discussed the publication of the project. With
    the help of different plugins, you can publish artifacts to a central location
    such as the local or remote **Maven Repository**. We also discussed how we can
    utilize the new maven-publish plugin and how to configure it, so that it fits
    into our own requirement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss few important plugins such as War and Scala.
    We'll also discuss other important concepts such as File management, Multi-Project,
    and Properties management.
  prefs: []
  type: TYPE_NORMAL
