- en: Chapter 5. Dependency Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：依赖管理
- en: One of the most important features of any software is managing dependencies.
    As we know, no software works in isolation and we usually depend on third-party
    or open source libraries. The libraries are required during the compile and runtime
    execution and they have to be available in the classpath. Gradle has excellent
    support for dependency management. We just need to write few lines of code in
    the build file and Gradle internally does all the heavy lifting of managing configurations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何软件最重要的特性之一就是依赖管理。正如我们所知，没有任何软件是独立工作的，我们通常依赖于第三方或开源库。这些库在编译和运行时执行过程中是必需的，并且它们必须存在于类路径中。Gradle对依赖管理提供了出色的支持。我们只需在构建文件中编写几行代码，Gradle就会在内部完成所有繁重的配置管理工作。
- en: In this chapter, we will go into details of **dependency management** of Gradle.
    We will discuss the different features such as how to manage project dependencies,
    resolving conflicts, and resolution strategies. We will also discuss how to publish
    artifacts in different repositories.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Gradle的**依赖管理**细节。我们将讨论不同的特性，例如如何管理项目依赖、解决冲突以及解决策略。我们还将讨论如何在不同的仓库中发布工件。
- en: Overview
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Dependency management is one of the most the important features of any build
    tool. It helps to manage software dependencies in a better way. If you are using
    **Ant**, which initially did not support any dependency management, you need to
    write the name of each and every dependent jar file and its location to `build.xml`.
    For small applications that do not have many dependencies, this approach might
    work well. However, for enterprise applications, where software depends on hundreds
    of other libraries, which internally can depend on some other libraries (transitive
    dependencies), this approach of configuring each and every jar file in your `build.xml`
    could work but it requires huge effort to maintain it. Also, managing their version
    conflicts would be really a big pain for any developer and could turn the build
    process into a nightmare. To resolve these drawbacks in Ant, Maven came with an
    internal dependency management solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理是任何构建工具最重要的特性之一。它有助于以更好的方式管理软件依赖。如果你使用的是**Ant**，它最初不支持任何依赖管理，你需要将每个依赖的jar文件及其位置写入`build.xml`。对于没有太多依赖的小型应用程序，这种方法可能效果不错。然而，对于企业应用程序，软件依赖于数百个其他库，这些库内部可能还依赖于其他库（传递依赖），在这种情况下，需要在`build.xml`中配置每个jar文件的方法可能可行，但需要巨大的维护工作量。此外，管理它们的版本冲突对于任何开发者来说都是一个巨大的痛苦，可能会将构建过程变成一场噩梦。为了解决Ant中的这些缺点，Maven引入了内置的依赖管理解决方案。
- en: Later, Ant also integrated with Apache Ivy (a dependency management solution)
    to provide the same feature. Gradle came with its own dependency management implementation.
    It helps to define first-level dependencies, logically group them into different
    configurations, define multiple repositories and also provide tasks to publish
    assets after the execution of the build file. It also supports Ivy, Maven, and
    flat file repositories. In this chapter, along with dependency management, we
    will also look into repositories configurations and asset publications, that is,
    how to configure different repositories and upload assets to repositories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Ant也集成了Apache Ivy（一个依赖管理解决方案）以提供相同的功能。Gradle带来了自己的依赖管理实现。它有助于定义一级依赖，逻辑地将它们分组到不同的配置中，定义多个仓库，并在构建文件执行后提供发布资产的任务。它还支持Ivy、Maven和平文件仓库。在本章中，除了依赖管理之外，我们还将探讨仓库配置和资产发布，即如何配置不同的仓库并将资产上传到仓库。
- en: Dependency configurations
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖配置
- en: 'Before starting with dependency configuration, let''s discuss how to publish
    packaged software in Java. You package and publish either in `.jar` or `.war`
    or `.ear` file formats to a repository. The goal is to share these assets within
    the teams in an organization or with open source developers. Consider a scenario
    where you are publishing a utility project (`messageutil.jar`) to a repository.
    Although the publication process mostly depends on an organization''s policy,
    the common practice is, all the assets that you plan to publish should be **versioned**
    and stored in a central repository, so that all other teams can share it. This
    versioning helps to track different versions of libraries. With versioned libraries,
    you can also revert to old versions in case of any functionality issues. Whenever
    you publish any asset to the repositories, always make sure it is versioned. To
    know more about versioning look at this link: [http://semver.org/](http://semver.org/).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始依赖配置之前，让我们讨论一下如何在Java中发布打包的软件。您可以将软件打包并发布为`.jar`、`.war`或`.ear`文件格式到仓库中。目标是共享这些资产在组织内部的团队或开源开发者之间。考虑一个场景，您正在将一个实用项目（`messageutil.jar`）发布到仓库中。尽管发布过程主要取决于组织的政策，但常见的做法是，您计划发布的所有资产都应该**版本化**并存储在中央仓库中，以便其他团队可以共享它。这种版本化有助于跟踪库的不同版本。有了版本化的库，您还可以在出现任何功能问题时回滚到旧版本。每次您将任何资产发布到仓库时，请确保它已版本化。要了解更多关于版本化的信息，请查看此链接：[http://semver.org/](http://semver.org/)。
- en: Dependency types
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖类型
- en: 'Other than internal or external JAR files, a project can also depend on:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内部或外部的JAR文件外，项目还可以依赖于：
- en: The files located on the filesystem
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统上的文件
- en: Some other projects (in case of a multiproject build) in the same build
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一构建中的其他一些项目（在多项目构建的情况下）
- en: The Gradle API (for custom tasks and plugins)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle API（用于自定义任务和插件）
- en: The Groovy version used by Gradle (for custom tasks and plugins)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle使用的Groovy版本（用于自定义任务和插件）
- en: We saw an example of the Gradle API and the Groovy version used in the previous
    chapters when we developed custom tasks and plugins. Project dependency will be
    discussed in [Chapter 6](ch06.html "Chapter 6. Working with Gradle"), *Working
    with Gradle*. In this chapter, we will discuss other module dependencies on global
    and local repositories, and file dependencies on the local system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开发自定义任务和插件时，在前几章中我们看到了Gradle API和Groovy版本的示例。项目依赖关系将在[第6章](ch06.html "第6章。使用Gradle")
    *使用Gradle* 中讨论。在本章中，我们将讨论全局和本地仓库上的其他模块依赖关系，以及本地系统上的文件依赖关系。
- en: We will start dependency management with a simple example. Consider you are
    building a project, `SampleProject`, which depends on a third-party library `log4j-1.2.16.jar`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的示例开始依赖管理。假设您正在构建一个名为`SampleProject`的项目，该项目依赖于第三方库`log4j-1.2.16.jar`。
- en: 'To build the project, you need this jar file at compile time. Gradle provides
    a very easy and systematic way to define dependencies of the project using the
    **dependencies** closure in the following way:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 构建项目时，您需要在编译时使用这个jar文件。Gradle提供了一种非常简单且系统化的方式来定义项目的依赖关系，即通过以下方式使用**dependencies**闭包：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Gradle groups dependencies to different configurations. If you apply **Java
    Plugin** to a project, it provides six different configurations, which are listed
    in the following table:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle将依赖关系分组到不同的配置中。如果您将**Java插件**应用到项目中，它将提供六个不同的配置，如下表所示：
- en: '| Names | Details |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 详情 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `compile` | The dependencies mentioned here are added to the classpath during
    compilation of the source code (`src/main/java`) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `compile` | 这里提到的依赖关系将在源代码（`src/main/java`）的编译过程中添加到类路径中 |'
- en: '| `runtime` | The dependencies mentioned here are required at runtime during
    execution of the source code (`src/main/java`) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `runtime` | 这里提到的依赖关系在执行源代码（`src/main/java`）时需要运行时 |'
- en: '| `testCompile` | The dependencies mentioned here are added to the classpath
    during compilation of the test code (`src/main/test`) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `testCompile` | 这里提到的依赖关系将在测试代码（`src/main/test`）的编译过程中添加到类路径中 |'
- en: '| `testRuntime` | The dependencies mentioned here are required at runtime during
    execution of the test code (`src/main/test`) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `testRuntime` | 这里提到的依赖关系在执行测试代码（`src/main/test`）时需要运行时 |'
- en: '| `archives` | This is used to tell the build file about the artifacts generated
    by the project |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `archives` | 这用于告诉构建文件关于项目生成的工件 |'
- en: '| `default` | This contains the artifacts and dependencies used at runtime
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `default` | 这包含在运行时使用的工件和依赖关系 |'
- en: 'To define the preceding dependencies, you need to pass the following details
    to Gradle''s dependency manager:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义前面的依赖项，您需要将以下详细信息传递给 Gradle 的依赖项管理器：
- en: JAR file group (or namespace)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 文件组（或命名空间）
- en: JAR filename
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 文件名
- en: JAR file version
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAR 文件版本
- en: classifier (in case JAR has classifier-like-specific JDK version)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分类器（如果 JAR 有类似分类器的特定 JDK 版本）
- en: 'The dependencies can be defined in one of the following ways:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项可以以下列方式之一定义：
- en: 'An individual dependency:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个依赖项：
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A Dependency as an Arraylist:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Arraylist 的依赖项：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A Dependency as a Configuration Closure:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为配置闭包的依赖项：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A Dependency as a Configuration Closure with key-value format:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以键值格式作为配置闭包的依赖项：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In case of a flat directory (local or remote filesystem), the dependency group
    name is not required.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在平面目录（本地或远程文件系统）的情况下，不需要依赖项组名。
- en: 'To configure project dependencies, you need to mention all the libraries in
    the `dependencies` closure. So the build file will look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置项目依赖项，您需要在 `dependencies` 闭包中提及所有库。因此，构建文件将看起来像这样：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Do not get confused with the `repositories` closure we have added in the example.
    We will discuss about this in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与我们在示例中添加的 `repositories` 闭包混淆。我们将在下一节中讨论这个问题。
- en: Repositories
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库
- en: The job is half done when we say dependencies are identified and defined. How
    Gradle will know where to get these dependencies from? Here comes the concept
    of `repositories`. Gradle provides the `repositories` closure to define repositories
    from where dependencies can be downloaded. You can configure any number of repositories
    and also any type of repositories in your project. For dependencies listed in
    the `dependencies` closure, Gradle searches repositories in sequential order.
    If it finds a library or a dependency in one of the repositories (if multiple
    repositories are configured), it skips searching other repositories. In the next
    section, we will learn how to configure different repositories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说依赖项已识别和定义时，工作已经完成了一半。Gradle 将如何知道从哪里获取这些依赖项呢？这就是 `repositories` 概念的出现。Gradle
    提供了 `repositories` 闭包来定义可以从哪里下载依赖项的仓库。您可以在项目中配置任意数量的仓库和任意类型的仓库。对于在 `dependencies`
    闭包中列出的依赖项，Gradle 将按顺序搜索仓库。如果它在配置的仓库之一中找到一个库或依赖项（如果配置了多个仓库），它将跳过搜索其他仓库。在下一节中，我们将学习如何配置不同的仓库。
- en: Repositories configuration
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库配置
- en: You can use the following methods to configure repositories. Gradle allows you
    to use more than one configuration in a build file.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方法来配置仓库。Gradle 允许您在构建文件中使用多个配置。
- en: '**Maven Central repository**: This configuration is used to directly download
    your dependencies from the **Maven Central repository**. You do not need to remember
    the repository URL. You can directly add `mavenCentral()` to the `repositories`
    closure as mentioned here:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven Central 仓库**：此配置用于直接从 **Maven Central 仓库** 下载您的依赖项。您不需要记住仓库 URL。您可以直接将
    `mavenCentral()` 添加到此处提到的 `repositories` 闭包中：'
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Maven JCenter repository**: Gradle also connects directly to the `jCenter`
    repository by using `jcenter()` inside the repositories.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven JCenter 仓库**：Gradle 还通过在 `repositories` 中使用 `jcenter()` 直接连接到 `jCenter`
    仓库。'
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Maven local Repository**: There might be a scenario where the local Maven
    cache contains all the required dependencies and you do not want to connect to
    the Maven central repository. Instead, you will need to use jars from Maven''s
    local cache. In this scenario, you can use `mavenLocal()` in the `repositories`
    closure. By default, Maven''s local cache path would be `<USER_HOME>/.m2/repository`.
    If you want to change it to another location, you can configure the path in `settings.xml`
    under `<USER_HOME>/.m2` or `<USER_HOME>/.m2/conf`. Having this configuration makes
    it easy to build a "SNAPSHOT" version of another project locally and include that
    version.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven 本地仓库**：可能存在一种情况，本地 Maven 缓存中包含所有必需的依赖项，并且您不想连接到 Maven 中央仓库。相反，您将需要使用
    Maven 的本地缓存中的 JAR 文件。在这种情况下，您可以在 `repositories` 闭包中使用 `mavenLocal()`。默认情况下，Maven
    的本地缓存路径将是 `<USER_HOME>/.m2/repository`。如果您想将其更改为另一个位置，您可以在 `<USER_HOME>/.m2` 或
    `<USER_HOME>/.m2/conf` 下的 `settings.xml` 中配置路径。拥有此配置可以轻松地在本地构建另一个项目的“SNAPSHOT”版本并将其包含在内。'
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Ivy repository**: If you want to refer to the Ivy repository, you can define
    it as follows:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ivy 仓库**：如果您想引用 Ivy 仓库，可以按以下方式定义：'
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can also define the custom layout for your Ivy repository. There is not
    an equivalent `ivyLocal()` because Ivy does not allow local publishing of artifacts
    such as Maven.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还可以为你的Ivy仓库定义自定义布局。由于Ivy不允许本地发布如Maven这样的工件，因此没有等效的`ivyLocal()`。
- en: '**Organization repository**: No matter how many open source repositories are
    there, you will always need a private repository for software development as you
    are the owner of this repository and changes can be tracked and managed better
    by private repositories. To use your organization''s private repository, you can
    configure the `Repositories` location in the following format:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织仓库**：无论有多少开源仓库，你都需要一个私有仓库来进行软件开发，因为你拥有这个仓库，并且私有仓库可以更好地跟踪和管理变更。要使用你组织的私有仓库，你可以按照以下格式配置`Repositories`位置：'
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If your private repository needs authentication, you can provide the credentials
    as well. You can add the credentials to `~/.gradle/gradle.properties` as well
    and use it from there, because it is not a good practice to add credentials directly
    to the build file.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你的私有仓库需要认证，你也可以提供凭证。你还可以将凭证添加到`~/.gradle/gradle.properties`中，并从那里使用它，因为将凭证直接添加到构建文件中并不是一个好的做法。
- en: 'For Maven''s format repositories, there is always metadata attached with the
    jar as `pom.xml`. There might be a scenario in which POM file and JAR file are
    located at two different locations. In such cases, you can mention both locations
    as follows:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Maven格式的仓库，jar文件总是附带有`pom.xml`作为元数据。可能存在一种情况，即POM文件和JAR文件位于两个不同的位置。在这种情况下，你可以如下提及这两个位置：
- en: '[PRE11]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the URL mentioned earlier contains the JAR file, Gradle will download the
    JAR file from that location; otherwise, it will search in `artifactUrls`. You
    can mention more than one `artifactUrls`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果前面提到的URL包含JAR文件，Gradle将从该位置下载JAR文件；否则，它将在`artifactUrls`中搜索。你可以提及多个`artifactUrls`。
- en: '**Flat directory repository**: There might be a case when you refer a repository
    in the local filesystem (not the `mavenLocal()` location). This situation could
    arise when some other projects or teams are creating jars at a different location
    and publishing those jars to a central location. You want your project to refer
    to these local directories only for dependency. This can be achieved by using
    the following code:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扁平目录仓库**：可能存在一种情况，当你引用本地文件系统中的仓库（不是`mavenLocal()`位置）时。这种情况可能发生在其他项目或团队在不同的位置创建JAR文件并将这些JAR文件发布到中央位置时。你希望你的项目仅将本地目录用于依赖项。这可以通过以下代码实现：'
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is not the recommended approach as this will result in inconsistencies.
    The recommended approach is to always use the private or global repository.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法并不推荐，因为这会导致不一致。推荐的方法是始终使用私有或全局仓库。
- en: Dependency resolution
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项解析
- en: We have seen the standard way of defining dependency and repository, which can
    help you to quick start with the concepts. It's time for a deep dive, and understand
    how to customize the standard configuration, which can suit your specific requirements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了定义依赖项和仓库的标准方式，这可以帮助你快速入门这些概念。现在是时候深入了解了，了解如何自定义标准配置，以适应你的特定需求。
- en: Transitive dependency
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传递依赖
- en: Suppose your application depends on `commons-httpclient-3.1.jar`, which is a
    first-level dependency. However, this JAR again depends on the following other
    JARs, `commons-codec-1.2.jar` and `commons-logging-1.0.4.jar`.And if we try to
    find more details, `commons-logging jar` again depends on some other JARs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的应用程序依赖于`commons-httpclient-3.1.jar`，这是一个一级依赖项。然而，这个JAR文件又依赖于以下其他JAR文件，`commons-codec-1.2.jar`和`commons-logging-1.0.4.jar`。如果我们尝试查找更多细节，`commons-logging
    jar`又依赖于其他一些JAR文件。
- en: Here, `commons-httpclient-3.1` is a first-level dependency; the two previously
    mentioned JARs are second-level dependencies, and so on. However, with Gradle,
    you do not need to manage all these levels of dependencies. Imagine the complexity,
    if you have to figure out and mention each level of dependency in the build file.
    This can be very tedious and time consuming. And it becomes more painful if you
    encounter some version conflicts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`commons-httpclient-3.1`是一个一级依赖项；前面提到的两个JAR文件是二级依赖项，依此类推。然而，使用Gradle，你不需要管理所有这些级别的依赖项。想象一下，如果你必须在构建文件中找出并提及每个级别的依赖项，这将是非常繁琐且耗时的。如果你遇到一些版本冲突，这会变得更加痛苦。
- en: With Gradle, you do not need to bother about any such dependency-related issues.
    Gradle provides complete automation for the dependency management. You just define
    the first-level dependency and Gradle will take care of all the transitive dependencies.
    By default, it will download all the transitive dependencies until the last level.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gradle，你不需要担心任何此类依赖项相关的问题。Gradle 为依赖项管理提供完全自动化。你只需定义第一级依赖项，Gradle 就会处理所有传递性依赖项。默认情况下，它将下载所有传递性依赖项，直到最后一级。
- en: Exclude transitiveness
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除传递性
- en: 'For some scenarios, you might not want to depend on Gradle to fetch all transitive
    dependencies. Rather, you want to have complete control to download only the libraries
    that you have mentioned in the build file. To switch off a transitive feature,
    you can set the transitive flag `off` in the build file (`build_transitive.gradle`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些场景，你可能不希望 Gradle 获取所有传递性依赖项。相反，你希望对构建文件中提到的库有完全的控制权，只下载这些库。要关闭传递性特性，你可以在构建文件
    (`build_transitive.gradle`) 中设置传递性标志 `off`：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Clean the Gradle cache (`~/.gradle/caches`) and try to build the project again.
    This time it will download only one JAR that is `commons-httpclient-3.1.jar`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清理 Gradle 缓存 (`~/.gradle/caches`) 并再次尝试构建项目。这次它将只下载一个 JAR 包，即 `commons-httpclient-3.1.jar`：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This feature could be useful if you need some other version of second-level
    dependencies, or the second-level dependency is missing in the repository and
    you want to manually copy that.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要第二级依赖项的其他版本，或者第二级依赖项在仓库中缺失，而你希望手动复制它，这个特性可能很有用。
- en: Selective exclude
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择性排除
- en: 'There might be a scenario when you want to partially use transitive feature,
    that is, you do not want to stop Gradle from getting transitive dependencies,
    but you know it might result in a version conflict. So, you might want some specific
    jars to be excluded from the second or next-level of dependencies. To selectively
    exclude dependencies from the second-level onwards, you can use the following
    configuration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一种情况，当你想要部分使用传递性特性时，也就是说，你不想阻止 Gradle 获取传递性依赖项，但你又知道这可能会导致版本冲突。因此，你可能希望某些特定的
    JAR 包在第二级或下一级依赖中被排除。为了从第二级开始选择性排除依赖项，你可以使用以下配置：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The exclude criteria requires group as the mandatory field, but the module can
    be optional.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 排除标准需要将组作为必填字段，但模块可以是可选的。
- en: Version conflicts
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本冲突
- en: 'Version conflict is a very common scenario in which the project depends on
    a specific JAR but of different versions. For example, your project depends on
    `commons-httpclient-3.1` JAR and `commons-codec-1.1` JAR. The `commons-httpclient-3.1`
    JAR has a transitive dependency on the `commons-codec-1.2` JAR. During the build
    process, Gradle will find the dependency on two different versions of the same
    JAR. Your build file (`build_versionconflict.gradle`) will look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 版本冲突是一个非常常见的场景，其中项目依赖于特定版本的 JAR 包。例如，你的项目依赖于 `commons-httpclient-3.1` JAR 包和
    `commons-codec-1.1` JAR 包。`commons-httpclient-3.1` JAR 包有一个对 `commons-codec-1.2`
    JAR 包的传递性依赖。在构建过程中，Gradle 将找到对同一 JAR 包的两个不同版本的依赖。你的构建文件 (`build_versionconflict.gradle`)
    将看起来像这样：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Issues due to version conflicts take a considerable amount of time even to get
    noticed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于版本冲突引起的问题甚至需要相当长的时间才能被发现。
- en: 'Gradle supports different strategies to resolve the version conflicts scenarios,
    they are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 支持不同的策略来解决版本冲突场景，如下所示：
- en: '**Latest version**: By default Gradle applies the **get latest** strategy to
    resolve version conflicts issues if it finds different versions of the same JAR
    file. In the preceding scenario, it will skip version 1.1 and download the `commons-codec`
    JAR of version 1.2.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最新版本**：默认情况下，Gradle 在发现同一 JAR 文件的不同版本时会应用 **获取最新版本** 策略来解决版本冲突问题。在前面的场景中，它将跳过版本
    1.1 并下载版本 1.2 的 `commons-codec` JAR 包。'
- en: 'After executing the `gradle –b build_versionconflict.gradle clean build` command,
    the output will be as follows:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行 `gradle –b build_versionconflict.gradle clean build` 命令后，输出将如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**fail on conflict**: The Get latest strategy might not work always. Sometimes,
    rather than getting the latest version, you might want the build to fail for further
    investigation. To enable this, you apply the `failOnVersionConflict()` configuration
    by adding the following closure:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在冲突时失败**：获取最新版本的策略并不总是有效。有时，你可能会希望构建失败以便进一步调查，而不是获取最新版本。要启用此功能，你可以通过添加以下闭包来应用
    `failOnVersionConflict()` 配置：'
- en: '[PRE18]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can update your build file with the preceding configuration. If you want
    this strategy for all the builds, you can add this to your `init` script.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用前面的配置更新你的构建文件。如果你想将此策略应用于所有构建，你可以将其添加到你的 `init` 脚本中。
- en: '**Force specific version**: In conflict situations, another alternative could
    be, rather than failing the build, you can download specific version of a JAR.
    This can be achieved by using **force flag**:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制指定版本**：在冲突情况下，另一种选择是，而不是使构建失败，你可以下载特定版本的 JAR。这可以通过使用 **强制标志** 实现：'
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, try to execute the `gradle -b build_versionconflict.gradle build` and
    observe the output:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，尝试执行 `gradle -b build_versionconflict.gradle build` 并观察输出：
- en: '[PRE20]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Dynamic dependency
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态依赖项
- en: To make the build flexible on the jar version, you can use the `latest.integration`
    placeholder, or you can define a version range such as `1.+`. With this option,
    you do not have to stick to a specific version. With the `1.+` or `2.+` format,
    it will fix the major version to 1 or 2 (it could be any number) and it will pick
    the latest of the minor version (for example, 1.9 or 2.9).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要使构建对 JAR 版本更灵活，你可以使用 `latest.integration` 占位符，或者你可以定义一个版本范围，例如 `1.+`。使用此选项，你不必坚持特定的版本。使用
    `1.+` 或 `2.+` 格式，它将固定主版本为 1 或 2（可以是任何数字），并选择次版本的最新版本（例如，1.9 或 2.9）。
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can use either one to get the latest dependency.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用其中任何一个来获取最新的依赖项。
- en: Customizing the dependency
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项定制
- en: Whenever Gradle searches for dependencies in the repository, first it searches
    for a module descriptor file (for example, `pom.xml` or `ivy.xml`). Gradle parses
    this file and downloads the actual JAR file and its dependencies mentioned in
    the module descriptor. There might be a case when a module descriptor file is
    not present. In this case, Gradle directly looks for the JAR file and downloads
    it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 Gradle 在仓库中搜索依赖项时，首先它会搜索一个模块描述符文件（例如，`pom.xml` 或 `ivy.xml`）。Gradle 解析此文件并下载模块描述符中提到的实际
    JAR 文件及其依赖项。可能存在一种情况，即没有模块描述符文件。在这种情况下，Gradle 直接查找 JAR 文件并下载它。
- en: Gradle enables you to play with your dependencies in different ways. Not only
    you can download other file formats such as ZIP and WAR, you can also mention
    different classifiers, if needed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 允许你以不同的方式处理依赖项。不仅你可以下载其他文件格式，如 ZIP 和 WAR，如果需要，还可以指定不同的分类器。
- en: Download file other than JAR
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载非 JAR 文件
- en: 'By default, Gradle downloads file with the `.jar` extension. Sometimes, you
    might need to download either a ZIP file or a WAR file, which does not have any
    module descriptor. In this scenario, you can explicitly mention the extension
    of the file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle 下载具有 `.jar` 扩展名的文件。有时，你可能需要下载 ZIP 文件或 WAR 文件，这些文件没有模块描述符。在这种情况下，你可以明确指定文件的扩展名：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Dependency on files with classifiers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有分类器的文件依赖项
- en: 'Sometimes you release the artifacts with special notation (known as classifiers)
    such as `sampleWeb-1.0-dev.war` or `sampleWeb-1.0-qa.jar`. To download artifacts
    with classifiers, Gradle provides the `classifier` tag:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会以特殊的标记（称为分类器）发布工件，例如 `sampleWeb-1.0-dev.war` 或 `sampleWeb-1.0-qa.jar`。要下载带有分类器的工件，Gradle
    提供了 `classifier` 标签：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Replacing transitive dependencies
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换传递依赖项
- en: 'If you do not want to download the existing transitive dependencies and want
    to replace them with your customized transitive dependencies, Gradle provides
    the following way:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想下载现有的传递依赖项并想用你定制的传递依赖项替换它们，Gradle 提供了以下方法：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we have used `@jar`, which can be used as a replacement for the `ext` tag
    that is used in the preceding example. This code snippet will not download the
    existing transitive dependencies of `commons-httpclient`, but it will download
    the JAR mentioned inside the curly braces.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们使用了 `@jar`，它可以替代前面示例中使用的 `ext` 标签。此代码片段将不会下载 `commons-httpclient` 的现有传递依赖项，但它将下载花括号内提到的
    JAR 文件。
- en: Custom configuration for dependency
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项的定制配置
- en: 'When we apply the Java plugin, Gradle automatically gives you some default
    configurations such as compile and runtime. We can extend this feature and use
    our own configuration for dependencies. This is an excellent way to group dependencies
    only needed at build time to achieve particular tasks such as code generators
    (depending on a templating library), xjc, cxf wsdl to Java, and so on. We can
    group them under our user-defined configurations. Before using custom configurations
    under the dependency closure, we need to define it inside the configuration closure.
    The following is the code snippet of the `build_customconf.gradle` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following is the output of the preceding code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Dependency reports
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gradle provides a very convenient way to list out all of the project dependencies
    from the first level to the *n*th level. It includes all your **transitive dependencies**,
    including manually changed, overridden, and forced dependencies. The dependency
    tree groups dependencies by configurations such as compile, testCompile, and so
    on. The following is the code snippet from the `build_depreport.gradle` file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It will show until the child level of all the dependencies for all configurations.
    You might be surprised to see why other configurations such as runtime and testRuntime
    are being displayed, though only compile configuration was defined. The following
    table shows the relationship between different configurations:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '| Dependency | Extends |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| compile | - |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| runtime | compile |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| testCompile | compile |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| testRuntime | runtime, testCompile |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| default | runtime |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: 'If you want to list out dependencies for only one configuration, you can mention
    that using `–configuration <configuration name>`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Dependency-specific details
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you might get issues while downloading some transitive dependencies
    and you do not know which dependency is downloading that JAR file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose while executing the preceding `build_depreport.gradle` script, you
    are getting issues while fetching the `commons-logging` JAR file. It is not the
    first-level dependency and you do not know which first-level dependency is responsible
    for this. To get that detail, use the `dependencyInsight` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you do not specify the `–configuration` option, it will apply the `compile`
    configuration by default. The other options are `runtime`, `testCompile`, and
    so on, as mentioned in the preceding example.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Publishing artifacts
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have discussed a lot about dependencies. How we can define project
    dependencies, customize them, and configure repositories to download libraries.
    Now, let's try to build the artifacts (JAR, WAR, and so on) and publish it to
    **Artifact repositories** (could be a local filesystem, remote location, or Maven
    repository) to make it available to all the other teams to share.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Default artifacts
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we apply the Java plugin, Gradle adds some default configuration to the
    project such as compile, runtime, testCompile. The Java plugin also adds one more
    configuration `archive`, which is used to define the artifacts of your project.
    Gradle provides the default artifact with some of the plugins. For example, Java,
    Groovy plugin publishes JAR as a default artifact, `war plugin` publish WAR as
    a default artifact. This JAR can be uploaded or published to a repository using
    the `uploadArchives` task.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们应用Java插件时，Gradle会向项目添加一些默认配置，例如编译、运行时、测试编译。Java插件还添加了一个额外的配置`archive`，用于定义你的项目工件。Gradle通过一些插件提供默认工件。例如，Java、Groovy插件将JAR作为默认工件发布，`war插件`将WAR作为默认工件。这个JAR可以使用`uploadArchives`任务上传或发布到仓库。
- en: 'The following code snippet shows how to configure the repository to upload
    archives using the `build_uploadarchives.gradle` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何通过`build_uploadarchives.gradle`文件配置仓库以上传归档：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Instead of the Maven repository, we can also use the flat directory as a repository.
    In the preceding example, replace the Maven closure with flatDir (`flatDir {dirs
    "./temp1" }`) configuration. Now, if you execute the `gradle uploadArchives` command,
    you will find the JAR file published in the `temp1` directory.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用平面目录作为仓库，而不是Maven仓库。在先前的示例中，将Maven闭包替换为`flatDir {dirs "./temp1" }`配置。现在，如果你执行`gradle
    uploadArchives`命令，你将在`temp1`目录中找到已发布的JAR文件。
- en: Custom artifacts
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义工件
- en: For each configuration, Gradle provides `Upload<configuration name>`, by default,
    which assembles and uploads the artifacts in the specified configuration. The
    `UploadArchives` task provided by the Java plugin uploads the default artifact
    (`jar`) to the repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个配置，Gradle默认提供`Upload<配置名称>`，它将组装并上传指定配置中的工件。Java插件提供的`UploadArchives`任务将默认工件（`jar`）上传到仓库。
- en: Sometimes, you might need to generate some additional artifacts with the JAR
    file such as the ZIP and XML files. This can be done by archive task to define
    an artifact.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要与JAR文件一起生成一些额外的工件，如ZIP和XML文件。这可以通过归档任务来定义工件。
- en: '![Custom artifacts](img/B02000_05_01.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![自定义工件](img/B02000_05_01.jpg)'
- en: Figure 5.1
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1
- en: In the preceding figure, the **assemble** task depends on the **jar** task,
    which is nothing but the default artifact of your Java plugin project. You can
    configure additional artifacts using the `archives` configuration. The input to
    the archive configuration can be an artifact itself or a task which creates an
    artifact.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**assemble**任务依赖于**jar**任务，这仅仅是你的Java插件项目的默认工件。你可以使用`archives`配置来配置额外的工件。归档配置的输入可以是一个工件本身或创建工件的任务。
- en: 'Let''s take a look at the following two examples:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下两个示例：
- en: Generate additional XML file along with your JAR file
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与你的JAR文件一起生成额外的XML文件
- en: 'In this example, we will generate additional XML file with the JAR file and
    upload it to the repository. The following is the content of the `CustomArtifact`/`build.gradle`
    file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将生成一个额外的XML文件与JAR文件一起，并将其上传到仓库。以下是`CustomArtifact`/`build.gradle`文件的内容：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have added `configurations.xml` as a separate XML file to the archive
    so that we can upload the file, along with the the JAR file, to the repository.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们已将`configurations.xml`作为一个单独的XML文件添加到归档中，这样我们就可以将文件与JAR文件一起上传到仓库。
- en: 'After executing Gradle''s `uploadArchives` command, you will find the following
    files in the `tempRepo` directory:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行Gradle的`uploadArchives`命令后，你将在`tempRepo`目录中找到以下文件：
- en: '![Generate additional XML file along with your JAR file](img/B02000_05_02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![与你的JAR文件一起生成额外的XML文件](img/B02000_05_02.jpg)'
- en: Figure 5.2
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2
- en: Gradle also generates checksum and a deployment descriptor (here, `ivy-1.0.xml`)
    along with the artifact.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle还会生成校验和以及部署描述符（这里为`ivy-1.0.xml`），与工件一起生成。
- en: In the following section, we will learn how to upload a ZIP file as an artifact.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将学习如何上传ZIP文件作为工件。
- en: Generate an additional ZIP file along with your JAR file
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与你的JAR文件一起生成额外的ZIP文件
- en: 'If you want to upload an additional ZIP file along with the JAR file, then
    you can mention the additional archives in the `artifacts` closure. The following
    is the `CustomArtifact/build_zip.gradle` file:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要上传一个额外的ZIP文件与JAR文件一起，你可以在`artifacts`闭包中提及额外的归档。以下是`CustomArtifact/build_zip.gradle`文件：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After executing the `gradle -b build_zip.gradle uploadArchives` command, verify
    the files in the `temp1` directory:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`gradle -b build_zip.gradle uploadArchives`命令后，验证`temp1`目录中的文件：
- en: '![Generate an additional ZIP file along with your JAR file](img/B02000_05_03.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![生成与 JAR 文件一起的附加 ZIP 文件](img/B02000_05_03.jpg)'
- en: Figure 5.3
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3
- en: Here, an additional `MySample-1.0.zip` is generated with the JAR file. You may
    have noticed that we did not make any additional call to the `zipSrc` task, which
    is required to create the ZIP file. Gradle applies a declarative approach here.
    Whatever archives you have configured in the `artifacts` closure, Gradle will
    create those artifacts. Within this closure, you can assign different type of
    tasks, such as JAR, ZIP, TAR (`org.gradle.api.tasks.building.AbstractArchiveTask`),
    or any file to be archived.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，除了 JAR 文件外，还生成了一个额外的 `MySample-1.0.zip` 文件。您可能已经注意到，我们没有对 `zipSrc` 任务进行任何额外的调用，这是创建
    ZIP 文件所必需的。在这里，Gradle 采用了一种声明式方法。无论您在 `artifacts` 闭包中配置了哪些存档，Gradle 都会创建这些存档。在此闭包内，您可以分配不同类型的任务，例如
    JAR、ZIP、TAR (`org.gradle.api.tasks.building.AbstractArchiveTask`) 或任何要存档的文件。
- en: Custom configuration
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义配置
- en: 'In the same way as custom dependency, you can also define custom configurations
    for your artifacts. Consider the following example (`CustomArtifacts/build_customconf.gradle`):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '与自定义依赖项一样，您也可以为您的存档定义自定义配置。考虑以下示例 (`CustomArtifacts/build_customconf.gradle`):'
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, execute the `gradle –b build_customconf.gradle uploadZipAsset` command
    to create and upload files to the repository. In the example, we have defined
    a custom configuration `zipAsset`. We used that configuration inside the artifacts
    closure. As mentioned in the preceding example, Gradle automatically provides
    the `upload<configname>` task for each configuration. Thus, we have the `cuploadZipAsset`
    task available to upload the required ZIP file to the repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行 `gradle –b build_customconf.gradle uploadZipAsset` 命令以创建和上传文件到仓库。在示例中，我们定义了一个自定义配置
    `zipAsset`。我们在 artifacts 闭包内部使用了该配置。如前例所述，Gradle 自动为每个配置提供 `upload<configname>`
    任务。因此，我们有 `cuploadZipAsset` 任务可用于上传所需的 ZIP 文件到仓库。
- en: The maven-publish plugins
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maven 发布插件
- en: In the previous section, we discussed the Maven plugin and other repositories
    configuration. Here, we will discuss the new plugin (`maven-publish plugin`) introduced
    by Gradle.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了 Maven 插件和其他仓库配置。在这里，我们将讨论 Gradle 引入的新插件（`maven-publish plugin`）。
- en: 'To have more control over the publication process, Gradle provides the `''maven-publish''`
    plugin. With the help of the following examples, you will see how it can help
    us in publication using the `MavenPublish`/`build.gradle` file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对发布过程有更多的控制，Gradle 提供了 `'maven-publish'` 插件。通过以下示例，您将看到它如何帮助我们使用 `MavenPublish`/`build.gradle`
    文件进行发布：
- en: 'You can configure publications by using following closure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下闭包来配置发布：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The following is the file `MavenPublish/build.gradle`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件是 `MavenPublish/build.gradle`。
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This plugin adds the following tasks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件添加以下任务：
- en: '`publish`: This publishes all the publications produced by this project'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish`: 这会发布此项目产生的所有发布物'
- en: '`publishToMavenLocal`: This publishes all the Maven publications produced by
    this project to the local Maven cache'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publishToMavenLocal`: 这会将此项目产生的所有 Maven 发布物发布到本地 Maven 缓存'
- en: 'When you add the preceding mentioned `publications` closure inside `publishing`,
    it will add two additional tasks, `generatePomFileFor<publicationName>Publication`
    and `public<publicationName>PublicationToMavenLocal`. You can find additional
    tasks in task list as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 `publishing` 内部添加前面提到的 `publications` 闭包时，它将添加两个额外的任务，`generatePomFileFor<publicationName>Publication`
    和 `public<publicationName>PublicationToMavenLocal`。您可以在任务列表中找到以下附加任务：
- en: '`generatePomFileForPluginPublication`: This generates the Maven POM file for
    publication ''plugin'''
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generatePomFileForPluginPublication`: 这为发布 ''plugin'' 生成 Maven POM 文件'
- en: '`publishPluginPublicationToMavenLocal`: This publishes Maven publication ''plugin''
    to the local Maven repository'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publishPluginPublicationToMavenLocal`: 这会将 Maven 发布的 ''plugin'' 发布到本地 Maven
    仓库'
- en: 'To publish the artifacts in the local Maven repository, execute the following
    command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地 Maven 仓库中发布存档，请执行以下命令：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If you browse the local Maven repository, you will also find that the POM file
    has the following content:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览本地 Maven 仓库，您也会发现 POM 文件具有以下内容：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: By default, it produces the JAR file for the Java project. If you want to add
    additional artifact along with JAR, you can customize the preceding configuration
    by adding additional artifact declaration in the following format.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它为 Java 项目生成 JAR 文件。如果您想与 JAR 文件一起添加额外的存档，您可以通过在以下格式中添加额外的存档声明来自定义前面的配置。
- en: 'Here is the sample code for `MavenPublish/build_zip.gradle`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`MavenPublish/build_zip.gradle`的示例代码：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, in the local repository, along with the JAR file, you will also find an
    additional ZIP file.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在本地仓库中，除了JAR文件外，你还会找到一个额外的ZIP文件。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that for each additional artifact that you are publishing, you will
    need to mention a classifier. Gradle allows only one artifact without a classifier.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于你发布的每个额外工件，你都需要提及一个分类器。Gradle只允许一个没有分类器的工件。
- en: Publishing to the local-hosted repository
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布到本地仓库
- en: 'To publish artifacts to the local-hosted repository with help of the `maven-publish`
    plugin, we can use the same configuration, which we discussed in the Maven plugin.
    The repositories closure is exactly the same as before, but it has to be surrounded
    by a publishing closure. You can define the closure as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`maven-publish`插件将工件发布到本地仓库，我们可以使用与在Maven插件中讨论的相同配置。仓库的闭包与之前完全相同，但它必须被一个发布闭包所包围。你可以按照以下方式定义闭包：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You can even publish to a local file repository by mentioning the URL `./localrepo`.
    Maven will automatically create a directory structure for you and you can find
    artifacts under `localrepo/<group>/<version>/artifact-<version>.jar`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过指定URL `./localrepo` 将工件发布到本地文件仓库。Maven将自动为你创建目录结构，你可以在`localrepo/<group>/<version>/artifact-<version>.jar`下找到工件。
- en: 'If you mention the name attribute in the `maven { ….}` closure, Gradle will
    automatically create a new task with the name `publishPluginPublicationTo<name>Repository`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提到`maven { ….}`闭包中的名称属性，Gradle将自动创建一个名为`publishPluginPublicationTo<name>Repository`的新任务：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, you will be able to use the `publishMavenJavaPublicationToLocalRepoRepository`
    task or simply the `publish` task to publish to the repository; such as `gradle
    -b build_localrepo.gradle publish`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够使用`publishMavenJavaPublicationToLocalRepoRepository`任务或简单地使用`publish`任务来发布到仓库；例如`gradle
    -b build_localrepo.gradle publish`。
- en: Custom POM
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义POM
- en: By default, Gradle generates the POM file for the artifact with default parameters.
    If you want to modify POM with additional details, you can utilize the `pom.withXml`
    closure. You can add any number of new nodes to the XML file and also update some
    of the existing details. Remember that `groupId`, `artifactId` and `version` are
    read only. You cannot modify these details. Consider the file `build_custompom.gradle`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Gradle使用默认参数为工件生成POM文件。如果你想使用`pom.withXml`闭包修改POM文件以包含额外的详细信息，你可以这样做。你可以在XML文件中添加任意数量的新节点，也可以更新一些现有细节。请记住，`groupId`、`artifactId`和`version`是只读的。你不能修改这些细节。考虑文件`build_custompom.gradle`。
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, execute the `publishToMavenLocal` task and you will find `pom.xml` generated
    in the repository.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行`publishToMavenLocal`任务，你将在仓库中找到生成的`pom.xml`文件。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered details of dependency management provided by Gradle. We
    looked into dependency configuration, strategies involved in dependency resolution,
    and configuring transitive dependencies. We also learned different versions of
    conflict strategies provided by Gradle and how we can configure it to get the
    most out of it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Gradle提供的依赖管理细节。我们探讨了依赖配置、依赖解析中涉及的战略以及配置传递依赖。我们还学习了Gradle提供的不同版本的冲突策略，以及我们如何配置它以获得最大利益。
- en: We also talked about repositories. We covered how you can use different repositories
    such as flat file, local **Maven Repository**, and remote repositories hosted
    on the HTTPS server. Finally, we discussed the publication of the project. With
    the help of different plugins, you can publish artifacts to a central location
    such as the local or remote **Maven Repository**. We also discussed how we can
    utilize the new maven-publish plugin and how to configure it, so that it fits
    into our own requirement.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了仓库。我们介绍了如何使用不同的仓库，例如平面文件、本地**Maven仓库**和托管在HTTPS服务器上的远程仓库。最后，我们讨论了项目的发布。通过使用不同的插件，你可以将工件发布到中央位置，如本地或远程**Maven仓库**。我们还讨论了如何利用新的maven-publish插件以及如何配置它，以便它符合我们的要求。
- en: In the next chapter, we will discuss few important plugins such as War and Scala.
    We'll also discuss other important concepts such as File management, Multi-Project,
    and Properties management.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些重要的插件，如War和Scala。我们还将讨论其他重要概念，例如文件管理、多项目和属性管理。
