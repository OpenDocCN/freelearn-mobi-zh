<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Interacting with Device Hardware</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Detecting the device orientation</li><li class="listitem" style="list-style-type: disc">Adjusting the UI orientation</li><li class="listitem" style="list-style-type: disc">The proximity sensor</li><li class="listitem" style="list-style-type: disc">Retrieving the battery information</li><li class="listitem" style="list-style-type: disc">Handling motion events</li><li class="listitem" style="list-style-type: disc">Handling touch events</li><li class="listitem" style="list-style-type: disc">Recognizing gestures</li><li class="listitem" style="list-style-type: disc">Custom gestures</li><li class="listitem" style="list-style-type: disc">Using the accelerometer</li><li class="listitem" style="list-style-type: disc">Using the gyroscope</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec74"/>Introduction</h1></div></div></div><p>Today's mobile devices are equipped with very advanced hardware, be it accelerometers to detect motion and orientation, proximity sensors, GPS modules and, among many other components, sophisticated multitouch screens.</p><p>In this chapter, we will focus on how to use this hardware within our apps to provide the user with an experience that extends into the 3D world. Specifically, we will discuss how to adjust the user interface orientation according to the position of the device, how to use the proximity sensor, and how to read the battery information. In a series of four tasks, we will learn how to capture user touches on the screen and recognize gestures.</p><p>Last but not least, we will create advanced apps that read the raw data from the accelerometer and gyroscope sensors to detect the device motion and rotation with detailed and simple guides.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec75"/>Detecting the device orientation</h1></div></div></div><p>In this recipe, we will learn how to make an app that is aware of changes in the device orientation.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec293"/>Getting ready</h2></div></div></div><p>Create a<a id="id520" class="indexterm"/> new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">DeviceOrientationApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec294"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the controller. </li><li class="listitem">In the <code class="literal">DeviceOrientationAppViewController</code> class, override the <code class="literal">ViewWillAppear</code> method and implement it with the following code:<div><pre class="programlisting">private NSObject orientationObserver;
public override void ViewWillAppear (bool animated)
{
  base.ViewWillAppear (animated);
  UIDevice.CurrentDevice.BeginGeneratingDeviceOrientationNotifications();
  this.orientationObserver = UIDevice.Notifications.ObserveOrientationDidChange((s, e) =&gt; {
    this.lblOrientation.Text = UIDevice.CurrentDevice.Orientation.ToString();
  });
}</pre></div></li><li class="listitem">Override the <code class="literal">ViewWillDisappear</code> method by using the following code:<div><pre class="programlisting">public override void ViewWillDisappear (bool animated)
{
  base.ViewWillDisappear (animated);
  NSNotificationCenter.DefaultCenter.RemoveObserver(this.orientationObserver);
    UIDevice.CurrentDevice.EndGeneratingDeviceOrientationNotifications();
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Rotate the simulator by holding the <em>Command</em> key on your Mac and by pressing the left or right arrow keys.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec295"/>How it works...</h2></div></div></div><p>Although the<a id="id521" class="indexterm"/> simulator lacks the accelerometer hardware, it supports notifications for orientation changes.</p><p>The device orientation notification mechanism can be accessed through the <code class="literal">UIDevice.CurrentDevice</code> static property. To receive notifications, we first need to instruct the runtime to issue them. We do this with the following method:</p><div><pre class="programlisting">UIDevice.CurrentDevice.BeginGeneratingDeviceOrientationNotifications();</pre></div><p>This method turns the accelerometer on and starts generating orientation notifications. We then need to start observing the notifications in order to respond to changes, as shown in the following code:</p><div><pre class="programlisting">this.orientationObserver = UIDevice.Notifications.ObserveOrientationDidChange((s, e) =&gt; {
  this.lblOrientation.Text = UIDevice.CurrentDevice.Orientation.ToString();
});</pre></div><p>Each time the device orientation changes, the observer triggers the anonymous method. In the anonymous method, we output the orientation, which we get from the <code class="literal">Orientation</code> property, to the label.</p><p>The <code class="literal">ViewWillDisappear</code> method is the method that is being called when the view controller is about to hide (for example, when we push another view controller on a navigation controller). Inside it, we make sure that we remove the orientation observer, and we instruct the runtime to stop generating orientation notifications by using the following code:</p><div><pre class="programlisting">NSNotificationCenter.DefaultCenter.RemoveObserver(this.orientationObserver);
UIDevice.CurrentDevice.EndGeneratingDeviceOrientationNotifications();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec296"/>There's more...</h2></div></div></div><p>The <code class="literal">Orientation</code> property of the <code class="literal">UIDevice</code> class returns an enumeration of the <code class="literal">UIDeviceOrientation</code> type. Its possible values are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Unknown</code>: This means that the device orientation is unknown</li><li class="listitem" style="list-style-type: disc"><code class="literal">Portrait</code>: This means that the device is in its normal portrait orientation, with the home button on the bottom side</li><li class="listitem" style="list-style-type: disc"><code class="literal">PortraitUpsideDown</code>: This means that the device is in an upside-down portrait orientation, with the home button on the top side</li><li class="listitem" style="list-style-type: disc"><code class="literal">LandscapeLeft</code>: This means that the device is in the landscape orientation, with the home button on the left side</li><li class="listitem" style="list-style-type: disc"><code class="literal">LandscapeRight</code>: This means that the device is in the landscape orientation, with the home button on the right side</li><li class="listitem" style="list-style-type: disc"><code class="literal">FaceUp</code>: This means that the device is parallel to the ground, with the screen facing up</li><li class="listitem" style="list-style-type: disc"><code class="literal">FaceDown</code>: This means that the device is parallel to the ground, with the screen facing down</li></ul></div><p>
<code class="literal">FaceUp</code> and <code class="literal">FaceDown</code> are two values that cannot be reproduced on the simulator.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec73"/>The device orientation and user interface orientation</h3></div></div></div><p>The user interface—in this case, the view controller—will also rotate and adjust to the new screen <a id="id522" class="indexterm"/>orientation by default. It is, however, important to note that the device orientation and the user interface orientation can be different. For example, the device can be in landscape, with <code class="literal">UIDevice.CurrentDevice.Orientation</code> returning <code class="literal">LandscapeLeft</code> without any change to the appearance of the view controller.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec297"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Adjusting the UI orientation</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Using the accelerometer</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec76"/>Adjusting the UI orientation</h1></div></div></div><p>In this<a id="id523" class="indexterm"/> chapter, we will learn how to rotate the user interface according to the screen orientation.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec298"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">UIOrientationApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec299"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the view the controller.</li><li class="listitem">Override the <code class="literal">ShouldAutoRotate</code> method:<div><pre class="programlisting">public override bool ShouldAutorotate ()
{
  return true;
}</pre></div></li><li class="listitem">Override the <code class="literal">GetSupportedInterfaceOrientations</code> method:<div><pre class="programlisting">public override UIInterfaceOrientationMask GetSupportedInterfaceOrientations ()
{
  return UIInterfaceOrientationMask.All;
}</pre></div></li><li class="listitem">Override the <code class="literal">DidRotate</code> method:<div><pre class="programlisting">public override void DidRotate (UIInterfaceOrientation fromInterfaceOrientation)
{
  base.DidRotate (fromInterfaceOrientation);
  this.lblOrientation.Text = this.InterfaceOrientation.ToString();
}</pre></div></li><li class="listitem">Compile <a id="id524" class="indexterm"/>and run the app on the simulator. Rotate the simulator by pressing the <em>Command</em> key and either the left or right arrow keys. The current user interface orientation will be shown on the simulator's screen.<p>Try rotating the simulator twice to turn the portrait orientation upside down. You will notice that the user interface will not rotate to this orientation and will remain on the landscape, as shown in the following screenshot:</p><div><img src="img/8924OT_09_01.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec300"/>How it works...</h2></div></div></div><p>On every view <a id="id525" class="indexterm"/>controller that is loaded, the system calls the <code class="literal">ShouldAutoRotate</code> method to determine whether it should rotate the specific controller. If the method returns <code class="literal">true</code>, then the system calls the <code class="literal">GetSupportedInterfaceOrientations</code> method to determine which orientations the controller is allowed to be rotated to. The <code class="literal">GetSupportedInterfaceOrientations</code> method implementation is shown in the following code:</p><div><pre class="programlisting">public override UIInterfaceOrientationMask GetSupportedInterfaceOrientations ()
{
  return UIInterfaceOrientationMask.All;
}</pre></div><p>However, there is an app-wide setting in the <code class="literal">Info.plist</code> file that takes priority over orientations<a id="id526" class="indexterm"/> for all view controllers. This can be accessed through the project options under the <strong>iOS Application</strong> node. The default setting is shown in the following screenshot:</p><div><img src="img/8924OT_09_02.jpg" alt="How it works..."/></div><p>This also explains why our user interface will not rotate when the device is turned upside down, despite the fact that we return <code class="literal">UIInterfaceOrientationMask.All</code> from the <code class="literal">GetSupportedInterfaceOrientations</code> method. To make the view controller support the <code class="literal">PortraitUpsideDown</code> orientation, we have to enable the <strong>Upside Down</strong> option through the orientation settings.</p><p>Similarly, if we wanted our user interface to only remain in a specific orientation, say, a portrait, we would just return <code class="literal">UIInterfaceOrientationMask.Portrait</code> from the <code class="literal">GetSupportedInterfaceOrientations</code> method, making sure that at least the <strong>Portrait</strong> orientation is enabled in the project settings.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec301"/>There's more...</h2></div></div></div><p>As long as the app supports an orientation, the view controller will adjust to it at the runtime, if we want it to. For example, if we would present a second view controller modally and we only want that view controller to be shown in the landscape orientations, we would implement its <code class="literal">GetSupportedInterfaceOrientations</code> method as shown in the following code:</p><div><pre class="programlisting">public override UIInterfaceOrientationMask GetSupportedInterfaceOrientations() {
  return UIInterfaceOrientationMask.LandscapeLeft | UIInterfaceOrientationMask.LandscapeRight;
}</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec74"/>User interface orientation on child controllers</h3></div></div></div><p>In the project that we created here, if the <code class="literal">UIOrientationAppViewController</code> was presented as a child view controller (for example, through <code class="literal">UINavigationController</code>), its <code class="literal">ShouldAutoRotate</code> and <code class="literal">GetSupportedInterfaceOrientations</code> methods would not have <a id="id527" class="indexterm"/>been called but the ones from <code class="literal">UINavigationController</code> would have been called instead, returning the corresponding default values.</p><p>In this situation, to make sure the user interface would rotate according to the current controller, we would have to subclass <code class="literal">UINavigationController</code> and override these two methods, returning the corresponding values from the currently active view controller in the navigation stack, as shown in the following code:</p><div><pre class="programlisting">// Inside our UINavigationController subclass:
public override ShouldAutoRotate() {
  return this.TopViewController.ShouldAutoRotate();
}
public override UIInterfaceOrientationMask GetSupportedInterfaceOrientations() {
  return this.TopViewController.GetSupportedInterfaceOrientations();
}</pre></div><p>This applies to any parent-child controller relationship, for example, if our parent controller was <code class="literal">UITabBarController</code> and so on.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec302"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Detecting the device orientation</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Using the accelerometer</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Navigating through different view controllers</em> recipe in <a class="link" href="ch03.html" title="Chapter 3. User Interface – View Controllers">Chapter 3</a>, <em>User Interface – View Controllers</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec77"/>Proximity sensor</h1></div></div></div><p>In this recipe, we <a id="id528" class="indexterm"/>will discuss how to use the proximity sensor to disable the device screen.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec303"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">ProximitySensorApp</code>.</p><div><div><h3 class="title"><a id="note49"/>Note</h3><p>The simulator does not support the proximity sensor.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec304"/>How to do it...</h2></div></div></div><p>Perform the<a id="id529" class="indexterm"/> following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">For this project, no controls are needed on the view controller. Declare an <code class="literal">NSObject</code> field that will hold the notification observer by using the following command:<div><pre class="programlisting">private NSObject proximityObserver;</pre></div></li><li class="listitem">Override the <code class="literal">ViewWillAppear</code> method of the controller and implement it according to the following code:<div><pre class="programlisting">public override void ViewWillAppear (bool animated)
{
  base.ViewWillAppear (animated);
  UIDevice.CurrentDevice.ProximityMonitoringEnabled = true;
  if (UIDevice.CurrentDevice.ProximityMonitoringEnabled)
  {
    this.proximityObserver = UIDevice.Notifications.ObserveProximityStateDidChange((s, e) =&gt; {
      Console.WriteLine("Proximity state: {0}", UIDevice.CurrentDevice.ProximityState);
    });
  }
}</pre></div></li><li class="listitem">Compile and run the app on the device. Put your finger over the proximity sensor (it is next to the speaker on an iPhone), and watch the <strong>Application Output</strong> pad in Xamarin Studio display the sensor state.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec305"/>How it works...</h2></div></div></div><p>Although the functionality of the proximity sensor is quite simple, it provides a very important feature. iOS devices have only one button on the front, which is the home button. Almost every user-device interaction is based on the touch-sensitive screen. This poses a problem on the iPhone; apart from its multiple features, it is also a phone. This means that it will most likely spend some time on the side of the user's face to make calls.</p><p>To avoid accidental virtual buttons being tapped, the proximity sensor gets activated when the phone app is running in order to disable the screen when the device is near the user's ear or whatever is over the sensor.</p><p>To enable the proximity sensor, set the property of the <code class="literal">UIDevice.CurrentDevice.ProximityMonitoringEnabled</code> property to <code class="literal">true</code>:</p><div><pre class="programlisting">UIDevice.CurrentDevice.ProximityMonitoringEnabled = true;</pre></div><p>If the device does not support the proximity sensor, this property will return <code class="literal">false</code> even after it has<a id="id530" class="indexterm"/> been set to <code class="literal">true</code>. So after setting it to <code class="literal">true</code>, we can check it to see whether the device supports the sensor by using the following code:</p><div><pre class="programlisting">if (UIDevice.CurrentDevice.ProximityMonitoringEnabled)</pre></div><p>After checking the support for a proximity sensor, we can add an observer to get notified of the sensor's state by using the following code:</p><div><pre class="programlisting">this.proximityObserver = UIDevice.Notifications.ObserveProximityStateDidChange((s, e) =&gt; {
  Console.WriteLine("Proximity state: {0}", UIDevice.CurrentDevice.ProximityState);
});</pre></div><p>The <code class="literal">ProximityState</code> property returns <code class="literal">true</code> if the sensor has turned the screen off and <code class="literal">false</code> if it has turned it back on.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec306"/>There's more...</h2></div></div></div><p>The proximity sensor usage is not limited to the phone call functionality. For example, if you are developing an app that could do some work while the device is in the user's pocket or purse, enabling the proximity sensor would help you make sure that no accidental controls are tapped. You can even save the battery power by just turning the screen off.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec307"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Retrieving the battery information</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec78"/>Retrieving the battery information</h1></div></div></div><p>In this recipe, we <a id="id531" class="indexterm"/>will learn how to read the charging states of the device and its battery usage.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec308"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">BatteryInfoApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec309"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the view of the controller.</li><li class="listitem">Override the <code class="literal">ViewWillAppear</code> method in the controller class as follows:<div><pre class="programlisting">private NSObject batteryStateChangeObserver;
public override void ViewWillAppear (bool animated)
{
  base.ViewWillAppear (animated);
  UIDevice.CurrentDevice.BatteryMonitoringEnabled = true;
<strong>  this.batteryStateChangeObserver = UIDevice.Notifications.ObserveBatteryStateDidChange((s, e) =&gt; {</strong>
<strong>    this.lblOutput.Text = string.Format("Battery level: {0}", UIDevice.CurrentDevice.BatteryLevel);</strong>
<strong>    Console.WriteLine("Battery state: {0}", UIDevice.CurrentDevice.BatteryState);</strong>
<strong>  });</strong>
}</pre></div></li><li class="listitem">Compile and <a id="id532" class="indexterm"/>run the app on the device. After the app loads, disconnect and/or connect the USB cable of the device. The battery level will be displayed on the label and the current state will be displayed in the <strong>Application Output</strong> pad.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec310"/>How it works...</h2></div></div></div><p>We can retrieve the battery information through the <code class="literal">UIDevice</code> class. The first thing we have to do is to enable the battery monitoring:</p><div><pre class="programlisting">UIDevice.CurrentDevice.BatteryMonitoringEnabled = true;</pre></div><p>On the simulator, which does not support battery monitoring, this property will return <code class="literal">false</code> even after we have set it to <code class="literal">true</code>.</p><p>We can then add an observer for the battery state change notifications, through the <code class="literal">UIDevice.BatteryStateDidChangeNotification</code> key, as indicated in the highlighted code in the preceding section. The battery level can be retrieved through the <code class="literal">BatteryLevel</code> property, which returns the charge percentage of the battery in the range of <code class="literal">0</code> through <code class="literal">1</code> (<code class="literal">0</code> meaning fully discharged and <code class="literal">1</code> meaning 100 percent charged) by using the following code:</p><div><pre class="programlisting">this.lblOutput.Text = string.Format("Battery level: {0}", UIDevice.CurrentDevice.BatteryLevel);</pre></div><p>Similarly, we can retrieve the state of the battery through the <code class="literal">BatteryState</code> property by using the following code:</p><div><pre class="programlisting">Console.WriteLine("Battery state: {0}", UIDevice.CurrentDevice.BatteryState);</pre></div><p>The possible values of the <code class="literal">BatteryState</code> property are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Unknown</code>: This means that the battery state cannot be determined or the battery monitoring is disabled</li><li class="listitem" style="list-style-type: disc"><code class="literal">Unplugged</code>: This means that the device is running on the battery power</li><li class="listitem" style="list-style-type: disc"><code class="literal">Charging</code>: This means that the device battery is getting charged, and the USB cable is connected</li><li class="listitem" style="list-style-type: disc"><code class="literal">Full</code>: This means that the device battery is full and the USB cable is connected</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec311"/>There's more...</h2></div></div></div><p>Apart from<a id="id533" class="indexterm"/> the battery state, we can get information on its power level. To do this, we need to add an observer for the <code class="literal">UIDevice.BatteryLevelDidChangeNotification</code> key, as shown in the following code:</p><div><pre class="programlisting">private NSObject batteryLevelChangedObserver;
//...
this.batteryLevelChangedObserver = UIDevice.Notifications.ObserveBatteryLevelDidChange((s, e) =&gt; {..//</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec75"/>Disabling battery monitoring</h3></div></div></div><p>Always <a id="id534" class="indexterm"/>disable battery monitoring when not needed. The actual monitoring mechanism itself consumes a significant amount of battery power.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec312"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Proximity sensor</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec79"/>Handling motion events</h1></div></div></div><p>In this<a id="id535" class="indexterm"/> recipe, we will learn how to intercept and respond to shake gestures.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec313"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">MotionEventsApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec314"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the view of the controller.</li><li class="listitem">Enter the following code in the <code class="literal">MotionEventsAppViewController</code> class:<div><pre class="programlisting">public override bool CanBecomeFirstResponder
{
  get {  return true; }
}
public override void ViewDidAppear (bool animated)
{
  base.ViewDidAppear (animated);
  this.BecomeFirstResponder();
}
public override void MotionBegan (UIEventSubtype motion, UIEvent evt)
{
  base.MotionBegan (motion, evt);
  this.lblOutput.Text = "Motion started!";
}
public override void MotionEnded (UIEventSubtype motion, UIEvent evt)
{
  base.MotionEnded (motion, evt);
  this.lblOutput.Text = "Motion ended!";
}
public override void MotionCancelled (UIEventSubtype motion, UIEvent evt)
{
  base.MotionCancelled (motion, evt);
  this.lblOutput.Text = "Motion cancelled!";
}</pre></div></li><li class="listitem">Compile <a id="id536" class="indexterm"/>and run the app on the device. Shake the device and watch the output on the label.</li></ol></div><div><div><h3 class="title"><a id="note50"/>Note</h3><p>You can also test this app on the simulator. After it loads, navigate to <strong>Hardware</strong> | <strong>Shake Gesture</strong> on the menu bar.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec315"/>How it works...</h2></div></div></div><p>By overriding the motion methods of the <code class="literal">UIViewController</code> class, we can intercept and respond to the motion events sent by the system. Just overriding these methods is not enough, though. For a controller to receive the motion events, it needs to be the first responder. To make sure that this happens, we first override the <code class="literal">CanBecomeFirstResponder</code> property and return <code class="literal">true</code> from it, as shown in the following code:</p><div><pre class="programlisting">public override bool CanBecomeFirstResponder
{
  get {  return true; }
}</pre></div><p>Then, we <a id="id537" class="indexterm"/>make sure that our controller becomes the first responder when its view appears, by calling the <code class="literal">BecomeFirstResponder</code> method in the <code class="literal">ViewDidAppear</code> override, as shown in the following code:</p><div><pre class="programlisting">public override void ViewDidAppear (bool animated)
{
  base.ViewDidAppear (animated);
  this.BecomeFirstResponder();
}</pre></div><p>The <code class="literal">ViewDidAppear</code> method gets called after the view has appeared on the screen.</p><p>The system determines whether a motion is a shake gesture and calls the appropriate methods. The methods with which we can override and capture shake gestures are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">MotionBegan</code>: This<a id="id538" class="indexterm"/> means that the shaking motion has started</li><li class="listitem" style="list-style-type: disc"><code class="literal">MotionEnded</code>: This <a id="id539" class="indexterm"/>means that the shaking motion has ended</li><li class="listitem" style="list-style-type: disc"><code class="literal">MotionCancelled</code>: This<a id="id540" class="indexterm"/> means that the shaking motion has been cancelled</li></ul></div><p>When the device starts moving, the <code class="literal">MotionBegan</code> method is called. If the motion lasts for about a second or less, the <code class="literal">MotionEnded</code> method is called. If it lasts longer, the system classifies it as not being a shake gesture and calls the <code class="literal">MotionCancelled</code> method. It is advisable to override all the three methods and react accordingly when we want to implement the shake gestures in an app.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec316"/>There's more...</h2></div></div></div><p>Motion events are only sent to objects that inherit the <code class="literal">UIResponder</code> class. This includes the <code class="literal">UIView</code> and <code class="literal">UIViewController</code> classes.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec76"/>More information on motion events</h3></div></div></div><p>The motion event <a id="id541" class="indexterm"/>mechanism is fairly simple. It merely detects near-instant device shakes, without providing any information on their direction or rate. To handle the motion events based on different characteristics, the accelerometer can be used in <a id="id542" class="indexterm"/>combination.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec317"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using the accelerometer</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec80"/>Handling touch events</h1></div></div></div><p>In this recipe, we will learn how to intercept and respond to user touches.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec318"/>Getting ready</h2></div></div></div><p>Create a <a id="id543" class="indexterm"/>new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">TouchEventsApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec319"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the view the controller.</li><li class="listitem">Enter the following code in the <code class="literal">TouchEventsAppViewController</code> class:<div><pre class="programlisting">public override void TouchesMoved (NSSet touches, UIEvent evt)
{
  base.TouchesMoved (touches, evt);
  UITouch touch = touches.AnyObject as UITouch;
  UIColor currentColor = this.View.BackgroundColor;
  float red, green, blue, alpha;
  currentColor.GetRGBA(out red, out green, out blue, out alpha);
  PointF previousLocation = touch.PreviousLocationInView(this.View);
  PointF touchLocation = touch.LocationInView(this.View);
  if (previousLocation.X != touchLocation.X)
  {
    this.lblOutput.Text = "Changing background color...";
    float colorValue = touchLocation.X / this.View.Bounds.Width;
    this.View.BackgroundColor = UIColor.FromRGB(colorValue, colorValue, colorValue);
  }
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click-and-drag  the cursor sideways on the simulator's screen and watch the view's background color gradually change from white to black. Note that clicking  with the cursor on the simulator screen is the equivalent of touching the device's screen with a finger.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec320"/>How it works...</h2></div></div></div><p>To respond to user touches, the object that acts as a touch receiver must have its <code class="literal">UserInteractionEnabled</code> property set to <code class="literal">true</code>. Almost all objects are enabled for user interaction by <a id="id544" class="indexterm"/>default, except for those whose primary usage is not intended for direct user interaction, for example the <code class="literal">UILabel</code> and the <code class="literal">UIImageView</code> object. We need to set <code class="literal">UserInteractionEnabled</code> to these objects explicitly if we want them to be sensitive to user touches. Apart from this, the objects that can handle touch events must inherit from the <code class="literal">UIResponder</code> class. Note that although the <code class="literal">UIViewController</code> class inherits from <code class="literal">UIResponder</code> and can therefore capture touch events, it does not have a <code class="literal">UserInteractionEnabled</code> property, and it is its main property of <code class="literal">UIView</code>, which controls the delivery of touch events. What this means is that if you override the touch methods of <code class="literal">UIViewController</code> but its view's <code class="literal">UserInteractionEnabled</code> property is set to <code class="literal">false</code>, these methods will not respond to user touches.</p><p>The methods responsible of handling the touch events are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesBegan</code>: <a id="id545" class="indexterm"/>It is called when the user has touched the screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesMoved</code>: <a id="id546" class="indexterm"/>It is called when the user is dragging his/her finger on the screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesEnded</code>: <a id="id547" class="indexterm"/>It is called when the user has lifted his/her finger from the screen</li><li class="listitem" style="list-style-type: disc"><code class="literal">TouchesCancelled</code>: It is called when the touch event has been cancelled by a system <a id="id548" class="indexterm"/>event, for example, when a notification alert is displayed</li></ul></div><p>The full project can be found in the downloadable source code. The <code class="literal">TouchesMoved</code> method implementation has been explained here.</p><p>Every touch method has two parameters. The first parameter is of the <code class="literal">NSSet</code> type and contains the <code class="literal">UITouch</code> objects. The <code class="literal">NSSet</code> class represents a collection of objects, while the <code class="literal">UITouch</code> class holds the information for each user touch. The second parameter is of the <code class="literal">UIEvent</code> type and holds the information of the actual event.</p><p>We can retrieve the <code class="literal">UITouch</code> object related to the actual touch through the <code class="literal">NSSet.AnyObject</code> return value by using the following code:</p><div><pre class="programlisting">UITouch touch = touches.AnyObject as UITouch;</pre></div><p>It returns an object of the <code class="literal">NSObject</code> type, which we convert to <code class="literal">UITouch</code>. We can get the previous and current locations of the touch through the following methods:</p><div><pre class="programlisting">PointF previousLocation = touch.PreviousLocationInView(this.View);
PointF touchLocation = touch.LocationInView(this.View);</pre></div><p>Both of the preceding methods return a <code class="literal">PointF</code> struct, which contains the location of the touch in the receiver's coordinate system. After receiving the location of the touch, we adjust the background color accordingly.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec321"/>There's more...</h2></div></div></div><p>This <a id="id549" class="indexterm"/>example is based on single user touches. To enable a view to respond to multiple touches, we have to set its <code class="literal">MultipleTouchEnabled</code> property to <code class="literal">true</code>. We can then get all the <code class="literal">UITouch</code> objects in an array:</p><div><pre class="programlisting">UITouch[] allTouches = touches.ToArray&lt;UITouch&gt;();</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec77"/>Getting the tap count</h3></div></div></div><p>We <a id="id550" class="indexterm"/>can determine the number of consecutive user taps through the <code class="literal">UITouch.TapCount</code> property inside the <code class="literal">ToucheEnded</code> method.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec322"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Handling motion events</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Recognizing gestures</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Custom gestures</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec81"/>Recognizing gestures</h1></div></div></div><p>In this recipe, we <a id="id551" class="indexterm"/>will discuss how to recognize touch gestures and respond accordingly.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec323"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">GestureApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec324"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the view of the controller.</li><li class="listitem">Add the following method in the <code class="literal">GestureAppViewController</code> class:<div><pre class="programlisting">private void OnPinchGesture(UIPinchGestureRecognizer pinch)
{
  switch (pinch.State)
  {
  case UIGestureRecognizerState.Began:
    this.lblOutput.Text = "Pinch began!";
    break;
  case UIGestureRecognizerState.Changed:
    this.lblOutput.Text = "Pinch changed!";
    break;
  case UIGestureRecognizerState.Ended:
    this.lblOutput.Text = "Pinch ended!";
    break;
  }
}</pre></div></li><li class="listitem">Add the<a id="id552" class="indexterm"/> following code in the <code class="literal">ViewDidLoad</code> method:<div><pre class="programlisting">UIPinchGestureRecognizer pinchGesture = new UIPinchGestureRecognizer(this.OnPinchGesture);
this.View.AddGestureRecognizer(pinchGesture);</pre></div></li><li class="listitem">Compile and run the app on the simulator. Hold down the <em>option</em> key and click-and-drag the mouse to perform the equivalent of a pinch on the simulator screen.<p>Holding down the Option key and dragging with the mouse cursor on the simulator is the equivalent of touching a device's screen with two fingers, as shown in the following screenshot:</p><div><img src="img/8924OT_09_03.jpg" alt="How to do it..."/></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec325"/>How it works...</h2></div></div></div><p>As <a id="id553" class="indexterm"/>the iOS Version 3.2 was released along with the iPad, Apple introduced the <code class="literal">UIGestureRecognizer</code> class and its derivatives. The gesture recognizers make use of the multitouch screens on iOS devices. Gestures are basically touch combinations that can be performed for specific actions.</p><p>For example, pinching on a fullscreen image in the native <em>Photos</em> app will zoom out. The action of pinching is the gesture that the user performs, while the gesture recognizer is responsible for recognizing and delivering the gesture event to its receiver.</p><p>In this <a id="id554" class="indexterm"/>example, we create a <code class="literal">UIPinchGestureRecognizer</code> instance, which will recognize the pinches performed on the screen. Its instance is created with the following code:</p><div><pre class="programlisting">UIPinchGestureRecognizer pinchGesture = new UIPinchGestureRecognizer(this.OnPinchGesture);</pre></div><p>The constructor that initializes the instance takes one parameter, which is of the <code class="literal">Action&lt;UIPinchGestureRecognizer&gt;</code> type and represents the method that will be called when the recognizer receives a gesture.</p><p>Inside the method, we read the <code class="literal">State</code> property of the gesture recognizer object and respond accordingly, as shown in the following code:</p><div><pre class="programlisting">switch (pinch.State) { 
//…</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec326"/>There's more...</h2></div></div></div><p>The state of each gesture recognizer is represented by an enumeration of the <code class="literal">UIGestureRecognizerState</code> type. Its possible values are shown as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Possible</code>: This indicates that the gesture has not been recognized yet. This is the default value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Began</code>: This indicates that the gesture has started.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Changed</code>: This indicates that the gesture has changed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Ended</code>: This indicates that the gesture has ended.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Cancelled</code>: This indicates that the gesture has been canceled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Failed</code>: This indicates that the gesture cannot be recognized.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Recognized</code>: This indicates that the gesture has been recognized.</li></ul></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec78"/>The advantage of gesture recognizers</h3></div></div></div><p>The advantage<a id="id555" class="indexterm"/> of gesture recognizers is that they save developers the time to create their own gesture recognition mechanisms through the touch events. Furthermore, they are based on the gestures that users are accustomed to using on iOS devices.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec327"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Handling touch events</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Custom gestures</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec82"/>Custom gestures</h1></div></div></div><p>In this recipe, we will learn how to create a custom gesture recognizer to create our own gesture <a id="id556" class="indexterm"/>response mechanism.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec328"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">CustomGestureApp</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec329"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a label to the view of the controller.</li><li class="listitem">Create the following nested class in the <code class="literal">CustomGestureAppViewController</code> class:<div><pre class="programlisting">private class DragLowerLeftGesture : UIGestureRecognizer
{
  private PointF startLocation;
  private RectangleF lowerLeftCornerRect;
  public override UIGestureRecognizerState State
  {
    get
    {
      return base.State;
    }  set
    {
      base.State = value;
    }
  }
  public override void TouchesBegan (NSSet touches, UIEvent evt)
  {
    base.TouchesBegan (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    this.startLocation = touch.LocationInView(this.View);
    RectangleF viewBounds = this.View.Bounds;
    this.lowerLeftCornerRect = new RectangleF(0f, viewBounds.Height - 50f, 50f, 50f);
    if (this.lowerLeftCornerRect.Contains(this.startLocation))
    {
      this.State = UIGestureRecognizerState.Failed;
    }  else
    {
      this.State = UIGestureRecognizerState.Began;
    }
  }
  public override void TouchesMoved (NSSet touches, UIEvent evt)
  {
    base.TouchesMoved (touches, evt);
    this.State = UIGestureRecognizerState.Changed;
  }
  public override void TouchesEnded (NSSet touches, UIEvent evt)
  {
    base.TouchesEnded (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    PointF touchLocation = touch.LocationInView(this.View);
    if (this.lowerLeftCornerRect.Contains(touchLocation))
    {
      this.State = UIGestureRecognizerState.Ended;
    }  else
    {
      this.State = UIGestureRecognizerState.Failed;
    }
  }
}</pre></div></li><li class="listitem">Add the<a id="id557" class="indexterm"/> following method to the class:<div><pre class="programlisting">private void OnDragLowerLeft(NSObject gesture)
{
  DragLowerLeftGesture drag = (DragLowerLeftGesture)gesture;
  switch (drag.State)
  {
  case UIGestureRecognizerState.Began:
    this.lblOutput.Text = "Drag began!";
    break;
  case UIGestureRecognizerState.Changed:
    this.lblOutput.Text = "Drag changed!";
    break;
  case UIGestureRecognizerState.Ended:
    this.lblOutput.Text = "Drag ended!";
    break;
  case UIGestureRecognizerState.Failed:
    this.lblOutput.Text = "Drag failed!";
    break;
  }
}</pre></div></li><li class="listitem">Initialize and add the gesture recognizer in the <code class="literal">ViewDidLoad</code> method as shown in the following code:<div><pre class="programlisting">DragLowerLeftGesture dragGesture = new DragLowerLeftGesture();
dragGesture.AddTarget(this.OnDragLowerLeft);
this.View.AddGestureRecognizer(dragGesture);</pre></div></li><li class="listitem">Compile and run the app on the simulator. Click-and-drag on the simulator's screen towards the lower-left corner.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec330"/>How it works...</h2></div></div></div><p>To create a<a id="id558" class="indexterm"/> gesture recognizer, we need to declare a class that inherits from the <code class="literal">UIGestureRecognizer</code> class. In this example, we are creating a gesture that will be recognized by dragging the finger on the screen towards a 50 x 50 point area in the lower-left corner of the screen. The following line of code shows the class declaration:</p><div><pre class="programlisting">private class DragLowerLeftGesture : UIGestureRecognizer</pre></div><p>The <code class="literal">UIGestureRecognizer</code> class contains the same touch methods that we use to intercept touches in views. We also have access to the view it was added to through its <code class="literal">View</code> property. Inside the <code class="literal">TouchesBegan</code> method, we determine the initial touch location. If it is outside the lower-left portion of the view, we set the <code class="literal">State</code> property to <code class="literal">Began</code>. If it is inside the lower-left portion, we set the <code class="literal">State</code> property to <code class="literal">Failed</code> so that the callback will not be called.</p><p>Inside the <code class="literal">TouchesEnded</code> method, we consider the gesture as <code class="literal">Ended</code> if the touch's location was inside the lower-left portion of the view. If it was not, the gesture recognition is considered as <code class="literal">Failed</code>.</p><p>The <code class="literal">TouchesMoved</code> method is where the <code class="literal">Changed</code> state will be set. For this simple gesture recognizer that we are creating, no other logic is needed.</p><p>As the <code class="literal">UIGestureRecognizer</code> class does not have a constructor that accepts an <code class="literal">Action&lt;T&gt;</code> object for the gesture handler, we initialize it with the default constructor and use the <code class="literal">AddTarget</code> method for this purpose by using the following code:</p><div><pre class="programlisting">dragGesture.AddTarget(this.OnDragLowerLeft);</pre></div><p>The only difference in this case is that the parameter is of the <code class="literal">Action&lt;NSObject&gt;</code> type, which we can cast to our own custom type, as shown in the following line of code:</p><div><pre class="programlisting">DragLowerLeftGesture drag = (DragLowerLeftGesture)gesture;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec331"/>There's more...</h2></div></div></div><p>This is a simple gesture recognizer that depends on a single touch. With the information provided <a id="id559" class="indexterm"/>in the touch methods, we can create more complex gestures that will support multiple touches.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec79"/>Another use of custom gesture recognizers</h3></div></div></div><p>There are some views that inherit from the <code class="literal">UIView</code> class, which, according to the Apple developer<a id="id560" class="indexterm"/> documentation, should not be subclassed. The <code class="literal">MKMapView</code> class represents one of these views that is used to display the maps. This poses a problem if we want to intercept the touch events from these views. Although we could use another view over it and intercept that view's touch events, it is quite complex (and error prone) to do so. A more simple approach is to create a simple custom gesture recognizer and add it to the view that we cannot subclass. This way, we can intercept its touches without having to subclass it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec332"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Recognizing gestures</em> recipe</li><li class="listitem" style="list-style-type: disc">The <em>Handling touch events</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec83"/>Using the accelerometer</h1></div></div></div><p>In this recipe, we will learn how to receive the accelerometer events to create an app that is aware of the<a id="id561" class="indexterm"/> device movement.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec333"/>Getting ready</h2></div></div></div><p>Create a new <strong>Single View Application</strong> in Xamarin Studio and name it <code class="literal">AccelerometerApp</code>.</p><div><div><h3 class="title"><a id="note51"/>Note</h3><p>The simulator does not support the accelerometer hardware. The project in this example will work correctly on a device.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec334"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two buttons and a label on the view of the controller.</li><li class="listitem">In the <code class="literal">ViewDidLoad</code> method, add the following code:<div><pre class="programlisting">this.btnStop.Enabled = false;
UIAccelerometer.SharedAccelerometer.UpdateInterval = 1 / 
  10;
this.btnStart.TouchUpInside += delegate {
  this.btnStart.Enabled = false;
  UIAccelerometer.SharedAccelerometer.Acceleration += this.Acceleration_Received;
  this.btnStop.Enabled = true;
} ;
this.btnStop.TouchUpInside += delegate {
  this.btnStop.Enabled = false;
  UIAccelerometer.SharedAccelerometer.Acceleration -= this.Acceleration_Received;
  this.btnStart.Enabled = true;
} ;</pre></div></li><li class="listitem">Add the following method in the class:<div><pre class="programlisting">private void Acceleration_Received (object sender, UIAccelerometerEventArgs e)
{
  this.lblOutput.Text = string.Format("X: {0}\nY: {1}\nZ: {2}", e.Acceleration.X, e.Acceleration.Y, e.Acceleration.Z);
}</pre></div></li><li class="listitem">Compile<a id="id562" class="indexterm"/> and run the app on the device. Tap the <strong>Start accelerometer</strong> button and watch the values get displayed on the label while moving or shaking the device.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec335"/>How it works...</h2></div></div></div><p>The <code class="literal">UIAccelerometer</code> class provides access to the accelerometer hardware through its <code class="literal">SharedAccelerometer</code> static property. To activate it, all we need to do is to assign a handler to its <code class="literal">Acceleration</code> event by using the following code:</p><div><pre class="programlisting">UIAccelerometer.SharedAccelerometer.Acceleration += this.Acceleration_Received;</pre></div><p>Inside the handler, we receive the accelerometer values through the <code class="literal">UIAccelerometerEventArgs.Acceleration</code> property. The property returns an object of the <code class="literal">UIAcceleration</code> type, which contains the accelerometer amount in three properties: <code class="literal">X</code>, <code class="literal">Y</code>, and <code class="literal">Z</code>. These properties represent the motion in the <em>x</em>-, <em>y</em>-, and <em>z</em>-axis. Consider the following screenshot:</p><div><img src="img/8924OT_09_04.jpg" alt="How it works..."/></div><p>Each of these values measure the amount of G-force by which the device moved on each axis. For example, if <code class="literal">X</code> has a value of <code class="literal">1</code>, the device is moving on the <em>x</em> axis to the right with an <a id="id563" class="indexterm"/>acceleration of 1G. If <code class="literal">X</code> has a value of <code class="literal">-1</code>, the device is moving on the <em>x</em> axis to the left with an acceleration of 1G. When the device is placed on a table with its back facing the floor and is not moving, the normal values of the acceleration should be close or equal to the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">X</code>: <code class="literal">0</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Y</code>: <code class="literal">0</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Z</code>: <code class="literal">-1</code></li></ul></div><p>Although the device is not moving, Z will be <code class="literal">-1</code> because the device measures the earth's gravity.</p><p>We can set the interval by which the accelerometer will issue the acceleration events, by setting its <code class="literal">UpdateInterval</code> property by using the following code:</p><div><pre class="programlisting">UIAccelerometer.SharedAccelerometer.UpdateInterval = 1 / 10;</pre></div><p>The property accepts a number of type <code class="literal">double</code>, which represents the interval by which the accelerometer will issue its acceleration events in seconds. Care must be taken when setting the update interval because the more events the accelerometer has to issue for a specific period of time, the more battery power it consumes.</p><p>To stop using the accelerometer, all we need to do is unhook the handler from the <code class="literal">Acceleration</code> event by using the following code:</p><div><pre class="programlisting">UIAccelerometer.SharedAccelerometer.Acceleration -= this.Acceleration_Received;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec336"/>There's more...</h2></div></div></div><p>The <code class="literal">UIAcceleration</code> class contains another useful property, named <code class="literal">Time</code>. It is a <code class="literal">double</code> that <a id="id564" class="indexterm"/>represents the relative time on which the acceleration event occurred. It is relative to the CPU time, and it is not suggested that you use this value to calculate the exact timestamp of the event.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec80"/>Consideration when using the accelerometer</h3></div></div></div><p>Although the iPhone's accelerometer is a very accurate and sensitive sensor, it should not be used for <a id="id565" class="indexterm"/>precise measurements. Also, the results it produces may vary among different iOS devices, even if they're of the same model.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec337"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using the gyroscope</em> recipe</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec84"/>Using the gyroscope</h1></div></div></div><p>In this recipe, we will learn how to use the device's built-in gyroscope.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec338"/>Getting ready</h2></div></div></div><p>Create a <a id="id566" class="indexterm"/>new project in Xamarin Studio and name it <code class="literal">GyroscopeApp</code>.</p><div><div><h3 class="title"><a id="note52"/>Note</h3><p>The simulator does not support the gyroscope hardware. Also, only newer devices contain a gyroscope. If this app is executed on a device without a gyroscope or on the simulator, no error will occur but no data will be displayed.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec339"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add two buttons and a label to the view the controller.</li><li class="listitem">Add the <code class="literal">MonoTouch.CoreMotion</code> namespace in the <code class="literal">GyroscopeAppViewController.cs</code> file.</li><li class="listitem">Enter the following private field in the class:<div><pre class="programlisting">private CMMotionManager motionManager;</pre></div></li><li class="listitem">Implement the <code class="literal">ViewDidLoad</code> method with the following code:<div><pre class="programlisting">this.motionManager = new CMMotionManager();
this.motionManager.GyroUpdateInterval = 1 / 10;
this.btnStart.TouchUpInside += delegate {
  this.motionManager.StartGyroUpdates(NSOperationQueue.MainQueue, this.GyroData_Received);
} ;
this.btnStop.TouchUpInside += delegate {
  this.motionManager.StopGyroUpdates();
} ;</pre></div><p>Add the following method:</p><div><pre class="programlisting">private void GyroData_Received(CMGyroData gyroData, NSError error)
{
  Console.WriteLine("rotation rate x: {0}, y: {1}, z: {2}", gyroData.RotationRate.x, gyroData.RotationRate.y, gyroData.RotationRate.z);
}</pre></div></li><li class="listitem">Compile <a id="id567" class="indexterm"/>and run the app on the device. Tap the <strong>Start gyroscope</strong> button and rotate the device in all axes. Watch the values get displayed in the <strong>Application Output</strong> pad.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec340"/>How it works...</h2></div></div></div><p>The gyroscope is a mechanism that measures orientation. Newer iOS devices support the gyroscope hardware, along with the accelerometer, to give even more accurate measurements of the device motion.</p><p>The <code class="literal">MonoTouch.CoreMotion</code> namespace wraps the objects contained in the native CoreMotion framework. The process of using the gyroscope hardware in code is similar to the one used for the accelerometer. The first difference is that there is no single object for the gyroscope in the <code class="literal">UIApplication</code> class. So, we need to create an instance of the <code class="literal">CMMotionManager</code> class as shown in the following code:</p><div><pre class="programlisting">private CMMotionManager motionManager;
//...
   this.motionManager = new CMMotionManager();</pre></div><p>Just like how we use the accelerometer, we can set the interval by which we will receive the gyroscope events in seconds by using the following code:</p><div><pre class="programlisting">this.motionManager.GyroUpdateInterval = 1 / 10;</pre></div><p>To start receiving the gyroscope events, we call the object's <code class="literal">StartGyroUpdates</code> method as shown in the following code:</p><div><pre class="programlisting">this.motionManager.StartGyroUpdates(NSOperationQueue.MainQueue, this.GyroData_Received);</pre></div><p>This method is overloaded; the first overload is parameterless and when called, the values of the gyroscopic measurements are set to the <code class="literal">GyroData</code> property. Using this overload is quite simple and easy, but no events are triggered here, and we have to provide a mechanism<a id="id568" class="indexterm"/> to read the measurements from the property.</p><p>The second overload, which is used in this example, accepts two parameters. The first parameter is the <code class="literal">NSOperationQueue</code> parameter on which the updates will occur, and the second parameter is the handler that will be executed when an update occurs.</p><p>The <code class="literal">NSOperationQueue</code> class represents an iOS mechanism to manage the <code class="literal">NSOperation</code> objects' execution. We access the runtime's main operation queue through the static <code class="literal">NSOperationQueue.MainQueue</code> property. Basically, this way, we instruct the runtime to manage the delivery of the handler in a more effective manner.</p><p>The second parameter is a delegate of the <code class="literal">CMGyroHandler</code> type. Its signature, represented by the method we created, is similar to the following code:</p><div><pre class="programlisting">private void GyroData_Received(CMGyroData gyroData, NSError error)</pre></div><p>The <code class="literal">CMGyroData</code> object contains the actual measurement values received from the gyroscope through its <code class="literal">RotationRate</code> property. The following code outputs the data from the property:</p><div><pre class="programlisting">Console.WriteLine("rotation rate x: {0}, y: {1}, z: {2}", gyroData.RotationRate.x, gyroData.RotationRate.y, gyroData.RotationRate.z);</pre></div><p>The rotation rate is reflected on the <em>x</em>, <em>y</em>, and <em>z</em> axis, represented by the corresponding <code class="literal">X</code>, <code class="literal">Y</code>, and <code class="literal">Z</code> properties. Each value is the amount of the rotation angle per second, which occurred on that axis, in radians.</p><p>Although it might seem a bit complicated at first, it is actually quite simple. For example, a value of 0.5 in the <em>z</em> axis means that the device rotated with a rate of 0.5 radians/sec to the left. A value of -0.5 in the <em>z</em>-axis means that the device rotated with a rate of 0.5 radians/sec to the right. The pattern to determine the rotation direction is based on the right-hand rule.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec341"/>There's more...</h2></div></div></div><p>If you want your app to be available only for devices that support the gyroscope, add the <code class="literal">UIRequiredDeviceCapabilities</code> key in your project's <code class="literal">Info.plist</code> file with the <code class="literal">gyroscope</code> value. If your app's functionality is based fully on the gyroscope, adding this key must be considered essential to avoid the app being downloaded by users with older devices, ending up with an app that does not work.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec81"/>Determining the availability of the gyroscope hardware</h3></div></div></div><p>To determine<a id="id569" class="indexterm"/> whether the device the app is running on supports the gyroscope hardware, check the value of the <code class="literal">GyroAvailable</code> property of the <code class="literal">CMMotionManager</code> instance.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec82"/>Converting radians to degrees</h3></div></div></div><p>A radian<a id="id570" class="indexterm"/> is an angle measurement unit. To convert an <a id="id571" class="indexterm"/>angle measurement from radians to degrees, consider the following helper method:</p><div><pre class="programlisting">public static double RadiansToDegrees (double radians)
{
  return (radians * 180 / Math.PI);
}</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec342"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <em>Using the accelerometer</em> recipe</li></ul></div></div></div></body></html>