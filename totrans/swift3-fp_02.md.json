["```swift\naccessControl func functionName(parameter: ParameterType) throws\n  -> ReturnType { }\n```", "```swift\nfuncName(firstParam: \"some String\", secondParam: \"some String\")\n\n```", "```swift\nlet someClassInstance = SomeClass()\nlet paramName = \"parameter name\"\nlet secondParamName = \"second Parameter\"\nsomeClassInstance.funcName(firstParam: paramName, secondParam:\n  secondParamName)\n\n```", "```swift\nfunc functionName() { } \n\n```", "```swift\nfunc functionName(firstParameter: ParameterType, secondParameter:\n    ParameterType) {\n    // function body\n}\n\n// To call:\nfunctionName(firstParameter: paramName, secondParameter: secondParamName)\n\n```", "```swift\nfunc functionName(parameter: ParameterType?, secondParameter: \n  ParameterType?) { }\n```", "```swift\nFunc functionName(externalParamName localParamName: ParameterType) \n// To call: \nfunctionName(externalParamName: parameter) \n\n```", "```swift\nfunc functionName(parameter: Int = 3) {\n    print(\"\\(parameter) is provided.\")\n}\n\nfunctionName(parameter: 5) // prints \"5 is provided.\"\nfunctionName() // prints \"3 is provided.\"\n\n```", "```swift\nfunc functionWithTupleParam(tupleParam: (Int, Int)) {} \n\n```", "```swift\nlet numbers = [3, 5, 9, 10]\n\nfunc convert(numbers: [Int], multiplier: Int) -> [String] {\n    let convertedValues = numbers.enumerated().map { (index, element) in\n        return \"\\(index): \\(element * multiplier)\"\n    }\n    return convertedValues\n}\n\n```", "```swift\nlet parameters = (numbers: numbers, multiplier: 3)\nconvert(parameters)\n\n```", "```swift\nfunc functionWithFunctionParam(funcParam: (Int, Int)-> Int) \n\n```", "```swift\nfunc functionWithGenerics<T, V>(firstParam: T, secondParam) \n\n```", "```swift\nfunc greet(names: String...) {\n    for name in names {\n        print(\"Greetings, \\(name)\")\n    }\n}\n\n// To call this function\ngreet(names: \"Steve\", \"Craig\") // prints twice\ngreet(names: \"Steve\", \"Craig\", \"Johny\") // prints three times\n\n```", "```swift\nfunc functionName() -> String { } \n\n```", "```swift\nfunc functionName() -> String? { } \n\n```", "```swift\nfunc functionName() -> (code: Int, status: String) { } \n\n```", "```swift\nfunc functionName() -> (code: Int, status: String)? { } \n\n```", "```swift\nfunc functionName() -> (code: Int, status: String?) { } \n\n```", "```swift\nfunc funcName() -> (Int, Int)-> Int {} \n\n```", "```swift\nfunc functionName() { } \n\n```", "```swift\nfunc functionName() -> Void { } \n\n```", "```swift\ny = f(x) or f(x) -> y \n\n```", "```swift\nfunc functionName(firstParam: Int, secondParam: Double) -> String \n\n```", "```swift\nvar simpleMathOperator: (Double, Double) -> Double \n\n```", "```swift\ntypealias SimpleOperator = (Double, Double) -> Double \n\n```", "```swift\nvar simpleMathOperator: SimpleOperator \n\n```", "```swift\nfunc addTwoNumbers(a: Double, b: Double) -> Double { return a + b } \n\nfunc subtractTwoNumbers(a: Double, b: Double) -> Double { return a - b } \n\nfunc divideTwoNumbers(a: Double, b: Double) -> Double { return a / b } \n\nfunc multiplyTwoNumbers(a: Double, b: Double) -> Double { return a * b } \n\n```", "```swift\nsimpleMathOperator = multiplyTwoNumbers \n\n```", "```swift\nlet result = simpleMathOperator(3.0, 4.0) // result is 12\n\n```", "```swift\nsimpleMathOperator = addTwoNumbers \nlet result = simpleMathOperator(3.5, 5.5) // result is 9 \n\n```", "```swift\nfunc calculateResult(mathOperator: SimpleOperator, a: Double, b: Double)\n  -> Double {\n    return mathOperator(a, b)\n}\n\nprint(\"The result is \\(calculateResult(mathOperator: simpleMathOperator,\n  a: 3.5, b: 5.5))\") // prints \"The result is 9.0\"\n```", "```swift\nfunc choosePlusMinus(isPlus: Bool) -> SimpleOperator {\n    return isPlus ? addTwoNumbers : subtractTwoNumbers\n}\n\nlet chosenOperator = choosePlusMinus(isPlus: true)\nprint(\"The result is \\(chosenOperator(3.5, 5.5))\") // prints \"The result\n  is 9.0\"\n```", "```swift\nfunc addTwoNumbers(a: Double, b: Double) -> Double { return a + b } \n\n```", "```swift\nfunc choosePlusMinus(isPlus: Bool) -> (Int, Int) -> Int {\n    func plus(a: Int, b: Int) -> Int {\n        return a + b\n    }\n    func minus(a: Int, b: Int) -> Int {\n        return a - b\n    }\n    return isPlus ? plus : minus\n}\n\n```", "```swift\nlet name: String = \"Your name\"\n\n```", "```swift\nfunc sayHello(name: String)\n\n```", "```swift\nsayHello(name: \"Your name\") // or\nsayHello(name: name)\n\n```", "```swift\nvar sayHelloFunc = sayHello\n\n```", "```swift\nfunc subtractTwoValues(a: Int, b: Int) -> Int {\n    return a - b\n}\n\nfunc addTwoValues(a: Int, b: Int) -> Int {\n    return a + b\n}\n\n```", "```swift\nfunc square(a: Int) -> Int {\n    return a * a\n}\n\nfunc triple(a: Int) -> Int {\n    return a * a * a // or return squareAValue(a) * a\n}\n\n```", "```swift\nfunc subtractTwoSquaredValues(a: Int, b: Int) -> Int {\n    return (a * a) - (b * b)\n}\n\n```", "```swift\nfunc addTwoSquaredValues(a: Int, b: Int) -> Int {\n    return (a * a) + (b * b)\n}\n\n```", "```swift\nfunc multiplyTwoTripledValues(a: Int, b: Int) -> Int {\n    return (a * a * a) * (b * b * b)\n}\n\n```", "```swift\ntypealias AddSubtractOperator = (Int, Int) -> Int\ntypealias SquareTripleOperator = (Int) -> Int\nfunc calcualte(a: Int, b: Int, funcA: AddSubtractOperator, funcB:\n  SquareTripleOperator) -> Int {\n    return funcA(funcB(a), funcB(b))\n}\n\n```", "```swift\nprint(\"The result of adding two squared values is: \\(calcualte(a: 2, b: 2,\n  funcA: addTwoValues, funcB: square))\") // prints \"The result of adding\n  two squared value is: 8\"\n\nprint(\"The result of subtracting two tripled value is: \\(calcualte(a: 3,\n  b: 2, funcA: subtractTwoValues, funcB: triple))\") // prints \"The result\n  of adding two tripled value is: 19\"\n```", "```swift\n\"10,20,40,30,80,60\" \n\n```", "```swift\nlet content = \"10,20,40,30,80,60\"\n\nfunc extractElements(_ content: String) -> [String] {\n    return content.characters.split(separator: \",\").map { String($0) }\n}\n\nlet elements = extractElements(content)\n\nfunc formatWithCurrency(content: [String]) -> [String] {\n    return content.map {\"\\($0)$\"}\n}\n\nlet formattedElements = formatWithCurrency(content: elements)\n\n```", "```swift\nextractElements: String -> [String] | formatWithCurrency: [String] \n  -> [String]\n```", "```swift\nlet composedFunction = { data in\n    formatWithCurrency(content: extractElements(data))\n}\n\ncomposedFunction(content)\n\n```", "```swift\noperatorType operator operatorName { } \n\n```", "```swift\ninfix operator operatorName { associativity left/right/none \n  precedence}\n```", "```swift\ninfix operator |> { associativity left }\nfunc |> <T, V>(f: T -> V, g: V -> V ) -> T -> V {\n    return { x in g(f(x)) }\n}\n\nlet composedWithCustomOperator = extractElements |> formatWithCurrency\ncomposedWithCustomOperator(\"10,20,40,30,80,60\")\n\n```", "```swift\n{ (parameters) -> ReturnType in\n    // body of closure\n}\n\n```", "```swift\nlet closureName: (Int) -> (Int) = {/* */ }\n\n```", "```swift\nvar closureName: (Int) -> (Int)?\n\n```", "```swift\ntypealias closureType = (Int, Int) -> (Int)\n\n```", "```swift\nfunc aFunc(closure: (Int) -> Int) -> Int {\n    // Statements, for example:\n    return closure(5)\n}\n\nlet result = aFunc(closure: { number in\n    // Statements, for example:\n    return number * 3\n})\n\nprint(result)\n\n```", "```swift\nvar anArray = [1, 2, 5, 3, 6, 4]\n\nanArray.sort(isOrderedBefore: { (param1: Int, param2: Int) -> Bool in\n    return param1 < param2\n})\n\n```", "```swift\nanArray.sort(isOrderedBefore: { (param1, param2) -> Bool in\n    return param1 < param2\n})\n\n```", "```swift\nanArray.sort(isOrderedBefore: { (param1, param2) in\n    return param1 < param2\n})\n\n```", "```swift\nanArray.sort { (param1, param2) in\n    return param1 < param2\n}\n\n```", "```swift\nanArray.sort {\n    return $0 < $1\n}\n\n```", "```swift\nanArray.sort {  0 < $1 }\n\n```", "```swift\nfunc sendRequest(responseType: String.Type, completion:\n  (responseData:String, error:NSError?) -> Void) {\n    // execute some time consuming operation, if successful {\n        completion(responseData: \"Response\", error: nil)\n    //}\n}\n\nsendRequest(String.self) {\n    (response: String?, error: NSError?) in\n    if let result = response {\n        print(result)\n    } else if let serverError = error {\n        // Error\n    }\n}\n\n```", "```swift\ncompletion(responseData: \"Response\", error: nil)\n\n```", "```swift\nfunc extractFullUserName(firstName: String, lastName: String) -> String {\n    return \"\\(firstName) \\(lastName)\"\n}\n\n```", "```swift\nfunc curriedExtractFullUserName(firstName: String)(lastName:\n  String) -> String {\n    return \"\\(firstName) \\(lastName)\"\n}\n\n```", "```swift\nlet fnIncludingFirstName = curriedExtractFullUserName(\"John\")\nlet extractedFullName = fnIncludingFirstName(lastName: \"Doe\")\n\n```", "```swift\n// Before:\nfunc curried(x: Int)(y: String) -> Float {\n    return Float(x) + Float(y)!\n}\n\n// Swift 3.0 syntax:\nfunc curried(x: Int) -> (String) -> Float {\n    return {(y: String) -> Float in\n        return Float(x) + Float(y)!\n    }\n}\n\n```", "```swift\nfunc explicityRetunClosure(firstName: String) -> (String) -> String {\n    return { (lastName: String) -> String in\n        return \"\\(firstName) \\(lastName)\"\n    }\n}\n\n```", "```swift\nlet fnIncludingFirstName = explicityRetunClosure(firstName: \"John\")\nlet extractedFullName = fnIncludingFirstName(\"Doe\")\n```", "```swift\nn! = n * (n - 1)!\n\n```", "```swift\n0! = 1! = 1\n\n```", "```swift\nfunc factorial(n: Int) -> Int {\n    return n * factorial(n: n - 1)\n}\n\n```", "```swift\nfunc factorial(n: Int) -> Int {\n    return n == 0 || n == 1 ? 1 : n * factorial(n: n - 1)\n}\n\nprint(factorial(n: 3))\n\n```", "```swift\nfunc powerOfTwo(n: Int) -> Int {\n    return n == 0 ? 1 : 2 * powerOfTwo(n: n - 1)\n}\n\nlet fnResult = powerOfTwo(n: 3)\n\n```", "```swift\nfunc power2(n: Int) -> Int {\n    var y = 1\n    for _ in 0...n - 1 {\n        y *= 2\n    }\n    return y\n}\n\nlet result = power2(n: 4)\n\n```", "```swift\nfunc repateString(str: String, n: Int) -> String {\n    return n == 0 ? \"\" : str + repateString(str: str , n: n - 1)\n}\n\nprint(repateString(str: \"Hello\", n: 4))\n\n```", "```swift\nfunc repeatString(str: String, n: Int) -> String {\n    var ourString = \"\"\n    for _ in 1...n {\n        ourString += str\n    }\n    return ourString\n}\n\nprint(repeatString(str: \"Hello\", n: 4))\n\n```", "```swift\nfunc factorial(n: Int, currentFactorial: Int = 1) -> Int {\n    return n == 0 ? currentFactorial : factorial(n: n - 1,\n      currentFactorial: currentFactorial * n)\n}\n\nprint(factorial(n: 3))\n\n```", "```swift\nfactorial(n: 3, currentFactorial: 1)\nreturn factorial(n: 2, currentFactorial: 1 * 3) // n = 3\nreturn factorial(n: 1, currentFactorial: 3 * 2) // n = 2\nreturn 6 // n = 1\n\n```", "```swift\nvar memo = Dictionary<Int, Int>()\n\nfunc memoizedPower2(n: Int) -> Int {\n    if let memoizedResult = memo[n] {\n        return memoizedResult\n    }\n    var y = 1\n    for _ in 0...n-1 {\n        y *= 2\n    }\n    memo[n] = y\n    return y\n}\nprint(memoizedPower2(n: 2))\nprint(memoizedPower2(n: 3))\nprint(memoizedPower2(n: 4))\nprint(memo) // result: [2: 4, 3: 8, 4: 16]\n\n```", "```swift\nfunc memoize<T: Hashable, U>(fn: ((T) -> U, T) -> U) -> (T) -> U {\n    var memo = Dictionary<T, U>()\n    var result: ((T) -> U)!\n    result = { x in\n        if let q = memo[x] { return q }\n        let r = fn(result, x)\n        memo[x] = r\n        return r\n    }\n    return result\n}\n\n```", "```swift\n((T) -> U, T) -> U\n\n```", "```swift\nlet factorial = memoize { factorial, x in\n    x == 0 ? 1 : x * factorial(x - 1)\n}\n\nprint(factorial(5))\n\n```", "```swift\nlet powerOf2 = memoize { pow2, x in\n    x == 0 ? 1 : 2 * pow2(x - 1)\n}\n\nprint(powerOf2(5))\n\n```"]