<html><head></head><body>
        

                            
                    <h1 class="header-title">Ranges, Progressions, and Sequences</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Exploring the use of range expressions to iterate through alphabet characters</li>
<li>Traversing through ranges using progression with a custom step value</li>
<li>Building custom progressions to traverse dates</li>
<li>Using range expressions with flow control statements</li>
<li>Discovering the concept of sequences</li>
<li>Applying sequences to solve algorithmic problems</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>This chapter will focus on explaining the advantages of <strong>range expressions</strong> and <strong>sequences</strong>. These powerful data structure concepts offered by the Kotlin standard library can help you to improve the quality and readability of your code, as well as its safety and performance. Range expressions provide a declarative way of iterating through sets of comparable types using <kbd>for</kbd> loops. They are also useful for implementing concise and safe control flow statements and conditions. The <kbd>Sequence</kbd> class, as a missing supplement to the <kbd>Collection</kbd> type, provides a built-in lazy evaluation of its elements. In many cases, using sequences can help optimize data-processing operations and make the code more efficient in terms of computation complexity and memory consumption. The recipes covered in this chapter are going to focus on solving real-life programming problems. Moreover, at the same time, they are also going to explain how those concepts work under the hood.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Exploring the use of range expressions to iterate through alphabet characters</h1>
                
            
            
                
<p>Ranges, provided by the Kotlin standard library, are a powerful solution for implementing iteration and conditional statements in a natural and safe way. A range can be understood as an abstract data type that represents a set of iterable elements and allows iteration through them in a declarative way. The <kbd>ClosedRange</kbd> interface from the <kbd>kotlin.ranges</kbd> package is a basic model of the range data structure. It contains references to the first and last elements of the range and provides the <kbd>contains(value: T): Boolean</kbd> and <kbd>isEmpty(): Boolean</kbd> functions, which are responsible for checking whether the specified element belongs to the range and whether the range is empty. In this recipe, we are going to learn how to declare a range that consists of alphabet characters and iterate through it in a decreasing order.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The Kotlin standard library provides functions that allow the declaration of ranges for the integral, primitive types, such as <kbd>Int</kbd>, <kbd>Long</kbd>, and <kbd>Char</kbd>. To define a new range instance, we can use the <kbd>rangeTo()</kbd> function. For example, we can declare a range of integers from <kbd>0</kbd> to <kbd>1000</kbd> in the following way:</p>
<pre>val range: IntRange = 0.rangeTo(1000)</pre>
<p>The <kbd>rangeTo()</kbd> function has also its own special operator equivalent, <kbd>..</kbd>, which allows the declaration of a range with a more natural syntax:</p>
<pre>val range: IntRange = 0..1000</pre>
<p>Also, in order to declare a range of elements in a decreasing order, we can use the <kbd>downTo()</kbd> function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a decreasing range of alphabet characters:</li>
</ol>
<pre style="padding-left: 60px">'Z' downTo 'A'</pre>
<p>                2. Create a <kbd>for</kbd> loop to traverse the range:</p>
<pre style="padding-left: 60px">for (letter in 'Z' downTo 'A') print(letter)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As a result, we are going to get the following code printed out to the console:</p>
<pre><strong>ZYXWVUTSRQPONMLKJIHGFEDCBA</strong></pre>
<p>As you can see, there is also a <kbd>downTo()</kbd> extension function variant for the <kbd>Char</kbd> type. We are using it to create a range of characters from <kbd>Z</kbd><em> </em>to <kbd>A</kbd>. Note that, thanks for the infix notation, we can omit the brackets while invoking the function—<kbd>'Z' downTo 'A'</kbd>.</p>
<p>Next, we are creating a <kbd>for</kbd> loop, which iterates through the range and prints out the subsequent <kbd>Char</kbd> elements. Using the <kbd>in</kbd> operator, we are specifying the object that is being iterated in the loop—and that's it! As you can see, the Kotlin syntax for the <kbd>for</kbd> loop is neat and natural to use.</p>
<p>Implementations of ranges of the primitive types, such as <kbd>IntRange</kbd>, <kbd>LongRange</kbd>, and <kbd>CharRange</kbd>, also contain <kbd>Iterator</kbd> interface implementations under the hood. They are being used while traversing the range using the <kbd>for</kbd> loop under the hood. In fact, the range implementing the <kbd>Iterable</kbd> interface is called a <strong>progression</strong>. Under the hood, the <kbd>IntRange</kbd>, <kbd>LongRange</kbd>, and <kbd>CharRange</kbd> classes inherit from the <kbd>IntProgression</kbd>, <kbd>LongProgression</kbd>, and <kbd>CharProgression</kbd> base classes, and they provide the implementations of the <kbd>Iterator</kbd> interface internally.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There is also a convenient way to reverse the order of an already-defined progression. We can do so with the extension function provided for the <kbd>IntProgression</kbd>, <kbd>LongProgression</kbd>, and <kbd>CharProgression</kbd> types, which is called <kbd>reversed()</kbd>. It returns new instances of progressions with a reversed order of elements. Here is an example of how to use the <kbd>reversed()</kbd> function:</p>
<pre>val daysOfYear: IntRange = 1..365<br/>for(day in daysOfYear.reversed()) {<br/>    println("Remaining days: $day")<br/>}</pre>
<p>The preceding <kbd>for</kbd> loop prints the following text to the console:</p>
<pre><strong>Remaining days: 365<br/>Remaining days: 364<br/>Remaining days: 363<br/>…</strong><br/><strong>Remaining days: 2<br/>Remaining days: 1</strong></pre>
<p>The Kotlin standard library offers also another handy extension function called <kbd>until()</kbd>, which allows the declaration of ranges that don't include the last element. It is pretty useful when working with classes that contain internal collections and don't provide elegant interfaces to access them. A good example would be the Android <kbd>ViewGroup</kbd> class, which is a container for the child <kbd>View</kbd> type objects. The following example presents how to iterate through the next indexes of any given <kbd>ViewGroup</kbd> instance children in order to modify the state of each of the children:</p>
<pre>val container: ViewGroup = activity.findViewById(R.id.container) as ViewGroup<br/>(0 until container.childCount).forEach {<br/>    val child: View = container.getChildAt(it)<br/>    child.visibility = View.INVISIBLE<br/>}</pre>
<p>The <kbd>until()</kbd> infix function helps to make the loop conditions clean and natural to understand.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>This recipe gave us an insight into how Kotlin standard library implementations of ranges for primitives are easy to work with. A problem can appear if we want to traverse non-primitive types using the <kbd>for</kbd> loop. However, it turns out we can easily declare a range for any <kbd>Comparable</kbd> type. This will be shown in the <em>Building custom progressions to traverse dates</em> recipe.</li>
</ul>
<ul>
<li>As you have noticed, we are using the <kbd>in</kbd> operator to specify the object that is being iterated in the loop. However, there are also other scenarios where the <kbd>in</kbd> and <kbd>!in</kbd> operators can be used together with ranges. We will investigate them in depth in the <em>Using range expressions with flow control statements</em> recipe.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Traversing through ranges using progression with a custom step value</h1>
                
            
            
                
<p>Besides doing so for the <kbd>Iterator</kbd> instances, progressions implementations for integral types, such as the <kbd>Int</kbd>, <kbd>Long</kbd>, and <kbd>Char</kbd> types, also include the <kbd>step</kbd> property. The <kbd>step</kbd> value specifies the intervals between the subsequent elements of a range. By default, the <kbd>step</kbd> value of a progression is equal to <kbd>1</kbd>. In this recipe, we are going to learn how to traverse a range of alphabet characters with a <kbd>step</kbd> value equal to <kbd>2</kbd>. In the result, we want to have every second alphabet letter printed to the console.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The Kotlin standard library provides a convenient way of creating progression with a custom <kbd>step</kbd> value. We can do so using an extension function for progressions of integral types called <kbd>step()</kbd>. We can also benefit from the infix notation and declare a progression with a custom <kbd>step</kbd>, as follows:</p>
<pre>val progression: IntProgression = 0..1000 step 100</pre>
<p>If we were to use <kbd>progression</kbd> in the <kbd>for</kbd> loop, it would iterate 10 times:</p>
<pre>val progression: IntProgression = 0..1000 step 100<br/>for (i in progression) {<br/>    println(i)<br/>}</pre>
<p>We could also achieve the same result by iterating with the <kbd>while</kbd> loop, as follows:</p>
<pre>var i = 0<br/>while (i &lt;= 1000) {<br/>    println(i)<br/>    i += 100<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a range of the <kbd>Char</kbd> type using the <kbd>downTo()</kbd><em> </em>function:</li>
</ol>
<pre style="padding-left: 60px">'z' downTo 'a'</pre>
<ol start="2">
<li>Convert the range to a progression with a custom <kbd>step</kbd> value using the <kbd>step()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">'z' downTo 'a' <strong>step 2</strong></pre>
<ol start="3">
<li>Use the <kbd>forEach()</kbd><em> </em>function to iterate through the elements of the progression and print each of them to the console:</li>
</ol>
<pre style="padding-left: 60px">('z' downTo 'a' step 2)<strong>.forEach { character -&gt; print(character) }</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the result, we are going to get the following code printed to the console:</p>
<pre><strong>zxvtrpnljhfdb</strong></pre>
<p>In the beginning, we declared a range containing all the alphabet characters in decreasing order with the <kbd>downTo()</kbd><em> </em>function. Then, we transformed the range a the custom progression containing every second character with the <kbd>step()</kbd> function. Finally, we are using the <kbd>Iterable.forEach()</kbd><em> </em>function to iterate through the next elements of the progression and print each of them to the console.</p>
<p>The <kbd>step()</kbd> extension function is available for the <kbd>IntProgression</kbd>, <kbd>LongProgression</kbd>, and <kbd>CharProgression</kbd> types. Under the hood, it creates a new instance of a progression copying the properties of the original one and setting up the new <kbd>step</kbd> value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Apart from iteration, range expressions are useful for defining flow control conditions. You can read more about this in the <em>Using range expressions with flow control statements</em> recipe.</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Building custom progressions to traverse dates</h1>
                
            
            
                
<p>Kotlin provides built-in support for ranges of primitive types. In the previous recipes, we worked with the <kbd>IntRange</kbd> and <kbd>CharRange</kbd> types, which are included in the Kotlin standard library. However, it is possible to implement a custom progression for any type by implementing the <kbd>Comparable</kbd> interface. In this recipe, we will learn how to create a progression of the <kbd>LocalDate</kbd> type and discover how to traverse the dates the easy way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In order to accomplish the task, we need to start by getting familiar with the <kbd>ClosedRange</kbd> and <kbd>Iterator</kbd> interfaces. We need to use them to declare a custom progression for the <kbd>LocalDate</kbd> class:</p>
<pre>public interface ClosedRange&lt;T: Comparable&lt;T&gt;&gt; {<br/>    public val start: T<br/>    public val endInclusive: T<br/>    public operator fun contains(value: T): Boolean {<br/>        return value &gt;= start &amp;&amp; value &lt;= endInclusive<br/>    }                                      <br/>    public fun isEmpty(): Boolean = start &gt; endInclusive<br/>}</pre>
<p>The <kbd>Iterator</kbd> interface provides information about the subsequent values and their availability:</p>
<pre>public interface Iterator&lt;out T&gt; {<br/>    public operator fun next(): T<br/>    public operator fun hasNext(): Boolean<br/>}</pre>
<p>The <kbd>ClosedRange</kbd> interface provides the minimum and maximum values of the range. It also provides the <kbd>contains(value: T): Boolean</kbd> and <kbd>isEmpty(): Boolean</kbd> functions, which check whether a given value belongs to the range and whether the range is empty respectively. Those two functions have default implementations provided in the <kbd>ClosedRange</kbd> interface. As the result, we don't need to override them in our custom implementation of the <kbd>ClosedRange</kbd> interface.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's start with implementing the <kbd>Iterator</kbd> interface for the <kbd>LocalDate</kbd> type. We are going to create a custom <kbd>LocalDateIterator</kbd> class, which implements the <kbd>Iterator&lt;LocalDate&gt;</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">class DateIterator(startDate: LocalDate,<br/>                   val endDateInclusive: LocalDate,<br/>                   val stepDays: Long) : Iterator&lt;LocalDate&gt; {<br/>    private var currentDate = startDate<br/>    override fun hasNext() = currentDate &lt;= endDateInclusive<br/>    override fun next(): LocalDate {<br/>        val next = currentDate<br/>        currentDate = currentDate.plusDays(stepDays)<br/>        return next<br/>    }<br/>}</pre>
<ol start="2">
<li>Now, we can implement the progression for the <kbd>LocalDate</kbd> type. Let's create a new class called <kbd>DateProgression</kbd>, which is going to implement the <kbd>Iterable&lt;LocalDate&gt;</kbd> and <kbd>ClosedRange&lt;LocalDate&gt;</kbd> interfaces:</li>
</ol>
<pre style="padding-left: 60px">class DateProgression(override val start: LocalDate,<br/>                      override val endInclusive: LocalDate,<br/>                      val stepDays: Long = 1) : <br/>                                                Iterable&lt;LocalDate&gt;, <br/>                                                ClosedRange&lt;LocalDate&gt; {<br/>    override fun iterator(): Iterator&lt;LocalDate&gt; {<br/>        return DateIterator(start, endInclusive, stepDays)<br/>    } <br/><br/>    infix fun step(days: Long) = DateProgression(start, endInclusive, days)<br/>}</pre>
<ol start="3">
<li>Finally, declare a custom <kbd>rangeTo</kbd> operator for the <kbd>LocalDate</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">operator fun LocalDate.rangeTo(other: LocalDate) = DateProgression(this, other)</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<div><p>Now, we are able to declare range expressions for the <kbd>LocalDate</kbd> type. Let's see how to use our implementation. In the following example, we will use our custom <kbd>LocalDate.rangeTo</kbd> operator implementation in order to create a range of dates and iterate its elements:</p>
<pre>val startDate = LocalDate.of(2020, 1, 1)<br/>val endDate = LocalDate.of(2020, 12, 31)<br/>for (date in startDate..endDate step 7) {<br/>    println("${date.dayOfWeek} $date ")<br/>}</pre>
<p>As a result, we are going to have the dates printed out to the console with a week-long interval:</p>
<pre><strong>WEDNESDAY 2020-01-01<br/>WEDNESDAY 2020-01-08<br/>WEDNESDAY 2020-01-15<br/>WEDNESDAY 2020-01-22<br/>WEDNESDAY 2020-01-29<br/>WEDNESDAY 2020-02-05<br/>...</strong><br/><strong>WEDNESDAY 2020-12-16<br/>WEDNESDAY 2020-12-23<br/>WEDNESDAY 2020-12-30</strong></pre></div>
<p class="CDPAlignLeft CDPAlign">The <kbd>DateIterator</kbd> class holds three properties—<kbd>currentDate: LocalDate</kbd>, <kbd>endDateInclusive: LocalDate</kbd>, and <kbd>stepDays: Long</kbd>. In the beginning, the <kbd>currentDate</kbd> property is initialized with the <kbd>startDate</kbd> value passed in the constructor. Inside the <kbd>next()</kbd> function, we are returning the <kbd>currentDate</kbd> value and updating it to the next date value using a given <kbd>stepDays</kbd> property interval.</p>
<p>The <kbd>DateProgression</kbd> class combines the functionalities of the <kbd>Iterable&lt;LocalDate&gt;</kbd> and <kbd>ClosedRange&lt;LocalDate&gt;</kbd> interfaces. It provides the <kbd>Iterator</kbd> object required by the <kbd>Iterable</kbd> interface by returning the <kbd>DateIterator</kbd> instance. It also overrides the <kbd>start</kbd> and <kbd>endInclusive</kbd> properties of the <kbd>ClosedRange</kbd> interface. There is also the <kbd>stepDays</kbd> property with a default value equal to <kbd>1</kbd>. Note that every time the <kbd>step</kbd> function is called, a new instance of the <kbd>DateProgression</kbd> class is being created.</p>
<p>You can follow the same pattern to implement custom progressions for any class that implements the <kbd>Comparable</kbd> interface.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using range expressions with flow control statements</h1>
                
            
            
                
<p>Apart from iterations, Kotlin range expressions can be useful when it comes to working with flow control statements. In this recipe, we are going to learn how to use range expressions together with <kbd>if</kbd> and <kbd>when</kbd> statements in order to tune up the code and make it safe. In this recipe, we are going to consider an example of using the <kbd>in</kbd> operator to define a condition of an <kbd>if</kbd> statement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Kotlin range expressions—represented by the <kbd>ClosedRange</kbd> interface—implement a <kbd>contains(value: T): Boolean</kbd> function, which returns an information if a given parameter belongs to the range. This feature makes it convenient to use ranges together with control flow instructions. The <kbd>contains()</kbd> function has also its equivalent operator, <kbd>in</kbd>, and its negation, <kbd>!in</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's create a variable and assign to it a random integer value:</li>
</ol>
<pre style="padding-left: 60px">val randomInt = Random().nextInt()</pre>
<ol start="2">
<li>Now we can check whether the <kbd>randomInt</kbd> value belongs to the scope of integers from <kbd>0</kbd> to <kbd>10</kbd> inclusive using range expressions:</li>
</ol>
<pre style="padding-left: 60px">if (randomInt in 0..10) {<br/>    print("$randomInt belongs to &lt;0, 10&gt; range")<br/>} else {<br/>    print("$randomInt doesn't belong to &lt;0, 10&gt; range")<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We have used a range expression together with the <kbd>in</kbd> operator in order to define a condition for the <kbd>if</kbd> statement. The condition statement is natural to read and concise. In contrast, an equivalent classic implementation would look like this:</p>
<pre>val randomInt = Random(20).nextInt()<br/>if (randomInt &gt;= 0 &amp;&amp; randomInt &lt;= 10) {<br/>    print("$randomInt belongs to &lt;0, 10&gt; range")<br/>} else {<br/>    print("$randomInt doesn't belong to &lt;0, 10&gt; range")<br/>}</pre>
<p>No doubt, the declarative approach using the range and <kbd>in</kbd> operator is cleaner and easier to read, compared to classic, imperative-style condition statements.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Range expressions can enhance use of the <kbd>when</kbd> expression as well. In the following example, we are going to implement a simple function that will be responsible for mapping a student's exam score to a corresponding grade. Let's say we have the following enum class model for student grades:</p>
<pre>enum class Grade { A, B, C, D }</pre>
<p>We can define a function that will map the exam score value, in the <kbd>0</kbd> to <kbd>100</kbd> % range, to the proper grade (<kbd>A</kbd>, <kbd>B</kbd>, <kbd>C</kbd>, or <kbd>D</kbd>) using a <kbd>when</kbd> expression, as follows:</p>
<pre>fun computeGrade(score: Int): Grade =<br/>        when (score) {<br/>            in 90..100 -&gt; Grade.A<br/>            in 75 until 90 -&gt; Grade.B<br/>            in 60 until 75 -&gt; Grade.C<br/>            in 0 until 60 -&gt; Grade.D<br/>            else -&gt; throw IllegalStateException("Wrong score value!")<br/>        }</pre>
<p>Using ranges together with the <kbd>in</kbd> operator makes the implementation of the <kbd>computeGrade()</kbd> function much cleaner and more natural than the classic equivalent implementation using traditional comparison operators, such as <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>&lt;=</kbd>, and <kbd>&gt;=</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>If you'd like to discover more about lambdas, the infix notation, and operator overloading, go ahead and dive into <a href="b9f006c0-470d-4daa-9d55-7f7c0c8fea52.xhtml" target="_blank">Chapter 2</a>, <em>Expressive Functions and Adjustable Interfaces</em></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Discovering the concept of sequences</h1>
                
            
            
                
<p>In terms of high-level functionalities, the <kbd>Sequence</kbd> and <kbd>Collection</kbd> data structures are nearly the same. They both allow iteration through their elements. There are also many powerful extension functions in the Kotlin standard library that provide declarative-style data-processing operations for each of them. However, the <kbd>Sequence</kbd> data structure behaves differently under the hood—it delays any operations on its elements until they are finally consumed. It instantiates the subsequent elements on the go while traversing through them. These characteristics of <kbd>Sequence</kbd>, called <strong>lazy evaluation</strong>, make this data structure quite similar to the Java concept,  <kbd>Stream</kbd>.  To understand all of this better, we are going to implement a simple data-processing scenario to analyze the efficiency and behavior of <kbd>Sequence</kbd> and contrast our findings with <kbd>Collection</kbd>-based implementation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Let's consider the following example:</p>
<pre>val collection = listOf("a", "b", "c", "d", "e", "f", "g", "h")<br/>val transformedCollection = collection.map {<br/>    println("Applying map function for $it")<br/>    it<br/>}<br/>println(transformedCollection.take(2))</pre>
<p>In the first line, we created a list of strings and assigned it to the <kbd>collection</kbd> variable. Next, we are applying the <kbd>map()</kbd><em> </em>function to the list. Mapping operation allows us to transform each element of the collection and return a new value instead of the original one. In our case, we are using it just to observe that <kbd>map()</kbd><em> </em>was invoked by printing the message to the console. Finally, we want to filter our collection to contain only the first two elements using the <kbd>take()</kbd><em> </em>function and print the content of the list to the console.</p>
<p class="mce-root"/>
<p>In the end, the preceding code prints the following output:</p>
<pre><strong>Applying map function for a</strong><br/><strong>Applying map function for b</strong><br/><strong>Applying map function for c</strong><br/><strong>Applying map function for d</strong><br/><strong>Applying map function for e</strong><br/><strong>Applying map function for f</strong><br/><strong>Applying map function for g</strong><br/><strong>Applying map function for h</strong><br/><strong>[a, b]</strong></pre>
<p>As you can see, the <kbd>map()</kbd><em> </em>function was properly applied to every element of the collection and the <kbd>take()</kbd><em> </em>function has properly filtered the elements of the list. However, it would not be an optimal implementation if we were working with a larger dataset. Preferably, we would like to wait with the execution of the data-processing operations until we know what specific elements of the dataset we really need, and then apply those operations only to those elements. It turns out that we can easily optimize our scenario using the <kbd>Sequence</kbd> data structure. Let's explore how to do it in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a <kbd>Sequence</kbd> instance for the given elements:</li>
</ol>
<pre style="padding-left: 60px">val sequence = sequenceOf("a", "b", "c", "d", "e", "f", "g", "h")</pre>
<ol start="2">
<li>Apply the mapping operation to the elements of the sequence:</li>
</ol>
<pre style="padding-left: 60px">val sequence = sequenceOf("a", "b", "c", "d", "e", "f", "g", "h")<br/><strong>val transformedSequence = sequence.map {<br/>    println("Applying map function for $it")</strong><br/><strong>    it<br/>}<br/></strong></pre>
<ol start="3">
<li>Print the first two elements of the sequence to the console:</li>
</ol>
<pre style="padding-left: 60px">val sequence = sequenceOf("a", "b", "c", "d", "e", "f", "g", "h")<br/><br/>val transformedSequence = sequence.map {<br/>    println("Applying map function for $it")<br/>    it<br/>}<br/><strong>println(transformedSequence.take(2).toList())</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Sequence</kbd>-based implementation is going to give us the following output:</p>
<pre><strong>Applying map function for a</strong><br/><strong>Applying map function for b</strong><br/><strong>[a, b]</strong></pre>
<p>As you can see, replacing the <kbd>Collection</kbd> data structure with the <kbd>Sequence</kbd> type allows us to gain the desired optimization.</p>
<p>The scenario considered in this recipe was implemented identically—first, using <kbd>List</kbd>, then using the <kbd>Sequence</kbd> type. However, we can notice the difference in the behavior of the <kbd>Sequence</kbd> data structure compared to that of <kbd>Collection</kbd>. The <kbd>map()</kbd> function was applied only to the first two elements of the sequence, even though the <kbd>take()</kbd> function was called after the mapping transformation declaration. It's also worth noting that in the example using <kbd>Collection</kbd>, the mapping was performed instantly when the <kbd>map()</kbd> function was invoked. In the case of <kbd>Sequence</kbd>, mapping was performed at the time of the evaluation of its elements while printing them to the console, and more precisely while converting <kbd>Sequence</kbd> to the <kbd>List</kbd> type with the following line of code:</p>
<pre>println(transformedSequence.take(2)<strong>.toList()</strong>)</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There is a convenient way of transforming <kbd>Collection</kbd> to <kbd>Sequence</kbd><em>. </em>We can do so with the <kbd>asSequence()</kbd><em> </em>extension function provided by the Kotlin standard library for the <kbd>Iterable</kbd> type. In order to convert a <kbd>Sequence</kbd><em> </em>instance into a <kbd>Collection</kbd> instance<em>, </em>you can use the <kbd>toList()</kbd> function. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Thanks to the feature of <kbd>Sequence</kbd> lazy evaluation, we have avoided needless calculations, increasing the performance of the code at the same time. Lazy evaluation allows the implementation of sequences with a potentially infinite number of elements and turns out to be effective when implementing algorithms as well.</li>
</ul>
<p class="mce-root"/>
<ul>
<li>You can explore a <kbd>Sequence</kbd>-based implementation of the Fibonacci algorithm in the <em>Applying sequences to solve algorithmic problems</em> recipe. It presents, in more detail, another useful function for defining sequences called <kbd>generateSequence()</kbd>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying sequences to solve algorithmic problems</h1>
                
            
            
                
<p>In this recipe, we are going to get familiar with the <kbd>generateSequence()</kbd> function, which provides an easy way to define the various types of sequences. We will use it to implement an algorithm for generating Fibonacci numbers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The basic variant of the <kbd>generateSequence()</kbd> function is declared as follows:</p>
<pre>fun &lt;T : Any&gt; generateSequence(nextFunction: () -&gt; T?): Sequence&lt;T&gt;</pre>
<p>It takes one parameter called <kbd>nextFunction</kbd>, which is a function that returns the next elements of the sequence. Under the hood, it is being invoked by the <kbd>Iterator.next()</kbd> function, inside the <kbd>Sequence</kbd> class' internal implementation, and allows instantiation of the next object to be returned while consuming the sequence values.</p>
<p>In the following example, we are going to implement a finite sequence that emits integers from <kbd>10</kbd> to <kbd>0</kbd>:</p>
<pre>var counter = 10<br/>val sequence: Sequence&lt;Int&gt; = generateSequence {<br/>    counter--.takeIf { value: Int -&gt; value &gt;= 0 }<br/>}<br/>print(sequence.toList())</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>takeIf()</kbd> function applied to the current <kbd>counter</kbd> value checks whether its value is greater or equal to <kbd>0</kbd>. If the condition is fulfilled, it returns the <kbd>counter</kbd> value; otherwise, it returns <kbd>null</kbd>. Whenever <kbd>null</kbd> is returned by the <kbd>generateSequence()</kbd> function, the sequence stops. After the <kbd>takeIf</kbd> function returns the value, the <kbd>counter</kbd> value is post-decremented. The preceding code will result in the following numbers being printed to the console:</p>
<pre><strong>[10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</strong></pre>
<p>The subsequent values of the Fibonacci sequence are generated by summing up their two preceding ones. Additionally, the two first values are equal to <kbd>0</kbd> and <kbd>1</kbd>. In order to implement such a sequence, we are going to use an extended variant of the <kbd>generateSequence()</kbd> function with an additional <kbd>seed</kbd> parameter, declared as follows:</p>
<pre>fun &lt;T : Any&gt; generateSequence(seed: T?, nextFunction: (T) -&gt; T?): Sequence&lt;T&gt;</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Declare a function called <kbd>fibonacci()</kbd> and use the <kbd>generateSequence()</kbd> function to define a formula for the next elements of the sequence:</li>
</ol>
<pre style="padding-left: 60px">fun fibonacci(): Sequence&lt;Int&gt; {<br/>    return generateSequence(Pair(0, 1)) { Pair(it.second, it.first + it.second) }<br/>            .map { it.first }<br/>}</pre>
<ol start="2">
<li>Use the <kbd>fibonacci()</kbd> function to print the next Fibonacci numbers to the console:</li>
</ol>
<pre style="padding-left: 60px">println(fibonacci().take(20).toList())</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As a result, we are going to get the next 20 Fibonacci numbers printed to the console:</p>
<pre><strong>[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]</strong></pre>
<p>The additional <kbd>seed</kbd> parameter in the <kbd>generateSequence()</kbd> provides a starting value. The <kbd>nextFunction()</kbd> function is applied to the <kbd>seed</kbd> while computing the second value. Later on, it is generating each following element using its preceding value. However, in the case of the Fibonacci sequence, we have two initial values and we need a pair of preceding values in order to compute the next value. For this reason, we wrapped them in <kbd>Pair</kbd> type instances. Basically, we are defining a sequence of  <kbd>Pair&lt;Int, Int&gt;</kbd> type elements, and in each <kbd>nextFunction()</kbd> call, we are returning a new pair that holds the values updated accordingly. At the end, we just need to use the <kbd>map()</kbd> function to replace each <kbd>Pair</kbd> element with the value of its <kbd>first</kbd> property. As a result, we are getting an infinite sequence of integer types returning the subsequent Fibonacci numbers.</p>


            

            
        
    </body></html>