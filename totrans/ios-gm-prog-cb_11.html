<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;11.&#xA0;Getting Started with Multiplayer Games"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Getting Started with Multiplayer Games</h1></div></div></div><p class="calibre8">In this chapter, we will be focusing on the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Anatomy of multiplayer games</li><li class="listitem">Setup for a multiplayer game</li><li class="listitem">Assigning roles to players</li></ul></div></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Getting Started with Multiplayer Games">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec59" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">So far in the book, we have done a lot of cool game-related stuff, such as SpriteKit, parallax scrolling background, physics simulation with autonomous moving agents, three-dimensional game programming using OpenGL, and much more. All these were done to make a single-player game, meaning only one person can play it at a time. But now, we will be moving forward to make a multiplayer game, which engages more than one person at the same time. Multiplayer is, in itself, more engaging and fun for the user, as live competition gets into the picture, making the gaming experience a lot more enjoyable for the users. So, it's time to understand things related to multiplayer games. In <a class="calibre1" title="Chapter 12. Implementing Multiplayer Games" href="part0069_split_000.html#page">Chapter 12</a>, <span class="strong"><em class="calibre9">Implementing Multiplayer Games</em></span>, we will be creating a multiplayer game. For taking a tour of multiplayer game development, the overall agenda will be divided into the following sections:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Creating a sample multiplayer game to understand the anatomy and various states of a multiplayer game.</li><li class="listitem" value="2">Doing the setup for the same multiplayer game using SpriteKit and Apple's Multipeer Connectivity framework. After that, handshaking or connection establishment between players using <code class="email">MCBrowserViewController</code> of the same framework.</li><li class="listitem" value="3">Assigning roles to players by sending and receiving network packets.</li></ol><div class="calibre14"/></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Anatomy of multiplayer games"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec60" class="calibre1"/>Anatomy of multiplayer games</h1></div></div></div><p class="calibre8">In a single-player game, there<a id="id429" class="calibre1"/> is only one player, so talking about the game as an object that maintains all of the game behavior, whereas if we understand <a id="id430" class="calibre1"/>the anatomy of multiplayer games, we'll see that it's totally different. In multiplayer games, there are multiple players playing the same game, so technically for every device, there is a player who is actively driving the game on that device. This is called the local player, and all other players are treated as remotes players for that device. The local player's activities should ideally be updated on the remote players' devices, which is the foremost challenge in multiplayer development. The update of the local player is called syncing the game on some other device, and is done by the game object that resides in the game. It's the responsibility of the game object (that is, the instance of game running on the device) to make the game look the same on all devices as a live game is played.</p><p class="calibre8">So, moving further in this section, we will be creating a fresh multiplayer game, called TankRace, using SpriteKit, in which game sessions will be instantiated. We will incorporate multiplayer game states with their explanation and essentiality. All the session and multiplayer related processes will be done using the Multipeer Connectivity framework introduced in iOS 7, which was a part of GameKit in iOS 6.</p></div>

<div class="book" title="Anatomy of multiplayer games">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec140" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">To develop the <a id="id431" class="calibre1"/>TankRace multiplayer game using SpriteKit, start by creating a new project. Open Xcode and go to <span class="strong"><strong class="calibre2">File</strong></span> | <span class="strong"><strong class="calibre2">New</strong></span> | <span class="strong"><strong class="calibre2">Project</strong></span> | <span class="strong"><strong class="calibre2">iOS</strong></span> | <span class="strong"><strong class="calibre2">Application</strong></span> | <span class="strong"><strong class="calibre2">SpriteKit Game</strong></span>. In the pop-up, type the <span class="strong"><strong class="calibre2">Product Name</strong></span> as <code class="email">TankRace</code>, go to <span class="strong"><strong class="calibre2">Devices</strong></span> | <span class="strong"><strong class="calibre2">iPhone</strong></span>, and click on <span class="strong"><strong class="calibre2">Next</strong></span>, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00165.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Click on <span class="strong"><strong class="calibre2">Next</strong></span> and save the project on your hard drive.</p><p class="calibre8">Once the <a id="id432" class="calibre1"/>project is saved, you should be able to see the project settings. On the project settings page, just check in the <span class="strong"><strong class="calibre2">Portrait</strong></span> from the <span class="strong"><strong class="calibre2">Device Orientation</strong></span> section and uncheck all others, as we are supporting only the portrait mode for this game. Also set the deployment target to 7.0 so that a range of devices can be supported. </p><p class="calibre8">The changes are shown here:</p><div class="mediaobject"><img src="../images/00166.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Let's take a <a id="id433" class="calibre1"/>closer view at what structure SpriteKit has provided:</p><div class="mediaobject"><img src="../images/00167.jpeg" alt="Getting ready" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the <code class="email">viewDidLoad</code> method of <code class="email">GameViewController</code> a piece of code is written that converts<a id="id434" class="calibre1"/> its view to <code class="email">SKView</code> and a scene that is, <code class="email">GameScene</code> is presented on the <code class="email">SKView</code> as shown below. The <code class="email">unarchiveFromFile</code> method is implemented by the project itself to fetch the <code class="email">GameScene.sks</code> file, which we can see in the project created. For not showing the FPS and nodes, comment both the lines as shown in the following code:</p><div class="informalexample"><pre class="programlisting">- (void)viewDidLoad
{
    [super viewDidLoad];

    // Configure the view.
    SKView * skView = (SKView *)self.view;
//    skView.showsFPS = YES;
//    skView.showsNodeCount = YES;

    /* Sprite Kit applies additional optimizations to improve rendering performance */
    skView.ignoresSiblingOrder = YES;
    
    // Create and configure the scene.
    GameScene *scene = [GameScene unarchiveFromFile:@"GameScene"];
    scene.scaleMode = SKSceneScaleModeAspectFill;
    
    // Present the scene.
    [skView presentScene:scene];
}</pre></div></div></div>

<div class="book" title="Anatomy of multiplayer games">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec141" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">Before starting with the multiplayer code we should make the game ready for it. First, go in to the <code class="email">GameScene</code> class and remove the sample <code class="email">SKLabelNode</code> addition code in the overridden method <code class="email">didMoveToView</code> of <code class="email">GameScene</code> where we usually set up the scene. Secondly, remove the <code class="email">for</code> loop of touches from the <code class="email">touchesBegan:withEvent</code> method, which does the addition of <code class="email">SKSpriteNode</code> and its action.</p><p class="calibre8">Our project is now ready to start with the multiplayer. Multiplayer games can be developed in several ways. They can be either played using Bluetooth, Wifi, Internet, or GameCenter. All these techniques allow us to interconnect devices and share data across devices. This allows us to show the movement of players in real time. You might have seen the responsiveness in multiplayer games. They are really seamless. In this section we will explore more about multiplayer games and their implementation in iOS. Here we will be instantiating a session (that is, MCSession) for the local player, which will further connect to another player in this recipe. Also, to instruct the user to touch we will add an info label saying <code class="email">Tap to connect</code> and further will implement the delegates of MCSession following with the explanation of Multiplayer Game States. Stated below are the steps to<a id="id435" class="calibre1"/> accomplish this task:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open <code class="email">GameScene.m</code> file, and create an interface with properties of <code class="email">InfoLabel</code> and all related session stuff. Also make <code class="email">GameScene</code> follow <code class="email">MCSessionDelegate</code> and the interface will look like this:<div class="informalexample"><pre class="programlisting">@interface GameScene() &lt;MCSessionDelegate&gt;

@property (nonatomic, strong) MCSession* gameSession;
@property (nonatomic, strong) MCPeerID* gamePeerID;
@property (nonatomic, strong) NSString* serviceType;
@property (nonatomic, strong) MCAdvertiserAssistant* advertiser;

@property (nonatomic, strong) SKLabelNode* gameInfoLabel;

@end</pre></div><p class="calibre15">Here <code class="email">gameSession</code> is the session that will be created for playing a multiplayer game, <code class="email">gamePeerID</code> is the unique ID for the local player of this <code class="email">gameSession</code>, which will be in future acting as the unique ID of the remote player to whom this device will be connected to. This is why it is called peerID. <code class="email">ServiceType</code> is the unique ID assigned particularly to the game; here, the service type will be TankRace and advertiser is a class that handles all incoming invitations to the user and handles all user responses. A <code class="email">gameInfoLabel</code> property is declared, which will be created to instruct the user to connect with other players.</p></li><li class="listitem" value="2">Add a method called <code class="email">addGameInfoLabelWithText</code>, which can be used to show any GameInfo with <code class="email">pragma</code> mark.<div class="informalexample"><pre class="programlisting">#pragma mark - Adding Assets Methods

- (void)addGameInfoLabelWithText:(NSString*)labelText
{
    if (self.gameInfoLabel == nil) {
        self.gameInfoLabel = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
        self.gameInfoLabel.text = labelText;
        self.gameInfoLabel.fontSize = 32;
        self.gameInfoLabel.position = CGPointMake(CGRectGetMidX(self.frame),
                                                  CGRectGetMidY(self.frame));
        self.gameInfoLabel.zPosition = 100;
        
        [self addChild:self.gameInfoLabel];
    }
}</pre></div></li><li class="listitem" value="3">Declare <a id="id436" class="calibre1"/>hash defines for different GameInfo texts.<div class="informalexample"><pre class="programlisting">#define kConnectingDevicesText @"Tap to Connect"
#define kGameStartedText       @"Game Started"
#define kConnectedDevicesText @"Devices Connected"</pre></div></li><li class="listitem" value="4">Call <code class="email">addGameInfoLabelWithText</code> from the <code class="email">didMoveToView</code> method of <code class="email">GameScene</code>. With text hash define <code class="email">kConnectingDevicesText</code> and <code class="email">pragma</code> mark as depicted below.<div class="informalexample"><pre class="programlisting">#pragma mark - Overridden Methods

-(void)didMoveToView:(SKView *)view {
    /* Setup your scene here */
    [self addGameInfoLabelWithText:kConnectingDevicesText];
}</pre></div></li><li class="listitem" value="5">Declare an <code class="email">enum</code>, <code class="email">GameState</code>, and a property corresponding to it in the private interface of <code class="email">GameScene</code>. Also, set the initial state of game as <code class="email">kGameStatePlayerToConnect</code>, as, to start a multiplayer game, players need to be connected first to play. Add these lines just above the hash defines:<div class="informalexample"><pre class="programlisting">typedef enum {

    kGameStatePlayerToConnect,
    kGameStatePlayerAllotment,
    kGameStatePlaying,
    kGameStateComplete,

} GameState;</pre></div></li><li class="listitem" value="6">Add this property of <code class="email">gameState</code> in the private interface of <code class="email">GameScene</code>:<div class="informalexample"><pre class="programlisting">@property (nonatomic, assign) GameState gameState;</pre></div></li><li class="listitem" value="7">Assign <code class="email">gameState</code> to <code class="email">kGameStatePlayerToConnect</code> in <code class="email">didMoveToView</code> of <code class="email">GameScene</code>:<div class="informalexample"><pre class="programlisting">self.gameState = kGameStatePlayerToConnect;</pre></div></li><li class="listitem" value="8">Create a method called <code class="email">instantiateMCSession</code> and add the <code class="email">pragma</code> mark as shown in the following code:<div class="informalexample"><pre class="programlisting">#pragma mark - Networking Related Methods

- (void)instantiateMCSession
{
  if (self.gameSession == nil)
  {
    UIDevice *device = [UIDevice currentDevice];
    MCPeerID* peerID = [[MCPeerID alloc] initWithDisplayName:device.name];
    self.gameSession = [[MCSession alloc] initWithPeer:peerID];
    self.gameSession.delegate = self;
      self.serviceType = @"TankFight"; // should be unique
    self.advertiser = [[MCAdvertiserAssistant alloc] initWithServiceType:self.serviceTypediscoveryInfo:nil session:self.gameSession];
        [self.advertiser start];
    }
}</pre></div><p class="calibre15">Here, an object of <code class="email">MCSession</code> is created using <code class="email">peerID</code> with the display name as the device name and the <code class="email">delegate</code> property of this object is set to the <code class="email">GameScene</code> object to get the <code class="email">delegate</code> methods implemented in this class. For invitations to the user and handling all user responses an object of <code class="email">MCAdvertiserAssistant</code> is created using the <code class="email">gameSession</code> and a <code class="email">serviceType</code>, which should be unique.</p><p class="calibre15">In the fist line of the <a id="id437" class="calibre1"/>code snippet we have used the <code class="email">pragma</code> marks. Using <code class="email">pragma</code> marks we can make our code much more readable and also provide logical grouping to our methods. It is a good programming practice to follow.</p></li><li class="listitem" value="9">Implement all delegates <code class="email">MCSessionDelegate</code> with the  <code class="email">pragma</code> mark as shown below:<div class="informalexample"><pre class="programlisting">#pragma mark - MCSessionDelegate Methods

- (void)session:(MCSession *)session peer:(MCPeerID *)peerID
 didChangeState:(MCSessionState)state {
// A peer has changed state - it's now either connecting, connected, or disconnected.
    if (state == MCSessionStateConnected)
    {
      NSLog(@"state == MCSessionStateConnected");
    }
    else if (state == MCSessionStateConnecting)
    {
        NSLog(@"state == MCSessionStateConnecting");
    }
    else if (state == MCSessionStateNotConnected)
    {
        NSLog(@"state == MCSessionStateNotConnected");
    }
}

- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID {
    // Data has been received from a peer.
    // Do something with the received data, on the main thread
    [[NSOperationQueue mainQueue]  addOperationWithBlock:^{
        
        // Process the data
    }];
}

- (void)session:(MCSession *)session didStartReceivingResourceWithName:(NSString *)resourceName fromPeer:(MCPeerID *)peerID withProgress:(NSProgress *)progress {
    // A file started being sent from a peer. (Not used in this example.)
}
- (void)session:(MCSession *)session didFinishReceivingResourceWithName:(NSString*)resourceName fromPeer:(MCPeerID *)peerID atURL:(NSURL *)localURL withError:(NSError *)error {
    // A file finished being sent from a peer. (Not used in this example.)
}

- (void)session:(MCSession *)session didReceiveStream:(NSInputStream *)stream
 withName:(NSString *)streamName fromPeer:(MCPeerID *)peerID {
    // Data started being streamed from a peer. (Not used in this example.)
}</pre></div><p class="calibre15">These all are the delegate methods of <code class="email">MCSession</code> implemented in the <code class="email">GameScene</code> class, amongst which the former two are mostly used. The first one is used to determine the state of game changes, like, whether it is connected, connecting or not connected. And the latter one is used to receive data, hence to process that data under an operation queue block as shown in the above implementation.</p></li><li class="listitem" value="10">Now <a id="id438" class="calibre1"/>add <code class="email">instantiateMCSession</code> in <code class="email">touchBegan:withEvent</code> according to <code class="email">gameState</code> of <code class="email">GameScene</code> with <code class="email">pragma</code> mark.<div class="informalexample"><pre class="programlisting">#pragma mark - Touch Methods
-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {
    /* Called when a touch begins */
    
    if (self.gameState == kGameStatePlayerToConnect)
    {
        [self instantiateMCSession];
    }
    else if (self.gameState == kGameStatePlaying)
    {
    }
}</pre></div><p class="calibre15">In the <code class="email">touchesBegan</code> method if the state is <code class="email">kGameStatePlayerToConnect</code> then it means that the user has touched to start the game that is, technically connecting of players to be done and in other states of game the handling would be done accordingly on touches.</p><p class="calibre15">After all these steps an initial session of game set up has been accomplished with an understanding of multiplayer games' architecture.</p></li></ol><div class="calibre14"/></div></div></div>

<div class="book" title="Anatomy of multiplayer games">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec142" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">In the preceding setup we used the Multipeer Connectivity framework for setting up a structure of a multiplayer game with an instance of <code class="email">MCSession</code> to be there in every device that will be used to play the game. We also implemented all its delegate methods, which informs the <code class="email">GameScene</code> about the changing of game states and will also be used for receiving data when incoming sections from some network packets are sent. For now, in this section, we have put a label <code class="email">Tap to connect</code> and on clicking the screen a session is <a id="id439" class="calibre1"/>instantiated. Now build the project. First you will see the following launch screen and then the initial <code class="email">GameScene</code> with a label <span class="strong"><strong class="calibre2">Tap to connect</strong></span>:</p><div class="mediaobject"><img src="../images/00168.jpeg" alt="How it works..." class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Setup for a multiplayer game"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec61" class="calibre1"/>Setup for a multiplayer game</h1></div></div></div><p class="calibre8">In this recipe, we will <a id="id440" class="calibre1"/>write the code for setting up our multiplayer game. All the configurations and session managers will be the part of this section. We will dig into the various concepts of creating and maintaining sessions.</p></div>

<div class="book" title="Setup for a multiplayer game">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec143" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before starting this recipe, MCSession, MCPeerId, advertiser and service type terms of Multipeer Connectivity framework should be known to us. In this recipe we will be establishing the connection between players, thereby, they can communicate in future, making the players play a game, which we will be doing in the next chapter.</p></div></div>

<div class="book" title="Setup for a multiplayer game">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec144" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">Now, on tapping the screen, a MCSession with a service type has been instantiated; we can use this session and service type to present a <code class="email">MCBrowserViewController</code> and establish connection <a id="id441" class="calibre1"/>between players (that is, devices). <code class="email">MCBrowserViewController</code> is fully equipped and designed for connecting multiple players for a session provided in the Multipeer Connectivity framework. These are the steps involved:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First of all, create a protocol of <code class="email">GameScene</code> as <code class="email">GameSceneDelegate</code> and its delegate object in <code class="email">GameScene</code>, which will be set as <code class="email">GameViewController</code> so that it uses its delegate method when the user touches the screen. <code class="email">GameViewController</code> can be informed to present <code class="email">MCBrowserViewController</code>. Declare the protocol code and <code class="email">GameSceneDelegate</code> object, as follows:<div class="informalexample"><pre class="programlisting">@protocol GameSceneDelegate &lt;NSObject&gt;

- (void)showMCBrowserControllerForSession:(MCSession*)sessionserviceType:(NSString*)serviceType;
@end

@property (nonatomic, weak) id&lt;GameSceneDelegate&gt; gameSceneDelegate;</pre></div></li><li class="listitem" value="2">When the user touches the screen that has the <code class="email">gameState</code> as <code class="email">kGameStatePlayerToConnect</code>, where we are calling the method, <code class="email">instantiateMCSession</code>, which also informs <code class="email">gameSceneDelegate</code> to show <code class="email">MCBrowserViewController</code> by passing <code class="email">gameSession</code> that was created and the <code class="email">serviceType</code> property:<div class="informalexample"><pre class="programlisting">if (self.gameSceneDelegate &amp;&amp; [self.gameSceneDelegate respondsToSelector:@selector(showMCBrowserControllerForSession:serviceType:)])
  {
    [self.gameSceneDelegate showMCBrowserControllerForSession:self.gameSession serviceType:self.serviceType];
  }</pre></div></li><li class="listitem" value="3">The delegate method has to be called by <code class="email">GameViewController</code>, and on the same controller, <code class="email">MCBrowserViewController</code> has to be presented, which will also have its own delegate methods. Now, it's time to declare the private interface of <code class="email">GameViewController</code> and follow both <code class="email">MCBrowserViewControllerDelegate</code> and <code class="email">GameSceneDelegate</code> as shown in this snippet:<div class="informalexample"><pre class="programlisting">@interface GameViewController() &lt;MCBrowserViewControllerDelegate,
       GameSceneDelegate&gt;
@property (nonatomic, strong) GameScene* gameScene;
@end</pre></div></li><li class="listitem" value="4">In <code class="email">viewDidLoad</code> of <code class="email">GameViewController</code>, replace the local scene object with <code class="email">self.gameScene</code> and assign the <code class="email">gameSceneDelegate</code> property of the <code class="email">GameScene</code> object as the <code class="email">GameViewController</code>, as shown here:<div class="informalexample"><pre class="programlisting">   // Create and configure the scene.
    self.gameScene = [GameScene unarchiveFromFile:@"GameScene"];
    self.gameScene.scaleMode = SKSceneScaleModeAspectFill;
    
    self.gameScene.gameSceneDelegate = self;
    
    // Present the scene.
    [skView presentScene:self.gameScene];</pre></div></li><li class="listitem" value="5">Implement <a id="id442" class="calibre1"/>the delegate method of <code class="email">GameSceneDelegate</code>, like this:<div class="informalexample"><pre class="programlisting">- (void)showMCBrowserControllerForSession:(MCSession*)session
serviceType:(NSString*)serviceType
{
    MCBrowserViewController* viewController = [[MCBrowserViewController alloc]
    initWithServiceType:serviceType session:session];
    
    viewController.minimumNumberOfPeers = 2;
    viewController.maximumNumberOfPeers = 2;
    
    viewController.delegate = self;
    
    [self presentViewController:viewController animated:YES completion:nil];
}</pre></div><p class="calibre15">In this method, <code class="email">MCBrowserViewController</code> is presented on <code class="email">GameViewController</code> with its delegate set and restricted the peers to <code class="email">2</code>.</p></li><li class="listitem" value="6">Add two public methods to <code class="email">GameScene</code>, to be called the cancel and done actions of <code class="email">MCBrowserViewController</code>.<div class="book"><ul class="itemizedlist1"><li class="listitem">In <code class="email">GameScene.h</code>, declare the public methods, as follows:<div class="informalexample"><pre class="programlisting">#pragma mark - Public Methods

- (void)startGame;
- (void)discardSession;</pre></div></li><li class="listitem">In <code class="email">GameScene.m</code>, define the public methods, like this:<div class="informalexample"><pre class="programlisting">- (void)startGame
{
    self.gameInfoLabel.text = kConnectedDevicesText;
}

- (void)discardSession
{
    self.gameState = kGameStatePlayerToConnect;
    
    self.gameSession = nil;
    self.gamePeerID = nil;
    self.serviceType = nil;
    self.advertiser = nil;
}</pre></div></li></ul></div></li><li class="listitem" value="7">Now <a id="id443" class="calibre1"/>we will add two public methods in the <code class="email">GameScene</code> file. These methods will be invoked on the cancel and done actions of <code class="email">MCBrowserViewControllerDelegate</code> respectively:<div class="informalexample"><pre class="programlisting">#pragma mark - MCBrowserViewControllerDelegate Methods

- (void)browserViewControllerDidFinish:(MCBrowserViewController *)browserViewController {
    // The MCSession is now ready to use.
    [self dismissViewControllerAnimated:YES completion:nil];
    if (self.gameScene)
    {
        [self.gameScene startGame];
    }
}

- (void)browserViewControllerWasCancelled:(MCBrowserViewController *)browserViewController{
    // The user cancelled.
    [self dismissViewControllerAnimated:YES completion:nil];
    if (self.gameScene)
    {
        [self.gameScene discardSession];
    }
}</pre></div><p class="calibre15">In both the delegate methods, first the <code class="email">MCBrowserViewController</code> is dismissed and <code class="email">GameScene</code> is informed to change accordingly.</p></li></ol><div class="calibre14"/></div><p class="calibre8">Now when both<a id="id444" class="calibre1"/> the device players click on the screen, <code class="email">MCBrowserViewController</code> opens and the players try to connect to each other using the default behavior provided by this controller, and when done we show the appropriate text to the player. Hence this entire implementation accomplishes our starter kit of this chapter.</p></div></div>

<div class="book" title="Setup for a multiplayer game">
<div class="book" title="How it works"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec145" class="calibre1"/>How it works</h2></div></div></div><p class="calibre8">Now we will understand how the connection using the <code class="email">MCBrowserViewController</code> is established in the following steps (in the snapshots shown below, the left side is the simulator device and right side is iPhone 5s):</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Both the players click on the screen and <code class="email">MCBrowserViewController</code> opens, searching for peers nearby, with cancel and done buttons placed on the navigation bar. Here the done button is disabled, as initially no one is connected to the device.<div class="mediaobject"><img src="../images/00169.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="2">Once a peer is detected, it shows the name of the devices in the list.<div class="mediaobject"><img src="../images/00170.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="3">After<a id="id445" class="calibre1"/> that both the players press the device name with which they want to connect and the search of peers stop. Hence following this selection of device a request is sent to connect to it.<div class="mediaobject"><img src="../images/00171.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="4">Depending <a id="id446" class="calibre1"/>on the reply of the other user the status of the peer at the right text of table row is updated; it can be <span class="strong"><strong class="calibre2">Connecting</strong></span>, <span class="strong"><strong class="calibre2">Connected</strong></span>. And when the devices are connected the status is changed to <span class="strong"><strong class="calibre2">Connected</strong></span> and the <span class="strong"><strong class="calibre2">Done</strong></span> button is enabled.<div class="mediaobject"><img src="../images/00172.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre13"> </p></li><li class="listitem" value="5">When the <a id="id447" class="calibre1"/>player selects <span class="strong"><strong class="calibre2">Done</strong></span> or <span class="strong"><strong class="calibre2">Cancel</strong></span>, we show them the appropriate text, <span class="strong"><strong class="calibre2">Devices Connected</strong></span> on clicking on the <span class="strong"><strong class="calibre2">Done</strong></span> button and <span class="strong"><strong class="calibre2">Tap to connect</strong></span> on clicking the <span class="strong"><strong class="calibre2">Cancel</strong></span> button. Now, the devices are logically connected to each other and are sharing the same session. This session will be used further in the multiplayer game by the user to play.<div class="mediaobject"><img src="../images/00173.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre13"> </p></li></ol><div class="calibre14"/></div><p class="calibre8">Here, in all this<a id="id448" class="calibre1"/> process, we will see some network lagging also, so if the devices are not connecting, try to reconnect by cancelling the controller and again clicking on the screen to refresh the controller again.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Assigning roles to players"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec62" class="calibre1"/>Assigning roles to players</h1></div></div></div><p class="calibre8">In this recipe, we will <a id="id449" class="calibre1"/>take our game template to the next step by assigning the roles to our players. This means we will be logically dividing the users and assigning roles to them. This will provide an individual identity to the players.</p></div>

<div class="book" title="Assigning roles to players">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec146" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before starting <a id="id450" class="calibre1"/>with assigning or as we can also call it, an allotment of players identity (which is first player and second player), we should be familiar with the Multipeer Connectivity framework. We must also have a basic knowledge of network packet sending and receiving. In this section we will be assigning the first and second player identities to the players once they are connected using the <code class="email">MCBrowserViewController</code> having just described it in the preceding recipe by pressing the <span class="strong"><strong class="calibre2">Done</strong></span> button.</p></div></div>

<div class="book" title="Assigning roles to players">
<div class="book" title="How to do it"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec147" class="calibre1"/>How to do it</h2></div></div></div><p class="calibre8">To accomplish the assignment of players, following are the steps to be followed:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">For a set up purpose for this add some enums, hash define constants and properties as shown below:<div class="book"><ul class="itemizedlist1"><li class="listitem">Declare an <code class="email">enum</code> called <code class="email">NetworkPacketCode</code> in which we add only the <code class="email">KNetworkPacketCodePlayerAllotment</code> packet code for now, and in the future more packet codes can be added for sending and receiving packets from the game.<div class="informalexample"><pre class="programlisting">typedef enum {
    KNetworkPacketCodePlayerAllotment,
    // More to be added while creating the game
} NetworkPacketCode;</pre></div></li><li class="listitem">Add texts to be shown to players when the player roles are being decided.<div class="informalexample"><pre class="programlisting">// Blue is the First and Red is the Second Player
#define kFirstPlayerLabelText  @"You're First Player"
#define kSecondPlayerLabelText @"You're Second Player"</pre></div></li><li class="listitem">Add the max packet size constant and some properties like <code class="email">gamePacketNumber</code>, <code class="email">gameUniqueIdForPlayerAllocation</code> in <code class="email">GameScene.m</code> to be used while sending packets.<div class="informalexample"><pre class="programlisting">#define kMaxTankPacketSize 1024
int gameUniqueIdForPlayerAllocation;
@property (nonatomic, assign) int gamePacketNumber;</pre></div></li></ul></div></li><li class="listitem" value="2">Now to<a id="id451" class="calibre1"/> send <a id="id452" class="calibre1"/>data from one device to another, we have an encapsulated data container, which is called a packet. Now this packet is sent over the network and the other player's device will update the view and position accordingly. For this, create a method to send the packet with a header <code class="email">NetworkPacketCode</code> and data specifying <code class="email">peerId</code> to which the data packet has to be sent and whether the packet should be sent with a reliable service or not.<div class="informalexample"><pre class="programlisting">- (void)sendNetworkPacketToPeerId:(MCPeerID*)peerId
   forPacketCode:(NetworkPacketCode)packetCode
      withData:(void *)data
         ofLength:(NSInteger)length
            reliable:(BOOL)reliable
{
    // the packet we'll send is resued
    static unsigned char networkPacket[kMaxTankPacketSize];
    const unsigned int packetHeaderSize = 2 * sizeof(int);
// we have two "ints" for our header
    if(length &lt; (kMaxTankPacketSize - packetHeaderSize))
    {
// our networkPacket buffer size minus the size of the header info
      int *pIntData = (int *)&amp;networkPacket[0];
      // header info
      pIntData[0] = self.gamePacketNumber++;
      pIntData[1] = packetCode;
      
      if (data)       {
        // copy data in after the header
          memcpy( &amp;networkPacket[packetHeaderSize], data, length );
        }
        
        NSData *packet = [NSData dataWithBytes: networkPacket length: (length+8)];
             NSError* error;
        if(reliable == YES)
        {
            [self.gameSession sendData:packet toPeers:[NSArray arrayWithObject:peerId] withMode:MCSessionSendDataReliableerror:&amp;error];
        }
        else
        {
            [self.gameSession sendData:packet toPeers:[NSArray arrayWithObject:peerId]withMode:MCSessionSendDataUnreliableerror:&amp;error];
        }
        if (error)
        {
            NSLog(@"Error:%@",[error description]);
        }
    }
}</pre></div><p class="calibre15">Here <code class="email">networkPacket</code> is created with a header and data. A variable <code class="email">pIntData</code> is declared, which<a id="id453" class="calibre1"/> is the header containing the <code class="email">NetworkPacketCode</code> and a <code class="email">gamePacketNumber</code> so that a unique number is <a id="id454" class="calibre1"/>assigned to a packet to serialize the network packets to be used to sync or update the game properly. Once the packet is created, a method called <code class="email">sendData</code> of <code class="email">MCSession</code> is called with the packet to be sent, <code class="email">peerID</code> to which the packet has to be sent, the mode, which can be <code class="email">MCSessionSendDataUnreliable</code> or <code class="email">MCSessionSendDataReliable</code> and <code class="email">error</code> to check whether an error has occurred while sending the packet.</p><p class="calibre15">This method will be reused everywhere in the game to send packets to peers of the same game.</p></li><li class="listitem" value="3">Generate a<a id="id455" class="calibre1"/> random number and store it in the <a id="id456" class="calibre1"/>variable <code class="email">gameUniqueIdForPlayerAllocation</code> declared above, which will help to decide which will be the first and second player. Add this line in the <code class="email">didMoveToView</code> method of <code class="email">GameScene</code>.<div class="informalexample"><pre class="programlisting">gameUniqueIdForPlayerAllocation = arc4random();</pre></div></li><li class="listitem" value="4">Add the following code to receiving data delegate method of <code class="email">MCSession</code> for handling of received packets based on their <code class="email">NetworkPacketCode</code> as shown in the following code:<div class="informalexample"><pre class="programlisting">- (void)session:(MCSession *)session didReceiveData:(NSData *)data fromPeer:(MCPeerID *)peerID {
    // Data has been received from a peer.
    // Do something with the received data, on the main thread
    [[NSOperationQueue mainQueue]  addOperationWithBlock:^{
    // Process the data
      unsigned char *incomingPacket = (unsigned char *)[data bytes];
      int *pIntData = (int *)&amp;incomingPacket[0];
      NetworkPacketCode packetCode = (NetworkPacketCode)pIntData[1];
        
      switch( packetCode ) {
       case KNetworkPacketCodePlayerAllotment:
       {
        NSInteger gameUniqueId = pIntData[2];                
        if (gameUniqueIdForPlayerAllocation &gt; gameUniqueId)
         {
            self.gameInfoLabel.text = kFirstPlayerLabelText;
         }
        else
           {
              self.gameInfoLabel.text = kSecondPlayerLabelText;
                }
                break;
            }
            default:
            break;
        }
    }];
}</pre></div><p class="calibre15">While<a id="id457" class="calibre1"/> receiving the data, it should be processed on a <code class="email">mainQueue</code> operation block. In this block, we will remove the header in the <code class="email">pIntData</code> pointer variable and get the <code class="email">NetworkPacketCode</code> sent in the packet. In this code, we will check the type of packet <a id="id458" class="calibre1"/>which is sent. Then we will parse the packet based on its type. In this, a player allotment packet type named <code class="email">KNetworkPacketCodePlayerAllotment</code> is passed, hence the data retrieved is <code class="email">gameUniqueId</code>. As discussed above, in <code class="email">didMoveToView</code>, we assigned a random number to a variable named <code class="email">gameUniqueIdForPlayerAllocation</code> for both the devices. Hence for both devices, different numbers are generated &amp; while sending the allotment packet from both devices, this is passed as the data (the allotment packet to be sent would be discussed in next point). Finally to decide which is first and second player, the local value of <code class="email">gameUniqueIdForPlayerAllocation</code> would be compared with the value sent in the packet, on this comparison one would be assigned as the first player and other as the second player, informing the users by changing appropriate text of <code class="email">gameInfoLabel</code> as shown in the delegate method.</p></li><li class="listitem" value="5">Remove the following written line from the public method <code class="email">startGame</code> of <code class="email">GameScene</code> as now, the <code class="email">gameInfoLabel</code> will be set according to the packet received.<div class="informalexample"><pre class="programlisting">self.gameInfoLabel.text = kConnectedDevicesText;</pre></div></li><li class="listitem" value="6">All these earlier processes start when the user clicks on the done button. This button is an indication that the players have been connected and a delegate method <code class="email">didChangeState</code> of <code class="email">MCSession</code> will be called with a <code class="email">MCSessionState</code> called <code class="email">MCSessionStateConnected</code>, and as a checking protocol is already in-built in this method of connected state, add the following code in the <code class="email">if</code> statement:<div class="informalexample"><pre class="programlisting">- (void)session:(MCSession *)session peer:(MCPeerID *)peerID didChangeState:(MCSessionState)state {
   // A peer has changed state - it's now either connecting, connected, or disconnected.
    
    if (state == MCSessionStateConnected)
    {
        NSLog(@"state == MCSessionStateConnected");
        
        // Remember the current peer
        self.gamePeerID = peerID;
        // Make sure we have a reference to the game session and it is set up
        self.gameSession = session;
        self.gameSession.delegate = self;
        self.gameState = kGameStatePlayerAllotment;
        
        self.gameInfoLabel.text = kGameStartedText;
        
        [self sendNetworkPacketToPeerId:self.gamePeerID
          forPacketCode:KNetworkPacketCodePlayerAllotment
            withData:&amp;gameUniqueIdForPlayerAllocation
               ofLength:sizeof(int)
                  reliable:YES];
    }
    else if (state == MCSessionStateConnecting)
    {
        NSLog(@"state == MCSessionStateConnecting");
    }
    else if (state == MCSessionStateNotConnected)
    {
        NSLog(@"state == MCSessionStateNotConnected");
    }
}</pre></div><p class="calibre15">Here, in this <a id="id459" class="calibre1"/>method, set all properties that<a id="id460" class="calibre1"/> come from the method, as it is the remote player information, and set the game state to <code class="email">kGameStatePlayerAllotment</code> locally. Then, we send the packet of the allotment of the player to <code class="email">peerID</code>, for which the connection has been established with a <code class="email">NetworkPacketCode</code> and a data part, which would be received at the remote end as discussed previously.</p></li></ol><div class="calibre14"/></div><p class="calibre8">Finally, we are done with connecting two players for a multiplayer game and assigning them a unique identity for further identification to build the game. This recipe acts as the solution kit for this chapter.</p></div></div>

<div class="book" title="Assigning roles to players">
<div class="book" title="How it works"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec148" class="calibre1"/>How it works</h2></div></div></div><p class="calibre8">The entire assignment <a id="id461" class="calibre1"/>of players depends on what action and data the packet is sent with, and how it is parsed at the receiver's end according to the <a id="id462" class="calibre1"/>convention set by the sender. To accomplish the allotment of the player's identity, we used a random number variable, which is locally generated and passed in the allotment packet. At the receiving end, the logic of allotment is written, checking the locally set and remotely passed random number. Based on this comparison, the first and second players are decided.</p><p class="calibre8">Some text is shown on both the devices, informing the players about their identity, as shown here:</p><div class="mediaobject"><img src="../images/00174.jpeg" alt="How it works" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Assigning roles to players">
<div class="book" title="There's more"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch11lvl2sec149" class="calibre1"/>There's more</h2></div></div></div><p class="calibre8">In the preceding section, we have<a id="id463" class="calibre1"/> used the Multipeer Connectivity framework. We can also use the GameKit framework. For more information on this take a look at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html">https://developer.apple.com/library/ios/documentation/GameKit/Reference/GameKit_Collection/index.html</a>.</p></div></div>

<div class="book" title="Assigning roles to players">
<div class="book" title="See also"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch11lvl2sec150" class="calibre1"/>See also</h2></div></div></div><p class="calibre8">For better understanding and learning the <a id="id464" class="calibre1"/>Multipeer Connectivity framework, visit <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html">https://developer.apple.com/library/prerelease/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/index.html</a>.</p></div></div></body></html>