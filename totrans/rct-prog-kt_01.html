<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">A Short Introduction to Reactive Programming</h1>
                </header>
            
            <article>
                
<p>The term <strong>reactive</strong> got famous recently. Not only did it get trending, but it has started ruling the software development sector with new blog posts articles <span>every day</span>, and presentations, emerging frameworks and libraries, and more. Even the big IT companies that are often referred to as market giants, such as Google, Facebook, Amazon, Microsoft, and Netflix, are not only supporting and using reactive programming themselves, but they've even started releasing new frameworks for the same.</p>
<p>So, as a programmer, we are wondering about reactive programming. Why is everyone getting crazy about it? What does <em>reactive programming</em> exactly mean? What are the benefits of reactive programming? And, finally, should we learn it? If yes, then how?</p>
<p>On the other hand, <strong>Kotlin</strong> is also the newest programming language you've heard of (we're guessing you've heard of Kotlin, as this book assumes that you've a little understanding of the language). Kotlin, as a language, solves many important problems in Java. The best part is its interoperability with Java. If you carefully watch the trends, then you would know that Kotlin has created not a strong wind but a storm to blow things around it. Even the Google at <em>Google IO/17</em> declared its official support for Kotlin as an official programming language for Android application development, noting that it is the first time since the perception of the Android Framework that Google has added another language to the Android family other than Java. Soon after, Spring also expressed their support for Kotlin.</p>
<p>To say it in simple words, Kotlin is powerful enough to create a great application, but if you combine reactive programming style with Kotlin, it would be super easy to build great apps better.</p>
<p>This book will present reactive programming in Kotlin with RxKotlin and Reactor, along with their implementations in Spring, Hibernate, and Android.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>What is reactive programming?</li>
<li>Reasons to adapt functional reactive programming</li>
<li>Reactive Manifesto</li>
<li>Comparison between the <kbd>observer</kbd> (reactive) pattern and familiar patterns</li>
<li>Getting started with RxKotlin</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is reactive programming?</h1>
                </header>
            
            <article>
                
<p>Reactive programming is an asynchronous programming paradigm that revolves around data streams and the propagation of change. In simpler words, those programs which propagate all the changes that affected its data/data streams to all the interested parties (such as end users, components and sub-parts, and other programs that are somehow related) are called <strong>reactive programs</strong>.</p>
<p>For example, take any spreadsheet (say the Google Sheet), put any number in the A1 cell, and in the B1 cell, write the <kbd>=ISEVEN(A1)</kbd> function; it'll show <kbd>TRUE</kbd> or  <kbd>FALSE</kbd>, depending on whether you've entered an even or odd number. Now, if you modify the number in A1, the value of B1 will also get changed automatically; such behavior is called <strong>reactive</strong>.</p>
<p>Not clear enough? Let's look at a coding example and then try to understand it again. The following is a normal Kotlin code block to determine if a number is even or odd:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      var number = 4 
      var isEven = isEven(number) 
      println("The number is " + (if (isEven) "Even" else "Odd")) 
      number = 9 
      println("The number is " + (if (isEven) "Even" else "Odd")) 
    } 
 
    fun isEven(n:Int):Boolean = ((n % 2) == 0) </pre>
<p>If you check the output of the program, then you'll see that, although the number is assigned a new value, <kbd>isEven</kbd> is still true; however, if <kbd>isEven</kbd> was made to track changes of the number, then it would automatically become false. A reactive program would just do the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reasons to adapt functional reactive programming</h1>
                </header>
            
            <article>
                
<p>So, let's first discuss the reasons to adapt functional reactive programming. There's no point in changing the whole way you code unless it gets you some really significant benefits, right? Yes, functional reactive programming gets you a set of mind-blowing benefits, as listed here:</p>
<ul>
<li><strong>Get rid of the callback hell</strong>:<br/>
A callback is a method that gets called when a predefined event occurs. The mechanism of passing interfaces with callback methods is called <strong>callback mechanism</strong>. This mechanism involves a hell of a lot of code, including the interfaces, their implementations, and more. Hence, it is referred to as <strong>callback hell</strong>.</li>
<li><strong>Standard mechanism for error handling</strong>:<br/>
Generally, while working with complex tasks and HTTP calls, handling errors are a major concern, especially in the absence of any standard mechanism, it becomes a headache.</li>
<li><strong>It's a lot simpler than regular threading</strong>:<br/>
Though Kotlin makes it easier to work with threading as compared to Java, it's still complicated enough. Reactive programming helps to make it easier.</li>
<li><strong>Straightforward way for async operations</strong>:<br/>
Threading and asynchronous operations are interrelated. As threading got easier, so did the async operations.</li>
<li><strong>One for everything</strong>, <strong>the same API for every operation</strong><strong>s</strong>:<br/>
Reactive programming, especially RxKotlin, offers you a simple and straightforward API. You can use it for anything and everything, be it network call, database access, computation, or UI operations.</li>
<li><strong>The functional way</strong>:<br/>
Reactive programming leads you to write readable declarative code as, here, things are more functional.</li>
<li><strong>Maintainable and testable code</strong>:<br/>
The most important point-by following reactive programming properly, your program becomes more maintainable and testable.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Manifesto</h1>
                </header>
            
            <article>
                
<p>So, what is the Reactive Manifesto? The Reactive Manifesto (<a href="http://www.reactivemanifesto.org"><span class="URLPACKT">http://www.reactivemanifesto.org</span></a>) is a document defining the four reactive principles. You can think of it as the map to the treasure of reactive programming, or like the bible for the programmers of the reactive programming religion.</p>
<p>Everyone starting with reactive programming should have a read of the manifesto to understand what reactive programming is all about and what its principles are.</p>
<p>So, the following is the gist of four principles that Reactive Manifesto defines:</p>
<ul>
<li><strong>Responsive</strong>:<br/>
The system responds in a timely manner. Responsive systems focus on providing rapid and consistent response times, so they deliver a consistent quality of service.</li>
<li><strong>Resilient</strong>:<br/>
In case the system faces any failure, it stays responsive. Resilience is achieved by replication, containment, isolation, and delegation. Failures are contained within each component, isolating components from each other, so when failure has occurred in a component, it will not affect the other components or the system as a whole.</li>
<li><strong>Elastic</strong>:<br/>
Reactive systems can react to changes and stay responsive under varying workload. They achieve elasticity in a cost effective way on commodity hardware and software platforms.</li>
<li><strong>Message driven</strong>:<br/>
In order to establish the resilient principle, reactive systems need to establish a boundary between components by relying on asynchronous message passing.</li>
</ul>
<p>By implementing all four preceding principles, the system becomes reliable and responsive thus, reactive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Streams standard specifications</h1>
                </header>
            
            <article>
                
<p>Along with the Reactive Manifesto, we also have a standard specification on Reactive Streams. Everything in the reactive world is accomplished with the help of Reactive Streams. In 2013, Netflix, Pivotal, and Lightbend (previously known as Typesafe) felt a need for a standards specification for Reactive Streams as the reactive programming was beginning to spread and more frameworks for reactive programming were starting to emerge, so they started the initiative that resulted in Reactive Streams standard specification, which is now getting implemented across various frameworks and platforms.</p>
<p>You can take a look at the Reactive Streams standard specification at—<a href="http://www.reactive-streams.org/"><span class="URLPACKT">http://www.reactive-streams.org/</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive Frameworks for Kotlin</h1>
                </header>
            
            <article>
                
<p>To write Reactive programs, we need a library or a specific programming language; we can't refer to Kotlin as a reactive language (basically, I don't know any such language that is reactive by itself) as it is a powerful and flexible programming language for modern multiplatform applications, fully interoperable with Java and Android. However, there are reactive libraries out there to help us with these. So, let's take a look at the available list:</p>
<ul>
<li>RxKotlin</li>
<li>Reactor-Kotlin</li>
<li>Redux-Kotlin</li>
<li>FunKTionale</li>
<li>RxJava and other Reactive Java Frameworks can also be used with Kotlin (as Kotlin is 100% interoperable with Java-bidirectional)</li>
</ul>
<div class="packt_infobox">In this book, we will focus on RxJava and Reactor-kotlin (in the later chapters, on Spring).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with RxKotlin</h1>
                </header>
            
            <article>
                
<p>RxKotlin is a specific implementation of reactive programming for Kotlin, which is influenced by functional programming. It favors function composition, avoidance of global state, and side effects. It relies on the <kbd>observer</kbd> pattern of producer/consumer, with a lot of operators that allow composing, scheduling, throttling, transforming, error handling, and lifecycle management.</p>
<p>Whereas Reactor-Kotlin is also based on functional programming, and it is widely accepted and backed by the Spring Framework.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloading and setting up RxKotlin</h1>
                </header>
            
            <article>
                
<p>You can download and build RxKotlin from GitHub (<a href="https://github.com/ReactiveX/RxKotlin"><span class="URLPACKT">https://github.com/ReactiveX/RxKotlin</span></a>). I do not require any other dependencies. The documentation on the GitHub wiki page is well structured. Here's how you can check out the project from GitHub and run the build:</p>
<pre><strong>$ git clone https://github.com/ReactiveX/RxKotlin.git</strong>
<strong>$ cd RxKotlin/</strong>
<strong>$ ./gradlew build</strong></pre>
<p>You can also use Maven and Gradle, as instructed on the page.</p>
<p>For Gradle, use the following compile dependency:</p>
<pre><strong>compile 'io.reactivex.rxjava2:rxkotlin:2.x.y'</strong> </pre>
<p>For Maven, use this dependency:</p>
<pre>    &lt;dependency&gt; 
      &lt;groupId&gt;io.reactivex.rxjava2&lt;/groupId&gt; 
      &lt;artifactId&gt;rxkotlin&lt;/artifactId&gt; 
      &lt;version&gt;2.x.y&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p>This book targets RxKotlin 2.x, so remember to use <kbd>io.reactive.rxjava2</kbd> instead of <kbd>io.reactivex.rxkotlin</kbd>, as the latter one is for RxKotlin 1.x.</p>
<div class="packt_infobox">Note that we are using RxKotlin version 2.1.0 for this book.</div>
<p>Now, let's take a look at what RxKotlin is all about. We will begin with something well-known and, gradually, we will get into the secrets of the library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing the pull mechanism with the RxJava push mechanism</h1>
                </header>
            
            <article>
                
<p>RxKotlin revolves around the observable type that represents a system of data/events intended for push mechanism (instead of the pull mechanism of the <kbd>iterator</kbd> pattern of traditional programs), thus it is lazy and can be used synchronously and asynchronously.</p>
<p>It will be easier for us to understand if we start with a simple example that works with a list of data. So, here is the code:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      var list:List&lt;Any&gt; = listOf("One", 2, "Three", "Four", 4.5,<br/>      "Five", 6.0f) // 1 
      var iterator = list.iterator() // 2 
      while (iterator.hasNext()) { // 3 
        println(iterator.next()) // Prints each element 4 
      } 
    } </pre>
<p>The following screenshot is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="178" width="429" src="assets/d1c8d575-2c41-4e63-9ab0-da8b5d83f1a3.jpg"/></div>
<p>So, let's go through the program line by line to understand how it works.</p>
<p>At comment <kbd>1</kbd>, we're creating a list of seven items (the list contains data of mixed data types with the help of any class). On comment <kbd>2</kbd>, we are creating <kbd>iterator</kbd> from the list, so that we can iterate over the data. In comment <kbd>3</kbd>, we have created a <kbd>while</kbd> loop to pull data from the list with the help of <kbd>iterator</kbd>, and then, in <kbd>4</kbd>, we're printing it.</p>
<p>The thing to notice is that we're pulling data from the list while the current thread is blocked until the data is received and ready. For example, think of getting that data from a network call/database query instead of just <kbd>List</kbd> and, in that case, how long the thread will be blocked. You can obviously create a separate thread for those operations, but then also, it will increase complexity.</p>
<p>Just give a thought; which one is a better approach? Making the program wait for data or pushing data to the program whenever it's available?</p>
<p>The building blocks of the ReactiveX Framework (be it RxKotlin or RxJava) are the observables. The <kbd>observable</kbd> class is just the opposite of <kbd>iterator</kbd> interface. It has an underlying collection or computation that produces values that can be consumed by a consumer. However, the difference is that the consumer doesn't <em>pull</em> these values from the producer, like in the <kbd>iterator</kbd> pattern; instead, the producer <em>pushes</em> the values as notifications to the consumer.</p>
<p>So, let's take the same example again, this time with <kbd>observable</kbd>:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      var list:List&lt;Any&gt; = listOf("One", 2, "Three",<br/>      "Four", 4.5, "Five", 6.0f) // 1 
      var observable: Observable&lt;Any&gt; = list.toObservable(); 
 
       observable.subscribeBy( // named arguments for<br/>       lambda Subscribers 
         onNext = { println(it) }, 
         onError =  { it.printStackTrace() }, 
         onComplete = { println("Done!") } 
      ) 
    } </pre>
<p>This program output is the same as the previous one—it prints all the items in the list. The difference is in the approach. So, let's see how it actually works:</p>
<ol>
<li>Create a list (just the same as the previous one).</li>
<li>An <kbd>observable</kbd> instance is created with that list.</li>
<li>We're subscribing to the <kbd>observer</kbd> instance (we're using named arguments for <kbd>lambda</kbd> and covering it in detail later).</li>
</ol>
<p>As we subscribe to <kbd>observable</kbd>, each data will be pushed to <kbd>onNext</kbd>, and, as it gets ready, it will call <kbd>onComplete</kbd> when all data is pushed and <kbd>onError</kbd> if any error occurs.</p>
<p>So, you learned to use the <kbd>observable</kbd> instances, and they are quite similar to the <kbd>iterator</kbd> instances, which is something we're very familiar with. We can use these <kbd>observable</kbd> instances to build asynchronous streams and push data updates to their subscribers (even to multiple subscribers).This was a simple implementation of the reactive programming paradigm. The data is being propagated to all the interested parties—the subscribers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ReactiveEvenOdd program</h1>
                </header>
            
            <article>
                
<p>So, now that we are somewhat familiar with <kbd>observables</kbd>, let's modify the even-odd program in a reactive way. Here is the code for doing so:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      var subject:Subject&lt;Int&gt; = PublishSubject.create() 
 
      subject.map({ isEven(it) }).subscribe({println<br/>      ("The number is ${(if (it) "Even" else "Odd")}" )}) 
 
      subject.onNext(4) 
      subject.onNext(9) 
    } </pre>
<p class="mce-root CDPAlignLeft CDPAlign">Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="83" width="377" src="assets/60dc06c0-1b42-4e9d-abf1-a7758439f918.jpg"/></div>
<p>In this program, we have used <kbd>subject</kbd> and <kbd>map</kbd>, which we will cover in the later chapters. Here, it is just to show how easy it is in reactive programming to notify the changes. If you look at the program closely, then you'll also find that the code is modular and functional. When we notify <kbd>subject</kbd> with a number, it calls the method in <kbd>map</kbd>, then it calls the method in <kbd>subscribe</kbd> with the return value of the <kbd>map</kbd> method. The <kbd>map</kbd> method checks if the number is even and returns true or false accordingly; in the <kbd>subscribe</kbd> method, we are receiving that value and printing even or odd accordingly. The <kbd>subject.onNext</kbd> method is the way through which we message the new value to the subject, so it can process it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The ReactiveCalculator project</h1>
                </header>
            
            <article>
                
<p>So, let's start with an event with the user input. Go through the following example:</p>
<pre>    fun main(args: Array&lt;String&gt;) { 
      println("Initial Out put with a = 15, b = 10") 
      var calculator:ReactiveCalculator = ReactiveCalculator(15,10) 
      println("Enter a = &lt;number&gt; or b = &lt;number&gt; in separate<br/>      lines\nexit to exit the program") 
      var line:String? 
      do { 
        line = readLine(); 
        calculator.handleInput(line) 
      } while (line!= null &amp;&amp; !line.toLowerCase().contains("exit")) 
    } </pre>
<p>If you run the code, you'll get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="318" width="362" src="assets/db5f48be-584a-4eef-b303-e091c49aaea3.jpg"/></div>
<p>In the <kbd>main</kbd> method, we are not doing much operation except for just listening to the input and passing it to the <kbd>ReactiveCalculator</kbd> class, and doing all other operations in the class itself, thus it is modular. In the later chapters, we will create a separate <kbd>observable</kbd> for the input process, and we will process all user inputs there. We have followed the pull mechanism on the user input for the sake of simplicity, which you will learn to remove in the next chapters. So, let's now take a look at the following <kbd>ReactiveCalculator</kbd> class:</p>
<pre>    class ReactiveCalculator(a:Int, b:Int) { 
      internal val subjectAdd: Subject&lt;Pair&lt;Int,Int&gt;&gt; = <br/>        PublishSubject.create() 
      internal val subjectSub: Subject&lt;Pair&lt;Int,Int&gt;&gt; =<br/>        PublishSubject.create() 
      internal val subjectMult: Subject&lt;Pair&lt;Int,Int&gt;&gt; =<br/>        PublishSubject.create() 
      internal val subjectDiv: Subject&lt;Pair&lt;Int,Int&gt;&gt; =<br/>        PublishSubject.create() 
 
      internal val subjectCalc:Subject&lt;ReactiveCalculator&gt; =<br/>        PublishSubject.create() 
 
      internal var nums:Pair&lt;Int,Int&gt; = Pair(0,0) 
 
      init{ 
        nums = Pair(a,b) 
 
        subjectAdd.map({ it.first+it.second }).subscribe<br/>        ({println("Add = $it")} ) 
        subjectSub.map({ it.first-it.second }).subscribe<br/>        ({println("Substract = $it")} ) 
        subjectMult.map({ it.first*it.second }).subscribe<br/>        ({println("Multiply = $it")} ) 
        subjectDiv.map({ it.first/(it.second*1.0) }).subscribe<br/>        ({println("Divide = $it")} ) 
 
        subjectCalc.subscribe({ 
          with(it) { 
            calculateAddition() 
            calculateSubstraction() 
            calculateMultiplication() 
            calculateDivision() 
          } 
         }) 
 
         subjectCalc.onNext(this) 
        } 
 
        fun calculateAddition() { 
          subjectAdd.onNext(nums) 
        } 
 
        fun calculateSubstraction() { 
          subjectSub.onNext(nums) 
        } 
 
        fun calculateMultiplication() { 
          subjectMult.onNext(nums) 
        } 
 
        fun calculateDivision() { 
          subjectDiv.onNext(nums) 
        } 
 
        fun modifyNumbers (a:Int = nums.first, b: Int = nums.second) { 
          nums = Pair(a,b) 
          subjectCalc.onNext(this) 
       } 
 
       fun handleInput(inputLine:String?) { 
        if(!inputLine.equals("exit")) { 
            val pattern: Pattern = Pattern.compile<br/>            ("([a|b])(?:\\s)?=(?:\\s)?(\\d*)"); 
 
            var a: Int? = null 
            var b: Int? = null 
 
            val matcher: Matcher = pattern.matcher(inputLine) 
 
            if (matcher.matches() &amp;&amp; matcher.group(1) != null <br/>            &amp;&amp;  matcher.group(2) != null) { 
              if(matcher.group(1).toLowerCase().equals("a")){ 
                 a = matcher.group(2).toInt() 
              } else if(matcher.group(1).toLowerCase().equals("b")){ 
                 b = matcher.group(2).toInt() 
               } 
            } 
 
            when { 
              a != null &amp;&amp; b != null -&gt; modifyNumbers(a, b) 
              a != null -&gt; modifyNumbers(a = a) 
              b != null -&gt; modifyNumbers(b = b) 
              else -&gt; println("Invalid Input") 
           } 
        } 
      } 
    }      </pre>
<p>In this program, we have push mechanism (<kbd>observable</kbd> pattern) only to the data, not the event (user input). W<span>hile the initial chapters in this book will show you how to observe on data changes; RxJava also allows you to <kbd>observer</kbd> events (such as user input), we will get them covered during the end of the book while discussing RxJava on Android</span>. So, now, let's understand how this code works.</p>
<p>First, we created a <kbd>ReactiveCalculator</kbd> class, which observes on its data and even on itself; so, whenever its property is modified, it calls all its <kbd>calculate</kbd> methods.</p>
<p>We used <kbd>Pair</kbd> to pair two variables and created four <kbd>subject</kbd> on the <kbd>Pair</kbd> to observe changes on it and then process it; we need four <kbd>subject</kbd> as there are four separate operations. You will also learn to optimize it with just one method in the later chapters.</p>
<p>On the <kbd>calculate</kbd> methods, we are just notifying the subject to process the <kbd>Pair</kbd> and print the new result.</p>
<p>If you focus on the <kbd>map</kbd> methods in both the programs, then you will learn that the <kbd>map</kbd> method takes the value that we passed with <kbd>onNext</kbd> and processes it to come up with a resultant value; that resultant value can be of any data type, and this resultant value is passed to the subscriber to process further and/or show the output.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about what reactive programming is and the reasons we should learn it. We also started with coding. The reactive coding pattern may seem new or somehow uncommon, but it is not that hard; while using it, you just need to declare a few more things.</p>
<p>We learned about <kbd>observable</kbd> and its use. We also got introduced to <kbd>subject</kbd> and <kbd>map</kbd>, which we will learn in depth in the later chapters.</p>
<p>We will continue with <kbd>ReactiveCalculator</kbd> example in the later chapters and see how we can optimize and enhance this program.</p>
<p>The three examples presented in this chapter may seem a bit confusing and complex at first, but they're really simple, and they will become familiar to you as you proceed with this book.</p>
<p>In the next chapter, we will learn more about functional programming and functional interfaces in RxKotlin.</p>


            </article>

            
        </section>
    </body></html>