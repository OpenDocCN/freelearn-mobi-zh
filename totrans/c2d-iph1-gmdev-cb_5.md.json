["```swift\n// TreeSceneMenu\n// The node for our binary tree of scenes\n@interface TreeSceneMenu : CCLayer {\nNSString *name;\n}\n+(id) sceneWithString:(NSString*)str;\n-(id) initWithString:(NSString*)str;\n-(void) goToScene1:(id)sender;\n-(void) goToScene2:(id)sender;\n-(void) back:(id)sender;\n@end\n@implementation TreeSceneMenu\n+(id) sceneWithString:(NSString*)str {\n//Initialize our scene\nCCScene *s = [CCScene node];\nTreeSceneMenu *node = [[TreeSceneMenu alloc] initWithString:str];\n[s addChild:node z:0 tag:0];\nreturn s;\n}\n-(id) initWithString:(NSString*)str {\nif( (self=[super init] )) {\n//Set scene name\nname = [NSString stringWithFormat:@\"%@\",str];\n[name retain];\n/* CODE OMITTED */\n//Buttons to push new scenes onto the stack\nCCMenuItemFont *scene1Item = [CCMenuItemFont itemFromString:[NSString stringWithFormat:@\"Scene %@.1\",name] target:self selector:@selector(goToScene1:)];\nCCMenuItemFont *scene2Item = [CCMenuItemFont itemFromString:[NSString stringWithFormat:@\"Scene %@.2\",name] target:self selector:@selector(goToScene2:)];\n//If we are at the root we \"Quit\" instead of going \"Back\"\nNSString *backStr = @\"Back\";\nif([str isEqualToString:@\"1\"]){\nbackStr = @\"Quit\";\n}\nCCMenuItemFont *backItem = [CCMenuItemFont itemFromString:backStr target:self selector:@selector(back:)];\n//Add menu items\nCCMenu *menu = [CCMenu menuWithItems: scene1Item, scene2Item, backItem, nil];\n[menu alignItemsVertically];\n[self addChild:menu];\n}\nreturn self;\n}\n//Push scene 1\n-(void) goToScene1:(id)sender {\n[[CCDirector sharedDirector] pushScene:[TreeSceneMenu sceneWithString:[NSString stringWithFormat:@\"%@.1\",name]]];\n}\n//Push scene 2\n-(void) goToScene2:(id)sender {\n[[CCDirector sharedDirector] pushScene:[TreeSceneMenu sceneWithString:[NSString stringWithFormat:@\"%@.2\",name]]];\n}\n//Pop scene\n-(void) back:(id)sender {\n[[CCDirector sharedDirector] popScene];\n}\n@end\n//Our Base Recipe\n@interface Ch5_SwitchingScenes : Recipe{}\n-(CCLayer*) runRecipe;\n-(void) goToScene1:(id)sender;\n@end\n@implementation Ch5_SwitchingScenes\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Go to our initial scene\nCCMenuItemFont *goToScene1 = [CCMenuItemFont itemFromString:@\"Go To Scene 1\" target:self selector:@selector(goToScene1:)];\nCCMenu *menu = [CCMenu menuWithItems: goToScene1, nil];\n[menu alignItemsVertically];\n[self addChild:menu];\nreturn self;\n}\nscenesswitching//Push initial scene\n-(void) goToScene1:(id)sender {\n[[CCDirector sharedDirector] pushScene:[TreeSceneMenu sceneWithString:@\"1\"]];\n}\n@end\n\n```", "```swift\n+(id) sceneWithString:(NSString*)str {\n//Initialize our scene\nCCScene *s = [CCScene node];\nTreeSceneMenu *node = [[TreeSceneMenu alloc] initWithString:str];\n[s addChild:node z:0 tag:0];\nreturn s;\n}\n\n```", "```swift\n@implementation TransSceneMenu\n+(id) sceneWithString:(NSString*)str withCurrentTransition:(int)ct {\n//Create scene\nCCScene *s = [CCScene node];\nTransSceneMenu *node = [[TransSceneMenu alloc] initWithString:str withCurrentTransition:ct];\n[s addChild:node z:0 tag:0];\nreturn s;\n}\n-(id) initWithString:(NSString*)str withCurrentTransition:(int)ct {\nif( (self=[super init] )) {\nname = str;\ncurrentTransition = ct;\n/* CODE OMITTED */\n}\nreturn self;\n}\n-(void) prevScene:(id)sender {\ncurrentTransition--;\nif(currentTransition < 0){\ncurrentTransition = numTransitionTypes-1;\n}\n[self loadNewScene];\n}\n-(void) nextScene:(id)sender {\ncurrentTransition++;\nif(currentTransition >= numTransitionTypes){\ncurrentTransition = 0;\n}\n[self loadNewScene];\n}\n-(void) randomScene:(id)sender {\ncurrentTransition = arc4random()%numTransitionTypes;\n[self loadNewScene];\n}\n-(void) loadNewScene {\n[[CCDirector sharedDirector] popScene];\nNSString *className = [NSString stringWithFormat:@\"%@\",transitionTypes[currentTransition]];\nClass clazz = NSClassFromString (className);\n[[CCDirector sharedDirector] pushScene: [clazz transitionWithDuration:1.2f scene:[TransSceneMenu sceneWithString:className withCurrentTransition:currentTransition]]];\n}\n-(void) quit:(id)sender {\n[[CCDirector sharedDirector] popScene];\n}\n@end\n//Our Base Recipe\n@interface Ch5_SceneTransitions : Recipe{}\n-(CCLayer*) runRecipe;\n-(void) viewTransitions:(id)sender;\n@end\n@implementation Ch5_SceneTransitions\n-(CCLayer*) runRecipe {\n[super runRecipe];\nCCMenuItemFont *viewTransitions = [CCMenuItemFont itemFromString:@\"View Transitions\" target:self selector:@selector(viewTransitions:)];\nCCMenu *menu = [CCMenu menuWithItems: viewTransitions, nil];\n[menu alignItemsVertically];\n[self addChild:menu];\nreturn self;\n}\n-(void) viewTransitions:(id)sender {\n[[CCDirector sharedDirector] pushScene:[TransSceneMenu sceneWithString:@\"\" withCurrentTransition:0]];\n}\n@end\n\n```", "```swift\n[[CCDirector sharedDirector] pushScene: [CCTransitionFade transitionWithDuration:1.2f scene:[MyScene scene] withColor:ccWHITE]];\n\n```", "```swift\n//CCDirector.h\n- (void) popSceneWithTransition: (Class)transitionClass duration:(ccTime)t;\n//CCDirector.m\n-(void) popSceneWithTransition: (Class)transitionClass duration:(ccTime)t {\nNSAssert( runningScene_ != nil, @\"A running Scene is needed\");\n[scenesStack_ removeLastObject];\nNSUInteger c = [scenesStack_ count];\nif( c == 0 ) {\n[self end];\n} else {\nCCScene* scene = [transitionClass transitionWithDuration:t scene:[scenesStack_ objectAtIndex:c-1]];\n[scenesStack_ replaceObjectAtIndex:c-1 withObject:scene];\nnextScene_ = scene;\n}\n}\n\n```", "```swift\n@interface MultiplexLayerMenu : CCLayer {}\n+(id) layerWithLayerNumber:(int)layerNumber;\n-(id) initWithLayerNumber:(int)layerNumber;\n-(void) goToLayer:(id)sender;\n@end\n@implementation MultiplexLayerMenu\n+(id) layerWithLayerNumber:(int)layerNumber {\nreturn [[[MultiplexLayerMenu alloc] initWithLayerNumber:layerNumber] autorelease];\n}\nCCLayerMultiplexusing-(id) initWithLayerNumber:(int)layerNumber {\nif( (self=[super init] )) {\n//Random background color\nCCSprite *bg = [CCSprite spriteWithFile:@\"blank.png\"];\nbg.position = ccp(240,160);\n[bg setTextureRect:CGRectMake(0,0,480,320)];\n[bg setColor:ccc3(arc4random()%150,arc4random()%150,arc4random()%150)];\n[self addChild:bg];\n//Layer number as message\nCCLabelBMFont *message = [CCLabelBMFont labelWithString:[NSString stringWithFormat:@\"Layer %i\",layerNumber+1] fntFile:@\"eurostile_30.fnt\"];\nmessage.position = ccp(160,270);\nmessage.scale = 0.75f;\n[message setColor:ccc3(255,255,255)];\n[self addChild:message z:10];\n//Buttons to go to different layers\nCCMenuItemFont *goToLayer1 = [CCMenuItemFont itemFromString:@\"Go To Layer 1\" target:self selector:@selector(goToLayer:)];\nCCMenuItemFont *goToLayer2 = [CCMenuItemFont itemFromString:@\"Go To Layer 2\" target:self selector:@selector(goToLayer:)];\nCCMenuItemFont *goToLayer3 = [CCMenuItemFont itemFromString:@\"Go To Layer 3\" target:self selector:@selector(goToLayer:)];\ngoToLayer1.tag = 0; goToLayer2.tag = 1; goToLayer3.tag = 2;\n//Add menu items\nCCMenu *menu = [CCMenu menuWithItems: goToLayer1, goToLayer2, goToLayer3, nil];\n[menu alignItemsVertically];\n[self addChild:menu];\n}\nreturn self;\n}\n//Switch to a different layer\n-(void) goToLayer:(id)sender {\nCCMenuItemFont *item = (CCMenuItemFont*)sender;\n[(CCLayerMultiplex*)parent_ switchTo:item.tag];\n}\n@end\n@interface Ch5_UsingCCLayerMultiplex : Recipe{}\n-(CCLayer*) runRecipe;\n@end\n@implementation Ch5_UsingCCLayerMultiplex\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Create our multiplex layer with three MultiplexLayerMenu objects\nCCLayerMultiplex *layer = [CCLayerMultiplex layerWithLayers: [MultiplexLayerMenu layerWithLayerNumber:0], [MultiplexLayerMenu layerWithLayerNumber:1],\n[MultiplexLayerMenu layerWithLayerNumber:2], nil];\n[self addChild: layer z:0];\nreturn self;\n}\n@end\n\n```", "```swift\n+(id) layerWithLayers: (CCLayer*) layer, ... NS_REQUIRES_NIL_TERMINATION;\n\n```", "```swift\n@implementation Ch5_UsingCCLabel\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//CCLabelAtlas for fixed-width bitmap fonts\nCCLabelAtlas *labelAtlas = [CCLabelAtlas labelWithString:@\"Atlas Label Test\" charMapFile:@\"tuffy_bold_italic-charmap.png\" itemWidth:48 itemHeight:65 startCharMap:' '];\n[self addChild:labelAtlas z:0];\nlabelAtlas.anchorPoint = ccp(0.5f,0.5f);\nlabelAtlas.scale = 0.5f;\nlabelAtlas.position = ccp(240,220);\n[labelAtlas setColor:ccc3(0,255,0)];\n[labelAtlas runAction:[CCRepeatForever actionWithAction: [CCSequence actions: [CCScaleTo actionWithDuration:1.0f scale:0.5f], [CCScaleTo actionWithDuration:1.0f scale:0.25f], nil]]];\n//CCLabelBMFont for variable-width bitmap fonts using FNT files\nCCLabelBMFont *labelBMFont = [CCLabelBMFont labelWithString:@\"Bitmap Label Test\" fntFile:@\"eurostile_30.fnt\"];\n[self addChild:labelBMFont z:0];\nlabelBMFont.position = ccp(240,160);\nfor(id c in labelBMFont.children){\nCCSprite *child = (CCSprite*)c;\n[child setColor:ccc3(arc4random()%255,arc4random()%255,arc4random()%255)];\n[child runAction:[CCRepeatForever actionWithAction:\n[CCSequence actions: [CCScaleTo actionWithDuration:arc4random()%2+1 scale:1.75f], [CCScaleTo actionWithDuration:arc4random()%2+1 scale:0.75f], nil]\n]];\n}\n//CCLabelTTF for true-type fonts\nCCLabelTTF *labelTTF = [CCLabelTTF labelWithString:@\"True-Type Label Test\" fontName:@\"arial_narrow.otf\" fontSize:32];\n[self addChild:labelTTF z:0];\nlabelTTF.position = ccp(240,100);\n[labelTTF runAction:[CCRepeatForever actionWithAction: [CCSequence actions: [CCScaleTo actionWithDuration:2.0f scale:1.5f], [CCScaleTo actionWithDuration:2.0f scale:0.5f], nil]]];\n[labelTTF setColor:ccc3(0,0,255)];\nreturn self;\n}\n@end\n\n```", "```swift\n@implementation OptionsMenu\n+(id) scene {\n//Create a scene\nCCScene *s = [CCScene node];\nOptionsMenu *node = [OptionsMenu node];\n[s addChild:node z:0 tag:0];\nreturn s;\n}\n-(id) init {\nif( (self=[super init] )) {\n/* CODE OMITTED */\n//Disabled title label for Sound option\nCCMenuItemFont *title1 = [CCMenuItemFont itemFromString:@\"Sound\"];\n[title1 setIsEnabled:NO];\ntitle1.color = ccc3(0,0,0);\n//Toggleable item for Sound option\nCCMenuItemToggle *item1 = [CCMenuItemToggle itemWithTarget:self selector:@selector(soundToggle:) items:\n[CCMenuItemFont itemFromString: @\"On\"], [CCMenuItemFont itemFromString: @\"Off\"], nil];\nCCMenuusing//Disabled title label for Difficulty option\nCCMenuItemFont *title2 = [CCMenuItemFont itemFromString:@\"Difficulty\"];\n[title2 setIsEnabled:NO];\ntitle2.color = ccc3(0,0,0);\n//Toggleable item for Difficulty option\nCCMenuItemToggle *item2 = [CCMenuItemToggle itemWithTarget:self selector:@selector(difficultyToggle:) items:\n[CCMenuItemFont itemFromString: @\"Easy\"], [CCMenuItemFont itemFromString: @\"Medium\"],\n[CCMenuItemFont itemFromString: @\"Hard\"], [CCMenuItemFont itemFromString: @\"Insane\"], nil];\n//Back button\nCCMenuItemFont *back = [CCMenuItemFont itemFromString:@\"Back\" target:self selector:@selector(back:)];\n//Finally, create our menu\nCCMenu *menu = [CCMenu menuWithItems:\ntitle1, title2,\nitem1, item2,\nback, nil]; // 5 items.\n//Align items in columns\n[menu alignItemsInColumns:\n[NSNumber numberWithUnsignedInt:2],\n[NSNumber numberWithUnsignedInt:2],\n[NSNumber numberWithUnsignedInt:1],\nnil\n];\n[self addChild:menu];\n}\nreturn self;\n}\n-(void) back:(id)sender {\n[[CCDirector sharedDirector] popScene];\n}\n//Use the 'selectedIndex' variable to identify the touched item\n-(void) soundToggle: (id) sender {\nCCMenuItem *item = (CCMenuItem*)sender;\n[message setString:[NSString stringWithFormat:@\"Selected Sound Index:%d\", [item selectedIndex]]];\n}\n-(void) difficultyToggle: (id) sender {\nCCMenuItem *item = (CCMenuItem*)sender;\n[message setString:[NSString stringWithFormat:@\"Selected Difficulty Index:%d\", [item selectedIndex]]];\n}\n@end\nCCMenuusing@implementation Ch5_UsingCCMenu\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Set font size/name\n[CCMenuItemFont setFontSize:30];\n[CCMenuItemFont setFontName:@\"Marker Felt\"];\n//Image Button\nCCMenuItemSprite *imageButton = [CCMenuItemSprite itemFromNormalSprite:[CCSprite spriteWithFile:@\"button_unselected.png\"]\nselectedSprite:[CCSprite spriteWithFile:@\"button_selected.png\"] disabledSprite:[CCSprite spriteWithFile:@\"button_disabled.png\"]\ntarget:self selector:@selector(buttonTouched:)];\n//Enable Options Label\nCCLabelBMFont *enableOptionsLabel = [CCLabelBMFont labelWithString:@\"Enable Options\" fntFile:@\"eurostile_30.fnt\"];\nCCMenuItemLabel *enableOptions = [CCMenuItemLabel itemWithLabel:enableOptionsLabel target:self selector:@selector(enableOptions:)];\n//Options Label\noptionsItem = [CCMenuItemFont itemFromString:@\"Options\" target:self selector:@selector(options:)];\noptionsItem.isEnabled = NO;\n//Re-Align Label\nCCMenuItemFont *reAlign = [CCMenuItemFont itemFromString:@\"Re-Align\" target:self selector:@selector(reAlign:)];\n//Add menu items\nmenu = [CCMenu menuWithItems: imageButton, enableOptions, optionsItem, reAlign, nil];\n[menu alignItemsVertically];\n[self addChild:menu];\nreturn self;\n}\n-(void) buttonTouched:(id)sender {\n[message setString:@\"Button touched!\"];\n}\n-(void) options:(id)sender {\n[[CCDirector sharedDirector] pushScene:[OptionsMenu scene]];\n}\n-(void) enableOptions:(id)sender {\noptionsItem.isEnabled = !optionsItem.isEnabled;\n}\n//Randomly re-align our menu\n-(void) reAlign:(id)sender {\nint n = arc4random()%6;\nif(n == 0){\n[menu alignItemsVertically];\n}else if(n == 1){\n[menu alignItemsHorizontally];\n}else if(n == 2){\n[menu alignItemsHorizontallyWithPadding:arc4random()%30];\n}else if(n == 3){\n[menu alignItemsVerticallyWithPadding:arc4random()%30];\n}else if(n == 4){\n[menu alignItemsInColumns: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];\n}else if(n == 5){\n[menu alignItemsInRows: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];\n}\n}\n@end\n\n```", "```swift\n    [CCMenuItemFont setFontSize:30];\n    [CCMenuItemFont setFontName:@\"Marker Felt\"];\n\n    ```", "```swift\n    CCMenuItemFont *reAlign = [CCMenuItemFont itemFromString:@\"Re-Align\" target:self selector:@selector(reAlign:)];\n\n    ```", "```swift\n    CCLabelBMFont *enableOptionsLabel = [CCLabelBMFont labelWithString:@\"Enable Options\" fntFile:@\"eurostile_30.fnt\"];\n    CCMenuItemLabel *enableOptions = [CCMenuItemLabel itemWithLabel:enableOptionsLabel target:self selector:@selector(enableOptions:)];\n\n    ```", "```swift\n    CCMenuItemSprite *imageButton = [CCMenuItemSprite itemFromNormalSprite:[CCSprite spriteWithFile:@\"button_unselected.png\"] selectedSprite:[CCSprite spriteWithFile:@\"button_selected.png\"] disabledSprite:[CCSprite spriteWithFile:@\"button_disabled.png\"] target:self selector:@selector(buttonTouched:)];\n\n    ```", "```swift\n    CCMenuItemToggle *item1 = [CCMenuItemToggle itemWithTarget:self selector:@selector(soundToggle:) items: [CCMenuItemFont itemFromString: @\"On\"], [CCMenuItemFont itemFromString: @\"Off\"], nil];\n\n    ```", "```swift\n    -(void) alignItemsVertically;\n    -(void) alignItemsVerticallyWithPadding:(float) padding;\n    -(void) alignItemsHorizontally;\n    -(void) alignItemsHorizontallyWithPadding: (float) padding;\n\n    ```", "```swift\n    [menu alignItemsInColumns: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];\n    [menu alignItemsInRows: [NSNumber numberWithUnsignedInt:2], [NSNumber numberWithUnsignedInt:2], nil];\n\n    ```", "```swift\n#import \"ShadowLabel.h\"\n@implementation Ch5_ShadowedLabels\n-(CCLayer*) runRecipe {\n[super runRecipe];\n/* Draw four different shadowed labels using 4 different fonts */\n[CCMenuItemFont setFontSize:47];\n[CCMenuItemFont setFontName:@\"Georgia\"];\n[self label:@\"Label 1\" at:ccp(-120,50) color:ccc3(0,50,255) activeColor:ccc3(0,200,255) selector:@selector(labelTouched:) tag:1];\n[CCMenuItemFont setFontSize:40];\n[CCMenuItemFont setFontName:@\"Marker Felt\"];\n[self label:@\"Label 2\" at:ccp(120,50) color:ccc3(255,128,0) activeColor:ccc3(255,255,0) selector:@selector(labelTouched:) tag:2];\n[CCMenuItemFont setFontSize:45];\n[CCMenuItemFont setFontName:@\"Arial\"];\n[self label:@\"Label 3\" at:ccp(-120,-50) color:ccc3(0,128,0) activeColor:ccc3(0,255,0) selector:@selector(labelTouched:) tag:3];\n[CCMenuItemFont setFontSize:50];\n[CCMenuItemFont setFontName:@\"Courier New\"];\n[self label:@\"Label 4\" at:ccp(120,-50) color:ccc3(255,0,0) activeColor:ccc3(255,255,0) selector:@selector(labelTouched:) tag:4];\nreturn self;\n}\n//Label creation helper method\n-(void) label:(NSString*)s at:(CGPoint)p color:(ccColor3B)col activeColor:(ccColor3B)activeCol selector:(SEL)sel tag:(int)tag {\nShadowLabel *label = [ShadowLabel labelFromString:s target:self selector:sel];\nlabel.position = p;\nlabel.color = col;\nlabel.activeColor = activeCol;\nlabel.tag = tag;\nCCMenu *menu = [CCMenu menuWithItems: label.shadow, label, nil];\n[self addChild:menu];\n}\n//Label touch callback\n-(void) labelTouched:(id)sender {\nShadowLabel *label = (ShadowLabel*)sender;\n[self showMessage:[NSString stringWithFormat:@\"Pressed label %d\",label.tag]];\n}\n@end\n\n```", "```swift\n@interface Ch5_UIKitAlerts : Recipe <UIAlertViewDelegate>{}\n-(CCLayer*) runRecipe;\n-(void)showPieAlert;\n-(void)alertView:(UIAlertView*)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;\n@end\n@implementation Ch5_UIKitAlerts\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[self showPieAlert];\nreturn self;\n}\n//Shows a UIAlertView\n-(void)showPieAlert {\nUIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\"Do You Like Pie?\" message:@\"\" delegate:self cancelButtonTitle:@\"Cancel\" otherButtonTitles:@\"Yes\",@\"No\",nil];\n[alert show];\n[alert release];\nUIKit alert dialogsabout}\n//AlertView callback\n-(void)alertView:(UIAlertView *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex {\nif(buttonIndex == 0) {\n[self showMessage:@\"You remain tight lipped on\\nthe 'pie' question.\"];\n}else if(buttonIndex == 1){\n[self showMessage:@\"Ah yes, another lover of pie.\"];\n}else if(buttonIndex == 2){\n[self showMessage:@\"You don't like pie?\\nWhat's wrong with you?\"];\n}\n}\n@end\n\n```", "```swift\n    -(void)alertView:(UIAlertView *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;\n\n    ```", "```swift\n#import \"CCUIViewWrapper.h\"\n@implementation Ch5_WrappingUIKit\n-(CCLayer*) runRecipe {\n[super runRecipe];\n[self addSpinningButton];\n[self addScrollView];\nreturn self;\n}\n-(void) addSpinningButton {\n//Label\nCCLabelBMFont *label = [CCLabelBMFont labelWithString:@\"UIButton\" fntFile:@\"eurostile_30.fnt\"];\nlabel.position = ccp(350,220);\nlabel.scale = 0.75f;\n[label setColor:ccc3(255,255,255)];\n[self addChild:label z:10];\n//Our UIButton example\nUIButton *button = [UIButton buttonWithType:UIButtonTypeRoundedRect];\n[button addTarget:self action:@selector(buttonTapped:) forControlEvents:UIControlEventTouchDown];\n[button setTitle:@\"Touch Me!\" forState:UIControlStateNormal];\nbutton.frame = CGRectMake(0.0, 0.0, 120.0, 40.0);\n//Wrap the UIButton using CCUIViewWrapper\nCCUIViewWrapper *wrapper = [CCUIViewWrapper wrapperForUIView:button];\n[self addChild:wrapper];\nwrapper.position = ccp(90,140);\n[wrapper runAction:[CCRepeatForever actionWithAction:[CCRotateBy actionWithDuration:5.0f angle:360]]];\n}\n-(void) addScrollView {\n//Label\nCCLabelBMFont *label = [CCLabelBMFont labelWithString:@\"UIScrollView\" fntFile:@\"eurostile_30.fnt\"];\nlabel.position = ccp(100,220);\nlabel.scale = 0.75f;\n[label setColor:ccc3(255,255,255)];\n[self addChild:label z:10];\n//Create a simple UIScrollView with colored UIViews\nCGPoint viewSize = ccp(200.0f,100.0f);\nCGPoint nodeSize = ccp(200.0f,50.0f);\nint nodeCount = 10;\n//Init scrollview\nUIScrollView *scrollview = [[UIScrollView alloc] initWithFrame: CGRectMake(0, 0, viewSize.x, viewSize.y)];\n//Add nodes\nfor (int i = 0; i <nodeCount; i++){\nCGFloat y = i * nodeSize.y;\nUIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, y, nodeSize.x, nodeSize.y)];\nview.backgroundColor = [UIColor colorWithRed:(CGFloat)random()/(CGFloat)RAND_MAX green:(CGFloat)random()/(CGFloat)RAND_MAX blue:(CGFloat)random()/(CGFloat)RAND_MAX alpha:1.0];\n[scrollview addSubview:view];\n[view release];\n}\nscrollview.contentSize = CGSizeMake(viewSize.x, viewSize.y * nodeCount/2);\n//Wrap the UIScrollView object using CCUIViewWrapper\nCCUIViewWrapper *wrapper = [CCUIViewWrapper wrapperForUIView:scrollview];\n[self addChild:wrapper];\nwrapper.rotation = -90;\nwrapper.position = ccp(50,400);\n}\n-(void) buttonTapped:(id)sender {\n[self showMessage:@\"Button tapped\"];\n}\n@end\n\n```", "```swift\nCCUIViewWrapper *wrapper = [CCUIViewWrapper wrapperForUIView:button];\n\n```", "```swift\n    #define GAME_AUTOROTATION kGameAutorotationNone\n\n    ```", "```swift\n#import \"GameMenuWindow.h\"\n@implementation Ch5_MenuWindows\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//Initialization\nwindows = [[[NSMutableArray alloc] init] autorelease];\nCCNode *windowContainer = [[CCNode alloc] init];\n/* Create three menu windows with randomized positions */\nGameMenuWindow *window1 = [GameMenuWindow windowWithTitle:@\"Window 1\" size:CGSizeMake(arc4random()%200+120,arc4random()%100+50)];\nwindow1.position = ccp(arc4random()%100+150,arc4random()%140+100);\n[windowContainer addChild:window1 z:1];\n[windows addObject:window1];\n/* CODE OMITTED */\n//Sort our window array by zOrder\n//This allows ordered touching\nNSSortDescriptor *sorter = [[NSSortDescriptor alloc] initWithKey:@\"self.zOrder\" ascending:NO];\n[windows sortUsingDescriptors:[NSArray arrayWithObject:sorter]];\n//Add window container node\n[self addChild:windowContainer];\nreturn self;\n}\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//Sort our window array before we process a touch\nNSSortDescriptor *sorter = [[NSSortDescriptor alloc] initWithKey:@\"self.zOrder\" ascending:NO];\n[windows sortUsingDescriptors:[NSArray arrayWithObject:sorter]];\n//Grab the window by touching the top bar. Otherwise, merely bring the window to the front\nfor(GameMenuWindow* w in windows){\nif(pointIsInRect(point, [w titleBarRect])){\n[w ccTouchesBegan:touches withEvent:event];\nreturn;\n}else if(pointIsInRect(point, [w rect])){\n[w bringToFront];\nreturn;\n}\n}\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//If we touched a window them we can drag it\nfor(GameMenuWindow* w in windows){\nif(w.isTouched){\n[w ccTouchesMoved:touches withEvent:event];\n}\n}\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//End a touch if neccessary\nfor(GameMenuWindow* w in windows){\nif(w.isTouched){\n[w ccTouchesEnded:touches withEvent:event];\n}\n}\n}\n@end\n\n```", "```swift\n    NSSortDescriptor *sorter = [[NSSortDescriptor alloc] initWithKey:@\"self.zOrder\" ascending:NO];\n    [windows sortUsingDescriptors:[NSArray arrayWithObject:sorter]];\n\n    ```", "```swift\n#import \"LoopingMenu.h\"\n@implementation Ch5_HorizScrollMenu\n-(CCLayer*) runRecipe {\n[super runRecipe];\nmessage.position = ccp(70,270);\n/* Create 5 default sprites and 'selected' sprites */\nCCSprite *book1 = [CCSprite spriteWithFile:@\"book1.jpg\"];\nCCSprite *book2 = [CCSprite spriteWithFile:@\"book2.jpg\"];\n/* CODE OMITTED */\nCCSprite *book1_selected = [CCSprite spriteWithFile:@\"book1.jpg\"]; book1_selected.color = ccc3(128,128,180); [book1_selected setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];\nCCSprite *book2_selected = [CCSprite spriteWithFile:@\"book2.jpg\"]; book2_selected.color = ccc3(128,128,180); [book2_selected setBlendFunc: (ccBlendFunc) { GL_ONE, GL_ONE }];\n/* CODE OMITTED */\n/* Create CCMenuItemSprites */\nCCMenuItemSprite* item1 = [CCMenuItemSprite itemFromNormalSprite:book1 selectedSprite:book1_selected target:self selector:@selector(bookClicked:)];\nitem1.tag = 1;\nCCMenuItemSprite* item2 = [CCMenuItemSprite itemFromNormalSprite:book2 selectedSprite:book2_selected target:self selector:@selector(bookClicked:)];\nitem2.tag = 2;\n/* CODE OMITTED */\n//Initialize LoopingMenu and add menu items\nLoopingMenu *menu = [LoopingMenu menuWithItems:item1, item2, item3, item4, item5, nil];\nmenu.position = ccp(240, 150);\n[menu alignItemsHorizontallyWithPadding:0];\n//Add LoopingMenu to scene\n[self addChild:menu];\nreturn self;\n}\n//Book clicked callback\n-(void) bookClicked:(id)sender {\nCCMenuItemSprite *sprite = (CCMenuItemSprite*)sender;\n[self showMessage:[NSString stringWithFormat:@\"Book clicked: %d\", sprite.tag]];\n}\n@end\n\n```", "```swift\nLoopingMenu *menu = [LoopingMenu menuWithItems:item1, item2, item3, item4, item5, nil];\n\n```", "```swift\n#import \"SlidingMenuGrid.h\"\n@implementation Ch5_VertSlidingMenuGrid\n-(CCLayer*) runRecipe {\n[super runRecipe];\nmessage.position = ccp(200,270);\n[self showMessage:@\"Tap a button or slide the menu grid up or down.\"];\n//Init item array\nNSMutableArray* allItems = [[[NSMutableArray alloc] init] autorelease];\n/* Create 45 CCMenuItemSprite objects with tags, callback methods and randomized colors */\nfor (int i = 1; i <= 45; ++i) {\nCCSprite* normalSprite = [CCSprite spriteWithFile:@\"sliding_menu_button_0.png\"];\nCCSprite* selectedSprite = [CCSprite spriteWithFile:@\"sliding_menu_button_1.png\"];\nccColor3B color = [self randomColor];\nnormalSprite.color = color;\nselectedSprite.color = color;\nCCMenuItemSprite* item = [CCMenuItemSprite itemFromNormalSprite:normalSprite selectedSprite:selectedSprite target:self selector:@selector(buttonClicked:)];\nitem.tag = i;\n//Add each item to array\n[allItems addObject:item];\n}\n//Init SlidingMenuGrid object with array and some other information\nSlidingMenuGrid* menuGrid = [SlidingMenuGrid menuWithArray:allItems cols:5 rows:3 position:ccp(70.f,220.f) padding:ccp(90.f,80.f) verticalPages:true];\n[self addChild:menuGrid z:1];\nreturn self;\n}\n//Button clicked callback\n-(void) buttonClicked:(id)sender {\nCCMenuItemSprite *sprite = (CCMenuItemSprite*)sender;\n[self showMessage:[NSString stringWithFormat:@\"Button clicked: %d\", sprite.tag]];\n}\n//Random base color method\n-(ccColor3B) randomColor {\n/* CODE OMITTED */\n}\n@end\n\n```", "```swift\nSlidingMenuGrid* menuGrid = [SlidingMenuGrid menuWithArray:allItems cols:5 rows:3 position:ccp(70.f,220.f) padding:ccp(90.f,80.f) verticalPages:true];\n\n```", "```swift\n/* The actual 'game' class where we display the textures we loaded asynchronously */\n@implementation GameScene\n+(id) sceneWithLevel:(NSString*)str {\n//Create our scene\nCCScene *s = [CCScene node];\nGameScene *node = [[GameScene alloc] initWithLevel:str];\n[s addChild:node z:0 tag:0];\nreturn s;\n}\n-(id) initWithLevel:(NSString*)str {\nif( (self=[super init] )) {\n//Load our level\n[self loadLevel:str];\n/* CODE OMITTED */\n//Create a label to indicate that this is the loaded level\nCCLabelBMFont *label = [CCLabelBMFont labelWithString:@\"The Loaded Level:\" fntFile:@\"eurostile_30.fnt\"];\n/* CODE OMITTED */\n//Quit button\nCCMenuItemFont *quitItem = [CCMenuItemFont itemFromString:@\"Quit\" target:self selector:@selector(quit:)];\nCCMenu *menu = [CCMenu menuWithItems: quitItem, nil];\nmenu.position = ccp(430,300);\n[self addChild:menu z:10];\n}\nreturn self;\n}\n//Quit callback\n-(void) quit:(id)sender {\n[[CCDirector sharedDirector] popScene];\n//Clear all loaded textures (including ones from other recipes)\n[[CCTextureCache sharedTextureCache] removeAllTextures];\n}\n//Load level file and process sprites\n-(void) loadLevel:(NSString*)str {\nNSString *jsonString = [[NSString alloc] initWithContentsOfFile:getActualPath(str) encoding:NSUTF8StringEncoding error:nil];\nNSData *jsonData = [jsonString dataUsingEncoding:NSUTF32BigEndianStringEncoding];\nNSDictionary *dict = [[CJSONDeserializer deserializer] deserializeAsDictionary:jsonData error:nil];\nNSArray *nodes = [dict objectForKey:@\"nodes\"];\nfor (id node in nodes) {\nif([[node objectForKey:@\"type\"] isEqualToString:@\"spriteFile\"]){\n[self processSpriteFile:node];\n}\n}\n}\n-(void) processSpriteFile:(NSDictionary*)node {\n//Init the sprite\nNSString *file = [node objectForKey:@\"file\"];\nCCSprite *sprite = [CCSprite spriteWithFile:file];\n//Set sprite position\nsprite.position = ccp(arc4random()%480, arc4random()%200);\n//Each numeric value is an NSString or NSNumber that must be cast into a float\nsprite.scale = [[node objectForKey:@\"scale\"] floatValue];\n//Set the anchor point so objects are positioned from the bottom-up\nsprite.anchorPoint = ccp(0.5,0);\n//Finally, add the sprite\n[self addChild:sprite z:2];\n}\n@end\n@implementation LoadingScene\n+(id) sceneWithLevel:(NSString*)str {\n//Create our scene\nCCScene *s = [CCScene node];\nLoadingScene *node = [[LoadingScene alloc] initWithLevel:str];\n[s addChild:node z:0 tag:0];\nreturn s;\n}\n-(id) initWithLevel:(NSString*)str {\nif( (self=[super init] )) {\n//Set levelStr\nlevelStr = str;\n[levelStr retain];\n/* CODE OMITTED */\n//Set the initial loading message\nloadingMessage = [CCLabelBMFont labelWithString:@\"Loading, Please Wait...0%\" fntFile:@\"eurostile_30.fnt\"];\n/* CODE OMITTED */\n//Create an initial '0%' loading bar\nloadingBar = [CCSprite spriteWithFile:@\"blank.png\"];\nloadingBar.color = ccc3(255,0,0);\n[loadingBar setTextureRect:CGRectMake(0,0,10,25)];\nloadingBar.position = ccp(50,50);\nloadingBar.anchorPoint = ccp(0,0);\n[self addChild:loadingBar z:10];\n//Start level pre-load\n[self preloadLevel];\n}\nreturn self;\n}\n//Asynchronously load all required textures\n-(void) preloadLevel {\nnodesLoaded = 0;\nNSString *jsonString = [[NSString alloc] initWithContentsOfFile:getActualPath(levelStr) encoding:NSUTF8StringEncoding error:nil];\nNSData *jsonData = [jsonString dataUsingEncoding:NSUTF32BigEndianStringEncoding];\nNSDictionary *dict = [[CJSONDeserializer deserializer] deserializeAsDictionary:jsonData error:nil];\nNSArray *nodes = [dict objectForKey:@\"nodes\"];\nnodesToLoad = [nodes count];\nfor (id node in nodes) {\nif([[node objectForKey:@\"type\"] isEqualToString:@\"spriteFile\"]){\n[self preloadSpriteFile:node];\n}\n}\n}\n//Asynchronously load a texture and call the specified callback when finished\n-(void) preloadSpriteFile:(NSDictionary*)node {\nNSString *file = [node objectForKey:@\"file\"];\n[[CCTextureCache sharedTextureCache] addImageAsync:file target:self selector:@selector(nodeLoaded:)];\n}\n//The loading callback\n//This increments nodesLoaded and reloads the indicators accordingly\n-(void) nodeLoaded:(id)sender {\nnodesLoaded++;\nfloat percentComplete = 100.0f * (nodesLoaded / nodesToLoad);\n[loadingMessage setString:[NSString stringWithFormat:@\"Loading, Please Wait...%d%@\", (int)percentComplete, @\"%\"]];\n//When we are 100% complete we run the game\nif(percentComplete >= 100.0f){\n[self runAction:[CCSequence actions: [CCDelayTime actionWithDuration:0.25f], [CCCallFunc actionWithTarget:self selector:@selector(runGame:)], nil]];\n}\n//Grow the loading bar\n[loadingBar setTextureRect:CGRectMake(0,0,percentComplete*4,25)];\n}\n//First pop this scene then load the game scene\n-(void) runGame:(id)sender {\n[[CCDirector sharedDirector] popScene];\n[[CCDirector sharedDirector] pushScene:[GameScene sceneWithLevel:@\"level1.json\"]];\n}\n@end\n@implementation Ch5_LoadingScreen\n-(CCLayer*) runRecipe {\n[super runRecipe];\n//The load level button\nCCMenuItemFont *loadLevelItem = [CCMenuItemFont itemFromString:@\"Load Level\" target:self selector:@selector(loadLevel:)];\nCCMenu *menu = [CCMenu menuWithItems: loadLevelItem, nil];\nmenu.position = ccp(240,160);\n[self addChild:menu];\nreturn self;\n}\n//Callback to load the level\n-(void) loadLevel:(id)sender {\n[[CCDirector sharedDirector] pushScene:[LoadingScene sceneWithLevel:@\"level1.json\"]];\n}\n@end\n\n```", "```swift\n    [[CCTextureCache sharedTextureCache] addImageAsync:file target:self selector:@selector(nodeLoaded:)];\n\n    ```", "```swift\n    [[CCTextureCache sharedTextureCache] removeAllTextures];\n\n    ```", "```swift\n    -(void) removeTexture: (CCTexture2D*) tex;\n    -(void) removeTextureForKey: (NSString*) textureKeyName;\n\n    ```", "```swift\n#import \"Minimap.h\"\n@implementation Ch5_Minimap\n-(CCLayer*) runRecipe {\n//Initialize the Minimap object\nminimap = [[[Minimap alloc] init] autorelease];\nminimap.position = ccp(300,140);\n[self addChild:minimap z:10];\n//Run our top-down isometric game recipe\n[super runRecipe];\n//Add trees as static objects\nfor(id t in trees){\nGameObject *tree = (GameObject*)t;\n[minimap addStaticObject:ccp(tree.body->GetPosition().x, tree.body->GetPosition().y)];\n}\nreturn self;\n}\n-(void) step:(ccTime)delta {\n[super step:delta];\n//Set the actor position\n[minimap setActor: ccp(gunman.body->GetPosition().x, gunman.body->GetPosition().y)];\n//Set individual projectile positions\nfor(id b in balls){\nGameObject *ball = (GameObject*)b;\n[minimap setProjectile:ccp(ball.body->GetPosition().x, ball.body->GetPosition().y) withKey:[NSString stringWithFormat:@\"%d\", ball.tag]];\n}\n}\n//We override this method to automatically add walls to the minimap\n-(void) addBrickWallFrom:(CGPoint)p1 to:(CGPoint)p2 height:(float)height {\n//Convert wall vertex positions to the properly scaled Box2D coordinates\nCGPoint vert1 = ccp(p1.x/PTM_RATIO,p1.y/PTM_RATIO/PERSPECTIVE_RATIO);\nCGPoint vert2 = ccp(p2.x/PTM_RATIO,p2.y/PTM_RATIO/PERSPECTIVE_RATIO);\n//Add both wall vertices\n[minimap addWallWithVertex1:vert1 withVertex2:vert2];\n[super addBrickWallFrom:p1 to:p2 height:height];\n}\n@end\n\n```"]