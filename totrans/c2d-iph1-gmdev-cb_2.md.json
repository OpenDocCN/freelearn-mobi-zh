["```swift\n//ColorTouchSprite.h\nenum { TS_NONE, TS_TAP, TS_HOLD, TS_DRAG };\n@interface ColorTouchSprite : CCSprite\n{\n@public\nfloat holdTime; //How long have we held down on this?\nint touchedState; //Current touched state\nbool isTouched; //Are we touching this currently?\nfloat lastMoved; //How long has it been since we moved this?\nCGPoint lastTouchedPoint; //Where did we last touch?\nconst float releaseThreshold = 1.0f; //How long before we recognize a release\nconst float holdThreshold = 0.2f; //How long before a tap turns into a hold\nconst float lastMovedThreshold = 0.5f; //How long before we consider you to be 'not moving'\nconst int dragThreshold = 3; //We have a drag threshold of 3 pixels.\n}\n@end\n@implementation ColorTouchSprite\n@synthesize touchedState;\n-(id) init {\nholdTime = 0; lastMoved = 0; touchedState = TS_NONE;\nisTouched = NO; lastTouchedPoint = ccp(0,0);\n[self schedule:@selector(step:)];\nreturn [super init];\n}\n-(void) step:(ccTime)dt {\n//We use holdTime to determine the difference between a tap and a hold\nif(isTouched){\nholdTime += dt; lastMoved += dt;\n}else{\nholdTime += dt;\nif(holdTime > releaseThreshold){\ntouchedState = TS_NONE;\n}\n}\n//If you are holding and you haven't moved in a while change the state\nif(holdTime > holdThreshold && isTouched && lastMoved > lastMovedThreshold){\ntouchedState = TS_HOLD;\n}\n}\n/* Used to determine whether or not we touched this object */\n- (CGRect) rect {\nfloat scaleMod = 1.0f;\nfloat w = [self contentSize].width * [self scale] * scaleMod;\nfloat h = [self contentSize].height * [self scale] * scaleMod;\nCGPoint point = CGPointMake([self position].x - (w/2), [self position].y - (h/2));\nreturn CGRectMake(point.x, point.y, w, h);\n}\n/* Process touches */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\nisTouched = YES; holdTime = 0; touchedState = TS_NONE;\nlastTouchedPoint = point;\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\nif(!isTouched){ return; }\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\nif(touchedState == TS_DRAG || distanceBetweenPoints(lastTouchedPoint, point) > dragThreshold){\ntouchedState = TS_DRAG;\nself.position = point;\nlastMoved = 0;\n}\nlastTouchedPoint = point;\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\nif(!isTouched){ return; }\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//A short hold time after a touch ended means a tap.\nif(holdTime < 10){\ntouchedState = TS_TAP;\n}\nholdTime = 0;\nisTouched = NO;\nlastTouchedPoint = point;\n}\n@end\n#import \"Helpers.h\"\n@implementation Ch2_TapHoldDragInput\n-(CCLayer*) runRecipe {\nself.isTouchEnabled = YES;\n//Our message sprite\nmessage = [CCLabelBMFont labelWithString:@\"Tap, hold or drag the square.\" fntFile:@\"eurostile_30.fnt\"];\nmessage.position = ccp(240,260);\nmessage.scale = 0.75f;\n[self addChild:message];\n//Init the ColorTouchSprite\ncolorTouchSprite = [ColorTouchSprite spriteWithFile:@\"blank.png\"];\ncolorTouchSprite.position = ccp(240,160);\n[colorTouchSprite setTextureRect:CGRectMake(0,0,100,100)];\n[self addChild:colorTouchSprite];\n[self schedule:@selector(step)];\nreturn self;\n}\n/* Process touch events */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//Helper function 'pointIsInRect' is defined in Helpers.h\nif(pointIsInRect(point, [colorTouchSprite rect])){\n[colorTouchSprite ccTouchesBegan:touches withEvent:event];\n}\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n@end\n\n```", "```swift\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;\n\n```", "```swift\n#import \"ColorTouchSprite.h\"\n@implementation Ch2_DepthTestingInput\n-(CCLayer*) runRecipe {\n//Init the ColorTouchSprites\n[self initSprites];\nreturn self;\n}\n-(void) initSprites {\nsprites = [[NSMutableArray alloc] init];\n//We add 10 randomly colored sprites\nfor(int x=0; x<10; x++){\nCCSprite *sprite = [ColorTouchSprite spriteWithFile:@\"blank.png\"];\n/* CODE OMITTED */\n}\n}\n/* Process touch events */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//Process input for all sprites\nfor(id sprite in sprites){\nif(pointIsInRect(point, [sprite rect])){\n//Swallow the input\n[sprite ccTouchesBegan:touches withEvent:event];\nreturn;\n}\n}\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//Process input for all sprites\nfor(id sprite in sprites){\nif(pointIsInRect(point, [sprite rect])){\n[sprite ccTouchesMoved:touches withEvent:event];\n}\n}\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//Process input for all sprites\nfor(id sprite in sprites){\n//End all input when you lift up your finger\n[sprite ccTouchesEnded:touches withEvent:event];\n}\n}\n@end\n\n```", "```swift\n//TouchableSprite.h\n@interface TouchableSprite : CCSprite\n{\n@public\nbool pressed; //Is this sprite pressed\nNSUInteger touchHash; //Used to identify individual touches\n}\n@end\n@implementation TouchableSprite\n- (bool)checkTouchWithPoint:(CGPoint)point {\nif(pointIsInRect(point, [self rect])){\nreturn YES;\n}else{\nreturn NO;\n}\n}\n- (CGRect) rect {\n//We set our scale mod to make sprite easier to press.\n//This also lets us press 2 sprites with 1 touch if they are sufficiently close.\nfloat scaleMod = 1.5f;\nfloat w = [self contentSize].width * [self scale] * scaleMod;\nfloat h = [self contentSize].height * [self scale] * scaleMod;\nCGPoint point = CGPointMake([self position].x - (w/2), [self position].y - (h/2));\nreturn CGRectMake(point.x, point.y, w, h);\n}\n- (void)ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//We use circle collision for our buttons\nif(pointIsInCircle(point, self.position, self.rect.size.width/2)){\ntouchHash = [touch hash];\n[self processTouch:point];\n}\n}\n- (void)ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\nif(pointIsInCircle(point, self.position, self.rect.size.width/2)){\nif(touchHash == [touch hash]){ //If we moved on this sprite\n[self processTouch:point];\n}else if(!pressed){ //If a new touch moves onto this sprite\ntouchHash = [touch hash];\n[self processTouch:point];\n}\n}else if(touchHash == [touch hash]){ //If we moved off of this sprite\n[self processRelease];\n}\n}\n- (void)ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\nif(touchHash == [touch hash]){ //If the touch which pressed this sprite ended we release\n[self processRelease];\n}\n}\n- (void)processTouch:(CGPoint)point {\npressed = YES;\n}\nbuttonscreating- (void)processRelease {\npressed = NO;\n}\n@end\n//GameButton.h\n@interface GameButton : TouchableSprite {\n@public\nNSString* upSpriteFrame;\nNSString* downSpriteFrame;\nNSString* name;\n}\n@end\n@implementation GameButton\n- (void)processTouch:(CGPoint)point {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[self setDisplayFrame:[cache spriteFrameByName:downSpriteFrame]];\npressed = true;\n[self setColor:ccc3(255,200,200)];\n}\n- (void)processRelease {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[self setDisplayFrame:[cache spriteFrameByName:upSpriteFrame]];\npressed = false;\n[self setColor:ccc3(255,255,255)];\n}\n@end\n@implementation Ch2_Buttons\n-(CCLayer*) runRecipe {\n//Init buttons data structure\nbuttons = [[NSMutableArray alloc] init];\n//Create buttons\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"dpad_buttons.plist\"];\n[self createButtonWithPosition:ccp(350,50) withUpFrame:@\"b_button_up.png\" withDownFrame:@\"b_button_down.png\" withName:@\"B\"];\n/* CODE OMITTED */\n//Schedule step method\n[self schedule:@selector(step)];\nreturn self;\n}\n/* Display pressed buttons */\n-(void) step {\n[message setString:@\"Buttons pressed:\"];\nfor(GameButton *b in buttons){\nif(b.pressed){\n[message setString:[NSString stringWithFormat:@\"%@ %@\",message.string,b.name]];\n}\n}\n}\n/* Button creation shortcut method */\n-(void) createButtonWithPosition:(CGPoint)position withUpFrame:(NSString*)upFrame withDownFrame:(NSString*)downFrame withName:(NSString*)name {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\nGameButton *button = [[GameButton alloc] init];\nbutton.position = position;\n[button setUpSpriteFrame:upFrame];\n[button setDownSpriteFrame:downFrame];\n[button setDisplayFrame:[cache spriteFrameByName:[button upSpriteFrame]]];\nbutton.name = name;\n[self addChild:button];\n[buttons addObject:button];\n}\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//Pass all touchesBegan events to GameButton instances\nfor(GameButton *b in buttons){\n[b ccTouchesBegan:touches withEvent:event];\n}\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n@end\n\n```", "```swift\n    [window setMultipleTouchEnabled:YES];\n\n    ```", "```swift\n#import \"TouchableSprite.h\"\n@interface DPad : TouchableSprite {\n@public\nCGPoint pressedVector;\nint direction;\n}\n@end\n@implementation DPad\n-(id)init {\nself = [super init];\nif (self != nil) {\npressedVector = ccp(0,0);\ndirection = DPAD_NO_DIRECTION;\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"dpad_buttons.plist\"];\n//Set the sprite display frame\n[self setDisplayFrame:[cache spriteFrameByName:@\"d_pad_normal.png\"]];\n}\nreturn self;\n}\n/* Process DPad touch */\n- (void)processTouch:(CGPoint)point {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n//Set a color visual cue if pressed\n[self setColor:ccc3(255,200,200)];\npressed = true;\nCGPoint center = CGPointMake( self.rect.origin.x+self.rect.size.width/2, self.rect.origin.y+self.rect.size.height/2 );\n//Process center dead zone\nif(distanceBetweenPoints(point, center) < self.rect.size.width/10){\n[self setDisplayFrame:[cache spriteFrameByName:@\"d_pad_normal.png\"]];\nself.rotation = 0;\npressedVector = ccp(0,0);\ndirection = DPAD_NO_DIRECTION;\nreturn;\n}\n//Process direction\nfloat radians = vectorToRadians( CGPointMake(point.x-center.x, point.y-center.y) );\nfloat degrees = radiansToDegrees(radians) + 90;\nfloat sin45 = 0.7071067812f;\nif(degrees >= 337.5 || degrees < 22.5){\n[self setDisplayFrame:[cache spriteFrameByName:@\"d_pad_horizontal.png\"]];\nself.rotation = 180; pressedVector = ccp(-1,0); direction = DPAD_LEFT;\n}else if(degrees >= 22.5 && degrees < 67.5){\n[self setDisplayFrame:[cache spriteFrameByName:@\"d_pad_diagonal.png\"]];\nself.rotation = -90; pressedVector = ccp(-sin45,sin45); direction = DPAD_UP_LEFT;\n}/* CODE OMITTED */\n}\n/* Process DPad release */\n- (void)processRelease {\n[self setColor:ccc3(255,255,255)];\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[self setDisplayFrame:[cache spriteFrameByName:@\"d_pad_normal.png\"]];\nself.rotation = 0;\npressed = false;\npressedVector = ccp(0,0);\ndirection = DPAD_NO_DIRECTION;\n}\n@end\n@implementation Ch2_DPad\n-(CCLayer*) runRecipe {\n//Add gunman sprites\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"gunman.plist\"];\n//Initialize gunman\ngunman = [SimpleAnimObject spriteWithSpriteFrame:[cache spriteFrameByName:@\"gunman_stand_down.png\"]];\ngunman.position = ccp(240,160);\n[self addChild:gunman];\ngunmanDirection = DPAD_DOWN;\n//Initialize DPad\n[cache addSpriteFramesWithFile:@\"dpad_buttons.plist\"];\ndPad = [[DPad alloc] init];\ndPad.position = ccp(100,100);\n[self addChild:dPad];\n[self schedule:@selector(step:)];\nreturn self;\n}\n-(void) step:(ccTime)delta {\n//We reset the animation if the gunman changes direction\nif(dPad.direction != DPAD_NO_DIRECTION){\nif(gunmanDirection != dPad.direction){\nresetAnimation = YES;\ngunmanDirection = dPad.direction;\n}\n}\nif(gunman.velocity.x != dPad.pressedVector.x*2 || gunman.velocity.y != dPad.pressedVector.y*2){\ngunman.velocity = ccp(dPad.pressedVector.x*2, dPad.pressedVector.y*2);\nresetAnimation = YES;\n}\n//Update gunman position\n[gunman update:delta];\n//Re-animate if necessary\nif(resetAnimation){\n[self animateGunman];\n}\ndirectional padcreating}\n-(void) animateGunman {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n/* Animate our gunman */\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"gunman_anim\" delay:0.15f];\nNSString *direction;\nbool flipX = NO;\nbool moving = YES;\nif(gunman.velocity.x == 0 && gunman.velocity.y == 0){ moving = NO; }\nif(gunmanDirection == DPAD_LEFT){ direction = @\"right\"; flipX = YES; }\nelse if(gunmanDirection == DPAD_UP_LEFT){ direction = @\"up_right\"; flipX = YES; }\n/* CODE OMITTED */\n//Our simple running loop\nif(moving){\n[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"gunman_run_%@_01.png\",direction]]];\n/* CODE OMITTED */\n}\ndirectional padcreatinggunman.flipX = flipX;\n[gunman runAction:[CCRepeatForever actionWithAction: [CCAnimate actionWithAnimation:animation]]];\n}\n/* Process touches */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n[dPad ccTouchesBegan:touches withEvent:event];\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n@end\n\n```", "```swift\n#import \"TouchableSprite.h\"\n//AnalogStick.h\n@interface AnalogStick : TouchableSprite {\n@public\nCGPoint _pressedVector; //Internal _pressedVector with no outer dead zone\nCCSprite *nub;\nCCSprite *bar;\nint direction;\n}\n@property (readonly) CGPoint pressedVector; //External pressedVector with a dead zone\n@end\n@implementation AnalogStick\n-(id)init {\nself = [super init];\nif (self != nil) {\nself.scale = 0.5f;\n_pressedVector = ccp(0,0);\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"analog_stick.plist\"];\n//Set the sprite display frame\n[self setDisplayFrame:[cache spriteFrameByName:@\"analog_pad.png\"]];\n//Init the bar, set position and display frame\nbar = [[CCSprite alloc] init];\n[bar setDisplayFrame:[cache spriteFrameByName:@\"analog_bar.png\"]];\n[self repositionBarWithPoint:self.position];\n[self addChild:bar];\n//Init the nub, set position and display frame\nnub = [[CCSprite alloc] init];\n[self repositionNub];\n[nub setDisplayFrame:[cache spriteFrameByName:@\"analog_nub.png\"]];\n[self addChild:nub];\n}\nreturn self;\n}\nanalog stickcreating, steps-(void)dealloc {\n[nub release];\n[bar release];\n[super dealloc];\n}\n/* Process analog stick touch */\n-(void)processTouch:(CGPoint)point {\nself.pressed = YES;\n[self setColor:ccc3(255,200,200)]; [nub setColor:ccc3(255,200,200)]; [bar setColor:ccc3(255,200,200)];\nCGPoint center = CGPointMake( self.rect.origin.x+self.rect.size.width/2, self.rect.origin.y+self.rect.size.height/2 );\n_pressedVector = CGPointMake((point.x-center.x)/(self.rect.size.width/2), (point.y-center.y)/(self.rect.size.height/2));\n[self repositionNub];\n[self repositionBarWithPoint:point];\n[self resetDirection];\n}\n/* Process analog stick release */\n-(void)processRelease {\n[self setColor:ccc3(255,255,255)]; [nub setColor:ccc3(255,255,255)]; [bar setColor:ccc3(255,255,255)];\nself.pressed = NO;\n_pressedVector = ccp(0,0);\n[self repositionNub];\n[self repositionBarWithPoint:self.position];\n}\n/* Reposition the nub according to the pressedVector */\n-(void)repositionNub {\nfloat width = ([self contentSize].width);\nfloat height = ([self contentSize].height);\nnub.position = ccp(_pressedVector.x*(width/2)+width/2,\n_pressedVector.y*(height/2)+height/2);\n}\nanalog stickcreating, steps/* Reposition the bar according to a pressed point */\n-(void)repositionBarWithPoint:(CGPoint)point {\nfloat width = ([self contentSize].width);\nfloat height = ([self contentSize].height);\n//Rotation\nfloat radians = vectorToRadians( _pressedVector );\nfloat degrees = radiansToDegrees(radians);\nbar.rotation = degrees;\n//Set the display frame of the bar\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[bar setDisplayFrame:[cache spriteFrameByName:@\"analog_bar.png\"]];\n//Calculate bar position\nfloat distFromCenter = distanceBetweenPoints(point, self.position);\nfloat sizeMod = distFromCenter / [self contentSize].width;\nfloat oldHeight = bar.textureRect.size.height;\nfloat newHeight = oldHeight * sizeMod * 5;\n//Custom fixes\nif(newHeight < 100){ newHeight = 100.0f; }\nif(distFromCenter < 3){ newHeight = 0.0f; }\nbar.textureRect = CGRectMake(bar.textureRect.origin.x,bar.textureRect.origin.y+ (oldHeight-newHeight),\nbar.textureRect.size.width,newHeight );\nbar.anchorPoint = ccp(0.5f,0);\nCGPoint directionVector = radiansToVector(radians-PI/2);\nbar.position = ccp(width/2 + directionVector.x*width/4, height/2 + directionVector.y*height/4);\n}\n/* Reset the direction based on the pressedVector */\n-(void) resetDirection {\nif(_pressedVector.x == 0 && _pressedVector.y == 0){\ndirection = AS_NO_DIRECTION;\nreturn;\n}\nanalog stickcreating, stepsfloat radians = vectorToRadians(_pressedVector);\nfloat degrees = radiansToDegrees(radians) + 90;\nif(degrees >= 337.5 || degrees < 22.5){\ndirection = AS_LEFT;\n}else if(degrees >= 22.5 && degrees < 67.5){\ndirection = AS_UP_LEFT;\n}/* CODE OMITTED */\n}\n-(float) magnitude {\nfloat m = sqrt( pow(_pressedVector.x,2) + pow(_pressedVector.y,2) );\n//25% end deadzone to make it easier to hold highest magnitude\nm += 0.25f;\nif(m > 1.0f){ m = 1.0f; }\nreturn m;\n}\n-(CGPoint) pressedVector {\nfloat m = sqrt( pow(_pressedVector.x,2) + pow(_pressedVector.y,2) );\nm += 0.25f;\nCGPoint pv = ccp(_pressedVector.x*1.25f, _pressedVector.y*1.25f);\n//25% end deadzone to make it easier to hold highest magnitude\nif(m > 1){\nfloat radians = vectorToRadians(_pressedVector);\npv = radiansToVector(radians + PI/2);\n}\nreturn pv;\n}\n@end\n@implementation Ch2_AnalogStick\n-(CCLayer*) runRecipe {\nself.isTouchEnabled = YES;\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\n[cache addSpriteFramesWithFile:@\"gunman.plist\"];\n//Initialize gunman\ngunman = [SimpleAnimObject spriteWithSpriteFrame:[cache spriteFrameByName:@\"gunman_stand_down.png\"]];\ngunman.position = ccp(240,160);\n[self addChild:gunman];\ngunman.velocity = ccp(0,0);\ngunmanDirection = AS_DOWN;\n//Initialize analog stick\n[cache addSpriteFramesWithFile:@\"analog_stick.plist\"];\nanalogStick = [[AnalogStick alloc] init];\nanalogStick.position = ccp(100,100);\n[self addChild:analogStick];\n[self schedule:@selector(step:)];\n//This sets off a chain reaction.\n[self animateGunman];\nreturn self;\n}\n-(void) step:(ccTime)delta {\n//Set gunman velocity and animate if necessary\nif(analogStick.direction != AS_NO_DIRECTION){\nif(analogStick.direction != gunmanDirection){\n[gunman stopAllActions];\ngunmanDirection = analogStick.direction;\n[self animateGunman];\n}\n}\ngunman.velocity = ccp(analogStick.pressedVector.x*4, analogStick.pressedVector.y*4);\n[gunman update:delta];\n}\n-(void) animateGunman {\nCCSpriteFrameCache *cache = [CCSpriteFrameCache sharedSpriteFrameCache];\nfloat speed = [analogStick magnitude];\n//Animation delay is inverse speed\nfloat delay = 0.075f/speed;\nif(delay > 0.5f){ delay = 0.5f; }\nCCAnimation *animation = [[CCAnimation alloc] initWithName:@\"gunman_anim\" delay:delay];\nNSString *direction;\nbool flipX = NO;\nbool moving = YES;\nif(gunman.velocity.x == 0 && gunman.velocity.y == 0){ moving = NO; }\nif(gunmanDirection == AS_LEFT){ direction = @\"right\"; flipX = YES; }\nelse if(gunmanDirection == AS_UP_LEFT){ direction = @\"up_right\"; flipX = YES; }\n/* CODE OMITTED */\n//Our simple animation loop\nif(moving){\n[animation addFrame:[cache spriteFrameByName:[NSString stringWithFormat:@\"gunman_run_%@_01.png\",direction]]];\n/* CODE OMITTED */\n}\ngunman.flipX = flipX;\n//animateGunman calls itself indefinitely\n[gunman runAction:[CCSequence actions: [CCAnimate actionWithAnimation:animation],\n[CCCallFunc actionWithTarget:self selector:@selector(animateGunman)], nil ]];\n}\n/* Process touches */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n[analogStick ccTouchesBegan:touches withEvent:event];\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n}\n@end\n\n```", "```swift\n    CGPoint center = CGPointMake( self.rect.origin.x+self.rect.size.width/2, self.rect.origin.y+self.rect.size.height/2 );\n    _pressedVector = CGPointMake((point.x-center.x)/(self.rect.size.width/2), (point.y-center.y)/(self.rect.size.height/2));\n\n    ```", "```swift\n@implementation Ch2_AccelerometerSteering\n-(CCLayer*) runRecipe {\n//Enable the accelerometer and set its updateInterval\nself.isAccelerometerEnabled = YES;\n[[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0 / 60)];\n//Init car background\nCCSprite *bg = [CCSprite spriteWithFile:@\"car_dash.jpg\"];\nbg.position = ccp(240,160);\nbg.opacity = 200;\n[self addChild:bg z:0];\n//Init steeringWheel sprite\nsteeringWheel = [CCSprite spriteWithFile:@\"car_steering_wheel.png\"];\nsteeringWheel.position = ccp(230,170);\n[self addChild:steeringWheel z:1];\nreturn self;\n}\n/* Handle accelerometer input */\n- (void)accelerometer:(UIAccelerometer*)accelerometer didAccelerate:(UIAcceleration*)acceleration{\n//Set steeringWheel rotation based on Y plane rotation\nsteeringWheel.rotation = -acceleration.y * 180;\n}\n@end\n\n```", "```swift\n#import \"IphoneCube.h\"\n@implementation Ch2_AccelerometerRotation\n-(CCLayer*) runRecipe {\n//Enable the accelerometer and set its updateInterval\nself.isAccelerometerEnabled = YES;\n[[UIAccelerometer sharedAccelerometer] setUpdateInterval:(1.0 / 60)];\n//Init our textured box\niphoneCube = [[IphoneCube alloc] init];\niphoneCube.translation3D = [Vector3D x:0.0f y:0.0f z:-2.0f];\niphoneCube.rotation3DAxis = [Vector3D x:0.0f y:0.0f z:(PI/2 - 0.075f)];\n[self addChild:iphoneCube z:3 tag:0];\nreturn self;\n}\n/* Handle accelerometer input */\n- (void)accelerometer:(UIAccelerometer*)accelerometer didAccelerate:(UIAcceleration*)acceleration{\n//Set x and y box orientation\niphoneCube.rotation3DAxis.x = -acceleration.x * 180;\niphoneCube.rotation3DAxis.y = -acceleration.y * 180;\n}\n@end\n\n```", "```swift\n#import \"IphoneCube.h\"\n@implementation Ch2_PinchZooming\n-(CCLayer*) runRecipe {\n//Enable touching\nself.isTouchEnabled = YES;\n//Set initial variables\narrowsIn = NO;\ncameraZoom = 1.0f;\nlastMultiTouchZoomDistance = 0.0f;\n//Init background\nbg = [CCSprite spriteWithFile:@\"dracula_castle.jpg\"];\nbg.position = ccp(240,160);\n[self addChild:bg];\n//Set initial zoom\n[self setCameraZoom:1];\nreturn self;\n}\n/* Check for HUD input */\n-(bool) hudPressedWithPoint:(CGPoint)point {\n//There is no HUD.\nreturn NO;\n}\n-(void) setCameraZoom:(float)zoom {\ncameraZoom = zoom;\nbg.scale = cameraZoom;\n}\n/* Check touches */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//If HUD has not been touched we reset lastMultiTouchZoomDistance\nif(![self hudPressedWithPoint:point]){\nlastMultiTouchZoomDistance = 0.0f;\n}\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\nCGSize s = [[CCDirector sharedDirector] winSize];\n//Check for only 2 touches\nif(touches.count == 2){\nNSArray *twoTouch = [touches allObjects];\n//Get both touches\nUITouch *tOne = [twoTouch objectAtIndex:0];\nUITouch *tTwo = [twoTouch objectAtIndex:1];\nCGPoint firstTouch = [tOne locationInView:[tOne view]];\nCGPoint secondTouch = [tTwo locationInView:[tTwo view]];\n//If HUD hasn't been touched we use this distance and last distance to calculate zooming\nif(![self hudPressedWithPoint:firstTouch] && ![self hudPressedWithPoint:secondTouch]){\nCGFloat currentDistance = distanceBetweenPoints(firstTouch, secondTouch);\nif(lastMultiTouchZoomDistance == 0){\nlastMultiTouchZoomDistance = currentDistance;\n}else{\nfloat difference = currentDistance - lastMultiTouchZoomDistance;\nfloat newZoom = (cameraZoom + (difference*cameraZoom/s.height));\nif(newZoom < 1.0f){ newZoom = 1.0f; }\nif(newZoom > 4.0f){ newZoom = 4.0f; }\n[self setCameraZoom:newZoom];\nlastMultiTouchZoomDistance = currentDistance;\n}\n}\n}\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\nUITouch *touch = [touches anyObject];\nCGPoint point = [touch locationInView: [touch view]];\npoint = [[CCDirector sharedDirector] convertToGL: point];\n//If HUD has not been touched we reset lastMultiTouchZoomDistance\nif(![self hudPressedWithPoint:point]){\nlastMultiTouchZoomDistance = 0.0f;\n}\n}\n@end\n\n```", "```swift\nfloat newZoom = (cameraZoom + (difference*cameraZoom/s.height));\n\n```", "```swift\n#import \"GestureLine.h\"\n#import \"GestureShapeLayer.h\"\n@implementation Ch2_Gestures\n-(CCLayer*) runRecipe {\n//Init message\nmessage = [CCLabelBMFont labelWithString:@\"Draw a rectangle, triangle, circle or line\" fntFile:@\"eurostile_30.fnt\"];\nmessage.position = ccp(200,270);\nmessage.scale = 0.65f;\n[message setColor:ccc3(255,0,0)];\n[self addChild:message z:3];\n//Allow touching\nself.isTouchEnabled = YES;\n//Set font size\n[CCMenuItemFont setFontSize:20];\n//Add our breadcrumbs node\n[self addBreadcrumbs];\n//Init GestureShapeLayer\ngestureShapeLayer = [[GestureShapeLayer alloc] init];\ngestureShapeLayer.position = ccp(0,0);\n[self addChild:gestureShapeLayer z:1];\nreturn self;\n}\n/* Process touches */\n-(void) ccTouchesBegan:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//Start a new gesture\n[self newGestureWithPoint:point];\n}\n-(void) ccTouchesMoved:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//Add a point to our current gesture\n[self addGesturePoint:point override:NO];\n}\n-(void) ccTouchesEnded:(NSSet *)touches withEvent:(UIEvent *)event {\n/* CODE OMITTED */\n//Finish our gesture\n[self finishGestureWithPoint:point];\n}\n-(void) newGestureWithPoint:(CGPoint)point {\n[self resetMessage];\n//Init gesture variables\ngestureShapeLayer.points = [[NSMutableArray alloc] init];\ngestureShapeLayer.lines = [[NSMutableArray alloc] init];\nfirstPoint = point;\nlastPoint = point;\nvertex = point;\n[gestureShapeLayer.points addObject:[NSValue valueWithCGPoint:point]];\ngestureShapeLayer.drawCircle = NO;\ngestureShapeLayer.drawLines = NO;\n}\n-(void) addGesturePoint:(CGPoint)point override:(bool)override {\n//Set our angle change tolerance to 40 degrees. If it changes more than this we consider this a 'line'\nfloat angleDiffTolerance = 40.0f;\n//Check the old angle versus the new one\nCGPoint vect = ccp(point.x-lastPoint.x, point.y-lastPoint.y);\nfloat newAngle = radiansToDegrees( vectorToRadians(vect) );\n//Add a line if the angle changed significantly\nif(gestureShapeLayer.points.count > 1){\nfloat angleDiff = angleDifference(newAngle, angle);\nif(override || (angleDiff > angleDiffTolerance && distanceBetweenPoints(vertex, point) > 15.0f)){\n[gestureShapeLayer.lines addObject:[GestureLine point1:vertex point2:point]];\nvertex = point;\n}\n}\n//Update values\nangle = newAngle;\nlastPoint = point;\n[gestureShapeLayer.points addObject:[NSValue valueWithCGPoint:point]];\n}\n-(void) finishGestureWithPoint:(CGPoint)point {\n[self addGesturePoint:point override:YES];\ngestureShapeLayer.drawCircle = NO;\ngestureShapeLayer.drawLines = NO;\n//To finish gestures which require the end to be close to the beginning point we supply this distance tolerance\nfloat lastPointTolerance = 100.0f;\n//Rectangles, triangles and circles\nif(distanceBetweenPoints(firstPoint, lastPoint) <= lastPointTolerance){\nif(gestureShapeLayer.lines.count == 4){ //4 lines\n[message setString:@\"Rectangle\"];\ngestureShapeLayer.drawLines = YES;\n}else if(gestureShapeLayer.lines.count == 3){ //3 lines\n[message setString:@\"Triangle\"];\ngestureShapeLayer.drawLines = YES;\n}else if(gestureShapeLayer.lines.count <= 1){ //0 or 1 lines\n[message setString:@\"Circle\"];\n[gestureShapeLayer setCircleRectFromPoints];\ngestureShapeLayer.drawCircle = YES;\n}else{\n[self resetMessage];\ngestureShapeLayer.lines = [[NSMutableArray alloc] init];\n}\n}else{ //Lines and angles\nif(gestureShapeLayer.lines.count == 1){ //1 line\n[message setString:@\"Line\"];\ngestureShapeLayer.drawLines = YES;\n}else if(gestureShapeLayer.lines.count == 2){ //2 lines\n[message setString:@\"Angle\"];\ngestureShapeLayer.drawLines = YES;\n}else{\n[self resetMessage];\ngestureShapeLayer.lines = [[NSMutableArray alloc] init];\n}\n}\n}\n@end\n\n```"]