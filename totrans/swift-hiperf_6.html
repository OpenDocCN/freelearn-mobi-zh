<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Architecting Applications for High Performance" id="1MBG21-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Architecting Applications for High Performance</h1></div></div></div><p class="calibre8">In previous chapters, we talked about different ways of improving code to achieve high-performance. Mostly we concentrated on a small part of the code and how to improve a function, an algorithm, and a data structure. In this chapter, we will concentrate on higher levels. We will talk about how to design an application architecture that can be scalable, maintainable, and high-performance.</p><p class="calibre8">In this chapter we are going to cover these topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">High-performance and concurrency overview</li><li class="listitem">Avoiding state</li><li class="listitem">Divide and conquer</li><li class="listitem">Designing asynchronous architecture</li></ul></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Architecting Applications for High Performance" id="1MBG21-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Achieving high performance"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec51" class="calibre1"/>Achieving high performance</h1></div></div></div><p class="calibre8">One of the ways to improve application performance is to run code concurrently. This not only allows us to run <a id="id353" class="calibre1"/>code faster and get the results more quickly, but it also frees the main-thread from doing a lot of work and being blocked. You should know that the main thread is responsible for events and user input handling. All the UI work is performed on the main thread and to achieve a really smooth user interaction we should do as little work as possible on the main thread.</p><p class="calibre8">Running code concurrently can be a tricky task and sometimes it can lead to increased running time for an operation. Making solid concurrent application architecture is also not a trivial task and you should plan it carefully.</p><p class="calibre8">To take full advantage of concurrency, it is very useful to understand the hardware we have at our disposal that allows us to do that.</p></div></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Architecting Applications for High Performance" id="1MBG21-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Achieving high performance">
<div class="book" title="Device architecture"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec59" class="calibre1"/>Device architecture</h2></div></div></div><p class="calibre8">In order to be able to achieve really high-performance, first we need to learn and understand what kinds of tools we have at our disposal. If you are making an iOS application, your application will run on the iPhone and iPad; for OS X it would run on the Mac. Although it might seem that the iPhone and the Mac differ a lot, they share the same basic <a id="id354" class="calibre1"/>concept and we can think about a Mac as a more powerful iPad device.</p><p class="calibre8">Nowadays, all computers and even phones use multi-core processors that allow us to execute many instructions at the same time in parallel. Starting with the iPhone 4s, all iPhones have a dual-core processor and the iPad Air 2 even has a 3-core processor. We should fully use that power and take advantage of it.</p><p class="calibre8">Let's have a look at how we could design code that could be run in parallel on multi-core processors.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Concurrency overview"><div class="book" id="1NA0K2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec52" class="calibre1"/>Concurrency overview</h1></div></div></div><p class="calibre8">By default, when <a id="id355" class="calibre1"/>you make an application it runs the code in a single-thread environment, a main thread. For example, an iOS application would call the <code class="literal">application:</code> <code class="literal">didFinishLaunchingWithOptions</code> method on the main thread.</p><p class="calibre8">A simpler example is an OS X Command Line Tool application. It has only one file: <code class="literal">main.swift</code>. When you start it, the system creates a single main thread and runs all the code in the <code class="literal">main.swift</code> file on that thread.</p><p class="calibre8">For testing code, playgrounds are the best. By default, playgrounds stop after executing the last line of code and don't wait for the concurrent code to finish executing. We can change this behavior by telling the playgrounds to keep running indefinitely. To do that, include these two lines in the playground file:</p><div class="informalexample"><pre class="programlisting">import XCPlayground
XCPSetExecutionShouldContinueIndefinitely()</pre></div><p class="calibre8">Now we can start playing with concurrency. The first task we need to do to run code concurrently is to schedule a task to be run on a different thread. We can schedule a task for concurrent execution by using:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Threads</li><li class="listitem"><span class="strong"><strong class="calibre9">GCD</strong></span> (<span class="strong"><strong class="calibre9">Grand Central Dispatch</strong></span>)</li><li class="listitem">Operation Queues</li></ul></div></div>

<div class="book" title="Concurrency overview">
<div class="book" title="Threads"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec60" class="calibre1"/>Threads</h2></div></div></div><p class="calibre8">As the first option, we <a id="id356" class="calibre1"/>could use threads. A thread is the most low-level API. All the concurrency is built on top of threads and runs multiple threads. We can use <code class="literal">NSThread</code> from the Foundation framework. The simplest way to do this is to create a new class <a id="id357" class="calibre1"/>with a method that will be the starting point for our new thread.</p><p class="calibre8">Let's see how we could schedule the new thread:</p><div class="informalexample"><pre class="programlisting">class Handler: NSObject {
  @objc class func run() {
    print("run")
  }
}

NSThread.detachNewThreadSelector("run", toTarget: Handler.self, withObject: nil)

let thread = NSThread(target: Handler.self, selector: "run", object: nil)
thread.start()</pre></div><p class="calibre8">You can create a new thread in two ways, by using the <code class="literal">detachNewThreadSelector</code> function or create an instance of <code class="literal">NSThread</code> and use the <code class="literal">start</code> function. We have to mark our <code class="literal">run</code> function with the <code class="literal">@objc</code> attribute because we use it as a selector when creating a thread, and <code class="literal">NSThread </code>is an Objective-C class that uses dynamic dispatch for method calling.</p><p class="calibre8">The <code class="literal">NSObject</code> has a simple API for performing a method on a different thread. Because our handler inherits for <code class="literal">NSObject</code> we can use it.</p><div class="informalexample"><pre class="programlisting">Handler.performSelectorInBackground("run", withObject: nil)</pre></div><p class="calibre8">Another way is to create a subclass of <code class="literal">NSThread</code> and override the starting point of a thread, the <code class="literal">main</code> function. In that way we don't need a handler class.</p><div class="informalexample"><pre class="programlisting">class MyWorker: NSThread {

  override func main() {
    print("Do work here")
  }
}

let worker = MyWorker()
worker.start()</pre></div><div class="book" title="Thread complexity"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec37" class="calibre1"/>Thread complexity</h3></div></div></div><p class="calibre8">Even though the code is pretty simple here, working with threads is quite a complex operation. We need to take care of managing the state of the thread, correctly terminating it, and releasing the<a id="id358" class="calibre1"/> resources used by the thread.</p><p class="calibre8">Creating a new thread is a very expensive and time-consuming operation, and we should avoid it when possible. The way to solve this is to reuse created threads. Creating and managing a thread-pool adds extraordinary complexity to the application that we don't need.</p><p class="calibre8">The process gets even harder when you need to communicate between threads and synchronize data between them.</p></div><div class="book" title="Solution for threads"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec38" class="calibre1"/>Solution for threads</h3></div></div></div><p class="calibre8">Instead of solving <a id="id359" class="calibre1"/>our initial task that we wanted to run concurrently, now we are spending time managing the complexity of that concurrent execution system. Fortunately we don't need to do that as there is a solution: <span class="strong"><em class="calibre10">Don't use threads</em></span>.</p><p class="calibre8">The <span class="strong"><em class="calibre10">iOS and Mac Concurrency Programming Guide</em></span> recommends not using threads but choosing a high-level API, a GCD, or Operation Queues.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip31" class="calibre1"/>Tip</h3><p class="calibre8">Thread APIs are shown in this chapter only for general knowledge. You should almost never use threads; use GCD instead.</p></div></div></div></div>

<div class="book" title="Concurrency overview">
<div class="book" title="GCD"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec61" class="calibre1"/>GCD</h2></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre9">GCD</strong></span> (<span class="strong"><strong class="calibre9">Grand Central Dispatch</strong></span>) is a high-level API that is built on top of threads and performs all aspects of<a id="id360" class="calibre1"/> thread management for you. Instead of working with threads, GCD provides a queue and task abstraction. You schedule a task to a queue for execution and the queue takes care of everything else. Let's <a id="id361" class="calibre1"/>see how we could rewrite our code with GCD:</p><div class="informalexample"><pre class="programlisting">let bgQueue = dispatch_get_global_queue(QOS_CLASS_BACKGROUND,0)
dispatch_async(bgQueue) {
  print("run")
}</pre></div><p class="calibre8">As you can see, the code looks simpler from the start. Before we dive into the details, let's have a look at GCD and its concepts:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Queues</li><li class="listitem">Tasks</li><li class="listitem">Adding tasks to the queue</li></ul></div><div class="book" title="Queues"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec39" class="calibre1"/>Queues</h3></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre9">queue</strong></span> is a structure that takes care of managing and executing its tasks. The queue is a first-in first-out data<a id="id362" class="calibre1"/> structure. That means that tasks in the queue are started in the<a id="id363" class="calibre1"/> order they were added to the queue.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">First in first out means that tasks are started in the same order but it doesn't mean that they can't be executed simultaneously. Concurrent queues can start many tasks at the same time.</p></div><p class="calibre8">The queue itself doesn't have much functionality. The main operation you would need to do is to create a queue or get one of the global queues.</p><p class="calibre8">There are three queue types:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Main queue</li><li class="listitem">Concurrent: global and own queues</li><li class="listitem">Serial</li></ul></div><div class="book" title="Main queues"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch06lvl4sec11" class="calibre1"/>Main queues</h4></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre9">main queue</strong></span> represents a queue associated with a main thread. It runs tasks serially, one after the other. You <a id="id364" class="calibre1"/>would usually use this queue to pass the result of an execution <a id="id365" class="calibre1"/>from other background queues to the main queue to update the UI state. You can get a main queue by calling the <code class="literal">dispatch_get_main_queue</code> function.</p><div class="informalexample"><pre class="programlisting">let mainQueue = dispatch_get_main_queue()</pre></div></div><div class="book" title="Concurrent queues"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch06lvl4sec12" class="calibre1"/>Concurrent queues</h4></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre9">concurrent queue</strong></span> runs its<a id="id366" class="calibre1"/> tasks concurrently. The easiest way to get a <a id="id367" class="calibre1"/>concurrent queue is to use a global concurrent queue.</p><div class="informalexample"><pre class="programlisting">func dispatch_get_global_queue(identifier: Int, flags: UInt) -&gt; dispatch_queue_t!</pre></div><p class="calibre8">To get a global queue, we need to specify what kind of priority we need. There are five types of queue with descending task priority. <code class="literal">USER_INTERACTIVE</code> is the most prioritized queue and <code class="literal">BACKGROUND</code> is the least.</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">QOS_CLASS_USER_INTERACTIVE</code></li><li class="listitem"><code class="literal">QOS_CLASS_USER_INITIATED</code></li><li class="listitem"><code class="literal">QOS_CLASS_DEFAULT</code></li><li class="listitem"><code class="literal">QOS_CLASS_UTILITY</code></li><li class="listitem"><code class="literal">QOS_CLASS_BACKGROUND</code><div class="note" title="Note"><h3 class="title2"><a id="tip32" class="calibre1"/>Tip</h3><p class="calibre8">Also available are old <code class="literal">DISPATCH_QUEUE_PRIORITY</code> constants that can be used when specifying a queue priority type instead of <code class="literal">QOS_CLASS</code> but <code class="literal">QOS_CLASS</code> is preferred.</p></div></li></ul></div><p class="calibre8">The second flag <a id="id368" class="calibre1"/>parameter is reserved and never used, so we just use 0. The global queues are available for use by the whole system and everyone can add tasks to them. When all you need is to run some tasks, this is a perfect fit.</p></div><div class="book" title="Own queues"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch06lvl4sec13" class="calibre1"/>Own queues</h4></div></div></div><p class="calibre8">When you need to<a id="id369" class="calibre1"/> do more complex handling and have full control of what tasks are added to the queue, you can create your own queue. Own queues fit well when you need to be notified of when all tasks are done, or to do more complex synchronization between tasks.</p><p class="calibre8">You can create both concurrent and serial queues. Serial queues execute one task at a time, one after another, not concurrently.</p><div class="informalexample"><pre class="programlisting">let concurentQ = dispatch_queue_create("my-c", DISPATCH_QUEUE_CONCURRENT)
let serialQ = dispatch_queue_create("my-s", DISPATCH_QUEUE_SERIAL)</pre></div></div></div><div class="book" title="Tasks"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec40" class="calibre1"/>Tasks</h3></div></div></div><p class="calibre8">A <span class="strong"><strong class="calibre9">task</strong></span> is a block of code that <a id="id370" class="calibre1"/>needs to be run. A task is defined as a <code class="literal">dispatch_block_t</code> type and it is<a id="id371" class="calibre1"/> defined as <code class="literal">() -&gt; Void</code>. We could use a closure or a function as a task.</p><div class="informalexample"><pre class="programlisting">typealias dispatch_block_t = () -&gt; Void

let tasks: dispatch_block_t = {
  print("do Work")
}

func doWork() {
  print("do Work Function")
}</pre></div></div><div class="book" title="Adding tasks to the queue"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch06lvl3sec41" class="calibre1"/>Adding tasks to the queue</h3></div></div></div><p class="calibre8">We have a queue and <a id="id372" class="calibre1"/>we have a task that we want to run. To run<a id="id373" class="calibre1"/> a task on a particular queue, we need to dispatch it to that queue. We<a id="id374" class="calibre1"/> could do this in two ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Synchronous</strong></span>: <code class="literal">dispatch_sync</code></li><li class="listitem"><span class="strong"><strong class="calibre9">Asynchronous</strong></span>: <code class="literal">dispatch_async</code></li></ul></div><p class="calibre8">Both functions are <a id="id375" class="calibre1"/>very simple and have the same type. The only differences are in their names and the way they work.</p><div class="informalexample"><pre class="programlisting">dispatch_sync(queue: dispatch_queue_t, _ block: dispatch_block_t)
dispatch_async(queue: dispatch_queue_t, _ block: dispatch_block_t)</pre></div><div class="book" title="Synchronous dispatch"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch06lvl4sec14" class="calibre1"/>Synchronous dispatch</h4></div></div></div><p class="calibre8">Synchronous dispatch submits a task for execution and waits until the task is done.</p><div class="informalexample"><pre class="programlisting">dispatch_sync(queue) { ... }</pre></div><p class="calibre8">When you use <a id="id376" class="calibre1"/>a concurrent queue and dispatch a task to it synchronously, the queue can run many tasks at the same time, but the <code class="literal">dispatch_sync</code> method waits until the task you submitted is finished.</p><div class="informalexample"><pre class="programlisting">let queue = dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)

dispatch_sync(queue) { print("Task 1") }
print("1 Done")

dispatch_sync(queue) { print("Task 2") }
print("2 Done")</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip33" class="calibre1"/>Tip</h3><p class="calibre8">Never call the <code class="literal">dispatch_sync</code> function from a task that is executing in the same queue. This would cause a deadlock for the serial queue and should be avoided for concurrent queues as well.</p><div class="informalexample"><pre class="programlisting">dispatch_sync(queue) {
  dispatch_sync(queue) {
    print("Never called") // Don't do this
  }
}</pre></div></div><p class="calibre8">In this example, the <code class="literal">print("1 Done") </code>instruction and the rest of the code will wait until <code class="literal">Task 1</code> is finished.</p></div><div class="book" title="Asynchronous dispatch"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch06lvl4sec15" class="calibre1"/>Asynchronous dispatch</h4></div></div></div><p class="calibre8">Asynchronous dispatch, on<a id="id377" class="calibre1"/> the other hand, submits a task for execution and returns it immediately.</p><div class="informalexample"><pre class="programlisting">dispatch_async(queue) { ... }</pre></div><p class="calibre8">If we use the previous example and change it to use <code class="literal">dispatch_async</code>, <code class="literal">1 Done</code> will<code class="literal"> </code>not wait for tasks to be finished. We can also simulate extra work by freezing the current thread with a <a id="id378" class="calibre1"/>sleep function.</p><div class="informalexample"><pre class="programlisting">let queue = dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)

dispatch_async(queue) {
  sleep(2) // sleep for 2 seconds
  print("Task 1")
}
print("1 Submitted")

dispatch_async(queue) { print("Task 2") }
print("2 Submitted")</pre></div><p class="calibre8">As a result, <code class="literal">Task 2</code> is submitted for execution immediately after <code class="literal">Task 1</code> and it finishes execution before <code class="literal">Task 1</code>. Here is the console output:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">1 Submitted</strong></span>
<span class="strong"><strong class="calibre9">2 Submitted</strong></span>
<span class="strong"><strong class="calibre9">Task 2</strong></span>
<span class="strong"><strong class="calibre9">Task 1</strong></span>
</pre></div><p class="calibre8">GCD also has some powerful tools for synchronizing submitted tasks, but we are not going to cover them here. If you want to learn more, read the <span class="strong"><em class="calibre10">Concurrency Programming Guide</em></span> article in the Apple<a id="id379" class="calibre1"/> library documentation at <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide">https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide</a>.</p></div></div></div></div>

<div class="book" title="Concurrency overview">
<div class="book" title="Operation queues"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec62" class="calibre1"/>Operation queues</h2></div></div></div><p class="calibre8">
<code class="literal">NSOperationQueue</code> is built on top of GCD and provides more high-level abstraction and an API that allows us to <a id="id380" class="calibre1"/>control an application controlflow.</p><p class="calibre8">The concept is very similar to GCD; it has a queue and tasks that you add to the particular queue.</p><div class="informalexample"><pre class="programlisting">let queue = NSOperationQueue()
queue.addOperationWithBlock {
  print("Some task")
}

NSOperationQueue.mainQueue().addOperationWithBlock {
  print("Some task")
}</pre></div><p class="calibre8">The NSOperationQueue provides a more high-level API but it is also a bit slower than GCD. NSOperationQueue fits very well with controlling the application flow, when tasks need to be chained, depend on each other, or need to be canceled. You can achieve the same functionality by using GCD but it would require implementing some extra logic that is already implemented by the NSOperationQueue.</p><p class="calibre8">GCD works very well when you need to perform a task and get the result and do not need to control the application flow.</p><p class="calibre8">Further in this chapter<a id="id381" class="calibre1"/> we will use GCD for concurrency. Now, let's move on and learn some tricks that will help us to make our code architecture more solid for concurrent programming.</p></div></div>
<div class="book" title="Designing asynchronous code" id="1O8H61-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec53" class="calibre1"/>Designing asynchronous code</h1></div></div></div><p class="calibre8">The first characteristic<a id="id382" class="calibre1"/> of asynchronous code is that it returns immediately and notifies the caller when it has completed the operation. The best solution is to return the result of the computation as well. This way we get more function style <span class="strong"><em class="calibre10">Input -&gt; Output </em></span>functions style.</p><p class="calibre8">Let's have a look at this simple example. This code has many issues and will refactor them all.</p><div class="informalexample"><pre class="programlisting">class SalesData {

  var revenue: [Int]
  var average: Int?

  init (revenue: [Int]) {
    self.revenue = revenue
  }

  func calculateAverage() {

    let queue = GCD.backgroundQueue()
    dispatch_async(queue) {

      var sum = 0
      for index in self.revenue.indices {
      sum += self.revenue[index]
      }

      self.average = sum / self.revenue.count
    }
  }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">We have made a GCD structure that provides a nice API for working with GCD code.  In the preceding example we have used a GCD <code class="literal">backgroundQueue</code> function; here is its implementation:</p><div class="informalexample"><pre class="programlisting">struct GCD {
  static func backgroundQueue() -&gt; dispatch_queue_t {
    return dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)
  }
}</pre></div></div><p class="calibre8">On the whole, the calculation code in that example is really bad and we could improve it by using a <code class="literal">reduce</code> method that would actually solve many problems and make the code safer and more readable.</p><div class="informalexample"><pre class="programlisting">let sum = self.revenue.reduce(0, combine: +)</pre></div><p class="calibre8">But the main point of that example was to show how dangerous it could be and what kinds of issues you could face with this architecture.</p><p class="calibre8">Let's use this code to see<a id="id383" class="calibre1"/> the problem:</p><div class="informalexample"><pre class="programlisting">let data = SalesData(revenue: makeRandomArray(100))
data.calculateAverage()
data.average // nil</pre></div><p class="calibre8">The problem is that <code class="literal">calculateAverage</code> returns immediately as it is supposed to and the average is not calculated at this moment. To solve that problem all the asynchronous code should have some way to notify a caller when the task is completed. The easiest way to do this is to add a callback completion function as a parameter.</p><div class="informalexample"><pre class="programlisting">func calculateAverage(result: () -&gt; Void ) {
  ...

  self.average = sum / self.revenue.count
  result()
}</pre></div><p class="calibre8">Now, when using this code, we can use a nice and clear trailing closure syntax for the result callback parameter.</p><div class="informalexample"><pre class="programlisting">let data = SalesData(revenue: makeRandomArray(100))
data.calculateAverage {
  print(data.average)
}</pre></div><p class="calibre8">There is one very important issue with this code. It is calling the <code class="literal">result</code> callback function on the background thread. It means that the closure we pass to <code class="literal">data.calculateAverage</code> will be called on the background but for us it's not documented and this behavior is not clear. We suppose that we will get that closure called on the main thread, because we are calling the <code class="literal">calculateAverage</code> function from the main thread. Let's do that. What we need to do is to switch to the main queue and call <code class="literal">result</code> on the main thread.</p><div class="informalexample"><pre class="programlisting">dispatch_async(GCD.mainQueue()) {
  result()
}</pre></div><p class="calibre8">The best practice is to always call a callback method on the main queue by default if another behavior is<a id="id384" class="calibre1"/> not required. If you need to call a callback on the special queue, then it should be passed to a function as a parameter.</p><p class="calibre8">This code works but there is still one improvement that could be done. When the result callback gets called, the first thing we do is get the <code class="literal">average</code> instance. It would be way better if the result callback returned the result of its computation.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip34" class="calibre1"/>Tip</h3><p class="calibre8">In general terms, it is a good functional programming style for functions to take input and return the result, <code class="literal">X -&gt; Y</code>. These functions are easier to use and test.</p></div><p class="calibre8">Let's refactor this code to pass an average result number to the callback function:</p><div class="informalexample"><pre class="programlisting">func calculateAverage(result: (Int?) -&gt; Void ) {
  ...

  self.average = sum / self.revenue.count
 
  dispatch_async(GCD.mainQueue()) {
    result(self.average)
  }
}

// Use case
let data = SalesData(revenue: makeRandomArray(1000))
data.calculateAverage { average in
  print(average)
}</pre></div><p class="calibre8">The change is not big but the benefits are quite extensive. When we use the <code class="literal">calculateAverage</code> function we get the result directly in the closure as a parameter. Now we don't need to access the instance variable of <code class="literal">SalesData</code>. <code class="literal">SalesData</code> becomes more of a closed-box type with hidden implementation details and because of that we will be able to do more refactoring in the future.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Avoiding state" id="1P71O1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec54" class="calibre1"/>Avoiding state</h1></div></div></div><p class="calibre8">The first rule is to<a id="id385" class="calibre1"/> avoid a state. When you are doing two things at the same time, those two processes should be as independent and isolated as possible. They shouldn't know anything about each other or share any mutable resources. If they do, then we would need to take care of synchronizing access to that shared resource, which would bring a complexity to our system that we don't want. Right now in our code we have two states: a <code class="literal">revenue</code> numbers array and the <code class="literal">average</code> result.  Both of the processes have access to that state.</p><p class="calibre8">The first problem in that the code is referencing itself. When you try to access an instance variable or a method that is out of the closure scope, you see an error message: <span class="strong"><strong class="calibre9">Reference to property 'revenue' in closure requires explicit 'self.' to make capture semantics explicit</strong></span>.</p><p class="calibre8">Xcode would also propose a fix to this issue, adding explicit self-capturing. This would solve the Xcode error but it wouldn't solve the root problem. When you see this error, stop and rethink your code design; in some cases it would be better to change the code, like in our case.</p><div class="mediaobject"><img src="../images/00025.jpeg" alt="Avoiding state" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The second problem is having a mutable state and mutating an instance variable. Let's use our last example once more and see why it's a bad idea to have a state and access instance variables in the concurrent code:</p><div class="informalexample"><pre class="programlisting">let data = SalesData(revenue: makeRandomArray(1000))
data.calculateAverage { average in
  print(average)
}
data.revenue.removeAll(keepCapacity: false)</pre></div><p class="calibre8">If you run this code, it will crash with a <span class="strong"><strong class="calibre9">fatal error: Array index out of range</strong></span> error due to getting the number from the array by an index operation:</p><div class="informalexample"><pre class="programlisting">sum += self.revenue[index]</pre></div><p class="calibre8">What is happening here is that, when we call <code class="literal">calculateAverage</code>, the revenue array has data, but later we remove all the revenue numbers and the arrays become empty; however, the indexes we are iterating over point to an old array size, and we are trying to access the index out of the bound arrays.</p><p class="calibre8">To solve that problem we <a id="id386" class="calibre1"/>should always try removing a state. One way to do that is to pass the needed data to a function as arguments or, if you want to have some state as in our case, capture the immutable values for a closure.</p></div>

<div class="book" title="Avoiding state" id="1P71O1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Capture list"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec63" class="calibre1"/>Capture list</h2></div></div></div><p class="calibre8">The first step<a id="id387" class="calibre1"/> to make this code better is to remove accessing mutable array variables. The easiest way to solve this is to make a local constant and use it in the closure.</p><div class="informalexample"><pre class="programlisting">let revenue = self.revenue
dispatch_async(queue) {
  var sum = 0
  for index in revenue.indices {
    sum += revenue [index]
  }

  self.average = sum / revenue.count
  ...
}</pre></div><p class="calibre8">This solution would work, because modifying the <code class="literal">revenue </code>instance variable doesn't have an impact on the local constant we have created. This code has one small issue. The constant is visible outside the closure, but it's intended to be used only inside the closure. It would be better if we could move it to the closure. We can do this by using a capture list of a closure. The only one change we need to do is to remove the local constant declaration and add it to the closure capture list. The rest of the code stays the same.</p><div class="informalexample"><pre class="programlisting">dispatch_async(queue) { [revenue] in
  ...
}</pre></div><p class="calibre8">In this example, we used a very short capture list notation, but we could also provide an alternative name for the constant we are capturing and add additional ARC <code class="literal">weak</code> or <code class="literal">unowned</code> attributes.</p><div class="informalexample"><pre class="programlisting">dispatch_async(queue) { [numbers = revenue] in  ...</pre></div></div></div>

<div class="book" title="Avoiding state" id="1P71O1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Immutable state"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec64" class="calibre1"/>Immutable state</h2></div></div></div><p class="calibre8">Having a state in the <a id="id388" class="calibre1"/>concurrent code is a bad design but there are two types of state: mutable and immutable. In any case, you will need to have some sort of a state in the application. If you are going to have a state, make it immutable; in that way you will ensure that it won't be changed and you can safely work with it.</p><p class="calibre8">If we have a look at our previous code example we could make the <code class="literal">revenue</code> numbers immutable, which would solve the problem:</p><div class="informalexample"><pre class="programlisting">class SalesData {
 
  let revenue: [Int]
  ...
}</pre></div><p class="calibre8">The first small change we would do is to change the revenue number array to be immutable. Because the <code class="literal">revenue</code> array is immutable it's not possible to modify it after we created an instance, so we need to remove this code.</p><div class="informalexample"><pre class="programlisting">  data.revenue.removeAll(keepCapacity: false)</pre></div><p class="calibre8">Because <code class="literal">revenue</code> is immutable now, it's safe to use it in a concurrent code, so we can remove the<a id="id389" class="calibre1"/> capture list and use the immutable revenue directly by using <code class="literal">self</code> explicitly as we did before.</p><div class="informalexample"><pre class="programlisting">func calculateAverage(result: (Int?) -&gt; Void ) {

  let queue = GCD.backgroundQueue()
  dispatch_async(queue) {
 
    var sum = 0
    for index in self.revenue.indices {
      sum += self.revenue[index]
    }

    self.average = sum / self.revenue.count
    dispatch_async(GCD.mainQueue()) {
      result(self.average)
    }
  }
}</pre></div><p class="calibre8">
<code class="literal">SalesData</code> contains immutable sales numbers that cannot be changed. This means that, after we have calculated the average value once, it will be the same all the time for that instance. The next time we call <code class="literal">calculateAverage</code>, we don't need to calculate it again if we can reuse it.</p><div class="informalexample"><pre class="programlisting">func calculateAverage(result: (Int?) -&gt; Void ) {

  if let average = self.average {
    result(average)
  } else {

    let queue = GCD.backgroundQueue()
    dispatch_async(queue) {
      ...
    }
  }
}</pre></div><p class="calibre8">We can even <a id="id390" class="calibre1"/>carry out one more step to make it immutable and use <code class="literal">struct</code> instead of a <code class="literal">class</code> for the <code class="literal">SalesData</code> type. When we do this, we will get an error saying:</p><p class="calibre8">
<span class="strong"><strong class="calibre9">cannot assign to property: 'self' is immutable</strong></span>
</p><p class="calibre8">
<span class="strong"><strong class="calibre9">self.average = sum / self.revenue.count</strong></span>
</p><p class="calibre8">When you assign new values to <code class="literal">self.average</code>, you are modifying a self instance, and because structs are immutable by default we need to mark that method as mutating:</p><div class="informalexample"><pre class="programlisting">struct SalesData {
  ...
  mutating func calculateAverage(result: (Int) -&gt; Void ) {
    ...
  }
}</pre></div><p class="calibre8">Those are only two changes we need to do. Also, when we are using it, we need to make an instance of <code class="literal">SalesData</code> as a variable, because <code class="literal">calculateAverage</code> is mutating it.</p><div class="informalexample"><pre class="programlisting">var data = SalesData(revenue: makeRandomArray(1000))
data.calculateAverage { average in
  print(average)
}</pre></div><p class="calibre8">So now we can't have a constant <code class="literal">let</code> immutable <code class="literal">SalesData</code> instance. This is not a sign of good architecture and we should refactor it. Using a struct for data entities is a very good solution so we should keep refactoring code with this approach.</p></div></div>
<div class="book" title="Divide and conquer"><div class="book" id="1Q5IA2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec55" class="calibre1"/>Divide and conquer</h1></div></div></div><p class="calibre8">The best way to <a id="id391" class="calibre1"/>achieve good, solid application architecture is to structure code well, create appropriate abstractions, and separate it into components with a single responsibility.</p><p class="calibre8">In functional programming it goes even further. The data—and the functions to work on that data—are also separated. The OOP concept of data and methods to work with it are split into two parts. This makes code even more flexible and reusable.</p><p class="calibre8">For concurrent code execution it's particularly<a id="id392" class="calibre1"/> important to split your code into standalone separate pieces because they can be sent for execution concurrently without blocking each other.</p><p class="calibre8">Before we start refactoring the code let's analyze it first. The goal is to identify a component with a single<a id="id393" class="calibre1"/> responsibility. I did it and here are those components:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">In Data</strong></span>: The first part is our input data. In our case it is a <code class="literal">SalesData</code> structure that holds immutable data in our application.</li><li class="listitem"><span class="strong"><strong class="calibre9">Calculation function</strong></span>: The next part is our function that knows how to calculate the average for <code class="literal">SalesData</code>. It's a simple first-class function that takes <code class="literal">SalesData</code> and returns the average. Its mathematical notation would be <code class="literal">f(x) = y</code> and the code notation would be <code class="literal">func calculateAverage(data: SalesData) -&gt; Int</code>.</li><li class="listitem"><span class="strong"><strong class="calibre9">Result data:</strong></span> This is a result returned by the calculation function. In our example, it is a simple <code class="literal">Int </code>number that represents an average.</li><li class="listitem"><span class="strong"><strong class="calibre9">Async execution operation</strong></span>: The next part is an operation that switches to the background thread and back to the main thread and that actually allows us to perform asynchronous code execution. In our example it's a <code class="literal">dispatch_async</code> function call with an appropriate queue.</li><li class="listitem"><span class="strong"><strong class="calibre9">Cache</strong></span>: Once we have calculated an average, we store it and don't perform the calculation again. This is exactly what a cache is for.</li></ul></div><p class="calibre8">Now we have identified <a id="id394" class="calibre1"/>separate components in our application, let's build relations and communication between them.</p><div class="mediaobject"><img src="../images/00026.jpeg" alt="Divide and conquer" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">To keep interaction simple, our application will ask a cache for an average value of <code class="literal">SalesData</code>. If a cache contains an average value, it will return it. Otherwise, it will start an async operation and pass <code class="literal">SalesData</code> to it. The async operation will call a <code class="literal">calculateAverage</code> function, get an average result, and pass it back to the cache. The cache will save it <a id="id395" class="calibre1"/>and forward it to the application.</p><p class="calibre8">This might sound a bit complicated when it's explained in words, but in code it's pretty simple, straightforward, and clear. Before we begin refactoring, let's have a look at the code that we made this structure for:</p><div class="informalexample"><pre class="programlisting">struct SalesData {
  let revenue: [Int]
  var average: Int?
 
  init (revenue: [Int]) {
    self.revenue = revenue
  }

  mutating func calculateAverage(result: (Int?) -&gt; Void ) {
   
    if let average = self.average {
      result(average)
    } else {
     
      let queue = GCD.backgroundQueue()
      dispatch_async(queue) {
        var sum = 0
        for index in self.revenue.indices {
          sum += self.revenue[index]
        }

        self.average = sum / self.revenue.count
        dispatch_async(GCD.mainQueue()) {
          result(self.average)
        }
      }
    }
  }
}</pre></div><p class="calibre8">The first idea that<a id="id396" class="calibre1"/> came to my mind was to follow the FP principle <span class="strong"><em class="calibre10">keep data and functions separate</em></span> and move the <code class="literal">calculateAverage</code> function outside a <code class="literal">SalesData</code> type.</p><div class="informalexample"><pre class="programlisting">struct SalesData {
  let revenue: [Int]
  var average: Int?
}

func calculateAverage(data: SalesData, result: (Int) -&gt; Void ) {
  ...
}</pre></div><p class="calibre8">This would work, but there is one issue with this code. The <code class="literal">calculateAverage </code>function can only work with the <code class="literal">SalesData</code> type, so it should be hidden inside the <code class="literal">SalesData</code> type and not be visible to other types. Also, in the Swift method notation is preferred.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip35" class="calibre1"/>Tip</h3><p class="calibre8">Swift 2.0 moves to methods over free functions, so it prefers to use an immutable method.</p><p class="calibre8">Example:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre9">Swift 2.0 Methods</strong></span>: <code class="literal">[1,2,3].map { $0 + 1 }.filter { $0 &gt; 1 }</code></li><li class="listitem"><span class="strong"><strong class="calibre9">Swift 1.2 Function</strong></span>: <code class="literal">filter(map([1,2,3]) { $0 + 1 }) { $0 &gt; 2 }</code></li></ul></div></div><p class="calibre8">Instead of moving the <code class="literal">calculateAverage</code> function out of the <code class="literal">SalesData</code> type, let's make it immutable and make it only perform an average calculation instead, as we have shown in our schema.</p><p class="calibre8">
<code class="literal">SalesData</code> should:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Store revenue numbers</li><li class="listitem">Be an immutable function for calculating its average</li></ul></div><p class="calibre8">Let's refactor the <code class="literal">SalesData</code> structure and remove all other methods to follow our new structure</p><div class="informalexample"><pre class="programlisting">struct SalesData {
  let revenue: [Int]
 
  var average: Int {
    return revenue.reduce(0, combine: +) / revenue.count
  }
}</pre></div><p class="calibre8">Here is the solution<a id="id397" class="calibre1"/> and it's very clean and simple. Instead of a function we have used a computed property. Swift tends to use more read-only properties for immutable data and in our example it will make for better readability in the future. Also, we have finally used the <code class="literal">reduce</code> method for calculating the average. We can use it in this way:</p><div class="informalexample"><pre class="programlisting">  let data = SalesData(revenue: [145, 24, 3012])
  data.average</pre></div><p class="calibre8">The next step is to make it work asynchronously. Let's make a new type for it. It should take a <code class="literal">SalesData</code> and a callback closure, which will return <code class="literal">Int</code>, a calculated average result.</p><div class="informalexample"><pre class="programlisting">struct AsyncOperation {

  static func calculate(data: SalesData, result: (Int) -&gt; Void ) {
    GCD.asyncOnBackground {
      let average = data.average
      GCD.asyncOnMain {
        result(average)
      }
    }
  }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">We have added two more helper methods to our GCD type:</p><div class="informalexample"><pre class="programlisting">struct GCD {
  static func asyncOnBackground(block: () -&gt; Void ) {
    dispatch_async(self.backgroundQueue(), block)
  }
  static func asyncOnMain(block: () -&gt; Void ) {
    dispatch_async(self.mainQueue(), block)
  }
}</pre></div></div><p class="calibre8">This code looks okay, but there is one more issue with it. Calling an average is embedded together with switching to the background and main threads. It would be better if we kept these functions separate, so they could be reused if we wanted to add growth numbers and do a similar<a id="id398" class="calibre1"/> calculation for them.</p><div class="informalexample"><pre class="programlisting">static func calculateAverage(data: SalesData, result: (Int) -&gt; Void ) {
  runAsync(data.average, result: result)
}

//MARK: - Private
private static func runAsync&lt;T&gt;(@autoclosure(escaping) work: () -&gt; T, result: (T) -&gt; Void ) {
  GCD.asyncOnBackground {
    let x = work()
    GCD.asyncOnMain {
      result(x)
    }
  }
}</pre></div><p class="calibre8">Here we created a <code class="literal">runAsync</code> generic function that performs some work on the background, and returns its result on the main thread. We have used an <code class="literal">@autoclosure(escaping)</code> attribute here in order to be able to pass an expression <code class="literal">data.average, ...)</code> instead of wrapping it into a closure manually. This makes the code syntax cleaner.</p><p class="calibre8">Now we can calculate the average in an asynchronous way.</p><div class="informalexample"><pre class="programlisting">let data = SalesData(revenue: [145, 24, 3012])
AsyncOperation.calculateAverage(data) { average in
  print(average)
}</pre></div><p class="calibre8">Now it's time to build our last component, a cache. For the caching functionality a dictionary would be the best choice. Let's add a dictionary to store average results for <code class="literal">SalesData</code>.</p><div class="informalexample"><pre class="programlisting">struct SalesDataCache {
  var revenueCache = [SalesData : Int]()
 
  subscript (data: SalesData) -&gt; Int? {
    return revenueCache[data]
  }

  mutating func getAverage(data: SalesData, result: (Int) -&gt; Void) {
    if let average = self[data] {
      result(average)
    } else {
      AsyncOperation.calculateAverage(data) { average in
        self.revenueCache[data] = average
        result(average)
      }
    }
  }
}</pre></div><p class="calibre8">We have created <a id="id399" class="calibre1"/>a <code class="literal">SalesDataCache</code> struct with one property, a cache, and a function to get the average value that either gives a cached value or calculates it and then saves it to the cache and returns. A very simple solution, but it won't work. It shows an error: <span class="strong"><strong class="calibre9">Type 'SalesData' does not conform to protocol 'Hashable'</strong></span>.</p><p class="calibre8">The keys in the dictionary have to be <code class="literal">Hashable</code>, so we need to implement this in our <code class="literal">SalesData</code> type. The <code class="literal">Hashable</code> protocol requires that we implement the <code class="literal">hashValue </code>property and the equality function.</p><div class="informalexample"><pre class="programlisting">var hashValue: Int { get }
func ==(lhs: Self, rhs: Self) -&gt; Bool</pre></div><p class="calibre8">Implementing a good hash function for an array of numbers is quite complex. The easiest way to do it is to add an <code class="literal">id</code> property to <code class="literal">SalesData</code> that will uniquely identify it.</p><div class="informalexample"><pre class="programlisting">struct SalesData {
  let id: Int
  revenue: [Int]
}

//MARK:- Hashable
extension SalesData: Hashable {
  var hashValue: Int {
    return id.hashValue
  }
}

func == (lhs: SalesData, rhs: SalesData) -&gt; Bool {
  return lhs.id == rhs.id
}</pre></div><p class="calibre8">Now our cache will work and we can finally use it in our application. Let's do that:</p><div class="informalexample"><pre class="programlisting">let range = 0...10
var cache = SalesDataCache()
let salesData = range.map {
  SalesData(id: $0, revenue: makeRandomArray(1000))
}

for data in salesData {
  cache.getAverage(data) { average in
    print(average)
  }
}</pre></div><p class="calibre8">As you can see, the API we have created is really easy to use. Even though there is a lot of logic going on behind the scenes, for you it's as simple as calling one method: <code class="literal">getAverage</code>.</p><p class="calibre8">Also, we have structured the underlying components in such a way that they can be used separately—for example, if we don't need a cache or asynchronous execution.</p><p class="calibre8">To wrap up the<a id="id400" class="calibre1"/> refactoring work on this example, let's see the full code we have ended up with:</p><div class="informalexample"><pre class="programlisting">struct SalesData {
  let id: Int
  let revenue: [Int]
 
  var average: Int {
    return revenue.reduce(0, combine: +) / revenue.count
  }
}

//MARK:- Hashable
extension SalesData: Hashable {
  var hashValue: Int {
    return id.hashValue
  }
}

func == (lhs: SalesData, rhs: SalesData) -&gt; Bool {
  return lhs.id == rhs.id
}

struct AsyncOperation {

  static func calculateAverage(data: SalesData, result: (Int) -&gt; Void) {
    runAsync(data.average, result: result)
  }

  //MARK: - Private
  private static func runAsync&lt;T&gt;(@autoclosure(escaping) work: () -&gt; T, result: (T) -&gt; Void ) {
    GCD.asyncOnBackground {
      let x = work()
      GCD.asyncOnMain {
        result(x)
      }
    }
  } 
}

struct SalesDataCache {
  private var revenueCache = [SalesData : Int]()

  subscript (data: SalesData) -&gt; Int? {
    return revenueCache[data]
  }

  mutating func getAverage(data: SalesData, result: (Int) -&gt; Void)  {
    if let average = self[data] {
      result(average)
    } else {
      AsyncOperation.calculateAverage(data) { average in
        self.revenueCache[data] = average
        result(average)
      }
    }
  }
}</pre></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Controlling the lifetime" id="1R42S1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec56" class="calibre1"/>Controlling the lifetime</h1></div></div></div><p class="calibre8">In our code, we<a id="id401" class="calibre1"/> have used an <code class="literal">@autoclosure(escaping)</code> attribute. It is a very powerful attribute and it deserves to be covered in detail. There is also an <code class="literal">@noescape</code> attribute. Let's explore them in more detail.</p></div>

<div class="book" title="Controlling the lifetime" id="1R42S1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="Applying the @autoclosure and @noescape attributes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec65" class="calibre1"/>Applying the @autoclosure and @noescape attributes</h2></div></div></div><p class="calibre8">First, let's have a<a id="id402" class="calibre1"/> look at when and how we could use these attributes. We can apply them to a function parameter with a function type. A<a id="id403" class="calibre1"/> function type can be represented as a method, function, or <a id="id404" class="calibre1"/>closure and it has <code class="literal">(parameters) -&gt; (return)</code> notation. Here are a<a id="id405" class="calibre1"/> few examples:</p><div class="informalexample"><pre class="programlisting">func aFunc(f: () -&gt; Void )
func increase(f: () -&gt; Int ) -&gt; Int
func multiply(f: (Int, Int) -&gt; Int ) -&gt; Int</pre></div></div></div>

<div class="book" title="Controlling the lifetime" id="1R42S1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="@autoclosure"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec66" class="calibre1"/>@autoclosure</h2></div></div></div><p class="calibre8">The <code class="literal">@autoclosure</code> attribute <a id="id406" class="calibre1"/>can be applied to a parameter with a function<a id="id407" class="calibre1"/> type that has no arguments and returns any type, <code class="literal">() -&gt; T</code>. For example:</p><div class="informalexample"><pre class="programlisting">func check(@autoclosure condition: () -&gt; Bool)
func increase(@autoclosure f: () -&gt; Int ) -&gt; Int</pre></div><p class="calibre8">When we use an <code class="literal">increase</code> function without the <code class="literal">@autoclosure</code> attribute, we need to pass a function, a method, or a closure as a parameter.</p><div class="informalexample"><pre class="programlisting">let x = 10
let res = increase( { x } )
check( { x &gt; 10 } )</pre></div><p class="calibre8">But in this use case it would be better if we could simply use an expression without the need to wrap it in a closure, like this:</p><div class="informalexample"><pre class="programlisting">let x = 10
let res = increase(x)
check(x &gt; 10)</pre></div><p class="calibre8">And that's exactly what <code class="literal">@autoclosure</code> allows us to do. When you make a parameter with the <code class="literal">@autoclosure</code> attribute, the expression you pass as an argument is automatically wrapped into a closure for you. It makes your code cleaner. That's all it does. No magic; it simply removes boilerplate code for you.</p></div></div>

<div class="book" title="Controlling the lifetime" id="1R42S1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="@noescape"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec67" class="calibre1"/>@noescape</h2></div></div></div><p class="calibre8">The <code class="literal">@noescape</code> keyword is <a id="id408" class="calibre1"/>more complex and interesting. It can be applied to a function parameter with any function<a id="id409" class="calibre1"/> type.</p><p class="calibre8">The <code class="literal">@noescape</code> attribute indicates that a closure will be used inside a function body, before the function return is called. It means it won't escape the function body.</p><p class="calibre8">When you apply this attribute, it indicates that a closure will be used synchronously inside the function body. Also, it means that it will be released when you leave the function. The lifetime of that closure parameter can't outlive the function call.</p><p class="calibre8">Applying this attribute enables some performance optimization but, more importantly, it disables the requirement to explicitly specify "<code class="literal">self.</code>" when accessing instance members.</p><p class="calibre8">Let's have a look at<a id="id410" class="calibre1"/> some examples to better understand this. For a simple example, we will use the same <code class="literal">increase</code> function, but now we will make it a method of a <code class="literal">struct</code>:</p><div class="informalexample"><pre class="programlisting">func increase(f: () -&gt; Int ) -&gt; Int {
  return f() + 1
}

struct Data {
  var number: Int
 
  mutating func increaseNumber() {
    number = increase { number }
  }
}</pre></div><p class="calibre8">The <code class="literal">increase</code> function call contains an error: <span class="strong"><strong class="calibre9">Reference to property 'number' in closure requires explicit 'self.' to make capture semantics explicit</strong></span>; we need to explicitly reference <code class="literal">self.number</code>.</p><p class="calibre8">But let's have a look at the <code class="literal">increase</code> function. The <code class="literal">f: ()-&gt; Int</code> parameter is used inside the function body and it's not leaving its scope. This is a great candidate for applying the <code class="literal">@noescape</code> attribute to it.</p><div class="informalexample"><pre class="programlisting">func increase(@noescape f: () -&gt; Int ) -&gt; Int {
  return f() + 1
}</pre></div><p class="calibre8">Now we don't need to do any further changes and explicitly reference <code class="literal">self.numbers</code>, because <code class="literal">@noescape</code> guarantees that a closure will be called before we leave that function and we can safely reference <code class="literal">self</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip36" class="calibre1"/>Tip</h3><p class="calibre8">Apply <code class="literal">@noescape</code> wherever possible. It adds an extra security level to the code. Also, it enables better optimization and increases performance.</p></div><p class="calibre8">If we have a look at methods and function such as <code class="literal">map</code>, <code class="literal">reduce</code>, <code class="literal">contains</code>, and others in the Swift standard library, you will see that they are marked with the <code class="literal">@noescape</code> attribute. The golden rule is: <span class="strong"><em class="calibre10">If you call the closure parameter before you leave the function, mark it with @noescape</em></span>.</p><p class="calibre8">Maybe in the<a id="id411" class="calibre1"/> future Swift will automatically do this for you, but for now we need to do it ourselves.</p></div></div>

<div class="book" title="Controlling the lifetime" id="1R42S1-f05765b7b5914043830034430c83d0a0">
<div class="book" title="@autoclosure (escaping)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch06lvl2sec68" class="calibre1"/>@autoclosure (escaping)</h2></div></div></div><p class="calibre8">The <code class="literal">@autoclosure</code> <a id="id412" class="calibre1"/>attribute also applies an <code class="literal">@noescape</code> implicitly. If you<a id="id413" class="calibre1"/> want to make a parameter an autoclosure, while indicating that it will have a bigger lifetime than a function, use an  <code class="literal">@autoclosure(escaping)</code> attribute. It could be useful for asynchronous code execution, like in our example with <code class="literal">AsyncOperation</code>.</p></div></div>
<div class="book" title="Summary" id="1S2JE1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec57" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In the first part of this chapter, we covered multithreading concurrency and multi-core device architecture. This general information allows us to understand the core principles of concurrent code execution.</p><p class="calibre8">In the second part, we covered three ways to run code asynchronously in Swift, by using threads, GCD, and NSOperation. We have explored the differences between them and the situations for which each is most suitable.</p><p class="calibre8">In the third part of the chapter, we concentrated on architecting asynchronous Swift code by using GCD. We have covered important tips such as passing a callback function parameter, avoiding a state, using immutable values, and others. Also, we have covered two Swift attributes—<code class="literal">@noescape</code> and <code class="literal">@autoclosure</code>—that are very useful.</p><p class="calibre8">In the next chapter, we will cover one more important performance optimization technique: Lazy Loading.</p></div></body></html>