["```kt\nfun <T> printAndClear(list: MutableList<T>) {\n```", "```kt\n    for (e in list) {\n```", "```kt\n        println(e)\n```", "```kt\n        list.remove(e)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nprintAndClear(mutableListOf(\"a\", \"b\", \"c\"))\n```", "```kt\nprivate fun <T> printAndClear(list: MutableList<T>): \n```", "```kt\n  MutableList<T> {\n```", "```kt\n    for (e in list) {\n```", "```kt\n        println(e)\n```", "```kt\n    }\n```", "```kt\n    return mutableListOf()\n```", "```kt\n}\n```", "```kt\ndata class Player(var score: Int)\n```", "```kt\nval scores = listOf(Player(0))\n```", "```kt\nval threads = List(2) {\n```", "```kt\n        thread {\n```", "```kt\n            for (i in 1..1000) {\n```", "```kt\n                scores[0].score++\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\nfor (t in threads) {\n```", "```kt\n    t.join()\n```", "```kt\n}\n```", "```kt\nprintln(scores[0].score) // Less than 2000 for sure\n```", "```kt\nthread { \n```", "```kt\n    for (i in 1..1000) { \n```", "```kt\n        scores[0].score = scores[0].score + 1 \n```", "```kt\n    }\n```", "```kt\n    println(\"Done\")\n```", "```kt\n}\n```", "```kt\nval pair = \"a\" to 1\n```", "```kt\npair.first = \"b\" // Doesn't work\n```", "```kt\npair.second = 2  // Still doesn't\n```", "```kt\nval (key, value) = pair\n```", "```kt\nprintln(\"$key => $value\")\n```", "```kt\nfor (p in mapOf(1 to \"Sunday\", 2 to \"Monday\")) {\n```", "```kt\n   println(\"${p.key} ${p.value}\")\n```", "```kt\n}\n```", "```kt\nval firstEdition = Triple(\"Design Patterns with Kotlin\",   310, 2018)\n```", "```kt\nfun generateMultiply(): (Int) -> Int {\n```", "```kt\n    return fun(x: Int): Int {\n```", "```kt\n        return x * 2\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nfun generateMultiply(): (Int) -> Int {\n```", "```kt\n    return { x: Int ->\n```", "```kt\n        x * 2\n```", "```kt\n    }\n```", "```kt\n} \n```", "```kt\n(Int) -> Int\n```", "```kt\n() -> Int\n```", "```kt\n(Int) -> Unit\n```", "```kt\nval multiplyFunction = generateMultiply()\n```", "```kt\n...\n```", "```kt\nprintln(multiplyFunction(3, 4))\n```", "```kt\nfun mathInvoker(x: Int, y: Int, mathFunction: (Int, Int) ->   Int) {\n```", "```kt\n    println(mathFunction(x, y))\n```", "```kt\n}\n```", "```kt\nmathInvoker(5, 6, multiplyFunction)\n```", "```kt\nmathInvoker(7, 8) { x, y ->\n```", "```kt\n   x * y\n```", "```kt\n}\n```", "```kt\nval dwarfs = listOf(\"Dwalin\", \"Balin\", \"Kili\", \"Fili\",   \"Dori\", \"Nori\", \"Ori\", \"Oin\", \"Gloin\", \"Bifur\", \"Bofur\",   \"Bombur\", \"Thorin\")\n```", "```kt\nfor (d in dwarfs) {\n```", "```kt\n    println(d)\n```", "```kt\n}\n```", "```kt\ndwarfs.forEach { d -> \n```", "```kt\n    println(d)\n```", "```kt\n}\n```", "```kt\nfun <T> Iterable<T>.forEach(action: (T) -> Unit)\n```", "```kt\ndwarfs.forEach { d: String ->  \n```", "```kt\n    println(d) \n```", "```kt\n}\n```", "```kt\ndwarfs.forEach {\n```", "```kt\n    println(it)\n```", "```kt\n}\n```", "```kt\ndwarfs.forEach(::println)\n```", "```kt\nfun counter(): () -> Int {\n```", "```kt\n    var i = 0\n```", "```kt\n    return { i++ }\n```", "```kt\n}\n```", "```kt\nval next = counter()\n```", "```kt\nprintln(next())\n```", "```kt\nprintln(next())\n```", "```kt\nprintln(next())\n```", "```kt\nfun sayHello() = println(\"Hello\")\n```", "```kt\nfun hello() = \"Hello\"\n```", "```kt\nfun testHello(): Boolean {\n```", "```kt\n    return \"Hello\" == hello()\n```", "```kt\n}\n```", "```kt\nfun <T> removeFirst(list: MutableList<T>): T {\n```", "```kt\n    return list.removeAt(0)\n```", "```kt\n}\n```", "```kt\nval list = mutableListOf(1, 2, 3)\n```", "```kt\nprintln(removeFirst(list)) // Prints 1\n```", "```kt\nprintln(removeFirst(list)) // Prints 2\n```", "```kt\nfun <T> withoutFirst(list: List<T>): T {\n```", "```kt\n    return ArrayList(list).removeAt(0)\n```", "```kt\n}\n```", "```kt\nval list = mutableListOf(1, 2, 3)\n```", "```kt\nprintln(withoutFirst(list)) // It's 1\n```", "```kt\nprintln(withoutFirst(list)) // Still 1\n```", "```kt\nfun subtract(x: Int, y: Int): Int {\n```", "```kt\n    return x - y\n```", "```kt\n}\n```", "```kt\nprintln(subtract(50, 8))\n```", "```kt\nsubtract(50)(8)\n```", "```kt\nfun subtract(x: Int): (Int) -> Int {\n```", "```kt\n    return fun(y: Int): Int {\n```", "```kt\n        return x - y\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nfun subtract(x: Int) = fun(y: Int): Int {\n```", "```kt\n    return x - y\n```", "```kt\n}\n```", "```kt\nfun subtract(x: Int) = {y: Int -> x - y}\n```", "```kt\nenum class LogLevel {\n```", "```kt\n    ERROR, WARNING, INFO\n```", "```kt\n}\n```", "```kt\nfun log(level: LogLevel, message: String) =     println(\"$level: $message\")\n```", "```kt\nval errorLog = fun(message: String) {\n```", "```kt\n    log(LogLevel.ERROR, message)\n```", "```kt\n}\n```", "```kt\nfun createLogger(level: LogLevel): (String) -> Unit {\n```", "```kt\n    return { message: String ->\n```", "```kt\n        log(level, message)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nval infoLogger = createLogger(LogLevel.INFO)\n```", "```kt\ninfoLogger(\"Log something\")\n```", "```kt\nval input = listOf(\n```", "```kt\n    setOf(1, 2, 3),\n```", "```kt\n    setOf(3, 1, 2),\n```", "```kt\n    setOf(2, 3, 1),\n```", "```kt\n    setOf(4, 5, 6)\n```", "```kt\n)\n```", "```kt\nfun sum(numbers: Set<Int>): Double {\n```", "```kt\n    return numbers.sumByDouble { it.toDouble() }\n```", "```kt\n}\n```", "```kt\nval resultsCache = mutableMapOf<Set<Int>, Double>()\n```", "```kt\nfun summarizer(): (Set<Int>) -> Double {\n```", "```kt\n    val resultsCache = mutableMapOf<Set<Int>, Double>()\n```", "```kt\n    return { numbers: Set<Int> ->\n```", "```kt\n        resultsCache.computeIfAbsent(numbers, ::sum)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nval summarizer = summarizer()\n```", "```kt\ninput.forEach {\n```", "```kt\n    println(summarizer(it))\n```", "```kt\n}\n```", "```kt\nclass Cat : Animal {\n```", "```kt\n    fun purr(): String {\n```", "```kt\n        return \"Purr-purr\";\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nclass Dog : Animal {\n```", "```kt\n    fun bark(): String {\n```", "```kt\n        return \"Bark-bark\";\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\ninterface Animal\n```", "```kt\nfun getSound(animal: Animal): String {\n```", "```kt\n    var sound: String? = null;\n```", "```kt\n    if (animal is Cat) {\n```", "```kt\n        sound = (animal as Cat).purr();\n```", "```kt\n    }\n```", "```kt\n    else if (animal is Dog) {\n```", "```kt\n        sound = (animal as Dog).bark();\n```", "```kt\n    }\n```", "```kt\n    if (sound == null) {\n```", "```kt\n        throw RuntimeException();\n```", "```kt\n    }\n```", "```kt\n    return sound;\n```", "```kt\n}\n```", "```kt\nfun getSound(animal: Animal) = when(animal) {\n```", "```kt\n    is Cat -> animal.purr()\n```", "```kt\n    is Dog -> animal.bark()\n```", "```kt\n    else -> throw RuntimeException(\"Unknown animal\")\n```", "```kt\n}\n```", "```kt\nfun sumRec(i: Int, sum: Long, numbers: List<Int>): Long {\n```", "```kt\n    return if (i == numbers.size) {\n```", "```kt\n        return sum\n```", "```kt\n    } else {\n```", "```kt\n        sumRec(i+1, numbers[i] + sum, numbers)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\nval numbers = List(1_000_000) {it}\n```", "```kt\nprintln(sumRec(0,  numbers)) \n```", "```kt\n// Crashed pretty soon, around 7K\n```", "```kt\ntailrec fun sumRec(i: Int, sum: Long, numbers: List<Int>): \n```", "```kt\n  Long {\n```", "```kt\n    return if (i == numbers.size) {\n```", "```kt\n        return sum\n```", "```kt\n    } else {\n```", "```kt\n        sumRec(i+1, numbers[i] + sum, numbers)\n```", "```kt\n    }\n```", "```kt\n}\n```", "```kt\ntailrec fun mergeSort(numbers: List<Int>): List<Int> {\n```", "```kt\n    return when {\n```", "```kt\n        numbers.size <= 1 -> numbers\n```", "```kt\n        numbers.size == 2 -> {\n```", "```kt\n            return if (numbers[0] < numbers[1]) {\n```", "```kt\n                numbers\n```", "```kt\n            } else {\n```", "```kt\n                listOf(numbers[1], numbers[0])\n```", "```kt\n            }\n```", "```kt\n        }\n```", "```kt\n        else -> {\n```", "```kt\n            val left = mergeSort(numbers.slice               (0..numbers.size / 2))\n```", "```kt\n            val right = mergeSort(numbers.slice               (numbers.size / 2 + 1 until numbers.size))\n```", "```kt\n            return merge(left, right)\n```", "```kt\n        }\n```", "```kt\n    }\n```", "```kt\n} \n```", "```kt\n> \"A function is marked as tail-recursive but no tail calls are found\"\n```"]