- en: 'Chapter 5. Scripting: Whose line is it anyway?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have finally moved past the basics. As you may have observed, the tasks and
    even the assets we've been using have been getting more and more complicated along
    the way. Now that we have hit scripting, the rubber will meet the road. Scripting
    is how you breathe life into your creation and turn it into an actual game. Prior
    to this, the best we could do is move around a lifeless world by scripting the
    camera — now we get to play.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How Unity handles scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specific scripting limitations and interfaces for iOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic iOS scripts that Unity provides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate with a web service to save our data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting is possibly the most important thing that you need to know to interact
    with Unity effectively. While you can optimize your assets, build your scene efficiently,
    and take advantage of every feature on the device — if you don't get scripting
    right it won't do anything useful.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get on with it...
  prefs: []
  type: TYPE_NORMAL
- en: Important preliminary points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have a background in programming and that you
    know something about JavaScript, C#, or Boo. As these are the scripting languages
    supported by Unity, some understanding of their design is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Scripting Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity has arguably the most flexible and complete scripting system of any engine
    at any price. Providing the ability for developers to use the languages Boo, Javascript,
    and C# Unity covers the bases when it comes to supporting a variety of developers.
    While there is no specific support for Java within the system, C# is a mature
    language that provides a near peer to the language. In addition, through the .Net/Mono
    framework it is possible to roll your own support for Java, F#, or any other language
    that is supported by the .Net platform including any new language that you create,
    though it's probably easier to just build a **domain specific language (DSL)**
    using Boo. The most important part is that each language is a first class citizen
    in Unity. With few exceptions, anything you want to do in Unity can be accomplished
    regardless of which language you choose.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Scripting system is at the heart of getting things done within Unity
    customizing the Unity editor and interacting with the runtime platform. Through
    scripts you have access to everything that you would want to change (and I do
    mean everything) including being able to extend the Unity compiler through the
    **Abstract Syntax Trees (AST)** themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Oh no! You've got Mono!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Microsoft originally created the .Net platform it created it principally
    for the Windows platform. However, Microsoft published the language specification
    to ECMA and shortly thereafter, the Mono open source project was created which
    brought the .Net platform to other platforms including OSX and Linux. At its core
    the Unity scripting system is built upon the .Net runtime and the benefits afforded
    it through the Mono project. While it was certainly possible that the Unity scripting
    system could have been based upon Java or some other system, .Net provided (out-of-the-box)
    a rich system for assemblies that made cross language functionality trivial to
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: Common Language Infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple scripting languages are possible in Unity due to the **Common Language
    Infrastructure (Cli)** of .Net. The purpose of the Common Language Infrastructure
    (CLI), is to provide a language-neutral platform for application development and
    execution, including functions for exception handling, garbage collection, security,
    and interoperability. By implementing the core aspects of the .NET Framework within
    the scope of the CLI, this functionality will not be tied to a single language,
    but will be available across the many languages supported by the framework. Microsoft's
    implementation of the CLI is called the **Common Language Runtime**, or **CLR**.
  prefs: []
  type: TYPE_NORMAL
- en: Boo- more than a ghost in mario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boo is an object-oriented, statically typed programming language that seeks
    to make use of the Common Language Infrastructure's support for Unicode, internationalization
    and web-applications, while using a Python-inspired syntax and a special focus
    on language and compiler extensibility. Some features of note include type inference,
    generators, multimethods, optional duck typing, macros, true closures, currying,
    and first-class functions. Boo has been actively developed since 2003.
  prefs: []
  type: TYPE_NORMAL
- en: Boo is free software released under an MIT/BSD style license. It is compatible
    with both the Microsoft .NET and Mono frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: What does a Boo script look like?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Should I choose Boo?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're looking for a new and novel way to write code that doesn't have a
    lot of ceremony and doesn't waste your time with lots of curly braces, Boo is
    definitely a language you want to look into. While the idea of using whitespace
    as a delimiter is considered offensive by some, there is an elegance that comes
    from writing code in Boo. If you've written in traditional languages it's not
    difficult to understand and there are some functions of Unity (not the iOS version)
    which can only be accessed using Boo.
  prefs: []
  type: TYPE_NORMAL
- en: While Boo is a fine language, there are two reasons why you shouldn't choose
    it.
  prefs: []
  type: TYPE_NORMAL
- en: First, there are very few examples written in Boo and very little written about
    it in the community at large.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More importantly, Boo is not currently supported on the iOS platform as of this
    writing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, our discussion of Boo within the context of iOS comes to an abrupt
    end.
  prefs: []
  type: TYPE_NORMAL
- en: UnityScript/JavaScript — Relevant beyond the web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is an implementation of the ECMAScript language standard and is typically
    used to enable programmatic access to computational objects within a host environment.
    It can be characterized as a prototype-based object-oriented scripting language
    that is dynamic, weakly typed, and has first-class functions. It is also considered
    a functional programming language like Scheme and OCaml because it has closures
    and supports higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: While UnityScript is, on the surface, syntactically similar to Javascript, the
    implementation used by Unity is not entirely ECMAScript compliant.
  prefs: []
  type: TYPE_NORMAL
- en: What does a JavaScript script look like?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Should I choose JavaScript?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is the defacto language in use by the Unity community and is prevalent
    across the web. Many people refer to Javascript as Unityscript. There are many
    people in the world who use it on a daily basis and if you're coming from a Flash
    background this is as close to ActionScript porting ease as you're likely to get
    (until someone ports ActionScript over to Unity). One of the strong benefits of
    JavaScript is that there isn't a lot of ceremony involved with getting things
    done and in most cases you will find that you write a lot less boilerplate to
    build an application with JavaScript. There is no need to create class structures
    and there isn't much need in getting directly to the attributes of objects and
    using them.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is available on all platforms including the iPhone, but as you begin
    building more complex examples with larger teams you may find that having more
    structure and typing will result in fewer defects. In addition, while JavaScript
    is the community choice today most authors and developers are moving over to C#
    as their primary development language.
  prefs: []
  type: TYPE_NORMAL
- en: C# The revenge of Microsoft
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# (pronounced "see sharp")[6] is a multi-paradigm programming language encompassing
    imperative, declarative, functional, generic, object-oriented (class-based), and
    component-oriented programming disciplines. It was developed by Microsoft within
    the .NET initiative and later approved as a standard by Ecma (ECMA-334) and ISO
    (ISO/IEC 23270). C# is one of the programming languages designed for the Common
    Language Infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: C# is intended to be a simple, modern, general-purpose, object-oriented programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: What does a C# script look like?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Should I choose C#?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a language, C# will be familiar to anyone who has done any modern object-oriented
    programming in the past 10 years. The syntax is very familiar for Java developers
    and reasonably easy for C++ developers to pick up.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of libraries that are available on the Internet that can
    be dropped right into your project to do things like XML parsing, connecting to
    social networks, loading pages, etc. In addition there is a critical mass of C#
    developers in the Unity community such that there is an increased emphasis on
    doing projects and documentation on C# going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, many of those that have published large numbers of iOS projects have
    stated that C# is an easier path to take for writing applications. If you're coming
    from a professional game development background or want a clean object-oriented
    Java/Pascal syntax this is your best choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the rest of the book, we will be using C# as the language for scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Creating and organizing scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a new C# script in Unity is similar to our approach for creating scripts
    using JavaScript or any of the other scripting languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select **Assets | Create | C Sharp Script**. This will create a new C# script
    in the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: While the Boo Script does appear as an option, it is not usable for Unity iOS
    projects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Creating and organizing scripts](img/978-1-84969-040-9_5_1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once you have created the new script it will appear in the **Project** view
    with the name `NewBehaviorScript` with some stubs for the methods `Start()` and
    `Update():`![Time for action — Creating and organizing scripts](img/978-1-84969-040-9_5_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder named `Scripts` and then drag the newly created script into
    the Scripts directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A best practice for scripts is to put them in a folder in the project. What
    you call this folder doesn't really matter, as it is more for your own organizational
    purposes than it is for Unity. You may choose to put UI centric scripts in one
    directory and AI scripts in another. However you manage the scripts is up to you,
    but you will create a large number of scripts in the course of creating the average
    game so you want to organize them so that they aren't all sitting at the root
    of your game project.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching scripts to Game Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, you can add a script to a **GameObject** by simply dragging
    the script onto the game object itself. What is important here, is that the **GameObject**
    is the owner of the script, if that game object is not participating in the scene
    — the methods in the script will never be called. For scripts that are global
    in nature, a common practice is to create an Empty Game Object in the scene and
    attach the global scripts to it. While it is common for people to associate these
    global scripts with the camera, you want to avoid this as many complex games will
    have many cameras — complicating the activation of the scripts as well as determining
    which object in the scene owns them.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing variables in the Unity editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often you will find yourself in the position of having written a script
    providing some values for variables within your script. As you test your game
    you will find that you will want to expose some of these variables to the Unity
    Editor so that you can modify them in the editor without having to edit and recompile
    the scripts themselves.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly important since many times you will want to provide a default
    value within the script which you can override due to some specific game use case.
    Rather than coming up with some complex mechanism to do this, simply declare the
    variable as a public variable and it will show up in the Unity editor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Key scripting methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scripting inside Unity consists of attaching custom script objects called behaviors
    to game objects. Different functions inside the script objects are called on certain
    events. The most used ones being the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Awake` | Called when the script object is being loaded but after all Game
    Objects have been initialized |'
  prefs: []
  type: TYPE_TB
- en: '| `Start` | Called only one time when the object this script is attached to
    is initially used in the scene |'
  prefs: []
  type: TYPE_TB
- en: '| `Update` | This function is called before rendering a frame. This is where
    most game behavior code goes, except physics code. |'
  prefs: []
  type: TYPE_TB
- en: '| `FixedUpdate` | This function is called once every physics time step. This
    is the place to do physics-based game behavior. Unlike Update, this method is
    not called every time, but at a specific interval.Use this for things that should
    be frame rate independent. |'
  prefs: []
  type: TYPE_TB
- en: '| `LateUpdate` | This function is called after Update has been called. This
    is useful if you want to execute some functionality after all of the other objects
    in the scene have been updated. |'
  prefs: []
  type: TYPE_TB
- en: '| `"Other Methods`" | Code outside functions is run when the object is loaded.
    This can be used to initialize the state of the script. |'
  prefs: []
  type: TYPE_TB
- en: iPhoneSettings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the iOS SDK promises to give you a single platform to all of the iOS devices,
    there are going to be times that you want to do device specific things. For example,
    you may want to load Retina Display compatible assets if you are on the iPhone4
    or you may want to provide another networking interface other than Game Center
    if you find yourself on a 1G, 2G, or base 3G device. Further, you may want to
    determine where this device is located in the world. All of this is accomplished
    by gaining access to iPhoneSettings.
  prefs: []
  type: TYPE_NORMAL
- en: Screen orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: iPhoneSettings provides an interface for getting the current screen orientation
    from the device and it will allow you to specify the orientation you want your
    content to be displayed in.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to only operate in one mode, you can attach a script to the camera
    and in its `Start()` method define the orientation you want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Later in the chapter we will build an example that illustrates how to move between
    the multiple modes that the device is capable of, as the user changes the device
    orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Sleep mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, any iOS portable device will follow power management settings and
    darken its screen after a certain amount of time to prevent draining the battery
    if the user isn't using it. The iOS power management system will reset its internal
    timers every time a touch event happens on the device. However, for games this
    may become a problem since you may not require the user to maintain contact with
    the device or through a Bluetooth keyboard during gameplay. Driving games and
    flight simulators come immediately to mind as two genres of games that may be
    impacted by this.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases it makes sense to put the device in a state where the device
    will not be allowed to go to sleep. This can be accomplished by setting the `screenCanDarken`
    attribute of `iPhoneSettings` to `false`. It is important to review that statement
    again the device will not be allowed to go to sleep EVER. As long as your application
    is running, it will block the device from entering a sleep state. Consequently,
    it is your responsibility to make sure that if you leave the states of your game
    where users aren't touching the device that you flip the `screenCanDarken` attibute
    to `true` so that iOS can darken the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Device information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides several useful fields to the developer that gives information
    about the device and its unique identification.
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| name | This is the name that the user has given to the device. Useful if
    you want to allow users to find one another across the wan or locally |'
  prefs: []
  type: TYPE_TB
- en: '| model | Provides a simple text model name |'
  prefs: []
  type: TYPE_TB
- en: '| systemName | This is simply the name of the OS running on the device |'
  prefs: []
  type: TYPE_TB
- en: '| generation | This will tell you what generation this device belongs to. The
    values are enumerated in iPhoneGeneration and provide a reliable way to determine
    exactly what type of device the user has |'
  prefs: []
  type: TYPE_TB
- en: '| uniqueIdentifier | This is the globally unique identifier that identifies
    this device specifically |'
  prefs: []
  type: TYPE_TB
- en: Time for action — Identifying the type of iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that we have designed our application such that it is optimized
    for high definition (HD) on iPhone 4 and the iPad.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the player runs this version of our application we want to tell them that
    the application would perform better if they used the standard definition (SD)
    version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: We will do this by detecting the device and either starting the application
    immediately or showing them a notice screen and then starting the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through the steps that would be necessary for this application functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the type of device we are using.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on conditional logic display a splash screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dismiss the splash screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify our device information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Add some device detection to the Start() script that we're attaching to our
    Camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we're looking for are iOS generations that are older than the iPhone4 and
    the iPad. We can check for this by looking at the value of `iPhoneSettings.generation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We choose `iPhoneSettings.generation` as opposed to `iPhoneSettings.model` because
    generation will return us an enumerated type and since all of the models are represented
    — this will be less error prone than trying to compare strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Conditionally show splash screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know whether or not we have an HD "qualified" device, we have the
    ability to conditionally display a screen. In this example we have built out our
    SD display as a level all on its own. This was done so that we could compartmentalize
    this body of work by itself without it cluttering up the rest of the game.
  prefs: []
  type: TYPE_NORMAL
- en: To load this SD purchase suggestion level we make a call to the `Application.LoadLevel()`
    method and provide it the name of the level that we want to load in this case
    it will be our `"SDAdvisory`" level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unity will now load this level and display it on the screen. Since we've set
    its background to just be an image for displaying this information we need to
    provide a mechanism for this advisory to be dismissed.
  prefs: []
  type: TYPE_NORMAL
- en: Dismiss the splash screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our new scene we want to be able to acknowledge that we've seen the advisory
    that we should be using the SD version of the game, yet proceed to playing the
    game in high definition. If you aren't building universal binaries of your game
    (which you should!), you should check for the appropriateness of the version of
    the content the user is attempting to run.
  prefs: []
  type: TYPE_NORMAL
- en: To dismiss this level and load our regular game we need to display a button
    on the screen that the user can click on and we need to listen for activity on
    this button. UnityGUI provides a clean mechanism to do this quickly, albeit not
    with the best performance. Ways to improve this performance will be covered in
    the Performance and Optimization sections later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now when the user clicks on the button with the `I Understand` label, the application
    will load the level `MainGame` and our game will continue on without any further
    interruption.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Unity started the player on our iOS device, it populated the `iPhoneSettings`
    class with the settings for our device. Since our script was attached to an object
    in the scene, our script had the ability to read these settings from the Unity
    player on the device. Based upon this we used a simple C# conditional if statement
    to determine if we were fine to start or needed to display a standard definition
    splash screen. We then presented a simple `UnityGUI` script that waited for the
    user to press a button which launched the main game.
  prefs: []
  type: TYPE_NORMAL
- en: Location services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The location services provide an interface to the cell tower triangulation and
    GPS functions of the device. You can get the status of the services through `iPhoneSettings`,
    and the location data will be available through `iPhoneInput.lastLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: To start the service, access the `StartlocationServiceUpdates()` method and
    give it the accuracy that you desire, as well as the update distance, both in
    meters. The update distance is the amount that the device must move before it
    will update the `iPhoneInput.lastLocation`. If you are familiar with using CoreLocation,
    you are familiar with the location services for iOS as Unity provides a wrapper
    around the CoreLocation API and simply exposes the data updates through `iPhoneInput.lastLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note, however, that GPS satellite acquisition is not instantaneous
    and Unity will expose the state of CoreLocations's response in the `LocationServiceStatus`
    attribute. This will return one of several LocationServiceStatus states which
    can be polled until you achieve a `LocationServiceStatus`. Running in the field
    at which point you will have actual GPS data in `iPhoneInput.lastLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Changing state according to player location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Location-based gaming is one area of innovation that has gone largely underutilized
    by the game development community. Let's suppose that we want to start a whole
    line of games that utilize the actual players location information to change some
    of the state in our game. For our purposes we will utilize the players location
    to determine the weather in their area, as well as the time of day so that we
    can have the player's game world match the world outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the steps that would be necessary for this application''s
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the location services on our device,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Poll the device location information,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the weather for this location,
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the location services on our device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As this is something that we only need to do when our application first starts,
    we can perform all of our operations in the `Start()` method of our script. All
    we need to do is:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `iPhoneSettings.StartLocationServiceUpdates()` method and Unity will
    start its interaction with the platform's CoreLocation services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that the location services have started, we need to wait for them to be
    available. Location services do not activate immediately and if the GPS is being
    utilized, the internal systems will have to acquire satellites to triangulate
    the device's location. If we try to acquire information from the device before
    this has completed, the resulting behavior is not defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to wait for the location services to start we need to enter a loop
    where we will check for the status of the location services and then enter a short
    wait state before checking again. We can do this by specifying an amount of time
    to wait that we configure in the Unity editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose variable to Unity editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To expose a variable to the Unity editor we need to define it in such a way
    that it is public in our script. This will allow Unity to expose this variable
    to the rest of the IDE and we will be able to change the value for this variable
    without having to edit the script again.
  prefs: []
  type: TYPE_NORMAL
- en: In our example we want to expose the maximum amount of time we will wait before
    we assume that we won't get location services working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be represented inside of the Unity Editor in the Inspector when you
    examine the Game Object that this script is attached to. In our example, if you
    take a look at the Camera object that we''ve attached this script to you will
    see the variable and whatever value it currently has. If you change this value,
    you will be overriding the default value that the script is providing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Expose variable to Unity editor](img/978-1-84969-040-9_5_3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Unity provides an overridden method WaitForSeconds, which takes an amount of
    time to wait. In order for us to invoke this method, we must:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a yield operation to tell Mono that our code needs to pause while this
    function runs. Normally one would simply add this as a single line of code, however,
    C# requires that the method which performs this yield has a different return type
    other than `void`. Thus, we cannot simply expose this in our `Start()` function.
    However, this is easily remedied by providing a secondary function which can handle
    this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can invoke this method from inside our `Start()` function, wait for a
    certain amount of time and then check to see if the location services are available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will check the status of the device, wait for 2 seconds and then check
    again. Each time it will reduce the number of retries remaining. When this reaches
    zero we can safely assume that either the user has chosen to not allow location
    services or there is something wrong which is preventing the location services
    from working (like Airplane Mode).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A second method that could be accomplished is to change the signature of the
    `Start()` method from one that returns `void` to one that returns `IEnumerator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Either mechanism is acceptable depending on what you intend to do and the style
    of development you're accustomed to. Both are included here for completeness.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Poll the device location information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know that the device is giving us location data, we can simply look
    in the `iPhoneInput.lastLocation` variable and extract the longitude and latitude.
    From these we can then integrate with a web service, which can tell us what the
    weather is where the device is located.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Get the weather for this location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know the latitude and longitude for the device, we can get the weather
    at this location so that we can use it in our game. To accomplish this we will
    use Google's Weather API and parse the XML we receive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The code first starts by defining variables that will store the results of
    our weather query: city, conditions, tempC, tempF, humidity, and wind.'
  prefs: []
  type: TYPE_NORMAL
- en: The `forLocation()` method takes latitude and longitude and converts them into
    the format that Google expects (the API doesn't support the decimal version of
    lat/lon — just an integer representation).
  prefs: []
  type: TYPE_NORMAL
- en: Next the API requests the XmlDocument from the Google servers by compositing
    the URL that will be passed to Google and telling the C# to load this data. Once
    it has returned we simply select the `current_conditions` for our location and
    we now have the weather for where our player is currently playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We activated the location services on our device and polled the device to determine
    where our device was located. We entered a wait loop to give the location services
    a chance to start and provide the user an opportunity to interact with the OS
    and give our application permission to use the gathered data. But, for our inability
    to launch this application remotely we just performed the same job as `FindMyiPhone`.
    Next we interfaced with a web service, which provided us the location that this
    lat/lon represents. With this information we accessed another web service that
    told us what the weather was in this location. By exposing this data to our environment
    script in the game we have created a game that uses real location data to function.
  prefs: []
  type: TYPE_NORMAL
- en: Screen manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the great things about modern smart phones is that they enable the device
    to be operated from a horizontal or vertical orientation. Due to this, it has
    become expected behavior that games are able to work in whatever orientation the
    device is in. Fortunately, there are ways to detect the screen orientation and
    have Unity update our content as a result of the change in device orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Rotating the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One piece of functionality, that I felt an odd omission from the iOS Unity product,
    was that of "out of the box" rotation so that when a user flips the screen, the
    game flips orientation as well. Fortunately we can rectify that with a simple
    rotation script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the steps that would be necessary for this application
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying that the screen orientation has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the player orientation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see how it is done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying that the screen orientation has changed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in handling an orientation change is:'
  prefs: []
  type: TYPE_NORMAL
- en: To actually realize that the orientation has changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two ways we can do this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can either check when the game first starts up only, in which case we need
    to put our orientation detection in the `Start()` method as it is only called
    once.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to check orientation changes as the user is playing the game then
    we need to check the state of the orientation on a frame-by-frame basis. We do
    this by putting our orientation code in the `Update()` method.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Input.deviceOrientationXE` "Input.deviceOrientation method" | Returns the
    physical orientation of the device |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: We will use the `deviceOrientation` attribute of the `Input` class to determine
    what the orientation of the device is. This information comes directly from the
    OS in real time, so as the orientation changes, we will be notified and can respond
    to the change without having to interrupt gameplay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Updating player orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know that the orientation has changed we need to update the Unity
    iOS player so that it displays our content with the proper orientation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `iPhoneSettings.screenOrientation` | Sets the logical orientation of the
    screen. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With `iPhoneSettings.screenOrientation` we can now tell the Unity player to
    change its orientation. You can set the orientation to any one of the `iPhoneScreenOrientations`
    available. It is recommended that you don't do anything that would be uncharacteristic
    to the way the iOS device is expected to operate as Apple may reject your application
    for that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By adding a script to our camera we get an `Update()` notification on a frame
    by frame basis. We can then look to see what the device orientation is and adjust
    our orientation accordingly. By updating the `iPhoneSettings` attributes we can
    quickly flip our scene to match whatever orientation we find ourselves in.
  prefs: []
  type: TYPE_NORMAL
- en: iPhoneUtils
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`iPhoneUtils` is a set of simple utilities to perform some basic functions
    on the iOS device. There isn''t much in `iPhoneUtils`, but it does provide functionality
    to determine if your application has been tampered with on the device, trigger
    vibration on the phone, and play movies.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing movies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two mechanisms for playing movies within iPhoneUtils: `PlayMovie`
    and `PlayMovieURL. PlayMovie` will play content that is on the phone in the `StreamingAssets`
    folder. Given that you have limited resources to move content if you want to perform
    over the air (OTA) distribution, `PlayMovie` may not be of use to you. `PlayMovie`
    is best suited to game cut scenes and your initial game intro movie since these
    will generally not be long.'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayMovieURL` is more practical for long running movies, dynamic content that
    you want to deliver to the user (episodic), or content that is simply too large
    to reasonably be distributed within your application. Remember, these are still
    mobile devices and they have bandwidth constraints. If you make your app large
    enough that it cannot be downloaded over the air, you are placing a limitation
    on your possible audience and hurting your customer''s experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Is my application genuine?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While not the end all in determining whether or not someone has stolen your
    application, `isApplicationGenuine` provides a mechanism through which you can
    detect if the application has been tampered with. It won't catch every pirate
    out there, but it is a useful function. Don't depend on this function exclusively
    for combating piracy!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Yarr! There be pirates!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reality check people are going to steal your game. For whatever reason they
    do it, you probably want to do something in response. Let's suppose that we want
    to detect whether or not someone has pirated our application and if they have
    stream them an advertisement movie from the web before continuing to a demo version
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the steps that would be necessary for this application
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step in this process is to create a demo scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this scene put all of your assets that you want to comprise this scene. In
    my case I'll create a simple scene that displays a simple puppy sitting by some
    rocks. You can control the puppy and move him around the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's create a demo version of the scene. For demo purposes I'll use the
    same puppy, but I will just set him up in a sleep animation loop in this scene.
    Whenever a user enters the demo world, all the puppies that they find will be
    asleep.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on conditional logic, display the demo scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can determine if our application hasn't been signed by Apple by checking
    the `iPhoneUtils.isApplicationGenuine` property. It is important to note that
    when you're building the application on your local machine it will return `false`.
    It will not return `true` until it has been signed by Apple and is on its way
    to the AppStore. Therefore, you do not want to simply check to see if the application
    is genuine and then refuse to load if it isn't as the reviewer may determine that
    your app doesn't work and then reject it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the unity player starts we check to see if this is an authentic version
    of our application. If Unity detects that the application has been tampered with
    it will send the user to an ad and a demo version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: But let's stop for a second. Pirates will STILL be able to get around this and
    they will be able to write a specific patch for your application. At this time
    there is no fool-proof mechanism for detecting or preventing piracy of any iOS
    application. As long as an iOS device can be jailbroken, people can get around
    any mechanism you put in place to prevent piracy. I put this example in here so
    that you will have some idea about creative ways to work with the reality of the
    situation, but don't expect that this alone will prevent piracy of your app.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of this writing Unity iOS did not have functionality to access the
    camera for taking pictures or streaming video. While there is certainly a gap
    there, this is a functionality which is generally not used in games. However,
    if you do want to gain access to the camera you have two choices; write a native
    code plugin for the camera or license the Prime31 Etcetera plugin ([http://www.prime31.com](http://www.prime31.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned about the different Unity scripting languages at
    a high-level and gained some insight into C# as a scripting language, which we
    will continue to use throughout the remainder of the book. In addition, we spent
    some time looking at the iPhone specific scripting interfaces and building a number
    of real-world examples, which utilize the functions available to you in the Unity
    iOS player.
  prefs: []
  type: TYPE_NORMAL
- en: With this specific iOS scripting under our belt and our demo project updated,
    we can continue and begin integrating with the iOS input system the keyboard,
    the touchscreen, and the accelerometer.
  prefs: []
  type: TYPE_NORMAL
