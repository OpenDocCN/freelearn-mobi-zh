- en: 'Chapter 5. Scripting: Whose line is it anyway?'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。脚本：到底是谁的台词？
- en: We have finally moved past the basics. As you may have observed, the tasks and
    even the assets we've been using have been getting more and more complicated along
    the way. Now that we have hit scripting, the rubber will meet the road. Scripting
    is how you breathe life into your creation and turn it into an actual game. Prior
    to this, the best we could do is move around a lifeless world by scripting the
    camera — now we get to play.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们终于走过了基础阶段。如您所观察到的，我们一直在使用的任务和资产变得越来越复杂。现在我们已经触及脚本，现实将变得具体。脚本就是您赋予创作生命并使其成为实际游戏的方式。在此之前，我们最好的做法是通过脚本相机在无生命的世界上移动——现在我们可以玩游戏了。
- en: 'In this chapter we shall learn:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: How Unity handles scripting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 如何处理脚本
- en: The specific scripting limitations and interfaces for iOS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS 的特定脚本限制和接口
- en: The basic iOS scripts that Unity provides
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 提供的基本 iOS 脚本
- en: Integrate with a web service to save our data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据集成到网络服务中保存
- en: Scripting is possibly the most important thing that you need to know to interact
    with Unity effectively. While you can optimize your assets, build your scene efficiently,
    and take advantage of every feature on the device — if you don't get scripting
    right it won't do anything useful.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可能是您需要了解的最重要的东西，以便有效地与 Unity 交互。虽然您可以优化您的资产，高效地构建场景，并利用设备上的每一个功能——但如果您没有正确处理脚本，它将不会做任何有用的事情。
- en: So let's get on with it...
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们就开始吧...
- en: Important preliminary points
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的预备知识
- en: This chapter assumes that you have a background in programming and that you
    know something about JavaScript, C#, or Boo. As these are the scripting languages
    supported by Unity, some understanding of their design is necessary.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您有编程背景，并且对 JavaScript、C# 或 Boo 有所了解。由于这些是 Unity 支持的脚本语言，对这些语言的设计有一定的了解是必要的。
- en: Unity Scripting Primer
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity 脚本入门
- en: Unity has arguably the most flexible and complete scripting system of any engine
    at any price. Providing the ability for developers to use the languages Boo, Javascript,
    and C# Unity covers the bases when it comes to supporting a variety of developers.
    While there is no specific support for Java within the system, C# is a mature
    language that provides a near peer to the language. In addition, through the .Net/Mono
    framework it is possible to roll your own support for Java, F#, or any other language
    that is supported by the .Net platform including any new language that you create,
    though it's probably easier to just build a **domain specific language (DSL)**
    using Boo. The most important part is that each language is a first class citizen
    in Unity. With few exceptions, anything you want to do in Unity can be accomplished
    regardless of which language you choose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 毫无疑问是任何价格范围内最灵活和最完整的脚本系统之一。它为开发者提供了使用 Boo、JavaScript 和 C# 等语言的能力，Unity
    在支持各种开发者方面覆盖了所有基础。虽然系统内没有对 Java 的具体支持，但 C# 是一种成熟的语言，它提供了与该语言近似的支持。此外，通过 .Net/Mono
    框架，您可以自行支持 Java、F# 或任何受 .Net 平台支持的其它语言，包括您创建的任何新语言，尽管使用 Boo 构建**领域特定语言（DSL）**可能更容易。最重要的是，在
    Unity 中，每种语言都是一等公民。在少数例外的情况下，您在 Unity 中想要做的任何事情都可以完成，无论您选择哪种语言。
- en: The Unity Scripting system is at the heart of getting things done within Unity
    customizing the Unity editor and interacting with the runtime platform. Through
    scripts you have access to everything that you would want to change (and I do
    mean everything) including being able to extend the Unity compiler through the
    **Abstract Syntax Trees (AST)** themselves.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 脚本系统是完成 Unity 内部任务、自定义 Unity 编辑器和与运行时平台交互的核心。通过脚本，您可以访问您想要更改的每一项（我确实是指每一项），包括能够通过**抽象语法树（AST）**本身扩展
    Unity 编译器。
- en: Oh no! You've got Mono!
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哎呀！你遇到了 Mono！
- en: When Microsoft originally created the .Net platform it created it principally
    for the Windows platform. However, Microsoft published the language specification
    to ECMA and shortly thereafter, the Mono open source project was created which
    brought the .Net platform to other platforms including OSX and Linux. At its core
    the Unity scripting system is built upon the .Net runtime and the benefits afforded
    it through the Mono project. While it was certainly possible that the Unity scripting
    system could have been based upon Java or some other system, .Net provided (out-of-the-box)
    a rich system for assemblies that made cross language functionality trivial to
    implement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软最初创建 .Net 平台时，它主要是为了 Windows 平台。然而，微软发布了语言规范给 ECMA，不久之后，Mono 开源项目被创建，将 .Net
    平台带到了其他平台，包括 OSX 和 Linux。在核心上，Unity 脚本系统是基于 .Net 运行时构建的，并通过 Mono 项目获得了其提供的优势。虽然
    Unity 脚本系统完全有可能基于 Java 或其他系统，但 .Net 提供了（开箱即用的）一个丰富的系统，使得跨语言功能实现变得非常简单。
- en: Common Language Infrastructure
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见语言基础设施
- en: Multiple scripting languages are possible in Unity due to the **Common Language
    Infrastructure (Cli)** of .Net. The purpose of the Common Language Infrastructure
    (CLI), is to provide a language-neutral platform for application development and
    execution, including functions for exception handling, garbage collection, security,
    and interoperability. By implementing the core aspects of the .NET Framework within
    the scope of the CLI, this functionality will not be tied to a single language,
    but will be available across the many languages supported by the framework. Microsoft's
    implementation of the CLI is called the **Common Language Runtime**, or **CLR**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .Net 的 **通用语言基础设施 (CLI)**，Unity 中可以实现多种脚本语言。通用语言基础设施 (CLI) 的目的是提供一个语言中立的平台，用于应用程序开发和执行，包括异常处理、垃圾回收、安全和互操作性等功能。通过在
    CLI 范围内实现 .NET 框架的核心方面，这些功能将不会绑定到单一的语言，而是将在框架支持的许多语言中可用。微软对 CLI 的实现被称为 **通用语言运行时
    (CLR**) 或 **CLR**。
- en: Boo- more than a ghost in mario
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Boo- 比马里奥中的幽灵还要多
- en: Boo is an object-oriented, statically typed programming language that seeks
    to make use of the Common Language Infrastructure's support for Unicode, internationalization
    and web-applications, while using a Python-inspired syntax and a special focus
    on language and compiler extensibility. Some features of note include type inference,
    generators, multimethods, optional duck typing, macros, true closures, currying,
    and first-class functions. Boo has been actively developed since 2003.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Boo 是一种面向对象的、静态类型的编程语言，旨在利用通用语言基础设施对 Unicode、国际化和网络应用程序的支持，同时使用受 Python 启发的语法和特别关注语言和编译器可扩展性。一些值得注意的功能包括类型推断、生成器、多方法、可选的鸭子类型、宏、真正的闭包、柯里化和一等函数。Boo
    自 2003 年以来一直在积极开发。
- en: Boo is free software released under an MIT/BSD style license. It is compatible
    with both the Microsoft .NET and Mono frameworks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Boo 是一种免费软件，采用 MIT/BSD 风格的许可证发布。它与 Microsoft .NET 和 Mono 框架都兼容。
- en: What does a Boo script look like?
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Boo 脚本看起来是什么样子？
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Should I choose Boo?
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该选择 Boo 吗？
- en: If you're looking for a new and novel way to write code that doesn't have a
    lot of ceremony and doesn't waste your time with lots of curly braces, Boo is
    definitely a language you want to look into. While the idea of using whitespace
    as a delimiter is considered offensive by some, there is an elegance that comes
    from writing code in Boo. If you've written in traditional languages it's not
    difficult to understand and there are some functions of Unity (not the iOS version)
    which can only be accessed using Boo.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一种新的、新颖的编写代码的方式，这种方式不需要太多的仪式感，也不浪费你很多时间在大量的花括号上，Boo 确实是一种你想要深入了解的语言。虽然有些人认为使用空白作为分隔符的想法令人反感，但在
    Boo 中编写代码却有一种优雅。如果你使用过传统语言，那么理解它并不困难，而且 Unity（非 iOS 版本）中的一些功能只能使用 Boo 来访问。
- en: While Boo is a fine language, there are two reasons why you shouldn't choose
    it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Boo 是一种优秀的语言，但有两个原因你不应该选择它。
- en: First, there are very few examples written in Boo and very little written about
    it in the community at large.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，用 Boo 编写的示例非常少，在社区中关于它的讨论也很少。
- en: More importantly, Boo is not currently supported on the iOS platform as of this
    writing.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，截至本文写作时，Boo 目前不支持 iOS 平台。
- en: With that, our discussion of Boo within the context of iOS comes to an abrupt
    end.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在 iOS 语境下对 Boo 的讨论突然结束。
- en: UnityScript/JavaScript — Relevant beyond the web
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UnityScript/JavaScript — 不仅仅局限于网页
- en: JavaScript is an implementation of the ECMAScript language standard and is typically
    used to enable programmatic access to computational objects within a host environment.
    It can be characterized as a prototype-based object-oriented scripting language
    that is dynamic, weakly typed, and has first-class functions. It is also considered
    a functional programming language like Scheme and OCaml because it has closures
    and supports higher-order functions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是ECMAScript语言标准的实现，通常用于在宿主环境中启用对计算对象的程序性访问。它可以被描述为一种基于原型的面向对象脚本语言，它是动态的、弱类型的，并且具有一等函数。它也被视为一种函数式编程语言，如Scheme和OCaml，因为它具有闭包并支持高阶函数。
- en: While UnityScript is, on the surface, syntactically similar to Javascript, the
    implementation used by Unity is not entirely ECMAScript compliant.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UnityScript在表面上与JavaScript的语法相似，但Unity使用的实现并不完全符合ECMAScript规范。
- en: What does a JavaScript script look like?
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个JavaScript脚本看起来是什么样子？
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Should I choose JavaScript?
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该选择JavaScript吗？
- en: JavaScript is the defacto language in use by the Unity community and is prevalent
    across the web. Many people refer to Javascript as Unityscript. There are many
    people in the world who use it on a daily basis and if you're coming from a Flash
    background this is as close to ActionScript porting ease as you're likely to get
    (until someone ports ActionScript over to Unity). One of the strong benefits of
    JavaScript is that there isn't a lot of ceremony involved with getting things
    done and in most cases you will find that you write a lot less boilerplate to
    build an application with JavaScript. There is no need to create class structures
    and there isn't much need in getting directly to the attributes of objects and
    using them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是Unity社区中使用的默认语言，并在整个互联网上广泛使用。许多人将JavaScript称为Unityscript。世界上有很多人每天都在使用它，如果你来自Flash背景，这将是你可能获得的ActionScript移植便捷性的最接近（直到有人将ActionScript移植到Unity）。JavaScript的一个强大优势是，完成事情时没有太多的仪式感，在大多数情况下，你会发现你用JavaScript构建应用程序时编写的样板代码要少得多。不需要创建类结构，也没有太多直接访问对象属性并使用它们的需要。
- en: JavaScript is available on all platforms including the iPhone, but as you begin
    building more complex examples with larger teams you may find that having more
    structure and typing will result in fewer defects. In addition, while JavaScript
    is the community choice today most authors and developers are moving over to C#
    as their primary development language.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript可在所有平台上使用，包括iPhone，但随着你开始使用更大团队构建更复杂的示例，你可能会发现更多的结构和类型将导致缺陷更少。此外，尽管JavaScript是目前社区的选择，但大多数作者和开发者正在转向C#作为他们的主要开发语言。
- en: C# The revenge of Microsoft
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 微软的复仇
- en: C# (pronounced "see sharp")[6] is a multi-paradigm programming language encompassing
    imperative, declarative, functional, generic, object-oriented (class-based), and
    component-oriented programming disciplines. It was developed by Microsoft within
    the .NET initiative and later approved as a standard by Ecma (ECMA-334) and ISO
    (ISO/IEC 23270). C# is one of the programming languages designed for the Common
    Language Infrastructure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: C#（发音为“see sharp”)[6]是一种多范式编程语言，包括命令式、声明式、函数式、泛型、面向对象（基于类）和组件式编程学科。它是在.NET倡议下由微软开发的，后来被Ecma（ECMA-334）和ISO（ISO/IEC
    23270）批准为标准。C#是专为通用语言基础设施设计的编程语言之一。
- en: C# is intended to be a simple, modern, general-purpose, object-oriented programming
    language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: C#旨在成为一个简单、现代、通用、面向对象的编程语言。
- en: What does a C# script look like?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个C#脚本看起来是什么样子？
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Should I choose C#?
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我应该选择C#吗？
- en: As a language, C# will be familiar to anyone who has done any modern object-oriented
    programming in the past 10 years. The syntax is very familiar for Java developers
    and reasonably easy for C++ developers to pick up.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种语言，C# 对于在过去10年内进行过任何现代面向对象编程的人来说将会很熟悉。其语法对Java开发者来说非常熟悉，对于C++开发者来说也相对容易上手。
- en: There are a number of libraries that are available on the Internet that can
    be dropped right into your project to do things like XML parsing, connecting to
    social networks, loading pages, etc. In addition there is a critical mass of C#
    developers in the Unity community such that there is an increased emphasis on
    doing projects and documentation on C# going forward.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多库可以直接添加到你的项目中，用于执行诸如XML解析、连接社交网络、加载页面等操作。此外，Unity社区中C#开发者数量众多，因此未来对C#项目和文档的重视程度将进一步提高。
- en: Finally, many of those that have published large numbers of iOS projects have
    stated that C# is an easier path to take for writing applications. If you're coming
    from a professional game development background or want a clean object-oriented
    Java/Pascal syntax this is your best choice.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多已经发布了大量 iOS 项目的开发者表示，C# 是编写应用程序的一个更容易的途径。如果你来自专业的游戏开发背景，或者想要一个干净的面向对象的
    Java/Pascal 语法，这是你的最佳选择。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the rest of the book, we will be using C# as the language for scripts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用 C# 作为脚本的语言。
- en: Time for action — Creating and organizing scripts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 创建和组织脚本
- en: Creating a new C# script in Unity is similar to our approach for creating scripts
    using JavaScript or any of the other scripting languages.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中创建一个新的 C# 脚本与使用 JavaScript 或其他任何脚本语言创建脚本的方法类似。
- en: 'Select **Assets | Create | C Sharp Script**. This will create a new C# script
    in the project:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **资产 | 创建 | C# 脚本**。这将在一个项目中创建一个新的 C# 脚本：
- en: Note
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While the Boo Script does appear as an option, it is not usable for Unity iOS
    projects.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然 Boo 脚本确实作为一个选项出现，但它不能用于 Unity iOS 项目。
- en: '![Time for action — Creating and organizing scripts](img/978-1-84969-040-9_5_1.jpg)'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 创建和组织脚本](img/978-1-84969-040-9_5_1.jpg)'
- en: Once you have created the new script it will appear in the **Project** view
    with the name `NewBehaviorScript` with some stubs for the methods `Start()` and
    `Update():`![Time for action — Creating and organizing scripts](img/978-1-84969-040-9_5_2.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了新的脚本，它将以 `NewBehaviorScript` 的名称出现在 **项目** 视图中，并包含 `Start()` 和 `Update()`
    方法的占位符：![行动时间 — 创建和组织脚本](img/978-1-84969-040-9_5_2.jpg)
- en: Create a folder named `Scripts` and then drag the newly created script into
    the Scripts directory.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Scripts` 的文件夹，然后将新创建的脚本拖放到脚本目录中。
- en: What just happened?
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: A best practice for scripts is to put them in a folder in the project. What
    you call this folder doesn't really matter, as it is more for your own organizational
    purposes than it is for Unity. You may choose to put UI centric scripts in one
    directory and AI scripts in another. However you manage the scripts is up to you,
    but you will create a large number of scripts in the course of creating the average
    game so you want to organize them so that they aren't all sitting at the root
    of your game project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的一个最佳实践是将它们放在项目中的一个文件夹中。你给这个文件夹起什么名字并不重要，因为它更多的是为了你自己的组织目的，而不是为了 Unity。你可以选择将
    UI 相关的脚本放在一个目录中，将 AI 脚本放在另一个目录中。无论你如何管理脚本，这取决于你，但在创建普通游戏的过程中，你会创建大量的脚本，所以你想要组织它们，以便它们不会都坐在游戏项目的根目录下。
- en: Attaching scripts to Game Objects
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将脚本附加到游戏对象
- en: As mentioned earlier, you can add a script to a **GameObject** by simply dragging
    the script onto the game object itself. What is important here, is that the **GameObject**
    is the owner of the script, if that game object is not participating in the scene
    — the methods in the script will never be called. For scripts that are global
    in nature, a common practice is to create an Empty Game Object in the scene and
    attach the global scripts to it. While it is common for people to associate these
    global scripts with the camera, you want to avoid this as many complex games will
    have many cameras — complicating the activation of the scripts as well as determining
    which object in the scene owns them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你可以通过简单地拖动脚本到游戏对象本身来将脚本添加到 **GameObject** 中。这里重要的是，**GameObject** 是脚本的所有者，如果该游戏对象不参与场景，脚本中的方法将永远不会被调用。对于本质上是全局的脚本，一个常见的做法是在场景中创建一个空的游戏对象，并将全局脚本附加到它上。虽然人们通常将这些全局脚本与摄像机关联起来，但你应该避免这样做，因为许多复杂的游戏会有很多摄像机——这会复杂化脚本的激活以及确定场景中哪个对象拥有它们。
- en: Exposing variables in the Unity editor
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器中公开变量
- en: Quite often you will find yourself in the position of having written a script
    providing some values for variables within your script. As you test your game
    you will find that you will want to expose some of these variables to the Unity
    Editor so that you can modify them in the editor without having to edit and recompile
    the scripts themselves.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的情况是，你会发现自己编写了一个脚本，为脚本中的变量提供了一些值。当你测试你的游戏时，你会发现你希望将这些变量中的某些暴露给 Unity 编辑器，这样你就可以在编辑器中修改它们，而无需编辑和重新编译脚本本身。
- en: This is particularly important since many times you will want to provide a default
    value within the script which you can override due to some specific game use case.
    Rather than coming up with some complex mechanism to do this, simply declare the
    variable as a public variable and it will show up in the Unity editor.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Key scripting methods
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scripting inside Unity consists of attaching custom script objects called behaviors
    to game objects. Different functions inside the script objects are called on certain
    events. The most used ones being the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `Awake` | Called when the script object is being loaded but after all Game
    Objects have been initialized |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `Start` | Called only one time when the object this script is attached to
    is initially used in the scene |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `Update` | This function is called before rendering a frame. This is where
    most game behavior code goes, except physics code. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `FixedUpdate` | This function is called once every physics time step. This
    is the place to do physics-based game behavior. Unlike Update, this method is
    not called every time, but at a specific interval.Use this for things that should
    be frame rate independent. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `LateUpdate` | This function is called after Update has been called. This
    is useful if you want to execute some functionality after all of the other objects
    in the scene have been updated. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `"Other Methods`" | Code outside functions is run when the object is loaded.
    This can be used to initialize the state of the script. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: iPhoneSettings
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the iOS SDK promises to give you a single platform to all of the iOS devices,
    there are going to be times that you want to do device specific things. For example,
    you may want to load Retina Display compatible assets if you are on the iPhone4
    or you may want to provide another networking interface other than Game Center
    if you find yourself on a 1G, 2G, or base 3G device. Further, you may want to
    determine where this device is located in the world. All of this is accomplished
    by gaining access to iPhoneSettings.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Screen orientation
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: iPhoneSettings provides an interface for getting the current screen orientation
    from the device and it will allow you to specify the orientation you want your
    content to be displayed in.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If you want to only operate in one mode, you can attach a script to the camera
    and in its `Start()` method define the orientation you want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Later in the chapter we will build an example that illustrates how to move between
    the multiple modes that the device is capable of, as the user changes the device
    orientation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Sleep mode
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, any iOS portable device will follow power management settings and
    darken its screen after a certain amount of time to prevent draining the battery
    if the user isn't using it. The iOS power management system will reset its internal
    timers every time a touch event happens on the device. However, for games this
    may become a problem since you may not require the user to maintain contact with
    the device or through a Bluetooth keyboard during gameplay. Driving games and
    flight simulators come immediately to mind as two genres of games that may be
    impacted by this.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何iOS便携式设备都会遵循电源管理设置，并在一段时间后变暗屏幕，以防止用户未使用时耗尽电池。每当设备上发生触摸事件时，iOS电源管理系统都会重置其内部计时器。然而，对于游戏来说，这可能会成为一个问题，因为您可能不需要用户在游戏过程中保持与设备的接触或通过蓝牙键盘。驾驶游戏和飞行模拟器是可能受到影响的游戏类型。
- en: In these cases it makes sense to put the device in a state where the device
    will not be allowed to go to sleep. This can be accomplished by setting the `screenCanDarken`
    attribute of `iPhoneSettings` to `false`. It is important to review that statement
    again the device will not be allowed to go to sleep EVER. As long as your application
    is running, it will block the device from entering a sleep state. Consequently,
    it is your responsibility to make sure that if you leave the states of your game
    where users aren't touching the device that you flip the `screenCanDarken` attibute
    to `true` so that iOS can darken the screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，将设备置于不允许其进入睡眠状态的状态是有意义的。这可以通过将`iPhoneSettings`的`screenCanDarken`属性设置为`false`来实现。重要的是再次审查该声明，设备将永远不会被允许进入睡眠状态。只要您的应用程序正在运行，它就会阻止设备进入睡眠状态。因此，您有责任确保如果您将游戏状态留置在用户未触摸设备的情况下，您将`screenCanDarken`属性切换回`true`，以便iOS可以变暗屏幕。
- en: Device information
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备信息
- en: Unity provides several useful fields to the developer that gives information
    about the device and its unique identification.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为开发者提供了几个有用的字段，这些字段提供了关于设备和其唯一标识的信息。
- en: '| Field | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| name | This is the name that the user has given to the device. Useful if
    you want to allow users to find one another across the wan or locally |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| name | 这是用户为设备指定的名称。如果您想允许用户在wan或本地找到彼此，这很有用 |'
- en: '| model | Provides a simple text model name |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| model | 提供一个简单的文本型号名称 |'
- en: '| systemName | This is simply the name of the OS running on the device |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| systemName | 这只是设备上运行的操作系统名称 |'
- en: '| generation | This will tell you what generation this device belongs to. The
    values are enumerated in iPhoneGeneration and provide a reliable way to determine
    exactly what type of device the user has |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| generation | 这将告诉您该设备属于哪个世代。值在iPhoneGeneration中枚举，并提供了一种可靠的方式来确定用户具体拥有哪种类型的设备
    |'
- en: '| uniqueIdentifier | This is the globally unique identifier that identifies
    this device specifically |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| uniqueIdentifier | 这是全球唯一的标识符，用于特定地识别此设备 |'
- en: Time for action — Identifying the type of iOS
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 识别iOS类型
- en: Let's suppose that we have designed our application such that it is optimized
    for high definition (HD) on iPhone 4 and the iPad.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经设计好我们的应用程序，使其针对iPhone 4和iPad的高清（HD）进行了优化。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the player runs this version of our application we want to tell them that
    the application would perform better if they used the standard definition (SD)
    version of the game.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家运行我们应用程序的这个版本，我们希望告诉他们，如果他们使用标准定义（SD）版本的游戏，应用程序将表现得更好。
- en: We will do this by detecting the device and either starting the application
    immediately or showing them a notice screen and then starting the application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检测设备，立即启动应用程序或显示通知屏幕，然后启动应用程序来实现这一点。
- en: Let's walk through the steps that would be necessary for this application functionality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现此应用程序功能所需的步骤。
- en: Identify the type of device we are using.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别我们正在使用的设备类型。
- en: Based on conditional logic display a splash screen.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据条件逻辑显示启动屏幕。
- en: Dismiss the splash screen.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭启动屏幕。
- en: Identify our device information
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别我们的设备信息
- en: 'What we need to do is:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是：
- en: Add some device detection to the Start() script that we're attaching to our
    Camera.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们附加到相机的Start()脚本中添加一些设备检测。
- en: What we're looking for are iOS generations that are older than the iPhone4 and
    the iPad. We can check for this by looking at the value of `iPhoneSettings.generation`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要寻找的是比iPhone 4和iPad更旧的iOS世代。我们可以通过查看`iPhoneSettings.generation`的值来检查这一点。
- en: We choose `iPhoneSettings.generation` as opposed to `iPhoneSettings.model` because
    generation will return us an enumerated type and since all of the models are represented
    — this will be less error prone than trying to compare strings.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择`iPhoneSettings.generation`而不是`iPhoneSettings.model`，因为`generation`会返回一个枚举类型，并且由于所有型号都被表示，这将比尝试比较字符串更不容易出错。
- en: '[PRE5]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Conditionally show splash screen
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件显示启动画面
- en: Now that we know whether or not we have an HD "qualified" device, we have the
    ability to conditionally display a screen. In this example we have built out our
    SD display as a level all on its own. This was done so that we could compartmentalize
    this body of work by itself without it cluttering up the rest of the game.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们是否有“合格”的HD设备，我们就有了条件显示屏幕的能力。在这个例子中，我们将SD显示作为一个单独的级别来构建。这样做是为了能够将这部分工作单独隔离开来，而不会使游戏的其他部分变得杂乱。
- en: To load this SD purchase suggestion level we make a call to the `Application.LoadLevel()`
    method and provide it the name of the level that we want to load in this case
    it will be our `"SDAdvisory`" level.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要加载这个SD购买建议级别，我们调用`Application.LoadLevel()`方法，并给它提供我们想要加载的级别的名称，在这种情况下，它将是我们的`"SDAdvisory"`级别。
- en: '[PRE6]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unity will now load this level and display it on the screen. Since we've set
    its background to just be an image for displaying this information we need to
    provide a mechanism for this advisory to be dismissed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Unity现在将加载这个级别并在屏幕上显示它。由于我们将其背景设置为仅用于显示信息的图像，我们需要提供一个机制来关闭这个提示。
- en: Dismiss the splash screen
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭启动画面
- en: In our new scene we want to be able to acknowledge that we've seen the advisory
    that we should be using the SD version of the game, yet proceed to playing the
    game in high definition. If you aren't building universal binaries of your game
    (which you should!), you should check for the appropriateness of the version of
    the content the user is attempting to run.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的新场景中，我们希望能够确认我们已经看到了应该使用游戏SD版本的提示，但仍然继续以高清模式玩游戏。如果你没有为你的游戏构建通用二进制（你应该这样做！），你应该检查用户尝试运行的版本的内容是否合适。
- en: To dismiss this level and load our regular game we need to display a button
    on the screen that the user can click on and we need to listen for activity on
    this button. UnityGUI provides a clean mechanism to do this quickly, albeit not
    with the best performance. Ways to improve this performance will be covered in
    the Performance and Optimization sections later in the book.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭这个级别并加载我们的常规游戏，我们需要在屏幕上显示一个用户可以点击的按钮，并且我们需要监听这个按钮的活动。UnityGUI提供了一个快速完成此操作的干净机制，尽管性能不是最佳。本书后面的性能和优化部分将涵盖提高性能的方法。
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now when the user clicks on the button with the `I Understand` label, the application
    will load the level `MainGame` and our game will continue on without any further
    interruption.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当用户点击带有`I Understand`标签的按钮时，应用程序将加载`MainGame`级别，我们的游戏将继续进行，而不会受到任何进一步的干扰。
- en: What just happened?
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: When Unity started the player on our iOS device, it populated the `iPhoneSettings`
    class with the settings for our device. Since our script was attached to an object
    in the scene, our script had the ability to read these settings from the Unity
    player on the device. Based upon this we used a simple C# conditional if statement
    to determine if we were fine to start or needed to display a standard definition
    splash screen. We then presented a simple `UnityGUI` script that waited for the
    user to press a button which launched the main game.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity在我们的iOS设备上启动玩家时，它将`iPhoneSettings`类填充了我们的设备的设置。由于我们的脚本附加到了场景中的对象，我们的脚本能够从设备上的Unity玩家中读取这些设置。基于此，我们使用了一个简单的C#条件if语句来确定我们是否可以开始或需要显示一个标准定义的启动画面。然后我们提供了一个简单的`UnityGUI`脚本，等待用户按下按钮以启动主游戏。
- en: Location services
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位服务
- en: The location services provide an interface to the cell tower triangulation and
    GPS functions of the device. You can get the status of the services through `iPhoneSettings`,
    and the location data will be available through `iPhoneInput.lastLocation`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 定位服务提供了一个接口，用于访问设备的基站三角测量和GPS功能。你可以通过`iPhoneSettings`获取服务状态，位置数据将通过`iPhoneInput.lastLocation`可用。
- en: To start the service, access the `StartlocationServiceUpdates()` method and
    give it the accuracy that you desire, as well as the update distance, both in
    meters. The update distance is the amount that the device must move before it
    will update the `iPhoneInput.lastLocation`. If you are familiar with using CoreLocation,
    you are familiar with the location services for iOS as Unity provides a wrapper
    around the CoreLocation API and simply exposes the data updates through `iPhoneInput.lastLocation`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务，访问`StartlocationServiceUpdates()`方法，并给它所需的精度，以及更新距离，两者都以米为单位。更新距离是设备必须移动的距离，在它更新`iPhoneInput.lastLocation`之前。如果你熟悉使用CoreLocation，你就熟悉了iOS的位置服务，因为Unity在CoreLocation
    API周围提供了一个包装器，并通过`iPhoneInput.lastLocation`简单地暴露数据更新。
- en: It is important to note, however, that GPS satellite acquisition is not instantaneous
    and Unity will expose the state of CoreLocations's response in the `LocationServiceStatus`
    attribute. This will return one of several LocationServiceStatus states which
    can be polled until you achieve a `LocationServiceStatus`. Running in the field
    at which point you will have actual GPS data in `iPhoneInput.lastLocation`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，GPS卫星获取不是瞬时的，Unity将通过`LocationServiceStatus`属性暴露CoreLocation响应的状态。这将返回几个`LocationServiceStatus`状态之一，你可以轮询这些状态，直到你达到`LocationServiceStatus`。在野外运行时，此时你将在`iPhoneInput.lastLocation`中获得实际的GPS数据。
- en: Time for action — Changing state according to player location
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——根据玩家位置更改状态
- en: Location-based gaming is one area of innovation that has gone largely underutilized
    by the game development community. Let's suppose that we want to start a whole
    line of games that utilize the actual players location information to change some
    of the state in our game. For our purposes we will utilize the players location
    to determine the weather in their area, as well as the time of day so that we
    can have the player's game world match the world outside.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 基于位置的电子游戏是游戏开发社区中一个很大程度上未被充分利用的创新领域。假设我们想要启动一系列利用实际玩家位置信息来改变游戏状态的游戏。为了我们的目的，我们将利用玩家的位置来确定他们所在地区的天气，以及一天中的时间，以便我们的玩家游戏世界可以与外界世界相匹配。
- en: 'Let''s walk through the steps that would be necessary for this application''s
    functionality:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现此应用程序功能所需的步骤：
- en: Start the location services on our device,
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的设备上启动位置服务，
- en: Poll the device location information,
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轮询设备位置信息，
- en: Get the weather for this location,
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取此位置的温度，
- en: Start the location services on our device
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的设备上启动位置服务
- en: 'As this is something that we only need to do when our application first starts,
    we can perform all of our operations in the `Start()` method of our script. All
    we need to do is:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是在我们的应用程序首次启动时需要做的事情，我们可以在脚本的`Start()`方法中执行所有操作。我们只需要做的是：
- en: Call the `iPhoneSettings.StartLocationServiceUpdates()` method and Unity will
    start its interaction with the platform's CoreLocation services.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`iPhoneSettings.StartLocationServiceUpdates()`方法，Unity将开始与平台的核心位置服务进行交互。
- en: '[PRE8]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that the location services have started, we need to wait for them to be
    available. Location services do not activate immediately and if the GPS is being
    utilized, the internal systems will have to acquire satellites to triangulate
    the device's location. If we try to acquire information from the device before
    this has completed, the resulting behavior is not defined.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在位置服务已经启动，我们需要等待它们可用。位置服务不会立即激活，如果正在使用GPS，内部系统将不得不获取卫星以三角测量设备的位置。如果我们尝试在完成之前从设备获取信息，结果的行为是未定义的。
- en: In order to wait for the location services to start we need to enter a loop
    where we will check for the status of the location services and then enter a short
    wait state before checking again. We can do this by specifying an amount of time
    to wait that we configure in the Unity editor.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了等待位置服务启动，我们需要进入一个循环，在该循环中我们将检查位置服务的状态，然后在再次检查之前进入一个短暂的等待状态。我们可以通过在Unity编辑器中配置要等待的时间量来实现这一点。
- en: Expose variable to Unity editor
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将变量暴露给Unity编辑器
- en: To expose a variable to the Unity editor we need to define it in such a way
    that it is public in our script. This will allow Unity to expose this variable
    to the rest of the IDE and we will be able to change the value for this variable
    without having to edit the script again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将变量暴露给Unity编辑器，我们需要以某种方式定义它，使其在我们的脚本中是公共的。这将允许Unity将此变量暴露给IDE的其余部分，我们可以在不再次编辑脚本的情况下更改此变量的值。
- en: In our example we want to expose the maximum amount of time we will wait before
    we assume that we won't get location services working.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们想要暴露我们将在假设无法获得位置服务之前等待的最大时间。
- en: '[PRE9]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will be represented inside of the Unity Editor in the Inspector when you
    examine the Game Object that this script is attached to. In our example, if you
    take a look at the Camera object that we''ve attached this script to you will
    see the variable and whatever value it currently has. If you change this value,
    you will be overriding the default value that the script is providing:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你检查这个脚本附加到的游戏对象时，这个信息将在Unity编辑器的检查器中显示。在我们的例子中，如果你查看我们附加了这个脚本的相机对象，你会看到变量及其当前值。如果你更改这个值，你将覆盖脚本提供的默认值：
- en: '![Expose variable to Unity editor](img/978-1-84969-040-9_5_3.jpg)'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![将变量暴露给Unity编辑器](img/978-1-84969-040-9_5_3.jpg)'
- en: 'Unity provides an overridden method WaitForSeconds, which takes an amount of
    time to wait. In order for us to invoke this method, we must:'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity提供了一个重载的 `WaitForSeconds` 方法，它接受等待的时间量。为了调用这个方法，我们必须：
- en: Perform a yield operation to tell Mono that our code needs to pause while this
    function runs. Normally one would simply add this as a single line of code, however,
    C# requires that the method which performs this yield has a different return type
    other than `void`. Thus, we cannot simply expose this in our `Start()` function.
    However, this is easily remedied by providing a secondary function which can handle
    this.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个yield操作来告诉Mono我们的代码需要在函数运行时暂停。通常人们会简单地将这作为一行代码添加，然而，C#要求执行这个yield的方法必须有一个不同于
    `void` 的返回类型。因此，我们无法简单地在 `Start()` 函数中暴露这个。但是，通过提供一个可以处理这个的辅助函数，这个问题很容易解决。
- en: '[PRE10]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we can invoke this method from inside our `Start()` function, wait for a
    certain amount of time and then check to see if the location services are available.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以从 `Start()` 函数内部调用这个方法，等待一定的时间，然后检查位置服务是否可用。
- en: '[PRE11]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will check the status of the device, wait for 2 seconds and then check
    again. Each time it will reduce the number of retries remaining. When this reaches
    zero we can safely assume that either the user has chosen to not allow location
    services or there is something wrong which is preventing the location services
    from working (like Airplane Mode).
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码将检查设备的状态，等待2秒钟然后再次检查。每次它都会减少剩余的重试次数。当这个次数达到零时，我们可以安全地假设用户选择不允许位置服务，或者有某些问题阻止位置服务正常工作（如飞行模式）。
- en: A second method that could be accomplished is to change the signature of the
    `Start()` method from one that returns `void` to one that returns `IEnumerator`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种可能实现的方法是将 `Start()` 方法的签名从返回 `void` 改为返回 `IEnumerator`。
- en: '[PRE12]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Either mechanism is acceptable depending on what you intend to do and the style
    of development you're accustomed to. Both are included here for completeness.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两种机制都是可接受的，取决于你的意图和习惯的开发风格。这里都包括在内以保持完整性。
- en: Poll the device location information
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮询设备位置信息
- en: Now that we know that the device is giving us location data, we can simply look
    in the `iPhoneInput.lastLocation` variable and extract the longitude and latitude.
    From these we can then integrate with a web service, which can tell us what the
    weather is where the device is located.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道设备正在给我们提供位置数据，我们只需查看 `iPhoneInput.lastLocation` 变量并提取经纬度。然后我们可以与一个网络服务集成，它可以告诉我们设备所在位置的天气情况。
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Get the weather for this location
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取此位置的天气
- en: Now that we know the latitude and longitude for the device, we can get the weather
    at this location so that we can use it in our game. To accomplish this we will
    use Google's Weather API and parse the XML we receive.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了设备的经纬度，我们可以获取该位置的天气信息，以便我们在游戏中使用。为了实现这一点，我们将使用谷歌的天气API并解析我们收到的XML。
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The code first starts by defining variables that will store the results of
    our weather query: city, conditions, tempC, tempF, humidity, and wind.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先定义了将存储我们天气查询结果的变量：城市、条件、温度C、温度F、湿度和风速。
- en: The `forLocation()` method takes latitude and longitude and converts them into
    the format that Google expects (the API doesn't support the decimal version of
    lat/lon — just an integer representation).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`forLocation()` 方法接受经纬度并将它们转换为谷歌期望的格式（API不支持十进制的经纬度版本——只支持整数表示）。'
- en: Next the API requests the XmlDocument from the Google servers by compositing
    the URL that will be passed to Google and telling the C# to load this data. Once
    it has returned we simply select the `current_conditions` for our location and
    we now have the weather for where our player is currently playing the game.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，API通过组合传递给Google的URL并告诉C#加载这些数据，从Google服务器请求XmlDocument。一旦返回，我们只需选择我们位置的`current_conditions`，我们现在就有了玩家当前玩游戏位置的天气情况。
- en: What just happened?
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We activated the location services on our device and polled the device to determine
    where our device was located. We entered a wait loop to give the location services
    a chance to start and provide the user an opportunity to interact with the OS
    and give our application permission to use the gathered data. But, for our inability
    to launch this application remotely we just performed the same job as `FindMyiPhone`.
    Next we interfaced with a web service, which provided us the location that this
    lat/lon represents. With this information we accessed another web service that
    told us what the weather was in this location. By exposing this data to our environment
    script in the game we have created a game that uses real location data to function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设备上激活了位置服务，并轮询设备以确定设备的位置。我们进入等待循环，以便位置服务有机会启动并提供用户与操作系统交互的机会，以便我们的应用程序获得使用收集到的数据的权限。但是，由于我们无法远程启动此应用程序，我们只是执行了与`FindMyiPhone`相同的任务。接下来，我们与一个网络服务接口，该服务提供了这个经纬度所代表的地理位置。有了这些信息，我们访问了另一个网络服务，该服务告诉我们这个位置的天气情况。通过将此数据暴露给游戏中的环境脚本，我们创建了一个使用真实位置数据来运行的游戏。
- en: Screen manipulation
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕操作
- en: One of the great things about modern smart phones is that they enable the device
    to be operated from a horizontal or vertical orientation. Due to this, it has
    become expected behavior that games are able to work in whatever orientation the
    device is in. Fortunately, there are ways to detect the screen orientation and
    have Unity update our content as a result of the change in device orientation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现代智能手机的其中一个优点是它们允许设备以水平或垂直方向操作。由于这个原因，游戏能够根据设备所处的方向工作已经成为一种预期行为。幸运的是，有方法可以检测屏幕方向，并让Unity根据设备方向的改变更新我们的内容。
- en: Time for action — Rotating the screen
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——旋转屏幕
- en: One piece of functionality, that I felt an odd omission from the iOS Unity product,
    was that of "out of the box" rotation so that when a user flips the screen, the
    game flips orientation as well. Fortunately we can rectify that with a simple
    rotation script.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一项功能，我觉得iOS Unity产品中遗漏了，就是“开箱即用”的旋转功能，这样当用户翻转屏幕时，游戏也会翻转方向。幸运的是，我们可以通过一个简单的旋转脚本来纠正这个问题。
- en: 'Let''s walk through the steps that would be necessary for this application
    functionality:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看实现此应用程序功能所需的步骤：
- en: Identifying that the screen orientation has changed.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别屏幕方向已改变。
- en: Updating the player orientation.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新玩家方向。
- en: Let's see how it is done.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看它是如何实现的。
- en: Identifying that the screen orientation has changed
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别屏幕方向已改变
- en: 'The first step in handling an orientation change is:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 处理方向改变的第一步是：
- en: To actually realize that the orientation has changed.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上实现方向改变。
- en: 'There are two ways we can do this:'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们有两种方法可以做到这一点：
- en: We can either check when the game first starts up only, in which case we need
    to put our orientation detection in the `Start()` method as it is only called
    once.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以只在游戏首次启动时检查，在这种情况下，我们需要将我们的方向检测放入`Start()`方法中，因为它只被调用一次。
- en: If we want to check orientation changes as the user is playing the game then
    we need to check the state of the orientation on a frame-by-frame basis. We do
    this by putting our orientation code in the `Update()` method.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想在用户玩游戏时检查方向改变，那么我们需要逐帧检查方向的状态。我们通过将方向代码放入`Update()`方法中来实现这一点。
- en: '| Method | Description |'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Input.deviceOrientationXE` "Input.deviceOrientation method" | Returns the
    physical orientation of the device |'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `Input.deviceOrientationXE` "Input.deviceOrientation方法" | 返回设备的物理方向 |'
- en: We will use the `deviceOrientation` attribute of the `Input` class to determine
    what the orientation of the device is. This information comes directly from the
    OS in real time, so as the orientation changes, we will be notified and can respond
    to the change without having to interrupt gameplay.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `Input` 类的 `deviceOrientation` 属性来确定设备的方向。这些信息直接来自操作系统，实时更新，因此当方向改变时，我们会收到通知，并可以响应变化，而无需中断游戏。
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Updating player orientation
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新播放器方向
- en: Now that we know that the orientation has changed we need to update the Unity
    iOS player so that it displays our content with the proper orientation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道方向已经改变，我们需要更新 Unity iOS 播放器，以便它以正确的方向显示我们的内容。
- en: '| Method | Description |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `iPhoneSettings.screenOrientation` | Sets the logical orientation of the
    screen. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `iPhoneSettings.screenOrientation` | 设置屏幕的逻辑方向。|'
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With `iPhoneSettings.screenOrientation` we can now tell the Unity player to
    change its orientation. You can set the orientation to any one of the `iPhoneScreenOrientations`
    available. It is recommended that you don't do anything that would be uncharacteristic
    to the way the iOS device is expected to operate as Apple may reject your application
    for that behavior.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `iPhoneSettings.screenOrientation` 我们现在可以告诉 Unity 播放器改变其方向。您可以将方向设置为 `iPhoneScreenOrientations`
    中可用的任何一个方向。建议您不要做任何与 iOS 设备预期操作不符的事情，因为苹果可能会因为这种行为拒绝您的应用程序。
- en: What just happened?
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: By adding a script to our camera we get an `Update()` notification on a frame
    by frame basis. We can then look to see what the device orientation is and adjust
    our orientation accordingly. By updating the `iPhoneSettings` attributes we can
    quickly flip our scene to match whatever orientation we find ourselves in.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向我们的相机添加脚本，我们可以在每一帧的基础上获得 `Update()` 通知。然后我们可以查看设备的方向，并相应地调整我们的方向。通过更新 `iPhoneSettings`
    属性，我们可以快速翻转场景以匹配我们发现自己所处的任何方向。
- en: iPhoneUtils
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iPhoneUtils
- en: '`iPhoneUtils` is a set of simple utilities to perform some basic functions
    on the iOS device. There isn''t much in `iPhoneUtils`, but it does provide functionality
    to determine if your application has been tampered with on the device, trigger
    vibration on the phone, and play movies.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`iPhoneUtils` 是一组简单的实用工具，用于在 iOS 设备上执行一些基本功能。`iPhoneUtils` 中没有太多内容，但它确实提供了确定您的应用程序是否在设备上被篡改的功能，触发手机的震动，以及播放电影。'
- en: Playing movies
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放电影
- en: 'There are two mechanisms for playing movies within iPhoneUtils: `PlayMovie`
    and `PlayMovieURL. PlayMovie` will play content that is on the phone in the `StreamingAssets`
    folder. Given that you have limited resources to move content if you want to perform
    over the air (OTA) distribution, `PlayMovie` may not be of use to you. `PlayMovie`
    is best suited to game cut scenes and your initial game intro movie since these
    will generally not be long.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iPhoneUtils 中播放电影有两种机制：`PlayMovie` 和 `PlayMovieURL`。`PlayMovie` 将播放手机上的 `StreamingAssets`
    文件夹中的内容。鉴于您在空中（OTA）分发时可以移动的内容有限，`PlayMovie` 可能对您没有帮助。`PlayMovie` 最适合游戏过场动画和您的初始游戏介绍电影，因为这些通常不会很长。
- en: '`PlayMovieURL` is more practical for long running movies, dynamic content that
    you want to deliver to the user (episodic), or content that is simply too large
    to reasonably be distributed within your application. Remember, these are still
    mobile devices and they have bandwidth constraints. If you make your app large
    enough that it cannot be downloaded over the air, you are placing a limitation
    on your possible audience and hurting your customer''s experience.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayMovieURL` 对于长时间运行的影片、希望向用户提供的动态内容（连续剧）或内容太大而无法合理地分布在您的应用程序中的内容来说更为实用。记住，这些仍然是移动设备，它们有带宽限制。如果您使您的应用程序足够大，以至于无法通过空中下载，那么您正在限制您可能的受众，并损害客户的体验。'
- en: Is my application genuine?
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我的程序是真实的吗？
- en: While not the end all in determining whether or not someone has stolen your
    application, `isApplicationGenuine` provides a mechanism through which you can
    detect if the application has been tampered with. It won't catch every pirate
    out there, but it is a useful function. Don't depend on this function exclusively
    for combating piracy!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `isApplicationGenuine` 并不能完全确定某人是否盗用了您的应用程序，但它提供了一个机制，通过这个机制您可以检测应用程序是否被篡改。它不会抓住所有的海盗，但这是一个有用的功能。不要仅依赖这个功能来对抗盗版！
- en: Time for action — Yarr! There be pirates!
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——啊哈！有海盗！
- en: Reality check people are going to steal your game. For whatever reason they
    do it, you probably want to do something in response. Let's suppose that we want
    to detect whether or not someone has pirated our application and if they have
    stream them an advertisement movie from the web before continuing to a demo version
    of our application.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现实情况是，人们会盗取你的游戏。无论他们出于什么原因这样做，你可能都想做出一些回应。假设我们想检测某人是否盗版了我们的应用程序，如果他们确实这样做了，在他们继续到应用程序的演示版本之前，从网络上向他们流式传输一个广告电影。
- en: 'Let''s walk through the steps that would be necessary for this application
    functionality:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看实现此应用程序功能所需的步骤：
- en: The first step in this process is to create a demo scene.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程的第一个步骤是创建一个演示场景。
- en: In this scene put all of your assets that you want to comprise this scene. In
    my case I'll create a simple scene that displays a simple puppy sitting by some
    rocks. You can control the puppy and move him around the scene.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个场景中放置你想要包含在这个场景中的所有资产。在我的情况下，我会创建一个简单的场景，显示一只小狗坐在一些岩石旁边。你可以控制小狗，并在场景中移动它。
- en: Now let's create a demo version of the scene. For demo purposes I'll use the
    same puppy, but I will just set him up in a sleep animation loop in this scene.
    Whenever a user enters the demo world, all the puppies that they find will be
    asleep.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个场景的演示版本。出于演示目的，我会使用同一只小狗，但我会在这个场景中只设置它进入睡眠动画循环。每当用户进入演示世界时，他们找到的所有小狗都会处于睡眠状态。
- en: Based on conditional logic, display the demo scene.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据条件逻辑，显示演示场景。
- en: '[PRE17]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can determine if our application hasn't been signed by Apple by checking
    the `iPhoneUtils.isApplicationGenuine` property. It is important to note that
    when you're building the application on your local machine it will return `false`.
    It will not return `true` until it has been signed by Apple and is on its way
    to the AppStore. Therefore, you do not want to simply check to see if the application
    is genuine and then refuse to load if it isn't as the reviewer may determine that
    your app doesn't work and then reject it accordingly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`iPhoneUtils.isApplicationGenuine`属性来确定我们的应用程序是否未被苹果签名。需要注意的是，当你在本地机器上构建应用程序时，它将返回`false`。只有在它被苹果签名并即将上传到AppStore时，它才会返回`true`。因此，你不应该简单地检查应用程序是否为正版，如果不是就拒绝加载，因为审阅者可能会认为你的应用程序无法工作，然后相应地拒绝它。
- en: What just happened?
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: When the unity player starts we check to see if this is an authentic version
    of our application. If Unity detects that the application has been tampered with
    it will send the user to an ad and a demo version of the game.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity播放器启动时，我们检查这是否是我们应用程序的合法版本。如果Unity检测到应用程序已被篡改，它将把用户发送到一个广告和一个游戏的演示版本。
- en: But let's stop for a second. Pirates will STILL be able to get around this and
    they will be able to write a specific patch for your application. At this time
    there is no fool-proof mechanism for detecting or preventing piracy of any iOS
    application. As long as an iOS device can be jailbroken, people can get around
    any mechanism you put in place to prevent piracy. I put this example in here so
    that you will have some idea about creative ways to work with the reality of the
    situation, but don't expect that this alone will prevent piracy of your app.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们暂停一下。盗版者仍然可以绕过这个限制，并且他们可以为你的应用程序编写特定的补丁。到目前为止，还没有一种万无一失的机制可以检测或防止任何iOS应用程序的盗版。只要iOS设备可以被越狱，人们就可以绕过你为防止盗版而设置的任何机制。我把这个例子放在这里，是为了让你对如何创造性地应对这种情况的现实有所了解，但不要期望这本身就能防止你的应用程序被盗版。
- en: Accessing the camera
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问相机
- en: At the time of this writing Unity iOS did not have functionality to access the
    camera for taking pictures or streaming video. While there is certainly a gap
    there, this is a functionality which is generally not used in games. However,
    if you do want to gain access to the camera you have two choices; write a native
    code plugin for the camera or license the Prime31 Etcetera plugin ([http://www.prime31.com](http://www.prime31.com)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Unity iOS没有提供访问相机进行拍照或流式传输视频的功能。虽然确实存在这个差距，但这种功能通常在游戏中并不常用。然而，如果你确实想访问相机，你有两个选择；为相机编写原生代码插件或获取Prime31
    Etcetera插件（[http://www.prime31.com](http://www.prime31.com)）的许可。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned about the different Unity scripting languages at
    a high-level and gained some insight into C# as a scripting language, which we
    will continue to use throughout the remainder of the book. In addition, we spent
    some time looking at the iPhone specific scripting interfaces and building a number
    of real-world examples, which utilize the functions available to you in the Unity
    iOS player.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们以高级别了解了不同的Unity脚本语言，并对C#作为脚本语言的一些见解，这些内容我们将贯穿整本书的剩余部分。此外，我们还花了一些时间研究iPhone特定的脚本接口，并构建了一些实际应用的示例，这些示例利用了Unity
    iOS播放器中可用的功能。
- en: With this specific iOS scripting under our belt and our demo project updated,
    we can continue and begin integrating with the iOS input system the keyboard,
    the touchscreen, and the accelerometer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了这种特定的iOS脚本并更新了我们的演示项目之后，我们可以继续前进，并开始与iOS输入系统集成，包括键盘、触摸屏和加速度计。
