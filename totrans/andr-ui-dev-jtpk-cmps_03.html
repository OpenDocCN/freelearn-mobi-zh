<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer019">
			<h1 id="_idParaDest-33"><a id="_idTextAnchor040"/>Chapter 2: Understanding the Declarative Paradigm</h1>
			<p>Jetpack Compose marks a fundamental shift in Android UI development. While the traditional view-based approach is centered around components and classes, the new framework follows a declarative approach.</p>
			<p>In <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, I introduced you to composable functions, the basic building blocks of a Compose-based UI. In this chapter, we will briefly review how Android UIs are implemented with traditional classes and techniques. You will learn about some issues of this approach, and how a declarative framework helps overcome them.</p>
			<p>The main sections of this chapter are as follows:</p>
			<ul>
				<li>Looking at the Android view system</li>
				<li>Moving from components to composable functions</li>
				<li>Examining architectural concepts</li>
			</ul>
			<p>We'll start by looking at my second sample app, <em class="italic">Hello View</em>. It is a re-implementation of the <em class="italic">Hello</em> app from <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>. <em class="italic">Hello View</em> uses views, an XML <strong class="bold">layout file</strong>, and <strong class="bold">view binding</strong>.</p>
			<p>Next, we will cover key aspects of <strong class="bold">components</strong>, which are UI building blocks in the view-based world. You will learn about the similarities and differences of composable functions, and we will find out how composable functions can overcome some of the limitations of component-centric frameworks.</p>
			<p>Finally, we will look at the different layers of the Android framework and how they relate to building UIs. By the end of this chapter, you will have gathered enough background information to explore the key principles of Jetpack Compose, which is the topic of the next chapter.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor041"/>Technical requirements</h1>
			<p>Please refer to the <em class="italic">Technical requirements</em> section in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio and how to get the sample app. All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02</a>.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor042"/>Looking at the Android view system</h1>
			<p>The<a id="_idIndexMarker042"/> traditional approach to building Android UIs is to define component trees and modify them during runtime. While this can be done completely programmatically, the preferred way is to create layout files. They use XML tags and attributes to define which UI elements should be presented on screen. Let's take a look:</p>
			<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p>
			<p class="source-code">&lt;androidx.constraintlayout.widget.ConstraintLayout</p>
			<p class="source-code">  </p>
			<p class="source-code">  </p>
			<p class="source-code">  android:layout_width="match_parent"</p>
			<p class="source-code">  android:layout_height="match_parent"&gt;</p>
			<p class="source-code">  &lt;TextView</p>
			<p class="source-code">    <strong class="bold">android:id</strong>="@+id/message"</p>
			<p class="source-code">    style="@style/TextAppearance.AppCompat.Medium"</p>
			<p class="source-code">    android:layout_width="wrap_content"</p>
			<p class="source-code">    android:layout_height="wrap_content"</p>
			<p class="source-code">    android:textAlignment="center"</p>
			<p class="source-code">    app:layout_constraintBottom_toBottomOf="parent"</p>
			<p class="source-code">    app:layout_constraintBottom_toTopOf="@id/name"</p>
			<p class="source-code">    app:layout_constraintEnd_toEndOf="parent"</p>
			<p class="source-code">    app:layout_constraintHorizontal_bias="0.5"</p>
			<p class="source-code">    app:layout_constraintStart_toStartOf="parent"</p>
			<p class="source-code">    app:layout_constraintTop_toTopOf="parent"</p>
			<p class="source-code">    app:layout_constraintVertical_bias="0.5"</p>
			<p class="source-code">    app:layout_constraintVertical_chainStyle="packed" /&gt;</p>
			<p class="source-code">  ...</p>
			<p class="source-code">&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</p>
			<p>Layout <a id="_idIndexMarker043"/>files define a hierarchical structure (a tree). In the previous XML snippet, the root node (<strong class="source-inline">ConstraintLayout</strong>) contains only one child (<strong class="source-inline">TextView</strong>). The complete XML file of <em class="italic">Hello View</em> has two more children, an <strong class="source-inline">EditText</strong> component and a <strong class="source-inline">Button</strong> component. Layout files of real-world apps can be quite nested, containing dozens of children.</p>
			<p>Generally speaking, <strong class="source-inline">...Layout</strong> elements are responsible for sizing and positioning their children. While they may have a visual representation (for example, background color or a border), they usually don't interact with the user. <strong class="source-inline">ScrollView</strong> is one of the exceptions to that rule. All other (non <strong class="source-inline">...Layout</strong>) elements such as buttons, checkboxes, and editable text fields not only allow for user interaction – it's their purpose.</p>
			<p>Both layout and non-layout elements are called components. We will return to this term in the <em class="italic">Moving from components to composable functions</em> section. But before that, let's see how layout files are used in apps. </p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor043"/>Inflating layout files</h2>
			<p>Activities are one <a id="_idIndexMarker044"/>of the core building blocks of an Android app. They implement a quite sophisticated lifecycle, which is reflected by a couple of methods we can override.</p>
			<p>Typically, <strong class="source-inline">onCreate()</strong> is used to prepare the app and to show the UI by invoking <strong class="source-inline">setContentView()</strong>. This method can receive an ID representing a layout file, for example, <strong class="source-inline">R.layout.main</strong>. Because of this, you must define variables pointing to the UI elements you wish to access. This may look like the following:</p>
			<p class="source-code">private lateinit var doneButton: Button</p>
			<p class="source-code">...</p>
			<p class="source-code">val doneButton = findViewById(R.id.done)</p>
			<p>It turned out that this doesn't scale well for bigger apps. There are two important issues to remember:</p>
			<ul>
				<li>You may face crashes during runtime if the variable is accessed before it has been initialized.</li>
				<li>The code quickly becomes lengthy if you have more than a few components.</li>
			</ul>
			<p>Sometimes, you can prevent the first issue by using local variables, as follows:</p>
			<p class="source-code">val doneButton = findViewById&lt;Button&gt;(R.id.done)</p>
			<p>This way, you <a id="_idIndexMarker045"/>can access the UI element immediately after the declaration. But the variable exists only in the scope in which it has been defined – a block or a function. This may be problematic because you often need to modify a component outside <strong class="source-inline">onCreate()</strong>. That's because in a component-based world, you modify the UI by modifying the properties of a component. It turned out that often the same set of changes are necessary for different parts of the app, so to avoid code duplication, they are refactored into methods, which need to know the component to change it.</p>
			<p>To solve the second issue – that is, to spare the developer from the task of keeping references to components – Google introduced view binding. It belongs to Jetpack and debuted in Android Studio 3.6. Let's see how it is used:</p>
			<p class="source-code">class MainActivity : AppCompatActivity() {</p>
			<p class="source-code">  <strong class="bold">private lateinit var binding: MainBinding</strong></p>
			<p class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">    super.onCreate(savedInstanceState)</p>
			<p class="source-code">    binding = MainBinding.<strong class="bold">inflate</strong>(layoutInflater)</p>
			<p class="source-code">    setContentView(<strong class="bold">binding.root</strong>)</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    enableOrDisableButton()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  ...</p>
			<p class="source-code">}</p>
			<p>No matter how<a id="_idIndexMarker046"/> complex the UI of an activity is, we need to keep only one reference. This variable is usually called <strong class="source-inline">binding</strong>, which is initialized by invoking <strong class="source-inline">inflate()</strong> of a <strong class="source-inline">...Binding</strong> instance. The <strong class="source-inline">MainBinding</strong> class in my example is automatically generated and updated, when <strong class="source-inline">main.xml</strong> is modified. Every layout file gets a corresponding <strong class="source-inline">...Binding</strong> class. To enable this mechanism, the <strong class="source-inline">viewBinding</strong> build option must be set to <strong class="source-inline">true</strong> in the module-level <strong class="source-inline">build.gradle</strong> file:</p>
			<p class="source-code">android {</p>
			<p class="source-code">  ...</p>
			<p class="source-code">  buildFeatures {</p>
			<p class="source-code">    viewBinding true</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>So, after you have inflated a layout file by invoking <strong class="source-inline">...Binding.inflate()</strong> and assigned it to an instance variable, you can access all of its components via their IDs using this variable. IDs are set using the XML attribute <strong class="source-inline">android:id</strong> (for example, <strong class="source-inline">android:id="@+id/message"</strong>).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">There is an important difference between the old-fashioned <strong class="source-inline">findViewById()</strong> and view binding. If you use the latter one, you must pass the root component (<strong class="source-inline">binding.root</strong>) to <strong class="source-inline">setContentView()</strong>, rather than an ID representing the layout file (<strong class="source-inline">R.layout.main</strong>).</p>
			<p>In this section, I have shown you how to obtain references to UI elements. The next section, <em class="italic">Modifying the UI</em>, will explain how to make use of this.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor044"/>Modifying the UI</h2>
			<p>In this section, we will see <a id="_idIndexMarker047"/>how to make changes to a View-based UI. Let's start by looking at the <strong class="source-inline">enableOrDisableButton()</strong> function, which is invoked in <strong class="source-inline">onCreate()</strong>. Its name gives you a clue regarding its purpose – enabling or disabling a button. But why do we need this? <em class="italic">Hello View</em> is a reimplementation of the <em class="italic">Hello</em> app from <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, but it has one additional feature. As long as the user has not entered at least one non-blank character, <strong class="bold">Done</strong> can't be clicked:</p>
			<p class="source-code">private fun enableOrDisableButton() {</p>
			<p class="source-code">  binding.done.isEnabled = binding.name.text.isNotBlank()</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">binding.done</strong> refers to the button during runtime. It can be clicked only if <strong class="source-inline">isEnabled</strong> is <strong class="source-inline">true</strong>. The text input field is denoted by <strong class="source-inline">binding.name</strong>. Its <strong class="source-inline">text</strong> property reflects what the user has already entered. <strong class="source-inline">isNotBlank()</strong> tells us if at least one non-whitespace character is present.</p>
			<p>In the code I have shown you so far, <strong class="source-inline">enableOrDisableButton()</strong> is called only at the end of <strong class="source-inline">onCreate()</strong>. But we also need to invoke the function whenever the user has input something. Let's see how to do this (please note that the following code snippets belong inside <strong class="source-inline">onCreate()</strong> so that they are executed when the activity is created):</p>
			<p class="source-code">binding.name.run {</p>
			<p class="source-code">  <strong class="bold">setOnEditorActionListener</strong> { _, _, _ -&gt;</p>
			<p class="source-code">    binding.done.<strong class="bold">performClick()</strong></p>
			<p class="source-code">    true</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">doAfterTextChanged</strong> {</p>
			<p class="source-code">    enableOrDisableButton()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  <strong class="bold">visibility = VISIBLE</strong></p>
			<p class="source-code">}</p>
			<p>Text input<a id="_idIndexMarker048"/> fields can modify certain aspects of the onscreen keyboard. For example, to have it show a <strong class="bold">Done</strong> key instead of the usual <strong class="bold">Enter</strong>, we add an <strong class="source-inline">android:imeOptions="actionDone"</strong> attribute to the layout file. To react to clicks on this key, we need to register code by invoking <strong class="source-inline">setOnEditorActionListener()</strong>. Then, <strong class="source-inline">binding.done.performClick()</strong> simulates clicks on the <strong class="bold">Done</strong> button. You will see shortly why I do this.</p>
			<p>The lambda function we pass to <strong class="source-inline">doAfterTextChanged()</strong> is invoked every time the user enters or deletes something in the text input field. When this happens, <strong class="source-inline">enableOrDisableButton()</strong> is called, which makes the button clickable if the text currently present in the input field is not blank.</p>
			<p>Finally, <strong class="source-inline">visibility = VISIBLE</strong> occurs inside <strong class="source-inline">binding.name.run {</strong>, so it makes the text input field visible. This is the desired state when the activity is created.</p>
			<p>Now, let's turn to code related to the <strong class="bold">Done</strong> button:</p>
			<p class="source-code">binding.done.run {</p>
			<p class="source-code">  setOnClickListener {</p>
			<p class="source-code">    val name = binding.name.text</p>
			<p class="source-code">    if (name.isNotBlank()) {</p>
			<p class="source-code">      binding.message.text = getString(R.string.hello,</p>
			<p class="source-code">                                       name)</p>
			<p class="source-code">      binding.name.visibility = GONE</p>
			<p class="source-code">      it.visibility = GONE</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  visibility = VISIBLE</p>
			<p class="source-code">}</p>
			<p>When <strong class="bold">Done</strong> is clicked, we test whether the text input field contains at least one character besides whitespace. If this is the case, the greeting message will be constructed and displayed. Also, both the button and the text input field are hidden; they need to disappear after the user has entered a name, because then only the greeting message should be visible. Making a component visible or invisible is done by modifying the <strong class="source-inline">visibility</strong> property: <strong class="source-inline">visibility = VISIBLE</strong> makes the <strong class="bold">Done</strong> button visible. This is the desired state when the activity is created.</p>
			<p>Do you <a id="_idIndexMarker049"/>remember that I promised to explain why I invoke <strong class="source-inline">performClick()</strong> inside the lambda function for <strong class="source-inline">setOnEditorActionListener</strong>? This way, I can reuse the code inside the button listener without refactoring it into a separate function and calling it instead, which certainly is a viable alternative.</p>
			<p>Before we move on, let's recap what have we seen so far:</p>
			<ul>
				<li>The UI is defined in an XML file.</li>
				<li>At runtime, it is inflated to a component tree.</li>
				<li>To change the UI, attributes of all related components must be modified.</li>
				<li>Even if a UI element is not visible, it remains part of the component tree.</li>
			</ul>
			<p>This is why common UI frameworks are <a id="_idIndexMarker050"/>called <strong class="bold">imperative</strong>. Any change to the UI is done by deliberately modifying the attributes of all components involved. As you can see in my example, this works quite well for small apps. But the more UI elements an app has, the more demanding it will be to keep track of such changes. Let me explain. Changes in domain data (adding an item to a list, deleting text, or loading an image from a remote service) require changes in the UI. The developer needs to know which portion of domain data relates to which UI element and must then modify the component tree accordingly. The bigger an app becomes, the more difficult this is.</p>
			<p>Also, without clear architectural guidance, the code for changing the component tree almost always eventually mixes with code that modifies data the app is using. This makes it even more demanding and error-prone to maintain and further develop the app. In the next section, we will turn to composable functions. You will learn how they differ from components and why this helps overcome weaknesses in the imperative approach.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor045"/>Moving from components to composable functions</h1>
			<p>So far, I explained the word <em class="italic">component</em> by saying that it refers to UI elements. In fact, the term is used in quite a few other areas. Generally speaking, components structure systems by separating distinct portions or parts of them. The inner workings of a component are typically hidden from the outside (known <a id="_idIndexMarker051"/>as the <strong class="bold">black box principle</strong>).</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To learn more about the <a id="_idIndexMarker052"/>black box principle, please refer to <a href="https://en.wikipedia.org/wiki/Black_box">https://en.wikipedia.org/wiki/Black_box</a>.</p>
			<p>Components <a id="_idIndexMarker053"/>communicate with other parts of the system by sending and receiving messages. The appearance or behavior of a component is controlled through a set of attributes, or <strong class="bold">properties</strong>.</p>
			<p>Consider <strong class="source-inline">TextView</strong>. We set text<a id="_idIndexMarker054"/> by modifying the <strong class="source-inline">text</strong> property and we control its visibility through <strong class="source-inline">visibility</strong>. What about sending and receiving messages? Let's look at <strong class="source-inline">Button</strong>. We can react to clicks (receive a message) by registering (sending a message) an <strong class="source-inline">OnClickListener</strong> instance. The same principle applies to <strong class="source-inline">EditText</strong>. We configure its appearance through setting properties (<strong class="source-inline">text</strong>), send a message by invoking <strong class="source-inline">setOnEditorActionListener()</strong>, and receive one through the lambda expression we passed as a parameter.</p>
			<p>Message-based communication and configuration via properties make components very tool-friendly. In fact, most component-based UI frameworks work well with drawing board-like editors. The developer defines a UI using drag and drop. Components<a id="_idIndexMarker055"/> are configured using property sheets. <em class="italic">Figure 2.1</em> shows the Layout Editor in Android Studio. You can switch between a <strong class="bold">Design</strong> view, browse <strong class="bold">Code</strong> (an XML file), or a combination of both (<strong class="bold">Split</strong>):</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="Images/B17505_02_01.jpg" alt="Figure 2.1 – The Layout Editor in Android Studio&#13;&#10;" width="1000" height="553"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The Layout Editor in Android Studio</p>
			<p>We now have a more precise understanding of how the <em class="italic">component</em> term is used in the context of UIs. Building on this foundation, we will now look at component hierarchies.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor046"/>Component hierarchies</h2>
			<p>If you compare the XML<a id="_idIndexMarker056"/> attributes of <strong class="source-inline">ConstraintLayout</strong>, <strong class="source-inline">TextView</strong>, and <strong class="source-inline">EditText</strong>, you will find unique attributes per tag, one example being <strong class="source-inline">android:inputType</strong>. On the other hand, <strong class="source-inline">android:layout_width</strong> and <strong class="source-inline">android:layout_height</strong> are present in all three tags, defining the size of the corresponding element. Size and position are relevant for all components.</p>
			<p>Yet, specific attributes influence visual appearance or behavior; this is <em class="italic">not</em> relevant for all kinds of UI elements, only a subset. Here's an example: text fields and buttons will want to show or receive text. A <strong class="source-inline">FrameLayout</strong> UI element won't. Think of it this way: the <em class="italic">more specialized</em> an attribute is, the <em class="italic">less likely is its reuse</em> in another component. However, general ones (such as <strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>, <strong class="source-inline">location</strong>, or <strong class="source-inline">color</strong>) will be needed in most UI elements.</p>
			<p>Based on its attributes, each component has a level of specialization. For example, <strong class="source-inline">EditText</strong> is more specific than <strong class="source-inline">TextView</strong> because it can handle text input. <strong class="source-inline">Button</strong> is a general-purpose button; clicking on it triggers some action. On the other hand, a <strong class="source-inline">CheckBox</strong> component can be either checked or unchecked. This type of button can represent two states. A <strong class="source-inline">Switch</strong> component has two states, too. It's a toggle switch widget that can select between two options.</p>
			<p>The degree of<a id="_idIndexMarker057"/> specialization can be modeled easily in object-oriented programming languages through inheritance. A more specialized UI element (class) extends a general element. Therefore, many often-used UI frameworks have been implemented in Java, C++, or C# (object-oriented languages). It is important to note, though, that component-like concepts can be achieved with other types of programming languages too. So, object orientation may be considered a benefit, but it's not a necessity.</p>
			<p>At this point, you may be thinking, <em class="italic">Didn't he mix two different things? How are tags and attributes of Android layout files related to classes?</em> Allow me to explain. Earlier, I said that an XML file is <strong class="bold">inflated</strong> to a component tree. To be more precise – it becomes an <em class="italic">object</em> tree. The tags in the XML file represent class names and its attributes correspond to members of that class. <strong class="source-inline">inflate()</strong> creates a tree of objects based on this information.</p>
			<p>So, Android layout files describe component trees outside of Java or Kotlin files using a different syntax (an XML syntax). But they are not declarative in the same way Jetpack Compose is because layout files define a UI regardless of the current state. For example, they do not take into account that a button should be disabled because a text field is empty. A Compose UI, on the other hand, is declared <em class="italic">based</em> on that.</p>
			<p>The remaining part of this section will look closer at some of Android's UI components and how they are related. Before that, let's recap what we have learned so far:</p>
			<ul>
				<li>All Android views are classes.</li>
				<li>Tags in layout files represent classes and attributes are their members.</li>
				<li><strong class="source-inline">inflate()</strong> creates an object tree.</li>
				<li>Changes to the UI are achieved by modifying this tree.</li>
			</ul>
			<p>Some of Android's UI elements are quite specific. <strong class="source-inline">RatingBar</strong>, for example, allows the user to rate something by selecting a certain number of stars. Others are way more general; for example, <strong class="source-inline">ImageView</strong> just displays image resources, and <strong class="source-inline">FrameLayout</strong> blocks out an area on the screen to display a stack of children. </p>
			<p>To understand how Android's UI elements are related, let's look at the ones used in <em class="italic">Hello View</em> in a little more detail. We'll start with <strong class="source-inline">ConstraintLayout</strong>:</p>
			<p class="source-code"><strong class="bold">java.lang.Object</strong></p>
			<p class="source-code">  ↳  <strong class="bold">android.view.View</strong></p>
			<p class="source-code">     ↳  android.view.<strong class="bold">ViewGroup</strong></p>
			<p class="source-code">        ↳  androidx.constraintlayout.widget.<strong class="bold">ConstraintLayout</strong></p>
			<p>The root of <em class="italic">all</em> classes<a id="_idIndexMarker058"/> in Java is <strong class="source-inline">java.lang.Object</strong>. Significant parts of the Android framework are based on Java and its class library. So, all views directly or indirectly extend <strong class="source-inline">java.lang.Object</strong>. The immediate parent of <strong class="source-inline">ConstraintLayout</strong> is <strong class="source-inline">android.view.ViewGroup</strong>, which in turn is a sibling of <strong class="source-inline">android.view.View</strong>.</p>
			<p>Now, let's look at <strong class="source-inline">android.widget.Button</strong>.</p>
			<p class="source-code">java.lang.Object</p>
			<p class="source-code">  ↳  <strong class="bold">android.view.View</strong></p>
			<p class="source-code">     ↳  <strong class="bold">android.widget.TextView</strong></p>
			<p class="source-code">        ↳  <strong class="bold">android.widget.Button</strong></p>
			<p>Its direct ancestor is <strong class="source-inline">android.widget.TextView</strong>, which extends <strong class="source-inline">android.view.View</strong>. Are we seeing a pattern here? <strong class="source-inline">android.view.View</strong> seems to be the root of all Android UI elements. Let's check our hypothesis by examining another component:</p>
			<p class="source-code">java.lang.Object</p>
			<p class="source-code">  ↳  android.view.View</p>
			<p class="source-code">     ↳  <strong class="bold">android.widget.TextView</strong></p>
			<p class="source-code">        ↳  <strong class="bold">android.widget.EditText</strong></p>
			<p>As you can see, components showing or receiving text usually extend <strong class="source-inline">android.widget.TextView</strong>, whose parent is <strong class="source-inline">android.view.View</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="source-inline">android.view.View</strong> is the root of all Android UI elements. All components that position and size their children extend <strong class="source-inline">android.view.ViewGroup</strong>.</p>
			<p>So far, structuring UI elements in a hierarchy based on specialization seems to work well. Unfortunately, this approach does have limitations. We'll turn to them in the following section.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor047"/>Limitations of component hierarchies</h2>
			<p>Buttons usually show <a id="_idIndexMarker059"/>text. Therefore, it seems natural to extend a more general text component. As we have seen in the previous section, Android does just that. What if your app requires a button that has no text and shows an image instead? In such scenarios, you can use <strong class="source-inline">ImageButton</strong>:</p>
			<p class="source-code">java.lang.Object</p>
			<p class="source-code">  ↳  android.view.View</p>
			<p class="source-code">     ↳  android.widget.ImageView</p>
			<p class="source-code">        ↳  android.widget.ImageButton</p>
			<p>T<a id="_idTextAnchor048"/>he class extends <strong class="source-inline">android.widget.ImageView</strong>. This makes sense, as the purpose of this component is to show just an image, quite like <strong class="source-inline">Button</strong> and text. But what if we want to show a button that contains both text and image? The closest common ancestor of <strong class="source-inline">ImageButton</strong> and an ordinary text button is <strong class="source-inline">android.view.View</strong>, the root of the Android UI element hierarchy. Therefore, everything <strong class="source-inline">Button</strong> inherits from <strong class="source-inline">TextView</strong> is not immediately available to <strong class="source-inline">ImageButton</strong> (and vice versa).</p>
			<p>The reason is that Java is based upon <strong class="bold">single inheritance</strong>: a class extends exactly one other class. If <strong class="source-inline">Button</strong> wanted to take advantage of the features of <strong class="source-inline">TextView</strong> and <strong class="source-inline">ImageView</strong>, it would need to extend both, which it can't. Does this mean that things would be different if Java supported <strong class="bold">multiple inheritance</strong>? We could combine the behavior of several components, but we still wouldn't be able to reuse functionality tied to <em class="italic">individual</em> attributes, methods, or sets of them. Let's see why this is important.</p>
			<p>The <strong class="source-inline">View</strong> class knows<a id="_idIndexMarker060"/> about padding (providing space to the inside of its bounds) but not about margins (space to the outside of its bounds). Margins are defined in <strong class="source-inline">ViewGroup</strong>. Hence, if a component wants to use them, it must extend <strong class="source-inline">ViewGroup</strong>. But in doing so, it inevitably inherits all other features of this class (for example, the ability to layout children), regardless of needing them or not. The underlying issue is that in a component-centric framework, the combination of <em class="italic">individual features</em> of one or more components to create a more specialized UI element is not possible because you cannot cut out these features. The reason for this is that reuse happens at a component level.</p>
			<p>To make individual features reusable, we need to put aside the notion of components. That's what, for example, Flutter (the very successful cross-platform alternative to Jetpack Compose) does. Its UI framework is fully declarative, still class-based. Flutter relies on a simple principle<a id="_idIndexMarker061"/> called <strong class="bold">composition over inheritance</strong>. It means the look and the behavior of a UI element (and the complete UI) are defined by combining simple building blocks, such as <strong class="source-inline">Container</strong>, <strong class="source-inline">Padding</strong>, <strong class="source-inline">Align</strong>, or <strong class="source-inline">GestureDetector</strong>, rather than modifying a parent.</p>
			<p>In Jetpack Compose, we combine simple building blocks too. Instead of classes, we use composable functions. Before we turn to them, I would like to briefly show you another potential issue of components.</p>
			<p>As you have seen, in class-based UI component frameworks, specialization is modeled through inheritance. The specialized version of a class (which may have new features, a new look, or behave slightly different than the ancestor) extends a more general version of the class. However, most object-oriented programming languages provide means to prohibit this; for example, if a Java class is marked final or a Kotlin class is not open, they cannot be extended.</p>
			<p>So, the framework developer can make a deliberate decision to prevent further inheritance. <strong class="source-inline">android.widget.Space</strong>, a lightweight <strong class="source-inline">View</strong> subclass to create gaps between UI elements, is final. The same applies to <strong class="source-inline">android.view.ViewStub</strong>. It's an invisible, zero-sized <strong class="source-inline">View</strong> used to lazily inflate layout resources at runtime. Fortunately, most of Android's UI elements can be extended. And for both examples, it seems unlikely that we would want to extend them. Hence, you may not face this potential issue<a id="_idIndexMarker062"/> at all. The point is that in a framework based upon composition rather than inheritance, it doesn't matter.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>Composing UIs with functions</h2>
			<p>Now it's time to return to<a id="_idIndexMarker063"/> composable functions. In this section, we <a id="_idIndexMarker064"/>will look at my sample app <em class="italic">Factorial</em> (<em class="italic">Figure 2.2</em>). When the user picks a number between 0 and 9, its factorial (the product of it and all the integers below it greater than 0) is computed and output, like so:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="Images/B17505_02_02.jpg" alt="Figure 2.2 – The Factorial app&#13;&#10;" width="1309" height="768"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Factorial app</p>
			<p>Here is the simple function that creates the output text:</p>
			<p class="source-code">fun factorialAsString(n: Int): String {</p>
			<p class="source-code">  var result = 1L</p>
			<p class="source-code">  for (i in 1..n) {</p>
			<p class="source-code">    result *= i</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return "$n! = $result"</p>
			<p class="source-code">}</p>
			<p>The factorial of an <strong class="source-inline">n</strong> non-negative integer value is the product of all positive integers less than or equal to <strong class="source-inline">n</strong>. So, the result can be computed easily by multiplying all integers between <strong class="source-inline">1</strong> and <strong class="source-inline">n</strong>. Please note that the maximum value of a Kotlin <strong class="source-inline">Long</strong> type is 9,223,372,036,854,775,807. Hence, my implementation does not work if <strong class="source-inline">result</strong> would need to be bigger than that.</p>
			<p>Next, I'll show you<a id="_idIndexMarker065"/> how the UI is<a id="_idIndexMarker066"/> composed:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Factorial() {</p>
			<p class="source-code">  var expanded by remember { mutableStateOf(false) }</p>
			<p class="source-code">  var text by remember {</p>
			<p class="source-code">    mutableStateOf(factorialAsString(0)) }</p>
			<p class="source-code">  <strong class="bold">Box</strong>(</p>
			<p class="source-code">    modifier = Modifier.fillMaxSize(),</p>
			<p class="source-code">    contentAlignment = Alignment.Center</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    <strong class="bold">Text</strong>(</p>
			<p class="source-code">      modifier = Modifier.clickable {</p>
			<p class="source-code">        expanded = true</p>
			<p class="source-code">      },</p>
			<p class="source-code">      text = text,</p>
			<p class="source-code">      style = MaterialTheme.typography.h2</p>
			<p class="source-code">    )</p>
			<p class="source-code">    <strong class="bold">DropdownMenu</strong>(</p>
			<p class="source-code">      expanded = expanded,</p>
			<p class="source-code">      onDismissRequest = {</p>
			<p class="source-code">        expanded = false</p>
			<p class="source-code">      }) {</p>
			<p class="source-code">      for (n in 0 until 10) {</p>
			<p class="source-code">        <strong class="bold">DropdownMenuItem</strong>(onClick = {</p>
			<p class="source-code">          expanded = false</p>
			<p class="source-code">          text = factorialAsString(n)</p>
			<p class="source-code">        }) {</p>
			<p class="source-code">          Text("${n.toString()}!")</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Factorial()</strong> composable function contains one predefined composable, <strong class="source-inline">Box()</strong>, which in turn has two children, <strong class="source-inline">Text()</strong> and <strong class="source-inline">DropdownMenu()</strong>. I briefly introduced you to <strong class="source-inline">Text()</strong> and <strong class="source-inline">Box()</strong> in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>. So let's concentrate on <strong class="source-inline">DropdownMenu()</strong>.</p>
			<p>A <a id="_idIndexMarker067"/>drop-down menu (the equivalent to a <strong class="source-inline">Spinner</strong>) displays <a id="_idIndexMarker068"/>a list of entries in a compact way. It appears upon interaction with an element, such as the following:</p>
			<ul>
				<li>An icon or a button</li>
				<li>When the user performs a specific action</li>
			</ul>
			<p>In my example, the <strong class="source-inline">Text()</strong> composable must be clicked.</p>
			<p>The content of a menu can either be provided by a <strong class="source-inline">for</strong> loop statement or by adding it one by one. Often, but not necessarily, <strong class="source-inline">DropdownMenuItem()</strong> is used. If the menu is expanded (that is, open or visible), it is controlled by the <strong class="source-inline">expanded</strong> parameter. <strong class="source-inline">onDismissRequest</strong> is used to react to closing the menu without selecting something. <strong class="source-inline">DropdownMenuItem()</strong> receives a click handler via the <strong class="source-inline">onClick</strong> parameter. That code is executed when the item is clicked.</p>
			<p>So far, I<a id="_idIndexMarker069"/> have presented quite a lot of information about <a id="_idIndexMarker070"/>composable functions to you. Before we move on, let's recap what we know so far:</p>
			<ul>
				<li>The entry point of a Compose UI is a composable function.</li>
				<li>From there, other composable functions are called.</li>
				<li>Often, composable functions receive <em class="italic">content</em> that is other composables.</li>
				<li>The order of invocation controls where a UI element will be in relation to other UI elements.</li>
			</ul>
			<p>Let's continue with how <strong class="source-inline">Factorial()</strong> works. It defines two variables, <strong class="source-inline">expanded</strong> and <strong class="source-inline">text</strong>. But how are they used? While an Android layout file defines a component tree in its initial state, a composable UI is always declared using actual data. This means that there is no need to set up or prepare the UI before it can be displayed for the first time. Whenever it is displayed, it looks the way you want. Let's see how this works.</p>
			<p>Most composable functions are configured by a set of parameters. Some of them are mandatory; others can be omitted. The important thing is that the composable is always called with actual values. On the other hand, components (that is, views) are initialized when they are created. And they remain this way until they are deliberately changed by altering the value of properties. That's why an app needs to keep references to all components (UI elements) it wishes to modify. But how is a Compose UI updated?</p>
			<p>The process of updating a Compose UI is<a id="_idIndexMarker071"/> called <strong class="bold">recomposition</strong>. It takes place automatically whenever a composable function being part of the UI needs to be updated. This is the case when some of the values that influence its look or behavior (parameters) change. If you always pass the same text to <strong class="source-inline">Text()</strong>, there is no need to recompose it. If, on the other hand, you pass something Jetpack Compose knows it can change, the Compose runtime will initiate an update, a recomposition, when that change happens. Values that change over <a id="_idIndexMarker072"/>time are called <strong class="bold">state</strong>. You can create state, for example, using <strong class="source-inline">mutableStateOf()</strong>. To refer to state in a composable, you need to <strong class="source-inline">remember</strong> it in that composable function.</p>
			<p>Both <strong class="source-inline">expanded</strong> and <strong class="source-inline">text</strong> contain state. When these variables are used as parameters for composable functions, those composables will be recomposed whenever the value of these variables changes. Setting <strong class="source-inline">expanded</strong> to <strong class="source-inline">true</strong> brings the drop-down menu on screen immediately. This is done inside a lambda function passed to <strong class="source-inline">clickable {}</strong>. I will be discussing this in the next section. Giving <strong class="source-inline">text</strong> a new value changes the display of <strong class="source-inline">Text()</strong> because we pass the variable <strong class="source-inline">text</strong> as the value of the equally named parameter. This happens, for example, inside the code block passed to <strong class="source-inline">onClick</strong>.</p>
			<p>Getting rid<a id="_idIndexMarker073"/> of a component tree (that needs to be <a id="_idIndexMarker074"/>updated deliberately) in favor of declaring a UI based on state and thus getting updates upon state changes for free is possibly one of the most exciting advantages of the declarative approach. In the next section, I will explain a few more architectural principles of component-based and declarative UI frameworks.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/>Examining architectural aspects</h1>
			<p>In the <em class="italic">Component hierarchies</em> section, I showed you that component-based UI frameworks rely on specialization. General features and concepts are implemented in the root component or one of its immediate successors. Such general features include the following:</p>
			<ul>
				<li>Location and size on screen</li>
				<li>Basic visual aspects like background (color)</li>
				<li>Simple user interactions (reacting to clicks)</li>
			</ul>
			<p>Any component will <a id="_idIndexMarker075"/>provide these features, either in a specialized way or in its basic implementation. Android's view system is class-based, so changing functionality is done by overriding the methods of the parent.</p>
			<p>Composable functions, on the other hand, do not have a shared set of properties. By annotating a function with <strong class="source-inline">@Composable</strong>, we make certain parts of Jetpack Compose aware of it. But besides not specifying a return type, composables seem to have few things in common. However, this would have been a pretty short-sighted architectural decision. In fact, Jetpack Compose makes providing a simple, predictable API really easy. The remaining part of this section illustrates this by showing you how to react to clicks, and how to size and position UI elements.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor051"/>Reacting to clicks</h2>
			<p>Android's <strong class="source-inline">View</strong> class contains a<a id="_idIndexMarker076"/> method called <strong class="source-inline">setOnClickListener()</strong>. It receives a <strong class="source-inline">View.OnClickListener</strong> instance. This interface contains one method, <strong class="source-inline">onClick(View v)</strong>. The implementation of this method provides the code that should be executed when the view is clicked. Additionally, there is a view property called <strong class="source-inline">clickable</strong>. It is accessed through <strong class="source-inline">setClickable()</strong> and <strong class="source-inline">isClickable()</strong>. If <strong class="source-inline">clickable</strong> is set to <strong class="source-inline">false</strong> after the listener has been set, the click event will not be delivered (<strong class="source-inline">onClick()</strong> is not called).</p>
			<p>Jetpack Compose can provide click handling in two ways. Firstly, composable functions that require it (because it is a core feature for them) have a dedicated <strong class="source-inline">onClick</strong> parameter. Secondly, composables that usually do not require click handling can be amended with a modifier. Let's start with the first one.</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun ButtonDemo() {</p>
			<p class="source-code">  Box {</p>
			<p class="source-code">    Button(onClick = {</p>
			<p class="source-code">      println("clicked")</p>
			<p class="source-code">    }) {</p>
			<p class="source-code">      Text("Click me!")</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Please note that <strong class="source-inline">onClick</strong> is mandatory; you must provide it.</p>
			<p>If you want to show the button but the user should not be able to click it, the code looks like this:</p>
			<p class="source-code">Button(</p>
			<p class="source-code">  onClick = {</p>
			<p class="source-code">    println("clicked")</p>
			<p class="source-code">  },</p>
			<p class="source-code">  enabled = false</p>
			<p class="source-code">) {</p>
			<p class="source-code">  Text("Click me!")</p>
			<p class="source-code">}</p>
			<p><em class="italic">Figure 2.3</em> shows what the<a id="_idIndexMarker077"/> button looks like when <strong class="source-inline">enabled</strong> is either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="Images/B17505_02_03.jpg" alt="Figure 2.3 – A button with enabled = true or false&#13;&#10;" width="486" height="121"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – A button with enabled = true or false</p>
			<p><strong class="source-inline">Text()</strong> doesn't have an <strong class="source-inline">onClick</strong> property. If you want to make it clickable (like I do in the <em class="italic">Factorial</em> app), you pass <strong class="source-inline">clickable { ... }</strong> to the <strong class="source-inline">modifier</strong> parameter:</p>
			<p class="source-code">modifier = Modifier.clickable { ...</p>
			<p>Modifiers, as their name suggests, provide an infrastructure for influencing both the visual appearance and behavior of composable functions. I will show you another example for modifiers in the next section. <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, covers them in much greater detail.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor052"/>Sizing and positioning UI elements</h2>
			<p>In component-centric<a id="_idIndexMarker078"/> UI frameworks, size and location onscreen (or relative to <a id="_idIndexMarker079"/>another component) are core properties. They are defined in the root component (on Android, the <strong class="source-inline">View</strong> class). Descendants of <strong class="source-inline">ViewGroup</strong> size and position their children by changing their corresponding properties. For example, <strong class="source-inline">RelativeLayout</strong> is based upon instructions such as <strong class="source-inline">toStartOf</strong>, <strong class="source-inline">toEndOf</strong>, or <strong class="source-inline">below</strong>. <strong class="source-inline">FrameLayout</strong> draws its children in a stack. And <strong class="source-inline">LinearLayout</strong> lays out children horizontally or vertically. So, <strong class="source-inline">...Layout</strong>s are containers with the ability to size and position their children.</p>
			<p>Jetpack Compose has a very similar concept. You have already learned about <strong class="source-inline">Row()</strong> and <strong class="source-inline">Column()</strong>, which lay out their content horizontally or vertically. <strong class="source-inline">Box()</strong> is similar to <strong class="source-inline">FrameLayout</strong>. It organizes its content in the order it appears in code. The position inside the box is controlled by <strong class="source-inline">contentAlignment</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun BoxDemo() {</p>
			<p class="source-code">  Box(contentAlignment = Alignment.Center) {</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .size(width = 100.dp, height = 100.dp)</p>
			<p class="source-code">        .background(Color.Green)</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Box(</p>
			<p class="source-code">      modifier = Modifier</p>
			<p class="source-code">        .size(width = 80.dp, height = 80.dp)</p>
			<p class="source-code">        .background(Color.Yellow)</p>
			<p class="source-code">    )</p>
			<p class="source-code">    Text(</p>
			<p class="source-code">      text = "Hello",</p>
			<p class="source-code">      color = Color.Black,</p>
			<p class="source-code">      modifier = Modifier.align(Alignment.TopStart)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The content may <a id="_idIndexMarker080"/>override this by using <strong class="source-inline">modifier = Modifier.align()</strong>, the <a id="_idIndexMarker081"/>result of which we can see in <em class="italic">Figure 2.4</em>:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="Images/B17505_02_04.jpg" alt="Figure 2.4 – An invisible box containing two colored boxes and text&#13;&#10;" width="232" height="252"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – An invisible box containing two colored boxes and text</p>
			<p>Modifiers can also be used to request a size. In some of my examples, you may have spotted <strong class="source-inline">Modifier.fillMaxSize()</strong>, which makes the composable as big as possible. <strong class="source-inline">Modifier.size()</strong> requests a particular size. Modifiers can be chained. The root of such a chain is the <strong class="source-inline">Modifier</strong> companion object. Subsequent modifiers are added using a dot.</p>
			<p>Before closing this chapter, I would like to emphasize the benefits of the modifier concept with one more example. Did you notice the <strong class="source-inline">background()</strong> modifiers of the first and second content box? This modifier allows you to set a background color for any composable function. When you need something a composable function does not offer out of the box, you can add it with a modifier. As you can write custom modifiers, the possibilities to adjust a composable to your needs are almost endless. I will elaborate on this in the next chapter.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor053"/>Summary</h1>
			<p>In this chapter, you have learned about key elements of component-centric UI frameworks. We saw some of the limitations of this approach and how the declarative paradigm can overcome them. For example, specialization takes place on a component level. If the framework is based upon inheritance, the distribution of features to children may be too broad. Jetpack Compose tackles this with the modifier mechanism, which allows us to amend functionality at a very fine-grained level; this means that composables only get the functionality they need (for example, a background color).</p>
			<p>The remaining chapters of this book are solely based on the declarative approach. In <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, we will take an even closer look at composable functions and examine the concepts of composition and recomposition. And, as promised, we will also dive deep into modifiers.</p>
		</div>
	</div></body></html>