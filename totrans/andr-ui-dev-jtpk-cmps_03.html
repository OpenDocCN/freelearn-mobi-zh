<html><head></head><body><div><div><h1 id="_idParaDest-33"><a id="_idTextAnchor040"/>Chapter 2: Understanding the Declarative Paradigm</h1>
			<p>Jetpack Compose marks a fundamental shift in Android UI development. While the traditional view-based approach is centered around components and classes, the new framework follows a declarative approach.</p>
			<p>In <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, I introduced you to composable functions, the basic building blocks of a Compose-based UI. In this chapter, we will briefly review how Android UIs are implemented with traditional classes and techniques. You will learn about some issues of this approach, and how a declarative framework helps overcome them.</p>
			<p>The main sections of this chapter are as follows:</p>
			<ul>
				<li>Looking at the Android view system</li>
				<li>Moving from components to composable functions</li>
				<li>Examining architectural concepts</li>
			</ul>
			<p>We'll start by looking at my second sample app, <em class="italic">Hello View</em>. It is a re-implementation of the <em class="italic">Hello</em> app from <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>. <em class="italic">Hello View</em> uses views, an XML <strong class="bold">layout file</strong>, and <strong class="bold">view binding</strong>.</p>
			<p>Next, we will cover key aspects of <strong class="bold">components</strong>, which are UI building blocks in the view-based world. You will learn about the similarities and differences of composable functions, and we will find out how composable functions can overcome some of the limitations of component-centric frameworks.</p>
			<p>Finally, we will look at the different layers of the Android framework and how they relate to building UIs. By the end of this chapter, you will have gathered enough background information to explore the key principles of Jetpack Compose, which is the topic of the next chapter.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor041"/>Technical requirements</h1>
			<p>Please refer to the <em class="italic">Technical requirements</em> section in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio and how to get the sample app. All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02</a>.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor042"/>Looking at the Android view system</h1>
			<p>The<a id="_idIndexMarker042"/> traditional approach to building Android UIs is to define component trees and modify them during runtime. While this can be done completely programmatically, the preferred way is to create layout files. They use XML tags and attributes to define which UI elements should be presented on screen. Let's take a look:</p>
			<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout
  
  
  android:layout_width="match_parent"
  android:layout_height="match_parent"&gt;
  &lt;TextView
    <strong class="bold">android:id</strong>="@+id/message"
    style="@style/TextAppearance.AppCompat.Medium"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:textAlignment="center"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintBottom_toTopOf="@id/name"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintHorizontal_bias="0.5"
    app:layout_constraintStart_toStartOf="parent"
    app:layout_constraintTop_toTopOf="parent"
    app:layout_constraintVertical_bias="0.5"
    app:layout_constraintVertical_chainStyle="packed" /&gt;
  ...
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;</pre>
			<p>Layout <a id="_idIndexMarker043"/>files define a hierarchical structure (a tree). In the previous XML snippet, the root node (<code>ConstraintLayout</code>) contains only one child (<code>TextView</code>). The complete XML file of <em class="italic">Hello View</em> has two more children, an <code>EditText</code> component and a <code>Button</code> component. Layout files of real-world apps can be quite nested, containing dozens of children.</p>
			<p>Generally speaking, <code>...Layout</code> elements are responsible for sizing and positioning their children. While they may have a visual representation (for example, background color or a border), they usually don't interact with the user. <code>ScrollView</code> is one of the exceptions to that rule. All other (non <code>...Layout</code>) elements such as buttons, checkboxes, and editable text fields not only allow for user interaction – it's their purpose.</p>
			<p>Both layout and non-layout elements are called components. We will return to this term in the <em class="italic">Moving from components to composable functions</em> section. But before that, let's see how layout files are used in apps. </p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor043"/>Inflating layout files</h2>
			<p>Activities are one <a id="_idIndexMarker044"/>of the core building blocks of an Android app. They implement a quite sophisticated lifecycle, which is reflected by a couple of methods we can override.</p>
			<p>Typically, <code>onCreate()</code> is used to prepare the app and to show the UI by invoking <code>setContentView()</code>. This method can receive an ID representing a layout file, for example, <code>R.layout.main</code>. Because of this, you must define variables pointing to the UI elements you wish to access. This may look like the following:</p>
			<pre>private lateinit var doneButton: Button
...
val doneButton = findViewById(R.id.done)</pre>
			<p>It turned out that this doesn't scale well for bigger apps. There are two important issues to remember:</p>
			<ul>
				<li>You may face crashes during runtime if the variable is accessed before it has been initialized.</li>
				<li>The code quickly becomes lengthy if you have more than a few components.</li>
			</ul>
			<p>Sometimes, you can prevent the first issue by using local variables, as follows:</p>
			<pre>val doneButton = findViewById&lt;Button&gt;(R.id.done)</pre>
			<p>This way, you <a id="_idIndexMarker045"/>can access the UI element immediately after the declaration. But the variable exists only in the scope in which it has been defined – a block or a function. This may be problematic because you often need to modify a component outside <code>onCreate()</code>. That's because in a component-based world, you modify the UI by modifying the properties of a component. It turned out that often the same set of changes are necessary for different parts of the app, so to avoid code duplication, they are refactored into methods, which need to know the component to change it.</p>
			<p>To solve the second issue – that is, to spare the developer from the task of keeping references to components – Google introduced view binding. It belongs to Jetpack and debuted in Android Studio 3.6. Let's see how it is used:</p>
			<pre>class MainActivity : AppCompatActivity() {
  <strong class="bold">private lateinit var binding: MainBinding</strong>
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    binding = MainBinding.<strong class="bold">inflate</strong>(layoutInflater)
    setContentView(<strong class="bold">binding.root</strong>)
    ...
    enableOrDisableButton()
  }
  ...
}</pre>
			<p>No matter how<a id="_idIndexMarker046"/> complex the UI of an activity is, we need to keep only one reference. This variable is usually called <code>binding</code>, which is initialized by invoking <code>inflate()</code> of a <code>...Binding</code> instance. The <code>MainBinding</code> class in my example is automatically generated and updated, when <code>main.xml</code> is modified. Every layout file gets a corresponding <code>...Binding</code> class. To enable this mechanism, the <code>viewBinding</code> build option must be set to <code>true</code> in the module-level <code>build.gradle</code> file:</p>
			<pre>android {
  ...
  buildFeatures {
    viewBinding true
  }
}</pre>
			<p>So, after you have inflated a layout file by invoking <code>...Binding.inflate()</code> and assigned it to an instance variable, you can access all of its components via their IDs using this variable. IDs are set using the XML attribute <code>android:id</code> (for example, <code>android:id="@+id/message"</code>).</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">There is an important difference between the old-fashioned <code>findViewById()</code> and view binding. If you use the latter one, you must pass the root component (<code>binding.root</code>) to <code>setContentView()</code>, rather than an ID representing the layout file (<code>R.layout.main</code>).</p>
			<p>In this section, I have shown you how to obtain references to UI elements. The next section, <em class="italic">Modifying the UI</em>, will explain how to make use of this.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor044"/>Modifying the UI</h2>
			<p>In this section, we will see <a id="_idIndexMarker047"/>how to make changes to a View-based UI. Let's start by looking at the <code>enableOrDisableButton()</code> function, which is invoked in <code>onCreate()</code>. Its name gives you a clue regarding its purpose – enabling or disabling a button. But why do we need this? <em class="italic">Hello View</em> is a reimplementation of the <em class="italic">Hello</em> app from <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, but it has one additional feature. As long as the user has not entered at least one non-blank character, <strong class="bold">Done</strong> can't be clicked:</p>
			<pre>private fun enableOrDisableButton() {
  binding.done.isEnabled = binding.name.text.isNotBlank()
}</pre>
			<p><code>binding.done</code> refers to the button during runtime. It can be clicked only if <code>isEnabled</code> is <code>true</code>. The text input field is denoted by <code>binding.name</code>. Its <code>text</code> property reflects what the user has already entered. <code>isNotBlank()</code> tells us if at least one non-whitespace character is present.</p>
			<p>In the code I have shown you so far, <code>enableOrDisableButton()</code> is called only at the end of <code>onCreate()</code>. But we also need to invoke the function whenever the user has input something. Let's see how to do this (please note that the following code snippets belong inside <code>onCreate()</code> so that they are executed when the activity is created):</p>
			<pre>binding.name.run {
  <strong class="bold">setOnEditorActionListener</strong> { _, _, _ -&gt;
    binding.done.<strong class="bold">performClick()</strong>
    true
  }
  <strong class="bold">doAfterTextChanged</strong> {
    enableOrDisableButton()
  }
  <strong class="bold">visibility = VISIBLE</strong>
}</pre>
			<p>Text input<a id="_idIndexMarker048"/> fields can modify certain aspects of the onscreen keyboard. For example, to have it show a <code>android:imeOptions="actionDone"</code> attribute to the layout file. To react to clicks on this key, we need to register code by invoking <code>setOnEditorActionListener()</code>. Then, <code>binding.done.performClick()</code> simulates clicks on the <strong class="bold">Done</strong> button. You will see shortly why I do this.</p>
			<p>The lambda function we pass to <code>doAfterTextChanged()</code> is invoked every time the user enters or deletes something in the text input field. When this happens, <code>enableOrDisableButton()</code> is called, which makes the button clickable if the text currently present in the input field is not blank.</p>
			<p>Finally, <code>visibility = VISIBLE</code> occurs inside <code>binding.name.run {</code>, so it makes the text input field visible. This is the desired state when the activity is created.</p>
			<p>Now, let's turn to code related to the <strong class="bold">Done</strong> button:</p>
			<pre>binding.done.run {
  setOnClickListener {
    val name = binding.name.text
    if (name.isNotBlank()) {
      binding.message.text = getString(R.string.hello,
                                       name)
      binding.name.visibility = GONE
      it.visibility = GONE
    }
  }
  visibility = VISIBLE
}</pre>
			<p>When <code>visibility</code> property: <code>visibility = VISIBLE</code> makes the <strong class="bold">Done</strong> button visible. This is the desired state when the activity is created.</p>
			<p>Do you <a id="_idIndexMarker049"/>remember that I promised to explain why I invoke <code>performClick()</code> inside the lambda function for <code>setOnEditorActionListener</code>? This way, I can reuse the code inside the button listener without refactoring it into a separate function and calling it instead, which certainly is a viable alternative.</p>
			<p>Before we move on, let's recap what have we seen so far:</p>
			<ul>
				<li>The UI is defined in an XML file.</li>
				<li>At runtime, it is inflated to a component tree.</li>
				<li>To change the UI, attributes of all related components must be modified.</li>
				<li>Even if a UI element is not visible, it remains part of the component tree.</li>
			</ul>
			<p>This is why common UI frameworks are <a id="_idIndexMarker050"/>called <strong class="bold">imperative</strong>. Any change to the UI is done by deliberately modifying the attributes of all components involved. As you can see in my example, this works quite well for small apps. But the more UI elements an app has, the more demanding it will be to keep track of such changes. Let me explain. Changes in domain data (adding an item to a list, deleting text, or loading an image from a remote service) require changes in the UI. The developer needs to know which portion of domain data relates to which UI element and must then modify the component tree accordingly. The bigger an app becomes, the more difficult this is.</p>
			<p>Also, without clear architectural guidance, the code for changing the component tree almost always eventually mixes with code that modifies data the app is using. This makes it even more demanding and error-prone to maintain and further develop the app. In the next section, we will turn to composable functions. You will learn how they differ from components and why this helps overcome weaknesses in the imperative approach.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor045"/>Moving from components to composable functions</h1>
			<p>So far, I explained the word <em class="italic">component</em> by saying that it refers to UI elements. In fact, the term is used in quite a few other areas. Generally speaking, components structure systems by separating distinct portions or parts of them. The inner workings of a component are typically hidden from the outside (known <a id="_idIndexMarker051"/>as the <strong class="bold">black box principle</strong>).</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To learn more about the <a id="_idIndexMarker052"/>black box principle, please refer to <a href="https://en.wikipedia.org/wiki/Black_box">https://en.wikipedia.org/wiki/Black_box</a>.</p>
			<p>Components <a id="_idIndexMarker053"/>communicate with other parts of the system by sending and receiving messages. The appearance or behavior of a component is controlled through a set of attributes, or <strong class="bold">properties</strong>.</p>
			<p>Consider <code>TextView</code>. We set text<a id="_idIndexMarker054"/> by modifying the <code>text</code> property and we control its visibility through <code>visibility</code>. What about sending and receiving messages? Let's look at <code>Button</code>. We can react to clicks (receive a message) by registering (sending a message) an <code>OnClickListener</code> instance. The same principle applies to <code>EditText</code>. We configure its appearance through setting properties (<code>text</code>), send a message by invoking <code>setOnEditorActionListener()</code>, and receive one through the lambda expression we passed as a parameter.</p>
			<p>Message-based communication and configuration via properties make components very tool-friendly. In fact, most component-based UI frameworks work well with drawing board-like editors. The developer defines a UI using drag and drop. Components<a id="_idIndexMarker055"/> are configured using property sheets. <em class="italic">Figure 2.1</em> shows the Layout Editor in Android Studio. You can switch between a <strong class="bold">Design</strong> view, browse <strong class="bold">Code</strong> (an XML file), or a combination of both (<strong class="bold">Split</strong>):</p>
			<div><div><img src="img/B17505_02_01.jpg" alt="Figure 2.1 – The Layout Editor in Android Studio&#13;&#10;" width="1000" height="553"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – The Layout Editor in Android Studio</p>
			<p>We now have a more precise understanding of how the <em class="italic">component</em> term is used in the context of UIs. Building on this foundation, we will now look at component hierarchies.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor046"/>Component hierarchies</h2>
			<p>If you compare the XML<a id="_idIndexMarker056"/> attributes of <code>ConstraintLayout</code>, <code>TextView</code>, and <code>EditText</code>, you will find unique attributes per tag, one example being <code>android:inputType</code>. On the other hand, <code>android:layout_width</code> and <code>android:layout_height</code> are present in all three tags, defining the size of the corresponding element. Size and position are relevant for all components.</p>
			<p>Yet, specific attributes influence visual appearance or behavior; this is <em class="italic">not</em> relevant for all kinds of UI elements, only a subset. Here's an example: text fields and buttons will want to show or receive text. A <code>FrameLayout</code> UI element won't. Think of it this way: the <em class="italic">more specialized</em> an attribute is, the <em class="italic">less likely is its reuse</em> in another component. However, general ones (such as <code>width</code>, <code>height</code>, <code>location</code>, or <code>color</code>) will be needed in most UI elements.</p>
			<p>Based on its attributes, each component has a level of specialization. For example, <code>EditText</code> is more specific than <code>TextView</code> because it can handle text input. <code>Button</code> is a general-purpose button; clicking on it triggers some action. On the other hand, a <code>CheckBox</code> component can be either checked or unchecked. This type of button can represent two states. A <code>Switch</code> component has two states, too. It's a toggle switch widget that can select between two options.</p>
			<p>The degree of<a id="_idIndexMarker057"/> specialization can be modeled easily in object-oriented programming languages through inheritance. A more specialized UI element (class) extends a general element. Therefore, many often-used UI frameworks have been implemented in Java, C++, or C# (object-oriented languages). It is important to note, though, that component-like concepts can be achieved with other types of programming languages too. So, object orientation may be considered a benefit, but it's not a necessity.</p>
			<p>At this point, you may be thinking, <em class="italic">Didn't he mix two different things? How are tags and attributes of Android layout files related to classes?</em> Allow me to explain. Earlier, I said that an XML file is <code>inflate()</code> creates a tree of objects based on this information.</p>
			<p>So, Android layout files describe component trees outside of Java or Kotlin files using a different syntax (an XML syntax). But they are not declarative in the same way Jetpack Compose is because layout files define a UI regardless of the current state. For example, they do not take into account that a button should be disabled because a text field is empty. A Compose UI, on the other hand, is declared <em class="italic">based</em> on that.</p>
			<p>The remaining part of this section will look closer at some of Android's UI components and how they are related. Before that, let's recap what we have learned so far:</p>
			<ul>
				<li>All Android views are classes.</li>
				<li>Tags in layout files represent classes and attributes are their members.</li>
				<li><code>inflate()</code> creates an object tree.</li>
				<li>Changes to the UI are achieved by modifying this tree.</li>
			</ul>
			<p>Some of Android's UI elements are quite specific. <code>RatingBar</code>, for example, allows the user to rate something by selecting a certain number of stars. Others are way more general; for example, <code>ImageView</code> just displays image resources, and <code>FrameLayout</code> blocks out an area on the screen to display a stack of children. </p>
			<p>To understand how Android's UI elements are related, let's look at the ones used in <em class="italic">Hello View</em> in a little more detail. We'll start with <code>ConstraintLayout</code>:</p>
			<pre><strong class="bold">java.lang.Object</strong>
  ↳  <strong class="bold">android.view.View</strong>
     ↳  android.view.<strong class="bold">ViewGroup</strong>
        ↳  androidx.constraintlayout.widget.<strong class="bold">ConstraintLayout</strong></pre>
			<p>The root of <em class="italic">all</em> classes<a id="_idIndexMarker058"/> in Java is <code>java.lang.Object</code>. Significant parts of the Android framework are based on Java and its class library. So, all views directly or indirectly extend <code>java.lang.Object</code>. The immediate parent of <code>ConstraintLayout</code> is <code>android.view.ViewGroup</code>, which in turn is a sibling of <code>android.view.View</code>.</p>
			<p>Now, let's look at <code>android.widget.Button</code>.</p>
			<pre>java.lang.Object
  ↳  <strong class="bold">android.view.View</strong>
     ↳  <strong class="bold">android.widget.TextView</strong>
        ↳  <strong class="bold">android.widget.Button</strong></pre>
			<p>Its direct ancestor is <code>android.widget.TextView</code>, which extends <code>android.view.View</code>. Are we seeing a pattern here? <code>android.view.View</code> seems to be the root of all Android UI elements. Let's check our hypothesis by examining another component:</p>
			<pre>java.lang.Object
  ↳  android.view.View
     ↳  <strong class="bold">android.widget.TextView</strong>
        ↳  <strong class="bold">android.widget.EditText</strong></pre>
			<p>As you can see, components showing or receiving text usually extend <code>android.widget.TextView</code>, whose parent is <code>android.view.View</code>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><code>android.view.View</code> is the root of all Android UI elements. All components that position and size their children extend <code>android.view.ViewGroup</code>.</p>
			<p>So far, structuring UI elements in a hierarchy based on specialization seems to work well. Unfortunately, this approach does have limitations. We'll turn to them in the following section.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor047"/>Limitations of component hierarchies</h2>
			<p>Buttons usually show <a id="_idIndexMarker059"/>text. Therefore, it seems natural to extend a more general text component. As we have seen in the previous section, Android does just that. What if your app requires a button that has no text and shows an image instead? In such scenarios, you can use <code>ImageButton</code>:</p>
			<pre>java.lang.Object
  ↳  android.view.View
     ↳  android.widget.ImageView
        ↳  android.widget.ImageButton</pre>
			<p>T<a id="_idTextAnchor048"/>he class extends <code>android.widget.ImageView</code>. This makes sense, as the purpose of this component is to show just an image, quite like <code>Button</code> and text. But what if we want to show a button that contains both text and image? The closest common ancestor of <code>ImageButton</code> and an ordinary text button is <code>android.view.View</code>, the root of the Android UI element hierarchy. Therefore, everything <code>Button</code> inherits from <code>TextView</code> is not immediately available to <code>ImageButton</code> (and vice versa).</p>
			<p>The reason is that Java is based upon <code>Button</code> wanted to take advantage of the features of <code>TextView</code> and <code>ImageView</code>, it would need to extend both, which it can't. Does this mean that things would be different if Java supported <strong class="bold">multiple inheritance</strong>? We could combine the behavior of several components, but we still wouldn't be able to reuse functionality tied to <em class="italic">individual</em> attributes, methods, or sets of them. Let's see why this is important.</p>
			<p>The <code>View</code> class knows<a id="_idIndexMarker060"/> about padding (providing space to the inside of its bounds) but not about margins (space to the outside of its bounds). Margins are defined in <code>ViewGroup</code>. Hence, if a component wants to use them, it must extend <code>ViewGroup</code>. But in doing so, it inevitably inherits all other features of this class (for example, the ability to layout children), regardless of needing them or not. The underlying issue is that in a component-centric framework, the combination of <em class="italic">individual features</em> of one or more components to create a more specialized UI element is not possible because you cannot cut out these features. The reason for this is that reuse happens at a component level.</p>
			<p>To make individual features reusable, we need to put aside the notion of components. That's what, for example, Flutter (the very successful cross-platform alternative to Jetpack Compose) does. Its UI framework is fully declarative, still class-based. Flutter relies on a simple principle<a id="_idIndexMarker061"/> called <code>Container</code>, <code>Padding</code>, <code>Align</code>, or <code>GestureDetector</code>, rather than modifying a parent.</p>
			<p>In Jetpack Compose, we combine simple building blocks too. Instead of classes, we use composable functions. Before we turn to them, I would like to briefly show you another potential issue of components.</p>
			<p>As you have seen, in class-based UI component frameworks, specialization is modeled through inheritance. The specialized version of a class (which may have new features, a new look, or behave slightly different than the ancestor) extends a more general version of the class. However, most object-oriented programming languages provide means to prohibit this; for example, if a Java class is marked final or a Kotlin class is not open, they cannot be extended.</p>
			<p>So, the framework developer can make a deliberate decision to prevent further inheritance. <code>android.widget.Space</code>, a lightweight <code>View</code> subclass to create gaps between UI elements, is final. The same applies to <code>android.view.ViewStub</code>. It's an invisible, zero-sized <code>View</code> used to lazily inflate layout resources at runtime. Fortunately, most of Android's UI elements can be extended. And for both examples, it seems unlikely that we would want to extend them. Hence, you may not face this potential issue<a id="_idIndexMarker062"/> at all. The point is that in a framework based upon composition rather than inheritance, it doesn't matter.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>Composing UIs with functions</h2>
			<p>Now it's time to return to<a id="_idIndexMarker063"/> composable functions. In this section, we <a id="_idIndexMarker064"/>will look at my sample app <em class="italic">Factorial</em> (<em class="italic">Figure 2.2</em>). When the user picks a number between 0 and 9, its factorial (the product of it and all the integers below it greater than 0) is computed and output, like so:</p>
			<div><div><img src="img/B17505_02_02.jpg" alt="Figure 2.2 – The Factorial app&#13;&#10;" width="1309" height="768"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Factorial app</p>
			<p>Here is the simple function that creates the output text:</p>
			<pre>fun factorialAsString(n: Int): String {
  var result = 1L
  for (i in 1..n) {
    result *= i
  }
  return "$n! = $result"
}</pre>
			<p>The factorial of an <code>n</code> non-negative integer value is the product of all positive integers less than or equal to <code>n</code>. So, the result can be computed easily by multiplying all integers between <code>1</code> and <code>n</code>. Please note that the maximum value of a Kotlin <code>Long</code> type is 9,223,372,036,854,775,807. Hence, my implementation does not work if <code>result</code> would need to be bigger than that.</p>
			<p>Next, I'll show you<a id="_idIndexMarker065"/> how the UI is<a id="_idIndexMarker066"/> composed:</p>
			<pre>@Composable
fun Factorial() {
  var expanded by remember { mutableStateOf(false) }
  var text by remember {
    mutableStateOf(factorialAsString(0)) }
  <strong class="bold">Box</strong>(
    modifier = Modifier.fillMaxSize(),
    contentAlignment = Alignment.Center
  ) {
    <strong class="bold">Text</strong>(
      modifier = Modifier.clickable {
        expanded = true
      },
      text = text,
      style = MaterialTheme.typography.h2
    )
    <strong class="bold">DropdownMenu</strong>(
      expanded = expanded,
      onDismissRequest = {
        expanded = false
      }) {
      for (n in 0 until 10) {
        <strong class="bold">DropdownMenuItem</strong>(onClick = {
          expanded = false
          text = factorialAsString(n)
        }) {
          Text("${n.toString()}!")
        }
      }
    }
  }
}</pre>
			<p>The <code>Factorial()</code> composable function contains one predefined composable, <code>Box()</code>, which in turn has two children, <code>Text()</code> and <code>DropdownMenu()</code>. I briefly introduced you to <code>Text()</code> and <code>Box()</code> in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>. So let's concentrate on <code>DropdownMenu()</code>.</p>
			<p>A <a id="_idIndexMarker067"/>drop-down menu (the equivalent to a <code>Spinner</code>) displays <a id="_idIndexMarker068"/>a list of entries in a compact way. It appears upon interaction with an element, such as the following:</p>
			<ul>
				<li>An icon or a button</li>
				<li>When the user performs a specific action</li>
			</ul>
			<p>In my example, the <code>Text()</code> composable must be clicked.</p>
			<p>The content of a menu can either be provided by a <code>for</code> loop statement or by adding it one by one. Often, but not necessarily, <code>DropdownMenuItem()</code> is used. If the menu is expanded (that is, open or visible), it is controlled by the <code>expanded</code> parameter. <code>onDismissRequest</code> is used to react to closing the menu without selecting something. <code>DropdownMenuItem()</code> receives a click handler via the <code>onClick</code> parameter. That code is executed when the item is clicked.</p>
			<p>So far, I<a id="_idIndexMarker069"/> have presented quite a lot of information about <a id="_idIndexMarker070"/>composable functions to you. Before we move on, let's recap what we know so far:</p>
			<ul>
				<li>The entry point of a Compose UI is a composable function.</li>
				<li>From there, other composable functions are called.</li>
				<li>Often, composable functions receive <em class="italic">content</em> that is other composables.</li>
				<li>The order of invocation controls where a UI element will be in relation to other UI elements.</li>
			</ul>
			<p>Let's continue with how <code>Factorial()</code> works. It defines two variables, <code>expanded</code> and <code>text</code>. But how are they used? While an Android layout file defines a component tree in its initial state, a composable UI is always declared using actual data. This means that there is no need to set up or prepare the UI before it can be displayed for the first time. Whenever it is displayed, it looks the way you want. Let's see how this works.</p>
			<p>Most composable functions are configured by a set of parameters. Some of them are mandatory; others can be omitted. The important thing is that the composable is always called with actual values. On the other hand, components (that is, views) are initialized when they are created. And they remain this way until they are deliberately changed by altering the value of properties. That's why an app needs to keep references to all components (UI elements) it wishes to modify. But how is a Compose UI updated?</p>
			<p>The process of updating a Compose UI is<a id="_idIndexMarker071"/> called <code>Text()</code>, there is no need to recompose it. If, on the other hand, you pass something Jetpack Compose knows it can change, the Compose runtime will initiate an update, a recomposition, when that change happens. Values that change over <a id="_idIndexMarker072"/>time are called <code>mutableStateOf()</code>. To refer to state in a composable, you need to <code>remember</code> it in that composable function.</p>
			<p>Both <code>expanded</code> and <code>text</code> contain state. When these variables are used as parameters for composable functions, those composables will be recomposed whenever the value of these variables changes. Setting <code>expanded</code> to <code>true</code> brings the drop-down menu on screen immediately. This is done inside a lambda function passed to <code>clickable {}</code>. I will be discussing this in the next section. Giving <code>text</code> a new value changes the display of <code>Text()</code> because we pass the variable <code>text</code> as the value of the equally named parameter. This happens, for example, inside the code block passed to <code>onClick</code>.</p>
			<p>Getting rid<a id="_idIndexMarker073"/> of a component tree (that needs to be <a id="_idIndexMarker074"/>updated deliberately) in favor of declaring a UI based on state and thus getting updates upon state changes for free is possibly one of the most exciting advantages of the declarative approach. In the next section, I will explain a few more architectural principles of component-based and declarative UI frameworks.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor050"/>Examining architectural aspects</h1>
			<p>In the <em class="italic">Component hierarchies</em> section, I showed you that component-based UI frameworks rely on specialization. General features and concepts are implemented in the root component or one of its immediate successors. Such general features include the following:</p>
			<ul>
				<li>Location and size on screen</li>
				<li>Basic visual aspects like background (color)</li>
				<li>Simple user interactions (reacting to clicks)</li>
			</ul>
			<p>Any component will <a id="_idIndexMarker075"/>provide these features, either in a specialized way or in its basic implementation. Android's view system is class-based, so changing functionality is done by overriding the methods of the parent.</p>
			<p>Composable functions, on the other hand, do not have a shared set of properties. By annotating a function with <code>@Composable</code>, we make certain parts of Jetpack Compose aware of it. But besides not specifying a return type, composables seem to have few things in common. However, this would have been a pretty short-sighted architectural decision. In fact, Jetpack Compose makes providing a simple, predictable API really easy. The remaining part of this section illustrates this by showing you how to react to clicks, and how to size and position UI elements.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor051"/>Reacting to clicks</h2>
			<p>Android's <code>View</code> class contains a<a id="_idIndexMarker076"/> method called <code>setOnClickListener()</code>. It receives a <code>View.OnClickListener</code> instance. This interface contains one method, <code>onClick(View v)</code>. The implementation of this method provides the code that should be executed when the view is clicked. Additionally, there is a view property called <code>clickable</code>. It is accessed through <code>setClickable()</code> and <code>isClickable()</code>. If <code>clickable</code> is set to <code>false</code> after the listener has been set, the click event will not be delivered (<code>onClick()</code> is not called).</p>
			<p>Jetpack Compose can provide click handling in two ways. Firstly, composable functions that require it (because it is a core feature for them) have a dedicated <code>onClick</code> parameter. Secondly, composables that usually do not require click handling can be amended with a modifier. Let's start with the first one.</p>
			<pre>@Composable
@Preview
fun ButtonDemo() {
  Box {
    Button(onClick = {
      println("clicked")
    }) {
      Text("Click me!")
    }
  }
}</pre>
			<p>Please note that <code>onClick</code> is mandatory; you must provide it.</p>
			<p>If you want to show the button but the user should not be able to click it, the code looks like this:</p>
			<pre>Button(
  onClick = {
    println("clicked")
  },
  enabled = false
) {
  Text("Click me!")
}</pre>
			<p><em class="italic">Figure 2.3</em> shows what the<a id="_idIndexMarker077"/> button looks like when <code>enabled</code> is either <code>true</code> or <code>false</code>:</p>
			<div><div><img src="img/B17505_02_03.jpg" alt="Figure 2.3 – A button with enabled = true or false&#13;&#10;" width="486" height="121"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – A button with enabled = true or false</p>
			<p><code>Text()</code> doesn't have an <code>onClick</code> property. If you want to make it clickable (like I do in the <em class="italic">Factorial</em> app), you pass <code>clickable { ... }</code> to the <code>modifier</code> parameter:</p>
			<pre>modifier = Modifier.clickable { ...</pre>
			<p>Modifiers, as their name suggests, provide an infrastructure for influencing both the visual appearance and behavior of composable functions. I will show you another example for modifiers in the next section. <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, covers them in much greater detail.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor052"/>Sizing and positioning UI elements</h2>
			<p>In component-centric<a id="_idIndexMarker078"/> UI frameworks, size and location onscreen (or relative to <a id="_idIndexMarker079"/>another component) are core properties. They are defined in the root component (on Android, the <code>View</code> class). Descendants of <code>ViewGroup</code> size and position their children by changing their corresponding properties. For example, <code>RelativeLayout</code> is based upon instructions such as <code>toStartOf</code>, <code>toEndOf</code>, or <code>below</code>. <code>FrameLayout</code> draws its children in a stack. And <code>LinearLayout</code> lays out children horizontally or vertically. So, <code>...Layout</code>s are containers with the ability to size and position their children.</p>
			<p>Jetpack Compose has a very similar concept. You have already learned about <code>Row()</code> and <code>Column()</code>, which lay out their content horizontally or vertically. <code>Box()</code> is similar to <code>FrameLayout</code>. It organizes its content in the order it appears in code. The position inside the box is controlled by <code>contentAlignment</code>:</p>
			<pre>@Composable
@Preview
fun BoxDemo() {
  Box(contentAlignment = Alignment.Center) {
    Box(
      modifier = Modifier
        .size(width = 100.dp, height = 100.dp)
        .background(Color.Green)
    )
    Box(
      modifier = Modifier
        .size(width = 80.dp, height = 80.dp)
        .background(Color.Yellow)
    )
    Text(
      text = "Hello",
      color = Color.Black,
      modifier = Modifier.align(Alignment.TopStart)
    )
  }
}</pre>
			<p>The content may <a id="_idIndexMarker080"/>override this by using <code>modifier = Modifier.align()</code>, the <a id="_idIndexMarker081"/>result of which we can see in <em class="italic">Figure 2.4</em>:</p>
			<div><div><img src="img/B17505_02_04.jpg" alt="Figure 2.4 – An invisible box containing two colored boxes and text&#13;&#10;" width="232" height="252"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – An invisible box containing two colored boxes and text</p>
			<p>Modifiers can also be used to request a size. In some of my examples, you may have spotted <code>Modifier.fillMaxSize()</code>, which makes the composable as big as possible. <code>Modifier.size()</code> requests a particular size. Modifiers can be chained. The root of such a chain is the <code>Modifier</code> companion object. Subsequent modifiers are added using a dot.</p>
			<p>Before closing this chapter, I would like to emphasize the benefits of the modifier concept with one more example. Did you notice the <code>background()</code> modifiers of the first and second content box? This modifier allows you to set a background color for any composable function. When you need something a composable function does not offer out of the box, you can add it with a modifier. As you can write custom modifiers, the possibilities to adjust a composable to your needs are almost endless. I will elaborate on this in the next chapter.</p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor053"/>Summary</h1>
			<p>In this chapter, you have learned about key elements of component-centric UI frameworks. We saw some of the limitations of this approach and how the declarative paradigm can overcome them. For example, specialization takes place on a component level. If the framework is based upon inheritance, the distribution of features to children may be too broad. Jetpack Compose tackles this with the modifier mechanism, which allows us to amend functionality at a very fine-grained level; this means that composables only get the functionality they need (for example, a background color).</p>
			<p>The remaining chapters of this book are solely based on the declarative approach. In <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, we will take an even closer look at composable functions and examine the concepts of composition and recomposition. And, as promised, we will also dive deep into modifiers.</p>
		</div>
	</div></body></html>