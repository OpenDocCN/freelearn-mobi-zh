- en: Chapter 5. Classes and Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first programming language that I learned was BASIC. It was a good language
    to begin programming with, but once I traded in my Commodore Vic-20 for a PCjr
    (yes, I had a PCjr and I really enjoyed it), I realized that there were other,
    more advanced languages out there, and spent a lot of time learning Pascal and
    C. It wasn't until I started college that I heard the term "object-oriented language".
    At that time, object-oriented languages were so new that there were no real courses
    on them, but I was able to experiment a little with C++. After I graduated, I
    left object-oriented programming behind, and it really wasn't until several years
    later, when I started to experiment with C++ again, that I really discovered the
    power and flexibility of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding properties and property observers to classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding methods to classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding initializers to classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using access controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding memory management and ARC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are classes and structures?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, classes and structures are very similar. If we really want to master
    Swift, it is very important to understand what makes classes and structures so
    similar and also what sets them apart because they are the building blocks of
    your applications. Apple describes classes and structures as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Classes and structures are general-purpose, flexible constructs that become
    the building blocks of your program''s code. You define properties and methods
    to add functionality to your classes and structures by using the already familiar
    syntax of constants, variables, and functions."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's begin by taking a quick look at some of the similarities between classes
    and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Similarities between classes and structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Swift, classes and structures are more similar than they are in other languages,
    such as Objective-C. The following is a list of some of the features that classes
    and structures share:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Properties: These are used to store information in our classes and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods: These provide functionality for our classes and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initializers: These are used when initializing instances of our classes and
    structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Subscripts: These provide access to values using the subscript syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extensions: These help in extending both classes and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's take a quick look at some of the differences between classes and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between classes and structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While classes and structures are very similar, there are also several very
    important differences. The following is a list of some of the differences between
    classes and structures in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type: A structure is a value type while a class is a reference type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inheritance: A structure cannot inherit from other types while a class can'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deinitializers: Structures cannot have custom deinitializers while a class
    can'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple references: We can have more than one reference to a class instance;
    however, with structures, we cannot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be emphasizing the differences between classes
    and structures to help us understand when to use each. Before we really dive into
    classes and structures, let's take a look at the difference between value types
    (structures) and reference types (classes). In order to understand when to use
    classes and structures and how to properly use them, it is important to understand
    the difference between value and reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Value versus reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Structures such as enums and tuples are value types. This means when we pass
    instances of a structure within our application, we pass a copy of the structure
    and not the original structure. Classes are reference types, which means when
    we pass an instance of a class within our application, we pass a reference to
    the original instance. It is very important to understand the difference between
    value and reference types. We will give a very high-level view here, and will
    provide additional details in the *Memory management* section at the end of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass structures within our application, we are passing copies of the
    structures and not the original structures. Since a function gets its own copy
    of the structure, it can change it as needed, without affecting the original instance
    of the structure.
  prefs: []
  type: TYPE_NORMAL
- en: When we pass an instance of a class within our application, we are passing a
    reference to the original instance of the class. Since we pass an instance of
    a class to a function, the function is getting a reference to the original instance;
    therefore, any changes made within the function will remain once the function
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the difference between value and reference types, let's look at
    a real-world object—a book. If we had a friend that wanted to read *Mastering
    Swift*, we could either buy them their own copy or share ours.
  prefs: []
  type: TYPE_NORMAL
- en: If we bought our friend their own copy of the book, then any notes they made
    within the book would remain in their copy of the book and would not be reflected
    in our copy. This is how pass by value works with structures and variables. Any
    changes that are made to the structure or variable within the function are not
    reflected in the original instance of the structure or variable.
  prefs: []
  type: TYPE_NORMAL
- en: If we share our copy of the book, then any notes they made within the book would
    stay in the book when they returned it to us. This is how pass by reference works.
    Any changes that are made to the instance of the class remains when the function
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: To read more about value versus reference types, see the *Memory management*
    section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class or structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We use the same syntax to define classes and structures. The only difference
    is we define a class using the `class` keyword, and a structure by using the `struct`
    keyword. Let''s look at the syntax used to create both classes and structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we define a new class named `MyClass` and a new structure
    named `MyStruct`. This effectively creates two new Swift types named `MyClass`
    and `MyStruct`. When we name a new type, we want to use the standard naming convention
    set by Swift where the name is in camel case, with the first letter being uppercase.
    Any method or property defined within the class or structure should also be named
    using camel case with the first letter being lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Empty classes and structures are not that useful, so let's look at how we can
    add properties to our classes and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Properties associate values with a class or a structure. There are two types
    of properties, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stored properties: They store variable or constant values as part of an instance
    of a class or structure. Stored properties can also have property observers that
    can monitor the property for changes and respond with custom actions when the
    value of the property changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Computed properties: They do not store a value themselves, but retrieve and
    possibly set other properties. The value returned by a computed property can also
    be calculated when it is requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stored property is a variable or constant that is stored as part of an instance
    of a class or structure. We can provide a default value for stored properties.
    These are defined with the `var` keyword. Let''s look at how we would use stored
    properties in classes and structures. In the following code, we will create a
    structure named `MyStruct` and a class named `MyClass`. The structure and the
    class both contain two stored properties, `c` and `v`. The stored property `c`
    is a constant because it is defined with the `let` keyword, and `v` is a variable
    because it is defined with the `var` keyword. Let''s take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the example, the syntax to define a stored property is the
    same for both classes and properties. Let''s look at how we would create an instance
    of both the structure and class. The following code creates an instance of the
    `MyStruct` structure named `myStruct` and an instance of the `MyClass` class named
    `myClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the differences between a structure and a class is that, by default,
    a structure creates an initializer that lets us populate the stored properties
    when we create an instance of the structure. Therefore, we could also create an
    instance of the `MyStruct` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the initializer is used to set the variable `v`,
    and the `c` constant will contain the number 5 that is set in the `struct` itself.
    If, for example, we did not give the constant an initial value, as shown in the
    following example, the default initializer would be used to also set the constant
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how the initializer for this new `struct` would
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to define a constant where we set the value when we initialize
    the class or struct at runtime rather than hardcoding the value of the constant
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: The order in which the parameters appear in the initializer is the order that
    we defined them in. In the previous example, we defined the c constant first;
    therefore, it is the first parameter in the initializer. We defined the v parameter
    second; therefore it is the second parameter in the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set or read a stored property, we use the standard dot syntax. Let''s look
    at how we would set and read stored properties in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we move on to computed properties, let''s create a structure and class
    that will represent an employee. We will be using and expanding these throughout
    this chapter to show how classes and structures are similar and how they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The employee structure is named `EmployeeStruct` and the employee class is
    named `EmployeeClass`. Both the class and structure have three stored properties:
    `firstName`, `lastName`, and `salaryYear`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within our structure or class, we can now access these properties by using
    the name of the property or the `self` keyword. Every instance of a structure
    or class has a property named `self`. This property refers to the instance itself;
    therefore, we can use it to access the properties within the instance. The following
    examples show how we can access the properties with the `self` keyword within
    the instance of the structure or class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Computed properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computed properties are properties that do not have backend variables that
    are used to store the values associated with the property. The values of a computed
    property are usually computed when code requests it. You can think of a computed
    property as a function disguised as a property. Let''s take a look at how we would
    define a read-only computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To create a read-only computed property, we begin by defining it as if it were
    a normal variable with the `var` keyword, followed by the variable name, colon
    and the variable type. What comes next is different; we add a curly bracket at
    the end of the declaration and then define a `getter` method that is called when
    the value of our computed property is requested. In the example, the `getter`
    method divides the current value of the `salaryYear` property by `52` to get the
    employee's weekly salary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify the definition of the read-only computed property by removing
    the `get` keyword. We could rewrite the `salaryWeek` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Computed properties are not limited to being read-only, we can also write to
    them. To enable the `salaryWeek` property to be writeable, we would need to add
    a `setter` method. The following example shows how we would add a `setter` method
    that will set the `salaryYear` property, based on the value being passed into
    the `salaryWeek` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the setter definition by not defining a name for the new value.
    In this case, the value would be assigned to a default variable name, `newValue`.
    The `salaryWeek` computed property could be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `salaryWeek` computed property, as written in the preceding example, could
    be added to either the `EmployeeClass` class or the `EmployeeStruct` structure
    without any modifications. Let''s see how we would do this by adding the `salaryWeek`
    property to our `EmployeeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how we would add the `salaryWeek` computed property to
    the `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the class and structure definitions are the same so far, except
    for the initial class or `struct` keywords are used to define them as either a
    structure or a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We read and write to a computed property exactly as we would to a stored property.
    Code that is external to the class or structure should not be aware that the property
    is a computer property. Let''s see this in action by creating an instance of the
    `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example starts off by creating an instance of the `EmployStruct`
    structure with the `salaryYear` value being set to `39,000`. Next, we print the
    value of the `salaryWeek` property to the `console`. This value is currently `750.00`.
    We then set the `salaryWeek` property to `1000.00` and print out both the `salaryWeek`
    and `salaryYear` properties to the console. The values of the `salaryWeek` and
    `salaryYear` properties are now `1000.00` and `52000` respectively. As we can
    see, in this example, setting either the `salaryWeek` or `salaryYear` property
    changes the values returned by both.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties can be very useful for offering different views of the same
    data. For example, if we had a value that represented the length of something,
    we could store the length in centimeters and then use computed properties that
    calculate the values for meters, millimeters, and kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at property observers.
  prefs: []
  type: TYPE_NORMAL
- en: Property observers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Property observers are called every time the value of the property is set. We
    can add property observers to any non-lazy stored property. We can also add property
    observers to any inherited stored or computed property by overriding the property
    in the subclass. We will look at the *Overriding properties* section a little
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are two property observers that we can set in Swift—`willSet` and `didSet`.
    The `willSet` observer is called right before the property is set, and the `didSet`
    observer is called right after the property is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note about property observers is that they are not called when
    the value is set during initialization. Let''s look at how we would add a property
    observer to the salary property of our `EmployeeClass` class and `EmployeeStruct`
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we add a property observer to a stored property, we need to include the
    type of the value being stored within the definition of the property. In the preceding
    example, we did not need to define our `salaryYear` property as a `Double` type;
    however, when we add property observers the definition is required.
  prefs: []
  type: TYPE_NORMAL
- en: After the property definition, we define a `willSet` observer that simply prints
    out the new value that the `salaryYear` property will be set to. We also define
    a `didSet` observer that will check whether the new value is greater than the
    old value and if so, it will print out that the employee got a raise, otherwise,
    it will print out that the employee did not get a raise.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the getter in computed properties, we do not need to define the name
    for the new value for the `willSet` observer. If we do not define a name, the
    new value is put in a constant named `newValue`. The following example shows how
    we would rewrite the previous `willSet` observer without defining a name for the
    new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, properties are mainly used to store information associated
    with a class or structure, and methods are mainly used to add the business logic
    to a class or structure. Let's look at how we would add methods to class or structure.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Methods are functions that are associated with a class or structure. A method,
    like a function, will encapsulate the code for a specific task or functionality
    that is associated with the class or structure. Let''s look at how we would define
    a method in classes and structures. The following code will return the full name
    of the employee by using the `firstName` and `lastName` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We define this method exactly as we would define any function. A method is simply
    a function that is associated with a specific class or structure, and everything
    that we learned about functions in the previous chapters applies to methods. The
    `getFullName()` function can be added directly to the `EmployeeClass` class or
    `EmployeeStruct` structure without any modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a method, we use the same dot syntax we used to access properties.
    The following code shows how we would access the `getFullName()` method of a class
    and a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we initialize an instance of both the `EmployeeClass`
    class and `EmployeeStruct` structure. We populate the structure and class with
    the same information and then use the `getFullName()` method to print the full
    name of the employee to the console. In both cases, `Jon Hoffman` is printed to
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a difference in how we define methods for classes and structures,
    which we need to update property values within the method. Let''s look at how
    we would define a method that gives an employee a raise within the `EmployeeClass`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add the preceding code to our `EmployeeClass`, it works as expected and
    when we call the method, with an amount, the employee gets a raise. However, if
    we try to add this method as it is written to the `EmployeeStruct` structure,
    we receive the `Cannot invoke ''+='' with an argument list of type ''(Double,
    Double)''` error. By default, we are not allowed to update property values within
    a method of a structure. If we want to modify a property, we can opt into mutating
    behavior for that method by adding the `mutating` keyword before the `func` keyword
    of the method declaration. Therefore, the following code would be the correct
    way to define the `giveRaise()` method for the `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we used the `self` property. Every instance of a
    type has a property called `self`, which is the instance itself. We use the `self`
    property to refer to the current instance of the type within the instance itself,
    so when we write `self.salaryYear`, we ask for the value of the `salaryYear` property
    of the current instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `self` property can be used to distinguish between a local variable and
    instance variable that have the same name. Let''s look at an example that illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the method accepts an argument with the name, `firstName`.
    There is also a property that has this name. We use the self property to specify
    that we want the instance property with the name, `firstName`, and not the local
    variable with this name.
  prefs: []
  type: TYPE_NORMAL
- en: Other than the `mutating` keyword being required for methods that change the
    value of the structure's properties, methods can be defined and used exactly as
    functions are defined and used. Therefore, everything we learned about functions
    in the previous chapter can be applied to methods.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we want to initialize properties or perform some business
    logic when a class or structure is first initialized. For this, we will use an
    initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Custom initializers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initializers are called when we initialize a new instance of a particular type
    (class or structure). Initialization is the process of preparing an instance for
    use. The initialization process can include setting initial values for stored
    properties, verifying resources, such as web services, files, and so on are available,
    or setting up the UI properly. Initializers are generally used to ensure that
    the instance of the class or structure is properly initialized prior to first
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializers are special methods that are used to create a new instance of
    a type. We define an initializer exactly as we would define other methods, but
    we must use the `init` keyword as the name of the initializer to tell the compiler
    that this method is an initializer. In its simplest form, the initializer does
    not accept any arguments. Let''s look at the syntax used to write a simple initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This format works for both classes and structures. By default, all classes
    and structures have an empty default initializer that we can override if we choose
    to. We saw these default initializers when we used the `EmployeeClass` class and
    `EmployeeStruct` structure in the previous section. Structures also have an additional
    default initializer, which we saw with the `EmployeeStruct` structure that accepts
    a value for each stored property and initializes them with those values. Let''s
    look at how we would add custom initializers to our `EmployeeClass` class and
    `EmployeeStruct` structure. In the following code, we create three custom initializers
    that will work for both the `EmployeeClass` class and `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first initializer, `init()`, when used, will set all of the stored properties
    to their default values. The second initializer, `init(firstName: String, lastName:
    String)`, when used, will populate the `firstName` and `lastName` properties with
    the values of the arguments. The third initializer, `init(firstName: String, lastName:
    String, salaryYear: Double)`, will populate all the properties with the values
    of the arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example we can see that in Swift, unlike Objective-C, an initializer
    does not have a return value. This means that we do not have to define the return
    type for the initializer or have a return statement within the initializer. Let''s
    look at how we would use these initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The variable `g` uses the `init()` initializer to create an instance of the
    `EmployeeClass` class; therefore, all the properties of this `EmployeeClass` instance
    contain their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `h` variable uses the `init(firstName: String, lastName: String)` initializer
    to create an instance of the `EmployeeStruct` structure; therefore, the `firstName`
    property of the structure is set to `Me` and the `lastName` property is set to
    `Moe`, which are the two arguments passed into the initializer. The `salaryYear`
    property is still set to the default value of 0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EmployeeClass` sets the `init(firstName: String, lastName: String, salaryYear:
    Double)` initializer to create an instance of the `EmployeeClass` class; therefore,
    the `firstName` property is set to `Me`, the `lastName` property is set to `Moe`,
    and the `salaryYear` is set to `45000`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since all the initializers are identified with the `init` keyword, the parameters
    and parameter types are used to identify which initializer to use. Therefore,
    Swift provides automatic external names for all of these parameters. In the previous
    example. We can see that when we use an initializer that has parameters, we include
    the parameter names. Let's take a look at internal and external parameter names
    with initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Internal and external parameter names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like functions, the parameters associated with an initializer can have
    separate internal and external names. Unlike functions, if we do not supply external
    parameter names for our parameters, Swift will automatically generate them for
    us. In the previous examples, we did not include external parameter names in the
    definition of the initializers, so Swift created them for us using the internal
    parameter name as the external parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to supply our own parameter names, we would do so by putting the
    external function name before the internal function name, exactly as we do with
    any normal function. Let''s look at how we would define our own external parameter
    names by redefining one of the initializers within our `EmployeeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created the `init(employeeWithFirstName firstName:
    String, lastName lastName: String, andSalary salaryYear: Double)` initializer.
    This initializer will create an instance of the `EmployeeClass` class and populate
    the instance properties with the value of the arguments. In this example, each
    of the parameters has both external and internal property names. Let''s look at
    how we would use this initializer, with the external property names, to create
    an instance of the `EmployeeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are now using the external parameter names as we defined in our
    initializer. Using external parameter names can help make our code more readable
    and differentiate between different initializers.
  prefs: []
  type: TYPE_NORMAL
- en: So, what will happen if our initializer fails? For example, what if our class
    relies on a specific resource, such as web service or a specific file that is
    not currently available? This is where failable initializers come in.
  prefs: []
  type: TYPE_NORMAL
- en: Failable initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A failable initializer is an initializer that may fail to initialize the resources
    needed for a class or a structure, thereby rendering the instance unusable. When
    using a failable initializer, the result of the initializer is an optional type,
    containing either a valid instance of the type or nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'An initializer can be made failable by adding a question mark (`?`) after the
    `init` keyword. Let''s look at how we would create a failable initializer that
    will not allow a new employee to be initialized with a salary below `$20,000`
    a year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we did not include a `return` statement within the
    initializer because Swift does not need to return the initialized instance; however,
    in a failable initializer, if the initialization fails, we will return a `nil`.
    If the initializer successfully initializes the instance, we do not need to return
    anything. Therefore, in our example, if the yearly salary that is passed in is
    below `$20,000` a year, we return `nil`, indicating that the initialization failed,
    otherwise, nothing will be returned. Let''s look at how we would use a failable
    initializer to create an instance of a class or structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we initialize the instance of the `EmployeeClass`
    class with a yearly salary greater than $20,000; therefore, the instance gets
    initialized correctly and the full name of `Jon Hoffman` is printed to the console.
    Now let''s try to initialize an instance of the `EmployeeClass` class with a yearly
    salary less than $20,000 to see how it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the yearly salary that we are attempting to initialize for our
    employee is less than $20,000; therefore, the initialization fails and a `Failed
    to initialize` message is printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we want to restrict access to certain parts of our code.
    This enables us to hide implementation details and only expose the interfaces
    we want to expose. This feature is handled with named access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Access control allows us to restrict the access and visibility to parts of our
    code. This allows us to hide implementation details and only expose the interfaces
    we want the external code to access. We can assign specific access levels to both
    classes and structures. We can also assign specific access levels to properties,
    methods, and initializers that belong to our classes and structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, there are three access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: This is the most visible access control level. It allows us to
    use the property, method, class, and so on anywhere we want to import the module.
    Basically, anything can use a property, method, class, and so on that has an access
    control level of public. This level is primarily used by frameworks to expose
    the framework''s public API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: This is the default access level. This access level allows us
    to use the property, method, class, and so on in the defining source as well as
    the module that the source is in (the application or framework). If this level
    is used in a framework, it lets other parts of the framework use the property,
    method, class, and so on, but code outside the framework will be unable to access
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This is the least visible access control level. It only allows
    us to use the property, method, class, and so on in the source file that defines
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are writing code that will be self-contained within a single application
    and there is no need for it to be made available outside the application, then
    we can largely ignore access controls. The default access level of internal already
    matches this requirement. We may, however, want to hide parts of the implementation,
    which can be done by setting the access level to private, but that should be an
    exception and not the rule.
  prefs: []
  type: TYPE_NORMAL
- en: When we are developing frameworks, the access controls really become useful.
    We would need to mark the public facing interfaces as public, so other modules
    such as applications that import the framework can use them. We would then use
    the internal and private access control levels to mark the interfaces that we
    want to use internally to the framework and the source file, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define access levels, we place the name of the level before the definition
    of the entity. The following code shows examples of how we would add access levels
    to several entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are some limitations with access controls, but these limitations are there
    to ensure that access levels in Swift follow a simple guiding principle—*no entity
    can be defined in terms of another entity that has a lower (more restrictive)
    access level*. What this means is we cannot assign a higher (less restrictive)
    access level to an entity when it relies on another entity that has a lower (more
    restrictive) access level.
  prefs: []
  type: TYPE_NORMAL
- en: 'As following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot mark a method as being public when one of the arguments or the return
    type has an access level of private because external code would not have access
    to the private type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot set the access level of a method or property to public when the class
    or structure has an access level of private because external code would not be
    able to access the constructor when the class is private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of inheritance is a basic object-oriented development concept. Inheritance
    allows a class to be defined as having a certain set of characteristics and then
    other classes can be derived from that class. The derived class inherits all of
    the features of the class it is inheriting from (unless the derived class overrides
    those characteristics) and then usually adds additional characteristics of its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance, we can create what is known as a class hierarchy. In a class
    hierarchy, the class at the top of the hierarchy is known as the **base class**
    and the derived classes are known as **subclasses**. We are not limited to only
    creating subclasses from a base class; we can also create subclasses from other
    subclasses. The class that a subclass is derived from is known as the parent or
    superclass. In Swift, a class can have only one parent class, known as single
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance is one of the fundamental differences that separate classes from
    structures. Classes can be derived from a parent or super class, but a structure
    cannot be.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses can call and access the properties, methods, and subscripts of their
    super class. They can also override the properties, methods, and subscripts of
    their super class. Subclasses can add property observers to properties that they
    inherit from a super class, so they can be notified when the values of the properties
    change. Let's look at an example that illustrates how inheritance works in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by defining a base class named `Plant`. The `Plant` class
    will have two properties, `height` and `age`. It will also have one method, `growHeight()`.
    The `height` property will represent the height of the plant, the `age` property
    will represent the age of the plant, and the `growHeight()` method will be used
    to increase the height of the plant. Here is how we would define the `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `Plant` base class, let''s see how we would define a subclass
    of it. We will name this subclass `Tree`. The `Tree` class will inherit the `age`
    and `height` properties of the `Plant` class and add one additional property named
    `limbs`. It will also inherit the `growHeight()` method of the `Plant` class and
    add two additional methods: `limbGrow()`, where a new limbs is grown, and `limbFall()`,
    where one of the limbs falls off the tree. Let''s have a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We indicate that a class has a super class by adding a colon and the name of
    the super class to the end of the class definition. In the `Tree` example, we
    indicated that the `Tree` class has a super class named `Plant`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we could use the `Tree` class that inherited the `age`
    and `height` properties from the `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example begins by creating an instance of the `Tree` class. We
    then set the `age` and `height` properties to `5` and `4`, respectively, and add
    two limbs to the tree by calling the `limbGrow()` method twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a base class named `Plant` that has a subclass named `Tree`. This
    means that the super (or parent) class of `Tree` is the `Plant` class. This also
    means that one of the subclasses (or child classes) of `Plant` is named `Tree`.
    There are, however, lots of different kinds of trees in the world. Let''s create
    two subclasses from the `Tree` class. These subclasses will be the `PineTree`
    class and the `OakTree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The class hierarchy now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inheritance](img/B05115_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to keep in mind that in Swift, a class can have multiple subclasses;
    however, a class can have only one super class. There are times when a subclass
    needs to provide its own implementation of a method or property that it inherited
    from its super class. This is known as overriding.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods and properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To override a method, property, or subscript, we need to prefix the definition
    with the `override` keyword. This tells the compiler that we intend to override
    something in the super class and that we did not make a duplicate definition by
    mistake. The `override` keyword does prompt the Swift compiler to verify that
    the super class (or one of its parents) has a matching declaration that can be
    overridden. If it cannot find a matching declaration in one of the super classes,
    an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how we would override a method. We will start by adding a `getDetails()`
    method to the `Plant` class that we will then override in the child classes. The
    following code shows how the new Plant class looks similar to with the `getDetails()`
    method added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see how we would override the `getDetails()` method in the `Tree`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing to note here is that we do not use the `override` keyword in the
    `Plant` class because it is the first class to implement this method; however,
    we do include it in the `Tree` class since we are overriding the `getDetails()`
    method from the `Plant` class. Now, let''s see what happens if we call the `getDetails()`
    method from an instance of the `Plant` and `Tree` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example would print the following two lines to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `getDetails()` method in the `Tree` subclass overrides the
    `getDetails()` of its parent `Plant` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Tree` class, we can still call the `getDetails()` method (or any
    overridden method, property, or subscript) of its super class by using the `super`
    prefix. Let''s see how we would call the `getDetails()` method of the `Plant`
    class from an instance of the `Tree` class. We will begin by replacing the `getDetails()`
    method in the `Plant` class with the following method that will generate a string
    containing the values of the `height` and `age` properties. Let''s take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are changing the `getDetails()` method to return
    a string that contains the `height` and `age` of the plant. Now let''s replace
    the `getDetails()` method for the `Tree` class with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we begin by calling the `getDetails()` method of
    the super class (the `Plant` class in this case) to get a string containing the
    tree''s `height` and `age`. We then build a new string object that contains the
    results of the `getDetails()` method from the super class, adds the number of
    limbs to it and then returns it. Let''s look at what happens if we call the `getDetails()`
    method of the `Tree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, the following line would be printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the string that is returned contains the `height` and `age` information
    from the `Plant` class and the limbs information from the `Tree` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also chain the overridden methods. Let''s see what happens if we add
    the following method to the `OakTree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the `getDetails()` method of an instance of the `OakTree` class,
    it calls the `getDetails()` method of its super class (the `Tree` class). The
    `getDetails()` method of the `Tree` class also calls the `getDetails()` method
    of its super class (the `Plant` class). The `getDetails()` method of the `Tree`
    class will finally create a string object that contains the `height` and `age`
    from the `Plant` class, the `limbs` from the `Tree` class, and the `leaves` from
    the `OakTree` class. Let''s look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, we would see the following line printed to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Overriding properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can provide custom `getter` and `setter` to override any inherited property.
    When we override a property, we must provide the name and the type of property
    we are overriding, so the compiler can verify one of the classes in the class
    hierarchy has a matching property to override. While overriding properties are
    not as common as overriding methods, it is good for us to know how to do this
    when we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we would override a property by adding the following method
    to our `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `description` property is a basic read-only property. This property returns
    the string, `Base class is Plant.`. Now let''s override this property by adding
    the following property to the `Tree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When we override a property, we use the same `override` keyword that we use
    when we override a method. The `override` keyword tells the compiler that we want
    to override a property, so the compiler can verify that another class in the class
    hierarchy contains a matching property to override. We then implement the property
    as we would any other property. Calling the `description` property of the tree
    would result in the `Base class is Plant. I am a Tree class.`. string being returned.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we want to prevent a subclass from overriding the properties
    and methods. There are also times when we want to prevent an entire class from
    being subclassed. Let's see how we do this.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing overrides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prevent overrides or subclassing, we use the `final` keyword. To use the
    `final` keyword, we add it before the item's definition. Examples are `final func`,
    `final var`, and `final class`.
  prefs: []
  type: TYPE_NORMAL
- en: Any attempt to override an item marked final will throw a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we would like to describe the implementations (methods,
    properties, and other requirements) of a class without actually providing the
    implementation. For this, we would use protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols define a blueprint of methods, properties, and other requirements
    for a class or a structure. A class or a structure can then provide an implementation
    that conforms to those requirements. The class or structure that provides the
    implementation is said to conform to the protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax to define a protocol is very similar to how we define a class or
    a structure. The following example shows the syntax used to define a protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We state that a class or structure conforms to a particular protocol by placing
    the name of the protocol after the class or structure''s name, separated by a
    colon. Here is an example of how we would state that a class conforms to the `MyProtocol`
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'A class or a structure can conform to multiple protocols. We would list the
    protocols that the class or structure conforms to by separating them with commas.
    The following example shows how we would state that our class conforms to multiple
    protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When we need a class to inherit from a super class and implement a protocol,
    we would list the super class first, followed by the protocols. The following
    example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Property requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol can require that the conforming class or structure provide certain
    properties with a specified name and type. The protocol does not say if the property
    should be a stored or computed property because the implementation details are
    left up to the conforming class or structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining a property within a protocol, we must specify whether the property
    is a read-only or a read-write property by using the `get` and `set` keywords.
    Let''s look at how we would define properties within a protocol by creating a
    `FullName` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FullName` protocol defines two properties, which any class or structure
    that conforms to the protocol must implement. These are the `firstName` and `lastName`
    properties. Both these properties in the `FullName` protocol are read-write properties.
    If we wanted to specify that the property is read-only, we would define it with
    only the `get` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we would create a `Scientist` class that conforms to this protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If we had forgotten to include either the `firstName` or `lastName` property,
    we would have received a `Scientist does not conform to protocol 'FullName'` error
    message. We also need to make sure that the type of the property is the same.
    For example, if we changed the `lastName` definition in the `Scientist` class
    to `var lastName = 42`, we would also receive a `Scientist does not conform to
    protocol 'FullName'` error message because the protocol specifies that we must
    have a `lastName` property of the string type.
  prefs: []
  type: TYPE_NORMAL
- en: Method requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A protocol can require that the conforming class or structure provide certain
    methods. We define a method within a protocol exactly as we do within a normal
    class or structure, except without the curly braces or method body. Let's add
    a `getFullName()` method to our `FullName` protocol and `Scientist` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how the `FullName` protocol would look with the
    `getFullName()` method added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to add a `getFullName()` method to our Scientist class so
    that it will properly conform to the `FullName` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Structures can conform to Swift protocols exactly as classes do. The following
    example shows how we can create a `FootballPlayer` structure that conforms to
    the `FullName` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When a class or structure conforms to a Swift protocol, we can be sure that
    it has implemented the required properties and methods. This can be very useful
    when we want to ensure that certain properties or methods are implemented over
    various classes, as our preceding examples show.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocols are also very useful when we want to decouple our code from requiring
    specific classes or structures. The following code shows how we would decouple
    our code using the `FullName` protocol, the `Scientist` class, and the `FootballPlayer`
    structure that we have already built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by creating an instance of the `Scientist` class
    and the `FootballPlayer` structure. We then create a `person` variable that is
    of the `FullName` (protocol) type and set it to the `scientist` instance that
    we just created. We then call the `getFullName()` method to retrieve our description.
    This will print out the `Kara Hoffman studies Physics` message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the `person` variable equal to the `player` instance and call the
    `getFullName()` method again. This will print out the `Dan Marino has the number
    13` message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the `person` variable does not care what the actual implementation
    class or structure is. Since we defined the `person` variable to be of the `FullName`
    type, we can set the `person` variable to an instance of any class or structure
    that conforms to the `FullName` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Optional requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when we want protocols to define optional requirements, that
    is, methods or properties that are not required to be implemented. To use optional
    requirements, we need to start off by marking the protocol with the `@objc` attribute.
    To mark a property or method as optional, we use the `optional` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One very important thing to note about using the `@objc` attribute is that only
    classes can adopt protocols marked with it; structures cannot adopt these protocols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we would use the `optional` keyword to define optional properties
    and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the `Phone` protocol we just created, we defined a required property named
    `phoneNumber`, and an optional property named `emailAddress`. Also, in the `Phone`
    protocol, we defined a required function named `dialNumber()` and an optional
    function named `getEmail()`. This means that a class that adopts the `Phone` protocol
    must provide a `phoneNumber` property and a `dialNumber()` method. A class that
    adopts the Phone protocol can also optionally provide an `emailAddress` property
    and a `getEmail()` method, but it is not required too.
  prefs: []
  type: TYPE_NORMAL
- en: Swift 2 adds protocol extensions to Swift. This is a very exciting and important
    feature in the Swift language. To read about protocol extensions, please refer
    to [Chapter 6](ch06.html "Chapter 6. Using Protocols and Protocol Extensions"),
    *Using Protocols and Protocol Extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we need to add additional functionality to an existing
    class or structure. To do this, we use extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With extensions, we can add new properties, methods, initializers, and subscripts,
    or make an existing class or structure conform to a protocol. One thing to note
    is that extensions cannot override the existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define an extension, we use the `extension` keyword, followed by the type
    that we are extending. The following example shows how we would create an extension
    that extends the string class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how extensions work by adding a `reverse()` method and a `firstLetter`
    property to Swift''s standard string class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: When we extend an existing class or structure, we define properties, methods,
    initializers, subscripts, and protocols in exactly the same way as we would normally
    define them in a standard class or structure. In the string extension example,
    we see that we define the `reverse()` method and the `firstLetter` property exactly
    as we would define them in a normal class.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions are very useful for adding additional functionality to classes and
    structures from external frameworks, even for Apple's frameworks, as demonstrated
    in the examples. It is preferred to use extensions to add additional functionality
    to classes from external frameworks rather than subclassing because it allows
    us to use the classes provided by the frameworks throughout our code.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned at the start of this chapter, structures are value types and
    classes are reference types. What this means is that when we pass an instance
    of a structure within our application, such as a parameter of a method, we create
    a new instance of the structure in the memory. This new instance of the structure
    is only valid while the application is in the scope where the structure was created.
    Once the structure goes out of scope, the new instance of the structure is destroyed
    and the memory is released. This makes memory management of structures pretty
    easy and somewhat painless.
  prefs: []
  type: TYPE_NORMAL
- en: Classes, on the other hand, are of the reference type. This means that we allocate
    the memory for the instance of the class only once when it is initially created.
    When we want to pass an instance of the class within our application, as either
    a function argument or by assigning it to a variable, we really pass a reference
    to where the instance is stored in the memory. Since the instance of a class may
    be referenced in multiple scopes (unlike a structure), it cannot be automatically
    destroyed, and memory is not released when it goes out of scope if it is referenced
    in another scope. Therefore, Swift need some form of memory management to track
    and release the memory used by instances of classes when the class is no longer
    needed. Swift uses **Automatic Reference Counting (ARC)** to track and manage
    memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: With ARC, for the most part, memory management in Swift simply works. ARC will
    automatically track the references to instances of classes, and when an instance
    is no longer needed (no references pointing to it), ARC will automatically destroy
    the instance and release the memory. There are a few instances where ARC requires
    additional information about relationships to properly manage the memory. Before
    we look at the instances where ARC needs help, let's look at how memory management
    and ARC work.
  prefs: []
  type: TYPE_NORMAL
- en: Reference versus value types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at an example that illustrates how a reference type (instance of
    a class) and a value type (instance of a structure or a variable) are passed to
    a function. We will begin by defining a new class named `MyClass` and a new structure
    named `MyStruct`. The `MyClass` class and the `MyStruct` structure each contain
    one property named `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now create a function that will accept, as parameters, one instance
    of the `MyClass` class and one instance of the `MyStruct` struct. Within the function,
    we will change the value of the `name` property of both the `MyClass` class and
    the `MyStruct` structure. Then, by examining the value of that property once the
    function exits, we will be able to see how instances of a class and structure
    are passed to functions. Here is the code for the `showPass()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the `showPass()` function, we print the values of the named properties for
    both the `MyClass` and `MyStruct` instances to the console. We then change the
    values of the named properties and reprint the values to the console again. This
    will show us the value of the properties when the function first begins and the
    value after the properties were changed (just before the function exits).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to see how a reference type and a value type are passed to a function,
    we will create an instance of both the `MyClass` class and the `MyStruct` structure,
    set the values of the `name` properties, and pass those instances to the `showPass()`
    function. The function will then change the values of the `name` properties and
    then return control back to the code that calls it. Finally, we will examine the
    value of the name properties after the `showPass()` function exits to see whether
    they have their original value or the value set in the function. Here is the code
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output, the `showPass()` function receives the instance
    of the class and structure with the name properties set to `set in main - class`
    and `set in main - struct`, respectively. Next, just before the function exits
    we see, that the `name` property of the class is set to `Set in function - class`
    and the `name` property of the structure is set to `Set in function - struct`.
    Finally, when the function exits and we are back to the main part of the code,
    we see that the `name` property of the class is set to `Set in function - class`,
    which was set in the `showPass()` function. However, the `name` property of the
    structure has the value that was originally set prior to calling the function,
    `set in main - struct`.
  prefs: []
  type: TYPE_NORMAL
- en: This example illustrates that when we pass a reference type (instance of a class)
    to a function, we are passing a reference to the original class that means any
    changes we make are kept when the function exits. When we pass a value type (instance
    of a structure or a variable) to a function, we are passing the value (copy of
    the instance), which means any changes that we make are made to the local copy
    and are lost once the function exits.
  prefs: []
  type: TYPE_NORMAL
- en: The working of ARC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever we create a new instance of a class, ARC allocates the memory needed
    to store that class. This ensures that there is enough memory to store the information
    associated with that instance of the class, and also locks the memory so that
    nothing overwrites it. When the instance of the class is no longer needed, ARC
    will release the memory allocated for the class so that it can be used for other
    purposes. This ensures that we are not tying up memory that is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: If ARC were to release the memory for an instance of a class that we still needed,
    it would not be possible to retrieve the class information from memory. If we
    did try to access the instance of the class after the memory was released, there
    is a possibility that our application would crash. To ensure memory is not released
    for an instance of a class that is still needed, ARC counts how many times the
    instance is referenced (how many active properties, variables, or constants are
    pointing to the instance of the class). Once the reference count for an instance
    of a class equals zero (nothing is referencing the instance), the memory is released.
  prefs: []
  type: TYPE_NORMAL
- en: All of the previous examples run properly in a Playground, the following examples
    will not. When we run sample code in a Playground, ARC does not release objects
    that we create; this is by design so that we can see how the application runs
    and also the state of the objects at each step. Therefore, we will need to run
    these samples as an iOS or OS X project. Let's look at an example of how ARC works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating a `MyClass` class with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This class is very similar to our previous `MyClass` class, except that we add
    a deinitializer that is called just before an instance of the class is destroyed
    and removed from memory. This deinitializer prints out a message to the console
    that lets us know that the instance of the class is about to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code that shows how ARC creates and destroys instances
    of a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the example, we begin by creating two instances of the `MyClass` class named
    `class1ref1` (which stands for class 1 reference 1) and `class2ref1` (which stands
    for class 2 reference 1). We then create a second reference to `class2ref1` named
    `class2ref2`. Now, in order to see how ARC works, we need to begin setting the
    references to nil. We start out by setting the `class1ref1` to `nil`. Since there
    is only one reference to `class1ref1`, the deinitializer will be called. Once
    the deinitializer completes its task, in our case, it prints a message to the
    console letting us know that the instance of the class has been destroyed and
    the memory has been released.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the `class2ref1` to nil, but there is a second reference to this
    class (`class2ref2`) that prevents ARC from destroying the instance so that the
    deinitializer is not called. Finally, we set `class2ref2` to nil, which allows
    ARC to destroy this instance of the `MyClass` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we will see the following output, which illustrates how
    ARC works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: From the example, it seems that ARC handles memory management very well. However,
    it is possible to write code that will prevent ARC from working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Strong reference cycles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A strong reference cycle is where the instance of two classes holds a strong
    reference to each other, preventing ARC from releasing either instance. Strong
    reference cycles are a lot easier to understand with an example, so let''s create
    one. Once again, we are not able to use a Playground for this example, so we need
    to create an Xcode project. In the project, we start off by creating two classes
    named `MyClass1` and `MyClass2` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the code, `MyClass1` contains an instance of `MyClass2`;
    therefore, the instance of `MyClass2` cannot be released until `MyClass1` is destroyed.
    We can also see from the code that `MyClass2` contains an instance of `MyClass1`;
    therefore, the instance of `MyClass1` cannot be released until `MyClass2` is destroyed.
    This creates a cycle of dependency in which neither instance can be destroyed
    until the other one is destroyed. Let''s see how this works by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the comments in the example, the reference counters for each
    instance never reaches zero; therefore, ARC cannot destroy the instances, thereby
    creating a memory leak. A memory leak is where an application continues to use
    memory but does not properly release it. This can cause an application to eventually
    crash.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve a strong reference cycle, we need to prevent one of the classes from
    keeping a strong hold on the instance of the other class, thereby allowing ARC
    to destroy them both. Swift provides two ways of doing this by letting us define
    the properties as either a weak reference or an unowned reference.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a weak reference and an unowned reference is that the
    instance which a weak reference refers to can be nil, whereas the instance that
    an unowned reference is referring to cannot be nil. This means that when we use
    a weak reference, the property must be an optional property since it can be nil.
    Let's see how we would use unowned and weak references to resolve a strong reference
    cycle. Let's start by looking at the unowned reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by creating two more classes, `MyClass3` and `MyClass4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `MyClass4` class looks pretty similar to the `MyClass1` and `MyClass2` classes
    in the preceding example. What is different here is the `MyClass3` class. In the
    `MyClass3` class, we set the `class4` property to `unowned`, which means it cannot
    be nil and it does not keep a strong reference to the `MyClass4` instance that
    it is referring to. Since the `class4` property cannot be `nil`, we also need
    to set it when the class is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how we can initialize and deinitialize the instances of these
    classes with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create an instance of the `MyClass4` class and then
    use that instance to create an instance of the `MyClass3` class. We then set the
    `class3` property of the `MyClass4` instance to the `MyClass3` instance we just
    created. This creates a reference cycle of dependency between the two classes
    again, but this time, the `MyClass3` instance is not keeping a strong hold on
    the `MyClass4` instance, allowing ARC to release both instances when they are
    no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this code, we see the following output, showing that both the `MyClass3`
    and `MyClass4` instances are released and the memory is freed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at how we would use a weak reference to prevent a strong reference
    cycle. We begin by creating two new classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `MyClass5` and `MyClass6` classes look very similar to the `MyClass1` and
    `MyClass2` classes we created earlier to show how a strong reference cycle works.
    The big difference is that we define the `class5` property in the `MyClass6` class
    as a weak reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can initialize and deinitialize instances of these classes
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we create instances of the `MyClass5` and `MyClass6`
    classes and then set the properties of those classes to point to the instance
    of the other class. Once again, this creates a cycle of dependency, but since
    we set the `class5` property of the `MyClass6` class to weak, it does not create
    a strong reference, allowing both instances to be released.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the code, we will see the following output, showing that both the
    `MyClass5` and `MyClass6` instances are released and the memory is freed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that we avoid creating circular dependencies, as shown in
    this section, but there are times when we need them. For those times, remember
    that ARC does need some help to release them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this chapter ends, we end the introduction to the Swift programming language.
    At this point, we have enough knowledge of the Swift language to begin writing
    our own applications; however, there is still much to learn.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapters, we will look in more depth at some of the concepts
    that we already discussed, such as optionals and subscripts. We will also show
    how we would perform common tasks with Swift, such as parsing common file formats
    and handling concurrency. Finally, we will also have some chapters that will help
    us write better code like a sample Swift style guide, and a chapter on design
    patterns.
  prefs: []
  type: TYPE_NORMAL
