<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Dependency Management</h1></div></div></div><p>One of the most important features of any software is managing dependencies. As we know, no software works in isolation and we usually depend on third-party or open source libraries. The libraries are required during the compile and runtime execution and they have to be available in the classpath. Gradle has excellent support for dependency management. We just need to write few lines of code in the build file and Gradle internally does all the heavy lifting of managing configurations.</p><p>In this chapter, we will go into details of <a id="id214" class="indexterm"/>
<strong>dependency management</strong> of Gradle. We will discuss the different features such as how to manage project dependencies, resolving conflicts, and resolution strategies. We will also discuss how to publish artifacts in different repositories.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Overview</h1></div></div></div><p>Dependency management is one of the most the important features of any build tool. It helps to manage software dependencies in a better way. If you are using <a id="id215" class="indexterm"/>
<strong>Ant</strong>, which initially did not support any dependency management, you need to write the name of each and every dependent jar file and its location to <code class="literal">build.xml</code>. For small applications that do not have many <a id="id216" class="indexterm"/>dependencies, this approach might work well. However, for enterprise applications, where software depends on hundreds of other libraries, which internally can depend on some other libraries (transitive dependencies), this approach of configuring each and every jar file in your <code class="literal">build.xml</code> could work but it requires huge effort to maintain it. Also, managing their version conflicts would be really a big pain for any developer and could turn the build process into a nightmare. To resolve these drawbacks in Ant, Maven came with an internal dependency management solution. </p><p>Later, Ant also integrated with Apache Ivy (a dependency management solution) to provide the same feature. Gradle came with its own dependency management implementation. It helps to define first-level dependencies, logically group them into different configurations, define multiple repositories and also provide tasks to publish assets after the execution of the build file. It also supports Ivy, Maven, and flat file repositories. In this chapter, along with dependency management, we will also look into repositories configurations and asset publications, that is, how to configure different repositories and upload assets to repositories.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Dependency configurations</h1></div></div></div><p>Before starting with dependency configuration, let's discuss how to<a id="id217" class="indexterm"/> publish packaged software in Java. You package and publish either in <code class="literal">.jar</code> or <code class="literal">.war</code> or <code class="literal">.ear</code> file formats to a repository. The goal is to share these assets within the teams in an organization or with open source developers. Consider a scenario where you are publishing a utility project (<code class="literal">messageutil.jar</code>) to a repository. Although the publication process mostly depends on an organization's policy, the common practice is, all the assets that you plan to publish should be <strong>versioned</strong> and stored in a central repository, so that all other teams can share it. This versioning helps to track different versions of libraries. With versioned libraries, you can also revert to old versions in case of any functionality issues. Whenever you publish any asset to the repositories, always make sure it is versioned. To know more about versioning look at this link: <a class="ulink" href="http://semver.org/">http://semver.org/</a>.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Dependency types</h2></div></div></div><p>Other than internal or external JAR files, a project can also depend on:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The files located on the filesystem</li><li class="listitem" style="list-style-type: disc">Some other projects (in case of a multiproject build) in the same build</li><li class="listitem" style="list-style-type: disc">The Gradle API (for custom tasks and plugins)</li><li class="listitem" style="list-style-type: disc">The Groovy version used by Gradle (for custom tasks and plugins)</li></ul></div><p>We saw an example<a id="id218" class="indexterm"/> of the Gradle API and the Groovy version used in the previous chapters when we developed custom tasks and plugins. Project dependency will be discussed in <a class="link" href="ch06.html" title="Chapter 6. Working with Gradle">Chapter 6</a>, <em>Working with Gradle</em>. In this chapter, we will discuss other module dependencies on global and local repositories, and file dependencies on the local system.</p><p>We will start dependency management with a simple example. Consider you are building a project, <code class="literal">SampleProject</code>, which depends on a third-party library <code class="literal">log4j-1.2.16.jar</code>.</p><p>To build the project, you need this jar file at compile time. Gradle provides a very easy and systematic way to define dependencies of the project using the <a id="id219" class="indexterm"/>
<strong>dependencies</strong> closure in the following way:</p><div><pre class="programlisting">dependencies {
  &lt;configuration name&gt; &lt;dependencies&gt;
}</pre></div><p>Gradle groups dependencies to different configurations. If you apply <strong>Java Plugin</strong> to a project, it provides six different configurations, which <a id="id220" class="indexterm"/>are listed in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Names</p>
</th><th style="text-align: left" valign="bottom">
<p>Details</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">compile</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The dependencies mentioned here are added to the classpath during compilation of the source code (<code class="literal">src/main/java</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">runtime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The dependencies mentioned here are required at runtime during execution of the source code (<code class="literal">src/main/java</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">testCompile</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The dependencies mentioned here are added to the classpath during compilation of the test code (<code class="literal">src/main/test</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">testRuntime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The dependencies mentioned here are required at runtime during execution of the test code (<code class="literal">src/main/test</code>)</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">archives</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is used to tell the build file about the artifacts generated by the project</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">default</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This contains the artifacts and dependencies used at runtime</p>
</td></tr></tbody></table></div><p>To define the preceding<a id="id221" class="indexterm"/> dependencies, you need to pass the following details to Gradle's dependency manager:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JAR file group (or namespace)</li><li class="listitem" style="list-style-type: disc">JAR filename</li><li class="listitem" style="list-style-type: disc">JAR file version</li><li class="listitem" style="list-style-type: disc">classifier (in case JAR has classifier-like-specific JDK version)</li></ul></div><p>The dependencies can be defined in one of the following ways:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An individual dependency:<div><pre class="programlisting">compile group: 'log4j', name: 'log4j', version: '1.2.16'</pre></div></li><li class="listitem" style="list-style-type: disc">A Dependency as an Arraylist:<div><pre class="programlisting">compile 'log4j:log4j:1.2.16','junit:junit:4.10'</pre></div></li><li class="listitem" style="list-style-type: disc">A Dependency as a Configuration Closure:<div><pre class="programlisting">compile ('log4j:log4j:1.2.16') ) {
    // extra configurations
}</pre></div></li><li class="listitem" style="list-style-type: disc">A Dependency as a Configuration Closure with key-value format:<div><pre class="programlisting">compile (group:'log4j',name:'log4j',version:'1.2.16') {
    // extra configurations
}</pre></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>In case of a flat directory (local or remote filesystem), the dependency group name is not required.</p></div></div></li></ul></div><p>To configure project dependencies, you need to mention all the libraries in the <code class="literal">dependencies</code> closure. So the build file will look like this:</p><div><pre class="programlisting">apply plugin: 'java'
repositories {
  mavenCentral()
}
dependencies {
  compile group: 'log4j', name: 'log4j', version: '1.2.16'
}</pre></div><p>Do not get confused <a id="id222" class="indexterm"/>with the <code class="literal">repositories</code> closure we have added in the example. We will discuss about this in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Repositories</h2></div></div></div><p>The job is half done when we say dependencies are identified and defined. How Gradle will know where to get these dependencies from? Here comes the concept of <code class="literal">repositories</code>. Gradle provides the<a id="id223" class="indexterm"/> <code class="literal">repositories</code> closure to define repositories from where dependencies can be downloaded. You can configure any number of repositories and also any type of repositories in your project. For dependencies listed in the <code class="literal">dependencies</code> closure, Gradle searches repositories in sequential order. If it finds a library or a dependency in one of the repositories (if multiple repositories are configured), it skips searching other repositories. In the next section, we will learn how to configure different repositories.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Repositories configuration</h2></div></div></div><p>You can use the following<a id="id224" class="indexterm"/> methods to configure repositories. Gradle allows you to use more than one configuration in a build file.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Maven Central repository</strong>: This<a id="id225" class="indexterm"/> configuration is used to directly download your dependencies from the <a id="id226" class="indexterm"/><strong>Maven Central repository</strong>. You do not need to remember the repository URL. You can directly add <code class="literal">mavenCentral()</code> to the <code class="literal">repositories</code> closure as mentioned here:<div><pre class="programlisting">repositories {
  mavenCentral()
}</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Maven JCenter repository</strong>: Gradle<a id="id227" class="indexterm"/> also connects<a id="id228" class="indexterm"/> directly to the <code class="literal">jCenter</code> repository by using <code class="literal">jcenter()</code> inside the repositories.<div><pre class="programlisting">repositories {
  jcenter()
}</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Maven local Repository</strong>: There might be a scenario where the local Maven cache contains all the required dependencies<a id="id229" class="indexterm"/> and you do not want to connect to the Maven central repository. Instead, you will need to use jars from Maven's local<a id="id230" class="indexterm"/> cache. In this scenario, you<a id="id231" class="indexterm"/> can use <code class="literal">mavenLocal()</code> in the <code class="literal">repositories</code> closure. By default, Maven's local cache path would be <code class="literal">&lt;USER_HOME&gt;/.m2/repository</code>. If you want to change it to another location, you can configure the path in <code class="literal">settings.xml</code> under <code class="literal">&lt;USER_HOME&gt;/.m2</code> or <code class="literal">&lt;USER_HOME&gt;/.m2/conf</code>. Having this configuration makes it easy to build a "SNAPSHOT" version of another project locally and include that version.<div><pre class="programlisting">repositories {
  mavenLocal()
}</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Ivy repository</strong>: If you want to<a id="id232" class="indexterm"/> refer to the Ivy<a id="id233" class="indexterm"/> repository, you can define it as follows:<div><pre class="programlisting">repositories {
  ivy {
    url "http://&lt;ivyrepositorylocation&gt;"
    layout "ivy"  // valid values are maven, gradle, ivy
  }
}</pre></div><p>You can also define the custom layout for your Ivy repository. There is not an equivalent <code class="literal">ivyLocal()</code> because Ivy does not allow local publishing of artifacts such as Maven.</p></li><li class="listitem" style="list-style-type: disc"><strong>Organization repository</strong>: No matter how <a id="id234" class="indexterm"/>many open source repositories are there, you will always need <a id="id235" class="indexterm"/>a private repository for software development as you are the owner of this repository and changes can be tracked and managed better by private repositories. To use your organization's private repository, you can configure the <code class="literal">Repositories</code> location in the following format:<div><pre class="programlisting">repositories {
  maven {
    url "http://private.repository/path"
    credentials {
      username 'guest'
      password '123123'
    }
  }
  ivy { // For Ivy repositories
  url "http://private.repository/path"
  }
}</pre></div><p>If your private repository needs authentication, you can provide the credentials as well. You can add the credentials to <code class="literal">~/.gradle/gradle.properties </code>as well and use it from there, because it is not a good practice to add credentials directly to the build file.</p><p>For Maven's format repositories, there<a id="id236" class="indexterm"/> is always metadata attached with the jar as <code class="literal">pom.xml</code>. There might be a scenario in which POM file and JAR file are<a id="id237" class="indexterm"/> located at two different locations. In such cases, you can mention both locations as follows:</p><div><pre class="programlisting">repositories {
  maven {
    url "http://private.repository/pompath"
    artifactUrls "http://private.repository/jardir"
  }
}</pre></div><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If the URL mentioned earlier contains the JAR file, Gradle will download the JAR file from that location; otherwise, it will search in <code class="literal">artifactUrls</code>. You can mention more than one <code class="literal">artifactUrls</code>.</p></div></div></li><li class="listitem" style="list-style-type: disc"><strong>Flat directory repository</strong>: There <a id="id238" class="indexterm"/>might be a case when you refer a repository in the local filesystem (not the <code class="literal">mavenLocal()</code> location). This situation could arise when some other<a id="id239" class="indexterm"/> projects or teams are creating jars at a different location and publishing those jars to a central location. You want your<a id="id240" class="indexterm"/> project to refer to these local directories only for dependency. This can be achieved by using the following code:<div><pre class="programlisting">repositories {
  flatDir {
  dirs '/localfile/dir1', '/localfile/dir2'
  }
}</pre></div><p>This is not the recommended approach as this will result in inconsistencies. The recommended approach is to always use the private or global<a id="id241" class="indexterm"/> repository.</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Dependency resolution</h1></div></div></div><p>We have seen the standard way of defining dependency and repository, which can help you to quick start with the<a id="id242" class="indexterm"/> concepts. It's time for a deep dive, and understand how to customize the standard configuration, which can suit your specific requirements.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Transitive dependency</h2></div></div></div><p>Suppose your application depends on <code class="literal">commons-httpclient-3.1.jar</code>, which is a first-level dependency. However, this JAR again depends on the following other JARs, <code class="literal">commons-codec-1.2.jar</code> and <code class="literal">commons-logging-1.0.4.jar</code>.And if we try to find more details, <code class="literal">commons-logging jar</code> again depends on some other JARs.</p><p>Here, <code class="literal">commons-httpclient-3.1</code> is a first-level dependency; the two previously mentioned JARs are second-level<a id="id243" class="indexterm"/> dependencies, and so on. However, with Gradle, you do not need to manage all these levels of dependencies. Imagine the complexity, if you have to figure out and mention each level of dependency in the build file. This can be very tedious and time consuming. And it becomes more painful if you encounter some version conflicts.</p><p>With Gradle, you do not need to bother about any such dependency-related issues. Gradle provides complete automation for the dependency management. You just define the first-level dependency and Gradle will take care of all the transitive dependencies. By default, it will download all the transitive dependencies until the last level.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Exclude transitiveness</h2></div></div></div><p>For some scenarios, you might not<a id="id244" class="indexterm"/> want to depend on Gradle to fetch all transitive dependencies. Rather, you want to have complete control to download only the libraries that you have mentioned in the build file. To switch off a transitive feature, you can set the transitive flag <code class="literal">off</code> in the build file (<code class="literal">build_transitive.gradle</code>):</p><div><pre class="programlisting">apply plugin:'java'
repositories {
  mavenCentral()
}
dependencies {
  compile group:'commons-httpclient', name:'commons-httpclient', version:'3.1', transitive: false
}</pre></div><p>Clean the Gradle cache (<code class="literal">~/.gradle/caches</code>) and try to build the project again. This time it will download only one JAR that is <code class="literal">commons-httpclient-3.1.jar</code>:</p><div><pre class="programlisting">
<strong>$ gradle –b build_transitive.gradle build</strong>
<strong>…..</strong>
<strong>:compileJava</strong>
<strong>Download https://repo1.maven.org/maven2/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.pom</strong>
<strong>Download https://repo1.maven.org/maven2/commons-httpclient/commons-httpclient/3.1/commons-httpclient-3.1.jar</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>…….</strong>
</pre></div><p>This feature could<a id="id245" class="indexterm"/> be useful if you need some other version of second-level dependencies, or the second-level dependency is missing in the repository and you want to manually copy that.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Selective exclude</h2></div></div></div><p>There might be a scenario when you want to partially use transitive feature, that is, you do not want to stop Gradle from <a id="id246" class="indexterm"/>getting transitive dependencies, but you know it might result in a version conflict. So, you might want some specific jars to be excluded from the second or next-level of dependencies. To selectively exclude dependencies from the second-level onwards, you can use the following configuration:</p><div><pre class="programlisting">dependencies{
  compile('commons-httpclient:commons-httpclient:3.1') {
    exclude group:'commons-codec' // exclude by group
    // exclude group:'commons-codec',module:'commons-codec'
  }
}</pre></div><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>The exclude criteria requires group as the mandatory field, but the module can be optional.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Version conflicts</h2></div></div></div><p>Version conflict is a very<a id="id247" class="indexterm"/> common scenario in which the project depends on a specific JAR but of different versions. For example, your project depends on <code class="literal">commons-httpclient-3.1</code> JAR and <code class="literal">commons-codec-1.1</code> JAR. The <code class="literal">commons-httpclient-3.1</code> JAR has a transitive dependency on the <code class="literal">commons-codec-1.2</code> JAR. During the build process, Gradle will find the dependency on two different versions of the same JAR. Your build file (<code class="literal">build_versionconflict.gradle</code>) will look like this:</p><div><pre class="programlisting">apply plugin:'java'

repositories {
  mavenCentral()
}
dependencies {
  compile group:'commons-httpclient', name:'commons-httpclient', version:'3.1'
  compile group:'commons-codec',name:'commons-codec', version:'1.1'
}</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Issues due to version conflicts take a considerable amount of time even to get noticed.</p></div></div><p>Gradle supports different strategies to resolve the version conflicts scenarios, they are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Latest version</strong>: By default Gradle applies the<a id="id248" class="indexterm"/> <strong>get latest</strong> strategy to resolve version conflicts issues<a id="id249" class="indexterm"/> if it finds different versions of the same JAR file. In the preceding scenario, it will skip version 1.1 and download the <code class="literal">commons-codec</code> JAR of version 1.2.<p>After executing the <code class="literal">gradle –b build_versionconflict.gradle clean build</code> command, the output will be as follows:</p><div><pre class="programlisting">
<strong>Download https://repo1.maven.org/maven2/commons-codec/commons-codec/1.1/commons-codec-1.1.pom</strong>
<strong>Download https://repo1.maven.org/maven2/commons-codec/commons-codec/1.2/commons-codec-1.2.pom</strong>
<strong>......</strong>
<strong>Download https://repo1.maven.org/maven2/commons-codec/commons-codec/1.2/commons-codec-1.2.jar</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>......</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>fail on conflict</strong>: The Get latest strategy might not work always. Sometimes, rather than getting the<a id="id250" class="indexterm"/> latest version, you might want the build to fail for further investigation. To<a id="id251" class="indexterm"/> enable this, you apply the <code class="literal">failOnVersionConflict()</code> configuration by adding the following closure:<div><pre class="programlisting">configurations.all {
resolutionStrategy {
  failOnVersionConflict()
}
}</pre></div><p>You can update your build file with the preceding configuration. If you want this strategy for all the builds, you can add this to your <code class="literal">init</code> script.</p></li><li class="listitem" style="list-style-type: disc"><strong>Force specific version</strong>: In conflict situations, another alternative could be, rather than failing the <a id="id252" class="indexterm"/>build, you can download specific version of a JAR. This can be achieved by using <strong>force flag</strong>:<div><pre class="programlisting">dependencies {
  compile group:'commons-httpclient', name:'commons-httpclient', version:'3.1'
  compile group:'commons-codec',name:'commons-codec', version:'1.1', force:true
}</pre></div><p>Now, try to execute the <code class="literal">gradle -b build_versionconflict.gradle build</code> and observe the output:</p><div><pre class="programlisting">
<strong>Download https://repo1.maven.org/maven2/commons-codec/commons-codec/1.1/commons-codec-1.1.pom</strong>
<strong>Download https://repo1.maven.org/maven2/commons-codec/commons-codec/1.1/commons-codec-1.1.jar</strong>
<strong>:processResources UP-TO-DATE</strong>
<strong>:classes</strong>
<strong>….</strong>
<strong>BUILD SUCCESSFUL</strong>
</pre></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Dynamic dependency</h2></div></div></div><p>To make the build flexible on the jar version, you can use the <code class="literal">latest.integration</code> placeholder, or you can define a<a id="id253" class="indexterm"/> version range such as <code class="literal">1.+</code>. With this option, you do not have to stick to a specific version. With the <code class="literal">1.+</code> or <code class="literal">2.+</code> format, it will fix the major version to 1 or 2 (it could be any number) and it will pick the latest of the minor version (for example, 1.9 or 2.9).</p><div><pre class="programlisting">compile group:'commons-codec',name:'commons-codec', version: '1.+'
compile group:'commons-codec',name:'commons-codec', version: 'latest.integration'</pre></div><p>You can use either one to get the latest dependency.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Customizing the dependency</h1></div></div></div><p>Whenever Gradle searches for dependencies in the repository, first it searches for a module descriptor file (for example, <code class="literal">pom.xml</code> or <code class="literal">ivy.xml</code>). Gradle parses this file and downloads the actual JAR file and its dependencies mentioned in the module descriptor. There might be a <a id="id254" class="indexterm"/>case when a module descriptor file is not present. In this case, Gradle directly looks for the JAR file and downloads it.</p><p>Gradle enables you to play with your dependencies in different ways. Not only you can download other file formats such as ZIP and WAR, you can also mention different classifiers, if needed.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Download file other than JAR</h2></div></div></div><p>By default, Gradle downloads<a id="id255" class="indexterm"/> file with the <code class="literal">.jar</code> extension. Sometimes, you might need to download either a ZIP file or a WAR file, which does not have any module descriptor. In this scenario, you can explicitly mention the extension of the file:</p><div><pre class="programlisting">Dependencies {
  runtime group: 'org.mywar', name: 'sampleWeb', version: '1.0', <strong>ext: 'war'</strong>
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Dependency on files with classifiers</h2></div></div></div><p>Sometimes you<a id="id256" class="indexterm"/> release the artifacts with special notation (known as classifiers) such as <code class="literal">sampleWeb-1.0-dev.war</code> or <code class="literal">sampleWeb-1.0-qa.jar</code>. To download artifacts with classifiers, Gradle provides the <code class="literal">classifier</code><a id="id257" class="indexterm"/> tag:</p><div><pre class="programlisting">dependencies {
  runtime group: 'org.mywar', name: 'sampleWeb', version: '1.0', <strong>classifier</strong>: 'qa', ext:'war'
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Replacing transitive dependencies</h2></div></div></div><p>If you do not want to download the existing transitive dependencies and want to replace them<a id="id258" class="indexterm"/> with your customized transitive dependencies, Gradle provides the following way:</p><div><pre class="programlisting">dependencies {
  compile module(group:'commons-httpclient', name:'commons-httpclient', version:'3.1') {
    dependencies "commons-codec:commons-codec:1.1@jar"
  }
}</pre></div><p>Here we have used <code class="literal">@jar</code>, which can be used as a replacement for the <code class="literal">ext</code> tag that is used in the preceding example. This code snippet will not download the existing transitive dependencies of <code class="literal">commons-httpclient</code>, but it will download the JAR mentioned inside the curly braces.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Custom configuration for dependency</h2></div></div></div><p>When we apply the Java plugin, Gradle automatically gives you some default configurations such as compile and runtime. We can extend this feature and use our own configuration for dependencies. This is an excellent way to group dependencies only needed at build time to achieve particular tasks such as code generators (depending on a templating library), xjc, cxf wsdl to Java, and so on. We can group them under our user-defined configurations. Before using custom configurations under the dependency closure, we need to define it inside the configuration closure. The following is the code snippet of the <code class="literal">build_customconf.gradle</code> file:</p><div><pre class="programlisting">apply plugin: 'java'
version=1.0
configurations {
  customDep
}
repositories {
  mavenCentral()
}
dependencies {
  customDep group: 'junit', name: 'junit', version: '4.11'
  compile group: 'log4j', name: 'log4j', version: '1.2.16'
}

task showCustomDep &lt;&lt; {
  FileTree deps  = project.configurations.customDep.asFileTree
  deps.each {File file -&gt;
    println "File names are "+file.name
  }
}</pre></div><p>The following<a id="id259" class="indexterm"/> is the output of the preceding code:</p><div><pre class="programlisting">
<strong>$ gradle –b build_customconf.gradle showCustomDep</strong>
<strong>:showCustomDep</strong>
<strong>….</strong>
<strong>Download https://repo1.maven.org/maven2/junit/junit/4.11/junit-4.11.jar</strong>
<strong>Download https://repo1.maven.org/maven2/org/hamcrest/hamcrest-core/1.3/hamcrest-core-1.3.jar</strong>
<strong>File names are junit-4.11.jar</strong>
<strong>File names are hamcrest-core-1.3.jar</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Dependency reports</h2></div></div></div><p>Gradle provides a very convenient <a id="id260" class="indexterm"/>way to list out all of the project dependencies from the first level to the <em>n</em>th level. It includes all your <strong>transitive dependencies</strong>, including<a id="id261" class="indexterm"/> manually changed, overridden, and forced dependencies. The dependency tree groups dependencies by <a id="id262" class="indexterm"/>configurations such as compile, testCompile, and so on. The following is the code snippet from the <code class="literal">build_depreport.gradle</code> file:</p><div><pre class="programlisting">apply plugin: 'java'
version=1.0
repositories {
  mavenCentral()
}
dependencies {
  compile group: 'log4j', name: 'log4j', version: '1.2.16'
  compile 'commons-httpclient:commons-httpclient:3.1'
  compile 'dom4j:dom4j:1.6.1'
}</pre></div><div><pre class="programlisting">
<strong>$ gradle –b build_depreport.gradle dependencies</strong>
<strong>…</strong>
<strong>Root project</strong>
<strong>….</strong>

<strong>+--- log4j:log4j:1.2.16</strong>
<strong>+--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>|    +--- commons-logging:commons-logging:1.0.4</strong>
<strong>|    \--- commons-codec:commons-codec:1.2</strong>
<strong>\--- dom4j:dom4j:1.6.1</strong>
<strong>     \--- xml-apis:xml-apis:1.0.b2</strong>

<strong>default – Configuration for default artifacts.</strong>
<strong>+--- log4j:log4j:1.2.16</strong>
<strong>+--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>|    +--- commons-logging:commons-logging:1.0.4</strong>
<strong>|    \--- commons-codec:commons-codec:1.2</strong>
<strong>\--- dom4j:dom4j:1.6.1</strong>
<strong>     \--- xml-apis:xml-apis:1.0.b2</strong>

<strong>runtime – Runtime classpath for source set 'main'.</strong>
<strong>+--- log4j:log4j:1.2.16</strong>
<strong>+--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>|    +--- commons-logging:commons-logging:1.0.4</strong>
<strong>|    \--- commons-codec:commons-codec:1.2</strong>
<strong>\--- dom4j:dom4j:1.6.1</strong>
<strong>     \--- xml-apis:xml-apis:1.0.b2</strong>

<strong>testCompile – Compile classpath for source set 'test'.</strong>
<strong>+--- log4j:log4j:1.2.16</strong>
<strong>+--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>|    +--- commons-logging:commons-logging:1.0.4</strong>
<strong>|    \--- commons-codec:commons-codec:1.2</strong>
<strong>\--- dom4j:dom4j:1.6.1</strong>
<strong>     \--- xml-apis:xml-apis:1.0.b2</strong>

<strong>testRuntime – Runtime classpath for source set 'test'.</strong>
<strong>+--- log4j:log4j:1.2.16</strong>
<strong>+--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>|    +--- commons-logging:commons-logging:1.0.4</strong>
<strong>|    \--- commons-codec:commons-codec:1.2</strong>
<strong>\--- dom4j:dom4j:1.6.1</strong>
<strong>     \--- xml-apis:xml-apis:1.0.b2</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>It will show until the child level of all the dependencies for all configurations. You might be surprised to see why other configurations such as runtime and testRuntime are being displayed, though <a id="id263" class="indexterm"/>only compile configuration was defined. The following table <a id="id264" class="indexterm"/>shows the relationship between different configurations:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Dependency</p>
</th><th style="text-align: left" valign="bottom">
<p>Extends</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>compile</p>
</td><td style="text-align: left" valign="top">
<p>-</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>runtime</p>
</td><td style="text-align: left" valign="top">
<p>compile</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>testCompile</p>
</td><td style="text-align: left" valign="top">
<p>compile</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>testRuntime</p>
</td><td style="text-align: left" valign="top">
<p>runtime, testCompile</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>default</p>
</td><td style="text-align: left" valign="top">
<p>runtime</p>
</td></tr></tbody></table></div><p>If you want to list out dependencies for only one configuration, you can mention that using <code class="literal">–configuration &lt;configuration name&gt;</code>:</p><div><pre class="programlisting">
<strong>$ gradle –b build_depreport.gradle dependencies –configuration compile</strong>
<strong>:dependencies</strong>

<strong>Root project</strong>

<strong>compile – Compile classpath for source set 'main'.</strong>
<strong>+--- log4j:log4j:1.2.16</strong>
<strong>+--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>|    +--- commons-logging:commons-logging:1.0.4</strong>
<strong>|    \--- commons-codec:commons-codec:1.2</strong>
<strong>\--- dom4j:dom4j:1.6.1</strong>
<strong>     \--- xml-apis:xml-apis:1.0.b2</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec07"/>Dependency-specific details</h3></div></div></div><p>Sometimes you might get issues<a id="id265" class="indexterm"/> while downloading some transitive dependencies and you do not know which dependency is downloading that JAR file.</p><p>Suppose while executing the preceding <code class="literal">build_depreport.gradle</code> script, you are getting issues while fetching the <code class="literal">commons-logging</code> JAR file. It is not the first-level dependency and you do not know which first-level dependency is responsible for this. To get that detail, use the <code class="literal">dependencyInsight</code> command:</p><div><pre class="programlisting">
<strong>$ gradle –b build_depreport.gradle dependencyInsight –dependency commons-logging –configuration runtime</strong>
<strong>:dependencyInsight</strong>
<strong>commons-logging:commons-logging:1.0.4</strong>
<strong>\--- commons-httpclient:commons-httpclient:3.1</strong>
<strong>     \--- runtime</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>If you do not specify the <code class="literal">–configuration</code> option, it will apply the <code class="literal">compile</code> configuration by default. The other options are <code class="literal">runtime</code>, <code class="literal">testCompile</code>, and so on, as mentioned in the preceding example.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Publishing artifacts</h1></div></div></div><p>Until now, we have<a id="id266" class="indexterm"/> discussed a lot about dependencies. How we can define project dependencies, customize them, and configure repositories to download libraries. Now, let's try to build the artifacts (JAR, WAR, and so on) and publish it to <a id="id267" class="indexterm"/>
<strong>Artifact repositories</strong> (could be a local filesystem, remote location, or Maven repository) to make it available to all the other teams to share.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Default artifacts</h2></div></div></div><p>When we apply the Java plugin, Gradle adds some default configuration to the project such as compile, runtime, testCompile. The Java plugin also adds one more configuration <code class="literal">archive</code>, which is used to define the artifacts of your project. Gradle provides the default artifact with some of the plugins. For example, Java, Groovy plugin publishes JAR as a default artifact, <code class="literal">war plugin</code> publish WAR as a default artifact. This JAR can be uploaded or<a id="id268" class="indexterm"/> published to a repository using the <code class="literal">uploadArchives</code> task.</p><p>The following code snippet shows how to configure the repository to upload archives using the <code class="literal">build_uploadarchives.gradle</code> file:</p><div><pre class="programlisting">apply plugin: 'java'
version=1.0

repositories {
  mavenCentral()
}
dependencies {
  compile group: 'log4j', name: 'log4j', version: '1.2.16'
  compile 'commons-httpclient:commons-httpclient:3.1'
  compile 'dom4j:dom4j:1.6.1'
}
uploadArchives {
  repositories {
    maven {
      credentials {
        username "guest"
        password "guest"
      }
      url "http://private.maven.repo"
    }
    //flatDir {dirs "./temp1" }
  }
}</pre></div><p>Instead of the Maven repository, we can also use the flat directory as a repository. In the preceding example, replace<a id="id269" class="indexterm"/> the Maven closure with flatDir (<code class="literal">flatDir {dirs "./temp1" }</code>) configuration. Now, if you execute the <code class="literal">gradle uploadArchives</code> command, you will find the JAR file published in the <code class="literal">temp1</code> directory.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Custom artifacts</h2></div></div></div><p>For each configuration, Gradle provides <code class="literal">Upload&lt;configuration name&gt;</code>, by default, which assembles and uploads<a id="id270" class="indexterm"/> the artifacts in the specified configuration. The <code class="literal">UploadArchives</code> task provided by the Java plugin uploads the default artifact (<code class="literal">jar</code>) to the<a id="id271" class="indexterm"/> repository.</p><p>Sometimes, you might need to generate some additional artifacts with the JAR file such as  the ZIP and XML files. This can be done by archive task to define an artifact.</p><div><img src="img/B02000_05_01.jpg" alt="Custom artifacts"/><div><p>Figure 5.1</p></div></div><p>In the preceding figure, the <a id="id272" class="indexterm"/>
<strong>assemble</strong> task depends on the <a id="id273" class="indexterm"/>
<strong>jar</strong> task, which is nothing but the default artifact of your Java plugin project. You can configure additional artifacts using the <code class="literal">archives</code> configuration. The input to the archive configuration can be an artifact itself or a task <a id="id274" class="indexterm"/>which creates an artifact.</p><p>Let's take a look<a id="id275" class="indexterm"/> at the following two examples:</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec08"/>Generate additional XML file along with your JAR file</h3></div></div></div><p>In this example, we will generate <a id="id276" class="indexterm"/>additional XML file with the JAR file and upload it to the repository. The following is the content of the <code class="literal">CustomArtifact</code>/<code class="literal">build.gradle</code> file:</p><div><pre class="programlisting">apply plugin: 'java'
archivesBaseName="MySample" // to customize Jar Name
version=1.0
repositories {
  mavenCentral()
}
def confFile = file('configurations.xml') // artifact2
artifacts {
  archives confFile
}
uploadArchives {
repositories {
   flatDir {dirs "./tempRepo"}
}
}</pre></div><p>Here, we have added <code class="literal">configurations.xml</code> as a separate XML file to the archive so that we can upload the file, along with the the JAR file, to the repository.</p><p>After executing Gradle's <code class="literal">uploadArchives</code> command, you will find the following files in the <code class="literal">tempRepo</code> directory:</p><div><img src="img/B02000_05_02.jpg" alt="Generate additional XML file along with your JAR file"/><div><p>Figure 5.2</p></div></div><p>Gradle also<a id="id277" class="indexterm"/> generates checksum and a deployment descriptor (here, <code class="literal">ivy-1.0.xml</code>) along with the artifact.</p><p>In the following section, we will learn how to upload a ZIP file as an artifact.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Generate an additional ZIP file along with your JAR file</h3></div></div></div><p>If you want to upload an<a id="id278" class="indexterm"/> additional ZIP file along with the JAR file, then you can mention the additional archives in the <code class="literal">artifacts</code> closure. The following is the <code class="literal">CustomArtifact/build_zip.gradle</code> file:</p><div><pre class="programlisting">apply plugin: 'java'
archivesBaseName="MySample" // to customize Jar Name
version=1.0
repositories {
  mavenCentral()
}
task zipSrc(type: Zip) {
  from 'src'
}
artifacts {
  archives zipSrc
}
uploadArchives {
  repositories {
    flatDir {dirs "./temp1" }
  }
}</pre></div><p>After executing the <code class="literal">gradle -b build_zip.gradle uploadArchives</code> command, verify the files in the <code class="literal">temp1</code> directory:</p><div><img src="img/B02000_05_03.jpg" alt="Generate an additional ZIP file along with your JAR file"/><div><p>Figure 5.3</p></div></div><p>Here, an additional <code class="literal">MySample-1.0.zip</code> is generated with the JAR file. You may have noticed that we did not make any additional call to the <code class="literal">zipSrc</code> task, which is required to create<a id="id279" class="indexterm"/> the ZIP file. Gradle applies a declarative approach here. Whatever archives you have configured in the <code class="literal">artifacts</code> closure, Gradle will create those artifacts. Within this closure, you can assign different type of tasks, such as JAR, ZIP, TAR (<code class="literal">org.gradle.api.tasks.building.AbstractArchiveTask</code>), or any file to be archived.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Custom configuration</h2></div></div></div><p>In the same way as custom dependency, you can also define custom configurations for your artifacts. Consider the<a id="id280" class="indexterm"/> following example (<code class="literal">CustomArtifacts/build_customconf.gradle</code>):</p><div><pre class="programlisting">apply plugin: 'java'

archivesBaseName="MySampleZip" // to customize Jar Name
version=1.0
configurations {
  zipAsset
}
repositories {
  mavenCentral()
}
task zipSrc(type: Zip) {
  from 'src'
}
artifacts {
  zipAsset zipSrc
}
uploadZipAsset {
  repositories {
    flatDir {dirs "./temp1" }
  }
}</pre></div><p>Now, execute the <code class="literal">gradle –b build_customconf.gradle uploadZipAsset</code> command to create and upload files to the repository. In the example, we have defined a custom configuration <code class="literal">zipAsset</code>. We used that configuration inside the artifacts closure. As mentioned in<a id="id281" class="indexterm"/> the preceding example, Gradle automatically provides the <code class="literal">upload&lt;configname&gt;</code> task for each configuration. Thus, we have the <code class="literal">cuploadZipAsset</code> task available to upload the required ZIP file to the repository.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>The maven-publish plugins</h2></div></div></div><p>In the previous<a id="id282" class="indexterm"/> section, we discussed the Maven plugin and other repositories configuration. Here, we will discuss the new plugin (<code class="literal">maven-publish plugin</code>) introduced by Gradle.</p><p>To have more control <a id="id283" class="indexterm"/>over the publication process, Gradle provides the <code class="literal">'maven-publish'</code> plugin. With the help of the following examples, you will see how it can help us in publication using the <code class="literal">MavenPublish</code>/<code class="literal">build.gradle</code> file:</p><p>You can configure publications by using following closure:</p><div><pre class="programlisting">publishing {
  publications {
    customPublicationName(MavenPublication) {
      // Configure the publication here
    }
  }
}</pre></div><p>The following is the file <code class="literal">MavenPublish/build.gradle</code>.</p><div><pre class="programlisting">apply plugin: 'java'
apply plugin: 'maven-publish'

publishing {
  publications {
    mavenJava(MavenPublication) {
      from components.java
      groupId 'org.mygroup'
      artifactId 'MySampleProj'
      version '1.0'
    }
  }

}</pre></div><p>This plugin adds the following tasks:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">publish</code>: This publishes all the publications produced by this project</li><li class="listitem" style="list-style-type: disc"><code class="literal">publishToMavenLocal</code>: This publishes all the Maven publications produced by this project to the local Maven cache</li></ul></div><p>When you add the preceding mentioned <code class="literal">publications</code> closure inside <code class="literal">publishing</code>, it will add two additional tasks, <code class="literal">generatePomFileFor&lt;publicationName&gt;Publication</code> and <code class="literal">public&lt;publicationName&gt;PublicationToMavenLocal</code>. You can find additional tasks in task list as<a id="id284" class="indexterm"/> follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">generatePomFileForPluginPublication</code>: This generates the Maven POM file for publication 'plugin'</li><li class="listitem" style="list-style-type: disc"><code class="literal">publishPluginPublicationToMavenLocal</code>: This publishes Maven publication 'plugin' to the local Maven repository</li></ul></div><p>To publish the artifacts in the<a id="id285" class="indexterm"/> local Maven repository, execute the following command:</p><div><pre class="programlisting">
<strong>$ gradle –i publishToMavenLocal</strong>

<strong>:publishMavenJavaPublicationToMavenLocal</strong>
<strong>Executing task ': publishMavenJavaPublicationToMavenLocal' (up-to-date check took 0.001 secs) due to:</strong>
<strong>  Task has not declared any outputs.</strong>
<strong>Publishing to repository org.gradle.api.internal.artifacts.repositories.DefaultMavenLocalArtifactRepository_Decorated@4a454218</strong>
<strong>[INFO] Installing /Chapter5/sent/MavenPublish/build/libs/MavenPublish.jar to &lt;%USER_HOME&gt;/.m2/repository/org/mygroup/MySampleProj/1.0/MySampleProj-1.0.jar</strong>
<strong>: publishMavenJavaPublicationToMavenLocal (Thread[main,5,main]) completed. Took 1.079 secs.</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>If you browse the local Maven repository, you will also find that the POM file has the following content:</p><div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" 
&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.mygroup&lt;/groupId&gt;
  &lt;artifactId&gt;MySampleProj&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
&lt;/project&gt;</pre></div><p>By default, it produces the JAR file for the Java project. If you want to add additional artifact along with JAR, you can customize the preceding configuration by adding additional artifact<a id="id286" class="indexterm"/> declaration in the following format.</p><p>Here is the sample <a id="id287" class="indexterm"/>code for <code class="literal">MavenPublish/build_zip.gradle</code>:</p><div><pre class="programlisting">apply plugin: 'java'
apply plugin: 'maven-publish'

task zipSrc(type: Zip) {
  baseName = 'SampleSource'
  from 'src'
}

publishing {
  publications {
    mavenJava(MavenPublication) {
      from components.java
      groupId 'org.mygroup'
      artifactId 'MySampleProj'
      version '1.0'

      artifact zipSrc {
        classifier "sources"
      }
      // artifact can be &lt;Jar,Zip tasks which will generate jar,zip file&gt;

    }
  }
}</pre></div><div><pre class="programlisting">
<strong>$ gradle –b build_zip.gradle – i publishToMavenLocal</strong>
<strong>. . .</strong>
<strong>Publishing to repository org.gradle.api.internal.artifacts.repositories.DefaultMavenLocalArtifactRepository_Decorated@434d54de</strong>
<strong>[INFO] Installing /Chapter5/MavenPublish/build/libs/MavenPublish.jar to &lt;USER_HOME&gt;/.m2/repository/org/mygroup/MySampleProj/1.0/MySampleProj-1.0.jar</strong>
<strong>[INFO] Installing /Chapter5/MavenPublish/build/distributions/SampleSource-source-.zip to &lt;USER_HOME&gt; /.m2/repository/org/mygroup/MySampleProj/1.0/MySampleProj-1.0-source-.zip</strong>
<strong>:publishPluginPublicationToMavenLocal (Thread[main,5,main]) completed. Took 0.85 secs.</strong>
<strong>. . .</strong>

<strong>BUILD SUCCESSFUL</strong>
</pre></div><p>Now, in the local<a id="id288" class="indexterm"/> repository, along with the JAR file, you will also find an<a id="id289" class="indexterm"/> additional ZIP file.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Remember that for each additional artifact that you are publishing, you will need to mention a classifier. Gradle allows only one artifact without a classifier.</p></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Publishing to the local-hosted repository</h3></div></div></div><p>To publish artifacts to the local-hosted repository with help of the <code class="literal">maven-publish</code> plugin, we can use the<a id="id290" class="indexterm"/> same configuration, which we discussed in the Maven plugin. The repositories closure is exactly the same as before, but it has to be surrounded by a publishing closure. You can define the closure as follows:</p><div><pre class="programlisting">Publishing {
  repositories {
    maven {
      name "localRepo"
      url "http://local.maven.repo"
      credentials { // if required
        username  = 'username'
        password = 'password'
      }
    }
  }
}</pre></div><p>You can even publish to a local file repository by mentioning the URL <code class="literal">./localrepo</code>. Maven will automatically create a directory structure for you and you can find artifacts under <code class="literal">localrepo/&lt;group&gt;/&lt;version&gt;/artifact-&lt;version&gt;.jar</code>.</p><p>If you mention the name attribute in the <code class="literal">maven { ….}</code> closure, Gradle will automatically create a new task with the name <code class="literal">publishPluginPublicationTo&lt;name&gt;Repository</code>:</p><div><pre class="programlisting">publishing {
  repositories {
    maven {
      name "localRepo"
      url "./localrepo"
    }
  }
}</pre></div><p>Now, you will<a id="id291" class="indexterm"/> be able to use the <code class="literal">publishMavenJavaPublicationToLocalRepoRepository</code> task or simply the <code class="literal">publish</code> task to publish to the repository; such as <code class="literal">gradle -b build_localrepo.gradle publish</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Custom POM</h3></div></div></div><p>By default, Gradle generates the POM file for the artifact with default parameters. If you want to modify POM with additional details, you can utilize the <code class="literal">pom.withXml</code> closure. You can add any number<a id="id292" class="indexterm"/> of new nodes to the XML file and also update some of the existing details. Remember that <code class="literal">groupId</code>, <code class="literal">artifactId</code> and <code class="literal">version</code> are read only. You cannot modify these details. Consider the file <code class="literal">build_custompom.gradle</code>.</p><div><pre class="programlisting">apply plugin: 'java'
apply plugin: 'maven-publish'
publishing {
  publications {
    mavenCustom(MavenPublication) {
      from components.java
      groupId 'org.mygroup'
      artifactId 'MySampleProj'
      version '1.0'

    pom.withXml {
      def root = asNode()
      root.appendNode('name', 'Sample Project')
      root.appendNode('description', 'Adding Additional details')
      def devs = root.appendNode('developers')
      def dev = devs.appendNode('developer')
      dev.appendNode('name', 'DeveloperName')
      }
    }
  }
}</pre></div><p>Now, execute the <code class="literal">publishToMavenLocal</code> task and you will find <code class="literal">pom.xml</code> generated in the repository.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Summary</h1></div></div></div><p>This chapter covered details of dependency management provided by Gradle. We looked into dependency configuration, strategies involved in dependency resolution, and configuring transitive dependencies. We also learned different versions of conflict strategies provided by Gradle and how we can configure it to get the most out of it.</p><p>We also talked about repositories. We covered how you can use different repositories such as flat file, local <strong>Maven Repository</strong>, and remote repositories hosted on the HTTPS server. Finally, we discussed the publication of the project. With the help of different plugins, you can publish artifacts to a central location such as the local or remote <strong>Maven Repository</strong>. We also discussed how we can utilize the new maven-publish plugin and how to configure it, so that it fits into our own requirement.</p><p>In the next chapter, we will discuss few important plugins such as War and Scala. We'll also discuss other important concepts such as File management, Multi-Project, and Properties management.</p></div></body></html>