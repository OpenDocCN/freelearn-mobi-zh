<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Automatic Garage Door Opener" id="aid-1AT9A1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Automatic Garage Door Opener</h1></div></div></div><p>This project is about an emerging technology called <a id="id377" class="indexterm"/>
<span class="strong"><strong>iBeacon</strong></span> that is based on the Bluetooth BLE communication protocol. Basically, an iBeacon is a small device that continuously transmits a unique coded signal. An iOS device can detect iBeacon to determine whether it is more or less near an iBeacon and trigger actions.</p><div class="note" title="Note"><h3 class="title"><a id="tip46"/>Tip</h3><p>
<span class="strong"><strong>iBeacon is an Apple technology</strong></span>
</p><p>iBeacon is a technology that was invented by Apple, and the protocol has not been disclosed (if you can find any information on the Internet, Google is your friend). So, to work with iBeacon devices, you need an iOS device and the API provided by Apple.</p><p>There is another standard that is<a id="id378" class="indexterm"/> emerging and which can also work with Android devices—AltBeacon (for more information, visit <a class="ulink" href="http://bit.ly/1KsXD17">http://bit.ly/1KsXD17</a>). The<a id="id379" class="indexterm"/> AltBeacon site has a lot of useful information for iOS too.</p></div><p>We are going to use these technologies to open our garage door as soon as we get close enough to it. You may wonder what the difference is between this and a traditional garage remote control or the numerous remote control apps that are available for iOS devices. The main difference is that everything happens automatically (automagically?); you don't even need to touch your phone. Believe it or not, you don't even need the controller app running.</p><div class="note" title="Note"><h3 class="title"><a id="tip47"/>Tip</h3><p>
<span class="strong"><strong>Don't have a garage?</strong></span>
</p><p>This project can be used to open any kind of door, but you may need to adapt or change your lock to something that can be controlled by an electric signal. Alternatively, you can use this project to control internal/external lights. There's no chance of getting bored!</p></div><p>Let's get started by having a closer look at iBeacon.</p><div class="section" title="iBeacon – a technical overview"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>iBeacon – a technical overview</h1></div></div></div><p>An iBeacon is a small <a id="id380" class="indexterm"/>device that, leveraging the Bluetooth BLE, establishes a region around itself. Any iOS device that supports Bluetooth BLE can determine whether it has entered or exited the region and roughly estimate the distance from the iBeacon.</p><p>We can put an iBeacon close to each museum artwork and write an iOS application that shows artwork information as soon as a visitor gets close to it. This is a typical example of how iBeacon is used.</p><p>iBeacon is univocally identified by three values—a UUID (a 16 bytes universal identifier), major (2 bytes), and minor (2 bytes), which are constantly transmitted over the Bluetooth signal.</p><div class="note" title="Note"><h3 class="title"><a id="tip48"/>Tip</h3><p>
<span class="strong"><strong>All that you need to know </strong></span>
<a id="id381" class="indexterm"/>
<span class="strong"><strong>about iBeacon</strong></span>
</p><p>You can find all that you need to know at <a class="ulink" href="https://developer.apple.com/ibeacon/">https://developer.apple.com/ibeacon/</a> and <a class="ulink" href="https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf">https://developer.apple.com/ibeacon/Getting-Started-with-iBeacon.pdf</a>.</p></div><p>Referring to the next diagram, you can see that there is a region around the iBeacon (the iBeacon region). The iOS application that registers to this region (with the UUID, major, and minor of the iBeacon) receives an "entering" notification when the iOS device crosses this region's border and enters it, and an "exiting" notification when the iOS device crosses the region's border and exits it. </p><p>We will discuss the details of this in the following sections:</p><div class="mediaobject"><img src="../Images/image00213.jpeg" alt="iBeacon – a technical overview"/></div><p style="clear:both; height: 1em;"> </p><p>In open air, the iBeacon<a id="id382" class="indexterm"/> region is about 30 meters wide, but this size widely depends on the hardware design, configuration, obstacles, and the way of installation.</p><p>When inside the region, an iOS device can continuously monitor the distance from the iBeacon device. This distance is returned as Far, Near, or Immediate. Apple doesn't declare the actual size of these distances, most likely because they are really influenced by the iBeacon's transmitting power, obstacles between the iBeacon and the iOS device, the iOS device orientation, and other factors. Anyway, this information can be used to change the application's behavior with the distance from iBeacon.</p><div class="note" title="Note"><h3 class="title"><a id="tip49"/>Tip</h3><p>
<span class="strong"><strong>iBeacon distance calculation</strong></span>
</p><p>An iOS device can <a id="id383" class="indexterm"/>find out the signal strength of the iBeacon. It can calculate the distance from the iBeacon by using a formula that describes the signal attenuation with distance. Unfortunately, since an iBeacon signal has a lot of fluctuations and its propagation is influenced by a lot of factors, the formula gives a very poor estimation of the distance. Probabilistic techniques have to be used to get the estimation of the distance to use this value for practical applications. We cannot cover these techniques in this book.</p></div><p>An interesting<a id="id384" class="indexterm"/> feature of how the iBeacon notifications are handled by the iOS is that even if the application is not running, the entering and exiting notifications are received and they start the application. To save the iOS device power, the application is started just for a few seconds (for about 3 seconds) and then paused. Then, the application has to complete every operation in this short interval.</p><p>I have to point out that usually, an iOS app receives an entering notification almost as soon as it crosses the iBeacon region. Conversely, the exiting notification may be received even a few minutes after the region border is crossed.</p></div></div>
<div class="section" title="The garage door opener requirements and design constraints"><div class="titlepage" id="aid-1BRPS2"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>The garage door opener requirements and design constraints</h1></div></div></div><p>Knowing the <a id="id385" class="indexterm"/>capabilities of the iBeacon, it's not hard to imagine how a garage door opener may work. The iBeacon is installed just behind the <a id="id386" class="indexterm"/>garage door. An Arduino with the BLE board listens for commands from the iOS device and controls the garage door opener. An iOS app sends an "Open" command when entering into the iBeacon region and a "Close" command when exiting the iBeacon region. Very simple, isn't it?</p><p>Unfortunately, we have to face the potentially long delay when receiving an exiting notification. When driving a car, you can cover a great distance traveling away from your garage in a few minutes; an iOS device cannot connect to the Arduino in such a long time.</p><p>Moreover, after taking a look at the next picture, you may realize that the iBeacon region may also cover only a part of the house. We obviously don't want that walking around the house with the iOS device in our pockets, the garage door would open and close randomly. </p><div class="mediaobject"><img src="../Images/image00214.jpeg" alt="The garage door opener requirements and design constraints"/></div><p style="clear:both; height: 1em;"> </p><p>A simple solution could be adding as many iBeacons as needed across the house, all with the same UUID, major, and minor, in order to extend the iBeacon region.</p><p>However, this <a id="id387" class="indexterm"/>solution will be too expensive. We are going to <a id="id388" class="indexterm"/>use another power feature of the iOS to overcome these two issues—geofencing:</p><div class="mediaobject"><img src="../Images/image00215.jpeg" alt="The garage door opener requirements and design constraints"/></div><p style="clear:both; height: 1em;"> </p><p>We can <a id="id389" class="indexterm"/>register a geofencing region (using the latitude and longitude of the center and the radius) that covers our entire house. On crossing the geofencing region's border, we get a notification (or even better, two notifications—one when entering the region and the other when exiting).</p><p>You may <a id="id390" class="indexterm"/>wonder why we don't simply use only a geofencing region to open the garage door. The reason behind not doing this is that the geofencing notifications are not very precise. They may have a very long delay and may not work in all areas. By combining the two technologies, we get exactly what we want to achieve.</p><p>We eventually overcame all the design challenges that involve tracking the entering of the device in the iBeacon region and its exiting from the geofencing region. This is how the automatic garage door opener works:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's assume that we are outside both the regions. When we cross the geofencing region, nothing happens, because the app recognizes only the exiting notification.</li><li class="listitem">As soon as we cross the iBeacon region a few meters away from the garage, the iOS device gets a notification, and it sends an opening command to the Arduino board, which controls the door, thereby opening the door.</li><li class="listitem">The door is automatically closed after a short time. This allows us to park the car inside the garage.</li><li class="listitem">From now on, the <a id="id391" class="indexterm"/>action of crossing the iBeacon region is ignored. Then, in case we cross the iBeacon region while moving around the house, the garage will not be opened.</li><li class="listitem">When we <a id="id392" class="indexterm"/>leave, we eventually cross the geofencing region. This event again enables the receiving of the iBeacon entering notification. We are in the same state that was described in step 1.</li></ol><div style="height:10px; width: 1px"/></div><p>We can describe the behavior of the app by using the following state diagram (strictly speaking, it's a Mealy State Machine; for more information, visit <a class="ulink" href="http://bit.ly/1hmZs3V">http://bit.ly/1hmZs3V</a>):</p><div class="mediaobject"><img src="../Images/image00216.jpeg" alt="The garage door opener requirements and design constraints"/></div><p style="clear:both; height: 1em;"> </p><p>We obviously don't want anyone else to open our garage. So, each authorized user must identify themselves by using a PIN (personal identification number). Assigning a new PIN, you allow others to get access to your garage. You can revoke access just by removing the PIN from the authorization list.</p><p>Then, the app has to manage the PINs, and we need a master PIN, which is wired into the Arduino code. Only the person who knows the master PIN is authorized to manage PINs.</p><div class="note" title="Note"><h3 class="title"><a id="tip50"/>Tip</h3><p>
<span class="strong"><strong>A security warning!</strong></span>
</p><p>Even if the iOS app requires a PIN in order to open the garage door, the app is not completely secure since it doesn't provide any encryption mechanism. Anyone can access the PIN by using a Bluetooth protocol sniffer. It's not so easy, but it's possible. You have been warned! Making the communication secure could be a good chance to learn more about encryption and how to implement encryption using the little memory and little processing power available on Arduino.</p></div></div>
<div class="section" title="Hardware" id="aid-1CQAE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Hardware</h1></div></div></div><p>The main hardware <a id="id393" class="indexterm"/>component that we need is the iBeacon. We have used the <a id="id394" class="indexterm"/>one that is shown at <a class="ulink" href="http://redbear.net">http://redbear.net</a>. Many products are available on the market at almost any price. When choosing an iBeacon, make sure that it is compatible with the iBeacon Apple protocol, since there are products that are not.</p><div class="note" title="Note"><h3 class="title"><a id="tip51"/>Tip</h3><p>
<span class="strong"><strong>An iOS device as an iBeacon</strong></span>
</p><p>If you have two iOS devices, you can use one of them to act as an iBeacon that running via one of the apps that are available on the iTunes store. I have published my own app for this purpose, which can be found at <a class="ulink" href="http://apple.co/1hmZt80">http://apple.co/1hmZt80</a>.</p></div><p>Depending on the iBeacon enclosure, it can be mounted inside or outside the garage. It is better if it is placed at a higher position. Usually, the battery that powers the iBeacon should last for at least one year. Consider battery replacement anyway while positioning it.</p><div class="section" title="Additional electronic components"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Additional electronic components</h2></div></div></div><p>In this project, we <a id="id395" class="indexterm"/>will need the following additional components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A BJT transistor: P2N2222 (see the details in the text)</li><li class="listitem">An NMOSFET transistor BS170 (see the details in the text)</li><li class="listitem">A 10K resistor (see the details in the text)</li><li class="listitem">A 1.5K resistor (see the details in the text)</li><li class="listitem">A diode 1N4001 (see the details in the text)</li><li class="listitem">A relay: coil voltage 5 and contact current max 1A (see the details in the text)</li></ul></div></div><div class="section" title="Electronic circuit"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>Electronic circuit</h2></div></div></div><p>The following picture<a id="id396" class="indexterm"/> shows the electric diagram of the electronic circuit that we need for the project:</p><div class="mediaobject"><img src="../Images/image00217.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>Usually, the relay current is about 40 mA, which exceeds the maximum amount of current that Arduino can provide. There are relays that draw less current, but to avoid burning the Arduino, we can use a transistor to power the relay. When the relay is turned off, the energy stored in the coil is discharged against the transistor as reverse current, and this can damage the transistor. The diode (a flyback diode) shorts this current, protecting the transistor from damage.</p><p>The following diagram shows how to mount the circuit on a breadboard:</p><div class="mediaobject"><img src="../Images/image00218.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>A relay is an <a id="id397" class="indexterm"/>electromechanical device that drains current, and it is subject to faults. So, you can use a more reliable circuit by using N-MOSFET. This alternative circuit is shown in the following diagram:</p><div class="mediaobject"><img src="../Images/image00219.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>The following <a id="id398" class="indexterm"/>diagram shows how to mount the circuit on a breadboard:</p><div class="mediaobject"><img src="../Images/image00220.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>The R1 resistor <a id="id399" class="indexterm"/>pulls down the gate of the MOSFET. So, it turns off when the driving pin (7) is LOW and the pin is floating like that during the powering on phase of Arduino.</p><div class="note" title="Note"><h3 class="title"><a id="note13"/>Note</h3><p>You may need to adjust the value of R1 in the range of 1K to 1M in order to ensure that the MOSFET doesn't turn on when not expected to.</p></div><div class="note" title="Note"><h3 class="title"><a id="tip52"/>Tip</h3><p>
<span class="strong"><strong>RFduino instead of Arduino</strong></span>
</p><p>For this project, we can use RFduino <a id="id400" class="indexterm"/>instead of Arduino (for more information, visit <a class="ulink" href="http://www.rfduino.com">http://www.rfduino.com</a>). It is compatible with Arduino, and also includes the Bluetooth device and the related software stack. Moreover, it can act as an iBeacon at the same time. One device could cover all the hardware requirements for the project. It doesn't have the EEPROM that we are going to use to store PINs, but we can store them in flash. The original version of this project was on RFduino and was a commercial product. For this book, I chose to work with Arduino to avoid buying another piece of hardware and because RFduino requires a more complex code to use Bluetooth for receiving commands and acting as an iBeacon at the same time. You can try to build the project on RFduino yourself. This could be a good opportunity to learn more. Check out RFduino. It's an amazing product!</p></div></div></div>
<div class="section" title="Arduino code" id="aid-1DOR01"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Arduino code</h1></div></div></div><p>The full code of this <a id="id401" class="indexterm"/>project can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>.</p><p>For a better understanding of the explanations in the next paragraphs, open the downloaded code while reading them.</p><p>In this project, we are going to use EEPROM to store PINS. In fact, this memory doesn't lose its content when it's not powered.</p><p>To store a PIN, we use the first character to indicate whether it is used or not and the last five characters to store the actual PIN (which is exactly five characters long). PINs are stored sequentially in EEPROM, starting from address 0.</p><div class="section" title="Setup code"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>Setup code</h2></div></div></div><p>Please refer <a id="id402" class="indexterm"/>to the downloaded code. Since the setup code is quite simple, it doesn't require a detailed explanation.</p><p>The setup code is not much different from the setup code of other projects. Let's take a look at the EEPROM initialization instead:</p><div class="informalexample"><pre class="programlisting">void setup() {


  // EEPROM INITIALIZATION - FIRST TIME ONLY

  for (int i = 0; i &lt; 6*NUMBER_OF_PINS; i++)
    EEPROM[i] = 0;

  // Set the master PIN

  EEPROM[0] = 1;
  EEPROM[1] = '1';
  EEPROM[2] = '2';
  EEPROM[3] = '3';
  EEPROM[4] = '4';
  EEPROM[5] = '5';

…

}</pre></div><p>The <code class="literal">for</code> loop initializes the EEPROM locations that are used to initialize PINs to 0. This loop has to be executed only the first time the code is executed, otherwise, it clears the stored PINS. In the <span class="emphasis"><em>Testing and tuning</em></span> section, we will provide more details on this.</p><p>The last few lines <a id="id403" class="indexterm"/>write the master PIN from location 1 (the master PIN is 12345 in the example). The location 0 is set to 1 to indicate that the next five locations are used to store a PIN.</p></div><div class="section" title="Main program"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>Main program</h2></div></div></div><p>The loop function is <a id="id404" class="indexterm"/>very easy. It only checks whether the door has been opened, and after this, <code class="literal">CLOSING_DOOR_INTERVAL</code> closes it by calling the <code class="literal">pulseOutput</code> function that pulses the relay for 300 ms.</p><p>The rest of the Arduino code is used to react to the messages that are received in the <code class="literal">rxCallback</code> function.</p><p>Each message is made up of a PIN (five characters) followed by a few other characters. The PIN is checked, and if it's not recognized, the message is rejected.</p><p>The main message is used to open the garage door: &lt;PIN&gt;O=1, where &lt;PIN&gt; is the 5 characters long PIN assigned to the user who is opening the door. When it's received, it pulses the relay and opens the door.</p><p>All the other messages, which are as follows, are related to PIN management:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">P</code>, when the iOS device requests the list of the current PINs stored in the Arduino EEPROM.</li><li class="listitem"><code class="literal">A</code>, when the iOS device needs to add a new PIN. The next 5 bytes after the command are the actual PIN.</li><li class="listitem"><code class="literal">E</code>, when the iOS device needs to update an existing PIN. The first byte after the command is the index of the PIN that needs to be edited, which is followed by 5 bytes of the new PIN.</li><li class="listitem"><code class="literal">D</code>, when the iOS device needs to delete an existing PIN. The first byte after the command is the index of the PIN that needs to be deleted.</li></ul></div><p>The functions, which implement each command, don't require much explanation. Note that the master PIN (PIN at the location 0 in EEPROM) is never transferred to the iOS application. To change the master PIN, it has to be changed directly in the code. The <code class="literal">printPins</code> function that dumps all the stored PINs can help you understand how the functions work. Comment out the calls that are already in the code.</p></div></div>
<div class="section" title="iOS code"><div class="titlepage" id="aid-1ENBI2"><div><div><h1 class="title"><a id="ch06lvl1sec44"/>iOS code</h1></div></div></div><p>In this chapter, we <a id="id405" class="indexterm"/>are going to look at the iOS application that monitors the iBeacon region and the geofencing region and sends a command to open the door. The same application manages the PINs that can be assigned to relatives, guests, and friends in order to open your garage.</p><p>The application can also be used to open the garage door manually like a traditional remote control.</p><p>The full code of this project can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>.</p><p>To understand better the explanations in the next paragraphs, open the downloaded code while reading.</p><div class="section" title="Creating the Xcode project"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Creating the Xcode project</h2></div></div></div><p>We will create a <a id="id406" class="indexterm"/>new project as we have done in the previous chapters. The following are the steps that you need to perform:</p><p>The following are the parameters for the new project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Project Type</strong></span>: Tabbed application</li><li class="listitem"><span class="strong"><strong>Product Name</strong></span>: GarageiBeacon</li><li class="listitem"><span class="strong"><strong>Language</strong></span>: Objective-C</li><li class="listitem"><span class="strong"><strong>Devices</strong></span>: Universal</li></ul></div><p>We have to set a capability for this project, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the project in the left pane of Xcode.</li><li class="listitem">Select <span class="strong"><strong>Capabilities</strong></span> in the right pane.</li><li class="listitem">Turn on the <span class="strong"><strong>Background Modes</strong></span> option and select <span class="strong"><strong>Location updates </strong></span>(see the following screenshot):<div class="mediaobject"><img src="../Images/image00221.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div><p>Once more, since <a id="id407" class="indexterm"/>the structure of this project is very close to the Pet Door Locker, we can reuse a part of the user interface and code by following these steps (for more details, go back to the iOS guided rover project in <a class="link" title="Chapter 4. iOS Guided Rover" href="part0033.xhtml#aid-VF2I1">Chapter 4</a>, <span class="emphasis"><em>iOS Guided Rover</em></span>, where we did almost the same thing as this):</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select <span class="strong"><strong>FirstViewController.h</strong></span> and <span class="strong"><strong>FirstViewController.m</strong></span>, right-click on them, click on <span class="strong"><strong>Delete</strong></span>, and select <span class="strong"><strong>Move to Trash</strong></span>.</li><li class="listitem">Using the same procedure, delete <span class="strong"><strong>SecondViewController</strong></span> and <span class="strong"><strong>Main.storyboard</strong></span>.</li><li class="listitem">Open the <span class="strong"><strong>PetDoorLocker</strong></span> project in Xcode.</li><li class="listitem">Select the following files and drag and drop them to this project:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>BLEConnectionViewController.h</strong></span></li><li class="listitem"><span class="strong"><strong>BLEConnectionViewController.m</strong></span></li><li class="listitem"><span class="strong"><strong>Main.storyboard</strong></span></li></ul></div><p>Ensure that <span class="strong"><strong>Copy items if needed</strong></span> is selected and then click on <span class="strong"><strong>Finish</strong></span>.</p></li><li class="listitem">Copy the icon that was used for the BLEConnectionViewController view controller.</li><li class="listitem">Create a <a id="id408" class="indexterm"/>new View Controller class called <code class="literal">GarageViewController</code>.</li><li class="listitem">Open the <span class="strong"><strong>Main.storyboard</strong></span> and locate the main View Controller.</li><li class="listitem">Delete all the graphical components.</li><li class="listitem">Open the <span class="strong"><strong>Identity Inspector</strong></span> and change the <span class="strong"><strong>Class</strong></span> to <span class="strong"><strong>GarageViewController</strong></span>.</li><li class="listitem">In order to make location properly ask for authorization, we need to add a new file. Do this by navigating to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span> | <span class="strong"><strong>File…</strong></span> and then select <span class="strong"><strong>iOS - Resource</strong></span> and <span class="strong"><strong>Strings File</strong></span>. Click on <span class="strong"><strong>Next</strong></span> and enter the name of the file, <code class="literal">InfoPlist</code>. Finally, click on <span class="strong"><strong>Create</strong></span>.</li><li class="listitem">Open the newly created file and enter the following line:<div class="informalexample"><pre class="programlisting">NSLocationAlwaysUsageDescription = "This is required in order to make Garage iBeacon working properly.";</pre></div></li></ol><div style="height:10px; width: 1px"/></div><p>Now, we are ready to create the new application!</p></div><div class="section" title="Designing the user interface for BLEConnectionViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Designing the user interface for BLEConnectionViewController</h2></div></div></div><p>We have to add <a id="id409" class="indexterm"/>many components to this view controller to add our personal PIN and information related to the geofencing region.</p><p>By now, you should be a master in adding UIKit components and the related Layout Constraints. So, we won't spend much time on this subject. Your final result should look similar to the one in the following picture. Anyway, you can always refer to the downloaded code, in case you need to:</p><div class="mediaobject"><img src="../Images/image00222.jpeg" alt="Designing the user interface for BLEConnectionViewController"/></div><p style="clear:both; height: 1em;"> </p><p>We also need to<a id="id410" class="indexterm"/> set the delegate outlet of the <span class="strong"><strong>PIN</strong></span> text field to the BLEConnectionViewController in order to know when it changes. You can do this by using the Connection Inspector.</p><p>For the PIN text field, we need to mask the values that will be entered. To do this, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Select the field.</li><li class="listitem">Open the Attributes Inspector.</li><li class="listitem">Select the <span class="strong"><strong>Secure Text Entry</strong></span> checkbox.</li></ol><div style="height:10px; width: 1px"/></div><p>Linking the new components to the code, you should end up with the following:</p><div class="informalexample"><pre class="programlisting">@interface BLEConnectionViewController ()

@property (strong, nonatomic) IBOutlet UILabel      *deviceUUIDLabel;

@property (strong, nonatomic) IBOutlet UITextField *pinField;
@property (strong, nonatomic) IBOutlet UITextField *longitudeField;
@property (strong, nonatomic) IBOutlet UITextField *latitudeField;
@property (strong, nonatomic) IBOutlet UISegmentedControl   *houseRegionSizeSegment;

@property (strong, nonatomic) CBCentralManager      *centralManager;
@property (strong, nonatomic) NSTimer               *scanningTimer;

@end</pre></div><p>The <span class="strong"><strong>Set House Position</strong></span> button <a id="id411" class="indexterm"/>will be used to set the center of the geofencing region around the house, and the <span class="strong"><strong>House Region Size</strong></span> segment will be used to set the radius of the geofencing region itself.</p><p>The button is connected to the method, as follows:</p><div class="informalexample"><pre class="programlisting">- (IBAction)startLocating:(id)sender {
    
}</pre></div><p>The segment is connected to the following:</p><div class="informalexample"><pre class="programlisting">- (IBAction)regionSizeChanged:(UISegmentedControl *)sender {
    
}</pre></div></div><div class="section" title="Designing the user interface for GarageViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Designing the user interface for GarageViewController</h2></div></div></div><p>This view <a id="id412" class="indexterm"/>controller is the main view controller of the application, and it should contain the button to manually open/close the garage door, just in case!</p><p>Since this is a learning project, we added some components to give the user a lot more information about their position with respect to the iBeacon and geofencing regions.</p><p>The GUI should look like the following screenshot:</p><div class="mediaobject"><img src="../Images/image00223.jpeg" alt="Designing the user interface for GarageViewController"/></div><p style="clear:both; height: 1em;"> </p><p>This time, the<a id="id413" class="indexterm"/> two buttons have a background (you can copy it from the downloaded code; it is named <code class="literal">buttonBackground.png</code>). To add it, select the button, open the <span class="strong"><strong>Attribute Inspector</strong></span>, and select <span class="strong"><strong>buttonBackground.png</strong></span> for the <span class="strong"><strong>Background</strong></span> (see the following screenshot):</p><div class="mediaobject"><img src="../Images/image00224.jpeg" alt="Designing the user interface for GarageViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Don't forget to change the <span class="strong"><strong>Text Color</strong></span> to white.</p><p>You can also <a id="id414" class="indexterm"/>copy the images for the three LEDs (<code class="literal">blueLED.png</code> and <code class="literal">grayLED.png</code>) from the downloaded project.</p><p>Once you have linked the GUI components to the code, you should end up with the following:</p><div class="informalexample"><pre class="programlisting">@interface GarageViewController ()

@property (strong, nonatomic) IBOutlet UIImageView  *houseRegionIndicator;
@property (strong, nonatomic) IBOutlet UIImageView  *garageRegionIndicator;
@property (strong, nonatomic) IBOutlet UIImageView *readyToOpenIndicator;

@end</pre></div><p>Moreover, the two buttons are linked to the two methods respectively, as follows:</p><div class="informalexample"><pre class="programlisting">- (IBAction)manualOperation:(UIButton *)sender {
}</pre></div><p>and:</p><div class="informalexample"><pre class="programlisting">- (IBAction)simulateHomeRegionExit:(UIButton *)sender {
}</pre></div></div><div class="section" title="Designing the user interface for PinsViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Designing the user interface for PinsViewController</h2></div></div></div><p>We need another <a id="id415" class="indexterm"/>view controller to manage the PINs. Create and link it to the main view controller like we did in the previous projects and embed it into a Navigation Controller. To do this, select the new view controller and navigate to <span class="strong"><strong>Editor</strong></span> | <span class="strong"><strong>Embed In Navigation Controller</strong></span>. This creates a Navigation Bar, where we can drop a button for adding the PINs (see the circled area in the following screenshot).</p><p>The GUI components are shown in the following screenshot. Basically, they are a Table View to show the enabled PINs and a field where one can enter the Master PIN. Only the person who knows the Master PIN can manage the other pins:</p><div class="mediaobject"><img src="../Images/image00225.jpeg" alt="Designing the user interface for PinsViewController"/></div><p style="clear:both; height: 1em;"> </p><p>Before moving on to the next section, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new class named PinsViewController that is inherited from UIViewController.</li><li class="listitem">Select the PinsViewController in the storyboard, open the Identity Inspector, and select PinsViewController for <span class="strong"><strong>Class</strong></span>.</li><li class="listitem">Open the Connections Inspector (browse <span class="strong"><strong>View</strong></span> | <span class="strong"><strong>Utilities</strong></span> | <span class="strong"><strong>Show Connections Inspector</strong></span>).</li><li class="listitem">Select the Table View,  drag the dataSource, and delegate outlets to the PinsViewController class (see the following screenshot). This tells the Table View to ask for items to show and inform about the events in the PinsViewController:<div class="mediaobject"><img src="../Images/image00226.jpeg" alt="Designing the user interface for PinsViewController"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Set the <a id="id416" class="indexterm"/>delegate outlet of the master PIN field to the view controller.</li><li class="listitem">Set the <span class="strong"><strong>Secure Text Entry</strong></span> checkbox for the master PIN.</li><li class="listitem">Linking the GUI components with the code, you should end up with the following:<div class="informalexample"><pre class="programlisting">@interface PinsViewController ()

@property (strong, nonatomic) IBOutlet UITableView *tableView;
@property (strong, nonatomic) IBOutlet UITextField *pinField;

@end</pre></div><p>and with the method:</p><div class="informalexample"><pre class="programlisting">- (IBAction)addPin:(id)sender {
}</pre></div></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="Writing code for BLEConnectionViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>Writing code for BLEConnectionViewController</h2></div></div></div><p>Since we copied this <a id="id417" class="indexterm"/>View Controller from the Pet Door Locker project, we need to make only a few changes.</p><p>First, we need to open the <span class="strong"><strong>BLEConnectionViewController.h</strong></span> file and add the following import:</p><div class="informalexample"><pre class="programlisting">#import &lt;CoreLocation/CoreLocation.h&gt;</pre></div><p>We also need to make a change to the following lines:</p><div class="informalexample"><pre class="programlisting">@interface BLEConnectionViewController : UIViewController &lt; CBCentralManagerDelegate&gt;


@end</pre></div><p>Change the preceding lines to the following:</p><div class="informalexample"><pre class="programlisting">@interface BLEConnectionViewController : UIViewController &lt;CLLocationManagerDelegate, CBCentralManagerDelegate&gt;


@end</pre></div><p>Then, open the <code class="literal">BLEConnectionViewController.m</code> to make the rest of the changes. Let's add a new property, as follows:</p><div class="informalexample"><pre class="programlisting">@property (strong, nonatomic) CLLocationManager     *locationManager;</pre></div><p>The location manager allows us to get the geographical coordinates (through the GPS receiver of our iOS device) of our house. This will be used to create the geofencing region.</p><p>To initialize the location manager, we have to change the <code class="literal">viewDidAppear</code> method to the following:</p><div class="informalexample"><pre class="programlisting">-(void)viewDidAppear:(BOOL)animated {
    
     [super viewDidAppear:animated];

    _locationManager = [[CLLocationManager alloc] init];
[_locationManager requestAlwaysAuthorization];

    _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
}</pre></div><p>The location manager has to be authorized by the user to work. For this reason, we need to issue the following method call:</p><div class="informalexample"><pre class="programlisting">[_locationManager requestAlwaysAuthorization];</pre></div><p>Calling this method, the iOS starts an authorization request to the user that contains the message we added to the InfoPlist file we created in the previous section. The code that<a id="id418" class="indexterm"/> is needed to start receiving the position of your own house is as follows:</p><div class="informalexample"><pre class="programlisting">- (IBAction)startLocating:(id)sender {
    
    _locationManager.delegate = self;
    _locationManager.distanceFilter = kCLDistanceFilterNone;
    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;
    [_locationManager startUpdatingLocation];
}</pre></div><p>The code doesn't require any explanation.</p><p>Once the GPS receiver has located the position, the following method is called, and we can store the longitude and latitude of the house:</p><div class="informalexample"><pre class="programlisting">- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations {

    [manager stopUpdatingLocation];
    CLLocation *currentLocation = [locations objectAtIndex:0];
    
    _latitudeField.text = [NSString stringWithFormat:@"%f",currentLocation.coordinate.latitude];
    _longitudeField.text = [NSString stringWithFormat:@"%f",currentLocation.coordinate.longitude];
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    
    [userDefaults setObject:[NSNumber numberWithFloat:currentLocation.coordinate.latitude] forKey:@"HouseLatitude"];
    [userDefaults setObject:[NSNumber numberWithFloat:currentLocation.coordinate.longitude] forKey:@"HouseLongitude"];
    [userDefaults synchronize];
    
    sleep(2);  // To be sure that monitoring of region started - To avoid kCLErrorDomain error 5 
}</pre></div><p>Please note that once the coordinates are available, we stop the location manager to update them (<code class="literal">[manager stopUpdatingLocation]</code>). We do this to save batteries and because we do not check the coordinates anymore to know whether we are inside or outside the region around the house. See the following sections to understand how we get this information.</p><p>When we change the size of the geofencing region, the following method is called:</p><div class="informalexample"><pre class="programlisting">- (IBAction)regionSizeChanged:(UISegmentedControl *)sender {
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    
    [userDefaults setObject:[NSNumber numberWithFloat:sender.selectedSegmentIndex+1] forKey:@"HouseSize"];
    [userDefaults synchronize];
}</pre></div><p>This is where <a id="id419" class="indexterm"/>we store the size of the region itself.</p><p>The last method that we need to write is used to store the personal PIN once it is modified:</p><div class="informalexample"><pre class="programlisting">- (BOOL)textFieldShouldReturn:(UITextField *)textField {
    
    [textField resignFirstResponder];
    
    NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
    
    [userDefaults setObject:textField.text forKey:@"GarageiBeaconPIN"];
    [userDefaults synchronize];
    
    return YES;
}</pre></div><p>To initialize the values of the text fields when the view controller is started, change the <code class="literal">viewDidLoad</code> method to the following:</p><div class="informalexample"><pre class="programlisting">- (void)viewDidLoad {
    
    [super viewDidLoad];
    
    _deviceUUIDLabel.text = [[NSUserDefaults standardUserDefaults] objectForKey:@"GarageiBeaconDevice"];
    _pinField.text = [[NSUserDefaults standardUserDefaults] objectForKey:@"GarageiBeaconPIN"];
        
    _latitudeField.text = [[[NSUserDefaults standardUserDefaults] objectForKey:@"HouseLatitude"] stringValue];
    _longitudeField.text = [[[NSUserDefaults standardUserDefaults] objectForKey:@"HouseLongitude"] stringValue];
}</pre></div><p>When the view<a id="id420" class="indexterm"/> controller is not shown on the screen, we can free both the location manager and the central manager, as follows:</p><div class="informalexample"><pre class="programlisting">-(void)viewDidDisappear:(BOOL)animated {
    [super viewDidDisappear:animated];

    _centralManager = nil;
    _locationManager = nil;
}</pre></div><p>Now, we are ready to work on the GarageViewController, which is much more interesting.</p></div><div class="section" title="Writing code for GarageViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>Writing code for GarageViewController</h2></div></div></div><p>Since we use both the <a id="id421" class="indexterm"/>location manager and the central manager, we need to update <span class="strong"><strong>GarageViewController.h</strong></span> with the required includes and protocols ending with:</p><div class="informalexample"><pre class="programlisting">#import &lt;CoreLocation/CoreLocation.h&gt;
#import &lt;CoreBluetooth/CoreBluetooth.h&gt;


@interface GarageViewController : UIViewController &lt;CLLocationManagerDelegate, CBCentralManagerDelegate, CBPeripheralDelegate&gt;


@end</pre></div><p>Then, we open the <span class="strong"><strong>GarageViewController.m</strong></span> to add the code to manage the notifications from the geofencing regions and the iBeacon region, and to send an opening message to the Arduino.</p><p>Add the following properties:</p><div class="informalexample"><pre class="programlisting">@property (nonatomic,strong) CLLocationManager      *locationManager;
@property (nonatomic,strong) CBCentralManager       *centralManager;

@property (strong, nonatomic) CBPeripheral          *arduinoDevice;
@property (strong, nonatomic) CBCharacteristic      *sendCharacteristic;

@property                     BOOL                  insideHouse;</pre></div><p>Then, we can add the code used to manage the Bluetooth communication with Arduino. This code is almost <a id="id422" class="indexterm"/>the same as what we used in the previous chapters. So, we don't have to spend much time on it. We just point out the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Since we don't receive any data from Arduino via Bluetooth, the <code class="literal">didUpdateValueForCharacteristic</code> function can be removed, and we don't need to look for the characteristic that was used to receive data</li><li class="listitem">Once the application gets connected to Arduino, it immediately sends the opening command</li></ul></div><p>The <code class="literal">didDiscoverCharacteristicsForService</code> method is slightly different from what we used in the other projects:</p><div class="informalexample"><pre class="programlisting">- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error {
    
    if (error) {
        
        NSLog(@"Error %@",[error localizedDescription]);
        
        return;
    }
    
    for (CBService *service in peripheral.services) {
        
        if ([service.UUID.UUIDString isEqualToString:NRF8001BB_SERVICE_UUID]) {
            
            for (CBCharacteristic *characteristic in service.characteristics) {
                
                if ([characteristic.UUID.UUIDString isEqualToString:NRF8001BB_CHAR_TX_UUID]) {
                    
                    _sendCharacteristic = characteristic;
                    
                    // Device connected - Sending opening command
                    
                    NSData      *data;
                    NSString    *msg;
                    
                    msg = [[NSString alloc] initWithFormat:@"%@O=1",[[NSUserDefaults standardUserDefaults] objectForKey:@"GarageiBeaconPIN"]];
                    data=[msg dataUsingEncoding:NSUTF8StringEncoding];
                    
                    [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
                    
                    // Disconnects
                    
                    [_centralManager cancelPeripheralConnection:_arduinoDevice];
                }
            }
        }
    }
}</pre></div><p>Once the <a id="id423" class="indexterm"/>view controller is started, we have to initialize the location manager and create the geofencing region and iBeacon region, if they are not yet created:</p><div class="informalexample"><pre class="programlisting">- (void)viewDidLoad {
    
    [super viewDidLoad];

    _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
    
    _locationManager = [[CLLocationManager alloc] init];
    _locationManager.delegate = self;
    
    _locationManager.desiredAccuracy = kCLLocationAccuracyBest;
    _locationManager.distanceFilter = kCLDistanceFilterNone;
    _locationManager.activityType = CLActivityTypeOther;
    
    [_locationManager requestAlwaysAuthorization];
    
    for (CLRegion *region in _locationManager.monitoredRegions) {

        [_locationManager requestStateForRegion:region];
    }
    
    _arduinoDevice = nil;
    
    // Monitoring change of UserDefaults
    
    [[NSUserDefaults standardUserDefaults] addObserver:self
                                            forKeyPath:@"HouseLongitude"
                                               options:NSKeyValueObservingOptionNew
                                               context:NULL];
 
    [[NSUserDefaults standardUserDefaults] addObserver:self
                                            forKeyPath:@"HouseSize"
                                               options:NSKeyValueObservingOptionNew
                                               context:NULL];
    
    [self addObserver:self
           forKeyPath:@"insideHouse"
              options:NSKeyValueObservingOptionNew
              context:NULL];
}</pre></div><p>Once the <a id="id424" class="indexterm"/>location manager is initialized and authorized by the user, the following method is called and the iBeacon region is created (we will discuss the actual iBeacon region creation later in this section):</p><div class="informalexample"><pre class="programlisting">- (void)locationManager:(CLLocationManager *)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status {
    
    if (status == kCLAuthorizationStatusAuthorizedAlways &amp;&amp; _centralManager.state == CBCentralManagerStatePoweredOn) {
        [self createGaregeRegionIfNeeded];
    }
}</pre></div><p>Then we call a method:</p><div class="informalexample"><pre class="programlisting">[[NSUserDefaults standardUserDefaults] addObserver:self
                                            forKeyPath:@"HouseLongitude"
                                               options:NSKeyValueObservingOptionNew
                                               context:NULL];</pre></div><p>This method activates a key-value observer in user defaults, where information about the geofencing region is stored.</p><div class="note" title="Note"><h3 class="title"><a id="tip53"/>Tip</h3><p>
<span class="strong"><strong>Key-value observing</strong></span>
</p><p>For more <a id="id425" class="indexterm"/>information <a id="id426" class="indexterm"/>about key-value observing, take a look at the Apple documentation at <a class="ulink" href="http://apple.co/1PZ6aJm">http://apple.co/1PZ6aJm</a>.</p></div><p>Now, every <a id="id427" class="indexterm"/>time the <code class="literal">HouseLongitude</code> changes, the <code class="literal">observeValueForKeyPath</code> method is called, and this allows us to create or update the geofencing region. Note that <code class="literal">HouseLongitude</code> changes in the BLEConnectionViewController when the user locates the house. The KVO technique allows you to automatically keep the geofencing region updated. The KVO is also set for the <code class="literal">HouseSize</code> user default property so that the region gets updated when the user changes the size of the region itself.</p><p>We can also set the KVO for the <code class="literal">insideHouse</code> property. We will talk about this later on.</p><p>Let's take a look at the <code class="literal">observeValueForKeyPath</code> method where the geofencing region is actually created:</p><div class="informalexample"><pre class="programlisting">-(void)observeValueForKeyPath:(NSString *)aKeyPath ofObject:(id)anObject change:(NSDictionary *)aChange context:(void *)aContext {
    
    
    if ([aKeyPath isEqualToString:@"insideHouse"]) {
        
        if (_insideHouse)
            _readyToOpenIndicator.image = [UIImage imageNamed:@"grayLED.png"];
        else
            _readyToOpenIndicator.image = [UIImage imageNamed:@"blueLED.png"];
        
        return;
    }
    
    CLLocationCoordinate2D center;
    
    center.latitude = [[[NSUserDefaults standardUserDefaults] objectForKey:@"HouseLatitude"] floatValue];
    center.longitude = [[[NSUserDefaults standardUserDefaults] objectForKey:@"HouseLongitude"] floatValue];
    
    double radius = [[[NSUserDefaults standardUserDefaults] objectForKey:@"HouseSize"] doubleValue];
    radius = (radius == 0) ? 1 : radius;
    
    
    //NSLog(@"Latitude %f Longitude %f Radius %f",center.latitude, center.longitude, radius);
    
    CLCircularRegion *houseRegion = [[CLCircularRegion alloc] initWithCenter:center
radius:100. * radius
identifier:@"House Region"];
    houseRegion.notifyOnEntry = YES;
    houseRegion.notifyOnExit = YES;
    
    [_locationManager startMonitoringForRegion:houseRegion];
    [_locationManager requestStateForRegion:houseRegion];
}</pre></div><p>To create the<a id="id428" class="indexterm"/> geofencing region, we need to define its center, which is the location of the house, and a radius that is manually chosen. Then, call the following:</p><div class="informalexample"><pre class="programlisting">[_locationManager startMonitoringForRegion:houseRegion];</pre></div><p>The iOS knows that we need to receive a notification as soon as we enter or exit the geofencing region. Therefore, we call:</p><div class="informalexample"><pre class="programlisting">[_locationManager requestStateForRegion:houseRegion];</pre></div><p>We request the iOS to establish whether we are inside or outside the geofencing region and call the <code class="literal">locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region</code> method to inform us about the same (we'll talk about this method later).</p><p>Let's see how iBeacon is created instead. Remember that when the location manager is authorized and the central manager, which manages the Bluetooth connections and communication, is turned on, the following method is called in order to create the iBeacon region:</p><div class="informalexample"><pre class="programlisting">-(void)createGaregeRegionIfNeeded {
    
    NSArray *regions = [_locationManager.monitoredRegions allObjects];
    
    NSPredicate *p = [NSPredicate predicateWithFormat:@"identifier == %@",@"Garage Region"];
    NSArray *garageRegions = [regions filteredArrayUsingPredicate:p];
    
    if (garageRegions.count == 0 &amp;&amp; _centralManager.state == CBCentralManagerStatePoweredOn) {
        
        NSUUID *beaconUUID = [[NSUUID alloc] initWithUUIDString:@"00000000-0000-0000-0000-0000000000FF"];
        
        CLBeaconRegion *beaconRegion = [[CLBeaconRegion alloc] initWithProximityUUID:beaconUUID
                                                                               major:0
                                                                               minor:1
                                                                          identifier:@"Garage Region"];
        beaconRegion.notifyEntryStateOnDisplay = YES;
        
        [_locationManager startMonitoringForRegion:beaconRegion];
        [_locationManager requestStateForRegion:beaconRegion];
    }
}</pre></div><p>The creation <a id="id429" class="indexterm"/>of the region is quite similar to that of the geofencing region. This time, the region has an UUID, a major, and a minor instead of a center and a radius.</p><p>Once the iBeacon region is created, we ask the iOS to start monitoring it (<code class="literal">[_locationManager startMonitoringForRegion:beaconRegion]</code>) and immediately tell us whether we are inside or outside the region itself (<code class="literal">[_locationManager requestStateForRegion:beaconRegion]</code>).</p><p>Now, let's take a look at the most important part of the code—the code that actually manages the regions' boundary crossing and sends the command of opening the garage door.</p><p>Every time we enter a region, the <code class="literal">didEnterRegion</code> method is called:</p><div class="informalexample"><pre class="programlisting">- (void)locationManager:(CLLocationManager *)manager didEnterRegion:(CLRegion *)region  {
    

    UILocalNotification* localNotification = [[UILocalNotification alloc] init];
    localNotification.fireDate = nil;
    localNotification.alertBody = [NSString stringWithFormat:@"Entering %@",region.identifier];
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.soundName = @"Chime.aiff";
    [[UIApplication sharedApplication] presentLocalNotificationNow:localNotification];
    
    if ([region.identifier isEqualToString:@"Garage Region"]) {
        
        [_locationManager startRangingBeaconsInRegion:(CLBeaconRegion *)region];
        
        if (_insideHouse)
            return;
        
        NSString *deviceIdentifier = [[NSUserDefaults standardUserDefaults] objectForKey:@"GarageiBeaconDevice"];
        
        if (deviceIdentifier!=nil &amp;&amp; _arduinoDevice==nil) {
            
            NSArray *devices = [_centralManager retrievePeripheralsWithIdentifiers:@[[CBUUID UUIDWithString:deviceIdentifier]]];
            if (devices.count == 0) {
                return;
            }
            
            _arduinoDevice = devices[0];
            _arduinoDevice.delegate = self;
        }
        
        [_centralManager connectPeripheral:_arduinoDevice options:nil];
        
        [self setInsideHouse:YES];
    }
}</pre></div><p>The first few<a id="id430" class="indexterm"/> lines send a local notification to the user to inform them that the region border has been crossed going into it.</p><p>If you are entering the iBeacon region and you are inside the house (<code class="literal">_insideHouse = YES</code>), nothing happens. This means that if the iBeacon region cannot cover the entire house and if you exit the iBeacon region by moving inside your house, you don't open the garage door unexpectedly.</p><p>If you are not in the house, the app gets connected to Arduino (via Bluetooth) and the garage door opens. Don't forget that the actual opening command is sent into the <code class="literal">didDiscoverCharacteristicsForService</code> method.</p><p>Forget <code class="literal">[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion *)region]</code> for now.</p><div class="note" title="Note"><h3 class="title"><a id="tip54"/>Tip</h3><p>
<span class="strong"><strong>Enabling local notifications</strong></span>
</p><p>In order to send local notifications, they have to be authorized by the user. To do this, we need to call the <code class="literal">[application registerUserNotificationSettings:[UIUserNotificationSettings settingsForTypes:UIUserNotificationTypeAlert|UIUserNotificationTypeBadge|UIUserNotificationTypeSound categories:nil]]</code> method as soon as the application starts. The <code class="literal">didFinishLaunchingWithOptions</code> method is the place where we call it.</p></div><p>Every time <a id="id431" class="indexterm"/>we get into a region, the <code class="literal">didExitRegion</code> method is called:</p><div class="informalexample"><pre class="programlisting">- (void)locationManager:(CLLocationManager *)manager didExitRegion:(CLRegion *)region {
    
UILocalNotification* localNotification = [[UILocalNotification alloc] init];
    localNotification.fireDate = nil;
    localNotification.alertBody = [NSString stringWithFormat:@"Exiting %@",region.identifier];
    localNotification.timeZone = [NSTimeZone defaultTimeZone];
    localNotification.soundName = @"Chime.aiff";
    [[UIApplication sharedApplication] presentLocalNotificationNow:localNotification];
    
    [_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion *)region];
    
    if ([region.identifier isEqualToString:@"House Region"]) {
        
        [self setInsideHouse:NO];
    }
}</pre></div><p>After sending a local notification, if we are exiting the geofencing region, we can set the <code class="literal">insideHouse</code> property to <code class="literal">NO</code> so that when we enter the iBeacon region again, the opening command is sent. Forget <code class="literal">[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion *)region]</code> for now.</p><p>Why don't we use the traditional code (<code class="literal">_insideHouse = YES</code>) to set the property? In the <code class="literal">viewDidLoad</code> method, we set an observer for the property so that every time it changes, the <code class="literal">observeValueForKeyPath</code> is called. The traditional code doesn't start the <code class="literal">observeValueForKeyPath</code> method, and we need to use <code class="literal">[self setInsideHouse:NO]</code> instead. When the <code class="literal">observeValueForKeyPath</code> is called because <code class="literal">insideHouse</code> changes, we update the image of the <code class="literal">readyToOpen</code>, keeping the user informed about whether the app will send the opening command on entering the iBeacon region or not. To do this, we need these few lines of code into the <code class="literal">observeValueForKeyPath</code> method:</p><div class="informalexample"><pre class="programlisting">    if ([aKeyPath isEqualToString:@"insideHouse"]) {
        
        if (_insideHouse)
            _readyToOpenIndicator.image = [UIImage imageNamed:@"grayLED.png"];
        else
            _readyToOpenIndicator.image = [UIImage imageNamed:@"blueLED.png"];
        
        return;
    }</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip55"/>Tip</h3><p>
<span class="strong"><strong>Working in the background</strong></span>
</p><p>What makes the iBeacon technology along with geofencing particularly interesting is that <code class="literal">didEnterRegion</code> and <code class="literal">didExitRegion</code> are also called when the application is either running in the background, or not even running. Unfortunately, when the application is not running, the iOS starts it and keeps it running for some period of time (for about 3s) to save the batteries. So, any kind of action that is required to respond to the event has to be very quick. In the code, we just connect to the Arduino and send a few bytes to it, and this takes up much less time than 3s.</p></div><p>The last <a id="id432" class="indexterm"/>relevant method that we need to write is <code class="literal">didDetermineState</code>, which is called to find out where the device is with respect to a region (calling <code class="literal">[_locationManager startMonitoringForRegion:beaconRegion]</code> or <code class="literal">[_locationManager startMonitoringForRegion:houseRegion]</code>) or when the iOS recognizes that something has changed. In this function, we update the indicators that visually inform the user that they are in one of the monitored regions, as follows:</p><div class="informalexample"><pre class="programlisting">- (void)locationManager:(CLLocationManager *)manager didDetermineState:(CLRegionState)state forRegion:(CLRegion *)region {
    
    switch (state) {
            
        case CLRegionStateInside:
            NSLog(@"Inside %@",region.identifier);
            break;
            
        case CLRegionStateOutside:
            NSLog(@"Outside %@",region.identifier);
            break;
            
        case CLRegionStateUnknown:
            NSLog(@"Unknown %@",region.identifier);
            break;
    }
    
    if ([region.identifier isEqualToString:@"Garage Region"]) {
        
        if (state==CLRegionStateInside) {
            
            _garageRegionIndicator.image = [UIImage imageNamed:@"blueLED.png"];
        }
        else {
            
            _garageRegionIndicator.image = [UIImage imageNamed:@"grayLED.png"];
        }
    }
    
    if ([region.identifier isEqualToString:@"House Region"]) {
        
        if (state==CLRegionStateInside) {
            
            _houseRegionIndicator.image = [UIImage imageNamed:@"blueLED.png"];
        }
        else {
            
            [self setInsideHouse:NO];
            _houseRegionIndicator.image = [UIImage imageNamed:@"grayLED.png"];
        }
    }
    
}</pre></div><p>Note that the <a id="id433" class="indexterm"/>visual information (inside the iBeacon and geofencing region, ready to open the garage door) is not strictly needed. We put that in the app to make you experiment with iBeacon and geofencing.</p><p>The last two methods are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">manualOperation</code>: This<a id="id434" class="indexterm"/> manually opens the garage door by sending the opening command.</li><li class="listitem"><code class="literal">simulateHomeRegionExit</code>: This <a id="id435" class="indexterm"/>simulates the exit from the geofencing region by manually setting the <code class="literal">insideHouse</code> property to <code class="literal">NO</code>. This can be useful in the debugging phase or if you wish to learn how the application works without having to actually drive away from your house (which we did too many times!).</li></ul></div><p>The code is very <a id="id436" class="indexterm"/>simple and doesn't require much explanation:</p><div class="informalexample"><pre class="programlisting">- (IBAction)manualOperation:(UIButton *)sender {
    
    NSString *deviceIdentifier = [[NSUserDefaults standardUserDefaults] objectForKey:@"GarageiBeaconDevice"];
    
    if (deviceIdentifier!=nil &amp;&amp; _arduinoDevice==nil) {
        
        NSArray *devices = [_centralManager retrievePeripheralsWithIdentifiers:@[[CBUUID UUIDWithString:deviceIdentifier]]];
        if (devices.count == 0) {
            return;
        }
        _arduinoDevice = devices[0];
        _arduinoDevice.delegate = self;
    }
    
    if (_arduinoDevice != nil) {
        [_centralManager connectPeripheral:_arduinoDevice options:nil];
    }
}

- (IBAction)simulateHomeRegionExit:(UIButton *)sender {
    
    //_insideHouse = NO; // This doesn't fire the KVO !
    [self setInsideHouse:NO];
}</pre></div><p>The very last two methods (we promise!) that you need to look at are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">didRangeBeacons</code>: This <a id="id437" class="indexterm"/>method is not used in this project, but we have shown it because it may be very useful in another iBeacon project, as it gives an estimation of the distance between an iOS device and each iBeacon in range. Ranging iBeacons can be started and stopped by using <code class="literal">[_locationManager startRangingBeaconsInRegion:(CLBeaconRegion *)region]</code> and <code class="literal">[_locationManager stopRangingBeaconsInRegion:(CLBeaconRegion *)region]</code> respectively.</li><li class="listitem"><code class="literal">monitoringDidFailForRegion</code>: This <a id="id438" class="indexterm"/>method tells us whether something is wrong in the <a id="id439" class="indexterm"/>monitoring of any region. Never forget to implement it.</li></ul></div><div class="informalexample"><pre class="programlisting">-(void)locationManager:(CLLocationManager *)manager didRangeBeacons:(NSArray *)beacons inRegion:(CLBeaconRegion *)region {
    
    if ([beacons count] == 0) {
        return;
    }
    
    CLBeacon *b = beacons[0];
    
    if (b.proximity == CLProximityFar) {
        
        NSLog(@"Far");
    }
    
    if (b.proximity == CLProximityNear) {
        
        NSLog(@"Near");
    }
    
    if (b.proximity == CLProximityImmediate) {
        
        NSLog(@"Immediate");
    }
    
    if (b.proximity == CLProximityUnknown) {
        
        NSLog(@"Unknown");
    }
}

- (void)locationManager:(CLLocationManager *)manager monitoringDidFailForRegion:(CLRegion *)region withError:(NSError *)error {
    
    UIAlertView *alert = [[UIAlertView alloc] initWithTitle:NSLocalizedString(@"Error",nil)
                                                    message:[NSString stringWithFormat:@"Region Monitoring Failed for the region: %@\n%@",[region identifier],[error localizedDescription]]
                                                   delegate:self
                                          cancelButtonTitle:@"Ok"
                                          otherButtonTitles:nil,nil];
    
    NSLog(@"%@",[error localizedDescription]);
    
    [alert show];
}</pre></div></div><div class="section" title="Writing code for PinsViewController"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>Writing code for PinsViewController</h2></div></div></div><p>This view controller<a id="id440" class="indexterm"/> manages the PINs that are required to authorize your relatives and friends so that they can access your garage. It works almost in the same way as the ActivationsTableViewController in the Power Plug project. So, we won't spend much time on it.</p><p>The main difference here is that we have to enter just a PIN, and it doesn't make sense to create a screen for that. We take advantage of a feature of UIAlertView. By setting its style to <code class="literal">UIAlertViewStylePlainTextInput</code>, it presents a text field in which we can enter the PIN. This is very easy and convenient.</p><p>You should be able to write this view controller yourself and compare your results with the downloaded code. Let's give it a try.</p></div><div class="section" title="Testing and tuning"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Testing and tuning</h2></div></div></div><p>We are now ready<a id="id441" class="indexterm"/> to test this project and impress our neighbors. First, you have <a id="id442" class="indexterm"/>to set the iBeacon parameters. If you are using RedLab iBeacon, you can set it by using the iOS app that is available from the iTunes Store for <a id="id443" class="indexterm"/>free (<a class="ulink" href="https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&amp;mt=8">https://itunes.apple.com/it/app/redbear-beacontool/id828819434?l=en&amp;mt=8</a>).</p><p>You have to enter the following values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>UUID</strong></span>: 00000000-0000-0000-0000-0000000000FF</li><li class="listitem"><span class="strong"><strong>Major</strong></span>: 0</li><li class="listitem"><span class="strong"><strong>Minor</strong></span>: 1</li><li class="listitem"><span class="strong"><strong>Advertising Interval</strong></span>: 250 ms</li><li class="listitem"><span class="strong"><strong>TX Power</strong></span>: 0</li></ul></div><div class="note" title="Note"><h3 class="title"><a id="note14"/>Note</h3><p>Double-check the UUID. It's a long string, and any error prevents the iBeacon from being recognized by the application.</p></div><div class="note" title="Note"><h3 class="title"><a id="tip56"/>Tip</h3><p>
<span class="strong"><strong>Tuning the iBeacon parameters</strong></span>
</p><p>Once everything works as expected, you can try reducing the TX power and/or Advertising Interval. The lower they are, the more battery you save, and the longer the iBeacon works without you having to replace the batteries. Moreover, reducing the TX power allows you to send the opening command when you are closer to your garage. Let's make some tests to detect the best values for you.</p></div><p>If you are <a id="id444" class="indexterm"/>using a different iBeacon, ask the manufacturer how to set the parameters so they are exactly the same.</p><p>Now, you <a id="id445" class="indexterm"/>should place the iBeacon near your garage door at a high position and leave it turned off.</p><p>Wire the relay contacts or the MOSFET pins to your garage door opener (please refer to the electric diagrams provided at the beginning of this chapter). There are a lot of different models out there, so you need to do this yourself. The general advice is that you have to put the relay exit (or the exit connected to the MOSFET) in parallel to the push button that you use to manually open and close the garage door. Take a look at your garage door opener instruction manual for more information and directions.</p><p>Before starting the test phase, we need to set up the Arduino code to properly clean up the EEPROM and store the master PIN. To do this, perform the following procedure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">setup</code> function, comment out the following lines, which clean up the EEPROM and store the master PIN:<div class="informalexample"><pre class="programlisting">  for (int i = 0; i &lt; 6*NUMBER_OF_PINS; i++)
    EEPROM[i] = 0;

  // Set the master PIN

  EEPROM[0] = 1;     // Don't change this
  EEPROM[1] = '1';
  EEPROM[2] = '2';
  EEPROM[3] = '3';
  EEPROM[4] = '4';
  EEPROM[5] = '5';</pre></div><div class="note" title="Note"><h3 class="title"><a id="note15"/>Note</h3><p>You can change the master PIN (12345) to your preferred code here.</p></div></li><li class="listitem">Upload the code to Arduino.</li><li class="listitem">Comment the previous code again and upload it to Arduino. Now, the EEPROM is cleared and the master PIN is stored.</li></ol><div style="height:10px; width: 1px"/></div><p>Now, when <a id="id446" class="indexterm"/>you open the app, you will see a message. You have to respond to this message by selecting <span class="strong"><strong>Allow</strong></span>:</p><div class="mediaobject"><img src="../Images/image00227.jpeg" alt="Testing and tuning"/></div><p style="clear:both; height: 1em;"> </p><p>In the app, open<a id="id447" class="indexterm"/> the Configuration tab, scan for the RF8001, choose your personal PIN, enter it in the PIN field, and then tap on Set House Position. A few seconds later, you should see the longitude and latitude of your house, as acquired by the GPS.</p><p>Set the <span class="strong"><strong>House Region Size</strong></span> to 100 meters. Change it to a higher value only if your garage door opens unexpectedly when you are inside your house or if you have a very large house (lucky you!).</p><p>Tap the <span class="strong"><strong>PINS</strong></span> tab, enter the master PIN (<code class="literal">12345</code>, if you have not changed it in the Arduino code), and tap <span class="emphasis"><em>Enter</em></span>. You should see an empty list. Tap on the add button (<span class="strong"><strong>+</strong></span>) and enter your personal PIN that you chose before.</p><p>Tap on the Main tab and then tap on the <span class="strong"><strong>Open</strong></span> button. Now, your garage should open and then close about 30 seconds later.</p><div class="note" title="Note"><h3 class="title"><a id="note16"/>Note</h3><p>To change the closing delay time, you have to change the value of CLOSING_DOOR_INTERVAL in the Arduino code. Moreover, to operate the garage door opener, Arduino shorts the control line for about 300 ms. If this is not enough for your device, you can change the delay in the <code class="literal">pulseOutput</code> function.</p></div><p>Now, we are going to test the most exciting feature—opening the garage automatically:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the Main tab again.</li><li class="listitem">You should see the <span class="strong"><strong>In House Region</strong></span> indicator turned on, the <span class="strong"><strong>In Garage Region</strong></span> turned off, and the <span class="strong"><strong>Ready To Open</strong></span> turned on.</li><li class="listitem">If the <span class="strong"><strong>Ready To Open</strong></span> indicator is off, tap on <span class="strong"><strong>Simulate Exit</strong></span>.</li><li class="listitem">Close your app, sending it to the background or closing it from the task list.</li><li class="listitem">Turn on the iBeacon.</li><li class="listitem">You should <a id="id448" class="indexterm"/>see a notification on the screen and hear a short sound, and your garage should start opening.</li><li class="listitem">Now, if you move <a id="id449" class="indexterm"/>around and inside your house, your garage shouldn't open anymore (the <span class="strong"><strong>Ready To Open </strong></span>indicator should remain off).</li><li class="listitem">Drive away from your house until you hear a sound notification from your iOS device. Please drive safely. You don't need to look at your iOS device while driving. The sound notification alerts you.</li><li class="listitem">Make a stop and check the application. Now, the <span class="strong"><strong>Ready To Open</strong></span> indicator should be on.</li><li class="listitem">Drive back to your house. As soon as you are close enough to the iBeacon, you should hear a notification, and the garage door should start opening.</li></ol><div style="height:10px; width: 1px"/></div><p>Now, you are ready to impress your neighbors!</p></div></div>
<div class="section" title="How to go further" id="aid-1FLS41"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec45"/>How to go further</h1></div></div></div><p>Some improvements <a id="id450" class="indexterm"/>that could be done to this project are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Setting the automatic door closing interval directly from the app instead of changing the Arduino code.</li><li class="listitem">Turning the garage lights on and off on entering and exiting the garage.</li><li class="listitem">Opening the garage door from the inside by using the noise generated by the car engine instead of manually. This requires listening to the motor noise from the iOS device and comparing it with a pre-recorded noise of the motor. This is done to avoid a situation where a noise inside or outside the garage unexpectedly opens the door. For signal comparison, you can use an operation called the correlation of two signals (take a look at the Accelerate framework that is available in iOS), but you have to pay attention to the fact that the acquired signal and the pre-recorded signal may have different lengths and/or may be time shifted. Okay, this is a big challenge, but this is the last chapter of the book, and you should be a master of Arduino and iOS programming by now. Digital signal processing is an art that you may be interested in.</li><li class="listitem">Checking whether <a id="id451" class="indexterm"/>the garage door is effectively closed by using a reed switch, a hall effect sensor, or an ultrasonic distance sensor, and having a notification sent to your phone. You may need the WiFi Shield to take advantage of one of the available IoT services to send the notification.</li></ul></div></div>
<div class="section" title="Summary" id="aid-1GKCM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec46"/>Summary</h1></div></div></div><p>While building this project, you learned a lot, especially with regards to iOS. You learned how to create and manage the geofencing and iBeacon regions. This opens the door to many different projects on iOS with or without the Arduino integration. Moreover, you learned how to monitor changes in properties (KVO), which is a technique that lies at the base of good programming together with the help of Model-View-Controller model. This can be applied many times. On Arduino, you learned how to use EEPROM to store information that needs to be permanently stored on the board to control the behavior of your programs.</p><p>This project ends this long journey of Arduino and iOS programming and the two platforms' integration.</p><p>I hope that you had fun reading the book, coding, and building at least some of the proposed projects (or maybe all!). Mostly, I hope that you learned more about Arduino, iOS, and their integration so that from now on, you can design and build your own projects.</p><p>Have a great time making some revolutionary and game-changing projects!</p></div></body></html>