<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Physics in Sprite Kit</h1></div></div></div><p>In previous chapters, we had gone through essentials to develop a game in Sprite Kit. Also, we have already developed starting scenes, which are different screen views associated with menu items.</p><p>To recap the previous chapter, where we discussed about nodes in detail, we studied the <code class="literal">SKNode</code> class and its associated properties and functions. Along with this, we discussed about building a node tree and actions on a node tree. We also applied major subclasses in our game, such as <code class="literal">SKLabelNode</code>, <code class="literal">SKCropNode</code>, <code class="literal">SKShapeNode</code>, <code class="literal">SKEmitterNode</code>, <code class="literal">SKLightNode</code>, and <code class="literal">SKVideoNode</code> to create the menu scene. Now, the time has come to venture further into Sprite Kit.</p><p>In the real world we are affected by many physical laws, such as mass, gravity, velocity, and so on. To make a game more realistic, Sprite Kit provides us with some classes and functions, which are used to make nodes act like bodies as in a real environment. By applying these classes to characters, environment, and so on, our game becomes realistic.</p><p>For example, in a platform game which involves a player walking on a road. It will be better to have gravity, force, friction, and so on, being applied to the player, the road or any other obstacle. Now, we are going to discuss about simulating physics in our game <em>Platformer</em>.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Simulating physics in Sprite Kit</h1></div></div></div><p>Most of the <a id="id230" class="indexterm"/>game engines have an inbuilt physics engine, and <a id="id231" class="indexterm"/>you can also add an external physics engine to a game engine. Fortunately, Apple provides a physics engine in Sprite Kit. In Sprite Kit, physics properties are applied by an object of the class, <code class="literal">SKPhysicsBody</code>. As we have already learned that objects are connected to a node in a node tree, physics simulation uses a node's orientation and position for simulation. In Sprite Kit, when a game renders, each frame invokes some functions in a cycle, as follows:</p><div><pre class="programlisting">update
didEvaluateActions
didSimulatePhysics
didApplyConstraints
didFinishUpdate</pre></div><p>After<a id="id232" class="indexterm"/> actions (such as image changing in a node for animation) <code class="literal">SKScene</code> <a id="id233" class="indexterm"/>simulates physics to do all the actions, such as gravity on a physics body, velocity change, collision between two physics bodies, and so on. If we go through our <code class="literal">SKNode</code> class, we will see there is a property called <code class="literal">physicsBody</code>. It takes the <code class="literal">SKPhysicsBody</code> object as a parameter and defines physics laws on those objects; it is obvious it will be inherited from its subclasses, such as <code class="literal">SKSpriteNode</code>, <code class="literal">SKEmitterNode</code>, <code class="literal">SKVideoNode</code>, and more. So, we can make any <code class="literal">SKNode</code> subclass a physics body by setting the <code class="literal">physicsBody</code> property on it.</p><p>Now it is time to dive into some necessary documentation of the essential class responsible for the physics behavior of a node in a scene. Let's discuss about the <code class="literal">SKPhysicsBody</code> class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>SKPhysicsBody</h1></div></div></div><p>A node's <code class="literal">physicsBody</code> property <a id="id234" class="indexterm"/>uses the <code class="literal">SKPhysicsBody</code> class object. In the life cycle of a frame, the <code class="literal">didSimulatePhysics</code> function is called just after actions are evaluated. The work of this function is to calculate the physical properties, such as gravity, velocity, friction, restitution, collision, or other forces. After these calculations are done, the positions and orientations of nodes are updated in the <code class="literal">update</code> function. If we are going to apply some force on a node, it is necessary that we assign the <code class="literal">SKPhysicsBody</code> object to that node first.</p><p>Sprite Kit provides us with two kinds <a id="id235" class="indexterm"/>of physics bodies:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Volume-based</strong>: These<a id="id236" class="indexterm"/> are the kind of physics bodies that have mass and volume</li><li class="listitem" style="list-style-type: disc"><strong>Edge-based</strong>: These<a id="id237" class="indexterm"/> are the kind of physics bodies that don't have mass and volume</li></ul></div><p>In volume-based bodies, we <a id="id238" class="indexterm"/>can control if it should be affected by gravity, friction, collision, and so on, by setting it as <code class="literal">static</code> or <code class="literal">dynamic</code>. This property is very useful as we can make a static platform or a moving object by just tweaking this property. These bodies are defined within specified boundaries, such as circle, rectangle, polygon, and so on. Irregular shapes are not allowed. For an irregular shaped body one can join small volume-based bodies to achieve desired pattern for a physics object.</p><p>On the other hand, edge-based bodies are used to make volume-less spaces in the game scene. That means they are not solid and allow other physics body inside their own boundaries. Edge-based physics bodies are always treated as if their <code class="literal">dynamic</code> property is <code class="literal">false</code> and could collide only with other volume-based physics bodies. To understand the concept of edge-based body, think of a scene having clouds; a cloud can never be solid, a volume-based physics object can enter into it.</p><div><img src="img/4201_05_01.jpg" alt="SKPhysicsBody"/><div><p>A graphical example of volume-based and edge-based physics bodies</p></div></div><p>These two kinds of physics bodies are made by calling appropriate initialization of <code class="literal">SKPhysicsBody</code>. We mostly use volume-based physics bodies in our scene.</p><p>As we define that, we need to instantiate the <code class="literal">SKPhysicsBody</code> class for making volume-based or edge-based physics bodies.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>The initialization of volume-based physics bodies</h2></div></div></div><p>Following are the<a id="id239" class="indexterm"/> initializers<a id="id240" class="indexterm"/> for volume-based physics <a id="id241" class="indexterm"/>bodies:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">init(circleOfRadius r: CGFloat) -&gt; SKPhysicsBody</code>: This initializer is used to make a circular physics body. It takes radius as a parameter and returns an <code class="literal">SKPhysicsBody</code> object. The center of gravity of this body lies in the center of the receiving node, that is, the, node on which this function is applied.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init(circleOfRadius r: CGFloat,center center: CGPoint) -&gt; SKPhysicsBody</code>: This initializer is very similar to the previous one except in that it takes one more parameter, that is, the origin of the physics body. We can shift our gravity or circular physics body's center with respect to the receiving coordinate system assigned by this initializer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init!(rectangleOfSize s: CGSize) -&gt; SKPhysicsBody</code>: This initializer is used to make rectangle shaped physics bodies. It takes a <code class="literal">rectangle</code> as a parameter and returns an <code class="literal">SKPhysicsBody</code> object, containing its center on the receiving node's center.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init!(rectangleOfSize s: CGSize,center center: CGPoint) -&gt; SKPhysicsBody</code>: This initializer is very similar to the previous one except in that it takes one more parameter that is, origin of the physics body. We can shift gravity on a rectangular physics body to the center with respect to the receiving coordinate system assigned by this initializer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init(bodies bodies: [AnyObject]) -&gt; SKPhysicsBody</code>: This initializer is used to make a new physics body by using the array of existing physics bodies. For this we have to pass only volume-based physics body objects in the array. The resultant area of the physics body from this initializer, is the union of the other child physics body inside the array. As it uses the shapes of its children's bodies, it means it can have spaces inside it, or even blank fields.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init!(polygonFromPath path: CGPath!) -&gt; SKPhysicsBody</code>: This initializer is used to make a polygon shaped physics body. It takes a convex polygon path with counterclockwise winding as a parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init!(texture texture: SKTexture!,size size: CGSize) -&gt; SKPhysicsBody</code>: This initializer is used to make a physics body using a texture. This is used when we need a physics body shape as per the texture shape. It is called per pixel physics and is very useful when the shape is neither rectangular nor circular. It was introduced in iOS 8. In this initializer, a texture and a size are used as parameters. First, texture is scaled to that size and then, the shape of the newly created physics body is decided by all of the pixels <a id="id242" class="indexterm"/>having <a id="id243" class="indexterm"/>a non-zero alpha value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init!(texture texture: SKTexture!,alphaThreshold alphaThreshold: Float,size size: CGSize) -&gt; SKPhysicsBody</code>: This<a id="id244" class="indexterm"/> initializer is very similar to the previous one and was also introduced in iOS 8, except that it takes one more argument, <code class="literal">alpha</code>, as parameter. We can define what should be the alpha value below which the pixels will be ignored, in order to create the new physics body. The rest of the process is the same as the previous one.</li></ul></div><p>After this, let's have a look at how to create an edge-based physics body.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>The initialization of edge-based physics bodies</h2></div></div></div><p>Following is the list of initializers<a id="id245" class="indexterm"/> used to <a id="id246" class="indexterm"/>make an edge-based physics <a id="id247" class="indexterm"/>body:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">init (edgeLoopFromRect rect: CGRect) -&gt; SKPhysicsBody</code>: This initializer takes a rectangle as a parameter and returns a new rectangular edge-based physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init (edgeFromPoint p1: CGPoint, toPoint p2: CGPoint) -&gt; SKPhysicsBody</code>: This initializer takes two points as parameters and returns an edge-based physics body between those two points.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init (edgeLoopFromPath path: CGPath!) -&gt; SKPhysicsBody</code>: This initializer takes a <code class="literal">path</code> as a parameter and returns an edge-based physics body based on that path. The path must not intersect itself. If the path is not closed, it creates a loop by joining the first and the last point of that path automatically.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init (edgeChainFromPath path: CGPath!) -&gt; SKPhysicsBody</code>: This initializer takes a <code class="literal">path</code> as a parameter and returns an edge chain-based physics <a id="id248" class="indexterm"/>body <a id="id249" class="indexterm"/>based on that path. The <a id="id250" class="indexterm"/>path must not intersect itself.</li></ul></div><p>These are the initialization processes for the physics body—both for volume-based and edge-based ones. We can customize a physics body's behavior by tweaking some of its properties.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>The behavior controller properties of a physics body</h2></div></div></div><p>Following is the<a id="id251" class="indexterm"/> list of properties from which we can control the behavior of a physics body:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">affectedByGravity</code>: This is a <a id="id252" class="indexterm"/>Boolean value. It determines if a physics body will be affected by gravity in the scene. Edge-based physics bodies simply ignore this property as they are not affected by gravity. The default value is <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">allowsRotation</code>: This is <a id="id253" class="indexterm"/>also a Boolean value. It determines if a physics body will be affected by angular forces and impulses applied to it in the scene. An edge-based physics body simply ignores this property. The default value is <code class="literal">true</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dynamic</code>: This is a<a id="id254" class="indexterm"/> Boolean value too. It determines if a physics body will be moved by the physics simulation in the scene. Edge-based physics bodies simply ignore this property. The default value is <code class="literal">true</code>.</li></ul></div><p>These are the behavior controller properties for a volume-based physics body. Along with this, a physics body has some of its own physical properties too.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>The physical properties of a physics body</h2></div></div></div><p>These are the properties<a id="id255" class="indexterm"/> possessed by a physics body. As you know, the velocity, force, gravity, collision, and so on, depend upon the mass, density, area, and so on, of a body.</p><p>Following is the list of physical properties of a physics body.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">mass</code>: It is the mass of the<a id="id256" class="indexterm"/> body in kilograms.</li><li class="listitem" style="list-style-type: disc"><code class="literal">density</code>: It is the density<a id="id257" class="indexterm"/> of the body in kilograms per square meter. The density and mass properties are interrelated. One property is recalculated every time the other is changed. The default value is 1.0.</li><li class="listitem" style="list-style-type: disc"><code class="literal">area</code>: It is the area<a id="id258" class="indexterm"/> covered by the body. This is a read-only property and is used to define the mass of the physics body with the help of the <code class="literal">density</code> property.</li><li class="listitem" style="list-style-type: disc"><code class="literal">friction</code>: It is used to<a id="id259" class="indexterm"/> determine how much friction force should be applied to the other physics body in contact with the current body. This property has a value between 0.0 and 1.0. The default value is 0.2.</li><li class="listitem" style="list-style-type: disc"><code class="literal">restitution</code>: It is used to<a id="id260" class="indexterm"/> determine the bounciness of the physics body. This property has a value between 0.0 and 1.0. The default value is 0.2.</li><li class="listitem" style="list-style-type: disc"><code class="literal">linearDamping</code>: It is used to <a id="id261" class="indexterm"/>reduce the linear velocity of a physics body. This property has a value between 0.0 and 1.0. The default value is 0.1.</li><li class="listitem" style="list-style-type: disc"><code class="literal">angularDamping</code>: It is used to <a id="id262" class="indexterm"/>reduce the angular velocity of a physics body. This property has a value between 0.0 and 1.0. The default value is 0.1.</li></ul></div><p>These properties define the physical behavior of a physics body.</p><p>The <code class="literal">SKPhysicsBody</code> class provides some properties and functions for collision control.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Collision control properties and functions</h2></div></div></div><p>Physics bodies use some category for collision detection with other physics bodies. Collision is very important in almost every game. When objects collide, there is a change in the velocity and discretion of the object, which needs precise calculation of the change in the physical parameters. We have to specify the category of the physics bodies in our game. There is a limitation as we can only define 32 different kinds of categories for the physics bodies in our game. We use these categories to define whether a physics body should collide with another physics body or not. This is very useful behavior and is used in a physics game in Sprite Kit.</p><p>Following is the list of <a id="id263" class="indexterm"/>collision control properties:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">categoryBitMask</code>: This is a<a id="id264" class="indexterm"/> mask which defines the category of the physics body. We can have up to 32 different categories. With the help of a category bitmask, you can define which physics bodies should interact with each other. This property is used along with <code class="literal">contactTestBitMark</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">collisionBitMask</code>: This <a id="id265" class="indexterm"/>property is used to<a id="id266" class="indexterm"/> define the categories of physics bodies which could collide. It is used to determine whether a collision occurs using an AND operation with the other physics body. If the result is a nonzero value, this body will be affected by the collision, otherwise not. This helps you skip collision calculations in case of a minute velocity change.</li><li class="listitem" style="list-style-type: disc"><code class="literal">usesPreciseCollisionDetection: Bool</code>: If <code class="literal">true</code>, this body will be affected by the <a id="id267" class="indexterm"/>collision, otherwise it will pass through the other body in a single frame. A <code class="literal">true</code> value on either of the bodies will lead to a collision, which means that more computation power will be used by Sprite Kit to detect collisions and perform precise calculations. For very small and fast moving objects, this property can be set to <code class="literal">true</code>, otherwise the default value is <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">contactTestBitMask</code>: This <a id="id268" class="indexterm"/>property defines which category a <code class="literal">BitMask</code> physics body should notify the intersection with the receiving physics body through an AND gate operation. If the value is non-zero, the <code class="literal">SKPhysicsContact</code> object is created and passed to the physics world delegate.</li><li class="listitem" style="list-style-type: disc"><code class="literal">allContactedBodies() -&gt; [AnyObject]</code>: This is the function which is used to determine if<a id="id269" class="indexterm"/> one or more bodies is in contact with the receiving physics body. It simply returns an array of all physics body objects that are in contact with the <a id="id270" class="indexterm"/>receiving physics <a id="id271" class="indexterm"/>body, that is, the body on which this function is applied.</li></ul></div><p>These collision control properties and functions determine the behavior of two or more physics body collisions or contacts in a physics simulation. But sometimes we need to give velocity or force to a physics body for some specific behavior. The <code class="literal">SKPhysicsBody</code> class defines some functions which are used to apply force and impulse on physics bodies for this purpose.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Forces and impulses</h2></div></div></div><p>To move a space ship <a id="id272" class="indexterm"/>or a car, we need to apply<a id="id273" class="indexterm"/> force in the direction of motion; to keep it moving one has to apply force continuously. Impulse is to change the momentum of an object, for example, to fire a bullet, we need not apply any force once it starts moving.</p><p>Following is the list of functions that are used to apply force and impulse on a physics body:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func applyForce(_ force: CGVector)</code>: This function is used to apply a force on the receiving physics body. It takes <code class="literal">force</code> as a parameter and accelerates the receiving physics body without any angular acceleration.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func applyTorque(_ torque: CGFloat)</code>: This function is used to apply an angular force on the receiving physics body. It takes <code class="literal">torque</code> as a parameter and applies angular acceleration to the receiving physics body. It does not apply any linear acceleration on the receiving physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func applyForce(_ force: CGVector,atPoint point: CGPoint)</code>: This function is used to apply a force on the receiving physics body at a specific point. As it is applied on a specific point on the physics body, it could change both the angular and linear acceleration of the body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func applyImpulse(_ impulse: CGVector)</code>: This function is used to apply an impulse to the center of gravity of the receiving physics body. It takes <code class="literal">impulse</code> as a parameter and affects linear velocity, without changing angular velocity.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func applyImpulse(_ impulse: CGVector,atPoint point: CGPoint)</code>: This function is used to apply an impulse on the receiving physics body at the specific point. As it is applied on a specific point on the physics body, it could change both angular and linear velocity of the receiving physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func applyAngularImpulse(_ impulse: CGFloat)</code>: This function is used to apply<a id="id274" class="indexterm"/> an angular <a id="id275" class="indexterm"/>impulse on the receiving physics body. It takes <code class="literal">impulse</code> as a parameter and applies angular velocity on the receiving physics body. It does not apply any linear velocity on the receiving physics body.</li></ul></div><p>Along with these functions, we also need to know the resultant velocity and angular velocity of the physics body. For this purpose, the <code class="literal">SKPhysicsBody</code> class has some properties.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec49"/>The velocity of a physics body</h2></div></div></div><p>Following is the list of <a id="id276" class="indexterm"/>functions which are used to apply velocity on a physics body:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">velocity</code>: It is used to determine the linear velocity of the physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">angularVelocity</code>: It is used to determine the angular velocity of the physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">resting</code>: It determines if the physics object is at rest in the physics world. This means that it is not taking part in physics simulation, until awakened by a force or collision. This property helps reduce the calculation in physics simulation, and thus, improves the performance.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKPhysicsBody</code>: It provides us with some other important properties. Other property <code class="literal">joints</code>, this property holds an array of <code class="literal">SKPhysicsJoint</code> objects, which are connected to the receiving physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fieldBitMask</code>: This property is applied on the physics body. Once this body is inside of an <code class="literal">SKFieldNode</code> object, the <code class="literal">fieldBitMask</code> property will perform a logical AND operation with the <code class="literal">categoryBitMask</code> property of the field node. The field node's effect will be applied to this body in case of a nonzero value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">charge</code>: It is used to calculate the electromagnetic field force of an <code class="literal">SKFieldNode</code> object on the receiver's physics body.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pinned</code>: It determines whether the receiver will be fixed in position with respect to its parent or not. Its default value is <code class="literal">false</code>. If it is <code class="literal">true</code>, then the node can freely rotate around its position with respect to its parent, applying physics to our <em>Platformer</em> game.</li></ul></div><p>Now, we are going to<a id="id277" class="indexterm"/> continue with our <em>Platformer</em> game and implement various physics engine capabilities in it. Before we start to apply physics in our game, we need to first make sure that the menu scene that loads initially is <code class="literal">MenuScene</code> (as discussed in <a class="link" href="ch03.html" title="Chapter 3. Sprites">Chapter 3</a>, <em>Sprites</em>) and not <code class="literal">NodeMenuScene</code>. We will be implementing the <code class="literal">NodeMenuScene</code> class when we discuss about shaders and particle emitters.</p><p>Please go over to the <code class="literal">GameViewController.swift</code> file and in the <code class="literal">GameViewController</code> class, comment out the following:</p><div><pre class="programlisting">let menuscene = NodeMenuScene()</pre></div><p>Instead, write this:</p><div><pre class="programlisting">let menuscene = MenuScene(size: view.bounds.size, playbutton: "Play", background:"BG")</pre></div><p>The above code will make your game load the <code class="literal">MenuScene</code> class. Now, head over to the <code class="literal">GameScene.swift</code> file to add physics bodies in our game.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Using GameScene.swift to add physics bodies</h2></div></div></div><p>Start by <a id="id278" class="indexterm"/>opening your <code class="literal">GameScene.swift</code> file.</p><div><ol class="orderedlist arabic"><li class="listitem">Edit the <code class="literal">GameScene</code> class declaration to add <code class="literal">SKPhysicsContactSelegate</code> as the following:<div><pre class="programlisting">class GameScene: SKScene, SKPhysicsContactDelegate</pre></div></li><li class="listitem">Then add the following code in it:<div><pre class="programlisting">let backgroundNode = SKSpriteNode(imageNamed: "BG")
    var spriteWithoutTexture : SKSpriteNode?
    let myAtlas = SKTextureAtlas(named: "idle.atlas")
    var player:SKSpriteNode = SKSpriteNode(imageNamed:"bro5_idle0001@2x")
    var currentno = 0

    // SETTING UP "RUNNING BAR", "BLOCK 1", "Block 2
    let runningBar = SKSpriteNode(imageNamed:"bar")
    let block1 = SKSpriteNode(imageNamed:"block1")
    let block2 = SKSpriteNode(imageNamed:"block2")
    var origRunningBarPositionX = CGFloat(0)
    var maxBarX = CGFloat(0)
    var groundSpeed = 5
    var playerBaseline = CGFloat(0)
    var onGround = true

    // INITIALIZING PHYSICAL PROPERTIES VALUES
    var velocityY = CGFloat(0)
    let gravity = CGFloat(0.6)
    var blockMaxX = CGFloat(0)
    var origBlockPositionX = CGFloat(0)
    var blockStatuses:Dictionary&lt;String,BlockStatus&gt; = [:]

    //COLLISION TYPE BETWEEN "BLOCKS" AND "PLAYER"
    enum ColliderType:UInt32
    {
        case player = 1
        case Block = 2
    }</pre></div><p>If you have a<a id="id279" class="indexterm"/> look at the preceding code, you will see that we have added three new images: one is running the bar on top, which our player will run or appear to run, the other two are <code class="literal">block1</code> and <code class="literal">block2</code>. These two images are obstacles, with which our player will collide. Apart from this, we have also initialized some physical property values such as velocity, gravity, and so on. We also have defined an enum to control the collision type between <code class="literal">Blocks</code> and <code class="literal">Player</code>.</p></li><li class="listitem">Now, add<a id="id280" class="indexterm"/> this function to start the execution flow, and to define the contact delegate to detect touch/contact on the screen (touch will help us determine the jump intensity):<div><pre class="programlisting">    override func didMoveToView(view: SKView)
    {
        self.physicsWorld.contactDelegate = self

        //#1
        addBackGround()
        addRunningBar()
        addPlayer()
        addBlocks()

    }</pre></div><p>In the preceding code, the <code class="literal">#1</code> code block is used for adding the background, running bar, player, and blocks into the scene with the methods. And also for setting up the physics properties, such as <code class="literal">categoryBitMask</code>, <code class="literal">ContactTestBitMask</code>, <code class="literal">CollisionBitMask</code>, and so on.</p></li><li class="listitem">Now, add the following function to generate blocks randomly, taking a number between <code class="literal">50</code> and <code class="literal">200</code>; this is used to randomly display blocks on the screen:<div><pre class="programlisting">func random() -&gt; UInt32
    {
        var range = UInt32(50)..&lt;UInt32(200)
        return range.startIndex + arc4random_uniform(range.endIndex - range.startIndex + 1)
//CREATING BLOCKS FROM LIBRARY METHOD OF iOS
    }</pre></div></li><li class="listitem">Now, add the next function for using sprite without texture:<div><pre class="programlisting">func addSpriteWithoutTexture()
    {
        spriteWithoutTexture = SKSpriteNode(texture: nil, color:UIColor.redColor(), size: CGSizeMake(100, 100))
        addChild(spriteWithoutTexture!)
    }</pre></div></li><li class="listitem">Add the next function to insert the background in the scene:<div><pre class="programlisting">func addBackGround()
    {
        backgroundNode.zPosition = 0
        var scaleX =  self.size.width/backgroundNode.size.width
        var scaleY =  self.size.height/backgroundNode.size.height
        backgroundNode.xScale = scaleX
        backgroundNode.yScale = scaleY
        addChild(backgroundNode)
    }</pre></div></li><li class="listitem">Add the<a id="id281" class="indexterm"/> following function to define the physics property for the player/character in our game:<div><pre class="programlisting">func addPlayer()
    {

        player.zPosition = 2;
        player.name = "Player"

        // PHYSICS PROPERTIES FOR player
        self.playerBaseline = self.runningBar.position.y + (self.runningBar.size.height / 2) + (self.player.size.height / 2)
        self.player.position = CGPointMake(CGRectGetMinX(self.frame) + self.player.size.width + (self.player.size.width / 4), self.playerBaseline)
        self.player.physicsBody = SKPhysicsBody(circleOfRadius: CGFloat(self.player.size.width / 2))
        self.player.physicsBody?.affectedByGravity = false
        self.player.physicsBody?.categoryBitMask = ColliderType.player.rawValue
// Will become '1' because its defined in "ColliderType" enum
        self.player.physicsBody?.contactTestBitMask = ColliderType.Block.rawValue
        self.player.physicsBody?.collisionBitMask = ColliderType.Block.rawValue

        self.addChild(player)
    }</pre></div></li><li class="listitem">Now, set up<a id="id282" class="indexterm"/> the running bar; the bar on which the player will appear to run:<div><pre class="programlisting">func addRunningBar()
   {
        self.runningBar.anchorPoint = CGPointMake(0, 0.5)
        self.runningBar.position = CGPointMake(CGRectGetMinX(self.frame),CGRectGetMinY
(self.frame) + (self.runningBar.size.height / 2))
        self.origRunningBarPositionX = self.runningBar.position.x
        self.maxBarX = self.runningBar.size.width - self.frame.size.width
        self.maxBarX *= -1
        self.addChild(self.runningBar)
    }</pre></div></li><li class="listitem">Time to insert the following function to add the blocks in the game:<div><pre class="programlisting">func addBlocks()
    {
        // PHYSICS PROPERTIES FOR BLOCK 1
        self.block1.position = CGPointMake(CGRectGetMaxX(self.frame) + self.block1.size.width, self.playerBaseline)
        self.block2.position = CGPointMake(CGRectGetMaxX(self.frame) + self.block2.size.width, self.playerBaseline + (self.block1.size.height / 2))
        self.block1.physicsBody = SKPhysicsBody(rectangleOfSize: self.block1.size)
        self.block1.physicsBody?.dynamic = false
        self.block1.physicsBody?.categoryBitMask = ColliderType.Block.rawValue
        self.block1.physicsBody?.contactTestBitMask = ColliderType.player.rawValue
        self.block1.physicsBody?.collisionBitMask = ColliderType.player.rawValue


        // PHYSICS PROPERTIES FOR BLOCK 2
        self.block2.physicsBody = SKPhysicsBody(rectangleOfSize: self.block1.size)
        self.block2.physicsBody?.dynamic = false
        self.block2.physicsBody?.categoryBitMask = ColliderType.Block.rawValue
        self.block2.physicsBody?.contactTestBitMask = ColliderType.player.rawValue
        self.block2.physicsBody?.collisionBitMask = ColliderType.player.rawValue

        self.origBlockPositionX = self.block1.position.x //ORIGINAL BLOCK POSITION (0,0)
        self.block1.name = "block1"   // SETTING BLOCK NAMES
        self.block2.name = "block2"

        // ADDING BLOCK 1 and BLOCK 2 to DICTIONARY BLOCKSTATUS
        blockStatuses["block1"] = BlockStatus(isRunning: false, timeGapForNextRun: random(), currentInterval: UInt32(0))
        blockStatuses["block2"] = BlockStatus(isRunning: false, timeGapForNextRun: random(), currentInterval: UInt32(0))

        self.blockMaxX = 0 - self.block1.size.width / 2

        self.addChild(self.block1)
        self.addChild(self.block2)
    }</pre></div></li><li class="listitem">Add the <a id="id283" class="indexterm"/>following function, which is called when the user touches the screen. It leads the character to jump:<div><pre class="programlisting">override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches
        {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == player.name
            {
                currentno++
                //changeSpriteFromTextureAtlas()

                if self.onGround
                {
                       self.velocityY = -18.0
                       self.onGround = false
                 }
            }
        }
    }</pre></div></li><li class="listitem">Also add the next function, which is called when the screen touch is released. It will bring down the character after the jump:<div><pre class="programlisting">override func touchesEnded(touches: NSSet, withEvent event: UIEvent)
    {
        if self.velocityY &lt; -9.0    //SETTING VELOCITY FOR JUMP ACTION IS FINISHED
        {
            self.velocityY = -9.0
        }
    }</pre></div></li><li class="listitem">Add the next <a id="id284" class="indexterm"/>method to define actions to perform scene-specific updates that need to occur before the scene's actions are evaluated:<div><pre class="programlisting">override func update(currentTime: NSTimeInterval)
    {
        if self.runningBar.position.x &lt;= maxBarX
            {
                    self.runningBar.position.x = self.origRunningBarPositionX
            }

            // JUMP ACTION
            self.velocityY += self.gravity
            self.player.position.y -= velocityY
            if self.player.position.y &lt; self.playerBaseline // STOPPING PLAYER TO FALLDOWN FROM BASELINE
            {
                self.player.position.y = self.playerBaseline
                velocityY = 0.0
                self.onGround = true
            }
            //move the ground
            runningBar.position.x -= CGFloat(self.groundSpeed)
            blockRunner()

    }</pre></div></li><li class="listitem">Finally, add <a id="id285" class="indexterm"/>the following function to make the blocks run:<div><pre class="programlisting">func blockRunner()
    {
        // LOOP FOR THE DICTIONARY TO GET BLOCKS
        for(block, blockStatus) in self.blockStatuses
        {
            var thisBlock = self.childNodeWithName(block)!
            if blockStatus.shouldRunBlock()
            {
                blockStatus.timeGapForNextRun = random()
                blockStatus.currentInterval = 0
                blockStatus.isRunning = true
            }

            if blockStatus.isRunning
            {

                if thisBlock.position.x &gt; blockMaxX
// IF IT IS POSITIVE (KEEP MOVING BLOCKS FROM RIGHT TO LEFT)
                {
                    thisBlock.position.x -= CGFloat(self.groundSpeed) 
                }
                else
// IF ITS TIME TO OFF THE SCREEN ie when BLOCKS should DISAPPEAR
                {
                    thisBlock.position.x = self.origBlockPositionX
                    //blockStatus.isRunning = false
                }
            }
            else
            {
                blockStatus.currentInterval++
            }
        }
    }</pre></div></li><li class="listitem">Also <a id="id286" class="indexterm"/>create one more <code class="literal">swift</code> file by the name of <code class="literal">BlockStatus.swift</code>, in Xcode. This file contains code to initialize and run the blocks:<div><pre class="programlisting">class BlockStatus            //
{
    var isRunning = false                 //CURRENTLY RUNNING ON SCREEN OR NOT
    var timeGapForNextRun = UInt32(0)      // HOW LONG WE IT SHOULD WAIT FOR NEXT RUN
    var currentInterval = UInt32(0)         //TOTAL INTERVAL WAITED

    // INITIALIZING BLOCK STATUS
    init(isRunning:Bool, timeGapForNextRun:UInt32, currentInterval:UInt32) {
        self.isRunning = isRunning
        self.timeGapForNextRun = timeGapForNextRun
        self.currentInterval = currentInterval
    }

    // RUNNING BLOCKS
    func shouldRunBlock() -&gt; Bool
    {
        return self.currentInterval &gt; self.timeGapForNextRun
    }
}</pre></div></li><li class="listitem">Now go<a id="id287" class="indexterm"/> ahead and run the game; make sure to experiment with various values to discover the behavior of your game. This will increase your understanding of physics in Sprite Kit.<div><img src="img/4201_05_02.jpg" alt="Using GameScene.swift to add physics bodies"/></div></li></ol></div><p>And following is the second image:</p><div><img src="img/4201_05_03.jpg" alt="Using GameScene.swift to add physics bodies"/></div><p>The<a id="id288" class="indexterm"/> preceding two screenshots display the character as static and blocks as moving. We can also perform jumps by touching on the character on the screen:</p><div><img src="img/4201_05_04.jpg" alt="Using GameScene.swift to add physics bodies"/></div><p>Did you<a id="id289" class="indexterm"/> notice that the player is not running, but instead, the bar under the player and the blocks colliding with it are moving. The character just appears to be running; in this case, we have just implemented the velocity method of jumping, instead of applying force in the y-direction.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Summary</h1></div></div></div><p>In this chapter, we discussed the physics engine. We learned about <code class="literal">SKPhysicsBody</code>. Now we know very well about edge-based and volume-based physics bodies in Sprite Kit. In our game, blocks coming towards the character are volume-based bodies. We also learned about the various initialization methods for these kinds of physics bodies. We learned how to apply the physics engine of Sprite Kit in a game, so as to explore its features.</p><p>In the next chapter, we will learn about animating sprites in Sprite Kit and adding various types of controls in our game. Also, we will discuss about collisions and SceneKit integration through Sprite Kit.</p></div></body></html>