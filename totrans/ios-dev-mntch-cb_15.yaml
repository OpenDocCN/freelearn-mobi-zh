- en: Chapter 15. iOS 5 Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章 iOS 5特性
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Reproducing the page curl effect
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新生成翻页效果
- en: Styling views
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图样式
- en: Twitter integration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Twitter集成
- en: Working with the split keyboard
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与分割键盘一起工作
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The fifth major release of iOS brought over 200 new features. In this chapter,
    we will work on only a few of them, which mostly have to do with enhanced user
    experience.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的第五个主要版本带来了200多项新特性。在本章中，我们将只关注其中的一些，这些特性大多与增强用户体验有关。
- en: Specifically, we will create a project that displays content separated into
    pages, which the user can navigate through like in a normal book, with the help
    of the newly introduced UIPageViewController class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将创建一个项目，显示内容分为页面，用户可以使用新引入的UIPageViewController类像在普通书籍中一样导航这些页面。
- en: We will then discuss the UIAppearance class, which allows us to style controls
    included in our application in a more flexible and easy manner. Social sharing
    could also not be absent in today's devices, so we will create a project that
    allows the user to use Twitter, using the TWTweetComposeViewController.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论UIAppearance类，它允许我们以更灵活和简单的方式对我们的应用程序中的控件进行样式设计。在今天的设备中，社交分享也不可或缺，因此我们将创建一个项目，允许用户使用Twitter，使用TWTweetComposeViewController。
- en: In the last recipe of this chapter, we will work with the new split keyboard
    feature for the iPad, to learn how we can adjust content according to the position
    of the virtual keyboard on the screen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个小节中，我们将使用iPad的新分割键盘功能，学习如何根据屏幕上虚拟键盘的位置调整内容。
- en: Reproducing the page curl effect
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新生成翻页效果
- en: In this recipe, we will create an app that displays content like a book, with
    the help of the `UIPageViewController` class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个应用，使用`UIPageViewController`类来显示类似书籍的内容。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPhone project in MonoDevelop, and name it `BookApp`. Apart from
    the `MainController`, add another controller, and name it `Page`. Configure the
    appearance of the `Page` controller however you like. In the source code for this
    recipe, it contains a `UIImageView` and a `UILabel`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的iPhone项目，并将其命名为`BookApp`。除了`MainController`外，再添加另一个控制器，并将其命名为`Page`。根据您的喜好配置`Page`控制器的外观。在这个菜谱的源代码中，它包含一个`UIImageView`和一个`UILabel`。
- en: How to do it...
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Enter the following code in the `MainController` class:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中输入以下代码：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a property to the `Page` class, and change its constructor, as shown in
    the following code:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Page`类中添加一个属性，并修改其构造函数，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, configure the content that will be displayed in the `Page`, in the
    `ViewDidLoad` method:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`ViewDidLoad`方法中配置将在`Page`中显示的内容：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile and run the application on the simulator.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: 'Click-and-drag on the simulator''s screen area to change page. The result should
    look similar to the following screenshot:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器的屏幕区域上点击并拖动以更改页面。结果应类似于以下截图：
- en: '![How to do it...](img/1468EXP_15_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_15_01.jpg)'
- en: How it works...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `UIPageViewController` class introduced with iOS 5 was a desired component
    by many developers. It allows us to navigate through content with the effect of
    a real book, like in Apple's iBooks application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 随着iOS 5的推出，`UIPageViewController`类成为许多开发者的期望组件。它允许我们通过类似真实书籍的效果导航内容，就像在苹果的iBooks应用中一样。
- en: 'We initialize it with the following line:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下行进行初始化：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first parameter of the constructor determines the type of the effect. The
    only available value right now is `PageCurl`. The second parameter determines
    the orientation of the effect. `Horizontal` is the value for the effect similar
    to a book, while `Vertical` is the value for the effect similar to a notebook,
    where the pages are bound at the top. The third parameter determines the position
    of the bind of the book. `Min` declares that the bind is on one edge of the screen;
    in this case, on the left side.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的第一个参数确定效果的类型。目前唯一可用的值是`PageCurl`。第二个参数确定效果的方向。`Horizontal`是类似于书籍的效果的值，而`Vertical`是类似于笔记本的效果的值，其中页面在顶部绑定。第三个参数确定书籍绑定的位置。`Min`表示绑定在屏幕的一侧；在这种情况下，在左侧。
- en: 'After initializing the page controller, we need to set its first page by calling
    its `SetViewControllers` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化页面控制器后，我们需要通过调用其`SetViewControllers`方法来设置其第一个页面：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Its first parameter is an array of `UIViewController` objects. We can set either
    one or two controllers for this parameter, depending on the device orientation.
    For example, if the application supported landscape orientation, we might want
    to show two pages at the same time. The second parameter basically determines
    the navigation direction of the included pages. `Forward` means that the next
    page will be loaded if we swipe from right to left on the screen, while `Reverse`
    means that the previous page will be loaded for the same swipe. The last parameter
    is of the delegate type `UICompletionHandler` and represents the handler to be
    executed after the controllers have been added. In this example, we do not need
    it, so we just pass an empty lambda.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其第一个参数是一个`UIViewController`对象的数组。我们可以为这个参数设置一个或两个控制器，具体取决于设备方向。例如，如果应用程序支持横屏方向，我们可能希望同时显示两个页面。第二个参数基本上决定了包含页面的导航方向。`Forward`表示如果我们从右向左在屏幕上滑动，将加载下一页，而`Reverse`表示对于相同的滑动，将加载上一页。最后一个参数是`UICompletionHandler`类型，代表在控制器被添加后要执行的处理器。在这个例子中，我们不需要它，所以我们只传递一个空的lambda。
- en: 'Next, we need to provide the data source for the rest of the pages of our "book".
    Once again, MonoTouch simplifies things for us by providing two very helpful properties
    for us to use: `GetNextViewController` and `GetPreviousViewController`. These
    properties merely represent the callback methods we would have to override if
    we were creating a `Delegate` object for the page controller. Apart from their
    names, the signatures of these two methods are identical:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的“书籍”其余页面提供数据源。MonoTouch再次为我们简化了事情，提供了两个非常有用的属性供我们使用：`GetNextViewController`和`GetPreviousViewController`。这两个属性仅仅代表了如果我们要为页面控制器创建一个`Delegate`对象时需要重写的回调方法。除了它们的名称外，这两个方法的签名是相同的：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first parameter gives us the page controller, while the second parameter
    gives us the controller that is currently displayed on screen when the method
    is called.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数给出了页面控制器，而第二个参数给出了在调用此方法时屏幕上当前显示的控制器。
- en: In the implementation of these methods, we simply have to return the controller
    that should be loaded next, or before the current one. If we do not want the effect
    to be activated, we just return `null`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法的实现中，我们只需返回应该加载的下一个控制器，或者当前控制器之前的一个。如果我们不希望激活效果，我们只需返回`null`。
- en: 'Last but not least, we set the size of the page controller''s view and add
    it to a superview, so that it will be displayed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们设置了页面控制器的视图大小，并将其添加到父视图中，以便它将被显示：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we would like our application to support landscape orientation, we would
    first have to implement the `ShouldAutoRotateToInterfaceOrientation` method in
    the `MainController` class, returning `true` from it for the orientation we wish
    to support. Secondly, we would have to provide two view controllers to the `SetViewControllers`
    method of the `UIPageViewController` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的应用程序支持横屏方向，我们首先必须在`MainController`类中实现`ShouldAutoRotateToInterfaceOrientation`方法，并从它返回我们希望支持的横屏方向。其次，我们必须为`UIPageViewController`类的`SetViewControllers`方法提供两个视图控制器。
- en: Double sided pages
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双面页面
- en: As you might have noticed in the screenshot of this recipe, when we turn a page,
    its content is displayed in reverse on the page's back, like when we see through
    a page in real books. We have the option of creating double-sided pages by setting
    the `UIPageViewController.DoubleSided` property to `true`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在菜谱的截图中所注意到的，当我们翻页时，其内容在页面的背面以相反的方式显示，就像我们通过真实书籍的一页看过去一样。我们有选项通过将`UIPageViewController.DoubleSided`属性设置为`true`来创建双面页面。
- en: Styling views
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图样式
- en: In this recipe, we will discover how we can easily style buttons across our
    application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将发现如何轻松地在我们应用程序中设置按钮样式。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `StyleButtonsApp`. Add the
    `MainController` and another controller with the name `ModalController`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`StyleButtonsApp`。添加`MainController`和另一个名为`ModalController`的控制器。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add one button on each of the controllers. In the `MainController` class, implement
    the `ViewDidLoad` method with the following code:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个控制器上添加一个按钮。在`MainController`类中，实现`ViewDidLoad`方法，代码如下：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `ViewDidLoad` method of the `ModalController` class, to dismiss
    it when the button is tapped:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ModalController`类的`ViewDidLoad`方法，以便在按钮被点击时关闭它：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Compile and run the application on the simulator.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the **Present** button to display the modal controller. Note that the
    buttons of both the `MainController` and `ModalController` have the same background
    color and text color.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示**按钮以显示模态控制器。注意，`MainController`和`ModalController`的按钮具有相同的背景颜色和文字颜色。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make all the buttons in our application look the same, we use the `Appearance`
    static property of the `UIButton` class. This property returns the object that
    inherits the `UIAppearance` class, which is the class that reflects the Objective-C
    `UIAppearance` protocol to MonoTouch.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序中的所有按钮看起来相同，我们使用`UIButton`类的`Appearance`静态属性。此属性返回继承自`UIAppearance`类的对象，这是将Objective-C的`UIAppearance`协议反映到MonoTouch中的类。
- en: This way, we have an `Appearance` static property for all views that support
    it, strongly-typed according to the view we want to style. For the `UIButton`,
    the `Appearance` property returns a `UIButtonAppearance` object. After we set
    the values we want in this object, all instances of `UIButton` in the application
    will share the same styling.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们为所有支持它的视图都有一个`Appearance`静态属性，根据我们想要样式的视图进行强类型化。对于`UIButton`，`Appearance`属性返回一个`UIButtonAppearance`对象。在设置好这个对象中的值后，应用程序中所有`UIButton`实例将共享相同的样式。
- en: So, in this example, as shown in the highlighted code, we set the background
    color and text color we want all of our buttons to have, and the runtime takes
    care of the rest for us.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，如高亮代码所示，我们设置了我们希望所有按钮都具有的背景颜色和文字颜色，运行时将为我们处理其余部分。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Styling our controls globally in our application is a very nice feature, but
    one might agree that it is a bit limiting. What if we wanted to style specific
    `UIButtons` in our application, instead of all? Consider the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中全局样式化控件是一个非常不错的功能，但有人可能会同意它有点限制。如果我们只想样式化特定的`UIButtons`而不是所有按钮怎么办？考虑以下代码：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AppearanceWhenContainedIn` method returns the corresponding `UIAppearance`
    object, in this case `UIButtonAppearance`, and accepts a variable number of parameters
    of the type `System.Type` (params `Type[] containers)`. This code will style only
    instances of `UIButton` that are contained in `ModalController` objects only.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppearanceWhenContainedIn`方法返回相应的`UIAppearance`对象，在这种情况下是`UIButtonAppearance`，并接受一个类型为`System.Type`的可变数量的参数（params
    `Type[] containers）`）。此代码将仅样式化包含在`ModalController`对象中的`UIButton`实例。'
- en: Although the number of parameters of the method is variable, the sequence of
    `Type` objects that we pass determines its behavior. For example, the following
    call would apply the styles we set to instances of `UIButton` contained in `ModalController`,
    only when `ModalController` is contained in `MainController`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该方法参数的数量是可变的，但我们传递的`Type`对象序列决定了其行为。例如，以下调用将只在我们将`ModalController`包含在`MainController`中时，将我们设置的样式应用到`ModalController`中包含的`UIButton`实例。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Specific properties
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定属性
- en: Every class that inherits from `UIView` inherits the `UIAppearance` class. However,
    not all properties of each class support it. For example, through the `UIButtonAppearance`
    object, we can set the background color of every `UIButton` in our application,
    but we cannot set the title.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自`UIView`的每个类都继承自`UIAppearance`类。然而，并非每个类的所有属性都支持它。例如，通过`UIButtonAppearance`对象，我们可以设置应用程序中每个`UIButton`的背景颜色，但不能设置标题。
- en: Twitter integration
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twitter集成
- en: In this recipe, we will create an application that implements Twitter sharing,
    to allow the user to send tweets.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个实现Twitter分享的应用程序，允许用户发送推文。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `TweetApp`. Add the `MainController`
    to the project.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`TweetApp`。将`MainController`添加到项目中。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a button on the view of `MainController` and the `MonoTouch.Twitter` namespace
    in the class. Next, enter the following code:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加一个按钮，并在类中输入`MonoTouch.Twitter`命名空间。接下来，输入以下代码：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compile and run the application on the simulator. If a Twitter account has not
    been set on the simulator, it can easily be configured through the `Settings`
    application.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。如果模拟器上尚未设置Twitter账户，可以通过`Settings`应用程序轻松配置。
- en: 'Tap the button to present the Twitter controller. The result should be similar
    to the following screenshot:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮以显示Twitter控制器。结果应该类似于以下截图：
- en: '![How to do it...](img/1468EXP_15_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_15_02.jpg)'
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: iOS provides the `TWTweetComposeViewController` class that provides the sharing
    functionality. This controller's is the same as the native interface that is used
    to share a photo from the device album. Just like similar native controllers,
    we can only set its content before it is presented. We cannot make modifications
    to it after it has been displayed to the user, and the user is responsible whether
    to send it or discard it.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 提供了 `TWTweetComposeViewController` 类，它提供了共享功能。此控制器与用于从设备相册共享照片的原生界面相同。就像类似的本地控制器一样，我们只能在它呈现之前设置其内容。我们无法在它向用户显示后对其进行修改，用户负责是否发送或丢弃它。
- en: 'We can determine if the user has configured a Twitter account on the device
    by reading the `CanSendTweet` static property:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取 `CanSendTweet` 静态属性来确定用户是否在设备上配置了 Twitter 账户：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we present the controller without an account set on the device, a native
    alert will be presented, giving the user the option to configure an account before
    proceeding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在设备上未设置账户的情况下呈现控制器，将显示一个原生警报，用户可以选择在继续之前配置账户。
- en: 'We then initialize the controller and set the text to be filled, if we wish,
    with the `SetInitialText` method:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们初始化控制器，并使用 `SetInitialText` 方法设置要填充的文本，如果需要的话：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We also have the option of adding URLs or images in the tweet, with the `AddUrl`
    and `AddImage` methods, respectively.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `AddUrl` 和 `AddImage` 方法分别添加推文中的 URL 或图片。
- en: 'In order to get feedback of whether the user has sent or cancelled the tweet,
    we call the `SetCompletionHandler` method, passing the callback to be called:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取用户是否发送或取消推文的反馈，我们调用 `SetCompletionHandler` 方法，传递要调用的回调：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This callback accepts one parameter of the enumeration type `TWTweetComposeViewControllerResult`,
    and it can contain either of the two values `Done` or `Cancelled`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此回调接受枚举类型 `TWTweetComposeViewControllerResult` 的一个参数，它可以包含两个值中的任意一个 `Done` 或
    `Cancelled`。
- en: Last but not least, we should dismiss the controller in the callback.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们应该在回调中关闭控制器。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Manually dismissing the `TWTweetComposeViewController` is not a requirement.
    If we do not dismiss it manually, however, it has been noticed that although the
    controller is dismissed when the user tapped on **Send**, it takes two taps on
    the **Cancel** button to dismiss it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 手动关闭 `TWTweetComposeViewController` 不是必需的。然而，如果没有手动关闭它，已经注意到尽管在用户点击 **Send**
    时控制器被关闭，但需要两次点击 **Cancel** 按钮才能关闭它。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from sending tweets, the `MonoTouch.Twitter` namespace also wraps the
    `TWRequest` class that allows us to read Twitter information, such as the user's
    timeline, through Twitter API URLs. Data received this way are in the form of
    JSON objects, and it is our responsibility of reading them properly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了发送推文外，`MonoTouch.Twitter` 命名空间还封装了 `TWRequest` 类，允许我们通过 Twitter API URL 读取
    Twitter 信息，例如用户的推文时间线。通过这种方式接收到的数据是以 JSON 对象的形式，正确读取它们是我们的责任。
- en: Supporting landscape orientation
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持横幅方向
- en: The `TWTweetComposeViewController` supports landscape orientation. To enable
    it, we just have to override the `ShouldAutoRotateToInterfaceOrientation` method
    in the controller that presents it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`TWTweetComposeViewController` 支持横幅方向。要启用它，我们只需覆盖呈现它的控制器中的 `ShouldAutoRotateToInterfaceOrientation`
    方法。'
- en: Working with the split keyboard
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与分割键盘一起工作
- en: In this recipe, we will create an iPad application that is aware of the changes
    to the positioning of the virtual keyboard, to adjust our content accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个能够感知虚拟键盘位置变化的应用程序，以便相应地调整我们的内容。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPad project in MonoDevelop, and name it `SplitKeyboardApp`. Add
    the `MainController` to the project.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的 iPad 项目，并将其命名为 `SplitKeyboardApp`。将 `MainController` 添加到项目中。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add a `UITextField,` and position it at the center of `MainController`. Resize
    the text field so that its width expands across the screen. Add the following
    code in the `MainController` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `UITextField`，并将其放置在 `MainController` 的中心位置。调整文本框的大小，使其宽度扩展到屏幕的另一侧。在 `MainController`
    类中添加以下代码：
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compile and run the application on the simulator.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the text field to show the keyboard. If the keyboard on the iPad simulator
    has not been previously used, it will default to its normal state, which is at
    the bottom and merged.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本框以显示键盘。如果之前未在 iPad 模拟器中使用过键盘，它将默认处于正常状态，即在底部并合并。
- en: Tap-and-drag the **hide keyboard** key at the bottom-right corner to move the
    keyboard, so that it splits, and leave it over the text field.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击并拖动屏幕右下角的**隐藏键盘**键来移动键盘，使其分裂，并让它停留在文本字段上方。
- en: '![How to do it...](img/1468EXP_15_03.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_15_03.jpg)'
- en: 'Watch the text field animate right above the keyboard. The result should be
    similar to the following screenshot:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察文本字段在键盘上方动画。结果应该类似于以下截图：
- en: '![How to do it...](img/1468EXP_15_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_15_04.jpg)'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To detect the position of the split keyboard, we first need to add an observer
    for the `UIKeyboardDidChangeFrameNotification` key:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测分裂键盘的位置，我们首先需要为`UIKeyboardDidChangeFrameNotification`键添加一个观察者：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Inside the `KeyboardFrameChanged` callback, we get the value of the `FrameEndUserInfoKey`
    key from the `UserInfo` dictionary. This value, returned as an `NSObject`, is
    actually an `NSValue` object that contains the frame of the keyboard. We read
    the `RectangleFValue` property from it to get the `RectangleF` object that holds
    the frame values of the keyboard:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`KeyboardFrameChanged`回调内部，我们从`UserInfo`字典中获取`FrameEndUserInfoKey`键的值。这个值，作为一个`NSObject`返回，实际上是一个包含键盘框架的`NSValue`对象。我们从它中读取`RectangleFValue`属性，以获取包含键盘框架值的`RectangleF`对象：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rest of the code moves the text field above the keyboard. Change it as you
    please!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码将文本字段移动到键盘上方。请随意更改它！
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `UserInfo` property of the `NSNotification` class returns an `NSDictionary`
    object, which contains various information about the keyboard. To enumerate the
    keys it contains, a simple `foreach` will do:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSNotification`类的`UserInfo`属性返回一个`NSDictionary`对象，其中包含有关键盘的各种信息。为了枚举它包含的键，简单的`foreach`即可：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Problems moving the keyboard?
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移动键盘有问题？
- en: The hide keyboard key presents a small "context menu" when we tap and hold on
    it. This menu gives us the option of docking and merging (or the opposite) the
    keyboard. To move the keyboard in the position we want, we have to start dragging
    as soon as we tap on the key.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏键盘键在我们长按它时会出现一个小的“上下文菜单”。这个菜单提供了停靠和合并（或相反操作）键盘的选项。为了将键盘移动到我们想要的位置，我们必须在点击键的瞬间就开始拖动。
