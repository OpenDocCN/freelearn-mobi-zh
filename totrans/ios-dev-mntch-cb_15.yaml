- en: Chapter 15. iOS 5 Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Reproducing the page curl effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the split keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fifth major release of iOS brought over 200 new features. In this chapter,
    we will work on only a few of them, which mostly have to do with enhanced user
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we will create a project that displays content separated into
    pages, which the user can navigate through like in a normal book, with the help
    of the newly introduced UIPageViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: We will then discuss the UIAppearance class, which allows us to style controls
    included in our application in a more flexible and easy manner. Social sharing
    could also not be absent in today's devices, so we will create a project that
    allows the user to use Twitter, using the TWTweetComposeViewController.
  prefs: []
  type: TYPE_NORMAL
- en: In the last recipe of this chapter, we will work with the new split keyboard
    feature for the iPad, to learn how we can adjust content according to the position
    of the virtual keyboard on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Reproducing the page curl effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an app that displays content like a book, with
    the help of the `UIPageViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPhone project in MonoDevelop, and name it `BookApp`. Apart from
    the `MainController`, add another controller, and name it `Page`. Configure the
    appearance of the `Page` controller however you like. In the source code for this
    recipe, it contains a `UIImageView` and a `UILabel`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Enter the following code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a property to the `Page` class, and change its constructor, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, configure the content that will be displayed in the `Page`, in the
    `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click-and-drag on the simulator''s screen area to change page. The result should
    look similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIPageViewController` class introduced with iOS 5 was a desired component
    by many developers. It allows us to navigate through content with the effect of
    a real book, like in Apple's iBooks application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize it with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of the constructor determines the type of the effect. The
    only available value right now is `PageCurl`. The second parameter determines
    the orientation of the effect. `Horizontal` is the value for the effect similar
    to a book, while `Vertical` is the value for the effect similar to a notebook,
    where the pages are bound at the top. The third parameter determines the position
    of the bind of the book. `Min` declares that the bind is on one edge of the screen;
    in this case, on the left side.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing the page controller, we need to set its first page by calling
    its `SetViewControllers` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Its first parameter is an array of `UIViewController` objects. We can set either
    one or two controllers for this parameter, depending on the device orientation.
    For example, if the application supported landscape orientation, we might want
    to show two pages at the same time. The second parameter basically determines
    the navigation direction of the included pages. `Forward` means that the next
    page will be loaded if we swipe from right to left on the screen, while `Reverse`
    means that the previous page will be loaded for the same swipe. The last parameter
    is of the delegate type `UICompletionHandler` and represents the handler to be
    executed after the controllers have been added. In this example, we do not need
    it, so we just pass an empty lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to provide the data source for the rest of the pages of our "book".
    Once again, MonoTouch simplifies things for us by providing two very helpful properties
    for us to use: `GetNextViewController` and `GetPreviousViewController`. These
    properties merely represent the callback methods we would have to override if
    we were creating a `Delegate` object for the page controller. Apart from their
    names, the signatures of these two methods are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter gives us the page controller, while the second parameter
    gives us the controller that is currently displayed on screen when the method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the implementation of these methods, we simply have to return the controller
    that should be loaded next, or before the current one. If we do not want the effect
    to be activated, we just return `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, we set the size of the page controller''s view and add
    it to a superview, so that it will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we would like our application to support landscape orientation, we would
    first have to implement the `ShouldAutoRotateToInterfaceOrientation` method in
    the `MainController` class, returning `true` from it for the orientation we wish
    to support. Secondly, we would have to provide two view controllers to the `SetViewControllers`
    method of the `UIPageViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Double sided pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might have noticed in the screenshot of this recipe, when we turn a page,
    its content is displayed in reverse on the page's back, like when we see through
    a page in real books. We have the option of creating double-sided pages by setting
    the `UIPageViewController.DoubleSided` property to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Styling views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discover how we can easily style buttons across our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `StyleButtonsApp`. Add the
    `MainController` and another controller with the name `ModalController`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add one button on each of the controllers. In the `MainController` class, implement
    the `ViewDidLoad` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ViewDidLoad` method of the `ModalController` class, to dismiss
    it when the button is tapped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the **Present** button to display the modal controller. Note that the
    buttons of both the `MainController` and `ModalController` have the same background
    color and text color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make all the buttons in our application look the same, we use the `Appearance`
    static property of the `UIButton` class. This property returns the object that
    inherits the `UIAppearance` class, which is the class that reflects the Objective-C
    `UIAppearance` protocol to MonoTouch.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we have an `Appearance` static property for all views that support
    it, strongly-typed according to the view we want to style. For the `UIButton`,
    the `Appearance` property returns a `UIButtonAppearance` object. After we set
    the values we want in this object, all instances of `UIButton` in the application
    will share the same styling.
  prefs: []
  type: TYPE_NORMAL
- en: So, in this example, as shown in the highlighted code, we set the background
    color and text color we want all of our buttons to have, and the runtime takes
    care of the rest for us.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Styling our controls globally in our application is a very nice feature, but
    one might agree that it is a bit limiting. What if we wanted to style specific
    `UIButtons` in our application, instead of all? Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `AppearanceWhenContainedIn` method returns the corresponding `UIAppearance`
    object, in this case `UIButtonAppearance`, and accepts a variable number of parameters
    of the type `System.Type` (params `Type[] containers)`. This code will style only
    instances of `UIButton` that are contained in `ModalController` objects only.
  prefs: []
  type: TYPE_NORMAL
- en: Although the number of parameters of the method is variable, the sequence of
    `Type` objects that we pass determines its behavior. For example, the following
    call would apply the styles we set to instances of `UIButton` contained in `ModalController`,
    only when `ModalController` is contained in `MainController`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Specific properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every class that inherits from `UIView` inherits the `UIAppearance` class. However,
    not all properties of each class support it. For example, through the `UIButtonAppearance`
    object, we can set the background color of every `UIButton` in our application,
    but we cannot set the title.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an application that implements Twitter sharing,
    to allow the user to send tweets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `TweetApp`. Add the `MainController`
    to the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a button on the view of `MainController` and the `MonoTouch.Twitter` namespace
    in the class. Next, enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator. If a Twitter account has not
    been set on the simulator, it can easily be configured through the `Settings`
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Tap the button to present the Twitter controller. The result should be similar
    to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: iOS provides the `TWTweetComposeViewController` class that provides the sharing
    functionality. This controller's is the same as the native interface that is used
    to share a photo from the device album. Just like similar native controllers,
    we can only set its content before it is presented. We cannot make modifications
    to it after it has been displayed to the user, and the user is responsible whether
    to send it or discard it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can determine if the user has configured a Twitter account on the device
    by reading the `CanSendTweet` static property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we present the controller without an account set on the device, a native
    alert will be presented, giving the user the option to configure an account before
    proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then initialize the controller and set the text to be filled, if we wish,
    with the `SetInitialText` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We also have the option of adding URLs or images in the tweet, with the `AddUrl`
    and `AddImage` methods, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get feedback of whether the user has sent or cancelled the tweet,
    we call the `SetCompletionHandler` method, passing the callback to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This callback accepts one parameter of the enumeration type `TWTweetComposeViewControllerResult`,
    and it can contain either of the two values `Done` or `Cancelled`.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we should dismiss the controller in the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Manually dismissing the `TWTweetComposeViewController` is not a requirement.
    If we do not dismiss it manually, however, it has been noticed that although the
    controller is dismissed when the user tapped on **Send**, it takes two taps on
    the **Cancel** button to dismiss it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from sending tweets, the `MonoTouch.Twitter` namespace also wraps the
    `TWRequest` class that allows us to read Twitter information, such as the user's
    timeline, through Twitter API URLs. Data received this way are in the form of
    JSON objects, and it is our responsibility of reading them properly.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting landscape orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TWTweetComposeViewController` supports landscape orientation. To enable
    it, we just have to override the `ShouldAutoRotateToInterfaceOrientation` method
    in the controller that presents it.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the split keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create an iPad application that is aware of the changes
    to the positioning of the virtual keyboard, to adjust our content accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new iPad project in MonoDevelop, and name it `SplitKeyboardApp`. Add
    the `MainController` to the project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a `UITextField,` and position it at the center of `MainController`. Resize
    the text field so that its width expands across the screen. Add the following
    code in the `MainController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap on the text field to show the keyboard. If the keyboard on the iPad simulator
    has not been previously used, it will default to its normal state, which is at
    the bottom and merged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap-and-drag the **hide keyboard** key at the bottom-right corner to move the
    keyboard, so that it splits, and leave it over the text field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Watch the text field animate right above the keyboard. The result should be
    similar to the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To detect the position of the split keyboard, we first need to add an observer
    for the `UIKeyboardDidChangeFrameNotification` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `KeyboardFrameChanged` callback, we get the value of the `FrameEndUserInfoKey`
    key from the `UserInfo` dictionary. This value, returned as an `NSObject`, is
    actually an `NSValue` object that contains the frame of the keyboard. We read
    the `RectangleFValue` property from it to get the `RectangleF` object that holds
    the frame values of the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code moves the text field above the keyboard. Change it as you
    please!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UserInfo` property of the `NSNotification` class returns an `NSDictionary`
    object, which contains various information about the keyboard. To enumerate the
    keys it contains, a simple `foreach` will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Problems moving the keyboard?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The hide keyboard key presents a small "context menu" when we tap and hold on
    it. This menu gives us the option of docking and merging (or the opposite) the
    keyboard. To move the keyboard in the position we want, we have to start dragging
    as soon as we tap on the key.
  prefs: []
  type: TYPE_NORMAL
