- en: Widgets, Widgets Everywhere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Flutter, the concept of widgets is very important. As stated in [Chapter
    1](6f964d6d-1e08-460b-9c4b-79023fa9816d.xhtml), *Introducing Flutter*, everything
    in Flutter is a widget. You might have a lot of questions about widgets, such
    as "What are the basic types of widgets?", "How do I create one?", "What are some
    good example of widgets?",and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore these questions together. We will first take
    a look at the widgets catalog and understand the fundamental widgets that will
    help you build apps with Flutter. We will also learn how to create custom widgets
    and then take a look at the concept of routing and navigating in a Flutter app.
    All of these topics will be covered in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Widgets Catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing and navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Widgets Catalog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Flutter team built this very good website called the **Widgets Catalog** ([https://flutter.io/widgets/](https://flutter.io/widgets/))
    where you can explore the variety of components that already exist in Flutter,
    divided by category. You will be using a lot of these widgets in your applications,
    so the more you know about them, the more efficiently you can use them in your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few fundamental widgets listed that will help you get
    familiar with the types of widgets you will find in the Widgets Catalog. The following
    is a list of those widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Container`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Icon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RaisedButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scaffold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Appbar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlaceHolder`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Row`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Column`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these widgets one by one in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the complex widgets in the catalog. It is used to contain a child
    widget within your parent widget, which it does by applying some styling properties
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: A container makes it possible to apply a variety of features, for example, background
    color, aligning the child within the container, setting some constraints to the
    size of the child, and applying some decoration or transformation property to
    the child (for example, you can rotate a widget). When we look at the amount of
    things you can do with this widget, it can be considered a complex widget. But
    in most cases, we will need only a couple of its features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the code to display the widget. The code will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69d034f0-00c5-4654-b184-efd3d15efff3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, you will need to show a widget based on a conditional expression—for
    example, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the conditional expression for a container. It works
    like most of the conditional expressions, where if the condition is true, you
    will get your regular widget. But if the condition is false, you will get something
    called a**null** widget.
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Displaying images on your application is one feature that your app must have.
    There are hardly any apps today that lack the functionality to display an image.
    And, to do this, the image widget comes into the picture. We can use the following
    code to use an image widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be displayed when you use the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/464b9cba-65c7-4b61-95bc-76167d9db23b.png)'
  prefs: []
  type: TYPE_IMG
- en: You can explore the several constructors it has to offer, but I suggest that
    you try and use them depending on the source you want to use. For example, if
    you have an `imageProvider`, you will use the default constructor, but if you
    have the image in an `AssetBundle`, you should use the `Image.asset` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an image-displaying widget, and images come in a few different formats.
    Here''s the list of image formats supported by the image widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '`JPEG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PNG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GIF`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animated GIF`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WebP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Animated WebP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BMP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WBMP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This widget is as self-explanatory as the last one. It is used for displaying
    text on the screen with a single style. We can also display the text on a single
    line or multiple lines; this depends on the layout constraints. The style argument
    when using this widget is optional. If the style argument is not provided, the
    widget will use the style from enclosing `DefaultTextStyle`, and if the provided
    style's `TextStyle.inherit` property is true, the given style will be merged with
    the default one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used for using a text widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot will display how the widget is displayed on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f16ef43-e15f-4e4c-a4b5-79fe15e8a754.png)'
  prefs: []
  type: TYPE_IMG
- en: There may be instances when you want to do more with this text widget. For example,
    to apply more than one style (to display some bold words in a line) to text, you
    can use the `TextSpan.rich` constructor, or to add interactivity to the text,
    you can use use a `GestureDetector`.
  prefs: []
  type: TYPE_NORMAL
- en: I would suggest using `FlatButton`, instead of a text widget for interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Icon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The icon widget is used to draw an icon using the font described in `IconData`,
    such as a material's predefined `IconData` in the `Icon` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to use the `Icon` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot displaying how the `Icon` widget looks on the
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c2a4a8a-fe6a-4bef-bd9f-3ce6c596047c.png)'
  prefs: []
  type: TYPE_IMG
- en: Just like the text widget, we can add interactivity with the `Icon` widget too.
    To do that, we can use `GestureDetector`.
  prefs: []
  type: TYPE_NORMAL
- en: RaisedButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This widget is used to display a simple elevated button. The button is elevated
    because the button is based on a material widget whose elevation increases when
    the button is pressed. If the `onPressed` callback is null, then the button will
    be disabled, and it will resemble a flat button in `disabledColor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to use the `RaisedButton` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot will be displayed when you use the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/37aa21dd-e07c-4788-b2b8-44b595ad7183.png)'
  prefs: []
  type: TYPE_IMG
- en: The suggestion is to use `RaisedButton` to add dimension in otherwise mostly
    flat layouts. I would recommend not using such a button in a dialog or a card.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffold
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scaffold** is a basic layout structure based on material design. In practice,
    if you use material design, every screen of your app will have a `Scaffold` as
    its base. The `Scaffold` widget is used for showing drawers, snackbars, bottomsheets,
    floating-action buttons, and so on, by offering APIs. To display a snackbar or
    a bottomsheet, you must use `Scaffoldstate` for the current context. We can use
    it via `Scaffold.of` and use the `ScaffoldState.showSnackbar` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to display a `snackbar` using `Scaffold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output that will be displayed using the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/996b8ed0-4a35-47dd-b1fb-46f363220e03.png)'
  prefs: []
  type: TYPE_IMG
- en: AppBar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`AppBar` is basically used as a property of `Scaffold`, and the majority of
    `Scaffold`s have app bars. The app bar consists of a toolbar and potentially other
    widgets. For example, it can host `TabBar`, `FlexibleSpaceBar`, or some actions
    optionally followed by `PopupMenuButton` for less common operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The property that''s used for `AppBar` is `Scaffold.appBar`. It looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/657a576e-36b4-479d-a94c-d2e09baf555e.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram displays where each widget will be placed by the `appBar`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: If the leading widget is omitted and `Scaffold` has a drawer, then `appBar`
    will place a button to open the drawer. If the nearest navigator has any previous
    routes, a `BackButton` will be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: PlaceHolder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`PlaceHolder` is another widget that explains itself through its name. The
    `PlaceHolder` widget is used for holding a place for a widget. It draws a box
    that represents where other widgets will be added later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used for a `PlaceHolder` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c622dd11-9e66-49fc-ab3d-c93292da18e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Column
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Column` is essential for composing layout in Flutter apps. It displays its
    children in a vertical array. The following code can be used for the `Column`
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba02c14e-4061-43f2-926c-5dd57b6223bc.png)'
  prefs: []
  type: TYPE_IMG
- en: The `Column` widget, however, does not support scrolling; for that, we can use
    `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it will be considered as an error by the system if you have more children
    in a column that will fit into the available room. That's because the column doesn't
    have the ability to recycle the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Row
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Row` widget is similar to the `Column` widget, but still different. We
    can say that it is the horizontal version of `column`. It draws the children in
    a horizontal array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used for a `Row` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a31ab713-91b4-48a4-a69f-61fda765c3af.png)'
  prefs: []
  type: TYPE_IMG
- en: The story in regard to scrolling remains the same as for the `Column` widget.
    It is recommended to use `ListView` if you want to scroll the children.
  prefs: []
  type: TYPE_NORMAL
- en: ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ListView` behaves similar to a column or a row; the only difference is that
    its children can be scrolled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three constructors for the `ListView` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: The default takes a list of widgets in its children property. This is a good
    choice for small lists because to build it, the list will process every child.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView.builder` takes an indexed builder to build the children on demand.
    This is the choice to pick if you have a large number of children, because every
    time the list processes only the visible children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView.custom` takes `SliverChildDelegate`, which provides the ability to
    customize more aspects of `ListView`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A note about Row, Column, and ListView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it can happen that you get a runtime exception at the time of building
    a row or a column that's been placed in another row/column or in any scenario
    that does not provide a maximum height constraint.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the inner widget should fill all the remaining space, but
    the outer widget has no specific size and should fill the available space too.
    So, they can't understand where to stop, and then an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve such a problem, you must understand why the inner column/row is receiving
    unbounded constraints. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the column/row is placed in another column/row, you can try to wrap the inner
    widget in an expanded widget, indicating that it should take the remaining space
    of the outer widget and not all the space it desires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the widget is placed in a `Listview` and is wrapped in an expanded or flexible, then
    that key is to remove that wrapping widget and to set the size of the inner widget
    manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another problem you may have to encounter the yellow-and-black-striped banner
    as shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1cbd5007-fc27-4e4c-b7de-813e4ee51547.png)'
  prefs: []
  type: TYPE_IMG
- en: This banner indicates that a row or column overflows its size. The solution
    is to use `ListView` and let the content scroll, or just to reduce the size of
    the children.
  prefs: []
  type: TYPE_NORMAL
- en: Creating widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw a number of widgets in the previous section, but there might be a possibility
    that you don't find the right ready-to-use widget that you want or that you want
    to combine more widgets in order to create a reusable group. Therefore, you have
    to create a custom widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of widget in Flutter that you can use to create your own
    custom widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at them in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stateless widgets** remain the same even if the user interacts with them.
    This kind of widget has no state, so they can''t change according to an internal
    state. They can only react to higher widget changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a stateless widget, we will extend the `StatelessWidget` abstract
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Stateful widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Stateful widgets** are dynamic components that have an internal state to
    manage. A stateful widget can react to state changes and change accordingly. The
    state is stored in a `State` object. To create a `StatefulWidget`, you have to
    extend the `StatefulWidget` abstract class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The state will be a class extending the `State<T extends StatefulWidget>` abstract
    class. Let''s take a look at example where the widget changes the background color
    according to its state. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To trigger the framework to rebuild the widget and apply the changes, you have
    to call the `setState()` function, or it won't see any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Routing and navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just looked at how to use widgets, but you won't be using just one widget.
    In a typical application, it's normal to find more than one screen. When an application
    has more than one screen, it is essential for the users to have a clear route
    to move through those pages, and to do so routing and navigating through the pages
    becomes very important for your application.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, if you are from an Android background, you would use more activities
    or fragments, and in iOS, you would create a new `viewControllers`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Flutter world, new screens are widgets! To navigate to a new route,
    we can use the `Navigator.push()` function, passing as an argument the current
    context and a new `MaterialPageRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SecondScreen` will be a normal widget that builds the screen. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To navigate back, we will use another function of the navigator: `Navigator.pop()`.
    This function will remove the current route from the stack of routes that are
    managed by the navigator. We can also use this function to return a value to the
    users when moving through the screen. Let's take a look at this in detail in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a value when navigating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Returning a value to the readers when moving from one screen to another screen
    can improve the user experience of your application. For example, just a simple
    `welcome` on the screen when opening an app, will increase the user experience.
    For this purpose, in Flutter, we have `Navigator.pop()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Navigator.pop()` takes the current context as an argument, but it has an optional
    dynamic argument. This means that you can return any value when popping a screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look at the return value of `Navigator.push()`, you can see that it
    returns a `Future<dynamic>`. So, when pushing a new screen, you can wait for the
    popped return value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ConfirmationScreen` will be as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went through the widget catalog; this catalog consists of
    a number basic widgets that we can start using instantly in our applications without
    building our own widgets. It is good to understand these basic widgets, as you
    will be using them in your application a lot. But there will be times when you
    will need a customized widget, to help you with that we went through stateless
    and stateful widgets, that will help you customize your widgets. And, finally,
    we learned how to navigate and route through those widgets.
  prefs: []
  type: TYPE_NORMAL
- en: What's next? There are more and more widgets you can use to build your apps.
    In the next chapter, we'll see some of them that can be used to build beautiful
    layouts.
  prefs: []
  type: TYPE_NORMAL
