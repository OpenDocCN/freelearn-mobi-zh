<html><head></head><body>
		<div id="_idContainer224">
			<h1 id="_idParaDest-247" class="chapter number"><a id="_idTextAnchor789"/>15</h1>
			<h1 id="_idParaDest-248">Architecture Patterns<a id="_idTextAnchor790"/></h1>
			<p>This chapter will introduce you to architectural patterns you can use for your Android projects. It covers <a id="_idIndexMarker1268"/>using the <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) pattern, adding ViewModels, and using data binding. You will also learn about using the Repository pattern for caching data and WorkManager for scheduling data retrieval <span class="No-Break">and storage.</span></p>
			<p>By the end of the chapter, you will be able to structure your Android project using MVVM and data binding. You will also be able to use the Repository pattern with the Room library to cache data and WorkManager to fetch and save data at a <span class="No-Break">scheduled interval<a id="_idTextAnchor791"/>.</span></p>
			<p>In the previous chapter, you learned about using Coroutines and Flow for background operations and data manipulation. Now, you will learn about architectural patterns so you can improve <span class="No-Break">your application.</span></p>
			<p>When developing an Android application, you may tend to write most of the code (including business logic) in activities or fragments. This will make your project hard to test and maintain later. As your project grows and becomes more complex, the difficulty also increases. You can improve your projects with <span class="No-Break">architectural patterns.</span></p>
			<p>Architectural patterns are general solutions for designing and developing parts of applications, especially for large apps. There are architectural patterns you can use to structure your <a id="_idIndexMarker1269"/>project into different layers (the presentation layer, the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) layer, and the data layer) or functions (observer/observable). With architectural patterns, you can organize your code in a way that makes it easier for you to develop, test, <span class="No-Break">and maintain.</span></p>
			<p>For Android <a id="_idIndexMarker1270"/>development, commonly used patterns <a id="_idIndexMarker1271"/>include <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>), <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>), and MVVM. The recommended architectural pattern is MVVM, which will be discussed in this chapter. You will also learn about data binding, the Repository pattern using the Room library, <span class="No-Break">and WorkManager.</span></p>
			<p>We will cover the following topics in <span class="No-Break">the chapter:</span></p>
			<ul>
				<li>Getting started <span class="No-Break">with MVVM</span></li>
				<li>Binding data on Android with <span class="No-Break">data binding</span></li>
				<li>Using Retrofit <span class="No-Break">and Moshi</span></li>
				<li>Implementing the <span class="No-Break">Repository pattern</span></li>
				<li><span class="No-Break">Using WorkManager</span></li>
			</ul>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor792"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/PZNNT"><span class="No-Break">https://packt.link/PZNNT</span></a></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor793"/>Getting started with MVVM</h1>
			<p>MVVM allows you to separate the UI and business logic. When you need to redesign the UI or update <a id="_idIndexMarker1272"/>the Model/business logic, you only need to touch the relevant component without affecting the other components of your app. This will make it easier for you to add new features and test your existing code. MVVM is also useful in creating huge applications that use a lot of data <span class="No-Break">and views.</span></p>
			<p>With the MVVM architectural pattern, your application will be grouped into <span class="No-Break">three components:</span></p>
			<ul>
				<li><strong class="bold">Model</strong>: This represents the <span class="No-Break">data layer</span></li>
				<li><strong class="bold">View</strong>: This is the UI that displays <span class="No-Break">the data</span></li>
				<li><strong class="bold">ViewModel</strong>: This fetches data from <strong class="source inline">Model</strong> and provides it <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">View</strong></span></li>
			</ul>
			<p>The MVVM architectural pattern can be understood better through the <span class="No-Break">following dia<a id="_idTextAnchor794"/>gram:</span></p>
			<div>
				<div id="_idContainer218" class="IMG---Figure">
					<img src="image/B19411_15_01.jpg" alt="Figure 15.1 – The MVVM architectural pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The MVVM architectural pattern</p>
			<p>The Model contains the data of the application. The activities, fragments, and layouts that your users see and interact with are the Views in MVVM. Views only deal with how the app looks. They let <strong class="source inline">ViewModel</strong> know about user actions (such as opening an activity or clicking on <span class="No-Break">a button).</span></p>
			<p>ViewModel links <strong class="source inline">View</strong> and <strong class="source inline">Model</strong>. ViewModels also perform the business logic processing and transform them for display in the View. Views subscribe to the ViewModel and update the UI when a <span class="No-Break">value changes.</span></p>
			<p>You can <a id="_idIndexMarker1273"/>use Jetpack’s ViewModel to create the ViewModel classes for your app. Jetpack’s ViewModel manages its own lifecycle so you don’t need to handle <span class="No-Break">it yourself.</span></p>
			<p>You can add ViewModel to your project by adding the following code in your <strong class="source inline">app/build.gradle</strong> <span class="No-Break">file dependencies:</span></p>
			<pre class="source code">
implementation 'androidx.lifecycle:
lifecycle-viewmodel-ktx:2.5.1'</pre>
			<p>For example, if you’re working on an app that displays movies, you could have <strong class="source inline">MovieViewModel</strong>. This ViewModel will have a function that fetches a list <span class="No-Break">of movies:</span></p>
			<pre class="source code">
class MovieViewModel : ViewModel() {
    private val _movies: MutableStateFlow&lt;List&lt;Movie&gt;&gt;
    fun movies: StateFlow&lt;List&lt;Movie&gt;&gt; { ... }
    ...
}</pre>
			<p>In your activity, you can create ViewModel <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">ViewModelProvider</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    private val movieViewModel by lazy {
        ViewModelProvider(this).get(MovieViewModel::
        class.java)
    }
    ...
}</pre>
			<p>Then, you can connect to the <strong class="source inline">movies</strong> Flow from <strong class="source inline">ViewModel</strong> and automatically update the list on the UI when the list of <span class="No-Break">movies changes:</span></p>
			<pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    lifecycleScope.launch {
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            launch {
                movieViewModel.popularMovies.collect {
                movies -&gt;
                    movieAdapter.addMovies(movies)
                }
            }
        }
    }
    ...
}</pre>
			<p>Views are <a id="_idIndexMarker1274"/>notified when values in <strong class="source inline">ViewModel</strong> have changed. You can also use data binding to connect <strong class="source inline">View</strong> with the data from <strong class="source inline">ViewModel</strong>. You will learn more about data binding in the <span class="No-Break">next se<a id="_idTextAnchor795"/><a id="_idTextAnchor796"/>ction.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor797"/>Binding data on Android with data binding</h2>
			<p>View <a id="_idIndexMarker1275"/>binding and data <a id="_idIndexMarker1276"/>binding <a id="_idIndexMarker1277"/>are two ways to bind data to Android Views. View binding is a simpler and faster binding, which you can use to replace <strong class="source inline">findViewById</strong> in your code. Data binding is more powerful and can be customized to connect your data with layout variables <span class="No-Break">and expressions.</span></p>
			<p>With data binding, you can link the views in your layout to data from a source such as a ViewModel. Instead of adding code to find the views in the layout file and updating them when the value from the ViewModel changes, data binding can handle that for <span class="No-Break">you automatically.</span></p>
			<p>To use <a id="_idIndexMarker1278"/>data binding <a id="_idIndexMarker1279"/>in your Android project, you should add the following <a id="_idIndexMarker1280"/>in the <strong class="source inline">android</strong> block of the <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
buildFeatures {
    dataBinding true
}</pre>
			<p>In the <strong class="source inline">layout</strong> file, you must wrap the root element with a <strong class="source inline">layout</strong> tag. Inside the <strong class="source inline">layout</strong> tag, you need to define the <strong class="source inline">data</strong> element for the data to be bound to this <span class="No-Break"><strong class="source inline">layout</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
&lt;layout xmlns:android=
    "http://schemas.android.com/apk/res/android"&gt;
    &lt;data&gt;
        &lt;variable name="movie" type=
        "com.example.model.Movie"/&gt;
    &lt;/data&gt;
    &lt;ConstraintLayout ... /&gt;
&lt;/layout&gt;</pre>
			<p>The <strong class="source inline">movie</strong> layout variable represents the <strong class="source inline">com.example.model.Movie</strong> class that will be displayed in the layout. To set the attribute to fields in the data model, you need to use the <strong class="source inline">@{}</strong> syntax. For example, to use the movie’s title as the text value of <strong class="source inline">TextView</strong>, you can use <span class="No-Break">the following:</span></p>
			<pre class="source code">
&lt;TextView
    ...
    android:text="@{movie.title}"/&gt;</pre>
			<p>You also need to change your activity file. If your <strong class="source inline">layout</strong> file is named <strong class="source inline">activity_movies.xml</strong>, the data binding library will generate a <strong class="source inline">binding</strong> class named <strong class="source inline">ActivityMoviesBinding</strong> in your project’s build files. In the activity, you can replace the <strong class="source inline">setContentView(R.layout.activity_movies)</strong> line with <span class="No-Break">the following:</span></p>
			<pre class="source code">
val binding: ActivityMoviesBinding = DataBindingUtil
.setContentView(this, R.layout.activity_movies)</pre>
			<p>You can <a id="_idIndexMarker1281"/>also use the <strong class="source inline">inflate</strong> method of the <strong class="source inline">binding</strong> class or the <span class="No-Break"><strong class="source inline">DataBindingUtil</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source code">
val binding: ActivityMoviesBinding = ActivityMoviesBinding
.inflate(getLayoutInflater())</pre>
			<p>Then, you can <a id="_idIndexMarker1282"/>set the <strong class="source inline">movie</strong> instance to bind in the layout <a id="_idIndexMarker1283"/>with the <strong class="source inline">layout</strong> variable <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">movie</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
val movieToDisplay = ...
binding.movie = movieToDisplay</pre>
			<p>If you are using <strong class="source inline">LiveData</strong> or <strong class="source inline">Flow</strong> as the item to bind to the layout, you need to set <strong class="source inline">lifeCycleOwner</strong> for the <strong class="source inline">binding</strong> variable. <strong class="source inline">lifeCycleOwner</strong> specifies the scope of the object. You can use the activity as <strong class="source inline">lifeCycleOwner</strong> of the <span class="No-Break"><strong class="source inline">binding</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source code">
binding.lifeCycleOwner = this</pre>
			<p>With this, when the values in <strong class="source inline">ViewModel</strong> change their value, <strong class="source inline">View</strong> will automatically update with the <span class="No-Break">new values.</span></p>
			<p>You set the movie title in <strong class="source inline">TextView</strong> with <strong class="source inline">android:text="@{movie.title}"</strong>. The data binding library has default binding adapters that handle the binding to the <strong class="source inline">android:text</strong> attribute. Sometimes, there are no default attributes that you can use. You can create your own binding adapter. For example, if you want to bind the list of movies for <strong class="source inline">RecyclerView</strong>, you can create a custom <span class="No-Break"><strong class="source inline">BindingAdapter</strong></span><span class="No-Break"> call:</span></p>
			<pre class="source code">
@BindingAdapter("list")
fun bindMovies(view: RecyclerView, movies: List&lt;Movie&gt;?) {
    val adapter = view.adapter as MovieAdapter
    adapter.addMovies(movies ?: emptyList())
}</pre>
			<p>This will <a id="_idIndexMarker1284"/>allow you <a id="_idIndexMarker1285"/>to add an <strong class="source inline">app:list</strong> attribute to <strong class="source inline">RecyclerView</strong> that accepts <a id="_idIndexMarker1286"/>a list <span class="No-Break">of movies:</span></p>
			<pre class="source code">
app:list="@{movies}"</pre>
			<p>Let’s try implementing data binding on a<a id="_idTextAnchor798"/>n <a id="_idTextAnchor799"/><span class="No-Break">Android project.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor800"/>Exercise 15.01– using data binding in an Android project</h2>
			<p>In the previous chapter, you worked on an application that displays popular movies using the <a id="_idIndexMarker1287"/>Movie Database API. For this chapter, you will <a id="_idIndexMarker1288"/>be improving the app using MVVM. You can use the <strong class="source inline">Popular Movies</strong> project from the previous chapter or make a copy of it. In this exercise, you will add data binding to bind the list of movies from <strong class="source inline">ViewModel</strong> to <span class="No-Break">the UI:</span></p>
			<ol>
				<li>Open the <strong class="source inline">Popular Movies</strong> project in <span class="No-Break">Android Studio.</span></li>
				<li>Open the <strong class="source inline">app/build.gradle</strong> file and add the following in the <span class="No-Break"><strong class="source inline">android</strong></span><span class="No-Break"> block:</span><pre class="source code">
buildFeatures {
    dataBinding true
}</pre></li>
			</ol>
			<p>This enables data binding for <span class="No-Break">your application.</span></p>
			<ol>
				<li value="3">Add the <strong class="source inline">kotlin-kapt</strong> plugin at the end of the plugins block in your <span class="No-Break"><strong class="source inline">app/build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
plugins {
    ...
    id 'kotlin-kapt'
}</pre></li>
			</ol>
			<p>The <strong class="source inline">kotlin-kapt</strong> plugin is the Kotlin annotation processing tool, which is needed for using <span class="No-Break">data binding.</span></p>
			<ol>
				<li value="4">Create a <a id="_idIndexMarker1289"/>new file called <strong class="source inline">RecyclerViewBinding</strong> that <a id="_idIndexMarker1290"/>contains the binding adapter for the <span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break"> list:</span><pre class="source code">
@BindingAdapter("list")
fun bindMovies(view: RecyclerView, movies:
List&lt;Movie&gt;?) {
    val adapter = view.adapter as MovieAdapter
    adapter.addMovies(movies ?: emptyList())
}</pre></li>
			</ol>
			<p>This will allow you to add an <strong class="source inline">app:list</strong> attribute for <strong class="source inline">RecyclerView</strong> where you can pass the list of movies to be displayed. The list of movies will be set to the adapter, updating <strong class="source inline">RecyclerView</strong> in <span class="No-Break">the UI.</span></p>
			<ol>
				<li value="5">Open the <strong class="source inline">activity_main.xml</strong> file and wrap everything inside a <span class="No-Break"><strong class="source inline">layout</strong></span><span class="No-Break"> tag:</span><pre class="source code">
&lt;layout xmlns:android=
    "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout
        ... &gt;
    &lt;/androidx.constraintlayout.widget
    .ConstraintLayout&gt;
&lt;/layout&gt;</pre></li>
			</ol>
			<p>With this, the data <a id="_idIndexMarker1291"/>binding library will <a id="_idIndexMarker1292"/>be able to generate a binding class for <span class="No-Break">this layout.</span></p>
			<ol>
				<li value="6">Inside the <strong class="source inline">layout</strong> tag and before the <strong class="source inline">ConstraintLayout</strong> tag, add a data element with a variable <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">viewModel</strong></span><span class="No-Break">:</span><pre class="source code">
&lt;data&gt;
    &lt;variable
        name="viewModel"
        type="com.example.popularmovies
        .MovieViewModel" /&gt;
&lt;/data&gt;</pre></li>
			</ol>
			<p>This creates a <strong class="source inline">viewModel</strong> layout variable that corresponds to your <span class="No-Break"><strong class="source inline">MovieViewModel</strong></span><span class="No-Break"> class.</span></p>
			<ol>
				<li value="7">In <strong class="source inline">RecyclerView</strong>, add the list to be displayed <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">app:list</strong></span><span class="No-Break">:</span><pre class="source code">
app:list="@{viewModel.popularMovies}"</pre></li>
			</ol>
			<p><strong class="source inline">popularMovies</strong> from <strong class="source inline">MovieViewModel.getPopularMovies</strong> will be passed as the list of movies <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="8">Open <strong class="source inline">MainActivity</strong>. In the <strong class="source inline">onCreate</strong> function, replace the <strong class="source inline">setContentView</strong> line with <span class="No-Break">the following:</span><pre class="source code">
val binding: ActivityMainBinding = DataBindingUtil
.setContentView(this, R.layout.activity_main)</pre></li>
			</ol>
			<p>This sets the <strong class="source inline">layout</strong> file to be used and creates a <span class="No-Break">binding object.</span></p>
			<ol>
				<li value="9">Remove the collection of <strong class="source inline">popularMoviesView</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">movieViewModel</strong></span><span class="No-Break">.</span></li>
				<li>Add the <a id="_idIndexMarker1293"/>following <a id="_idIndexMarker1294"/>after the initialization <span class="No-Break">of </span><span class="No-Break"><strong class="source inline">movieViewModel</strong></span><span class="No-Break">:</span><pre class="source code">
binding.viewModel = movieViewModel
binding.lifecycleOwner = this</pre></li>
			</ol>
			<p>This binds <strong class="source inline">movieViewModel</strong> to the <strong class="source inline">viewModel</strong> layout variable in the <span class="No-Break"><strong class="source inline">activity_main.xml</strong></span><span class="No-Break"> file.</span></p>
			<ol>
				<li value="11">Run the application. It should work as usual, displaying the list of popular movies, where clicking on one will open the deta<a id="_idTextAnchor801"/>ils of the <span class="No-Break">movie selected:</span></li>
			</ol>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/B19411_15_02.jpg" alt="Figure 15.2 – The main screen (left) with the year’s popular movies and the details screen (right) with more information about the selected movie"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – The main screen (left) with the year’s popular movies and the details screen (right) with more information about the selected movie</p>
			<p>In this <a id="_idIndexMarker1295"/>exercise, you have used data binding on <a id="_idIndexMarker1296"/>an <span class="No-Break">Android project.</span></p>
			<p>Data binding links the Views to the ViewModel. The ViewModel retrieves the data from the Model. Some of the libraries you can use to fetch data are Retrofit and Moshi, which you will learn more<a id="_idTextAnchor802"/><a id="_idTextAnchor803"/> about in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor804"/>Using Retrofit and Moshi</h1>
			<p>When connecting to your remote network, you can use Retrofit. Retrofit is an HTTP client that makes <a id="_idIndexMarker1297"/>it easy to implement creating requests and retrieving responses <a id="_idIndexMarker1298"/>from your <span class="No-Break">backend server.</span></p>
			<p>You can add Retrofit to your project by adding the following code to your <strong class="source inline">app/build.gradle</strong> <span class="No-Break">file dependencies:</span></p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:retrofit:2.9.0'</pre>
			<p>You can then convert the JSON response from Retrofit by using Moshi, a library for parsing JSON into Java objects. For example, you can convert the JSON string response from getting the list of movies into a <strong class="source inline">ListofMovie</strong> object for display and storage in <span class="No-Break">your app.</span></p>
			<p>You can add the Moshi Converter to your project by adding the following code to your <strong class="source inline">app/build.gradle</strong> <span class="No-Break">file dependencies:</span></p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:
converter-moshi:2.9.0'</pre>
			<p>In your Retrofit builder code, you can call <strong class="source inline">addConverterFactory</strong> and <span class="No-Break">pass </span><span class="No-Break"><strong class="source inline">Moshi</strong></span><strong class="source inline">
</strong><span class="No-Break"><strong class="source inline">ConverterFactory</strong></span><span class="No-Break">:</span></p>
			<pre class="source code">
Retrofit.Builder()
    ...
    .addConverterFactory(MoshiConverterFactory.create())
    ...</pre>
			<p>You can call the data layer from the ViewModel. To reduce its complexity, you can use the Repository pattern for loading and caching data. You will learn ab<a id="_idTextAnchor805"/><a id="_idTextAnchor806"/>out this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor807"/>Implementing the Repository pattern</h2>
			<p>Instead of <strong class="source inline">ViewModel</strong> directly <a id="_idIndexMarker1299"/>calling the services for getting and storing data, it should delegate that task to another component, such as <span class="No-Break">a repository.</span></p>
			<p>With the Repository pattern, you can move the code in the <strong class="source inline">ViewModel</strong> that handles the data layer into a separate class. This reduces the complexity of <strong class="source inline">ViewModel</strong>, making it easier to maintain and test. The repository will manage where the data is fetched and stored, just as if the local database or the network service w<a id="_idTextAnchor808"/>ere used to get or <span class="No-Break">store data:</span></p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B19411_15_03.jpg" alt="Figure 15.3 – ViewModel with the Repository pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – ViewModel with the Repository pattern</p>
			<p>In <strong class="source inline">ViewModel</strong>, you can <a id="_idIndexMarker1300"/>add a property for <span class="No-Break">the repository:</span></p>
			<pre class="source code">
class MovieViewModel(val repository: MovieRepository):
ViewModel() { ...}</pre>
			<p><strong class="source inline">ViewModel</strong> will get the movies from the repository, or it can listen to them. It will not know where you actually got the <span class="No-Break">list from.</span></p>
			<p>You can create a repository interface that connects to a data source, such as in the <span class="No-Break">following example:</span></p>
			<pre class="source code">
interface MovieRepository {
    fun getMovies(): List&lt;Movie&gt;
}</pre>
			<p>The <strong class="source inline">MovieRepository</strong> interface has a <strong class="source inline">getMovies</strong> function that your repository implementation class will override to fetch movies from the data source. You can also have a single repository class that handles the fetching of data from either the local database or from your <span class="No-Break">remote endpoint.</span></p>
			<p>When using the local database as the data source for your repository, you can use the Room library, which makes it easier for you to work with the SQLite database by writing less code and having compile-time checks <span class="No-Break">on queries.</span></p>
			<p>You can <a id="_idIndexMarker1301"/>add Room to your project by adding the following code to your <strong class="source inline">app/build.gradle</strong> <span class="No-Break">file dependencies:</span></p>
			<pre class="source code">
implementation 'androidx.room:room-runtime:2.4.3'
implementation 'androidx.room:room-ktx:2.4.3'
kapt 'androidx.room:room-compiler:2.4.3'</pre>
			<p>Let’s try adding the Repository pattern w<a id="_idTextAnchor809"/>ith <a id="_idTextAnchor810"/>Room to an <span class="No-Break">Android project.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor811"/>Exercise 15.02 – using Repository with Room in an Android project</h2>
			<p>You have added data binding in the <strong class="source inline">Popular Movies</strong> project in the previous exercise. In this <a id="_idIndexMarker1302"/>exercise, you will update the app with the <span class="No-Break">Repository pattern.</span></p>
			<p>When opening the app, it fetches the list of movies from the network. This takes a while. You will cache this data into the local database every time you fetch them. When the user opens the app next time, the app will immediately display the list of movies from the database on the screen. You will be using Room for <span class="No-Break">data caching:</span></p>
			<ol>
				<li>Open the <strong class="source inline">Popular Movies</strong> project that you used in the <span class="No-Break">previous exercise.</span></li>
				<li>Open the <strong class="source inline">app/build.gradle</strong> file and add the dependencies for the <span class="No-Break">Room library:</span><pre class="source code">
implementation 'androidx.room:room-runtime:2.4.3'
implementation 'androidx.room:room-ktx:2.4.3'
kapt 'androidx.room:room-compiler:2.4.3'</pre></li>
				<li>Open the <strong class="source inline">Movie</strong> class and add an <strong class="source inline">Entity</strong> annotation <span class="No-Break">for it:</span><pre class="source code">
@Entity(tableName = "movies",  primaryKeys = [("id")])
data class Movie( ... )</pre></li>
			</ol>
			<p>The <strong class="source inline">Entity</strong> annotation will create a table named <strong class="source inline">movies</strong> for the list of movies. It also sets <strong class="source inline">id</strong> as the primary key of <span class="No-Break">the table.</span></p>
			<ol>
				<li value="4">Make a <a id="_idIndexMarker1303"/>new package called <strong class="source inline">com.example.popularmovies.database</strong>. Create a <strong class="source inline">MovieDao</strong> data access object for accessing the <span class="No-Break"><strong class="source inline">movies</strong></span><span class="No-Break"> table:</span><pre class="source code">
@Dao
interface MovieDao {
@Insert(onConflict = OnConflictStrategy.REPLACE)
fun addMovies(movies: List&lt;Movie&gt;)
@Query("SELECT * FROM movies")
fun getMovies(): List&lt;Movie&gt;
}</pre></li>
			</ol>
			<p>This class contains a function for adding a list of movies in the database and another for getting all the movies from <span class="No-Break">the database.</span></p>
			<ol>
				<li value="5">Create a <strong class="source inline">MovieDatabase</strong> class in the <span class="No-Break"><strong class="source inline">com.example.popularmovies.database</strong></span><span class="No-Break"> package:</span><pre class="source code">
@Database(entities = [Movie::class], version = 1)
abstract class MovieDatabase : RoomDatabase() {
    abstract fun movieDao(): MovieDao
    companion object {
        @Volatile
        private var instance: MovieDatabase? = null
        fun getInstance(context: Context):
        MovieDatabase {
            return instance ?: synchronized(this) {
                instance ?: buildDatabase(
                context).also { instance = it }
            }
        }
        private fun buildDatabase(context: Context):
        MovieDatabase {
            return Room.databaseBuilder(context,
            MovieDatabase::class.java, "movie-db")
            .build()
        }
    }
}</pre></li>
			</ol>
			<p>This database has a version of <strong class="source inline">1</strong>, a single entity for <strong class="source inline">Movie</strong>, and the data access object <a id="_idIndexMarker1304"/>for the movies. It also has a <strong class="source inline">getInstance</strong> function to generate an instance of <span class="No-Break">the database.</span></p>
			<ol>
				<li value="6">Update the <strong class="source inline">MovieRepository</strong> class with constructors <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">movieDatabase</strong></span><span class="No-Break">:</span><pre class="source code">
class MovieRepository(private val movieService:
MovieService, private val movieDatabase:
MovieDatabase) { ... }</pre></li>
				<li>Update the <span class="No-Break"><strong class="source inline">fetchMovies</strong></span><span class="No-Break"> function:</span><pre class="source code">
fun fetchMovies(): Flow&lt;List&lt;Movie&gt;&gt; {
    return flow {
        val movieDao: MovieDao =
            movieDatabase.movieDao()
        val savedMovies = movieDao.getMovies()
        if(savedMovies.isEmpty()) {
            val movies = movieService
                .getPopularMovies(apiKey).results
            movieDao.addMovies(movies)
            emit(movies)
        } else {
            emit(savedMovies)
        }
    }.flowOn(Dispatchers.IO)
}</pre></li>
			</ol>
			<p>It will <a id="_idIndexMarker1305"/>fetch the movies from the database. If there’s nothing saved yet, it will retrieve the list from the network endpoint and then <span class="No-Break">save it.</span></p>
			<ol>
				<li value="8">Open <strong class="source inline">MovieApplication</strong> and in the <strong class="source inline">onCreate</strong> function, replace the <strong class="source inline">movieRepository</strong> initialization with <span class="No-Break">the following:</span><pre class="source code">
val movieDatabase =
    MovieDatabase.getInstance(applicationContext)
movieRepository =
    MovieRepository(movieService, movieDatabase)</pre></li>
				<li>Run the application. It will display the list of popular movies, and clicking on one will open the details of the movie selected. If you turn off mobile data or disconnect from the wireless network, it will still display the list of movies, w<a id="_idTextAnchor812"/>hich is now cached in <span class="No-Break">the database:</span></li>
			</ol>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B19411_15_04.jpg" alt="Figure 15.4 – The Popular Movies app using Repository with Room"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – The Popular Movies app using Repository with Room</p>
			<p>In this <a id="_idIndexMarker1306"/>exercise, you have improved the app by moving the loading and storing of data into a repository. You have also used Room to cache <span class="No-Break">the data.</span></p>
			<p>The repository fetches the data from the data source. If there’s no data stored in the database yet, the app will call the network to request the data. This can take a while. You can improve the user experience by pre-fetching data at a scheduled time so the next time the user opens the app, they will already see the updated contents. You can do this with WorkManager, which w<a id="_idTextAnchor813"/><a id="_idTextAnchor814"/>e will discuss in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor815"/>Using WorkManager</h1>
			<p><strong class="bold">WorkManager</strong> is a Jetpack <a id="_idIndexMarker1307"/>library for background operations that can be delayed and can run based on the constraints you set. It is ideal for doing something that must be run but can be <a id="_idIndexMarker1308"/>done later or at regular intervals, regardless of whether the app is running <span class="No-Break">or not.</span></p>
			<p>You can use WorkManager to run tasks such as fetching the data from the network and storing it in your database at scheduled intervals. WorkManager will run the task even if the app has been closed or if the device restarts. This will keep your database up to date with <span class="No-Break">your backend.</span></p>
			<p>You can add WorkManager to your project by adding the following code to your <strong class="source inline">app/build.gradle</strong> <span class="No-Break">file dependencies:</span></p>
			<pre class="source code">
implementation 'androidx.work:work-runtime:2.7.1'</pre>
			<p>WorkManager can call the repository to fetch and store data from either the local database or the <span class="No-Break">network server.</span></p>
			<p>Let’s try addi<a id="_idTextAnchor816"/>ng Wo<a id="_idTextAnchor817"/>rkManager to an <span class="No-Break">Android project.</span></p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor818"/>Exercise 15.03 – adding WorkManager to an Android Project</h2>
			<p>In the previous exercise, you added the Repository pattern with Room to cache data in the local database. The app can now fetch the data from the database instead of the network. Now, you will <a id="_idIndexMarker1309"/>be adding WorkManager to schedule <a id="_idIndexMarker1310"/>a task for fetching data from the server and saving it to the database at <span class="No-Break">scheduled intervals:</span></p>
			<ol>
				<li>Open the Popular Movies project you used in the <span class="No-Break">previous exercise.</span></li>
				<li>Open the <strong class="source inline">app/build.gradle</strong> file and add the dependency for the <span class="No-Break">WorkManager library:</span><pre class="source code">
implementation 'androidx.work:work-runtime:2.7.1'</pre></li>
			</ol>
			<p>This will allow you to add the WorkManager workers to <span class="No-Break">your app.</span></p>
			<ol>
				<li value="3">Open <strong class="source inline">MovieRepository</strong> and add a suspending function for fetching movies from the network using <strong class="source inline">apiKey</strong> from <strong class="source inline">movieDatabase</strong> and saving them to <span class="No-Break">the database:</span><pre class="source code">
suspend fun fetchMoviesFromNetwork() {
    val movieDao: MovieDao = movieDatabase.movieDao()
    try {
        val popularMovies = movieService
            .getPopularMovies(apiKey)
        val moviesFetched = popularMovies.results
        movieDao.addMovies(moviesFetched)
    } catch (exception: Exception) {
        Log.d("MovieRepository", "An error occurred:
            ${exception.message}")
    }
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1311"/>be the function that will be called <a id="_idIndexMarker1312"/>by the <strong class="source inline">Worker</strong> class that will be running to fetch and save <span class="No-Break">the movies.</span></p>
			<ol>
				<li value="4">Create the <strong class="source inline">MovieWorker</strong> class in the <span class="No-Break"><strong class="source inline">com.example.popularmovies</strong></span><span class="No-Break"> package:</span><pre class="source code">
class MovieWorker(private val context: Context,
params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result {
        val movieRepository = (context as
        MovieApplication).movieRepository
        CoroutineScope(Dispatchers.IO).launch {
            movieRepository.fetchMoviesFromNetwork()
        }
        return Result.success()
    }
}</pre></li>
				<li>Open <strong class="source inline">MovieApplication</strong> and <a id="_idIndexMarker1313"/>at the end <a id="_idIndexMarker1314"/>of the <strong class="source inline">onCreate</strong> function, schedule <strong class="source inline">MovieWorker</strong> to retrieve and save <span class="No-Break">the movies:</span><pre class="source code">
override fun onCreate() {
    ...
    val constraints =
        Constraints.Builder().setRequiredNetworkType(
        NetworkType.CONNECTED).build()
    val workRequest = PeriodicWorkRequest
        .Builder(MovieWorker::class.java, 1,
        TimeUnit.HOURS).setConstraints(constraints)
        .addTag("movie-work").build()
    WorkManager.getInstance(
        applicationContext).enqueue(workRequest)
}</pre></li>
			</ol>
			<p>This schedules <strong class="source inline">MovieWorker</strong> to run every hour when the device is connected to the network. <strong class="source inline">MovieWorker</strong> will fetch the list of movies from the network and save it to the <span class="No-Break">local database.</span></p>
			<ol>
				<li value="6">Run the application. Close it and make sure the device is connected to the internet. After more than an hour, open the application again and check whether the list of movies displayed has been updated. If not, try again in a few hours. The list of movies <a id="_idIndexMarker1315"/>displayed will be updated regularly, around <a id="_idTextAnchor819"/><a id="_idIndexMarker1316"/>every hour, even if the app has <span class="No-Break">been closed.</span></li>
			</ol>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B19411_15_041.jpg" alt="Figure 15.5 – The Popular Movies app updates its list with WorkManager"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – The Popular Movies app updates its list with WorkManager</p>
			<p>In this exercise, you added WorkManager to your application to automatically update the database with the li<a id="_idTextAnchor820"/>st of <a id="_idTextAnchor821"/>the movies retrieved from <span class="No-Break">the network.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor822"/>Activity 15.01 – revisiting the TV Guide app</h2>
			<p>In the previous chapter, you developed an app that can display a list of TV shows that are on the air. The app <a id="_idIndexMarker1317"/>had two screens: the main screen and the details screen. On the main screen, there’s a list of TV shows. When clicking on a TV show, the details screen will be displayed with the details of the <span class="No-Break">selected show.</span></p>
			<p>When running the app, it takes a while to display the list of shows. Update the app to cache the list so it will be immediately displayed when opening the app. Also, improve the app by using MVVM with data binding and <span class="No-Break">adding WorkManager.</span></p>
			<p>You can use the TV Guide app you worked on in the previous chapter or download it from the GitHub repository (<a href="https://packt.link/Eti8M">https://packt.link/Eti8M</a>). The following ste<a id="_idTextAnchor823"/>ps will help guide you through <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Open the TV Guide app in Android Studio. Open the <strong class="source inline">app/build.gradle</strong> file and add the <strong class="source inline">kotlin-kapt</strong> plugin, the data binding dependency, and the dependencies for Room <span class="No-Break">and WorkManager.</span></li>
				<li>Create a binding adapter class <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">RecyclerView</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="source inline">activity_main.xml</strong>, wrap everything inside a <span class="No-Break"><strong class="source inline">layout</strong></span><span class="No-Break"> tag.</span></li>
				<li>Inside the <strong class="source inline">layout</strong> tag and before the <strong class="source inline">ConstraintLayout</strong> tag, add a data element with a variable <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">ViewModel</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="source inline">RecyclerView</strong>, add the list to be displayed <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">app:list</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="source inline">MainActivity</strong>, replace the line for <strong class="source inline">setContentView</strong> with the <span class="No-Break"><strong class="source inline">DataBindingUtil.setContentView</strong></span><span class="No-Break"> function.</span></li>
				<li>Replace the observer from <strong class="source inline">TVShowViewModel</strong> with the data <span class="No-Break">binding code.</span></li>
				<li>Add an <strong class="source inline">Entity</strong> annotation in the <span class="No-Break"><strong class="source inline">TVShow</strong></span><span class="No-Break"> class.</span></li>
				<li>Create a <strong class="source inline">TVDao</strong> data access object for accessing the <strong class="source inline">TV </strong><span class="No-Break"><strong class="source inline">shows</strong></span><span class="No-Break"> table.</span></li>
				<li>Create a <span class="No-Break"><strong class="source inline">TVDatabase</strong></span><span class="No-Break"> class.</span></li>
				<li>Update <strong class="source inline">TVShowRepository</strong> with a constructor <span class="No-Break">for </span><span class="No-Break"><strong class="source inline">tvDatabase</strong></span><span class="No-Break">.</span></li>
				<li>Update the <strong class="source inline">fetchTVShows</strong> function to get the TV shows from the local database. If there’s nothing there yet, retrieve the list from the endpoint and save it in <span class="No-Break">the database.</span></li>
				<li>Add a suspending <strong class="source inline">fetchTVShowsFromNetwork</strong> function to get the TV shows from the network and save them to <span class="No-Break">the database.</span></li>
				<li>Create the <span class="No-Break"><strong class="source inline">TVShowWorker</strong></span><span class="No-Break"> class.</span></li>
				<li>Open the <strong class="source inline">TVApplication</strong> file. In <strong class="source inline">onCreate</strong>, schedule <strong class="source inline">TVShowWorker</strong> to retrieve and save <span class="No-Break">the shows.</span></li>
				<li>Run your <a id="_idIndexMarker1318"/>application. The app will display a list of TV shows. Clicking on a TV show will open the details activity, which displays the movie details. The main screen and de<a id="_idTextAnchor824"/>tails screen will be similar to <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B19411_15_05.jpg" alt="Figure 15.6 – The main screen and details screen of the TV Guide app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – The main screen and details screen of the TV Guide app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution <a id="_idIndexMarker1319"/>to this activity can be found <span class="No-Break">at </span><a href="https://packt.link/By7eE"><span class="No-Break">https://packt.link/By7eE</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor825"/>Summary</h1>
			<p>This chapter focused on architectural patterns for Android. You started with the MVVM architectural pattern. You learned about its three components: the Model, the View, and the ViewModel. You also used data binding to link the View with <span class="No-Break">the ViewModel.</span></p>
			<p>Next, you learned about how the Repository pattern can be used to cache data. Then, you learned about WorkManager and how you can schedule tasks such as retrieving data from the network and saving that data to the database to update your <span class="No-Break">local data.</span></p>
			<p>In the next chapter, you will learn how to improve the look and design of your apps with animations. You will add animations and transitions to your apps with <strong class="source inline">CoordinatorLayout</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">MotionLayout</strong></span><span class="No-Break">.</span></p>
		</div>
	</body></html>