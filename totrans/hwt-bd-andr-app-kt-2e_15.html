<html><head></head><body>
		<div><h1 id="_idParaDest-247" class="chapter number"><a id="_idTextAnchor789"/>15</h1>
			<h1 id="_idParaDest-248">Architecture Patterns<a id="_idTextAnchor790"/></h1>
			<p>This chapter will introduce you to architectural patterns you can use for your Android projects. It covers <a id="_idIndexMarker1268"/>using the <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) pattern, adding ViewModels, and using data binding. You will also learn about using the Repository pattern for caching data and WorkManager for scheduling data retrieval and storage.</p>
			<p>By the end of the chapter, you will be able to structure your Android project using MVVM and data binding. You will also be able to use the Repository pattern with the Room library to cache data and WorkManager to fetch and save data at a scheduled interval<a id="_idTextAnchor791"/>.</p>
			<p>In the previous chapter, you learned about using Coroutines and Flow for background operations and data manipulation. Now, you will learn about architectural patterns so you can improve your application.</p>
			<p>When developing an Android application, you may tend to write most of the code (including business logic) in activities or fragments. This will make your project hard to test and maintain later. As your project grows and becomes more complex, the difficulty also increases. You can improve your projects with architectural patterns.</p>
			<p>Architectural patterns are general solutions for designing and developing parts of applications, especially for large apps. There are architectural patterns you can use to structure your <a id="_idIndexMarker1269"/>project into different layers (the presentation layer, the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) layer, and the data layer) or functions (observer/observable). With architectural patterns, you can organize your code in a way that makes it easier for you to develop, test, and maintain.</p>
			<p>For Android <a id="_idIndexMarker1270"/>development, commonly used patterns <a id="_idIndexMarker1271"/>include <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>), <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>), and MVVM. The recommended architectural pattern is MVVM, which will be discussed in this chapter. You will also learn about data binding, the Repository pattern using the Room library, and WorkManager.</p>
			<p>We will cover the following topics in the chapter:</p>
			<ul>
				<li>Getting started with MVVM</li>
				<li>Binding data on Android with data binding</li>
				<li>Using Retrofit and Moshi</li>
				<li>Implementing the Repository pattern</li>
				<li>Using WorkManager</li>
			</ul>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor792"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/PZNNT">https://packt.link/PZNNT</a></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor793"/>Getting started with MVVM</h1>
			<p>MVVM allows you to separate the UI and business logic. When you need to redesign the UI or update <a id="_idIndexMarker1272"/>the Model/business logic, you only need to touch the relevant component without affecting the other components of your app. This will make it easier for you to add new features and test your existing code. MVVM is also useful in creating huge applications that use a lot of data and views.</p>
			<p>With the MVVM architectural pattern, your application will be grouped into three components:</p>
			<ul>
				<li><strong class="bold">Model</strong>: This represents the data layer</li>
				<li><strong class="bold">View</strong>: This is the UI that displays the data</li>
				<li><code>Model</code> and provides it to <code>View</code></li>
			</ul>
			<p>The MVVM architectural pattern can be understood better through the following dia<a id="_idTextAnchor794"/>gram:</p>
			<div><div><img src="img/B19411_15_01.jpg" alt="Figure 15.1 – The MVVM architectural pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – The MVVM architectural pattern</p>
			<p>The Model contains the data of the application. The activities, fragments, and layouts that your users see and interact with are the Views in MVVM. Views only deal with how the app looks. They let <code>ViewModel</code> know about user actions (such as opening an activity or clicking on a button).</p>
			<p>ViewModel links <code>View</code> and <code>Model</code>. ViewModels also perform the business logic processing and transform them for display in the View. Views subscribe to the ViewModel and update the UI when a value changes.</p>
			<p>You can <a id="_idIndexMarker1273"/>use Jetpack’s ViewModel to create the ViewModel classes for your app. Jetpack’s ViewModel manages its own lifecycle so you don’t need to handle it yourself.</p>
			<p>You can add ViewModel to your project by adding the following code in your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source code">
implementation 'androidx.lifecycle:
lifecycle-viewmodel-ktx:2.5.1'</pre>
			<p>For example, if you’re working on an app that displays movies, you could have <code>MovieViewModel</code>. This ViewModel will have a function that fetches a list of movies:</p>
			<pre class="source code">
class MovieViewModel : ViewModel() {
    private val _movies: MutableStateFlow&lt;List&lt;Movie&gt;&gt;
    fun movies: StateFlow&lt;List&lt;Movie&gt;&gt; { ... }
    ...
}</pre>
			<p>In your activity, you can create ViewModel using <code>ViewModelProvider</code>:</p>
			<pre class="source code">
class MainActivity : AppCompatActivity() {
    private val movieViewModel by lazy {
        ViewModelProvider(this).get(MovieViewModel::
        class.java)
    }
    ...
}</pre>
			<p>Then, you can connect to the <code>movies</code> Flow from <code>ViewModel</code> and automatically update the list on the UI when the list of movies changes:</p>
			<pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
    ...
    lifecycleScope.launch {
        repeatOnLifecycle(Lifecycle.State.STARTED) {
            launch {
                movieViewModel.popularMovies.collect {
                movies -&gt;
                    movieAdapter.addMovies(movies)
                }
            }
        }
    }
    ...
}</pre>
			<p>Views are <a id="_idIndexMarker1274"/>notified when values in <code>ViewModel</code> have changed. You can also use data binding to connect <code>View</code> with the data from <code>ViewModel</code>. You will learn more about data binding in the next se<a id="_idTextAnchor795"/><a id="_idTextAnchor796"/>ction.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor797"/>Binding data on Android with data binding</h2>
			<p>View <a id="_idIndexMarker1275"/>binding and data <a id="_idIndexMarker1276"/>binding <a id="_idIndexMarker1277"/>are two ways to bind data to Android Views. View binding is a simpler and faster binding, which you can use to replace <code>findViewById</code> in your code. Data binding is more powerful and can be customized to connect your data with layout variables and expressions.</p>
			<p>With data binding, you can link the views in your layout to data from a source such as a ViewModel. Instead of adding code to find the views in the layout file and updating them when the value from the ViewModel changes, data binding can handle that for you automatically.</p>
			<p>To use <a id="_idIndexMarker1278"/>data binding <a id="_idIndexMarker1279"/>in your Android project, you should add the following <a id="_idIndexMarker1280"/>in the <code>android</code> block of the <code>app/build.gradle</code> file:</p>
			<pre class="source code">
buildFeatures {
    dataBinding true
}</pre>
			<p>In the <code>layout</code> file, you must wrap the root element with a <code>layout</code> tag. Inside the <code>layout</code> tag, you need to define the <code>data</code> element for the data to be bound to this <code>layout</code> file:</p>
			<pre class="source code">
&lt;layout xmlns:android=
    "http://schemas.android.com/apk/res/android"&gt;
    &lt;data&gt;
        &lt;variable name="movie" type=
        "com.example.model.Movie"/&gt;
    &lt;/data&gt;
    &lt;ConstraintLayout ... /&gt;
&lt;/layout&gt;</pre>
			<p>The <code>movie</code> layout variable represents the <code>com.example.model.Movie</code> class that will be displayed in the layout. To set the attribute to fields in the data model, you need to use the <code>@{}</code> syntax. For example, to use the movie’s title as the text value of <code>TextView</code>, you can use the following:</p>
			<pre class="source code">
&lt;TextView
    ...
    android:text="@{movie.title}"/&gt;</pre>
			<p>You also need to change your activity file. If your <code>layout</code> file is named <code>activity_movies.xml</code>, the data binding library will generate a <code>binding</code> class named <code>ActivityMoviesBinding</code> in your project’s build files. In the activity, you can replace the <code>setContentView(R.layout.activity_movies)</code> line with the following:</p>
			<pre class="source code">
val binding: ActivityMoviesBinding = DataBindingUtil
.setContentView(this, R.layout.activity_movies)</pre>
			<p>You can <a id="_idIndexMarker1281"/>also use the <code>inflate</code> method of the <code>binding</code> class or the <code>DataBindingUtil</code> class:</p>
			<pre class="source code">
val binding: ActivityMoviesBinding = ActivityMoviesBinding
.inflate(getLayoutInflater())</pre>
			<p>Then, you can <a id="_idIndexMarker1282"/>set the <code>movie</code> instance to bind in the layout <a id="_idIndexMarker1283"/>with the <code>layout</code> variable named <code>movie</code>:</p>
			<pre class="source code">
val movieToDisplay = ...
binding.movie = movieToDisplay</pre>
			<p>If you are using <code>LiveData</code> or <code>Flow</code> as the item to bind to the layout, you need to set <code>lifeCycleOwner</code> for the <code>binding</code> variable. <code>lifeCycleOwner</code> specifies the scope of the object. You can use the activity as <code>lifeCycleOwner</code> of the <code>binding</code> class:</p>
			<pre class="source code">
binding.lifeCycleOwner = this</pre>
			<p>With this, when the values in <code>ViewModel</code> change their value, <code>View</code> will automatically update with the new values.</p>
			<p>You set the movie title in <code>TextView</code> with <code>android:text="@{movie.title}"</code>. The data binding library has default binding adapters that handle the binding to the <code>android:text</code> attribute. Sometimes, there are no default attributes that you can use. You can create your own binding adapter. For example, if you want to bind the list of movies for <code>RecyclerView</code>, you can create a custom <code>BindingAdapter</code> call:</p>
			<pre class="source code">
@BindingAdapter("list")
fun bindMovies(view: RecyclerView, movies: List&lt;Movie&gt;?) {
    val adapter = view.adapter as MovieAdapter
    adapter.addMovies(movies ?: emptyList())
}</pre>
			<p>This will <a id="_idIndexMarker1284"/>allow you <a id="_idIndexMarker1285"/>to add an <code>app:list</code> attribute to <code>RecyclerView</code> that accepts <a id="_idIndexMarker1286"/>a list of movies:</p>
			<pre class="source code">
app:list="@{movies}"</pre>
			<p>Let’s try implementing data binding on a<a id="_idTextAnchor798"/>n <a id="_idTextAnchor799"/>Android project.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor800"/>Exercise 15.01– using data binding in an Android project</h2>
			<p>In the previous chapter, you worked on an application that displays popular movies using the <a id="_idIndexMarker1287"/>Movie Database API. For this chapter, you will <a id="_idIndexMarker1288"/>be improving the app using MVVM. You can use the <code>Popular Movies</code> project from the previous chapter or make a copy of it. In this exercise, you will add data binding to bind the list of movies from <code>ViewModel</code> to the UI:</p>
			<ol>
				<li>Open the <code>Popular Movies</code> project in Android Studio.</li>
				<li>Open the <code>app/build.gradle</code> file and add the following in the <code>android</code> block:<pre class="source code">
buildFeatures {
    dataBinding true
}</pre></li>
			</ol>
			<p>This enables data binding for your application.</p>
			<ol>
				<li value="3">Add the <code>kotlin-kapt</code> plugin at the end of the plugins block in your <code>app/build.gradle</code> file:<pre class="source code">
plugins {
    ...
    id 'kotlin-kapt'
}</pre></li>
			</ol>
			<p>The <code>kotlin-kapt</code> plugin is the Kotlin annotation processing tool, which is needed for using data binding.</p>
			<ol>
				<li value="4">Create a <a id="_idIndexMarker1289"/>new file called <code>RecyclerViewBinding</code> that <a id="_idIndexMarker1290"/>contains the binding adapter for the <code>RecyclerView</code> list:<pre class="source code">
@BindingAdapter("list")
fun bindMovies(view: RecyclerView, movies:
List&lt;Movie&gt;?) {
    val adapter = view.adapter as MovieAdapter
    adapter.addMovies(movies ?: emptyList())
}</pre></li>
			</ol>
			<p>This will allow you to add an <code>app:list</code> attribute for <code>RecyclerView</code> where you can pass the list of movies to be displayed. The list of movies will be set to the adapter, updating <code>RecyclerView</code> in the UI.</p>
			<ol>
				<li value="5">Open the <code>activity_main.xml</code> file and wrap everything inside a <code>layout</code> tag:<pre class="source code">
&lt;layout xmlns:android=
    "http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout
        ... &gt;
    &lt;/androidx.constraintlayout.widget
    .ConstraintLayout&gt;
&lt;/layout&gt;</pre></li>
			</ol>
			<p>With this, the data <a id="_idIndexMarker1291"/>binding library will <a id="_idIndexMarker1292"/>be able to generate a binding class for this layout.</p>
			<ol>
				<li value="6">Inside the <code>layout</code> tag and before the <code>ConstraintLayout</code> tag, add a data element with a variable for <code>viewModel</code>:<pre class="source code">
&lt;data&gt;
    &lt;variable
        name="viewModel"
        type="com.example.popularmovies
        .MovieViewModel" /&gt;
&lt;/data&gt;</pre></li>
			</ol>
			<p>This creates a <code>viewModel</code> layout variable that corresponds to your <code>MovieViewModel</code> class.</p>
			<ol>
				<li value="7">In <code>RecyclerView</code>, add the list to be displayed with <code>app:list</code>:<pre class="source code">
app:list="@{viewModel.popularMovies}"</pre></li>
			</ol>
			<p><code>popularMovies</code> from <code>MovieViewModel.getPopularMovies</code> will be passed as the list of movies for <code>RecyclerView</code>.</p>
			<ol>
				<li value="8">Open <code>MainActivity</code>. In the <code>onCreate</code> function, replace the <code>setContentView</code> line with the following:<pre class="source code">
val binding: ActivityMainBinding = DataBindingUtil
.setContentView(this, R.layout.activity_main)</pre></li>
			</ol>
			<p>This sets the <code>layout</code> file to be used and creates a binding object.</p>
			<ol>
				<li value="9">Remove the collection of <code>popularMoviesView</code> from <code>movieViewModel</code>.</li>
				<li>Add the <a id="_idIndexMarker1293"/>following <a id="_idIndexMarker1294"/>after the initialization of <code>movieViewModel</code>:<pre class="source code">
binding.viewModel = movieViewModel
binding.lifecycleOwner = this</pre></li>
			</ol>
			<p>This binds <code>movieViewModel</code> to the <code>viewModel</code> layout variable in the <code>activity_main.xml</code> file.</p>
			<ol>
				<li value="11">Run the application. It should work as usual, displaying the list of popular movies, where clicking on one will open the deta<a id="_idTextAnchor801"/>ils of the movie selected:</li>
			</ol>
			<div><div><img src="img/B19411_15_02.jpg" alt="Figure 15.2 – The main screen (left) with the year’s popular movies and the details screen (right) with more information about the selected movie"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – The main screen (left) with the year’s popular movies and the details screen (right) with more information about the selected movie</p>
			<p>In this <a id="_idIndexMarker1295"/>exercise, you have used data binding on <a id="_idIndexMarker1296"/>an Android project.</p>
			<p>Data binding links the Views to the ViewModel. The ViewModel retrieves the data from the Model. Some of the libraries you can use to fetch data are Retrofit and Moshi, which you will learn more<a id="_idTextAnchor802"/><a id="_idTextAnchor803"/> about in the next section.</p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor804"/>Using Retrofit and Moshi</h1>
			<p>When connecting to your remote network, you can use Retrofit. Retrofit is an HTTP client that makes <a id="_idIndexMarker1297"/>it easy to implement creating requests and retrieving responses <a id="_idIndexMarker1298"/>from your backend server.</p>
			<p>You can add Retrofit to your project by adding the following code to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:retrofit:2.9.0'</pre>
			<p>You can then convert the JSON response from Retrofit by using Moshi, a library for parsing JSON into Java objects. For example, you can convert the JSON string response from getting the list of movies into a <code>ListofMovie</code> object for display and storage in your app.</p>
			<p>You can add the Moshi Converter to your project by adding the following code to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source code">
implementation 'com.squareup.retrofit2:
converter-moshi:2.9.0'</pre>
			<p>In your Retrofit builder code, you can call <code>addConverterFactory</code> and pass <code>Moshi</code><strong class="source inline">
</strong><code>ConverterFactory</code>:</p>
			<pre class="source code">
Retrofit.Builder()
    ...
    .addConverterFactory(MoshiConverterFactory.create())
    ...</pre>
			<p>You can call the data layer from the ViewModel. To reduce its complexity, you can use the Repository pattern for loading and caching data. You will learn ab<a id="_idTextAnchor805"/><a id="_idTextAnchor806"/>out this in the next section.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor807"/>Implementing the Repository pattern</h2>
			<p>Instead of <code>ViewModel</code> directly <a id="_idIndexMarker1299"/>calling the services for getting and storing data, it should delegate that task to another component, such as a repository.</p>
			<p>With the Repository pattern, you can move the code in the <code>ViewModel</code> that handles the data layer into a separate class. This reduces the complexity of <code>ViewModel</code>, making it easier to maintain and test. The repository will manage where the data is fetched and stored, just as if the local database or the network service w<a id="_idTextAnchor808"/>ere used to get or store data:</p>
			<div><div><img src="img/B19411_15_03.jpg" alt="Figure 15.3 – ViewModel with the Repository pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – ViewModel with the Repository pattern</p>
			<p>In <code>ViewModel</code>, you can <a id="_idIndexMarker1300"/>add a property for the repository:</p>
			<pre class="source code">
class MovieViewModel(val repository: MovieRepository):
ViewModel() { ...}</pre>
			<p><code>ViewModel</code> will get the movies from the repository, or it can listen to them. It will not know where you actually got the list from.</p>
			<p>You can create a repository interface that connects to a data source, such as in the following example:</p>
			<pre class="source code">
interface MovieRepository {
    fun getMovies(): List&lt;Movie&gt;
}</pre>
			<p>The <code>MovieRepository</code> interface has a <code>getMovies</code> function that your repository implementation class will override to fetch movies from the data source. You can also have a single repository class that handles the fetching of data from either the local database or from your remote endpoint.</p>
			<p>When using the local database as the data source for your repository, you can use the Room library, which makes it easier for you to work with the SQLite database by writing less code and having compile-time checks on queries.</p>
			<p>You can <a id="_idIndexMarker1301"/>add Room to your project by adding the following code to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source code">
implementation 'androidx.room:room-runtime:2.4.3'
implementation 'androidx.room:room-ktx:2.4.3'
kapt 'androidx.room:room-compiler:2.4.3'</pre>
			<p>Let’s try adding the Repository pattern w<a id="_idTextAnchor809"/>ith <a id="_idTextAnchor810"/>Room to an Android project.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor811"/>Exercise 15.02 – using Repository with Room in an Android project</h2>
			<p>You have added data binding in the <code>Popular Movies</code> project in the previous exercise. In this <a id="_idIndexMarker1302"/>exercise, you will update the app with the Repository pattern.</p>
			<p>When opening the app, it fetches the list of movies from the network. This takes a while. You will cache this data into the local database every time you fetch them. When the user opens the app next time, the app will immediately display the list of movies from the database on the screen. You will be using Room for data caching:</p>
			<ol>
				<li>Open the <code>Popular Movies</code> project that you used in the previous exercise.</li>
				<li>Open the <code>app/build.gradle</code> file and add the dependencies for the Room library:<pre class="source code">
implementation 'androidx.room:room-runtime:2.4.3'
implementation 'androidx.room:room-ktx:2.4.3'
kapt 'androidx.room:room-compiler:2.4.3'</pre></li>
				<li>Open the <code>Movie</code> class and add an <code>Entity</code> annotation for it:<pre class="source code">
@Entity(tableName = "movies",  primaryKeys = [("id")])
data class Movie( ... )</pre></li>
			</ol>
			<p>The <code>Entity</code> annotation will create a table named <code>movies</code> for the list of movies. It also sets <code>id</code> as the primary key of the table.</p>
			<ol>
				<li value="4">Make a <a id="_idIndexMarker1303"/>new package called <code>com.example.popularmovies.database</code>. Create a <code>MovieDao</code> data access object for accessing the <code>movies</code> table:<pre class="source code">
@Dao
interface MovieDao {
@Insert(onConflict = OnConflictStrategy.REPLACE)
fun addMovies(movies: List&lt;Movie&gt;)
@Query("SELECT * FROM movies")
fun getMovies(): List&lt;Movie&gt;
}</pre></li>
			</ol>
			<p>This class contains a function for adding a list of movies in the database and another for getting all the movies from the database.</p>
			<ol>
				<li value="5">Create a <code>MovieDatabase</code> class in the <code>com.example.popularmovies.database</code> package:<pre class="source code">
@Database(entities = [Movie::class], version = 1)
abstract class MovieDatabase : RoomDatabase() {
    abstract fun movieDao(): MovieDao
    companion object {
        @Volatile
        private var instance: MovieDatabase? = null
        fun getInstance(context: Context):
        MovieDatabase {
            return instance ?: synchronized(this) {
                instance ?: buildDatabase(
                context).also { instance = it }
            }
        }
        private fun buildDatabase(context: Context):
        MovieDatabase {
            return Room.databaseBuilder(context,
            MovieDatabase::class.java, "movie-db")
            .build()
        }
    }
}</pre></li>
			</ol>
			<p>This database has a version of <code>1</code>, a single entity for <code>Movie</code>, and the data access object <a id="_idIndexMarker1304"/>for the movies. It also has a <code>getInstance</code> function to generate an instance of the database.</p>
			<ol>
				<li value="6">Update the <code>MovieRepository</code> class with constructors for <code>movieDatabase</code>:<pre class="source code">
class MovieRepository(private val movieService:
MovieService, private val movieDatabase:
MovieDatabase) { ... }</pre></li>
				<li>Update the <code>fetchMovies</code> function:<pre class="source code">
fun fetchMovies(): Flow&lt;List&lt;Movie&gt;&gt; {
    return flow {
        val movieDao: MovieDao =
            movieDatabase.movieDao()
        val savedMovies = movieDao.getMovies()
        if(savedMovies.isEmpty()) {
            val movies = movieService
                .getPopularMovies(apiKey).results
            movieDao.addMovies(movies)
            emit(movies)
        } else {
            emit(savedMovies)
        }
    }.flowOn(Dispatchers.IO)
}</pre></li>
			</ol>
			<p>It will <a id="_idIndexMarker1305"/>fetch the movies from the database. If there’s nothing saved yet, it will retrieve the list from the network endpoint and then save it.</p>
			<ol>
				<li value="8">Open <code>MovieApplication</code> and in the <code>onCreate</code> function, replace the <code>movieRepository</code> initialization with the following:<pre class="source code">
val movieDatabase =
    MovieDatabase.getInstance(applicationContext)
movieRepository =
    MovieRepository(movieService, movieDatabase)</pre></li>
				<li>Run the application. It will display the list of popular movies, and clicking on one will open the details of the movie selected. If you turn off mobile data or disconnect from the wireless network, it will still display the list of movies, w<a id="_idTextAnchor812"/>hich is now cached in the database:</li>
			</ol>
			<div><div><img src="img/B19411_15_04.jpg" alt="Figure 15.4 – The Popular Movies app using Repository with Room"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – The Popular Movies app using Repository with Room</p>
			<p>In this <a id="_idIndexMarker1306"/>exercise, you have improved the app by moving the loading and storing of data into a repository. You have also used Room to cache the data.</p>
			<p>The repository fetches the data from the data source. If there’s no data stored in the database yet, the app will call the network to request the data. This can take a while. You can improve the user experience by pre-fetching data at a scheduled time so the next time the user opens the app, they will already see the updated contents. You can do this with WorkManager, which w<a id="_idTextAnchor813"/><a id="_idTextAnchor814"/>e will discuss in the next section.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor815"/>Using WorkManager</h1>
			<p><strong class="bold">WorkManager</strong> is a Jetpack <a id="_idIndexMarker1307"/>library for background operations that can be delayed and can run based on the constraints you set. It is ideal for doing something that must be run but can be <a id="_idIndexMarker1308"/>done later or at regular intervals, regardless of whether the app is running or not.</p>
			<p>You can use WorkManager to run tasks such as fetching the data from the network and storing it in your database at scheduled intervals. WorkManager will run the task even if the app has been closed or if the device restarts. This will keep your database up to date with your backend.</p>
			<p>You can add WorkManager to your project by adding the following code to your <code>app/build.gradle</code> file dependencies:</p>
			<pre class="source code">
implementation 'androidx.work:work-runtime:2.7.1'</pre>
			<p>WorkManager can call the repository to fetch and store data from either the local database or the network server.</p>
			<p>Let’s try addi<a id="_idTextAnchor816"/>ng Wo<a id="_idTextAnchor817"/>rkManager to an Android project.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor818"/>Exercise 15.03 – adding WorkManager to an Android Project</h2>
			<p>In the previous exercise, you added the Repository pattern with Room to cache data in the local database. The app can now fetch the data from the database instead of the network. Now, you will <a id="_idIndexMarker1309"/>be adding WorkManager to schedule <a id="_idIndexMarker1310"/>a task for fetching data from the server and saving it to the database at scheduled intervals:</p>
			<ol>
				<li>Open the Popular Movies project you used in the previous exercise.</li>
				<li>Open the <code>app/build.gradle</code> file and add the dependency for the WorkManager library:<pre class="source code">
implementation 'androidx.work:work-runtime:2.7.1'</pre></li>
			</ol>
			<p>This will allow you to add the WorkManager workers to your app.</p>
			<ol>
				<li value="3">Open <code>MovieRepository</code> and add a suspending function for fetching movies from the network using <code>apiKey</code> from <code>movieDatabase</code> and saving them to the database:<pre class="source code">
suspend fun fetchMoviesFromNetwork() {
    val movieDao: MovieDao = movieDatabase.movieDao()
    try {
        val popularMovies = movieService
            .getPopularMovies(apiKey)
        val moviesFetched = popularMovies.results
        movieDao.addMovies(moviesFetched)
    } catch (exception: Exception) {
        Log.d("MovieRepository", "An error occurred:
            ${exception.message}")
    }
}</pre></li>
			</ol>
			<p>This will <a id="_idIndexMarker1311"/>be the function that will be called <a id="_idIndexMarker1312"/>by the <code>Worker</code> class that will be running to fetch and save the movies.</p>
			<ol>
				<li value="4">Create the <code>MovieWorker</code> class in the <code>com.example.popularmovies</code> package:<pre class="source code">
class MovieWorker(private val context: Context,
params: WorkerParameters) : Worker(context, params) {
    override fun doWork(): Result {
        val movieRepository = (context as
        MovieApplication).movieRepository
        CoroutineScope(Dispatchers.IO).launch {
            movieRepository.fetchMoviesFromNetwork()
        }
        return Result.success()
    }
}</pre></li>
				<li>Open <code>MovieApplication</code> and <a id="_idIndexMarker1313"/>at the end <a id="_idIndexMarker1314"/>of the <code>onCreate</code> function, schedule <code>MovieWorker</code> to retrieve and save the movies:<pre class="source code">
override fun onCreate() {
    ...
    val constraints =
        Constraints.Builder().setRequiredNetworkType(
        NetworkType.CONNECTED).build()
    val workRequest = PeriodicWorkRequest
        .Builder(MovieWorker::class.java, 1,
        TimeUnit.HOURS).setConstraints(constraints)
        .addTag("movie-work").build()
    WorkManager.getInstance(
        applicationContext).enqueue(workRequest)
}</pre></li>
			</ol>
			<p>This schedules <code>MovieWorker</code> to run every hour when the device is connected to the network. <code>MovieWorker</code> will fetch the list of movies from the network and save it to the local database.</p>
			<ol>
				<li value="6">Run the application. Close it and make sure the device is connected to the internet. After more than an hour, open the application again and check whether the list of movies displayed has been updated. If not, try again in a few hours. The list of movies <a id="_idIndexMarker1315"/>displayed will be updated regularly, around <a id="_idTextAnchor819"/><a id="_idIndexMarker1316"/>every hour, even if the app has been closed.</li>
			</ol>
			<div><div><img src="img/B19411_15_041.jpg" alt="Figure 15.5 – The Popular Movies app updates its list with WorkManager"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – The Popular Movies app updates its list with WorkManager</p>
			<p>In this exercise, you added WorkManager to your application to automatically update the database with the li<a id="_idTextAnchor820"/>st of <a id="_idTextAnchor821"/>the movies retrieved from the network.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor822"/>Activity 15.01 – revisiting the TV Guide app</h2>
			<p>In the previous chapter, you developed an app that can display a list of TV shows that are on the air. The app <a id="_idIndexMarker1317"/>had two screens: the main screen and the details screen. On the main screen, there’s a list of TV shows. When clicking on a TV show, the details screen will be displayed with the details of the selected show.</p>
			<p>When running the app, it takes a while to display the list of shows. Update the app to cache the list so it will be immediately displayed when opening the app. Also, improve the app by using MVVM with data binding and adding WorkManager.</p>
			<p>You can use the TV Guide app you worked on in the previous chapter or download it from the GitHub repository (<a href="https://packt.link/Eti8M">https://packt.link/Eti8M</a>). The following ste<a id="_idTextAnchor823"/>ps will help guide you through this activity:</p>
			<ol>
				<li>Open the TV Guide app in Android Studio. Open the <code>app/build.gradle</code> file and add the <code>kotlin-kapt</code> plugin, the data binding dependency, and the dependencies for Room and WorkManager.</li>
				<li>Create a binding adapter class for <code>RecyclerView</code>.</li>
				<li>In <code>activity_main.xml</code>, wrap everything inside a <code>layout</code> tag.</li>
				<li>Inside the <code>layout</code> tag and before the <code>ConstraintLayout</code> tag, add a data element with a variable for <code>ViewModel</code>.</li>
				<li>In <code>RecyclerView</code>, add the list to be displayed with <code>app:list</code>.</li>
				<li>In <code>MainActivity</code>, replace the line for <code>setContentView</code> with the <code>DataBindingUtil.setContentView</code> function.</li>
				<li>Replace the observer from <code>TVShowViewModel</code> with the data binding code.</li>
				<li>Add an <code>Entity</code> annotation in the <code>TVShow</code> class.</li>
				<li>Create a <code>TVDao</code> data access object for accessing the <code>TV </code><code>shows</code> table.</li>
				<li>Create a <code>TVDatabase</code> class.</li>
				<li>Update <code>TVShowRepository</code> with a constructor for <code>tvDatabase</code>.</li>
				<li>Update the <code>fetchTVShows</code> function to get the TV shows from the local database. If there’s nothing there yet, retrieve the list from the endpoint and save it in the database.</li>
				<li>Add a suspending <code>fetchTVShowsFromNetwork</code> function to get the TV shows from the network and save them to the database.</li>
				<li>Create the <code>TVShowWorker</code> class.</li>
				<li>Open the <code>TVApplication</code> file. In <code>onCreate</code>, schedule <code>TVShowWorker</code> to retrieve and save the shows.</li>
				<li>Run your <a id="_idIndexMarker1318"/>application. The app will display a list of TV shows. Clicking on a TV show will open the details activity, which displays the movie details. The main screen and de<a id="_idTextAnchor824"/>tails screen will be similar to the following:</li>
			</ol>
			<div><div><img src="img/B19411_15_05.jpg" alt="Figure 15.6 – The main screen and details screen of the TV Guide app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – The main screen and details screen of the TV Guide app</p>
			<p class="callout heading">Note</p>
			<p class="callout">The solution <a id="_idIndexMarker1319"/>to this activity can be found at <a href="https://packt.link/By7eE">https://packt.link/By7eE</a>.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor825"/>Summary</h1>
			<p>This chapter focused on architectural patterns for Android. You started with the MVVM architectural pattern. You learned about its three components: the Model, the View, and the ViewModel. You also used data binding to link the View with the ViewModel.</p>
			<p>Next, you learned about how the Repository pattern can be used to cache data. Then, you learned about WorkManager and how you can schedule tasks such as retrieving data from the network and saving that data to the database to update your local data.</p>
			<p>In the next chapter, you will learn how to improve the look and design of your apps with animations. You will add animations and transitions to your apps with <code>CoordinatorLayout</code> and <code>MotionLayout</code>.</p>
		</div>
	</body></html>