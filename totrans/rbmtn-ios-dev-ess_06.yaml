- en: Chapter 6. Device Capability – Power Unleashed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*"Software will give you respect, but hardware will give you the Power."*'
  prefs: []
  type: TYPE_NORMAL
- en: '*- Akshat Paul*'
  prefs: []
  type: TYPE_NORMAL
- en: An iPhone is not only used for making calls, surfing the Internet, and playing
    music, but it is also the most advanced piece of hardware that can be used to
    take pictures, know your present location, comprehend gestures, and to do so many
    other things. So why not take advantage of these incredible device capabilities
    in your application. The beauty of these features is that just by tapping into
    the tools that the iPhone SDK provides, one can quickly import pictures, locations,
    and maps with minimal lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location Manager (GPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Address Book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera – smile please!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The camera is probably the most widely used feature of an iOS device. In this
    section, we will cover the most frequently used Camera events by creating an application
    that will allow us to take a picture using the Camera device and to select a picture
    from the Gallery.
  prefs: []
  type: TYPE_NORMAL
- en: An iPhone implements image selection through a picker that allows us to get
    images from different sources, such as Camera Roll or Photo Library. The `UIImagePickerController`
    class provides basic, customizable user interfaces (UIs) for taking pictures and
    videos, also providing the user with some simple editing capabilities for newly
    captured media.
  prefs: []
  type: TYPE_NORMAL
- en: 'The role and appearance of a `UIImagePickerController` class depends on the
    value of `sourceType` assigned to it. There are three ways to choose the source
    of an image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose from Camera:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Choose from any folder in Gallery:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Choose from Photo Album (Camera Roll):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Camera example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create an application that will allow us to capture a photo from the
    camera and select an image from Photo Gallery. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application with the `motion` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `app_delegate.rb` and set the root controller to `CameraController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named `camera_controller.rb` inside the `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s see what we have done so far by testing our application on the simulator
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the results as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Camera example](img/5220OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we are using an iPhone simulator, we cannot access the camera hardware.
    However, if we test our application with an iPhone device, we will be able to
    use the camera hardware and capture images from it. Now let''s choose an image
    from Gallery by clicking on the **Choose from Gallery** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Camera example](img/5220OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the Camera code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we need to initiate two buttons for the photo-taking process and choose
    a picture from Gallery. We will also create an image picker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So when we click on the **Click from camera** and **Choose from Gallery** buttons,
    the `start_camera` and `open_gallery` actions will be called, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So we have used `UIImagePickerControllerSourceTypeCamera` and `UIImagePickerControllerSourceTypePhotoLibrary`
    as source types; they will open the Camera and Photo Library tools, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an iOS application can also be installed on devices such as an iPod, which
    does not have a camera, to check the device for a camera, the `UIImagePickerController.isSourceTypeAvailable(UIImagePickerControllerSourceTypeCamera)`
    method is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two camera picker delegates are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`imagePickerController:didFinishPickingImage`: This is called when the image
    is selected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imagePickerControllerDidCancel`: This is called when the **Cancel** button
    is clicked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following delegate will be called when an image is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `self.dismissModalViewControllerAnimated(true)` method is called explicitly
    to remove the pop-up, and then the image is displayed using `UIImageView`.
  prefs: []
  type: TYPE_NORMAL
- en: Location Manager – directions for apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You must have observed that in many iOS applications, your current location
    is spotted automatically. With RubyMotion, we can easily use the location capabilities
    of your device with our application. There are two parts to this: the first is
    to find the device location and the second is to display it in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: iOS SDK contains various layers; one of them is the **Core Services** layer
    and a part of this layer is the **Core Location** framework. This framework uses
    the available hardware to determine a user's current position and where they are
    heading. Core Location provides us with coordinates, text strings, and number
    values instead of visual location information such as maps. Later in the chapter,
    we will also use Map Kit that will help us embed maps directly in our views using
    our knowledge of the Core Location framework.
  prefs: []
  type: TYPE_NORMAL
- en: Location Manager example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create an application to demonstrate how we can use Location Manager
    with the RubyMotion application. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application with the `motion` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `app_delegate.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `rake` file and add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the Location service, we have to include the following two frameworks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`CoreLocation`: The `CoreLocation` framework lets you determine the current
    location. This framework uses the available hardware of the device to determine
    the device''s current position and where it is heading.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapKit`: The `MapKit` framework provides an interface for embedding maps directly
    into your app''s views.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the `location_controller.rb` controller in the `app` folder and add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we configured the `CLLocationManager` object using the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Always check to see whether the desired services are available before starting
    any service and abandon the operation if they are not. You can do so by triggering
    `CLLocationManager.locationServicesEnable`. If this returns `true`, the service
    has been enabled for your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The user has the option of denying applications the ability to access its Location
    service data. During the initial use by an application, the Core Location framework
    prompts the user to confirm that using the Location service is acceptable. If
    the user denies the request, the `CLLocationManager` object reports an appropriate
    error to the delegate in future requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then we created an instance of the `CLLocationManager` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we configured additional properties relevant to the Location service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`desiredAccuracy` supports a wide range of methods that provide different levels
    of accuracy. You can also use `KCLLocationAccuracyBest`; it will give you more
    accurate results but it will also drain the battery. `KCLLocationAccuracyKilometer`
    doesn''t give an accurate location but is more effective in terms of performance.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This message will appear when the application asks for permissions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then we created a delegate to handle the latitude and longitude for our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, we called the appropriate start method to begin the delivery of events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s fire up the terminal and test our app using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Location Manager example](img/5220OT_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If your location is not set in your simulator, you will get a pop-up showing
    an error, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: As we are using the iOS simulator, we do not have physical GPS access for the
    iPhone device. However, iOS simulator does give us the option to mimic this by
    selecting or adding values via the emulator. From the toolbar, navigate to **Debug**
    | **Location** and either choose or add custom longitude and latitude values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Location Manager example](img/5220OT_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see a pop-up on the screen with a custom message, which we had described
    in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Location Manager example](img/5220OT_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we click on **OK**, we will see the longitude and latitude of our current
    location as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Location Manager example](img/5220OT_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now let's plot the current location on a map and display this on our screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `location_controller.rb` file in the `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have chosen `MKMapTypeStandard`, but `MKMapView` provides the following
    three types of maps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`MKMapTypeStandard`: This shows a street and some road names'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKMapTypeSatellite`: This shows satellite imagery'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MKMapTypeHybrid`: This shows a satellite image of the area with roads and
    their names along with other information superimposed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, add the following code in the `viewDidLoad` method in the `location_controller.rb`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the application in the simulator using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Location Manager example](img/5220OT_06_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The preceding code will only show a map on the screen and not pinpoint the location.
    We are now going to add a pin—annotations in MapKit terms—to our map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `show_map` method in the `location_controller.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CLLocationCoordinate2D` is a structure that contains the geographical coordinate
    of a location.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add the pin (Annotation), you must create a class that explicitly implements
    the `MKAnnotation` protocol. We should define the following attributes in this
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`coordinate`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtitle`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a file named `my_annotation.rb` inside the `app` folder. Create
    a class named `MyAnnotation` that has these attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `location_controller.rb` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s fire up the terminal and run our application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Location Manager example](img/5220OT_06_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: In the preceding screenshot, we can see a map with the current location and
    its description.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can change the location in the simulator by navigating to **Debug** | **Change
    Location**.
  prefs: []
  type: TYPE_NORMAL
- en: Gestures – non-verbal communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gestures are a big part of iOS applications. For example, when we pinch on a
    picture, it gets zoomed, or when we rotate our device, the orientation of the
    picture changes. Detecting gestures in your application is very easy with the
    built-in `UIGestureRecognizer` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few subclasses of `UIGestureRecognizer`, each designed to detect
    a specific type of gesture. You can handle the most commonly used gestures with
    the following subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UITapGestureRecognizer`: This class detects the tapping gesture made on the
    device screen by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIPinchGestureRecognizer`: This class detects the pinching gesture made on
    screen by the user. This motion is usually used to zoom in or out of a view or
    to change the size of a visual component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIPanGestureRecognizer`: This class detects the dragging or panning gesture
    that the user makes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UISwipeGestureRecognizer`: This class detects when the user makes a swiping
    gesture across the screen. Instances of this class may be configured to detect
    motion only in a specific direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIRotationGestureRecognizer`: This class identifies the rotation gesture that
    the user makes. (To make a rotation gesture, move two fingers located opposite
    each other in contact with the screen and move them in a circular motion.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UILongPressGestureRecognizer`: This class is used to identify when the user
    touches the screen with one or more fingers for a specified period of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gesture example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an example of how the gesture feature can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an application that will help us understand the various gestures we
    have discussed in the last section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `app_delegate.rb` file in the `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a file named `gesture_controller.rb` in the `app` folder and add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Gesture example](img/5220OT_06_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You must be wondering how we can use multi-touch on a simulator. To use this
    feature on a simulator, hold the *Option* key; doing this will display two circles
    on the simulator screen. You can move them in the desired direction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Gesture example](img/5220OT_06_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Now let''s understand the code. First, we created a different recognizer for
    each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For each recognizer, we'll call an action. This means that whenever the user
    creates a pattern or makes a gesture, such as a rotation, its corresponding action
    is called. For example, when a user tries to pinch the view, `pinchGestureRecognizer`
    gets called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that after we have created the recognizers, we need to add them to
    the view so that users can interact with them. We did this by adding them to the
    `addGestureRecognizer()` method by passing the recognizer object to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we created actions for each gesture. We are just showing a pop-up when
    the user shows any of the common gestures. For example, when we pinch, the following
    code is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This action is called in several states, such as when pinching starts and when
    pinching stops. For discrete gestures, such as a tapping gesture, the gesture
    recognizer invokes the method once per recognition; for continuous gestures, the
    gesture recognizer invokes the method at repeated intervals until the gesture
    ends (that is, until the last finger is lifted from the gesture recognizer''s
    view). So, there can be many states that you can find by `UIGestureRecognizerState`.
    Its value can be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStatePossible`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStateBegan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStateChanged`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStateEnded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStateCancelled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStateFailed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIGestureRecognizerStateRecognized` = `UIGestureRecognizerStateEnded`![Gesture
    example](img/5220OT_06_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As shown in the preceding figure, when a gesture is recognized, every subsequent
    state transition causes an action message to be sent to the target. When a gesture
    recognizer reaches the **Recognized** or **Ended** state, it is asked to reset
    its internal state in preparation for a new attempt at recognizing the gesture.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Responses to the gestures should be in line with what the users expect. For
    example, a pinching gesture should scale a view, zooming it in and out; it should
    not be interpreted as, say, a selection request, for which a tap is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Do it yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can implement your own custom gesture recognizer. To implement this, first
    create a subclass of `UIGestureRecognizer`. Then you can override the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reset`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touchesBegan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touchesMoved`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touchesEnded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touchesCancelled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Data – manage your data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes applications are required to save and manipulate user data. iOS SDK
    provides a framework for this purpose known as Core Data.
  prefs: []
  type: TYPE_NORMAL
- en: The **Core Data** framework provides comprehensive and automated solutions related
    to an object's life cycle and its searching and persistence features. It can retrieve
    and manipulate data purely on an object level without having to worry about the
    details of storage and retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: With Core Data, data can be handled using higher-level objects indicating entities
    and their relationships. Core Data interfaces directly with SQLite, separating
    the developer from the underlying SQL.
  prefs: []
  type: TYPE_NORMAL
- en: So does it mean Core Data is a database? No; Core Data is not a database and
    the best example of this is that Core Data can be used totally in memory without
    any form of persistence. Then is Core Data similar to an ORM such as Active Record
    or Hibernate? No; Core Data is an object graph manager with life cycle, searching,
    and persistence features. With Core Data, an app can define a database schema,
    create a database file, and create and manage record data.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a simple employee application that will allow us to add the
    name and age of an employee. This example is only used to demonstrate how Core
    Data works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an application using the `motion` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `CoreData` framework in the `rake.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will be an MVC application, so let''s create a model named `employee.rb`
    in the `app` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You must have noticed that we have inherited the `Employee` class from `NSManagedObject`.
    We have created an array of arrays for attributes in the `employee` table with
    the attributes `name` and `age`. You must be wondering what other parameters there
    are in this array. To understand this, we will have to write a few helpers in
    our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s create a folder named `helper` and add a file named `NSEntityDescription.rb`
    with the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The attributes that we have created in the employee model are defined through
    this class. For each attribute, the `NSAttributeDescription` class will be used
    to define them. The `NSAttributeDescription` class is used to describe attributes
    of an entity described by an instance of `NSEntityDescription`. It is inherited
    from `NSPropertyDescription`, which provides most of the basic behavior. Instances
    of `NSAttributeDescription` are used to describe attributes, as distinct from
    relationships. We can define many properties for an object of `NSAttributeDescription`;
    for example, we can put a validation on it, we can index the attribute, and much
    more.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a file named `NSManagedObject.rb` in the `app` folder and add
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An `NSEntityDescription` object describes an entity in Core Data. An entity
    to a manage object is what a class is to an ID or, to use a database analogy,
    what tables are to rows. An `NSEntityDescription` object may have `NSAttributeDescription`
    and `NSRelationshipDescription` objects that represent the properties of the entity
    in the schema. An entity may also have fetched properties, represented by instances
    of `NSFetchedPropertyDescription`, and the model may have fetched request templates,
    represented by instances of `NSFetchRequest`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `app_delegate.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Till now we have done some basic settings that we are required to do before
    actually using database operations. In this case, we are stating that our objects
    must be stored in a SQLite database at a location we define in our code with the
    filename `EmployeeStore.sqlite`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the preceding code, we have created an object of `NSManagedObjectModel` with
    all the entities. You can think of this object as a reference of the objects to
    be used by Core Data. The next object needed is the `NSPersistentStoreCoordinator`
    object that will allow Core Data to persist the information. It is also responsible
    for choosing a location to save our objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the last part of our code, we have used the most important class, which is
    the `NSManagedObjectContext` class. This class is responsible for creating, destroying,
    and fetching the objects. An instance of `NSManagedObjectContext` represents a
    single "object space" or scratch pad in an application. Its primary responsibility
    is to manage a collection of managed objects. These objects form a group of related
    model objects that represent an internally consistent view of one or more persistent
    stores. A single managed object instance exists in one and only one context, but
    multiple copies of an object can exist in different contexts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s fire up the terminal and run our application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Core Data example](img/5220OT_06_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'You will see a blank screen as we have not yet created the controller and view.
    We will create them in the next section, but before that, let''s first update
    the `app_delegate` file to accommodate the controller and view with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating an employee
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last part of the previous code snippet, we initialized `EmployeeViewController`.
    Next, we will pass the managed object context to the next controller that will
    later be used for either creating, fetching, or deleting objects. And in the end,
    we will create a window and assign `EmployeeViewController` as its root controller:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `employee_view_controller.rb` in the `app` folder with
    the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s fetch specific objects using the `NSFetchRequest` object. We also
    need to tell Core Data which entity we want to retrieve. This can be done using
    `NSEntityDescription`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's a lot of code; let's try to understand it. First, we created a `tableView`
    to create a table as it's the best way to represent this type of data. Then, we
    created a **+** button at the top of the navigation bar with the `add_new_employee`
    action associated with it. When this button is pressed, it calls the `add_new_employee`
    action that, in turn, calls a new view, shows a form, and adds a new employee.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we created a `reload_data` method that will be called to refresh the view
    with employee data. It will fetch the employee data using the `NSFetchRequest`
    object. Then, we declared `NSEntityDescription` for the `Employee` object so we
    can tell Core Data which entity we want to retrieve. We also sorted the result
    by name using `NSSortDescriptor`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the last part of our example, we created an `update_fetched_employee_with_fetch_request`
    method that will fetch the employee array and update the table to show all of
    the data. `NSManagedObjectContext` executes the fetch request that we created
    using the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create the view that will be called when the **+** button is
    clicked on. Let''s create a file named `add_employee_view_controller.rb` and add
    the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the preceding code, we created two text fields, one for name and the other
    for age and we first added a **Save** button on top of the view that will save
    the employee details by calling the `save_employee` action. In the `save_employee`
    action, we used Core Data to create a new instance of the `employee` object in
    the following way:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we assigned the value of the text field to the `employee` object and finally
    saved that object and navigated to `EmployeeViewController`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s fire up the terminal and run our application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Creating an employee](img/5220OT_06_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, let's add data to the **Employee** form using the view:![Creating an employee](img/5220OT_06_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting the employee
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the completion of the last section, our Core Data application is capable
    of adding new employee records. But there may be instances when we''ll need to
    delete an employee record. In this section, we''ll enhance our app to delete employee
    records. The use case for this feature will be such that when we slide any row,
    the system will ask for a confirmation. And once we confirm, the record will be
    deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `employee_view_controller.rb` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the iOS `tableView`, we have a direct way of creating or deleting a row.
    In the preceding code, we first passed the value `true` to the `tableView(tableView,
    canEditRowAtIndexPath: indexPath)` delegate. Then in order to perform a delete
    action, we defined the `tableView(tableView, commitEditingStyle: editingStyle,
    forRowAtIndexPath: indexPath)` delegate.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we fetch the row that we want to delete, we use `NSManagedObjectContext`
    to delete that object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that we have to always call `save` to persist it to our database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s fire up the terminal and run the application using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Deleting the employee](img/5220OT_06_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As shown in the preceding screenshot, when we slide the row, we get a system
    prompt to delete the row. And once we click on **Delete**, the row gets deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Address Book – manage your contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Address Book for iOS provides a way to store the contact information and other
    personal information of people in a centralized database that can then be shared
    between various applications. In this section, we will perform basic operations
    related to the Address Book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following operations in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Access the device's Address Book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a desired user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy data from the Address Book into our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to work with an Address Book:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a sample address book application with our favorite `motion`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create a controller named `addressbook_controller.rb` and replace
    the following code in `app_delegate.rb` so that our delegate points to our address
    book controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in our `addressbook_controller.rb` controller, which will initially be
    empty, we will add a button and two labels. With the button, we will access our
    Address Book and thereafter choose the desired contact. In the labels, we will
    display the data of the user that we had selected from the Address Book. Let''s
    add the following code in our `addressbook_controller` controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s `rake` and see the progress so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Address Book – manage your contacts](img/5220OT_06_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the preceding step, we mentioned about a `phonebook_access` method; let''s
    create it. This method will help us access our device''s Address Book. Further,
    let''s add the following code to our `addressbook_controller.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, let's execute the `rake` command and see if we are able to access
    the Address Book by clicking on the **Click for contacts** button:![Address Book
    – manage your contacts](img/5220OT_06_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the last step, we are in our Address Book and can see the list of contacts.
    Next, we need to add a method that will copy the desired contact and navigate
    back to our application. This can be done with `peoplePickerNavigationController`.
    Further, we''ll add the following code in `addressbook_controller`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to display all of the data we have copied from the Address Book.
    This can be done using the `displayPerson` method that will let us use the saved
    values. Add the following method to `addressbook_controller`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Address Book – manage your contacts](img/5220OT_06_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Great! But we have missed something. What if a user changes his mind and does
    not want any contact? We need to find a way to get back to the original application
    from the Address Book. This can be done by adding the following three-line method
    in `addressbook_controller`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Do it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we have learned a lot; now let''s use our acquired knowledge and improvise
    our restro application by implementing the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – show nearest restaurant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get data from the server, use the `http://restro.nalwaya.com/restaurants/find_restaurent_distance.json?latitude=#{latitude}&&longitude=#{longitude}`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: You have to pass the latitude and longitude with this request, and in return,
    you will get a list of restaurants in the JSON format. Use this as input and create
    a view displaying the results.
  prefs: []
  type: TYPE_NORMAL
- en: Task 2 – mark each restaurant on a map with a pin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `http://restro.nalwaya.com/restaurants/search.json?city={city_name}`
    API that will give you a list of restaurants with their latitude and longitude
    in the JSON format. Use these coordinates to show their location on the map.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are done with this exercise, compare your solution with the one available
    in the chapter code available with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is what we have learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to access Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Core Location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use different device gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to store data on a phone using Core Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to access the Address Book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are acclimatized with the basics of RubyMotion, in the next chapter
    we will dig deep into the advanced features of iOS SDK with RubyMotion. iOS SDK
    is very powerful and has vast functionalities. In the next chapter, we will discuss
    how to use `.storyboard`, `.xib`, and `WebView` in detail, to create a truly interactive
    application.
  prefs: []
  type: TYPE_NORMAL
