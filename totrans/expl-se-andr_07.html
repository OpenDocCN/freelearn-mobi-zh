<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Utilizing Audit Logs"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Utilizing Audit Logs</h1></div></div></div><p>So far we've seen AVC records or the SELinux denial messages show up in <code class="literal">dmesg</code>, but <code class="literal">dmesg</code> is a circular memory buffer, subject to frequent rollover dependent on how verbose your kernel is. By using the audit kernel subsystem, we can route these messages into user space and log them to disk. On the desktop, the daemon that does this is called <code class="literal">auditd</code>. A minimal port of <code class="literal">auditd</code> is maintained in the NSA branches however, it has not officially been merged into AOSP. We are going to use the <code class="literal">auditd</code> version from the NSA branches since we are working on Android 4.3. The officially merged version as of April 7, 2014 can be found at <a class="ulink" href="https://android-review.googlesource.com/#/c/89645/">https://android-review.googlesource.com/#/c/89645/</a>. It's implemented within <code class="literal">logd</code>, and merged at <a class="ulink" href="https://android-review.googlesource.com/#/c/83526/">https://android-review.googlesource.com/#/c/83526/</a>.</p><p>In this chapter, we will:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Update <a id="id184" class="indexterm"/>our system with the fast-paced SE for <span class="strong"><strong>Android Open Source Community</strong></span> (<span class="strong"><strong>AOSP</strong></span>)</li><li class="listitem" style="list-style-type: disc">Investigate how the audit subsystem works</li><li class="listitem" style="list-style-type: disc">Learn to read SELinux audit logs and start writing policy</li><li class="listitem" style="list-style-type: disc">Look at contexts relative to the logs</li></ul></div><p>All LSMs should log their messages into the audit subsystem. The audit subsystem can then route the messages to the kernel circular buffer using <code class="literal">printk</code>, or to the auditing daemon in user space, if one is present. The kernel and userspace logging daemon communicate using the <code class="literal">AUDIT_NETLINK</code> socket. We will dissect this interface further in the chapter.</p><p>Lastly, the audit subsystem has the capability to print comprehensive records when policy violations occur. Although you don't need this feature to enable and work with SELinux, it can make your life easier. To enable this system, you must use <code class="literal">auditd</code>, because <code class="literal">logd</code> currently doesn't have this support. You'll need to build your kernel with <code class="literal">CONFIG_AUDITSYSCALL=y</code> and place an <code class="literal">audit.rules</code> file in <code class="literal">/data/misc/audit/</code>. After you patch your tree with the following instructions, read <code class="literal">system/core/auditd/README</code>.</p><p>Unfortunately, the UDOO kernel version 3.0.35 does not support <code class="literal">CONFIG_AUDITSYSCALL</code>. The patch located at <a class="ulink" href="https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b">https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=29ef73b7a823b77a7cd0bdd7d7cded3fb6c2587b</a> should enable the support. However, on the UDOO, it causes a deadlock we could not trace down.</p><div class="section" title="Upgrades – patches galore"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Upgrades – patches galore</h1></div></div></div><p>Although <a id="id185" class="indexterm"/>Android 4.3, released from Google, had SE for Android support, it is still limited, especially in the areas of auditing. One of the simplest ways to bring this to a more useable state is to get the patches for some of the projects from the NSA's SE for Android 4.3 branch. Here, the community has staged and deployed many of the more advanced features which were not merged in the 4.3 timeframe.</p><p>The NSA maintains repositories at <a class="ulink" href="https://bitbucket.org/seandroid/">https://bitbucket.org/seandroid/</a>. There are many<a id="id186" class="indexterm"/> projects so figuring out which to use and what branch can be daunting. A way to find them is to go through each project and find the projects with a <code class="literal">SEAndroid-4.3</code> branch. You don't need to descend into the device trees since we're not <a id="id187" class="indexterm"/>building AOSP devices. The list of such project is:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://bitbucket.org/seandroid/system-core">https://bitbucket.org/seandroid/system-core</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://bitbucket.org/seandroid/frameworks-base">https://bitbucket.org/seandroid/frameworks-base</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://bitbucket.org/seandroid/external-libselinux">https://bitbucket.org/seandroid/external-libselinux</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://bitbucket.org/seandroid/build">https://bitbucket.org/seandroid/build</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://bitbucket.org/seandroid/frameworks-native">https://bitbucket.org/seandroid/frameworks-native</a></li></ul></div><p>We can also safely skip <code class="literal">sepolicy</code> since we've already updated it to the bleeding edge, but the kernels<a id="id188" class="indexterm"/> are a bit trickier. We need the changes from kernel-common (<a class="ulink" href="https://bitbucket.org/seandroid/kernel-common">https://bitbucket.org/seandroid/kernel-common</a>) and the binder <a id="id189" class="indexterm"/>patch (<a class="ulink" href="https://android-review.googlesource.com/#/c/45984/">https://android-review.googlesource.com/#/c/45984/</a>), which can be attained as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir ~/sepatches</strong></span>
<span class="strong"><strong>$ cd ~/sepatches</strong></span>
<span class="strong"><strong>$ git clone https://bitbucket.org/seandroid/system-core.git</strong></span>
<span class="strong"><strong>$ git clone https://bitbucket.org/seandroid/frameworks-base.git</strong></span>
<span class="strong"><strong>$ git clone https://bitbucket.org/seandroid/external-libselinux.git</strong></span>
<span class="strong"><strong>$ git clone https://bitbucket.org/seandroid/build.git</strong></span>
<span class="strong"><strong>$ git clone https://bitbucket.org/seandroid/frameworks-native.git</strong></span>
</pre></div><p>We can start by figuring out the exact version we need to patch to by looking at the <code class="literal">build/core/build_id.mk</code> file, and by using the webpage <a class="ulink" href="https://source.android.com/source/build-numbers.html">https://source.android.com/source/build-numbers.html</a> to do a lookup.</p><p>The file shows <code class="literal">BUILD_ID</code> is <code class="literal">JSS15J</code>, and the lookup shows that we are working with the <code class="literal">android-4.3_r2.1</code> release for the UDOO.</p><p>For each downloaded project so far, generate the patches by running the command <code class="literal">git checkout origin/seandroid-4.3_r2</code>. Finally, execute <code class="literal">git format-patch origin/jb-mr2.0-release</code>. Since there is no <code class="literal">4.3._r2.1</code> branch, we're using <code class="literal">r2</code>.</p><p>For each<a id="id190" class="indexterm"/> of these patches, you'll need to apply them in the tree from their corresponding <code class="literal">udoo/&lt;project&gt;</code> folder. It is important to apply the patches for each project in numeric order starting with the <code class="literal">0001*</code> patch, moving on to <code class="literal">0002*</code>, and so on. As an example of how to apply a specific patch for a project, let's look at the first patch needed for <code class="literal">system-core</code>. Note that these Git repositories use hyphens in place of the slashes in the source tree; so <code class="literal">frameworks-base</code> correlates to <code class="literal">frameworks/base</code>.</p><p>First, generate the patches:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd sepatches/system-core</strong></span>
<span class="strong"><strong>$ git checkout origin/seandroid-4.3_r2</strong></span>
<span class="strong"><strong>$ git format-patch origin/jb-mr2.0-release</strong></span>
</pre></div><p>Apply the first patch, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd &lt;udoo_root&gt;/system/core</strong></span>
<span class="strong"><strong>$ patch -p1 &lt; ~/sepatches/system-core/0001-Add-writable-data-space-for-radio.patch </strong></span>
<span class="strong"><strong>patching file rootdir/init.rc</strong></span>
<span class="strong"><strong>Reversed (or previously applied) patch detected! Assume -R? [n] </strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>Note that for UDOO, it is important not to apply a patch number higher than <code class="literal">0005</code> in <code class="literal">frameworks/base</code>. For other projects, you should apply all the patches.</p></div></div><p>Note the error. Just hit <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> to quit the patching process whenever you see this. The Git trees are not quite perfect, and because of this, some of the patches are already in the UDOO source. The patch command will let us know, and we can skip these by canceling them, when warned, with <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span>. Keep going through the patches, canceling the ones already applied, and fixing up any failures. After patching userspace, it's <span class="emphasis"><em>highly</em></span> recommended that you build to ensure nothing is broken.</p><p>Once <a id="id191" class="indexterm"/>userspace is completely patched, we need to patch the kernel. Start by cloning the kernel-common project from Bitbucket with the <code class="literal">git clone https://bitbucket.org/seandroid/kernel-common.git</code> command. We will patch the kernel with the same method as the rest of the projects with the exception of the binder patch. By viewing the <a id="id192" class="indexterm"/>link for the binder patch mentioned, <a class="ulink" href="https://android-review.googlesource.com/#/c/45984/">https://android-review.googlesource.com/#/c/45984/</a>, we found that the Git SHA hash is <code class="literal">a3c9991b560cf0a8dec1622fcc0edca5d0ced936</code>, as given in the <span class="strong"><strong>Patch set 4</strong></span> reference field in the following screenshot:</p><div class="mediaobject"><img src="graphics/0594OS_7_1.jpg" alt="Upgrades – patches galore"/></div><p>We can then<a id="id193" class="indexterm"/> generate the patch for this SHA hash:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ git format-patch -1 a3c9991b560cf0a8dec1622fcc0edca5d0ced936</strong></span>
<span class="strong"><strong>0001-Add-security-hooks-to-binder-and-implement-the-hooks.patch</strong></span>
</pre></div><p>Then, apply that patch with the patch command as we did before. The patch has a failed hunk for a header file inclusion; just fix it up like the others by using the reject file. When you build, you'll get this error in the kernel:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>security/selinux/hooks.c:1846:9: error: variable 'sad' has initializer but incomplete type</strong></span>
<span class="strong"><strong>security/selinux/hooks.c:1846:28: error: storage size of 'sad' isn't known</strong></span>
</pre></div><p>Go ahead and remove this line and all references. This was a change made in the 3.0 kernels:</p><div class="informalexample"><pre class="programlisting">struct selinux_audit_data sad = {0,};
ad.selinux_audit_data = &amp;sad;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>We figured this out by looking through the original 3.0 patches, which can be found at following link:</p><p>
<a class="ulink" href="https://bitbucket.org/seandroid/kernel-omap/commits/59bc19226c746f479edc2acca9a41f60669cbe82?at=seandroid-omap-tuna-3.0">https://bitbucket.org/seandroid/kernel-omap/commits/59bc19226c746f479edc2acca9a41f60669cbe82?at=seandroid-omap-tuna-3.0</a>
</p></div></div><p>As you recall, the UDOO uses a custom <code class="literal">init.rc</code>. We need to add any changes to <code class="literal">init.rc</code> to the one UDOO actually uses. All the patches that can modify <code class="literal">init.rc</code> will be in the system-core project, specifically these:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0003-Auditd-initial-commit.patch</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">0007-Handle-policy-reloads-within-ueventd-rather-than-res.patch</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">0009-Allow-system-UID-to-set-enforcing-and-booleans.patch</code></li></ul></div><p>Go ahead <a id="id194" class="indexterm"/>and find the changes to <code class="literal">init.rc</code> in these patches and apply them to <code class="literal">device/fsl/imx6/etc/init.rc</code> using the same patch technique.</p></div></div>
<div class="section" title="The audit system"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>The audit system</h1></div></div></div><p>In the<a id="id195" class="indexterm"/> previous section, we did a lot of patching; the point of which was to enable the audit integration work done on Android and its dependencies. These patches also fix some bugs in the code and, very importantly, enable the SELinux/LSM binder hooks and policy controls.</p><p>The audit system in Linux is used by LSMs to print the denial records as well as to gather very thorough and complete records of events. No matter what, when an LSM prints a message, it gets propagated to the audit subsystem and printed. However, if the audit subsystem has been enabled, then you get more context associated with the denial. The audit subsystem even supports loading rules for watching this. For instance, you could watch all writes to <code class="literal">/system</code> that were not done by the system UID.</p><div class="section" title="The auditd daemon"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec28"/>The auditd daemon</h2></div></div></div><p>The <code class="literal">auditd</code> <a id="id196" class="indexterm"/>daemon, or service, runs in userspace and listens<a id="id197" class="indexterm"/> over a NETLINK socket to the audit subsystem. The daemon registers itself to receive the kernel messages, and can also load the audit rules over this socket. Once registered, the <code class="literal">auditd</code> daemon receives all the audit events. The <code class="literal">auditd</code> daemon was minimally ported, and there was an attempt to mainline it into Android that was later rejected. However, <code class="literal">auditd</code> has been used by various OEMs (such as Samsung) and by the NSA's 4.3 branch. An alternative approach that put records in logcat was later merged into Android (for more information, refer to <a class="ulink" href="https://android-review.googlesource.com/89645">https://android-review.googlesource.com/89645</a>).</p><p>Earlier, we saw the AVC denial messages from SELinux in <code class="literal">dmesg</code>. The problem with this is that the circular memory log is prone to rollover when you have many denials or a chatty kernel. With <code class="literal">auditd</code>, all the messages come to the daemon and are written to the <code class="literal">/data/misc/audit/audit.log</code> file. This log file, herein referred to as <code class="literal">audit.log</code>, may exist on device boot and is rotated into the <code class="literal">/data/misc/audit/audit.old</code> file, known as <code class="literal">audit.old</code>. The daemon resumes logging to a new <code class="literal">audit.log</code> file. This rotate event occurs when the size threshold <code class="literal">AUDITD_MAX_LOG_FILE_SIZEKB</code> (set during compile time in the <code class="literal">system/core/auditd/Android.mk</code> file) is exceeded. This threshold is typically 1000 KB but can be changed in the device's <code class="literal">makefile</code>. Also, sending <code class="literal">SIGHUP</code> with <code class="literal">kill</code> will cause a rotate as in the following example.</p><p>Verify <a id="id198" class="indexterm"/>the <a id="id199" class="indexterm"/> daemon is running and get its PID:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # ps -Z | grep audit</strong></span>
<span class="strong"><strong>u:r:auditd:s0 audit 2281 1 /system/bin/auditd</strong></span>
<span class="strong"><strong>u:r:kernel:s0 root 2293 2 kauditd</strong></span>
</pre></div><p>Verify only one log exists:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # ls -la /data/misc/audit/</strong></span>
<span class="strong"><strong>-rw-r----- audit system 79173 1970-01-02 00:19 audit.log</strong></span>
</pre></div><p>Rotate the logs:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # kill -SIGHUP 2281</strong></span>
</pre></div><p>Verify <code class="literal">audit.old</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>root@udoo:/ # ls -la /data/misc/audit/</strong></span>
<span class="strong"><strong>-rw-r----- audit system 319 1970-01-02 00:20 audit.log</strong></span>
<span class="strong"><strong>-rw-r----- audit system 79173 1970-01-02 00:19 audit.old</strong></span>
</pre></div></div><div class="section" title="Auditd internals"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec29"/>Auditd internals</h2></div></div></div><p>Since<a id="id200" class="indexterm"/> the <code class="literal">auditd</code> and <code class="literal">libaudit</code> code from the <a id="id201" class="indexterm"/>Linux desktop have a GPL license, a rewrite was done for Android, released under the Apache license. The rewrite is minimal, thus you will only find the functions implemented that were required to support the daemon. The functional and header interfaces should remain identical though.</p><p>The <code class="literal">auditd</code> daemon starts life at <code class="literal">main()</code> in <code class="literal">system/core/auditd.c</code>. It quickly changes its permissions from UID root to a special <code class="literal">auditd</code> UID. When it does this, it retains <code class="literal">CAPSYS_AUDIT</code>, which is a required DAC capability check to use the <code class="literal">AUDIT</code> NETLINK socket. It does this via a call to <code class="literal">drop_privileges_or_die()</code>. From there, it does some option parsing with <code class="literal">getopt()</code>, and we finally get to the audit-specific calls, the first of which opens the NETLINK socket using <code class="literal">audit_open()</code>. This function simply calls <code class="literal">socket(PF_NETLINK, SOCK_RAW, NETLINK_AUDIT)</code>, which opens a file descriptor to the NETLINK socket. After opening the socket, the daemon opens a handle to <code class="literal">audit.log</code> with a call to <code class="literal">audit_log_open(const char *logfile, const char *rotatefile, size_t threshold)</code>. This function checks whether the <code class="literal">audit.log</code> file exists and, if it does, renames it to <code class="literal">audit.old</code>. It then creates a new empty log file in which the data is recorded.</p><p>The next step is to register the daemon with the audit subsystem so that it knows to whom to send messages. By setting the PID of the daemon, you ensure that only this daemon will get the messages. Since NETLINK can support many readers, you don't want a "rogue <code class="literal">auditd</code>" to read the messages. With that stated, the daemon calls <code class="literal">audit_set_pid(audit_fd, getpid(), WAIT_YES)</code>, where <code class="literal">audit_fd</code> is the NETLINK socket from <code class="literal">audit_open()</code>, <code class="literal">getpid()</code> returns the daemon's PID, and <code class="literal">WAIT_YES</code> causes the daemon to block until the operation is complete. Next, the daemon enables the audit subsystem's advanced features with a call to <code class="literal">audit_set_enabled(audit_fd, 1)</code> and adds rules to the audit subsystem via <code class="literal">audit_rules_read_and_add(audit_fd, AUDITD_RULES_FILE)</code>. This function reads the rules<a id="id202" class="indexterm"/> from that file, formats some structures, and sends<a id="id203" class="indexterm"/> those structures to the kernel.</p><p>The <code class="literal">audit_set_enabled()</code> and <code class="literal">audit_rules_read_and_add()</code>only have an effect if the kernel is built with <code class="literal">CONFIG_AUDITSYSCALL</code>. After this, the daemon checks whether the <code class="literal">-k</code> option was specified. The <code class="literal">-k</code> option tells <code class="literal">auditd</code> to look in <code class="literal">dmesg</code> for any missed audit records. It does this because there is a race between capturing audit records before the circular buffer overflows and userspace starting many services, generating audit events and policy violations. Essentially, this helps coalesce the audit events from early boot into the same log files.</p><p>After this, the daemon enters a loop to read from the NETLINK socket, formatting the messages, and writing them to the log file. It starts this loop by waiting for IO on the NETLINK socket using <code class="literal">poll()</code>. If <code class="literal">poll()</code> exits with an error, the loop continues to check the <code class="literal">quit</code> variable. If <code class="literal">EINTR</code> is raised, the loop guard, <code class="literal">quit</code>, is set to <code class="literal">true</code> in the signal handler, and the daemon exits. If <code class="literal">poll()</code> is data on the NETLINK, the daemon calls <code class="literal">audit_get_reply(audit_fd, &amp;rep, GET_REPLY_BLOCKING, 0)</code>, getting an <code class="literal">audit_reply</code> structure back with the <code class="literal">rep</code> parameter. It then writes the <code class="literal">audit_reply</code> structure (with formatting) to the <code class="literal">audit.log</code> file with <code class="literal">audit_log_write(alog, "type=%d msg=%.*s\n", rep.type, rep.len, rep.msg.data)</code>. It does this until <code class="literal">EINTR</code> is raised, at which point, the daemon exits.</p><p>When the daemon exits, it clears the PID registered with the kernel (<code class="literal">audit_set_pid(audit_fd, 0)</code>), closes the audit socket via <code class="literal">audit_close()</code> (which is really just the syscall, <code class="literal">close(audit_fd)</code>), and closes the <code class="literal">audit.log</code> with <code class="literal">audit_log_close()</code>. The <code class="literal">audit_log_*</code> family of functions is not part of the GPLed interface to audit and is a custom write.</p><p>When Google ported <code class="literal">auditd</code> to the <code class="literal">logd</code> infrastructure in Android, it used the same functions and library code used by the daemon's <code class="literal">main()</code> and wrapped it into <code class="literal">logd</code>. However, Google <span class="emphasis"><em>did not</em></span> take the <code class="literal">audit_set_enabled()</code> and <code class="literal">audit_rules_read_and_add()</code> functions.</p></div></div>
<div class="section" title="Interpreting SELinux denial logs"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec42"/>Interpreting SELinux denial logs</h1></div></div></div><p>The <a id="id204" class="indexterm"/>SELinux denials get routed to the kernel audit subsystem, to <code class="literal">auditd</code>, and finally, to <code class="literal">audit.log</code> and <code class="literal">audit.old</code>. With the logs resident in <code class="literal">audit.log</code>, let's pull this file over <code class="literal">adb</code> and have a closer look at it.</p><p>Run the following command from the host, with <code class="literal">adb</code> enabled:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb pull /data/misc/audit/audit.log</strong></span>
</pre></div><p>Now, let's tail that file and look for these lines:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ tail audit.log</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>type=1400 msg=audit(88526.980:312): avc: denied { getattr } for pid=3083 comm="adbd" path="/data/misc/audit/audit.log" dev=mmcblk0p4 ino=42 scontext=u:r:adbd:s0 tcontext=u:object_r:audit_log:s0 tclass=file</strong></span>
<span class="strong"><strong>type=1400 msg=audit(88527.030:313): avc: denied { read } for pid=3083 comm="adbd" name="audit.log" dev=mmcblk0p4 ino=42 scontext=u:r:adbd:s0 tcontext=u:object_r:audit_log:s0 tclass=file</strong></span>
<span class="strong"><strong>type=1400 msg=audit(88527.030:314): avc: denied { open } for pid=3083 comm="adbd" name="audit.log" dev=mmcblk0p4 ino=42 scontext=u:r:adbd:s0 tcontext=u:object_r:audit_log:s0 tclass=file</strong></span>
</pre></div><p>The <a id="id205" class="indexterm"/>records here consist of two major portions: <code class="literal">type</code> and <code class="literal">msg</code>. The <code class="literal">type</code> field indicates what type of message it is. Messages with type 1400 are AVC messages, which are SELinux denial messages (there are other types, as well). The <code class="literal">msg</code> (short for message) portion of the preceding policy contains the part for us to analyze.</p><p>The last command we executed was <code class="literal">adb pull /data/misc/audit/aduit.log</code> and, as you can see, we have a few <code class="literal">adb</code> policy violations at the tail of the <code class="literal">audit.log</code> file. Let's start by looking at this event:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>type=1400 msg=audit(88526.980:312): avc: denied { getattr } for pid=3083 comm="adbd" path="/data/misc/audit/audit.log" dev=mmcblk0p4 ino=42 scontext=u:r:adbd:s0 tcontext=u:object_r:audit_log:s0 tclass=file</strong></span>
</pre></div><p>We can see that the <code class="literal">comm</code> field is <code class="literal">adbd</code>. However, it's not wise to trust this value since it can be controlled from userspace using the <code class="literal">prctl()</code> interface. It can only be viewed as a hint. The best way to verify this is to check the PID using <code class="literal">ps -Z</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong># ps -Z | grep adbd</strong></span>
<span class="strong"><strong>u:r:adbd:s0 root 3083 1 /sbin/adbd</strong></span>
</pre></div><p>With the daemon verified, we can now check the message in more detail. The message consists of the following fields (optional fields are identified by <code class="literal">*</code>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">avc: denied</code>: This part will always happen and denotes it is a denial record.</li><li class="listitem" style="list-style-type: disc"><code class="literal">{ permission }</code>: This is the permission that was denied, in this case, <code class="literal">getattr</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">for</code>: This will always be printed and makes the output readable.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Path*</code>: This is the optional field that contains the path of the object in question. It only makes sense for filesystem access denials.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dev*</code>: This is the optional field that identifies the block device for the mounted filesystem. It only makes sense for filesystem access denials.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ino*</code>: This is the optional inode of the file. Only the anonymous files in Linux print inode. It only makes sense for filesystem access denials.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tclass</code>: This is the target class of the object, which in our case was <code class="literal">file</code>.</li></ul></div><p>At this<a id="id206" class="indexterm"/> point, we need to understand what the <code class="literal">msg</code> portion of the denial record is telling us at a very distilled level. It is saying that the Android debug bridge daemon wants to be able to call <code class="literal">getattr</code> on our policy file. A few events down, we will see it also wants <code class="literal">read</code> and <code class="literal">open</code>. This is the side effect of running <code class="literal">adb pull</code>. A <code class="literal">getattr</code> permission denial occurs from a <code class="literal">stat()</code> syscall, and the <code class="literal">read/open</code> are from <code class="literal">read()</code> and <code class="literal">open()</code> syscalls. If you want to allow this in your policy, which would be a security decision based on your threat model, you should add:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>allow adbd audit_log:file { getattr read open };</strong></span>
</pre></div><p>Alternatively, use the macro sets defined in <code class="literal">global_macros</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>allow adbd audit_log:file r_file_perms;</strong></span>
</pre></div><p>Most of the time, you should use the macros defined in <code class="literal">global_macros</code> for file permission accesses. Typically, adding them one by one is very time consuming and tedious. The macros group the permissions in a context analogous to read, write, and execute DAC permissions. For instance, if you give it <code class="literal">open</code> and <code class="literal">read</code>, there's a good chance at some point that the source domain will need to stat the file. So, the <code class="literal">r_file_perms</code> macro has those permissions in it already.</p><p>You should add this rule to <code class="literal">external/sepolicy/adbd.te</code>. The <code class="literal">.te</code> files (also called <code class="literal">type enforcement</code> files) are organized by source context, so make sure you add it to the correct file. We do not recommend adding this allow rule—there's no legitimate reason that <code class="literal">adbd</code> needs access to the audit logs—we can safely ignore these with a <code class="literal">dontaudit</code> rule:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>dontaudit adbd audit_log:file r_file_perms;</strong></span>
</pre></div><p>The <code class="literal">dontaudit</code> rule is a policy statement that says don't audit (print) denials that match this rule.</p><p>If you're not sure what to do, the best advice is to leverage the mailing lists for SE for Android, SELinux, and audit. Just keep the messages appropriate to the specific mailing lists topic.</p><p>A tool exists called <code class="literal">audit2allow</code>, which can help you write policy allow rules. However, it's only a tool and can be misused. It translates the policy file to the allow rules for the policy:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat audit.log | audit2allow </strong></span>
<span class="strong"><strong>#============= adbd ==============</strong></span>
<span class="strong"><strong>allow adbd audit_log:file { read getattr open };</strong></span>
</pre></div><p>The <code class="literal">audit2allow</code> tool is not macro aware or aware if you really want to add this allow rule to the policy file. Only the policy author can make this decision.</p><p>There is <a id="id207" class="indexterm"/>also a tool to enable the <code class="literal">r_file_*</code> macro mapping <a id="id208" class="indexterm"/>called <code class="literal">fixup.py</code>. You can get the tool at <a class="ulink" href="https://bitbucket.org/billcroberts/fixup/overview">https://bitbucket.org/billcroberts/fixup/overview</a>. After downloading, make it executable, and place it somewhere in your executable path:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ chmod a+x fixup.py</strong></span>
<span class="strong"><strong>$ cat audit.log | audit2allow | fixup.py </strong></span>
<span class="strong"><strong>#============= adbd ==============</strong></span>
<span class="strong"><strong>allow adbd audit_log:file r_file_perms;</strong></span>
</pre></div></div>
<div class="section" title="Contexts"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Contexts</h1></div></div></div><p>In the<a id="id209" class="indexterm"/> simplest sense, writing policies is just the activity of identifying policy violations and adding the appropriate allow rules to the policy file. However, in order for SELinux to be effective, the source and target contexts must be correct. If they are not, the allow rules are meaningless.</p><p>The first things you might encounter are denials where the target type is unlabeled. In this case, the proper target label needs to be set (refer to <a class="link" href="ch11.html" title="Chapter 11. Labeling Properties">Chapter 11</a>, <span class="emphasis"><em>Labeling Properties</em></span>). Also, process labels can be wrong. Multiple processes can belong to a domain, and unless explicitly done via policy, the child process of a parent inherits the parent's domain. However, in Android, domains that have multiple processes are quite limited. You will never see multiple processes in <code class="literal">init</code>, <code class="literal">system_server</code>, <code class="literal">adbd</code>, <code class="literal">auditd</code>, <code class="literal">debuggerd</code>, <code class="literal">dhcp</code>, <code class="literal">servicemanager</code>, <code class="literal">vold</code>, <code class="literal">netd</code>, <code class="literal">surfaceflinger</code>, <code class="literal">drmserver</code>, <code class="literal">mediaserver</code>, <code class="literal">installd</code>, <code class="literal">keystore</code>, <code class="literal">sdcardd</code>, <code class="literal">wpa</code>, and <code class="literal">zygote</code> domains.</p><p>It's okay to see multiple processes in the following domains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">system_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">untrusted_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">platform_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">shared_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">media_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">release_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isolated_app</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">shell</code></li></ul></div><p>On a released device, nothing should be run in the <code class="literal">su</code>, <code class="literal">recovery</code>, and <code class="literal">init_shell</code> domains. The<a id="id210" class="indexterm"/> following table provides a complete mapping of domains to the expected executables <a id="id211" class="indexterm"/>and cardinality:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Domain</p>
</th><th style="text-align: left" valign="bottom">
<p>Executable(s)</p>
</th><th style="text-align: left" valign="bottom">
<p>Cardinality (N)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:init:s0"</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/init</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:ueventd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/sbin/ueventd</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:healthd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/sbin/healthd</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:servicemanager:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/servicemanager</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:vold:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/vold</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:netd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/netd</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:debuggerd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/debuggerd, /system/bin/debuggerd64</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:surfaceflinger:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/surfaceflinger</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:zygote:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">zygote, zygote64</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:drmserver:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/drmserver</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:mediaserver:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/mediaserver</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N &gt;= 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:installd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/installd</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:keystore:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/keystore</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:system_server:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">system_server</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N ==1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:sdcardd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/sdcard</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N &gt;=1</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:watchdogd:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/sbin/watchdogd</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N &gt;=0 &amp;&amp; N &lt; 2</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:wpa:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/system/bin/wpa_supplicant</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N &gt;=0 &amp;&amp; N &lt; 2</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:init_shell:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 0</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:recovery:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 0</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">u:r:su:s0</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">null</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">N == 0</code>
</p>
</td></tr></tbody></table></div><p>Several<a id="id212" class="indexterm"/> <span class="strong"><strong>Compatibility Test Suite</strong></span> (<span class="strong"><strong>CTS</strong></span>) tests have been<a id="id213" class="indexterm"/> written around this and submitted to AOSP at <a class="ulink" href="https://android-review.googlesource.com/#/c/82861/">https://android-review.googlesource.com/#/c/82861/</a>.</p><p>Based on these generic assertions of what a good policy should look like, let's evaluate ours.</p><p>First, we will check for unlabeled objects. From the host, with the <code class="literal">audit.log</code> file you obtained with <code class="literal">adb pull</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cat audit.log | grep unlabeled</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>type=1400 msg=audit(86527.670:341): avc: denied { rename } for pid=3206 comm="pool-1-thread-1" name="com.android.settings_preferences.xml" dev=mmcblk0p4 ino=129664 scontext=u:r:system_app:s0 tcontext=u:object_r:unlabeled:s0 tclass=file</strong></span>
<span class="strong"><strong>...</strong></span>
</pre></div><p>It looks like we have some files and other things that are not labeled properly; we will address these in the <a class="link" href="ch11.html" title="Chapter 11. Labeling Properties">Chapter 11</a>, <span class="emphasis"><em>Labeling Properties</em></span>. Now, let's check for domains that have multiple processes when they should not, and find improper binaries in those domains (refer to the previous table for the complete mapping.)</p><p>Init:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell ps -Z | grep u:r:init:s0</strong></span>
<span class="strong"><strong>u:r:init:s0 root 1 0 /init</strong></span>
<span class="strong"><strong>u:r:init:s0 root 2267 1 /sbin/watchdogd</strong></span>
</pre></div><p>Zygote:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ adb shell ps -Z | grep u:r:zygote:s0</strong></span>
<span class="strong"><strong>u:r:zygote:s0 root 2285 1 zygote</strong></span>
<span class="strong"><strong>$ adb shell ps -Z | grep u:r:init_shell</strong></span>
<span class="strong"><strong>u:r:init_shell:s0 root 2278 1 /system/bin/sh</strong></span>
<span class="strong"><strong>… through all domains</strong></span>
</pre></div><p>After doing this, we found issues because something is running in the <code class="literal">init_shell</code> domain, and <code class="literal">watchdogd</code> is in the <code class="literal">init</code> domain. These must be corrected.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Summary</h1></div></div></div><p>Writing <code class="literal">sepolicy</code> is relatively easy, writing good policy is an art. It requires the policy author to understand the system and the implications of the <code class="literal">allow</code> rule. Policy itself is a meta-programming language where the language controls how userspace and the kernel get along, and much like any program, the policy can be architected for a specific use. Policies can be too porous (essentially useless) or very tight and difficult to change without breaking the portions that already work.</p><p>A good policy needs to preserve the intended proper function of the system, so thorough testing of all the systems within Android is essential. CTS is a great help in exercising Android, but it often does not cover all the cases; user testing is recommended. In the next chapter, we will cover how filesystems and filesystem objects get their security labels and how we can change them. Later, we will go over how to use CTS as a tool to test the system and generate policy violations for intended behaviors.</p></div></body></html>