<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-248"><a id="_idTextAnchor441"/>9</h1>
<h1 id="_idParaDest-249"><a id="_idTextAnchor442"/>Building for Large Screens</h1>
<p>We can all agree now that we live in a world with foldable phones, a technology we never anticipated, due to their growing demand and popularity. Ten years ago, if you had told a developer we would have foldable phones, no one would have believed it due to the ambiguity of screen complexity and the transfer of information.</p>
<p>However, now the devices are here with us. And since some of these devices run on the Android operating system, it’s vital to know how we developers will build our applications to cater to foldability, along with the number of Android tablets we’re now seeing on the market. The support for large screens seems now mandatory, and in this chapter, we will look at supporting large screens in the new Modern Android Development.</p>
<p>In this chapter, we’ll be covering the following recipes:</p>
<ul>
<li>Building adaptive layouts in Modern Android Development</li>
<li>Building adaptive layouts using <code>ConstraintLayouts</code></li>
<li>Handling large-screen configuration changes and continuity</li>
<li>Understanding activity embedding</li>
<li>Material Theming in Compose</li>
<li>Testing your applications on a foldable device</li>
</ul>
<h1 id="_idParaDest-250"><a id="_idTextAnchor443"/>Technical requirements</h1>
<p>The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine">https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_nine</a>.</p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor444"/>Building adaptive layouts in Modern Android Development</h1>
<p>When building the UI for your application in Modern Android Development, it is fair to say that you <a id="_idIndexMarker572"/>should consider <a id="_idIndexMarker573"/>ensuring the application is responsive to different screen sizes, orientations, and form factors. Finally, developers can now remove the lock in portrait mode. In this recipe, we will utilize ideas we learned from previous recipes and build an adaptive app for different screen sizes and orientations.</p>
<h2 id="_idParaDest-252"><a id="_idTextAnchor445"/>Getting ready</h2>
<p>We will be using the cities application to create a traveler profile, and our screen should be able to change based on different screen sizes and support foldable devices and tablets. To get the entire code, check out the <em class="italic">Technical </em><em class="italic">requirements</em> section.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor446"/>How to do it…</h2>
<p>For this recipe, we will create a new project, and this time, instead of picking the empty Compose Activity template, we will pick empty Compose Activity (<code>Material 3</code>). <code>Material 3</code> seeks to improve our application’s look and feel in Android. It includes updated theming, components, and great features, such as Material You personalization using dynamic color:</p>
<ol>
<li>Let’s start by creating an Empty Compose Activity (<code>Material3</code>) project and calling it <code>Traveller</code>; note that you can call your project anything you wish.</li>
</ol>
<div><div><img alt="Figure 9.1 – Creating a new Empty Compose Activity (Material3) project" src="img/Figure_9.1_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Creating a new Empty Compose Activity (Material3) project</p>
<p>Complex applications utilize responsive UI, and in most cases, ensuring you choose the right navigation type for your application comes in handy. The Material library offers navigation components to developers, such as the bottom navigation, navigation drawer, and navigation rail. You can get the starter code for these in the <em class="italic">Technical </em><em class="italic">requirements</em> section.</p>
<ol>
<li value="2">Add the following dependency, and check the project for the correct version number, <code>1.1.0</code>:<pre class="source-code">
implementation "androidx.compose.material3:material3-window-size-class:1.1.0"</pre></li>
<li>When <a id="_idIndexMarker574"/>ensuring our code <a id="_idIndexMarker575"/>caters to adaptability, we have to remember a responsive UI retains data when a phone is rotated, folded, or unfolded. The most crucial part is ensuring we handle the posture. We will create a function, <code>cityPosture</code>, that takes <code>FoldingFeature</code> as input and returns a Boolean:<pre class="source-code">
@OptIn(ExperimentalContracts::class)</pre><pre class="source-code">
fun cityPosture(foldFeature: FoldingFeature?): Boolean {</pre><pre class="source-code">
    contract { returns(true) implies (foldFeature !=</pre><pre class="source-code">
        null) }</pre><pre class="source-code">
    return foldFeature?.state ==</pre><pre class="source-code">
        FoldingFeature.State.HALF_OPENED &amp;&amp;</pre><pre class="source-code">
            foldFeature.orientation ==</pre><pre class="source-code">
                FoldingFeature.Orientation.VERTICAL</pre><pre class="source-code">
}</pre></li>
</ol>
<p>We handle the state based on the three provided states. We also annotate it with the <a id="_idIndexMarker576"/>experimental <a id="_idIndexMarker577"/>class because this API is still experimental, which means it can change in the future and is not very stable.</p>
<ol>
<li value="4">Next, we need to cover <code>isSeparating</code>, which listens to the <code>FLAT</code> <em class="italic">fully open</em> and the <code>isSeparating</code> Boolean, which calculates whether <code>FoldingFeature</code> should be considered, splitting the window into multiple physical areas that users can see as logically separate:<pre class="source-code">
@OptIn(ExperimentalContracts::class)</pre><pre class="source-code">
fun separating(foldFeature: FoldingFeature?): Boolean {</pre><pre class="source-code">
    contract { returns(true) implies (foldFeature !=</pre><pre class="source-code">
        null) }</pre><pre class="source-code">
    return foldFeature?.state ==</pre><pre class="source-code">
        FoldingFeature.State.FLAT &amp;&amp;</pre><pre class="source-code">
            foldFeature.isSeparating</pre><pre class="source-code">
}</pre></li>
<li>We will also create a sealed interface, <code>DevicePosture</code>. This is a Jetpack Compose UI <a id="_idIndexMarker578"/>component <a id="_idIndexMarker579"/>that allows you to detect a device’s posture or orientation, such as whether the device is in portrait or landscape mode:<pre class="source-code">
sealed interface DevicePosture {</pre><pre class="source-code">
    object NormalPosture : DevicePosture</pre><pre class="source-code">
    data class CityPosture(</pre><pre class="source-code">
        val hingePosition: Rect</pre><pre class="source-code">
    ) : DevicePosture</pre><pre class="source-code">
    data class Separating(</pre><pre class="source-code">
        val hingePosition: Rect,</pre><pre class="source-code">
        var orientation: FoldingFeature.Orientation</pre><pre class="source-code">
    ) : DevicePosture</pre><pre class="source-code">
}</pre></li>
<li>In our <code>MainActivity</code>, we now need to ensure we calculate the window size:<pre class="source-code">
val windowSize = calculateWindowSizeClass(activity = this)</pre></li>
<li>Then, we will ensure we handle all sizes well by creating <code>postureStateFlow</code>, which will listen to our <code>DevicePosture</code> and act when <code>cityPosture</code> is either folded, unfolded, or normal:<pre class="source-code">
val postureStateFlow = WindowInfoTracker.getOrCreate(this).windowLayoutInfo(this)</pre><pre class="source-code">
. . .</pre><pre class="source-code">
when {</pre><pre class="source-code">
    cityPosture(foldingFeature) -&gt;</pre><pre class="source-code">
      DevicePosture.CityPosture(foldingFeature.bounds)</pre><pre class="source-code">
    separating(foldingFeature) -&gt;</pre><pre class="source-code">
      DevicePosture.Separating(foldingFeature.bounds,</pre><pre class="source-code">
        foldingFeature.orientation)</pre><pre class="source-code">
    else -&gt; DevicePosture.NormalPosture</pre><pre class="source-code">
}</pre><pre class="source-code">
    }</pre><pre class="source-code">
. . .</pre><pre class="source-code">
    )</pre></li>
<li>We now <a id="_idIndexMarker580"/>need to get set up <a id="_idIndexMarker581"/>with a foldable testing virtual device. You can repeat the steps from the first chapter on how to create a virtual device if you need a refresher; otherwise, you should go ahead and create a foldable device. The arrow in <em class="italic">Figure 9</em><em class="italic">.2</em> shows how you will control the foldable screens.</li>
</ol>
<div><div><img alt="Figure 9.2 – The foldable controls" src="img/Figure_9.2_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The foldable controls</p>
<ol>
<li value="9">Then, finally, <a id="_idIndexMarker582"/>when you <a id="_idIndexMarker583"/>run the app, you will see that it changes based on folded and unfolded states, working well. <em class="italic">Figure 9</em><em class="italic">.3</em> shows when the state is folded.</li>
</ol>
<div><div><img alt="Figure 9.3 – The folded state" src="img/Figure_9.3_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The folded state</p>
<ol>
<li value="10">In <em class="italic">Figure 9</em><em class="italic">.4</em>, you can see that we changed the bottom navigation and now have our <a id="_idIndexMarker584"/>navigation <a id="_idIndexMarker585"/>drawer set to the side for more straightforward navigation. It should be acknowledged that this project is extensive, so we cannot cover all parts of the code. Make sure to utilize the Compose concepts learned in the previous chapter for this section.</li>
</ol>
<div><div><img alt="Figure 9.4 – The full-screen state (not folded)" src="img/Figure_9.4_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The full-screen state (not folded)</p>
<p>Note that when <a id="_idIndexMarker586"/>you expand <a id="_idIndexMarker587"/>the navigation drawer, you can see all items, and you should be able to navigate easily.</p>
<div><div><img alt="Figure 9.5 – The navigation drawer open" src="img/Figure_9.5_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The navigation drawer open</p>
<p>You can also <a id="_idIndexMarker588"/>see on the <a id="_idIndexMarker589"/>side panel a more descriptive view of your UI, which helps debug issues.</p>
<div><div><img alt="Figure 9.6 – The device pose" src="img/Figure_9.6_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – The device pose</p>
<p class="callout-heading">Important note</p>
<p class="callout">The code base for this project is vast and hence, cannot be covered in just one recipe; you can find the full code in the <em class="italic">Technical </em><em class="italic">requiremen<a id="_idTextAnchor447"/>ts</em> section.</p>
<h2 id="_idParaDest-254">Ho<a id="_idTextAnchor448"/>w it works…</h2>
<p>We covered the bottom navigation in <a href="B18827_04.xhtml#_idTextAnchor190"><em class="italic">Chapter 4</em></a>, <em class="italic">Navigation in Modern Android Development</em>. In this <a id="_idIndexMarker590"/>chapter, however, we <a id="_idIndexMarker591"/>use it to showcase how your application can change as the screen changes if your application is installed on a foldable device, which is very important in Modern Android<a id="_idTextAnchor449"/> Development.</p>
<p>The navigation rail is used for medium-screen sizes, whereas the navigation drawer, just like in the old way of writing applications, is used as a side drawer and is suitable for large-screen devices. <code>FoldFeature</code> is a built-in Jetpack Compose UI component that allows you to <a id="_idIndexMarker592"/>create a folding animation effect when you click on it.</p>
<p>Here are the steps to use <code>FoldFeature</code> in your Android app. You can also customize <code>FoldFeature</code> by providing the necessary parameters:</p>
<ul>
<li><code>foldableState</code>: This state controls the folding and unfolding of <code>FoldFeature</code>. You can create a <code>FoldState</code> instance using the <code>rememberFoldState()</code> function.</li>
<li><code>foldedConten</code>t: Content will be displayed when <code>FoldFeature</code> is folded.</li>
<li><code>expandedContent</code>: This is the content that will be displayed when <code>FoldFeature</code> is in its e<a id="_idTextAnchor450"/>xpanded state.</li>
<li><code>foldingIcon</code>: This is the icon that will be displayed to indicate the folding state o<a id="_idTextAnchor451"/>f <code>FoldFeature</code>.</li>
</ul>
<p>A foldable device has the ability to be in various states and postures. The Jetpack <code>WindowManager</code> library’s <code>WindowLayoutInfo</code> class, which is what we use in our example, provides us <a id="_idIndexMarker593"/>with the <a id="_idIndexMarker594"/>following details. <code>state</code> helps describe the folded state the device is in. When the phone is fully opened, then the state is either <code>FLAT</code> or <code>HALF_OPENED</code>. We also get to play around with <code>orientation</code>, which is the orientatio<a id="_idTextAnchor452"/>n of the hinge.</p>
<p>The hinge can be either <code>HORIZONTAL</code> or <code>VERTICAL</code>. We have <code>occlusionType</code>, and this is the value that is <code>FULL</code> when the hinge hides part of the display. Otherwise, the value is <code>NONE</code>. Finally, we have <code>isSeparating</code>, which becomes valid when the hinge creates two logical displays.</p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor453"/>Building adaptive layouts using ConstraintLayouts</h1>
<p>Jetpack Compose, a declarative <a id="_idIndexMarker595"/>UI toolkit to <a id="_idIndexMarker596"/>build great UIs, is ideal to implement and design screen layouts that adjust automatically by themselves and render content well across different screen sizes.</p>
<p>This can be useful to consider when building your application, since the chance of it being installed in a foldable device is high. Furthermore, this can range from simple layout adjustments to filling up a foldable space that looks like a tablet.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor454"/>Getting ready</h2>
<p>You need to have read the previous chapters to follow along with this recipe.</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor455"/>How to do it…</h2>
<p>For this recipe, we will <a id="_idIndexMarker597"/>build a separate composable function to show you how to use <code>ConstraintLayout</code> in the same <a id="_idIndexMarker598"/>project instead of creating a new one:</p>
<ol>
<li>Let’s go ahead and open <code>Traveller</code>. Add a new package and call it <code>constraintllayoutexample</code>. Inside the package, create a Kotlin file, called <code>ConstraintLayoutExample</code>, and then add the following dependency to the project:<pre class="source-code">
implementation "Androidx.constraintlayout:constraintlayout-compose:1.x.x"</pre></li>
<li>In our example, we will create a fun <code>AndroidCommunity()</code> and use <code>ConstraintLayout</code> to create <code>title</code>, <code>aboutCommunity</code>, and <code>AndroidImage</code> references:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun AndroidCommunity() {</pre><pre class="source-code">
    ConstraintLayout {</pre><pre class="source-code">
        val (title, aboutCommunity, AndroidImage) =</pre><pre class="source-code">
            createRefs()</pre><pre class="source-code">
 . . .</pre><pre class="source-code">
}</pre></li>
<li><code>createRefs()</code>, which means <em class="italic">create references</em>, simply creates a reference for each composable in our <code>ConstrainLayout</code>.</li>
<li>Now, let us go ahead and create our title text, <code>aboutCommunity</code>, and <code>AndroidImage</code>:<pre class="source-code">
Text(</pre><pre class="source-code">
    text = stringResource(id =</pre><pre class="source-code">
        R.string.Android_community),</pre><pre class="source-code">
    modifier = Modifier.constrainAs(title) {</pre><pre class="source-code">
        top.linkTo(parent.top)</pre><pre class="source-code">
        start.linkTo(parent.start)</pre><pre class="source-code">
        end.linkTo(parent.end)</pre><pre class="source-code">
    }</pre><pre class="source-code">
        .padding(top = 12.dp),</pre><pre class="source-code">
    style = TextStyle(</pre><pre class="source-code">
        color = Color.Blue,</pre><pre class="source-code">
        fontSize = 24.sp</pre><pre class="source-code">
    )</pre><pre class="source-code">
)</pre></li>
<li>Our title text has a modifier that has constraints defined, and if you have used XML before, you <a id="_idIndexMarker599"/>may notice that this works exactly how XML works. We provide constraints <a id="_idIndexMarker600"/>using the <code>constrainAs()</code> modifier, which, in our case, takes the references as a parameter and lets us specify its constraints in the body lambda. Hereafter, our constraints are specified using <code>linkTo(...)</code> or other methods, but in this case, we will use <code>linkTo(parent.top)</code>.</li>
</ol>
<p>We can now connect the parts together using a similar style, in addition, ensure you <a id="_idIndexMarker601"/>check the <em class="italic">Technical requirements</em> section <a id="_idIndexMarker602"/>for the entire code:</p>
<pre class="source-code">
Text(
    text = stringResource(id =
       R.string.about_community),
    modifier = Modifier.constrainAs(aboutCommunity) {
        top.linkTo(title.bottom)
        start.linkTo(parent.start)
        end.linkTo(parent.end)
        width = Dimension.fillToConstraints
    }
        .padding(top = 12.dp, start = 12.dp,
            end = 12.dp),
    style = TextStyle(
        fontSize = 18.sp
    )
)</pre>
<ol>
<li value="6">Then, we build the image:<pre class="source-code">
Image(</pre><pre class="source-code">
    painter = painterResource(id =</pre><pre class="source-code">
        R.drawable.Android),</pre><pre class="source-code">
    contentDescription = stringResource(id =</pre><pre class="source-code">
        R.string.Android_image),</pre><pre class="source-code">
    modifier = Modifier.constrainAs(AndroidImage) {</pre><pre class="source-code">
        top.linkTo(aboutCommunity.bottom,</pre><pre class="source-code">
            margin = 16.dp)</pre><pre class="source-code">
        centerHorizontallyTo(parent)</pre><pre class="source-code">
    }</pre><pre class="source-code">
)</pre><pre class="source-code">
. . .</pre></li>
<li>Finally, to run this part of the code, you can run the <code>@</code><code>Preview</code> section:<pre class="source-code">
@Preview(showBackground = true)</pre><pre class="source-code">
@Composable</pre><pre class="source-code">
fun ShowAndroidCommunity() {</pre><pre class="source-code">
    TravellerTheme() {</pre><pre class="source-code">
        AndroidCommunity()</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>When you <a id="_idIndexMarker603"/>run the application, it <a id="_idIndexMarker604"/>should render and adapt well to the screen sizes. For instance, if the state is full (which means not folded), data should be displayed on the entire screen (see <em class="italic">Figure 9</em><em class="italic">.7</em>).</li>
</ol>
<div><div><img alt="Figure 9.7 – The full screen of the not folded state" src="img/Figure_9.7_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – The full screen of the not folded state</p>
<ol>
<li value="9">In <em class="italic">Figure 9</em><em class="italic">.8</em>, you <a id="_idIndexMarker605"/>can see a version <a id="_idIndexMarker606"/>of the data when the screen is folded and how it adapts to the specified dimensions.</li>
</ol>
<div><div><img alt="Figure 9.8 – The folded state" src="img/Figure_9.8_B18827.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The folded state</p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor456"/>How it works…</h2>
<p>We use modifiers to adjust the spacing between components and use dimension resources to <a id="_idIndexMarker607"/>define the margin between <a id="_idIndexMarker608"/>an image and <code>aboutCommunity</code>. Our layout will adjust based on the screen size to look good on both small and large screens.</p>
<p>We also use <code>ConstraintLayout</code>, which is a layout manager that allows us to create complex layouts with a flat view hierarchy. It also has built-in support for responsive layouts to create different layouts for different screen sizes and orientations.</p>
<p>The best use cases for <code>ConstraintLayout</code> include the following:</p>
<ul>
<li>When you want <a id="_idIndexMarker609"/>to avoid nesting multiple columns and rows; this can include when you want to position your elements on screen for easier code readability</li>
<li>Utilizing it when you need to use guidelines, chains, or barriers in your positioning</li>
</ul>
<p>We mentioned modifiers in previous chapters, which are like attributes in XML layouts. They allow us to <a id="_idIndexMarker610"/>apply different styles and <a id="_idIndexMarker611"/>behaviors to the components in our layout. You can use modifiers to change your component’s size, position, and other properties, based on the screen size.</p>
<p>In our example, we use dynamic padding and margins, and you can use them to adjust the spacing between components based on the screen size. For example, you can use a modifier to add more padding to a component on larger screens.</p>
<p>This allows you to create responsive layouts that adjust based on the screen size.</p>
<h1 id="_idParaDest-259"><a id="_idTextAnchor457"/>Handling large-screen configuration changes and continuity</h1>
<p>Android <a id="_idIndexMarker612"/>devices undergo various configuration changes during their operation. Some of the most notable, or standard, ones include the following:</p>
<ul>
<li><strong class="bold">Screen orientation change</strong>: This occurs when a user rotates a device’s screen, triggering a configuration change. This is when the device switches from portrait to landscape mode or vice versa.</li>
<li><strong class="bold">Screen size change</strong>: This is when a user changes the screen size of a device – for example, by plugging or unplugging an external display, triggering a configuration change.</li>
<li><strong class="bold">Language or locale change</strong>: This is when a user changes the language or locale of a device, triggering a configuration change. This can affect the formatting of text and dates, among other things.</li>
<li><strong class="bold">Theme change</strong>: This is when a user changes a device’s theme, triggering a configuration change. This can affect the appearance of the UI.</li>
<li><strong class="bold">Keyboard availability change</strong>: This is when a user attaches or detaches a keyboard from a device, triggering a configuration change. This can affect the layout of the UI, and so on.</li>
</ul>
<p>In this recipe, we will look at leveraging this knowledge to better handle screen size changes when dealing with foldable devices.</p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor458"/>Getting ready</h2>
<p>In the first recipe, <em class="italic">Building adaptive layouts in Modern Android Development</em>, we discussed <a id="_idIndexMarker613"/>different state configurations and how to handle them better. In this recipe, we will learn how to use the already provided <code>rememberFoldableState</code> function in Jetpack Compose to handle screen changes in foldable devices.</p>
<h2 id="_idParaDest-261"><a id="_idTextAnchor459"/>How to do it…</h2>
<p>Let’s use the already created <code>Traveller</code> project for this example; you will not need to create a new project:</p>
<ol>
<li>To be able to use <code>rememberFoldableState</code>, we will need to import it into our project:<pre class="source-code">
import Androidx.window.layout.FoldableState</pre></li>
<li>Then, we will create a new <code>val/ property foldableState</code> and initialize it with our <code>rememberFoldableState</code>:<pre class="source-code">
val foldState = rememberFoldableState()</pre></li>
<li>Using the <code>foldState</code> object, we can get information about foldable devices, make our application respond to the correct state, and display data as needed. The three states available are <code>STATE_FLAT</code>, <code>STATE_HALF_OPENED</code>, and<code> STATE_CLOSED</code>:<pre class="source-code">
when (foldState.state) {</pre><pre class="source-code">
    FoldableState.STATE_FLAT -&gt; {</pre><pre class="source-code">
        // Our Device is flat (unfolded)do something</pre><pre class="source-code">
    }</pre><pre class="source-code">
    FoldableState.STATE_HALF_OPENED -&gt; {</pre><pre class="source-code">
        //Our Device is partially folded. Do something</pre><pre class="source-code">
    }</pre><pre class="source-code">
    FoldableState.STATE_CLOSED -&gt; {</pre><pre class="source-code">
        //Our Device is fully folded do something</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre></li>
<li>We can then use this information to adjust our UI accordingly, such as showing or hiding <a id="_idIndexMarker614"/>certain elements based on the foldable state or specified position. Also, we can create two different layouts for when the device is folded and when it is unfolded:<pre class="source-code">
val isFolded = foldState.state == FoldableState.STATE_CLOSED</pre><pre class="source-code">
if (isFolded) {</pre><pre class="source-code">
    // Create our layout for when the device is folded</pre><pre class="source-code">
} else {</pre><pre class="source-code">
    // Create our layout for when the device is</pre><pre class="source-code">
       unfolded</pre><pre class="source-code">
}</pre></li>
</ol>
<p>And that’s it; this will help solve the foldable state if you have a complex UI system that needs better handling.</p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor460"/>How it works…</h2>
<p>Handling significant screen configuration changes, especially with foldable devices, can be challenging in Android Jetpack Compose. Here are some tips that can help you use the Configuration API. It allows you to get information about a device’s screen configuration, such as screen size, orientation, and foldable state. You can use this informat<a id="_idTextAnchor461"/>ion to adjust your UI accordingly.</p>
<p>Compose’s layout system makes it easy to create responsive UIs that can adapt to different screen sizes and aspect ratios. Use flexible layouts such as columns and rows to create a UI tha<a id="_idTextAnchor462"/>t can scale up or down as needed.</p>
<p>The <code>rememberFoldableState</code> function lets you get information about a device’s foldable state <a id="_idIndexMarker615"/>and adjust your UI accordingly. For example, you can use this function to create two different layouts, one for when the device is folded and one for when it is unfolded.</p>
<p>Testing your app with different screen configurations is also essential to ensure that it works properly. You can use the Android emulator or physical devices to test your app.</p>
<h1 id="_idParaDest-263"><a id="_idTextAnchor463"/>Understanding activity embedding</h1>
<p>In Jetpack Compose, activity embedding refers to the process of including a composable function within the <a id="_idIndexMarker616"/>context of an activity. This allows you to create custom views that can integrate seamlessly with existing Android activities.</p>
<p>To embed a composable function within an activity, you can use the <code>setContent</code> method of the activity. This method accepts a composable function as a parameter, which can be used to define the activity’s layout.</p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor464"/>Getting ready</h2>
<p>You need to have completed the previous re<a id="_idTextAnchor465"/>cipes to follow along.</p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor466"/>How to do it…</h2>
<p>Let’s look at an example of embedding a<a id="_idTextAnchor467"/> composable function in an activity:</p>
<pre class="source-code">
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyCustomView()
        }
    }
}
@Composable
fun MyCustomView() {
    Text(te<a id="_idTextAnchor468"/>xt = "Hello, Android Community!")
}</pre>
<p>In this example, the <code>setContent</code> method embeds the <code>MyCustomView</code> composable function within <code>MainActivity</code>. When the activity is created, the <code>MyCustomView</code> function will be called to generate the activity’s layout.</p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor469"/>How it works…</h2>
<p>The <code>MyCustomView</code> function is defined as a composable function using the <code>@Composable</code> annotation. This allows the function to be called multiple times without causing any side effects. In <a id="_idIndexMarker617"/>this case, the function simply displays a <code>Text</code> composable with the text <code>Hello, </code><code>Android Community!</code>.</p>
<p>By embedding composable functions within activities, you can create custom views that can be easily integrated into your Android app. This can be especially useful to create reusable components or customize the layout of existing activities.</p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor470"/>Material Theming in Compose</h1>
<p><strong class="bold">Material Theming</strong> in Compose is <a id="_idIndexMarker618"/>a design system introduced by Google that provides guidelines and principles to design user interfaces. Material Theming helps designers create interfaces that are consistent, easy to use, and visually appealing. Some key features of Material Theming in Jetpack Compose include the following:</p>
<ul>
<li><code>MaterialTheme</code> composable that allows you to apply a color palette to your entire app.</li>
<li><code>Typography</code> composable that allows you to apply a typography style to your text.</li>
<li><code>Shape</code> composable that allows you to apply a shape to your components.</li>
<li><code>Icon</code> composable that allows you to use Material icons in your app.</li>
</ul>
<p>By using Material Theming in Jetpack Compose, you can create interfaces that are consistent, easy to <a id="_idIndexMarker623"/>use, and visually appealing. Material Theming in Jetpack Compose helps you focus on designing your app’s functionality, while the design system takes care of the visual details.</p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor471"/>Getting ready</h2>
<p>To be able to follow along, you need to have worked on previous recipes.</p>
<h2 id="_idParaDest-269"><a id="_idTextAnchor472"/>How to do it…</h2>
<p>Many applications still do not use <code>Material 3</code>, but if you build a new application from scratch, it is highly recommended you go with <code>Material 3</code>. One thing to note is when you create a project, <code>Material 3</code> does not come pre-installed; this means you need to go ahead and update the Material libraries yourself to <code>Material 3</code>.</p>
<p>Let’s see an example of implementing <code>Material 3</code> theming in Jetpack Compose for your Android applications:</p>
<ol>
<li>You will need to add the required <code>Material 3</code> dependencies to your app’s <code>build.gradle</code> file:<pre class="source-code">
implementation 'Androidx.compose.material3:material3:1.0.0-alpha14'</pre></li>
<li>Then, you <a id="_idIndexMarker624"/>will need to declare your app theme:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun MyAppMaterialTheme(content: @Composable () -&gt; Unit) {</pre><pre class="source-code">
    MaterialTheme(</pre><pre class="source-code">
        colorScheme = /**/,</pre><pre class="source-code">
        typography = /**/,</pre><pre class="source-code">
        shapes = /**/,</pre><pre class="source-code">
        content = content</pre><pre class="source-code">
    )</pre><pre class="source-code">
}</pre></li>
<li>Finally, you can use your theme in the entire application:<pre class="source-code">
@Composable</pre><pre class="source-code">
fun MyApp() {</pre><pre class="source-code">
    MyAppMaterialTheme {}</pre><pre class="source-code">
}</pre></li>
</ol>
<p>In this example, we’ve used <code>Material 3</code> colors, typography, and shapes to create a consistent and visually appealing interface. We’ve also used <code>Material 3</code> icons to enhance the user experience. Finally, we’ve wrapped our app’s content in the <code>MyAppMaterialTheme</code> composable to apply the <code>Material </code><code>3</code> theme.</p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor473"/>How it works…</h2>
<p>Here’s how <code>Material 3</code> works in Jetpack Compose. <code>Material 3</code> introduces new and updated components, such as <code>AppBar</code>, <code>BottomNavigation</code>, and <code>TabBar</code>, which can be used in Jetpack Compose using the <code>Androidx.compose.material3</code> package. These components have updated design and functionality<a id="_idTextAnchor474"/>, and they follow the <code>Material </code><code>3</code> guidelines.</p>
<p>Material 3 also introduces a new theming system that allows for more customization and flexibility – that is, in Jetpack Compose, <code>Material 3</code> theming can be applied using the <code>MaterialTheme3</code> composable. This composable allows you to customize the color scheme, typography, and shapes of your app, and it also provides new options to customize t<a id="_idTextAnchor475"/>he elevation and shadows of your components.</p>
<p>The icons are now modern and easily accessible, which is a big plus for us developers. Finally, Material 3 introduces a new typography system that provides updated styles and guidelines for <a id="_idIndexMarker625"/>typography in your app. In Jetpack Compose, <code>Material 3</code> typography can be applied using the <code>Material3Typography</code> object, which prov<a id="_idTextAnchor476"/>ides several predefined styles for your text.</p>
<p>By using <code>Material 3</code> in Jetpack Compose, you can create modern and visually appealing interfaces that follow the latest design guidelines. Also note that <code>Material 3</code> components, theming, icons, and typography can all be used together to create a cohesi<a id="_idTextAnchor477"/>ve and consistent design system for your app.</p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor478"/>See also…</h2>
<p>There is much to cover in Material Design, and trying to cover all components in a single recipe will <a id="_idIndexMarker626"/>not do it justice. To learn more about the components and how to ensure your application follows the Material Design guideline, read more here: <a href="https://material.io/components">https://material.io/components</a>.</p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor479"/>Testing your applications on a foldable device</h1>
<p>Testing your apps <a id="_idIndexMarker627"/>on foldable devices is essential to <a id="_idIndexMarker628"/>ensure they work correctly and provide an excellent user experience. In this recipe, we will look at some tips to test y<a id="_idTextAnchor480"/>our apps on foldable devices in Jetpack Compose.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor481"/>Getting ready</h2>
<p>You will need to have done the previous recipes. You can access the en<a id="_idTextAnchor482"/>tire code in the <em class="italic">Technical </em><em class="italic">requirements</em> section.</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor483"/>How to do it…</h2>
<p>Here are some tips to test your applications on foldable devices:</p>
<ul>
<li><strong class="bold">Use an emulator</strong>: You can use the Android emulator to test your app on foldable devices without buying a physical device. The emulator provides a range of foldable device configurations that you can use to test your app.</li>
<li><strong class="bold">Use real devices</strong>: Testing your app on an actual foldable device can provide a more accurate <a id="_idIndexMarker629"/>representation of how your app will work on these devices. If you have access to a foldable device, it’s highly recommended to test your app on it.</li>
<li><strong class="bold">Test different screen modes</strong>: Foldable devices come in different screen modes, such as single-screen, dual-screen, and extended screens. It’s essential to test your app on different screen modes to ensure it works correctly in all modes.</li>
<li><strong class="bold">Test with different screen sizes</strong>: Foldable devices come in different sizes, so it’s crucial to test your app on different screen sizes to ensure it works well on all devices.</li>
<li><strong class="bold">Test app transition</strong>: Testing your app’s transition between different screen modes can help you identify any issues with an app’s layout or behavior. Make sure to test all the t<a id="_idTextAnchor484"/>ransition modes, such as fold, unfold, and hinge.</li>
<li><strong class="bold">Use automated testing</strong>: Automated testing can help you test your app on different <a id="_idIndexMarker630"/>screen sizes, modes, and orientations more efficiently. You can use tools such as Espresso or U<a id="_idTextAnchor485"/>I Automator to<a id="_idTextAnchor486"/> write automated tests for your app.</li>
</ul>
<h2 id="_idParaDest-275"><a id="_idTextAnchor487"/>How it works…</h2>
<p>Overall, testing <a id="_idIndexMarker631"/>your app on foldable devices requires <a id="_idIndexMarker632"/>careful consideration of a device’s unique features and abilities. By following these tips, you can ensure that your app is optimized for foldable devices and provides an excellent user experience.</p>
</div>
</body></html>