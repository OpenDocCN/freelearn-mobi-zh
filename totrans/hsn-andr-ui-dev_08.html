<html><head></head><body>
        

                            
                    <h1 class="header-title">Designing Material Layouts</h1>
                
            
            
                
<p class="mce-root">When designing and creating the layout for a screen, there are many different schools of thought about how it should be done. Modern layouts are often complex systems that change their shape dynamically as the user interacts with them. In the past, layouts tended to be quite rigid structures with only specialized areas such as windows or slit panels that could be adjusted by the user. However, a mobile application must make better use of their available space, since they're typically used on physically smaller devices. The direct interaction of a touch interface also changes how the user expects an application to behave; you need to not only react to the users gestures, but also be mindful of where their hand and fingers are likely to be on the screen as they might be obscuring some part of the screen, as they drag to scroll through your application.</p>
<p class="mce-root">The easiest way to see how a layout can change and adjust is with a jumbo collapsing toolbar. When the screen opens, the toolbar is full sized and takes up enough space to contain various additional widgets and information. As the screen is scrolled, the action button vanishes, and the toolbar collapses in size. Then, the toolbar pins itself to the top of the screen and remains visible as just the title and possibly some action buttons, as shown here:</p>
<div><img src="img/02822db6-d361-47d1-9253-4b2e52ddd52a.png"/></div>
<p>This collapsing behavior is something you see commonly in material applications--various parts of the user interface being shown or hidden as the user scrolls or changes what they are doing. These layouts often coordinate the moving, resizing, showing, and hiding of many different widgets at the same time, and there's a special class for that--the <kbd>CoordinatorLayout</kbd>.</p>
<p>In this chapter, we'll take a look at the <kbd>CoordinatorLayout</kbd> and some other specialist Android layout classes in order to do the following:</p>
<ul>
<li style="font-weight: 400">Create layouts that change based on user actions</li>
<li style="font-weight: 400">Create layouts on flexible grids</li>
<li style="font-weight: 400">Allow the user to take actions using gestures</li>
<li style="font-weight: 400">Highlight some widgets above others using elevation</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Looking at material structure</h1>
                
            
            
                
<p>Material layouts have a selection of patterns that applications should follow for every screen they build. This sort of template is often called the <strong>scaffolding</strong>, and for mobile, it looks like this:</p>
<div><img height="301" width="170" src="img/3f0a7b7a-4c05-4b04-9dc4-bcc3e84a7eb7.png"/></div>
<p>What is important about the scaffolding is that while it defines the basic layout of virtually every screen, it doesn't define how you should achieve this design, and even on Android, you'll find that there are several different ways of creating a screen with the preceding layout structure. Several elements are also optional: the Bottom Bar and floating action button are often left out because they aren't useful to a screen. The App Bar appears on most screens, but can be much larger and can also be folded away to provide the user with more reading space in the content area.</p>
<p>It's also important to understand that by default, the platform theming will put the App Bar (presented by the <kbd>ActionBar</kbd> class) into an <kbd>Activity</kbd> for you; it's also common to create your own App Bar using the <kbd>Toolbar</kbd> class and the <kbd>NoActionBar</kbd> theme on the <kbd>Activity</kbd>. In fact, in <a href="6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml" target="_blank">Chapter 2</a>, <em>Designing Form Screens</em>, when you created the <kbd>CaptureClaimActivity</kbd>, the Android Studio template did exactly this:</p>
<pre>&lt;activity<br/>    android:name=".CaptureClaimActivity"<br/>    android:label="@string/title_activity_capture_claim"<br/>    android:theme="@style/AppTheme.NoActionBar" /&gt;</pre>
<p>In the <kbd>CaptureClaimActivity</kbd> class, near the top of the <kbd>onCreate</kbd> method, you'll be able to find the following code snippet:</p>
<pre>Toolbar toolbar = findViewById(R.id.toolbar);<br/>setSupportActionBar(toolbar);</pre>
<p>This code allows your application to take complete control of the <kbd>Toolbar</kbd>, from what it looks like, to what widgets it contains. Setting it as the <kbd>SupportActionBar</kbd> tells the <kbd>AppCompatActivity</kbd> to delegate any calls to <kbd>Activity.setTitle</kbd> and similar methods to the <kbd>Toolbar</kbd>, but in no other way changes how the <kbd>Toolbar</kbd> interacts with the layout system. This is still firmly under your control now.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing CoordinatorLayout</h1>
                
            
            
                
<p>Android has a small family of layouts designed to work together to achieve the dynamic movement effects when the user scrolls. At the core of this group is the <kbd>CoordinatorLayout</kbd> class, which allows complex behaviors to be attached to any number of floating sibling widgets that can depend on and react to each other's position and size. To illustrate how a <kbd>CoordinatorLayout</kbd> actually works, take a look at this diagram:</p>
<div><img height="209" width="367" src="img/ea7ef32e-740a-40e3-8cf6-e0885b1d0d5c.png"/></div>
<p>Even though the <kbd>FloatingActionButton</kbd> appears to be floating above the other widgets, it's a direct child of the <kbd>CoordinatorLayout</kbd>. It remains in place because it is anchored to the bottom of the toolbar. If the toolbar changes its size or position, the <kbd>CoordinatorLayout</kbd> will move the <kbd>FloatingActionButton</kbd> so that it appears to be attached to the bottom of the toolbar. These movements are all done together as part of the layout process, resulting in every frame being pixel perfect and everything appearing to move and resize together.</p>
<p><kbd>CoordinatorLayout</kbd> defines two major ways to manipulate its child widgets--anchors and behaviors:</p>
<ul>
<li><strong>Anchors</strong> are by far the simpler of these two; they simply attach one widget to another widget. The anchors respond to the <kbd>layout_gravity</kbd> attribute and a special <kbd>layout_anchorGravity</kbd> attribute to determine exactly where the anchored widget should appear relatively to the widget it's attached to.</li>
<li><strong>Behaviors</strong> are more complex; they are entire classes that can be used to manipulate the widget in any way based on other widgets (known as its <strong>dependencies</strong>). Several classes define their own behavior classes that should be used when they are declared within a <kbd>CoordinatorLayout</kbd>. For example, <kbd>FloatingActionButton</kbd> declares a <kbd>FloatingActionButton.Behavior</kbd> class that will hide the button if its anchor-point approaches too close to the end of the screen, and make it reappear when there is enough space again. This showing and hiding behavior is even accompanied by an animation.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Coordinating the Overview Screen</h1>
                
            
            
                
<p>The Overview screen you built in <a href="22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml" target="_blank">Chapter 7</a>, <em>Creating Overview Screens</em>, is a perfect candidate for a <kbd>CoordinatorLayout</kbd>. To start with, the allowance overview bar can be made to collapse, and unfold as the user scrolls. This allows more space for the claim items on the screen as they are scrolling, and by expanding the overview again when they scroll upward, the user doesn't have to scroll all the way to the top to get the overview back.</p>
<p>This behavior won't just use the <kbd>CoordinatorLayout</kbd>, but will also need the help of the <kbd>AppBarLayout</kbd> and <kbd>CollapsingToolbarLayout</kbd> classes as you'll need to take control of the Material Design scaffolding to make it work. Follow these steps to move the allowance overview into the header bar and make it collapse:</p>
<ol>
<li style="font-weight: 400">First, open the <kbd>AndroidManifest</kbd> file from the manifests folder in the project tree (use the Android perspective).</li>
<li style="font-weight: 400">Find the <kbd>OverviewActivity</kbd> entry and add a theme attribute that will tell the system not to provide a system <kbd>ActionBar</kbd>, because you'll be adding your own:</li>
</ol>
<pre style="padding-left: 60px">&lt;activity<br/>    android:name=".OverviewActivity"<br/><strong>    android:theme="@style/AppTheme.NoActionBar"</strong><br/>    android:windowSoftInputMode="stateHidden"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.intent.action.MAIN" /&gt;<br/>        &lt;category android:name="android.intent.category.LAUNCHER" /&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/activity&gt;</pre>
<ol start="3">
<li style="font-weight: 400">Now, open the <kbd>activity_overview</kbd> layout file and change to the text mode. Remove the <kbd>FrameLayout</kbd> and all of its contents; you'll need to completely rewrite this file.</li>
</ol>
<ol start="4">
<li style="font-weight: 400">Create the <kbd>CoordinatorLayout</kbd> root element with all the standard namespaces and context. Note that this time you'll tell the system that this widget will fit to the root window, and not act as <em>contents</em>:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.design.widget.CoordinatorLayout <br/>    <br/>    <br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/><strong>    android:fitsSystemWindows="true"</strong><br/><strong>    </strong>android:id="@+id/scaffolding"<br/>    tools:context="com.packtpub.claim.OverviewActivity"&gt;<br/>&lt;/android.support.design.widget.CoordinatorLayout&gt;</pre>
<ol start="5">
<li>Now, create the <kbd>AppBarLayout</kbd> element within the <kbd>CoordinatorLayout</kbd>; again, you'll tell the system that the <kbd>AppBarLayout</kbd> fits to the system window and is not to be treated as normal <em>content</em> widgets:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.design.widget.AppBarLayout<br/>    android:id="@+id/app_bar"<br/>    android:layout_width="match_parent"<br/><strong>    android:layout_height="@dimen/app_bar_height"</strong><br/><strong>    </strong>android:fitsSystemWindows="true"<br/>    android:theme="@style/AppTheme.AppBarOverlay"&gt;<br/>&lt;/android.support.design.widget.AppBarLayout&gt;</pre>
<ol start="6">
<li>Use the code-assistance for the <kbd>layout_height</kbd> to create a new dimension resource named <kbd>app_bar_height</kbd>, and assign it a value of <kbd>180dp</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;dimen name="app_bar_height"&gt;180dp&lt;/dimen&gt;</pre>
<ol start="7">
<li>Within the <kbd>AppBarLayout</kbd>, you need to declare the <kbd>CollapsingToolbarLayout</kbd>. This will handle the collapsing and expanding of the toolbar and other widgets as the user scrolls. You use the <kbd>layout_scrollFlags</kbd> to tell it how to collapse and expand, but it's important to note that it's actually the <kbd>AppBarLayout</kbd> that takes care of these, so any children of <kbd>AppBarLayout</kbd> can use these flags. In this particular case, we'll be telling it to collapse when the user scrolls down the list of items, but not to exit (vanish) completely, and to reenter as soon as the user starts to scroll up the list again:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">&lt;android.support.design.widget.CollapsingToolbarLayout<br/>    android:id="@+id/toolbar_layout"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:fitsSystemWindows="true"<br/>    app:contentScrim="?attr/colorPrimary"<br/>    app:expandedTitleGravity="top"<br/>    <strong>app:layout_scrollFlags="scroll|enterAlwaysCollapsed|snap|exitUntilCollapsed"</strong><br/>    app:toolbarId="@+id/toolbar"&gt;<br/>&lt;/android.support.design.widget.CollapsingToolbarLayout&gt;</pre>
<p>In the preceding code, the <kbd>CollapsingToolbarLayout</kbd> declares its <kbd>contentScrim</kbd> as <kbd>?attr/colorPrimary</kbd>. The attributes <kbd>?</kbd> syntax is a type of lookup that is used with theming. It tells the resource-system to look up that attribute in the theme, rather than directly referencing the attribute.</p>
<ol start="8">
<li>Within the <kbd>CollapsingToolbarLayout</kbd>, you'll need to declare a <kbd>Toolbar</kbd> widget. This widget will take the place of the system <kbd>ActionBar</kbd>. We use the <kbd>layout_collapseMode</kbd> to tell the <kbd>CollapsingToolbarLayout</kbd> to <em>pin</em> the <kbd>Toolbar</kbd> to the top of the screen once it has been collapsed (rather than having it vanish completely):</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.Toolbar<br/>    android:id="@+id/toolbar"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="?attr/actionBarSize"<br/>    app:layout_collapseMode="pin"<br/>    app:popupTheme="@style/AppTheme.PopupOverlay" /&gt;</pre>
<ol start="9">
<li>After the <kbd>Toolbar</kbd> widget, you can declare the <kbd>AllowanceOverviewFragment</kbd>; it will use the <kbd>parallax</kbd> collapse mode and will disappear as the use scrolls down the list of claim items:</li>
</ol>
<pre style="padding-left: 60px">&lt;fragment<br/>    android:id="@+id/overview"<br/>    class="com.packtpub.claim.ui.AllowanceOverviewFragment"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"<br/>    android:layout_gravity="bottom"<br/>    android:layout_marginBottom="@dimen/grid_spacer1"<br/>    app:layout_collapseMode="parallax"<br/>    app:layout_collapseParallaxMultiplier="0.65" /&gt;</pre>
<ol start="10">
<li>That concludes your new <kbd>AppBarLayout</kbd> structure; now you need to add the <kbd>RecyclerView</kbd> in after the <kbd>AppBarLayout</kbd> and tell the <kbd>CoordinatorLayout</kbd> that it is scrolling content using the <kbd>layout_behaviour</kbd> attribute. This will tell the <kbd>CoordinatorLayout</kbd> that when the <kbd>RecyclerView</kbd> is scrolled, the <kbd>AppBarLayout</kbd> should react to the scrolling:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.RecyclerView<br/>    android:id="@+id/claim_items"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:layout_marginTop="@dimen/grid_spacer1"<br/>    android:clipToPadding="false"<br/>    android:clipChildren="false"<br/>    android:paddingLeft="@dimen/grid_spacer1"<br/>    android:paddingRight="@dimen/grid_spacer1"<br/>    app:layoutManager="android.support.v7.widget.LinearLayoutManager"<br/>    app:layout_behavior="@string/appbar_scrolling_view_behavior" /&gt;</pre>
<p>The <kbd>RecyclerView</kbd> declared that its behavior references a string resource by the name <kbd>appbar_scrolling_view_behavior</kbd>, but you haven't declared any such resource in your <kbd>strings.xml</kbd> file, so why doesn't the code assistant complain? This is a string resource declared by the <kbd>CoordinatorLayout</kbd> support library, and it gets merged into your application resources during the build. Its contents is the full class-name for the scrolling view <kbd>Behaviour</kbd> implementation (that is: ).</p>
<ol start="11">
<li>The final element in your <kbd>CoordinatorLayout</kbd> should be the <kbd>NewClaimItemFloatingActionButtonFragment</kbd>, which will automatically gain special behavior within the <kbd>CoordinatorLayout</kbd> because of how the <kbd>FloatingActionButton</kbd> class is written:</li>
</ol>
<pre style="padding-left: 60px">&lt;fragment<br/>    android:id="@+id/new_claim_item"<br/>    class="com.packtpub.claim.ui.NewClaimItemFloatingActionButtonFragment"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:layout_gravity="bottom|end"<br/>    android:layout_margin="@dimen/fab_margin" /&gt;</pre>
<p>The <kbd>FloatingActionButton</kbd> class declares a default <kbd>Behaviour</kbd> class that the <kbd>CoordinatorLayout</kbd> looks for when any child is added to it. This defines how the <kbd>FloatingActionButton</kbd> is positioned on the screen, when it should disappear, reappear, and even move relative to panels that may appear at the bottom of the screen (such as snackbars). The declaration is made using a publicly accessible annotation:</p>
<pre style="padding-left: 60px">@CoordinatorLayout.DefaultBehavior(FloatingActionButton.Behavior.class)<br/>public class FloatingActionButton extends VisibilityAwareImageButton {</pre>
<p>Due to how your application has been structured, the <kbd>OverviewActivity</kbd> class doesn't need to be modified for this new layout to work. It will still automatically populate the <kbd>RecyclerView</kbd> with the <kbd>ClaimItem</kbd> objects, and the fragments will communicate through the database. It is, however, useful to make the new <kbd>Toolbar</kbd> widget act as the <kbd>ActionBar</kbd> for the <kbd>OverviewActivity</kbd>; you can do this by changing the <kbd>onCreate</kbd> method to call <kbd>setSupportActionBar</kbd>:</p>
<pre style="padding-left: 60px">protected void onCreate(final Bundle savedInstanceState) {<br/>    super.onCreate(savedInstanceState);<br/>    setContentView(R.layout.activity_overview);<br/><br/>    <strong>setSupportActionBar(findViewById(R.id.toolbar));</strong><br/>    // …<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Swiping to delete</h1>
                
            
            
                
<p>While you have a way for your users to create claim items, the users have no way to delete the claim items that they have created. A common pattern in lists on mobile apps is to allow the user to swipe right to dismiss or delete items. <kbd>RecyclerView</kbd> provides some excellent and easy-to-use structures to enable this sort of behavior; however, it's always important to ensure that users don't delete items by mistake.</p>
<p class="mce-root">In the past, most user interfaces used confirmation dialogs when executing destructive actions. However, these "are you sure" dialogs are a horrible distraction for most users, because such messages violate a key principle--the application assumes that the user probably doesn't want to perform an action that they just took. In reality, the user probably did mean to delete the item, but the application interrupts them to ask whether they're sure about their choice. A much better behavior is to assume that the user does want to take the action, but then to give them a way to undo their action if they have made a mistake. Material Design has a design pattern and widget dedicated specifically to this sort of task--the <kbd>Snackbar</kbd>.</p>
<p class="mce-root">In Material Design language, the <kbd>Snackbar</kbd> is a small bar that can appear at the bottom of the screen, providing the user with information and possible actions that they can take based on the information given. The most commonly seen use is when something is deleted, and the user is given the chance to undo the delete. Undo actions might appear to be challenging, but they're actually very simple to carry out if correctly wrapped in a <kbd>Command</kbd> class. Follow these steps to add a swipe-to-delete action and an undo option to the travel claims application:</p>
<ol>
<li style="font-weight: 400">Open the <kbd>DataBoundViewHolder</kbd> class in the ui package.</li>
<li style="font-weight: 400">Your new classes will need a simple way to access the items from the <kbd>DataBoundViewHolder</kbd>, but the <kbd>ViewDataBinding</kbd> doesn't offer a <kbd>getVariable</kbd> method, so you'll need to keep it in a class field and provide a getter method:</li>
</ol>
<pre style="padding-left: 60px">private I item;<br/>public I getItem() { return item; }</pre>
<ol start="3">
<li>You'll also need to modify the <kbd>setItem</kbd> method to capture this field:</li>
</ol>
<pre style="padding-left: 60px">public void setItem(final I item) {<br/>    <strong>this.item = item;</strong><br/>    binding.setVariable(BR.item, item);<br/>}</pre>
<ol start="4">
<li style="font-weight: 400">Open the <kbd>OverviewActivity</kbd> source file in Android Studio.</li>
</ol>
<ol start="5">
<li style="font-weight: 400">At the bottom of the <kbd>OverviewActivity</kbd> class, you'll need to declare a new <kbd>ActionCommand</kbd> class that will encapsulate both the delete action and the undo operation. Unlike most other <kbd>ActionCommand</kbd> classes, this one is not reusable and takes no arguments:</li>
</ol>
<pre style="padding-left: 60px">class DeleteClaimItemCommand<br/>        extends ActionCommand&lt;Void, Void&gt;<br/>        implements View.OnClickListener {<br/>}</pre>
<ol start="6">
<li>The new <kbd>DeleteClaimItemCommand</kbd> class will need a reference to the <kbd>ClaimDatabase</kbd>, and will also have a <kbd>ClaimItem</kbd> field that it will delete and optionally restore:</li>
</ol>
<pre style="padding-left: 60px">private final ClaimDatabase database = ClaimApplication.getClaimDatabase();<br/>private final ClaimItem item;<br/>public DeleteClaimItemCommand(final ClaimItem item) {<br/>    this.item = item;<br/>}</pre>
<ol start="7">
<li>The <kbd>onBackground</kbd> implementation deletes the <kbd>ClaimItem</kbd> object from the database, but the <kbd>DeleteClaimItemCommand</kbd> keeps a reference to the in-memory implementation if the user decides to restore it:</li>
</ol>
<pre style="padding-left: 60px">public Void onBackground(final Void noArgs) {<br/>    database.claimItemDao().delete(item);<br/>    return null;<br/>}</pre>
<p>This code does not delete the <kbd>Attachments</kbd> related to the <kbd>ClaimItem</kbd>, which will cause the application to leak attachment files and database rows. In practice, you would also want to ensure that the attachments are cleaned up as well by copying the behavior used for <kbd>ClaimItem</kbd>, but that is beyond the scope of this example.</p>
<ol start="8">
<li>The <kbd>onForeground</kbd> implementation will need to display a <kbd>Snackbar</kbd> notification telling the user that the item was deleted; for that, you'll need a localizable message. The <kbd>Context</kbd> class offers a convenience <kbd>getString</kbd> method that will generate a formatted string from the application resources:</li>
</ol>
<pre style="padding-left: 60px">final String message = getString(<br/>        R.string.msg_claim_item_deleted,<br/>        item.getDescription());</pre>
<ol start="9">
<li>Use the code assistance to create a new string resource named <kbd>msg_claim_item_deleted</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;string name="msg_claim_item_deleted"&gt;<strong>%s Deleted</strong>&lt;/string&gt;</pre>
<p>These strings follow the formatting rules defined in <kbd>java.util.Formatter</kbd> or <kbd>String.format</kbd>, allowing you to create relatively complex formatting rules. By providing different <kbd>strings.xml</kbd> files for different languages and formats like this, you can very easily localize most strings in your application.</p>
<ol start="10">
<li>In the <kbd>onForeground</kbd> method, you'll need to grab a reference to the <kbd>CoordinatorLayout</kbd> as a base for the <kbd>Snackbar</kbd>:</li>
</ol>
<pre style="padding-left: 60px">final View scaffolding = findViewById(R.id.scaffolding);</pre>
<ol start="11">
<li>Then, create the <kbd>Snackbar</kbd> object, specifying its undo action text, and use the <kbd>DeleteClaimItemCommand</kbd> as the action handler (<kbd>OnClickListener</kbd>):</li>
</ol>
<pre style="padding-left: 60px">Snackbar.make(scaffolding, message, Snackbar.LENGTH_LONG)<br/>        .setAction(R.string.undo, this)<br/>        .show();</pre>
<ol start="12">
<li>Use the code assistance on the <kbd>R.string.undo</kbd> reference to create a new string resource for the text of the <kbd>undo</kbd> action:</li>
</ol>
<pre style="padding-left: 60px">&lt;string name="undo"&gt;Undo&lt;/string&gt;</pre>
<ol start="13">
<li>If the user clicks on the undo action, the <kbd>DeleteClaimItemCommands</kbd> and <kbd>onClick</kbd> methods will be invoked. It can then use its cached reference to the deleted <kbd>ClaimItem</kbd> to restore it in the database:</li>
</ol>
<pre style="padding-left: 60px">public void onClick(final View view) {<br/>    AsyncTask.SERIAL_EXECUTOR.execute(database.createClaimItemTask(item));<br/>}</pre>
<ol start="14">
<li>As another inner-class to the <kbd>OverviewActivity</kbd>, you'll need a class to provide the action definition and handling for the <em>swipe-to-delete</em> behavior. This new class will extend the <kbd>SimpleCallback</kbd> class of the <kbd>ItemTouchHelper</kbd> class, which provides the handling for the movement gesture recognition:</li>
</ol>
<pre style="padding-left: 60px">private class SwipeToDeleteCallback extends ItemTouchHelper.SimpleCallback {<br/>}</pre>
<ol start="15">
<li>The <kbd>SimpleCallback</kbd> constructor takes two sets of "flags" in the form of <kbd>int</kbd> values. These are simply a number of numbers that you can binary "or" (using the <kbd>|</kbd> operator) together. These define the different gestures to allow and manage. The first of these are the flags for different types of "move" gestures that can be used to reorder the items in a <kbd>RecyclerView</kbd> (leaving this as zero indicates that no move gestures should be recognized). The second flag's argument is for "swipe" gestures, which are what we're interested in here:</li>
</ol>
<pre style="padding-left: 60px">SwipeToDeleteCallback() {<br/>    super(0, ItemTouchHelper.RIGHT);<br/>}</pre>
<ol start="16">
<li>The <kbd>SimpleCallback</kbd> class requires that you declare handler methods for moving and swiping, even though the class will not deal with movement gestures. You'll need to declare <kbd>onMove</kbd>, but the class can just return <kbd>false</kbd> as its implementation:</li>
</ol>
<pre style="padding-left: 60px">public boolean onMove(<br/>        final RecyclerView recyclerView,<br/>        final RecyclerView.ViewHolder viewHolder,<br/>        final RecyclerView.ViewHolder target) {<br/><br/>    return false;<br/>}</pre>
<ol start="17">
<li>Next, you can define the implementation of the <kbd>onSwipe</kbd> method, which will create a <kbd>DeleteClaimItemCommand</kbd> and execute it:</li>
</ol>
<pre style="padding-left: 60px">public void onSwiped(<br/>        final RecyclerView.ViewHolder viewHolder,<br/>        final int direction) {<br/><br/>    final DataBoundViewHolder&lt;?, ClaimItem&gt; holder<br/>           = (DataBoundViewHolder&lt;?, ClaimItem&gt;) viewHolder;<br/>    <strong>new DeleteClaimItemCommand(holder.getItem()).exec(null);</strong><br/>}</pre>
<ol start="18">
<li>Now, to attach the <kbd>SwipeToDeleteCallback</kbd> to the <kbd>RecyclerView</kbd>, you need to wrap it using the <kbd>ItemTouchHelper</kbd> class, and attach that to your <kbd>RecyclerView</kbd> instance at the bottom of the <kbd>onCreate</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">final RecyclerView claimItems = findViewById(R.id.claim_items);<br/>    claimItems.setAdapter(new ClaimItemAdapter(<br/>            this, this,<br/>            ClaimApplication.getClaimDatabase().claimItemDao().selectAll()<br/>    ));<br/><br/>    <strong>new ItemTouchHelper(new SwipeToDeleteCallback())</strong><br/><strong>            .attachToRecyclerView(claimItems);</strong><br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Elevating widgets</h1>
                
            
            
                
<p>An excellent way of highlighting one widget over the others on the screen is to make it appear over the others on the screen, not two-dimensionally, but floating above them as though in three-dimensions. This is already a clear pattern if you look at the <kbd>FloatingActionButton</kbd> classes; they don't just overlap other widgets, but they have a shadow and appear to float in space (hence the class name <kbd>FloatingActionButton</kbd>).</p>
<p class="mce-root">One of the great features in the Android widget library is that the <kbd>View</kbd> class defines the notion of elevation, which makes it usable by every widget in the toolkit. The elevation of a widget doesn't affect its two-dimensional position or size, but does cause it to produce a shadow that will be correctly shaded as though the widget is floating in three-dimensions. This can be used to create an amazing effect when you need to draw attention to a message, or when the user is repositioning a widget on the screen (for example, reorganizing a list of reminders). Given that most of a Material Design user interface is flat, adding a three-dimensional elevation instantly makes a widget stand out for the user.</p>
<p>Much like the borders and shadow of a <kbd>CardView</kbd> widget, when you use elevation, you need to ensure that the shadow is not clipped by the parent widget or the padding attributes. Use the <kbd>clipChildren</kbd> and <kbd>clipToPadding</kbd> attributes to control this.</p>
<p>Follow these steps to add an elevation effect to the swipe-to-delete behavior callback:</p>
<ol>
<li>Open the <kbd>OverviewActivity</kbd> and find the <kbd>SwipeToDeleteCallback</kbd> inner class.</li>
<li>The class will need to be able to reset the elevation if the user "drops" an item after picking it up to delete it. For this, the <kbd>SwipeToDeleteCallback</kbd> class will need a field with the default card elevation:</li>
</ol>
<pre style="padding-left: 60px">final float defaultElevation = <br/>        getResources().getDimensionPixelSize(R.dimen.cardview_default_elevation);</pre>
<ol start="3">
<li>Every time a child of the <kbd>RecyclerView</kbd> is drawn after being picked up, the <kbd>ItemTouchHelper</kbd> allows you to override the drawing behavior. In your case, you want to adjust the elevation of the card relative to how far right the user has dragged it. In order to work on older versions of Android, this code uses the <kbd>ViewCompat</kbd> class to change the elevation:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">public void onChildDraw(<br/>        final Canvas c,<br/>        final RecyclerView recyclerView,<br/>        final RecyclerView.ViewHolder viewHolder,<br/>        final float dX, final float dY,<br/>        final int actionState,<br/>        final boolean isCurrentlyActive) {<br/><br/>    if (isCurrentlyActive) {<br/>        <strong>ViewCompat.setElevation(</strong><br/><strong>                viewHolder.itemView,</strong><br/><strong>                Math.min(</strong><br/><strong>                        Math.max(dX / 4f, defaultElevation),</strong><br/><strong>                        defaultElevation * 16f</strong><br/><strong>                )</strong><br/><strong>        );</strong><br/>    }<br/><br/>    super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);<br/>}</pre>
<ol start="4">
<li>Once the card is released by the user, we need to clear the elevation value by setting it back to its default; the <kbd>ItemTouchHelper</kbd> will invoke the <kbd>clearView</kbd> callback when the user drops an item:</li>
</ol>
<pre style="padding-left: 60px">public void clearView(<br/>        final RecyclerView recyclerView,<br/>        final RecyclerView.ViewHolder viewHolder) {<br/>    <strong>ViewCompat.setElevation(viewHolder.itemView, defaultElevation);</strong><br/>    super.clearView(recyclerView, viewHolder);<br/>}</pre>
<p>Once you've implemented this behavior, the user will receive secondary visual feedback on the swipe to delete gesture, as the card they drag will appear to rise above the others as they pull it to the right. It'll also do the reverse and appear to descend back to its normal elevation if they drag it to the left again. This elevation feedback can be even more useful on interfaces where the user can change the position of the cards in a list (for example, in a to-do list). Note that as the card's elevation increases, it casts a shadow on the cards both below and above it:</p>
<div><img src="img/6ba8e1ad-4842-451f-b1f0-df6616b8cf26.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Building layouts using grids</h1>
                
            
            
                
<p>When building screens, it's common to want specific widgets to appear the same size and shape as other widgets. This is often achieved using flexible grid models for the layout. By dividing the screen into a number of cells, and having each widget occupy one or more cells, you can create very complex layouts that will stretch to any screen size. However, this traditional model is completely outdated when faced with <kbd>ConstraintLayout</kbd>, which is capable of maintaining complex relationships between widgets without the need for a grid.</p>
<p class="mce-root"/>
<p class="mce-root">In most situations, <kbd>ConstraintLayout</kbd> should be more than capable of managing any complex layout you choose to design, and will be much more flexible than a grid/table layout manager. Unlike a grid-based layout engine, <kbd>ConstraintLayout</kbd> is much more flexible when dealing with widgets that are sized based on a font or images that can be various sizes, depending on the physical screen size and pixel-density. While <kbd>GridLayout</kbd> will adjust the size of the cells to accommodate such widgets, they are still confined by grid lines.</p>
<p class="mce-root">However, every now and then, you'll need to build a layout based on grid cells. For situations like this, you'll want to use the <kbd>GridLayout</kbd> class. <kbd>GridLayout</kbd> allows you to define layouts based on an invisible grid, where each widget can take up one or more cells, and the size of each row and column is flexible; that is, each column can be a different width, and each row can be a different height. It's important to remember that <kbd>GridLayout</kbd> is not intended for displaying large tables of data, but rather for laying out screens that favor a grid-like structure. If you need to present your user with a scrolling grid (for example, of icon images), then a better model to be used is the <kbd>RecyclerView</kbd> with a <kbd>GridLayoutManager</kbd>, as this will scale to virtually any number of child components.</p>
<p>There are two different implementations of <kbd>GridLayout</kbd> in Android: one is in the platform core APIs, and the other is in the support v7 APIs. For compatibility reasons, it's typically best to use the class from the support package as it includes many of the more recently added features that might not appear on the platform implementation.</p>
<p>To explore the <kbd>GridLayout</kbd> a bit, let's take a look at how you will implement the <em>Capture Claim Details</em> card using <kbd>GridLayout</kbd> instead of <kbd>ConstraintLayout</kbd>:</p>
<ol>
<li>First, you'll need to add the <kbd>GridLayout</kbd> implementation to your project. Open the Gradle Scripts in the project tree and open the build.gradle for the app module (use the Android perspective).</li>
<li>In the dependencies list, add a dependency for the grid-layout module:</li>
</ol>
<pre style="padding-left: 60px">implementation 'com.android.support:appcompat-v7:26.0.0'<br/><strong>implementation 'com.android.support:gridlayout-v7:26.0.0'</strong></pre>
<p>The version number at the end (in this case, <kbd>26.0.0</kbd>) must exactly match the version number of the <kbd>appcompat</kbd> module your application references. If these versions don't match exactly, it can lead to instabilities and in some cases, your application won't even compile. Change the version number to match the one declared on the <kbd>appcompat</kbd> reference in your <kbd>build.gradle</kbd> before continuing to the next step.</p>
<ol start="3">
<li>Save the file, and synchronize the project using the Sync Now link that appears at the top of the editor.</li>
<li style="font-weight: 400">Right-click on the res | layout directory in the project file tree, and select New | Layout resource file.</li>
<li style="font-weight: 400">Name the new file <kbd>fragment_capture_claim_grid</kbd>.</li>
<li style="font-weight: 400">Change the root element to <kbd>android.support.v7.widget.GridLayout</kbd>:</li>
</ol>
<div><img src="img/d0713e73-432f-47b0-96f3-47fb7083ee73.png"/></div>
<ol start="7">
<li>Change to the Text mode editor.</li>
<li>As you're using the support libraries <kbd>GridLayout</kbd> implementation, several of the XML attributes will be in the <kbd>app</kbd> namespace rather than the platform (<kbd>android</kbd>) namespace. You'll need to add the <kbd>app</kbd> namespace to the <kbd>GridLayout</kbd> declaration:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.v7.widget.GridLayout<br/>    <br/>    <strong/><br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"&gt;<br/>&lt;/android.support.v7.widget.GridLayout&gt;</pre>
<ol start="9">
<li><kbd>GridLayout</kbd> sets many of the layout attributes by default, and assumes, by default, that each child is in the cell, following the one before it (starting at the top-left cell). It allows you to specify the <kbd>columnWeight</kbd> and <kbd>rowWeight</kbd> attributes to define how much of the available space each cell should take up. Declare a <kbd>TextInputLayout</kbd> to take up 70% of the available space:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.design.widget.TextInputLayout <strong>app:layout_columnWeight="0.7"</strong>&gt;<br/>    &lt;android.support.design.widget.TextInputEditText<br/>        android:id="@+id/description"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:hint="@string/label_description" /&gt;<br/>&lt;/android.support.design.widget.TextInputLayout&gt;</pre>
<p>The preceding <kbd>TextInputLayout</kbd> widget only occupies a single cell within the <kbd>GridLayout</kbd>, but that cell has been told to take up 70% of the available horizontal space when rendering.</p>
<ol start="10">
<li>Next, declare the amount <kbd>TextInputLayout</kbd>; this will also only occupy a single cell, but we'll want it to occupy the remaining 30% of the horizontal space:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.design.widget.TextInputLayout <strong>app:layout_columnWeight="0.3"</strong>&gt;<br/>    &lt;android.support.design.widget.TextInputEditText<br/>        android:id="@+id/amount"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:hint="@string/label_amount" /&gt;<br/>&lt;/android.support.design.widget.TextInputLayout&gt;</pre>
<ol start="11">
<li>Now, we want to declare a <kbd>DatePickerLayout</kbd> for the user to select the date, but we need to tell the <kbd>GridLayout</kbd> to put it on the next row. You do this using the <kbd>row</kbd> and <kbd>column</kbd> attributes. This widget also needs to take up the full width of the <kbd>GridLayout</kbd>, which means it needs to occupy two columns, which is done using the <kbd>columnSpan</kbd> attribute:</li>
</ol>
<pre>&lt;com.packtput.claim.widget.DatePickerLayout<br/>    android:id="@+id/date"<br/>    <strong>app:layout_row="1"</strong><br/><strong>    app:layout_column="0"</strong><br/><strong>    app:layout_columnSpan="2"</strong><br/><strong>    app:layout_gravity="fill_horizontal</strong>" /&gt;</pre>
<p>If you take a look in the Design view, you'll note that this layout looks almost identical to the one you wrote in <a href="6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml" target="_blank">Chapter 2</a>, <em>Designing Form Screens</em>, for capturing the claims. The biggest difference is that the <kbd>ConstraintLayout</kbd> uses a fixed minimum size for the Amount, while this layout uses relative sizes by manipulating the weights of the grid cells. The resulting layout should look like this:</p>
<div><img height="111" width="208" src="img/7947bd9d-6e56-49b9-a984-c0f0eb3c159f.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Stack view</h1>
                
            
            
                
<p>Sometimes, it's useful to be able to display long lists of items with only one item visible at a time, for example, the list of attachments for a <kbd>ClaimItem</kbd>. In this case, you can use the side-to-side <kbd>ViewPager</kbd> as you've already done, but there is another option--the <kbd>StackView</kbd>. The <kbd>StackView</kbd> class presents its contents as a three-dimensional stack of cards, with the "top" card fully visible, and some of the cards "behind it," as shown:</p>
<div><img height="284" width="279" src="img/97eae5f4-0729-43ca-af85-4007e5f7ab7b.png"/></div>
<p>This is often a very useful pattern, as it provides the user with plenty of screen space to view the top item, while also being able to see that there are other items that can be viewed. This makes it ideal for displaying photos or large cards of data. It's very similar to how Android displays the list of running applications when you tap on the "Recent Apps" button on a device.</p>
<p>The <kbd>StackView</kbd> is a classic <kbd>Adapter</kbd> view, and works using the same <kbd>Adapter</kbd> implementations as <kbd>ListView</kbd> or <kbd>GridView</kbd>. If done correctly, you can write code that can be used in any of these classes; follow these steps to build a simple <kbd>StackView</kbd> and <kbd>Adapter</kbd> implementation that can be used to preview the <kbd>Attachment</kbd> differently:</p>
<ol>
<li style="font-weight: 400">Right-click on the ui.attachments package in the project tree, and select New| Java Class.</li>
<li style="font-weight: 400">Name the new class <kbd>AttachmentListAdapter</kbd>.</li>
<li style="font-weight: 400">Change the Superclass to <kbd>android.widget.BaseAdapter</kbd>.</li>
<li style="font-weight: 400">Click on OK to create the new class.</li>
<li style="font-weight: 400">In the new <kbd>AttachmentListAdapter</kbd> class, declare a <kbd>List</kbd> of <kbd>Attachment</kbd> objects to present to the user:</li>
</ol>
<pre style="padding-left: 60px">private List&lt;Attachment&gt; attachments = Collections.emptyList();</pre>
<ol start="6">
<li>Create a constructor to observe a <kbd>LiveData</kbd> and assign the <kbd>List</kbd> of attachments and notify the <kbd>StackView</kbd> when things change:</li>
</ol>
<pre style="padding-left: 60px">public AttachmentListAdapter(<br/>        final LifecycleOwner lifecycleOwner,<br/>        final LiveData&lt;List&lt;Attachment&gt;&gt; attachments) {<br/><br/>    attachments.observe(lifecycleOwner, new Observer&lt;List&lt;Attachment&gt;&gt;() {<br/>        @Override<br/>        public void onChanged(final List&lt;Attachment&gt; attachments) {<br/>            AttachmentListAdapter.this.attachments =<br/>                    attachments != null<br/>                            ? attachments<br/>                            : Collections.&lt;Attachment&gt;emptyList();<br/>            notifyDataSetChanged();<br/>        }<br/>    });<br/>}</pre>
<ol start="7">
<li>Much like a <kbd>RecyclerView.Adapter</kbd> implementation, the <kbd>BaseAdapter</kbd> needs a method to access the number of items it's expected to present:</li>
</ol>
<pre style="padding-left: 60px">public int getCount() { return attachments.size(); }</pre>
<ol start="8">
<li>Unlike the <kbd>RecyclerView.Adapter</kbd> implementations, however, a <kbd>BaseAdapter</kbd> is expected to expose the underlying data directly. It's also required to expose a unique ID for each element of data:</li>
</ol>
<pre style="padding-left: 60px">public Object getItem(final int i) { return attachments.get(i); }<br/>public long getItemId(final int i) { return attachments.get(i).id; }</pre>
<ol start="9">
<li>Also, unlike a <kbd>RecylcerView.Adapter</kbd>, there is only a single method to create and reuse the existing view items, as well as bind the data to them. In this method, the second argument may be <kbd>null</kbd>, but can also be an existing view that is expecting to be recycled:</li>
</ol>
<pre style="padding-left: 60px">public View getView(<br/>        final int i,<br/>        final View view,<br/>        final ViewGroup viewGroup) {<br/><br/>    AttachmentPreview preview = (AttachmentPreview) view;<br/>    if (preview == null) {<br/>        preview = new AttachmentPreview(viewGroup.getContext());<br/>    }<br/><br/>    preview.setAttachment(attachments.get(i));<br/><br/>    return preview;<br/>}</pre>
<ol start="10">
<li>To use a <kbd>StackView</kbd> from a layout XML file, you simply need to declare the <kbd>StackView</kbd> as you would a <kbd>RecyclerView</kbd> or <kbd>ViewPager</kbd>:</li>
</ol>
<pre style="padding-left: 60px">&lt;StackView<br/>    android:id="@+id/attachments"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" /&gt;</pre>
<ol start="11">
<li>Then, from the enclosing <kbd>Activity</kbd> or <kbd>Fragment</kbd>, you will need to set its <kbd>Adapter</kbd>. Much like the <kbd>RecyclerView</kbd>, the <kbd>Adapter</kbd> can also be specified from a data-bound layout. Here's how the code might look in an <kbd>Activity</kbd>:</li>
</ol>
<pre style="padding-left: 60px">final StackView attachments = findViewById(R.id.attachments);<br/>attachments.setAdapter(new AttachmentListAdapter(<br/>        this,<br/>        database.attachmentDao().selectForClaimItemId(claimItem.id)<br/>));</pre>
<p>The <kbd>StackView</kbd> class is an excellent way to present the user with a large number of larger and more visual items. It's excellent for browsing things such as photographs or preview graphics, and provides you with an easy-to-use three-dimensional transformation. Before using <kbd>StackView</kbd>, you should always consider whether the user will need to see the data from more than one item at a time. Sometimes, it's best to combine a <kbd>RecyclerView</kbd> as an "overview" with a <kbd>StackView</kbd> for viewing the individual items.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<ol>
<li>Elevation should be used for which of the following?
<ul>
<li>When the user selects an item in a list</li>
<li>To selectively highlight one item above a flat layout</li>
<li>When a user swipes to delete items</li>
</ul>
</li>
<li class="mce-root"><kbd>CoordinatorLayout</kbd> can be used to coordinate movement and size between which of these?
<ul>
<li class="mce-root">The components nested in an <kbd>AppBarLayout</kbd></li>
<li class="mce-root">Any of its direct child widgets</li>
<li class="mce-root"><kbd>Fragment</kbd> in different activities</li>
</ul>
</li>
<li class="mce-root">To change elevation of a widget in a backward-compatible way, you need to do which of the mentioned?
<ul>
<li class="mce-root">Nest the widget in a <kbd>CardView</kbd></li>
<li class="mce-root">Use the <kbd>ViewCompat</kbd> class</li>
<li class="mce-root">Use Java reflection to call <kbd>setElevation</kbd></li>
</ul>
</li>
</ol>
<ol start="4">
<li class="mce-root">The <kbd>GridLayout</kbd> class should be used in which of the following conditions?
<ul>
<li class="mce-root">When <kbd>ConstraintLayout</kbd> is not available</li>
<li class="mce-root">To display large tables of data</li>
<li class="mce-root">To lay out screens along grid lines</li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Taking ownership of what is normally the system's decorations for your application provides you with a huge variety of additional flexibility and power. By using the <kbd>CoordinatorLayout</kbd> to host the scaffolding and content of your screens, you further extend your flexibility by allowing widgets to dynamically interact with each other, even when being animated. This provides you with a way to produce pixel-perfect screens with minimal additional work.</p>
<p>Using layouts that cannot only dynamically change their shape, but also change their content using gestures such as swipe-to-dismiss to further enhance the direct manipulation aspects of a touchscreen user interface have been covered. At the same time, it's important to always consider the interactions of your user and when to interrupt them, especially around destructive actions. While there are still times where you might want to use a confirmation dialog, it's generally better to give users a method to undo their actions. It's often a very simple thing to keep the deleted entity objects in-memory until the <kbd>Snackbar</kbd> vanishes and is released from memory. Inserting entities that you have deleted from Room will actually maintain their IDs, meaning that their rows are restored exactly as they were before they were deleted.</p>
<p>In the next chapter, we'll take a look at navigation in Android applications, and explore various user interface features that are provided for your user to navigate your application. We'll also take a look at some techniques that allow you to take more control of your application's navigation flow. Providing consistent and quality navigation makes a huge difference to your user's experience.</p>


            

            
        
    </body></html>