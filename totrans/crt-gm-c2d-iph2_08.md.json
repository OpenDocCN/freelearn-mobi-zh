["```swift\n    CCTMXTiledMap *_tileMap;\n    CCTMXLayer *_ground;\n    CCTMXLayer *_triggers;\n    CCTMXLayer *_pickups;\n    CCTMXLayer *_walls;\n    CCTMXObjectGroup *spawns;\n\n    NSInteger tmw; // tilemap width\n    NSInteger tmh; // tilemap height\n    NSInteger tw; // tile width\n    NSInteger th; // tile height\n```", "```swift\n        // Load the map\n        self.tileMap = [CCTMXTiledMap tiledMapWithTMXFile:\n                        @\"desert_map.tmx\"];\n        self.ground = [_tileMap layerNamed:@\"ground\"];\n        self.triggers = [_tileMap layerNamed:@\"triggers\"];\n        self.pickups = [_tileMap layerNamed:@\"pickups\"];\n        self.walls = [_tileMap layerNamed:@\"walls\"];\n        self.triggers.visible = NO;\n        self.walls.visible = NO;\n\n        [self addChild:_tileMap z:-1];\n\n        // Load the spawn object layer\n        spawns = [_tileMap objectGroupNamed:@\"spawns\"];\n        NSAssert(spawns != nil, @\"'spawns' missing\");\n```", "```swift\n        // Shorthand for tilemap sizes, with retina fix\n        tmw = _tileMap.mapSize.width;\n        tmh = _tileMap.mapSize.height;\n        tw = _tileMap.tileSize.width /\n                            CC_CONTENT_SCALE_FACTOR();\n        th = _tileMap.tileSize.height /\n                            CC_CONTENT_SCALE_FACTOR();\n```", "```swift\n-(void) addHero {\n    // Get the player spawn location\n    NSMutableDictionary *playerSpawn =\n                    [spawns objectNamed:@\"playerSpawn\"];\n    NSAssert(playerSpawn != nil, @\"playerSpawn missing\");\n    int x = [[playerSpawn valueForKey:@\"x\"] intValue];\n    int y = [[playerSpawn valueForKey:@\"y\"] intValue];\n    CGPoint heroPos = ccp(x / CC_CONTENT_SCALE_FACTOR(),\n                          y / CC_CONTENT_SCALE_FACTOR());\n\n    // Create the player\n    hero = [TDHero heroAtPos:heroPos onLayer:self];\n    [self addChild:hero];\n}\n```", "```swift\n@class TDPlayfieldLayer;\n\n@interface TDHero : CCNode {\n    TDPlayfieldLayer *parentLayer;\n    CCSprite *sprite; // sprite for the hero\n}\n\n@property (nonatomic, retain) CCSprite *sprite;\n\n+(id) heroAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer;\n\n-(void) shoot;\n-(void) rotateToTarget:(CGPoint)target;\n\n@end\n```", "```swift\n+(id) heroAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer {\n    return [[[self alloc] initForHeroAtPos:pos onLayer:layer]\n                                                 autorelease];\n}\n\n-(id) initForHeroAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer  {\n    if((self = [super init])) {\n\n        // Keep a reference to the layer\n        parentLayer = layer;\n\n        // Build the sprite\n        self.sprite = [CCSprite\n                    spriteWithSpriteFrameName:IMG_HERO];\n        [sprite setPosition:pos];\n        // Add the sprite to the layer\n        [parentLayer addChild:sprite z:2];\n    }\n    return self;\n}\n```", "```swift\n-(void) rotateToTarget:(CGPoint)target {\n    // Rotate toward player\n    CGPoint diff = ccpSub(target,sprite.position);\n    float angleRadians = atanf((float)diff.y /\n                               (float)diff.x);\n    float angleDegrees=CC_RADIANS_TO_DEGREES(angleRadians);\n    float cocosAngle = -angleDegrees;\n    if (diff.x < 0) {\n        cocosAngle += 180;\n    }\n    sprite.rotation = cocosAngle;\n}\n```", "```swift\n-(void) shoot {\n    // Create a projectile at hero's position\n    TDBullet *bullet = [TDBullet\n                   bulletFactoryForLayer:parentLayer];\n    bullet.position = self.sprite.position;\n    bullet.rotation = self.sprite.rotation;\n    bullet.isEnemy = NO;\n\n    // Add bullets to parentLayer's array\n    [parentLayer addBullet:bullet];\n\n    // Play a sound effect\n    [[SimpleAudioEngine sharedEngine] playEffect:SND_SHOOT];\n}\n```", "```swift\n-(void)setViewpointCenter:(CGPoint) position {\n    // Method written Ray Wenderlich\n    // Posted at www.raywenderlich.com\n    int x = MAX(position.x, size.width / 2);\n    int y = MAX(position.y, size.height / 2);\n    x = MIN(x, (_tileMap.mapSize.width *\n                _tileMap.tileSize.width) - size.width / 2);\n    y = MIN(y, (_tileMap.mapSize.height *\n                _tileMap.tileSize.height) - size.height/2);\n    CGPoint actualPosition = ccp(x, y);\n    CGPoint centerOfView = ccp(size.width/2,\n                               size.height/2);\n    CGPoint viewPoint = ccpSub(centerOfView,\n                               actualPosition);\n    self.position = viewPoint;\n}\n```", "```swift\n-(void) addJoystick {\n    SneakyJoystickSkinnedBase *leftJoy =\n            [[[SneakyJoystickSkinnedBase alloc] init]\n             autorelease];\n    leftJoy.backgroundSprite = [ColoredCircleSprite\n       circleWithColor:ccc4(255, 255, 0, 128) radius:32];\n    leftJoy.thumbSprite = [ColoredCircleSprite\n       circleWithColor:ccc4(0, 0, 255, 200) radius:16];\n    leftJoy.joystick = [[[SneakyJoystick alloc]\n       initWithRect:CGRectMake(0,0,64,64)] autorelease];\n    leftJoystick = leftJoy.joystick;\n    leftJoy.position = ccp(64,36);\n    [self addChild:leftJoy z:30];\n} \n```", "```swift\n-(void) addFireButton {\n    SneakyButtonSkinnedBase *rightBut =\n            [[[SneakyButtonSkinnedBase alloc] init]\n             autorelease];\n    rightBut.position = ccp(420,36);\n    rightBut.defaultSprite = [ColoredCircleSprite\n      circleWithColor:ccc4(255, 255, 255, 128) radius:32];\n    rightBut.activatedSprite = [ColoredCircleSprite\n      circleWithColor:ccc4(255, 255, 255, 255) radius:32];\n    rightBut.pressSprite = [ColoredCircleSprite\n      circleWithColor:ccc4(255, 0, 0, 255) radius:32];\n    rightBut.button = [[[SneakyButton alloc]\n      initWithRect:CGRectMake(0, 0, 64, 64)] autorelease];\n    rightButton = rightBut.button;\n    rightButton.isToggleable = YES;\n    [self addChild:rightBut];\n}\n```", "```swift\n-(void)update:(ccTime)delta {\n    // Do nothing if the touches are off\n    if ([pf preventTouches]) {\n        return;\n    }\n    if ([pf isGameOver]) {\n        [[CCDirector sharedDirector] replaceScene:\n                                [TDMenuScene node]];\n    }\n    if (isTiltControl) {\n        // Tilt code here\n    } else {\n        // If the stick isn't centered, then we're moving\n        if (CGPointEqualToPoint(leftJoystick.stickPosition,\n                                CGPointZero) == NO) {\n            // Pass the call to the playfield\n            [pf applyJoystick:leftJoystick\n                         toNode:pf.hero.sprite\n                   forTimeDelta:delta];\n        }\n    }\n    // If the button is active, let the playfield know\n    if (rightButton.active) {\n        [pf setHeroShooting:YES];\n    } else {\n        [pf setHeroShooting:NO];\n    }\n}\n```", "```swift\n-(void) addTiltControl {\n    // Set up the accelerometer\n    self.isAccelerometerEnabled = YES;\n\n    [[UIAccelerometer sharedAccelerometer]\n                  setUpdateInterval:1.0 / 60];\n    [[UIAccelerometer sharedAccelerometer] setDelegate:self];\n}\n\n- (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration {\n    // Accelerometer values based on portrait mode, so\n    // we reverse them for landscape\n    accelX = acceleration.y * 7;\n    accelY = -acceleration.x * 7;\n}\n```", "```swift\n        // Tilt code here\n        CGPoint heroPos = [pf getHeroPos];\n        CGPoint newHeroPos = ccp(heroPos.x + accelX,\n                                 heroPos.y + accelY);\n\n        [pf rotateHeroToward:newHeroPos];\n        [pf setHeroPos:newHeroPos];\n```", "```swift\n+(id) controlsWithPlayfieldLayer:(TDPlayfieldLayer*)\n                   playfieldLayer withTilt:(BOOL)isTilt {\n    return [[[self alloc]\n                   initWithPlayfieldLayer:playfieldLayer\n                   withTilt:isTilt] autorelease];\n}\n\n-(id) initWithPlayfieldLayer:(TDPlayfieldLayer*)playfieldLayer\n                                   withTilt:(BOOL)isTilt {\n    if(self = [super init]) {\n        pf = playfieldLayer;\n        isTiltControl = isTilt;\n        if (isTiltControl) {\n            // Set up the tilt controls\n            [self addTiltControl];\n        } else {\n            // Set up the joystick\n            [self addJoystick];\n        }\n\n        // Add the fire button (all modes)\n        [self addFireButton];\n\n        [self scheduleUpdate];\n    }\n    return self;\n}\n```", "```swift\n-(void)applyJoystick:(SneakyJoystick*)joystick\n              toNode:(CCSprite*)sprite\n        forTimeDelta:(float)delta {\n\n    // Scale up the joystick's reading to faster movement\n    CGPoint scaledVelocity = ccpMult(joystick.velocity,\n                                     200);\n\n    // Apply the scaled velocity to the position\n    float newPosX = hero.sprite.position.x +\n                        scaledVelocity.x * delta;\n    float newPosY = hero.sprite.position.y +\n                        scaledVelocity.y * delta;\n    CGPoint newPos = ccp(newPosX, newPosY);\n\n    // Rotate the hero\n    [hero rotateToTarget:newPos];\n\n    // Set the new position\n    [self setHeroPos:newPos];\n}\n```", "```swift\n-(void) setHeroPos:(CGPoint)pos {\n    // Set the new position\n    hero.sprite.position = pos;\n\n    // Center the view on the hero\n    [self setViewpointCenter:pos];\n}\n```", "```swift\n-(CGPoint) getHeroPos {\n    return hero.sprite.position;\n}\n\n-(void) rotateHeroToward:(CGPoint)target {\n    [hero rotateToTarget:target];\n}\n```", "```swift\n-(void) addDisplay {\n    // Add the fixed text of the HUD\n    CCLabelTTF *kills = [CCLabelTTF \n                      labelWithString:@\"Kills:\"\n                      fontName:@\"Verdana\" fontSize:16];\n    [kills setAnchorPoint:ccp(0,0.5)];\n    [kills setPosition:ccp(10,305)];\n    [kills setColor:ccRED];\n    [self addChild:kills];\n\n    CCLabelTTF *health = [CCLabelTTF\n                      labelWithString:@\"Health:\"\n                      fontName:@\"Verdana\" fontSize:16];\n    [health setAnchorPoint:ccp(0,0.5)];\n    [health setPosition:ccp(140,305)];\n    [health setColor:ccGREEN];\n    [self addChild:health];\n\n    CCLabelTTF *goals = [CCLabelTTF\n                      labelWithString:@\"Goalposts Left:\"\n                      fontName:@\"Verdana\" fontSize:16];\n    [goals setAnchorPoint:ccp(0,0.5)];\n    [goals setPosition:ccp(300,305)];\n    [goals setColor:ccBLUE];\n    [self addChild:goals];\n\n    // Add the kill counter\n    lblKills = [CCLabelTTF labelWithString:@\"\"\n                       fontName:@\"Verdana\" fontSize:16];\n    [lblKills setAnchorPoint:ccp(0,0.5)];\n    [lblKills setPosition:ccp(60,305)];\n    [lblKills setColor:ccRED];\n    [self addChild:lblKills];\n\n    // Add the health counter\n    lblHeroHealth = [CCLabelTTF labelWithString:@\"\"\n                      fontName:@\"Verdana\" fontSize:16];\n    [lblHeroHealth setAnchorPoint:ccp(0,0.5)];\n    [lblHeroHealth setPosition:ccp(200,305)];\n    [lblHeroHealth setColor:ccGREEN];\n    [self addChild:lblHeroHealth];\n\n    // Add the goal counter\n    lblGoalsRemaining = [CCLabelTTF labelWithString:@\"\"\n                      fontName:@\"Verdana\" fontSize:16];\n    [lblGoalsRemaining setAnchorPoint:ccp(0,0.5)];\n    [lblGoalsRemaining setPosition:ccp(430,305)];\n    [lblGoalsRemaining setColor:ccBLUE];\n    [self addChild:lblGoalsRemaining];\n}\n```", "```swift\n-(void) changeHealthTo:(NSInteger)newHealth {\n    NSString *newVal = [NSString stringWithFormat:@\"%i %%\",\n                          newHealth];\n    [lblHeroHealth setString:newVal];\n}\n\n-(void) changeGoalTo:(NSInteger)newGoal {\n    NSString *newVal = [NSString stringWithFormat:@\"%i\",\n                          newGoal];\n    [lblGoalsRemaining setString:newVal];\n}\n\n-(void) changeKillsTo:(NSInteger)newKills {\n    NSString *newVal = [NSString stringWithFormat:@\"%i\",\n                         newKills];\n    [lblKills setString:newVal];\n}\n```", "```swift\n@implementation TDPlayfieldScene\n\n+(id) sceneWithTiltControls:(BOOL)isTilt {\n    return [[[self alloc] initWithTiltControls:isTilt]\n                                         autorelease];\n}\n\n-(id) initWithTiltControls:(BOOL)isTilt {\n   if( (self=[super init])) {\n        TDHUDLayer *hudLayer = [TDHUDLayer node];\n        [self addChild:hudLayer z:5];\n\n        TDPlayfieldLayer *pf = [TDPlayfieldLayer\n                      layerWithHUDLayer:hudLayer];\n        [self addChild: pf];\n\n        TDControlLayer *controls = [TDControlLayer\n                      controlsWithPlayfieldLayer:pf\n                      withTilt:isTilt];\n        [self addChild:controls z:10];\n\n   }\n   return self;\n}\n\n@end\n```", "```swift\n-(CGPoint)tileCoordForPos:(CGPoint)pos {\n    // Convert map posiiton to tile coordinate\n    NSInteger x = pos.x / tw;\n    NSInteger y = ((tmh * th) - pos.y) / th;\n\n    return ccp(x,y);\n}\n```", "```swift\n- (CGPoint)posForTileCoord:(CGPoint)tileCoord {\n    // Convert the tile coordinate to map position\n    NSInteger x = (tileCoord.x * tw) + tw / 2;\n    NSInteger y = (tmh * th)-(tileCoord.y * th)-th / 2;\n\n    return ccp(x, y);\n}\n```", "```swift\n- (BOOL)isValidTileCoord:(CGPoint)tileCoord {\n    if (tileCoord.x < 0 || tileCoord.y < 0 ||\n        tileCoord.x >= tmw ||\n        tileCoord.y >= tmh) {\n        return FALSE;\n    } else {\n        return TRUE;\n    }\n}\n```", "```swift\n-(BOOL)isWallAtTileCoord:(CGPoint)tileCoord {\n    // If it is invalid, act like it is a wall\n    if ([self isValidTileCoord:tileCoord] == NO) {\n        return YES;\n    }\n\n    int gid = [self.walls tileGIDAt:tileCoord];\n    NSDictionary *properties = [_tileMap\n                                   propertiesForGID:gid];\n\n    return ([properties valueForKey:@\"Blocked\"] != nil);\n} \n```", "```swift\n-(BOOL)isGoalAtTileCoord:(CGPoint)tileCoord {\n    int gid = [self.triggers tileGIDAt:tileCoord];\n    NSDictionary *properties = [_tileMap\n                                propertiesForGID:gid];\n\n    return ([properties valueForKey:@\"Goal\"] != nil);\n}\n\n-(BOOL)isHealthAtTileCoord:(CGPoint)tileCoord {\n    int gid = [self.triggers tileGIDAt:tileCoord];\n    NSDictionary *properties = [_tileMap\n                                propertiesForGID:gid];\n\n    return ([properties valueForKey:@\"Health\"] != nil);\n}\n```", "```swift\n-(void) setHeroPos:(CGPoint)pos {\n    // Get the tile coordinates\n    CGPoint tileCoord = [self tileCoordForPos:pos];\n\n    // Check if the new tile is blocked\n    if ([self isWallAtTileCoord:tileCoord]) {\n        // Return without allowing the move\n        return;\n    }\n\n    // Check if the hero picked up health\n    if ([self isHealthAtTileCoord:tileCoord]) {\n        // Remove it from the map\n        [_triggers removeTileAt:tileCoord];\n        [_pickups removeTileAt:tileCoord];\n        // Add health to the player\n        [self heroGetsHealth];\n    }\n\n    // Check if the hero grabbed a goal\n    if ([self isGoalAtTileCoord:tileCoord]) {\n        // Remove it from the map\n        [_triggers removeTileAt:tileCoord];\n        [_pickups removeTileAt:tileCoord];\n        // Add goal to the player\n        [self heroGetsGoal];\n    }\n\n    // Set the new position\n    hero.sprite.position = pos;\n\n    // Center the view on the hero\n    [self setViewpointCenter:pos];\n}\n```", "```swift\n-(void) heroGetsHealth {\n    heroHealth = heroHealth + 40;\n    [hudLayer changeHealthTo:heroHealth];\n}\n```", "```swift\n-(void) heroGetsGoal {\n    heroGoalsRemaining--;\n    [hudLayer changeGoalTo:heroGoalsRemaining];\n\n    if (heroGoalsRemaining <= 0) {\n        // hero wins\n        isGameOver = YES;\n        preventTouches = YES;\n    }\n}\n```", "```swift\n-(void) update:(ccTime) dt {\n    // If the shoot button is pressed\n    if (heroShooting) {\n        // We limit the hero's shoot speed to avoid\n        // massive \"bullet rain\" effect\n        if (currHeroShootSpeed > 0) {\n            currHeroShootSpeed -= dt;\n        } else {\n            // Ready to shoot\n            [hero shoot];\n            currHeroShootSpeed = shootSpeed;\n        }\n    } else {\n        // Get ready to shoot next press\n        currHeroShootSpeed = 0;\n    }\n\n    // Move the enemies\n\n    // Move the bullets\n\n    // Check collisions\n\n    // Is the game over?\n    if (isGameOver) {\n        [self gameOver];\n    }\n}\n```", "```swift\n+(id) bulletFactoryForLayer:(TDPlayfieldLayer*)layer {\n    return [[[self alloc] initForLayer:layer\n               withSpriteFrameName:IMG_BULLET] autorelease];\n}\n\n-(id) initForLayer:(TDPlayfieldLayer*)layer\n         withSpriteFrameName:(NSString*)spriteFrameName {\n    if((self = [super\n                initWithSpriteFrameName:spriteFrameName])) {\n\n        parentLayer = layer;\n\n        totalMoveDist = 200;\n        thisMoveDist = 10;\n\n        isDead = NO;\n\n    }\n    return self;\n}\n```", "```swift\n-(void) update:(ccTime)dt {\n\n    if (isDead) {\n        return;\n    }\n    // Calculate the movement\n    CGFloat targetAngle =\n            CC_DEGREES_TO_RADIANS(-self.rotation);\n    CGPoint targetPoint = ccpMult(ccpForAngle(targetAngle),\n                                  thisMoveDist);\n    CGPoint finalTarget = ccpAdd(targetPoint, self.position);\n\n    self.position = finalTarget;\n\n    totalMoveDist = totalMoveDist - thisMoveDist;\n\n    if (totalMoveDist <= 0) {\n        [parentLayer removeBullet:self];\n        return;\n    }\n\n    // Convert location to tile coords\n    CGPoint tileCoord = [parentLayer tileCoordForPos:\n                         self.position];\n\n    // Check for walls.  Walls stop bullets.\n    if ([parentLayer isWallAtTileCoord:tileCoord]) {\n        [parentLayer removeBullet:self];\n    }\n}\n```", "```swift\n-(void) addBullet:(TDBullet*)thisBullet {\n    [self addChild:thisBullet z:5];\n    [bulletArray addObject:thisBullet];\n}\n\n-(void) removeBullet:(TDBullet*)thisBullet {\n    [thisBullet setIsDead:YES];\n    [bulletArray removeObject:thisBullet];\n    [thisBullet removeFromParentAndCleanup:YES];\n}\n```", "```swift\n    for (int i = 0; i < [bulletArray count]; i++) {\n        [[bulletArray objectAtIndex:i] update:dt];\n    }\n```", "```swift\n+(id) enemyAtPos:(CGPoint)pos onLayer:(TDPlayfieldLayer*)layer {\n    return [[[self alloc] initForEnemyAtPos:pos onLayer:layer]\n                                                autorelease];\n}\n\n-(id) initForEnemyAtPos:(CGPoint)pos\n                   onLayer:(TDPlayfieldLayer*)layer  {\n    if((self = [super init])) {\n        // Keep a reference to the layer\n        parentLayer = layer;\n\n        // Build the sprite\n        [self buildEnemySpriteAtPos:pos];\n\n        // Add the sprite to the layer\n        [parentLayer addChild:sprite z:2];\n\n        // Set the max shooting speed\n        maxShootSpeed = 3;\n    }\n    return self;\n}\n```", "```swift\n-(void) buildEnemySpriteAtPos:(CGPoint)pos {\n    sprite = [CCSprite\n                spriteWithSpriteFrameName:IMG_ENEMY];\n    [sprite setPosition:pos];\n}\n```", "```swift\n-(void) rotateToTarget:(CGPoint)target {\n    // Rotate toward player\n    CGPoint diff = ccpSub(target,sprite.position);\n    float angleRadians = atanf((float)diff.y / (float)diff.x);\n    float angleDegrees = CC_RADIANS_TO_DEGREES(angleRadians);\n    float cocosAngle = -angleDegrees;\n    if (diff.x < 0) {\n        cocosAngle += 180;\n    }\n    sprite.rotation = cocosAngle;\n} \n```", "```swift\n-(void) moveToward:(CGPoint)target {\n    // Rotate toward player\n    [self rotateToTarget:target];\n\n    // Move toward the player\n    CGFloat targetAngle =\n                CC_DEGREES_TO_RADIANS(-sprite.rotation);\n    CGPoint targetPoint = ccpForAngle(targetAngle);\n    CGPoint finalTarget = ccpAdd(targetPoint,\n                                 sprite.position);\n    CGPoint tileCoord = [parentLayer\n                         tileCoordForPos:finalTarget];\n\n    if ([parentLayer isWallAtTileCoord:tileCoord]) {\n        // Cannot move - hit a wall\n        return;\n    }\n\n    // Set the new position\n    sprite.position = finalTarget;\n}\n```", "```swift\n-(void) shoot {\n    // Create a projectile at hero's position\n    TDBullet *bullet = [TDBullet\n                         bulletFactoryForLayer:parentLayer];\n    bullet.position = self.sprite.position;\n    bullet.rotation = self.sprite.rotation;\n    bullet.isEnemy = YES;\n    [bullet setColor:ccRED];\n\n    // add bullets to parentLayer's array\n    [parentLayer addBullet:bullet];\n\n    // Play a sound effect\n    [[SimpleAudioEngine sharedEngine] playEffect:SND_SHOOT];\n}\n```", "```swift\n-(void) update:(ccTime)dt {\n    currShootSpeed = currShootSpeed - dt;\n\n    // Take a step\n    [self moveToward:[parentLayer getHeroPos]];\n\n    if (ccpDistance(sprite.position, \n                     [parentLayer getHeroPos]) < 250) {\n        // Limit the shoot speed\n        if (currShootSpeed <= 0) {\n            // Ready to shoot\n            [self shoot];\n            currShootSpeed = maxShootSpeed;\n        }\n    }\n}\n```", "```swift\n    for (int i = 0; i < [enemyArray count]; i++) {\n        [[enemyArray objectAtIndex:i] update:dt];\n    }\n```", "```swift\n-(void) addEnemyOfType:(EnemyType)enemyType {\n    // Randomly pick a spawn point\n    NSString *enemySpawnID = [NSString stringWithFormat:\n                              @\"EnemySpawn%i\",\n                              (arc4random() % 11) + 1];\n\n    // Get the point\n    NSMutableDictionary *enemySpawn = [spawns objectNamed:\n                                       enemySpawnID];\n    float x = [[enemySpawn valueForKey:@\"x\"] floatValue];\n    float y = [[enemySpawn valueForKey:@\"y\"] floatValue];\n\n    // Retina-ize the position (TMX files are in pixels)\n    x /= CC_CONTENT_SCALE_FACTOR();\n    y /= CC_CONTENT_SCALE_FACTOR();\n\n    if (enemyType == kEnemyEasy) {\n        // Create the enemy (will put itself on the layer)\n        TDEnemy *enemy = [TDEnemy enemyAtPos:ccp(x,y)\n                                     onLayer:self];\n\n        // Add it to the array\n        [enemyArray addObject:enemy];\n    }\n    else if (enemyType == kEnemyHard) {\n        // Create the enemy (will put itself on the layer)\n        TDEnemySmart *enemy = [TDEnemySmart\n                               enemyAtPos:ccp(x,y)\n                               onLayer:self];\n\n        // Add it to the array\n        [enemyArray addObject:enemy];\n    }\n}\n```", "```swift\n-(void) addEnemies {\n    // Add some enemies\n    for (int i = 0; i < 5; i++) {\n        [self addEnemyOfType:kEnemyEasy];\n    }\n    for (int i = 0; i < 3; i++) {\n        [self addEnemyOfType:kEnemyHard];\n    }\n}\n```", "```swift\n-(void) checkCollisions {\n    NSMutableArray *bulletsToDelete = \n                         [[NSMutableArray alloc] init];\n\n    for (TDBullet *aBullet in bulletArray) {\n        if (CGRectIntersectsRect(aBullet.boundingBox,\n                                 hero.sprite.boundingBox)\n                                && aBullet.isEnemy) {\n            // Hero got hit!\n            [self heroGetsHit];\n            [bulletsToDelete addObject:aBullet];\n            [aBullet removeFromParentAndCleanup:YES];\n            break;\n        }\n        // Iterate through enemies, see if they got hit\n        for (TDEnemy *anEnemy in enemyArray) {\n            if (CGRectIntersectsRect(aBullet.boundingBox,\n                                anEnemy.sprite.boundingBox)\n                            && aBullet.isEnemy == NO) {\n                //Enemy got hit\n                [self enemyGetsHit:anEnemy];\n                [bulletsToDelete addObject:aBullet];\n                [aBullet removeFromParentAndCleanup:YES];\n                break;\n            }\n        }\n    }\n    // Remove the bullets\n    for (int i = 0; i < [bulletsToDelete count]; i++) {\n        [bulletArray removeObjectsInArray:bulletsToDelete];\n    }\n\n    [bulletsToDelete release];\n} \n```", "```swift\n    [self checkCollisions];\n```", "```swift\n-(void) heroGetsHit {\n    // Decrease the hero's health\n    heroHealth = heroHealth - 20;\n    [hudLayer changeHealthTo:heroHealth];\n\n    // Play the effect\n    [[SimpleAudioEngine sharedEngine] playEffect:SND_HERO];\n\n    if (heroHealth <= 0) {\n        // Hero died.\n        isGameOver = YES;\n        preventTouches = YES;\n    }\n}\n```", "```swift\n-(void) enemyGetsHit:(TDEnemy*) thisEnemy {\n    // Get rid of the enemy\n    [thisEnemy.sprite removeFromParentAndCleanup:YES];\n    [enemyArray removeObject:thisEnemy];\n\n    // Score the kill\n    heroKills++;\n    [hudLayer changeKillsTo:heroKills];\n\n    // Play the effect\n    [[SimpleAudioEngine sharedEngine] playEffect:SND_ENEMY];\n\n    // Spawn a new enemy to replace this one\n    [self addEnemyOfType:kEnemyEasy];\n}\n```", "```swift\n-(void) gameOver {\n    [self unscheduleUpdate];\n\n    NSString *msg = @\"You win!\";\n\n    if (heroHealth <= 0) {\n        msg = @\"You died.\";\n    }\n\n    [hudLayer showGameOver:msg];\n\n    CCDelayTime *delay = [CCDelayTime actionWithDuration:3.0];\n    CCCallBlock *allowExit = [CCCallBlock actionWithBlock:^{\n        preventTouches = NO;\n    }];\n\n    [self runAction:[CCSequence actions: delay, allowExit,\n                     nil]];\n}\n```", "```swift\n-(void) showGameOver:(NSString*)msg {\n\n    CGSize size = [[CCDirector sharedDirector] winSize];\n\n    CCLabelTTF *gameOver = [CCLabelTTF labelWithString:msg\n                     fontName:@\"Verdana\" fontSize:30];\n    [gameOver setColor:ccRED];\n    [gameOver setPosition:ccp(size.width/2,\n                            size.height/2)];\n    [self addChild:gameOver z:50];\n}\n```"]