<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Designing and Implementing the Messenger Backend with Spring Boot 2.0</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing and Implementing the Messenger Backend with Spring Boot 2.0</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In the last couple of chapters, we gained a firm grasp of the fundamentals of the Kotlin programming language by implementing the classic game, <em>Tetris</em>. In <a href="kt-prog-ex_ch03.html">Chapter 3</a>,&#160;<em>Implementing Tetris Logic and Functionality</em>, we finished the development of the game by implementing its application logic. We created programmatic models for blocks, shapes, frames, and the application as a whole, via an app model class. In addition, we learned how to create custom views by implementing Tetris view—a view that the user of the application interacted with to play the game.</span></p>
<p class="p1"><span class="s1">We will hone our Kotlin development skills further by developing a simple messenger application for the Android platform. In the process of implementing the Android application, we will first develop a RESTful API that will provide web content to the application behind the scenes. The application programming interface will be built with Spring Boot 2.0. After developing the application programming interface, we will deploy it to a remote server. Over the course of this chapter, you will learn about the following topics:</span></p>
<ul>
<li class="li1"><span class="s1">Basic system design</span></li>
<li class="li1"><span class="s1">Modeling system behavior with state diagrams</span></li>
<li class="li1"><span class="s1">Database design fundamentals</span></li>
<li class="li1"><span class="s1">Modeling a database with entity relationship (E-R) diagrams</span></li>
</ul>
<ul>
<li class="li1"><span class="s1">Building backend microservices with Spring Boot 2.0</span></li>
<li class="li1"><span class="s1">Working with PostgreSQL</span></li>
<li class="li1"><span class="s1">Dependency management with Maven</span></li>
<li class="li1"><span class="s1">Amazon Web Services (AWS)</span></li>
</ul>
<p class="p1"><span class="s1">Without further ado, let's dive into this chapter by designing the messenger application programming interface.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing the messenger API</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">To design a fully functional RESTful application programming interface for our messenger android application, we must fully understand the concept of application programming interfaces, <strong>Representational State Transfer</strong> (<strong>REST</strong>) and RESTful services.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application programming interfaces</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">An application programming interface is a collection of functions, routines, procedures, protocols, and resources that can be used for building software. In other words, an application programming interface—API for short—is a collection of well-defined and appropriately structured methods or channels of communication between software components.</span></p>
<p class="p1"><span class="s1">Application programming interfaces can be developed for use with various application domains. Some common application domains that APIs are developed for include the development of web-based systems, operating systems, and computer hardware, as well as interaction with embedded systems.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">REST</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Restful state transfer is a way of facilitating functional operation and interactions between two or more distinct systems (or subsystems) via the internet. Web services that adhere to REST allow interacting systems to access web content; they also perform authorized operations on web content that they have access to. These inter-system communications are done using a well-defined set of stateless operations. A RESTful web service adheres to REST and provides web content to communicating systems via predetermined stateless operations.</span></p>
<p class="p1"><span class="s1">In the present day, numerous systems that communicate with web services utilize REST. Systems that may utilize REST are based on the client-server architecture. The API we will be developing is based on REST, and, as such, will make use of representational state transfer.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Designing the messenger API system</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In this section, we will attempt to concisely design the messenger API system. You may be wondering at this point what exactly system design is and what it entails. Fear not, we will explain these in the next few paragraphs.</span></p>
<p class="p1"><span class="s1">System design is the process of defining the architecture, modules, interfaces, and data for a system to satisfy specified requirements that are from a pre-performed system analysis phase. System design consists of numerous processes and the utilization of different design orientations. In addition, the in-depth designing of systems requires the understanding of numerous topics, such as coupling and cohesion, which are far beyond the scope of this book. With this in mind, we shall attempt to give basic definitions of the interactions and data utilized in our system. We shall achieve this by designing the system incrementally.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Incremental development</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s2">Incremental development is an approach that can be used for the development of systems. Incremental development utilizes the incremental build model. The incremental build model is a method of developing software in which a product is designed, implemented, and tested incrementally. We will be developing the<span class="Apple-converted-space">&#160;</span> messenger API incrementally. We will in no way attempt to specify everything needed by the messenger API before we start coding. We will determine a set of specifications to get us going with the development and then create some functionality, after which we will repeat the process.</span></p>
<p class="p2"><span class="s2">To comfortably utilize the incremental development methodology, we must utilize software that does not penalize us for making changes over the development process, such as a case where we need to change the type of data catered for by the system. Spring Boot is a perfect candidate for developing systems incrementally as it enables quick and easy changes to systems.</span></p>
<p class="p2"><span class="s2">Up to this point, we have referred to Spring Boot a couple of times but have neither discussed what it is nor what it is used for. Let's use this opportunity to quickly do that.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Boot</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Spring Boot is a web application framework that was designed and developed for the purpose of the boot strapping and development of Spring applications. Spring is a web application framework that facilitates the development of web applications for the Java platform. Spring Boot makes creating industrial-strength production-grade spring-based applications easy.</span></p>
<p class="p1"><span class="s1">We will explore how to create web applications with Spring Boot over the course of this chapter, but now is not the time for that. Before we start developing the application, we must specify what the application actually does (we cannot build something when we don't know how it works, after all).</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">What the messenger system does</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Here, we will determine the initial requirements of the messenger system and what activities can occur within the system. We will identify high-level use cases of the messenger application.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Use cases</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">A use case is a statement about how an entity uses a system. Entity here refers to a type of user or a component interacting with the system. In use case definitions, entities can also be referred to as actors.</span></p>
<p class="p1"><span class="s1">We start off by identifying the actors in the messenger system. A glaringly obvious actor is the user of the application (the person that uses the application to satisfy their messaging needs). Another actor that ideally should be considered is the admin. For the purpose of this simple messenger application though, we will cater for the single user actor. The use cases of the user are as follows:</span></p>
<ul>
<li class="li1"><span class="s1">The user uses the messenger platform to send and receive messages</span></li>
<li class="li1"><span class="s1">The user uses the messenger platform to view other users on the messenger app</span></li>
<li class="li1"><span class="s1">The user uses the messenger platform to set and update his status</span></li>
<li>The user can sign up to the messenger platform</li>
<li>The user can log in to the messenger platform</li>
</ul>
<p class="p1"><span class="s1">The preceding use cases are enough to get us going. If, at any point during the course of system development, we come across a new use case, we can easily add that to the system. Now that we have identified the use cases of the system, we must properly describe the behavior of the system in catering for these use cases.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">System behavior</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">We define system behavior to have an accurate idea of what the system does, as well as to clearly describe the interactions between components of the system. As this is a very simple application, we can clearly describe application behavior with the aid of a diagram. We will make use of a state diagram to properly describe this behavior.</span></p>
<p class="p1"><strong><span class="s1">State diagrams</span></strong><span class="s1">:&#160;</span><span class="s1">A state diagram is used to describe the behavior of systems. A state diagram describes a system utilizing different possible states. In a state diagram, there exists a finite number of possible states that a system can be in.</span></p>
<p class="p1"><span class="s1">The following is the state diagram for our system, taking into consideration the defined use cases:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/0b6275fc-b0c1-466e-8aa3-c6bb22f78c6a.jpg" style="width:49.00em;height:39.75em;"/></div>
<p>Each circle in the preceding diagram represents a state of execution of the system at a point in time. Each arrow represents an action a user can request to be carried out by the system. Upon initial start, the API waits for requests from client applications.&#160; This behavior is shown in the <strong>Waiting for action</strong> state. When an action request is received by the API from the client application, the system goes out of the <strong>Waiting for action</strong> state and services the request sent with an appropriate process.&#160;</p>
<p>For example, when a user requests a status update from the Android application, the server leaves the <strong>Waiting for action</strong>&#160;state and executes the&#160; <strong>Attempt status update</strong>&#160;process, after which it goes back to the <strong>Waiting for action</strong>&#160;state.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Identifying data</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">It is important to have an idea of the type of data needed before implementing a system. We can easily identify this data from the use case definitions we gave earlier. From our use case specifications, we can determine that two basic types of data are required. These are the user data and the message data. As the names imply, the user data is the data required of every user, and message data is the data pertaining to a message sent. We are not concerned with things such as schemas, entities, or entity relationship diagrams yet. We just require an idea of the data to be required by the system.</span></p>
<p class="p1"><span class="s1">As this is a messenger app, the user we will require a username, phone number, password, and a status message. It will also be useful to keep track of the status of their account to know whether the account of a particular user is activated or has been deactivated for some reason. Not much is required as of now pertaining the messages sent. We need to keep track of the sender of a message and the intended recipient of the message.</span></p>
<p class="p1"><span class="s1">That is all for now with respect to the data needed. We will identify more data required as the development of the application progresses, but, for now, let's code.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing the messenger backend</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">Now that we have some sense of direction pertaining to the use cases of the messenger system as a whole, the data required within the system, and the behavior of the system, we can get started with developing the backend of the system. As we have said earlier, we will be utilizing Spring Boot to develop the messenger API because it is a perfect candidate for incremental development. In addition to this, Kotlin and Spring Boot function very well together.</span></p>
<p class="p2"><span class="s1">As we will be handling data within the messenger API, we will need a suitable database to store the data needed by the messenger system. We will making use of PostgreSQL as our database. Let’s take a brief look at PostgreSQL.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">PostgreSQL&#160;</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">PostgreSQL is an object-relational database management system that puts particular emphasis on extensibility and standards compliance. PostgreSQL is known as Postgres. It is commonly utilized as a database server. When utilized in this way, its primary functions are to securely store data and return the data stored upon request by software applications.</span></p>
<p class="p2"><span class="s1">There are numerous advantages to using PostgreSQL as a datastore. Some of these advantages are:</span></p>
<ul>
<li class="li2"><span class="s1"><strong>Extensibility</strong>: The features of PostgreSQL can be easily and readily extended by its users. This is because its source code is available to all for free.</span></li>
<li class="li2"><span class="s1"><strong>Portability</strong>: PostgreSQL is available for all major platforms. Versions of PostgreSQL are available for almost every UNIX brand. Windows compatibility is also made possible via they Cygwin framework.</span></li>
<li class="li2"><span class="s1"><strong>Integrity</strong>: Ready availability of GUI-based tools that facilitate easy interactions with PostgreSQL.</span></li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Installing PostgreSQL</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">The installation of PostgreSQL is straightforward on all platforms. This section highlights its installation process on Windows, macOS, and Linux.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Windows installation</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">To install PostgreSQL&#160;on Windows, perform the following steps:</span></p>
<ol class="ol1">
<li class="li2"><span class="s1">Download and run an appropriate version of the Windows PostgreSQL interactive installer. This can be downloaded from <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows"><span class="s4">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads#windows</span></a><span class="s4">.</span></span></li>
<li class="li2"><span class="s1">Install PostgreSQL as a Windows service. Make sure you take note of the PostgreSQL Windows service account name and password. You will need these details later in the installation process.</span></li>
</ol>
<ol class="ol1" start="3">
<li class="li2"><span class="s1">Select the <span class="packt_screen">PL/pgsql</span> procedural language to be installed when prompted by the installer to do so.</span></li>
<li class="li2"><span class="s1">You may choose to install <span class="packt_screen">pgAdmin</span> when directed to the <span class="packt_screen">Installation options</span> screen. If you install <span class="packt_screen">pgAdmin</span>, enable the <span class="packt_screen">Adminpack</span> contrib module when prompted by the installer.</span></li>
</ol>
<p class="p2"><span class="s1">If you follow the previous steps properly, PostgreSQL will be successfully installed on your system.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">macOS installation</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">PostgreSQL can be easily installed on macOS with Homebrew. If you do not already have Homebrew installed on your system, consult <a href="kt-prog-ex_ch01.html">Chapter 1</a>,&#160;<em>The Fundamentals</em> for its installation instructions. Once you have determined that Homebrew is installed on your system, open your terminal and run the following command:</span></p>
<pre class="p7"><strong><span class="s5">brew search postgres</span></strong></pre>
<p class="p2"><span class="s1">Follow the installation instructions when prompted in the Terminal. Along the course of the installation, you may be asked for the admin password of your system. Input the password and wait for the installation to finish. You will be prompted once the installation is complete.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Linux installation</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">PostgreSQL can easily be installed on Linux with the use of the PostgreSQL Linux installer:</span></p>
<ol class="ol1">
<li class="li2"><span class="s1">Go to the PostgreSQL installer download web page at&#160;<a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads"><span class="s4">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</span></a>.</span></li>
<li class="li2"><span class="s1">Select the PostgreSQL version you want to install.</span></li>
<li class="li2"><span class="s1">Select an appropriate Linux installer for PostgreSQL.</span></li>
<li class="li2"><span class="s1">Click the download button to download the installer.</span></li>
<li class="li2"><span class="s1">Run the installer once it has been downloaded and follow all installation instructions appropriately.</span></li>
<li class="li2"><span class="s1">Once you have provided the information needed by the installer, PostgreSQL will be installed on your system.</span></li>
</ol>
<p>Now that we have set up PostgreSQL on our system, we can commence with the creation of the messenger API.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a new Spring Boot application</h1>
                </header>
            
            <article>
                
<p class="p2"><span class="s1">The initial creation on a Spring Boot application is easy with the utilization of IntelliJ IDE and the Spring initializer. Open IntelliJ IDE and create a new project with the Spring Initializer. This can be done by clicking on <span class="packt_screen">Create New Project</span> and selecting <span class="packt_screen">Spring Initializer</span>&#160;on the left side bar of the <span class="packt_screen">New Project</span>&#160;screen:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/cfcdb014-9701-4b9c-8fa1-4c318745d573.jpg" style="width:53.33em;height:40.00em;"/></div>
<p class="p1"><span class="s1">After selecting the Spring Initializer, progress to the next screen by clicking the <span class="packt_screen">Next</span>&#160;button. Upon clicking next, before the next screen is displayed, Spring Initializer will be retrieved by the IDE. This will only take a few moments to do.</span></p>
<div class="packt_infobox"><span>The Spring plugin is only available in the Ultimate edition of IntelliJ IDEA, which comes with a paid subscription.</span></div>
<p class="p1"><span class="s1">Once the Spring Initializer is retrieved, you will be asked to provide the appropriate details for the project to be created. Fill in the necessary details. You may choose to use the details used for the development of the application in this book or decide to input your own. However, in the instance that you want to use our details, do the following:</span></p>
<ol class="ol1">
<li class="li1"><span class="s1">Input <kbd>com.example</kbd>&#160;as the group ID.</span></li>
<li class="li1"><span class="s1">Enter <kbd>messenger-api</kbd> as the artifact ID.</span></li>
<li class="li1"><span class="s1">Select <span class="packt_screen">Maven Project</span>&#160;as the project type if it is not already selected.</span></li>
<li class="li1"><span class="s1">Leave the packaging option and the Java version the way they are.</span></li>
<li class="li1"><span class="s1">Select <span class="packt_screen">Kotlin</span> as the language. This is important, as we are learning the Kotlin language, after all.</span></li>
<li class="li1"><span class="s1">Leave the <span class="packt_screen">SNAPSHOT</span> value as it is.</span></li>
<li class="li1"><span class="s1">Enter a description of your choice.</span></li>
<li class="li1"><span class="s1">Input <kbd>com.example.messenger.api</kbd>&#160;as the package name.</span></li>
</ol>
<p class="p1"><span class="s1">After filling in the required project information, proceed to the next screen by clicking <span class="packt_screen">Next</span>:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/64b45967-3681-4f5f-a436-03c427b640d8.jpg" style="width:57.67em;height:42.67em;"/></div>
<p class="p1"><span class="s1">In the next screen, you will be asked to select the project dependencies. For starters, we will need to select the Security, Web, JPA, and PostgreSQL dependencies. <span class="packt_screen">Security</span> can be found under the <span class="packt_screen">Core</span>&#160;category, <span class="packt_screen">Web</span> can be found under the <span class="packt_screen">Web</span>&#160;category, and <span class="packt_screen">JPA</span> and <span class="packt_screen">PostgreSQL</span> can be found under the <span class="packt_screen">SQL</span>&#160;category. In addition, in the <span class="packt_screen">Spring Boot Version</span> selection drop-down menu at the top of the screen, select <span class="packt_screen">2.0.0 M5</span> as the version.</span></p>
<p class="p1"><span class="s1">After the selection of the necessary dependencies, the content should look similar to the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/702ff1e7-f2a8-428a-8d53-b9176ee7ffbc.jpg" style="width:57.08em;height:41.67em;"/></div>
<div>
<p class="p1"><span class="s1">After selecting the appropriate dependencies, click <span class="packt_screen">Next</span>&#160;to continue to the final setup screen. You will be asked to provide a project name and a project location. Fill in <kbd>messenger-api</kbd><span class="Apple-converted-space">&#160;</span>as the project name and select the location where want the project to be saved on your computer. Select <span class="packt_screen">Finish</span>&#160;and wait for the project to be set up. You will be taken to a new IDE window containing the initial project files.</span></p>
</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting familiar with Spring Boot</h1>
                </header>
            
            <article>
                
<div>
<p class="p1"><span>Let's take a look at the structure of the initial program files for this Spring Boot application. The following is the screenshot of the structure of your Spring Boot application files:</span></p>
</div>
<div class="CDPAlignCenter CDPAlign"><img src="images/8f299d4c-2156-4a9f-bf11-cfc1a514fe12.jpg" style="width:20.17em;height:22.67em;"/></div>
<p class="p1"><span class="s1">All source files are contained in the <kbd>src</kbd>&#160;directory. This directory contains the core application program files as well as the test programs that are written for the application. Core application program files should be put in the <kbd>src/main</kbd> directory and test programs are located in <kbd>src/test</kbd>. The main directory contains two subdirectories. These are the <kbd>kotlin</kbd>&#160;directory and the <kbd>resources</kbd>&#160;directory. All packages and main source files will be placed in this directory over the course of this chapter. More specifically, our program files and packages will be placed within the <kbd>com.example.messenger.api</kbd> package. Let's have a quick look at the <kbd>MessengerApiAplication.kt</kbd> file:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/51ef928f-315b-420f-a251-8046c82bf1de.jpg" style="width:59.75em;height:19.67em;"/></div>
<p class="p1"><span class="s1">The <kbd>MessengerApplication.kt</kbd><span>&#160;file&#160;</span>contains the main function. This is the entry point of every Spring Boot application. This function is called when the application starts. Once it is called, the function runs the Spring application by calling the&#160;<kbd>SpringApplication.run()</kbd><span>&#160;</span>function. This function takes two arguments. The first argument is a class reference and the second is the arguments to be passed to the application upon start.</span></p>
<p class="p1"><span class="s1">In the same file, there's a<span>&#160;</span><kbd>MessengerApiApplication</kbd><span>&#160;</span>class. This class is annotated with the<span>&#160;</span><kbd>@SpringBootApplication</kbd><span>&#160;</span>annotation. The use of this annotation is equivalent to the combined use of the<span>&#160;</span><kbd>@Configuration</kbd>,<span>&#160;</span><kbd>@EnableAutoConfiguration</kbd><span>,&#160;</span>and<span>&#160;</span><kbd>@ComponentScan</kbd><span>&#160;</span>annotations. Classes annotated with<span>&#160;</span><kbd>@Configuration</kbd><span>&#160;</span>are sources of bean definitions.</span></p>
<div class="p1 packt_infobox"><span class="s1">A bean is an object that is instantiated and assembled by a Spring IoC container.</span></div>
<p class="p1"><span class="s1">The <kbd>@EnableAutoConfiguration</kbd><span>&#160;attribute&#160;</span>tells the Spring Boot that you want your Spring application to be automatically configured based on the jar dependencies that you have provided. The<span>&#160;</span><kbd>@ComponentScan</kbd><span>&#160;</span>annotation configures component scanning directories for use with the<span>&#160;</span><kbd>@Configuration</kbd><span>&#160;</span>classes.</span></p>
<p class="p1"><span class="s1">Over the course of developing Spring Boot applications, it will be necessary to use several annotations for varying reasons. Using these annotations may be overwhelming at first, but with time they will become second nature.</span></p>
<p class="p1"><span class="s1">Besides<span>&#160;</span><kbd>MessengerApplication.kt</kbd>, another important file is the <kbd>application.properties</kbd>&#160;file, located in<span>&#160;</span><kbd>src/main/resources</kbd>. This file is used for configuring Spring Boot applications properties. Upon opening this file, you will discover that it has no content. This is because we have not yet defined any application configurations or properties. Let's go ahead and add a couple of configurations. Input the following into the <kbd>application.properties</kbd> file:</span></p>
<pre class="p1"><span class="s1">spring.jpa.generate-ddl=true<br/></span><span class="s1">spring.jpa.hibernate.ddl-auto=create-drop</span></pre>
<p class="p1"><span class="s1">The<span>&#160;</span><kbd>spring.jpa.generate-ddl</kbd>&#160;property specifies whether the database schema should be generated upon startup of the application. When this property is set to <kbd>true</kbd>, the schema is generated on application startup, otherwise the schema is not generated.&#160;</span><span class="s1">The<span>&#160;</span><kbd>spring.jpa.hibernate.ddl-auto</kbd><span>&#160;property&#160;</span>is used to specify the DDL mode. We use <kbd>create-drop</kbd>&#160;because we want the schema to be created upon application startup and destroyed upon the termination of the application.</span></p>
<p class="p1"><span class="s1">We have utilized properties to define the schema of our database but have yet to create an actual database for the <kbd>messenger-api</kbd>. If you installed pgAdmin along with PostgreSQL, you can easily create a database with the software. If you didn't install pgAdmin, fear not, we can still easily create a database for our application by using PostgreSQL's <kbd>createdb</kbd>&#160;command. Navigate to your terminal and enter the following command:</span></p>
<pre class="p1"><strong><span class="s1">createdb -h localhost --username=&lt;username&gt; --password messenger-api</span></strong></pre>
<p class="p1"><span class="s1">The <kbd>-h</kbd> flag is used to specify the host name of the machine on which the database server is running. The <kbd>--username</kbd>&#160;flag specifies the username to connect to the server with. The <kbd>--password</kbd>&#160;flag forces a prompt for the specification of a password. The <kbd>messenger-api</kbd>&#160;is the name we are giving to the database being created. Substitute <kbd>&lt;username&gt;</kbd>&#160;with your server username. After you've input the command, click the enter key to run the command. Input a desired password when prompted to do so. A database named <kbd>messenger-api</kbd> will be created in PostgreSQL.</span></p>
<p class="p1"><span class="s1">Now that we have out database set up, we need to connect the Spring Boot application to the database. We can do this with the use of the <kbd>spring.datasource.url</kbd>, <kbd>spring.datasource.username</kbd>, and <kbd>spring.datasource.password</kbd> properties. Add the following configurations to the<span>&#160;</span><kbd>application.properties</kbd><span>&#160;file</span>:</span></p>
<pre class="p1"><span class="s1">spring.jpa.generate-ddl=true<br/></span><span class="s1">spring.jpa.hibernate.ddl-auto=create-drop<br/></span><span class="s1">spring.datasource.url=jdbc:postgresql://localhost:5432/messenger-api<br/></span><span class="s1">spring.datasource.username=&lt;username&gt;<br/></span><span class="s1">spring.datasource.password=&lt;password&gt;</span></pre>
<p class="p1"><span class="s1">The <kbd>spring.datasource.url</kbd>&#160;property specifies the JDBC URL via which Spring Boot will connect to the database. The&#160;<span>&#160;</span><kbd>spring.datasource.username</kbd><span>&#160;</span>and<span>&#160;</span><kbd>spring.datasource.password</kbd><span>&#160;are the properties&#160;</span>used to specify the server username and the password correlating with the specified username. Replace <kbd>&lt;username&gt;</kbd> and <kbd>&lt;password&gt;</kbd> with your username and password.</span></p>
<p class="p1"><span class="s1">Once you have these properties set up, you are ready to start the Spring Boot application.&#160;</span></p>
<p class="p1"><span class="s1">Once you have these properties set up, you are ready to start the Spring Boot application. You can run the <kbd>messenger-api</kbd> application by clicking on the Kotlin logo next to the main function in <kbd>MessengerApiApplication.kt</kbd> and selecting the <span class="packt_screen">Run</span>&#160;option, as shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/bb7fda59-faa5-44b7-9925-888a83b16608.jpg" style="width:49.00em;height:20.17em;"/></div>
<p class="p1"><span class="s1">Wait for a moment for the project to build. Once the project build process is complete, the application will be started on a Tomcat server.</span></p>
<p class="p1"><span class="s1">Let's continue exploring our project files. Locate a <kbd>pom.xml</kbd>&#160;file in the root directory of the project. <strong>POM</strong> stands for <strong>Project Object Model</strong>. On the Apache Maven site, the following is said about the POM: <em>A Project Object Model or POM is the fundamental unit of work in Maven.</em> It is an XML file that contains information about the project and configuration details used by Maven to build the project. Once you have located this file, open it. Straightforward, right? That’s all fine and dandy, but, for the sake of clarity, here's a brief description of Maven.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Maven</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Apache Maven is a software project management and comprehension tool that is based on the concept of the POM. Maven can be used for several purposes, such as project build management and documentation.</span></p>
<p class="p1"><span class="s1">Having understood the project files to an extent, we will continue development by implementing some models to cater to the data we identified earlier.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating models</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Here, we are going to model the data we have identified into suitable entity classes&#160;that can be introspected by Spring Boot to build a suitable database schema. The first model we will concern ourselves with is the user model. Create a package named <kbd>models</kbd>&#160;under the <kbd>com.example.messenger.api</kbd> package. Create a <kbd>User.kt</kbd> file within the package and input the following code:</span></p>
<pre><span>package </span>com.example.messenger.api.models<br/><br/><span>import </span>org.hibernate.validator.constraints.<span>Length<br/></span><span>import </span>org.springframework.format.annotation.<span>DateTimeFormat<br/></span><span>import </span>java.time.Instant<br/><span>import </span>java.util.*<br/><span>import </span>javax.persistence.*<br/><span>import </span>javax.validation.constraints.<span>Pattern<br/></span><span>import </span>javax.validation.constraints.<span>Size<br/></span><span><br/>@Entity<br/></span><span>@Table</span>(<span>name = </span><span>"`user`"</span>)<br/><span>@EntityListeners</span>(UserListener::<span>class</span>)<br/><span>class </span>User(<br/>  <span>@Column</span>(<span>unique = </span><span>true</span>)<br/>  <span>@Size</span>(<span>min = </span><span>2</span>)<br/>  <span>var </span><span>username</span>: String = ""<span>,<br/></span><span>  @Size</span>(<span>min = </span><span>11</span>)<br/>  <span>@Pattern</span>(<span>regexp=</span><span>"^</span><span>\\</span><span>(?(</span><span>\\</span><span>d{3})</span><span>\\</span><span>)?[- ]?(</span><span>\\</span><span>d{3})[- ]?(</span><span>\\</span><span>d{4})$"</span>)<br/>  <span>var </span><span>phoneNumber</span>: String = ""<span>,<br/></span><span>  @Size</span>(<span>min = </span><span>60</span><span>, </span><span>max = </span><span>60</span>)<br/>  <span>var </span><span>password</span>: String = ""<span>,<br/></span><span>  var </span><span>status</span>: String = <span>""</span><span>,<br/></span><span>  @Pattern</span>(<span>regexp = </span><span>"</span><span>\\</span><span>A(activated|deactivated)</span><span>\\</span><span>z"</span>)<br/>  <span>var </span><span>accountStatus</span>: String = <span>"activated"</span><br/>)</pre>
<p>We made use of a lot of annotations in the preceding code block. We will take a look at what each of them does in the order in which they appear. First up, we have the <kbd>@Entity</kbd> annotation, which indicates that the class is a <strong>Java Persistence API</strong> (<strong>JPA</strong>)&#160;entity. The use of the <kbd>@Table</kbd> annotation specifies a table name for the entity being represented by the class. This is useful during schema generation. In the case that an <kbd>@Table</kbd> annotation is not used, the name of the table generated will be the class name. A database table will be created in PostgreSQL with the name <kbd>user</kbd>.&#160; <kbd>@EntityListener</kbd>, as the name implies, specifies an entity listener for the entity class. We have not yet created a <kbd>UserListener</kbd> class, but don't worry, we will do that in a little bit.</p>
<p>Now let's take a look at the properties of the <kbd>User</kbd> class. We added seven class properties in total. The first five are <kbd>username</kbd>, <kbd>password</kbd>, <kbd>phoneNumber</kbd>, <kbd>accountStatus</kbd>, and&#160;<kbd>status</kbd>;&#160;<span>each property represents a type of data we need for a user, as we earlier identified in the <em>Identifying data</em>&#160;section of this chapter.&#160;</span>We have now created our user entity and are ready to proceed. But wait, there's a problem. We need a way to uniquely identify each user that is created. In addition, it is important for future reference to keep track of when new users are added to the messenger platform. After careful consideration, we realize that it is important to have&#160;<kbd>id</kbd> and <kbd>createdAt</kbd> properties in our entity. You may be wondering—why are we adding <kbd>id</kbd> and <kbd>createdAt</kbd> properties to the user entity? After all, we did not specify we needed them earlier on. This is true. But, as we are developing this backend incrementally, we are allowed to make changes and additions when the need arises. Let's go ahead and add these two properties:</p>
<pre><span>@Entity<br/></span><span>@Table</span>(<span>name = </span><span>"`user`"</span>)<br/><span>@EntityListeners</span>(UserListener::<span>class</span>)<br/><span>class </span>User(<br/>  <span>@Column</span>(<span>unique = </span><span>true</span>)<br/>  <span>@Size</span>(<span>min = </span><span>2</span>)<br/>  <span>var </span><span>username</span>: String = ""<span>,<br/></span><span>  @Size</span>(<span>min = </span><span>8</span><span>, </span><span>max = </span><span>15</span>)<br/>  <span>@Column</span>(<span>unique = </span><span>true</span>)<br/>  <span>@Pattern</span>(<span>regexp = </span><span>"^</span><span>\\</span><span>(?(</span><span>\\</span><span>d{3})</span><span>\\</span><span>)?[- ]?(</span><span>\\</span><span>d{3})[- ]?(</span><span>\\</span><span>d{4})$"</span>)<br/>  <span>var </span><span>phoneNumber</span>: String = ""<span>,<br/></span><span>  @Size</span>(<span>min = </span><span>60</span><span>, </span><span>max = </span><span>60</span>)<br/>  <span>var </span><span>password</span>: String = ""<span>,<br/></span><span>  var </span><span>status</span>: String = <span>"available"</span><span>,<br/></span><span>  @Pattern</span>(<span>regexp = </span><span>"</span><span>\\</span><span>A(activated|deactivated)</span><span>\\</span><span>z"</span>)<br/>  <span>var </span><span>accountStatus</span>: String = <span>"activated"</span><span>,<br/></span><span>  @Id<br/></span><span>  @GeneratedValue</span>(<span>strategy = </span>GenerationType.<span>AUTO</span>)<br/>  <span>var </span><span>id</span>: Long = <span>0</span><span>,<br/></span><span>  @DateTimeFormat<br/></span><span>  var </span><span>createdAt</span>: Date = Date.from(Instant.now())<br/>)</pre>
<p>Perfect. Now we need to understand what each annotation does. <kbd>@Column</kbd> is used to specify a property representing a table column. In practice, all properties of entities represent a column in the table. We make use of <kbd>@Column(unique = true)</kbd>&#160;in our code specifically to place a uniqueness constraint on properties. This is useful when we do not want more than one record to have a particular attribute value. <kbd>@Size</kbd>, as you might have guessed, is used to specify the size of an attribute present in a table. <kbd>@Pattern</kbd> specifies a pattern that a table attribute must match for it to be valid.</p>
<p><kbd>@Id</kbd> specifies a property that uniquely identifies the entity (the <kbd>id</kbd> property, in this case). <kbd>@GeneratedValue(strategy = GenerationType.AUTO)</kbd>&#160;specifies that we want the <kbd>id</kbd> value to be generated automatically. <kbd>@DateTimeFormat</kbd>&#160; places a timestamp constraint on values to be stored in the <kbd>created_at</kbd> column of the user table.</p>
<p>It is time to create a <kbd>UserListener</kbd> class. Create a new package named <kbd>listeners</kbd>. Add the following <kbd>UserListener</kbd> class to the package:</p>
<pre><span>package </span>com.example.messenger.api.listeners<br/><br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder<br/><span>import </span>javax.persistence.<span>PrePersist<br/></span><span>import </span>javax.persistence.<span>PreUpdate<br/></span><span><br/></span><span>class </span>UserListener {<br/><br/>  <span>@PrePersist<br/></span><span>  @PreUpdate<br/></span><span>  fun </span><span>hashPassword</span>(user: User) {<br/>    user.<span>password </span>= BCryptPasswordEncoder().encode(user.<span>password</span>)<br/>  }<br/>}</pre>
<p>User passwords should never be saved as plain text in a database. For security reasons, they must always be appropriately hashed before being stored. The&#160;<kbd>hashPassword()</kbd>&#160;function performs this hashing procedure by replacing the string value held by the password property of a user object with its hashed equivalent using <kbd>BCrypt</kbd>. <kbd>@PrePersist</kbd> and <kbd>@PreUpdate</kbd>&#160;specifies that this function should be called before the persistence or update of a user record in the database.</p>
<p>Now let's create an entity for messages. Go ahead and add a <kbd>Message</kbd>&#160;class in the <kbd>models</kbd> package and add the following code to the class:</p>
<pre><span>package </span>com.example.messenger.api.models<br/><br/><span>import </span>org.springframework.format.annotation.<span>DateTimeFormat<br/></span><span>import </span>java.time.Instant<br/><span>import </span>java.util.*<br/><span>import </span>javax.persistence.*<br/><span><br/></span><span>@Entity<br/></span><span>class </span>Message(<br/>  <span>@ManyToOne</span>(<span>optional = </span><span>false</span>)<br/>  <span>@JoinColumn</span>(<span>name = </span><span>"user_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/>  <span>var </span><span>sender</span>: User? = <span>null,<br/></span><span>  @ManyToOne</span>(<span>optional = </span><span>false</span>)<br/>  <span>@JoinColumn</span>(<span>name = </span><span>"recipient_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/>  <span>var </span><span>recipient</span>: User? = <span>null,<br/></span><span>  var </span><span>body</span>: String? = <span>""</span><span>,<br/></span><span>  @ManyToOne</span>(<span>optional = </span><span>false</span>)<br/>  <span>@JoinColumn</span>(<span>name=</span><span>"conversation_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/>  <span>var </span><span>conversation</span>: Conversation? = <span>null,<br/></span><span>  @Id @GeneratedValue</span>(<span>strategy = </span>GenerationType.<span>AUTO</span>) <span>var </span><span>id</span>: Long = <span>0</span><span>,<br/></span><span>  @DateTimeFormat<br/></span><span>  var </span><span>createdAt</span>: Date = Date.from(Instant.now())<br/>)</pre>
<p>We made use of some familiar annotations as well as two new ones. As we discussed earlier, every message has a sender as well as a recipient. Both message senders and message recipients are users on the messenger platform, hence the message entity has both sender and recipient properties of the&#160;<kbd>User</kbd>&#160;type. A user can be a sender of many messages as well as a recipient of many messages. These are relationships that need to be implemented. We make use of the <kbd>@ManyToOne</kbd> annotation to do this. The many-to-one relationships are not optional, thus we use <kbd>@ManyToOne(optional = false)</kbd>.&#160; <kbd>@JoinColumn</kbd> s<span>pecifies a column for joining an entity association or element collection:</span></p>
<pre><span>@JoinColumn</span>(<span>name = </span><span>"user_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/><span>var </span><span>sender</span>: User? = <span>null</span></pre>
<p>The code snippet adds a <kbd>user_id</kbd> attribute that references the <kbd>id</kbd> of a user to the <kbd>message</kbd> table.&#160;</p>
<p>Upon close inspection, you will notice that a conversation property was used in the <kbd>Message</kbd> class. This is because messages sent between users happen in conversation threads. Simply put, every message belongs to a thread. We need to add a <kbd>Conversation</kbd> class to our <kbd>models</kbd> package,&#160;representing the conversation entity:</p>
<pre><span>package </span>com.example.messenger.api.models<br/><br/><span>import </span>org.springframework.format.annotation.<span>DateTimeFormat<br/></span><span>import </span>java.time.Instant<br/><span>import </span>java.util.*<br/><span>import </span>javax.persistence.*<br/><span><br/></span><span>@Entity<br/></span><span>class </span>Conversation(<br/>  <span>@ManyToOne</span>(<span>optional = </span><span>false</span>)<br/>  <span>@JoinColumn</span>(<span>name = </span><span>"sender_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/>  <span>var </span><span>sender</span>: User? = <span>null,<br/></span><span>  @ManyToOne</span>(<span>optional = </span><span>false</span>)<br/>  <span>@JoinColumn</span>(<span>name = </span><span>"recipient_id"</span><span>, </span><span>referencedColumnName = </span><span>"id"</span>)<br/>  <span>var </span><span>recipient</span>: User? = <span>null,<br/></span><span>  @Id<br/></span><span>  @GeneratedValue</span>(<span>strategy = </span>GenerationType.<span>AUTO</span>)<br/>  <span>var </span><span>id</span>: Long = <span>0</span><span>,<br/></span><span>  @DateTimeFormat<br/></span><span>  val </span><span>createdAt</span>: Date = Date.from(Instant.now())<br/>) {<br/><br/>  <span>@OneToMany</span>(<span>mappedBy = </span><span>"conversation"</span><span>, </span><span>targetEntity = </span>Message::<span>class</span>)<br/>  <span>private var </span><span>messages</span>: Collection&lt;Message&gt;? = <span>null<br/></span>}</pre>
<p>Numerous messages belong to a conversation, so we have a <kbd>messages</kbd>&#160; collection in the body of the <kbd>Conversation</kbd> class.</p>
<p>We are almost done with the creation of entity models. The only thing left to do is to add appropriate collections for&#160; a user's sent and received messages:&#160;</p>
<pre><span>package </span>com.example.messenger.api.models<br/><br/><span>import </span>com.example.messenger.api.listeners.UserListener<br/><span>import </span>org.springframework.format.annotation.<span>DateTimeFormat<br/></span><span>import </span>java.time.Instant<br/><span>import </span>java.util.*<br/><span>import </span>javax.persistence.*<br/><span>import </span>javax.validation.constraints.<span>Pattern<br/></span><span>import </span>javax.validation.constraints.<span>Size<br/></span><span><br/></span><span>@Entity<br/></span><span>@Table</span>(<span>name = </span><span>"`user`"</span>)<br/><span>@EntityListeners</span>(UserListener::<span>class</span>)<br/><span>class </span>User(<br/>  <span>@Column</span>(<span>unique = </span><span>true</span>)<br/>  <span>@Size</span>(<span>min = </span><span>2</span>)<br/>  <span>var </span><span>username</span>: String = <span>""</span><span>,<br/></span><span>  @Size</span>(<span>min = </span><span>8</span><span>, </span><span>max = </span><span>15</span>)<br/>  <span>@Column</span>(<span>unique = </span><span>true</span>)<br/>  <span>@Pattern</span>(<span>regexp = </span><span>"^</span><span>\\</span><span>(?(</span><span>\\</span><span>d{3})</span><span>\\</span><span>)?[- ]?(</span><span>\\</span><span>d{3})[- ]?(</span><span>\\</span><span>d{4})$"</span>)<br/>  <span>var </span><span>phoneNumber</span>: String = <span>""</span><span>,<br/></span><span>  @Size</span>(<span>min = </span><span>60</span><span>, </span><span>max = </span><span>60</span>)<br/>  <span>var </span><span>password</span>: String = <span>""</span><span>,<br/></span><span>  var </span><span>status</span>: String = <span>"available"</span><span>,<br/></span><span>  @Pattern</span>(<span>regexp = </span><span>"</span><span>\\</span><span>A(activated|deactivated)</span><span>\\</span><span>z"</span>)<br/>  <span>var </span><span>accountStatus</span>: String = <span>"activated"</span><span>,<br/></span><span>  @Id<br/></span><span>  @GeneratedValue</span>(<span>strategy = </span>GenerationType.<span>AUTO</span>)<br/>  <span>var </span><span>id</span>: Long = <span>0</span><span>,<br/></span><span>  @DateTimeFormat<br/></span><span>  var </span><span>createdAt</span>: Date = Date.from(Instant.now())<br/>) {<br/>  //collection of sent messages<br/>  <span>@OneToMany</span>(<span>mappedBy = </span><span>"sender"</span><span>, </span><span>targetEntity = </span>Message::<span>class</span>)<br/>  <span>private var </span><span>sentMessages</span>: Collection&lt;Message&gt;? = <span>null<br/></span><span><br/>  //collection of received messages<br/></span><span>  @OneToMany</span>(<span>mappedBy = </span><span>"recipient"</span><span>, </span><span>targetEntity = </span>Message::<span>class</span>)<br/>  <span>private var </span><span>receivedMessages</span>: Collection&lt;Message&gt;? = <span>null</span><span><br/></span>}</pre>
<p>That's it! We are done creating entities. To help you to understand the entities we have made as well as their relationships, here's an entity relationship diagram (E-R diagram). It shows the entities that we have made and their relationships:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/cff0845e-3539-462d-843e-a32ceecb929c.jpg" style="width:26.50em;height:22.58em;"/></div>
<p>According to the E-R diagram, a user has many messages, a message belongs to a user, a message belongs to a conversation, and a conversation has many messages. In addition, a user has many conversations.</p>
<p>Having created the necessary models, there's only one problem. We have no way to access the data stored by these entities. We need to create repositories to do this.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating repositories</h1>
                </header>
            
            <article>
                
<p><span><strong>Spring Data JPA</strong> has is the ability to create repository implementations automatically, at runtime, from a repository interface. We will see how this works by creating a repository to access the&#160;<kbd>User</kbd> entities. Create a <kbd>repositories</kbd>&#160;package and include <kbd>UserRepository.kt</kbd> in it:</span></p>
<pre><span>package </span>com.example.messenger.api.repositories<br/><br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>org.springframework.data.repository.CrudRepository<br/><span><br/></span><span>interface </span>UserRepository : CrudRepository&lt;User<span>, </span>Long&gt; {<br/><br/>  <span>fun </span><span>findByUsername</span>(username: String): User?<br/><br/>  <span>fun </span><span>findByPhoneNumber</span>(phoneNumber: String): User?<br/>}</pre>
<p><kbd>UserRepository</kbd> extends the <kbd>CrudRepository</kbd> interface. The <kbd>entity</kbd> type and <kbd>id</kbd> type it works with are specified in the generic parameters of <kbd>CrudRepository</kbd><span>. By extending</span> <kbd>CrudRepository</kbd><span>,</span> <kbd>UserRepository</kbd> <span>inherits methods for working with</span> <kbd>User</kbd> <span>persistence, such as methods for saving, finding, and deleting</span> <kbd>User</kbd> <span>entities.</span></p>
<p>In addition, Spring JPA allows the declaration of other query functions by the use of method signatures. We exploited this capability to create <kbd>findByUsername()</kbd> and <kbd>findByPhoneNumber()</kbd> functions.</p>
<p>As we currently have three entities, we need to have three repositories to query them. Create a <kbd>MessageRepository</kbd> interface in <kbd>repositories</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.repositories<br/><br/><span>import </span>com.example.messenger.api.models.Message<br/><span>import </span>org.springframework.data.repository.CrudRepository<span><br/></span><span><br/></span><span>interface </span>MessageRepository : CrudRepository&lt;Message<span>, </span>Long&gt; {<br/>  <span>fun </span><span>findByConversationId</span>(conversationId: Long): List&lt;Message&gt;<br/>}</pre>
<p>Notice the preceding method signature specifies <kbd>List&lt;Message&gt;</kbd> as its return type. Spring JPA automatically recognizes this and returns a list of <kbd>Message</kbd>&#160;elements when <kbd>findByConversationId()</kbd> is called.</p>
<p>Lastly, implement a <kbd>ConversationRepository</kbd> interface:</p>
<pre><span>package </span>com.example.messenger.api.repositories<br/><br/><span>import </span>com.example.messenger.api.models.Conversation<br/><span>import </span>org.springframework.data.repository.CrudRepository<br/><span><br/>interface </span>ConversationRepository : CrudRepository&lt;Conversation<span>, </span>Long&gt; {<br/>    <span>fun </span><span>findBySenderId</span>(id: Long): List&lt;Conversation&gt;<br/><br/>    <span>fun </span><span>findByRecipientId</span>(id: Long): List&lt;Conversation&gt;<br/><br/>    <span>fun </span><span>findBySenderIdAndRecipientId</span>(senderId: Long<span>,<br/>        </span>recipientId: Long): Conversation?<br/>}</pre>
<p>As we now have our entities set and the necessary repositories to query these entities, we can start work on implementing the business logic of the messenger backend. This will require us to learn about services and service implementations.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Services and service implementations</h1>
                </header>
            
            <article>
                
<p>A service implementation is a spring bean that is annotated by <kbd>@Service</kbd>. Business logic for spring applications is most commonly put in a service implementation. A <em>service</em>, on the other hand, is an interface with function signatures for application behavior that must be implemented by implementing classes. A simple way to recall the differentiation between the two is to keep in mind that a service is an interface and a service implementation is a class that implements a service.</p>
<p>Now to create some services and service implementations. Create a <kbd>service</kbd> package. We will add both services and service implementations in here. Create a <kbd>UserService</kbd> interface as with the following codes within the package:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.models.User<br/><span><br/></span><span>interface </span>UserService {<br/>  <span>fun </span><span>attemptRegistration</span>(userDetails: User): User<br/><br/>  <span>fun </span><span>listUsers</span>(currentUser): List&lt;User&gt;<br/><br/>  <span>fun </span><span>retrieveUserData</span>(username: String): User?<br/><br/>  <span>fun </span><span>retrieveUserData</span>(id: Long): User?<br/><br/>  <span>fun </span><span>usernameExists</span>(username: String): Boolean<br/>}</pre>
<p>In the preceding&#160;<kbd>UserService</kbd> interface, we have defined functions that must be declared by classes that implement&#160;<kbd>UserService</kbd>. That's it! <kbd>UserService</kbd>&#160;is ready to be implemented. Now to create an implementation of the service. Add a <kbd>UserServiceImpl</kbd> class to the services package. We are going to implement <kbd>UserService</kbd> and as such we need overriding functions for <kbd>attemptRegistration()</kbd>, <kbd>listUsers()</kbd>, <kbd>retrieveUserData()</kbd>, and <kbd>usernameExists()</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.exceptions.InvalidUserIdException<br/><span>import </span>com.example.messenger.api.exceptions.<span>UserStatusEmptyException</span><br/><span>import </span>com.example.messenger.api.exceptions.UsernameUnavailableException<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span><br/></span><span><br/></span><span>@Service<br/></span><span>class </span>UserServiceImpl(<span>val </span><span>repository</span>: UserRepository) : UserService {<br/>  <span>@Throws</span>(UsernameUnavailableException::<span>class</span>)<br/>  <span>override fun </span><span>attemptRegistration</span>(userDetails: User): User {<br/>    <span>if </span>(!usernameExists(userDetails.<span>username</span>)) {<br/>      <span>val </span>user = User()<br/>      user.<span>username </span>= userDetails.<span>username<br/></span><span>      </span>user.<span>phoneNumber </span>= userDetails.<span>phoneNumber<br/></span><span>      </span>user.<span>password </span>= userDetails.<span>password<br/></span><span>      repository</span>.save(user)<br/>      obscurePassword(user)<br/>      <span>return </span>user<br/>    }<br/>    <span>throw </span>UsernameUnavailableException(<span>"The username <br/></span><span>                  ${</span>userDetails.<span>username</span><span>}</span><span> is unavailable."</span>)<br/>  }<br/><br/>  <span>@Throws</span>(<span>UserStatusEmptyException</span>::<span>class</span>)<br/>  <span>fun </span><span>updateUserStatus</span>(currentUser: User<span>, </span>updateDetails: User): User {<br/>    <span>if </span>(!updateDetails.<span>status</span>.<span>isEmpty</span>()) {<br/>      currentUser.<span>status </span>= updateDetails.<span>status<br/></span><span>      repository</span>.save(currentUser)<br/>      <span>return  </span>currentUser<br/>    }<br/>    <span>throw </span><span>UserStatusEmptyException</span>()<br/>  }<br/><br/>  <span>override fun </span><span>listUsers</span>(currentUser: User): List&lt;User&gt; {<br/>    <span>return </span><span>repository</span>.findAll().mapTo(ArrayList(), { it })<br/>                     .filter{ it != currentUser }<br/>  }<br/><br/>  <span>override fun </span><span>retrieveUserData</span>(username: String): User? {<br/>    <span>val </span>user = <span>repository</span>.findByUsername(username)<br/>    obscurePassword(user)<br/>    <span>return </span>user<br/>  }<br/><br/>  <span>@Throws</span>(InvalidUserIdException::<span>class</span>)<br/>  <span>override fun </span><span>retrieveUserData</span>(id: Long): User {<br/>    <span>val </span>userOptional = <span>repository</span>.findById(id)<br/>    <span>if </span>(userOptional.<span>isPresent</span>) {<br/>      <span>val </span>user = userOptional.get()<br/>      obscurePassword(user)<br/>      <span>return </span>user<br/>    }<br/>    <span>throw </span>InvalidUserIdException(<span>"A user with an id of '</span><span>$</span>id<span>' <br/>                                 does not exist."</span>)<br/>  }<br/><br/>  <span>override fun </span><span>usernameExists</span>(username: String): Boolean {<br/>    <span>return </span><span>repository</span>.findByUsername(username) != <span>null<br/></span><span>  </span>}<br/><br/>  <span>private fun </span><span>obscurePassword</span>(user: User?) {<br/>    user?.<span>password </span>= <span>"XXX XXXX XXX"<br/></span><span>  </span>}<br/>}</pre>
<p>In the primary constructor definition of <kbd>UserServiceImpl</kbd>, an instance of <kbd>UserRepository</kbd> was specified as a required argument. You don't need to worry about passing such an argument yourself. Spring recognizes that&#160;<kbd><span>UserServiceImpl</span></kbd>&#160;needs a <kbd>UserRepository</kbd> instance and provides the class with one via dependency injection. In addition to the functions implemented, we declared an&#160;<kbd>obscurePassword()</kbd> function that simply hashed passwords within a <kbd>User</kbd> entity with&#160;<span><kbd>XXX XXXX XXX</kbd>.<br/></span></p>
<p>Still in the spirit of service and service implementation creation, let's go ahead and add some for messages and conversations. Add a <kbd>MessageService</kbd> interface to the <kbd>service</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.models.Message<br/><span>import </span>com.example.messenger.api.models.User<br/><span><br/></span><span>interface </span>MessageService {<br/><br/>  <span>fun </span><span>sendMessage</span>(sender: User<span>, </span>recipientId: Long<span>, <br/></span>                  messageText: <span>String</span>): Message<br/>}</pre>
<p>We added a single method signature for <kbd>sendMessage()</kbd> that must be overriden by <kbd>MessageServiceImpl</kbd>. The following is the message service implementation:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.exceptions.MessageEmptyException<br/><span>import </span>com.example.messenger.api.exceptions.MessageRecipientInvalidException<br/><span>import </span>com.example.messenger.api.models.Conversation<br/><span>import </span>com.example.messenger.api.models.Message<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.ConversationRepository<br/><span>import </span>com.example.messenger.api.repositories.MessageRepository<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span><br/></span><span>@Service<br/></span><span>class </span>MessageServiceImpl(<span>val </span><span>repository</span>: MessageRepository<span>,<br/>             val </span><span>conversationRepository</span>: ConversationRepository<span>,<br/></span><span>             val </span><span>conversationService</span>: ConversationService<span>,<br/>             val </span><span>userRepository</span>: UserRepository) : MessageService {<br/><br/>  <span>@Throws</span>(MessageEmptyException::<span>class, <br/></span>          MessageRecipientInvalidException::<span>class</span>)<br/>  <span>override fun </span><span>sendMessage</span>(sender: User<span>, </span>recipientId: Long<span>, <br/></span>                           messageText: String): Message {<br/>    <span>val </span>optional = <span>userRepository</span>.findById(recipientId)<br/> <br/>      <span>if </span>(optional.<span>isPresent</span>) {<br/>        <span>val </span>recipient = optional.get()<br/><br/>        <span>if </span>(!messageText.<span>isEmpty</span>()) {<br/>          <span>val </span>conversation: Conversation = <span>if </span>(<span>conversationService<br/></span>                     .conversationExists(sender<span>, </span>recipient)) {<br/>            <span>conversationService</span>.getConversation(sender<span>, </span>recipient) <br/><span>                               as </span>Conversation<br/>          } <span>else </span>{<br/>            <span>conversationService</span>.createConversation(sender<span>, </span>recipient)<br/>          }<br/>          <span>conversationRepository</span>.save(conversation)<br/><br/>          <span>val </span>message = Message(sender<span>, </span>recipient<span>, </span>messageText<span>, <br/></span>                                conversation)<br/>          <span>repository</span>.save(message)<br/>          <span>return </span>message<br/>        }<br/>      } <span>else </span>{<br/>        <span>throw </span>MessageRecipientInvalidException(<span>"The recipient id <br/>                              '</span><span>$</span>recipientId<span>' is invalid."</span>)<br/>      }<br/>      <span>throw </span>MessageEmptyException()<br/>    }<br/>  }</pre>
<p>The preceding implementation of <kbd>sendMessage()</kbd> first checks whether the message content is empty. If not, then the function checks whether there exists an active conversation between the sender and the recipient. If there is one, it is retrieved and stored in <kbd>conversation</kbd>, otherwise a new <kbd>Conversation</kbd> is created between the two users and stored in <kbd>conversation</kbd>. The conversation is then saved and the message is created and saved.</p>
<p><kbd>ConversationService</kbd> and <kbd>ConversationServiceImpl</kbd> can now be implemented. Create a <kbd>ConversationService</kbd> interface in <kbd>services</kbd> and add the following code:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.models.Conversation<br/><span>import </span>com.example.messenger.api.models.User<br/><span><br/></span><span>interface </span>ConversationService {<br/><br/>  <span>fun </span><span>createConversation</span>(userA: User<span>, </span>userB: User): Conversation<br/>  <span>fun </span><span>conversationExists</span>(userA: User<span>, </span>userB: User): Boolean<br/>  <span>fun </span><span>getConversation</span>(userA: User<span>, </span>userB: User): Conversation?<br/>  <span>fun </span><span>retrieveThread</span>(conversationId: Long): Conversation<br/>  <span>fun </span><span>listUserConversations</span>(userId: Long): List&lt;Conversation&gt;<br/>  <span>fun </span><span>nameSecondParty</span>(conversation: Conversation<span>, </span>userId: Long): String<br/>}</pre>
<p>We have added six function signatures for now. They are <kbd>createConversation()</kbd>, <kbd>conversationExists()</kbd>, <kbd>getConversation()</kbd>&#160;,&#160;<kbd>retrieveThread()</kbd>, <kbd>listUserConversations()</kbd>, and <kbd>nameSecondParty()</kbd>. Now we shall add <kbd>ConversationServiceImpl</kbd> to <kbd>services</kbd>&#160;and implement the first three methods <kbd>createConversation()</kbd>, <kbd>conversationExists()</kbd> and <kbd>getConversation()</kbd>. This implementation is shown in the following code snippet:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.exceptions.ConversationIdInvalidException<br/><span>import </span>com.example.messenger.api.models.Conversation<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.ConversationRepository<br/><span>import </span>org.springframework.stereotype.<span>Service<br/></span><span><br/></span><span>@Service<br/></span><span>class </span>ConversationServiceImpl(<span>val </span><span>repository</span>: ConversationRepository) :<br/>      ConversationService {<br/><br/>  <span>override fun </span><span>createConversation</span>(userA: User<span>, </span>userB: User):<br/>               Conversation {<br/>    <span>val </span>conversation = Conversation(userA<span>, </span>userB)<br/>    <span>repository</span>.save(conversation)<br/>    <span>return  </span>conversation<br/>  }<br/><br/>  <span>override fun </span><span>conversationExists</span>(userA: User<span>, </span>userB: User): Boolean {<br/>    <span>return if </span>(<span>repository</span>.findBySenderIdAndRecipientId<br/>               (userA.<span>id</span><span>, </span>userB.<span>id</span>) != <span>null</span>)<br/>    <span>true<br/></span><span>    else </span><span>repository</span>.findBySenderIdAndRecipientId<br/>               (userB.<span>id</span><span>, </span>userA.<span>id</span>) != <span>null<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>getConversation</span>(userA: User<span>, </span>userB: User): Conversation? {<br/>    <span>return when </span>{<br/>      <span>repository</span>.findBySenderIdAndRecipientId(userA.<span>id</span><span>,<br/>                               </span>userB.<span>id</span>) != <span>null </span>-&gt;<br/>      <span>repository</span>.findBySenderIdAndRecipientId(userA.<span>id</span><span>, </span>userB.<span>id</span>)<br/>      <span>repository</span>.findBySenderIdAndRecipientId(userB.<span>id</span><span>, <br/></span>                               userA.<span>id</span>) != <span>null </span>-&gt;<br/>      <span>repository</span>.findBySenderIdAndRecipientId(userB.<span>id</span><span>, </span>userA.<span>id</span>)<br/>      <span>else </span>-&gt; <span>null<br/></span><span>    </span>}<br/><br/>  }<br/>}</pre>
<p>Having added the first three methods, go ahead and include the remaining three methods,<span>&#160;</span><kbd>retrieveThread()</kbd><span>,&#160;</span><kbd>listUserConversations()</kbd><span>, and&#160;</span><kbd>nameSecondParty()</kbd>, below to <kbd>ConversationServiceImpl</kbd>:</p>
<pre><span>override fun </span><span>retrieveThread</span>(conversationId: Long): Conversation {<br/>  <span>val </span>conversation = <span>repository</span>.findById(conversationId)<br/><br/>  <span>if </span>(conversation.<span>isPresent</span>) {<br/>    <span>return </span>conversation.get()<br/>  }<br/>  <span>throw </span>ConversationIdInvalidException(<span>"Invalid conversation id <br/>                                        '</span><span>$</span>conversationId<span>'"</span>)<br/>}<br/><br/><span>override fun </span><span>listUserConversations</span>(userId: Long): <br/>               ArrayList&lt;Conversation&gt; {<br/>  <span>val </span>conversationList: ArrayList&lt;Conversation&gt; = ArrayList()<br/>  conversationList.addAll(<span>repository</span>.findBySenderId(userId))<br/>  conversationList.addAll(<span>repository</span>.findByRecipientId(userId))<br/><br/>  <span>return </span>conversationList<br/>}<br/><br/><span>override fun </span><span>nameSecondParty</span>(conversation: Conversation<span>,<br/>                             </span>userId: Long): <span>String</span> {<br/>  <span>return if </span>(conversation.<span>sender</span>?.<span>id </span>== userId) {<br/>    conversation.<span>recipient</span>?.<span>username </span><span>as </span><span>String</span><br/>  } <span>else </span>{<br/>    conversation.<span>sender</span>?.<span>username </span><span>as </span><span>String</span><br/>  }<br/>}</pre>
<p>You might have noticed that we threw exceptions of different types several times within service implementation classes. As we have not yet created these exceptions, we will need to do so. In addition, we need to create an&#160;<kbd>ExceptionHandler</kbd>&#160;for each of these exceptions. These exception handlers will send appropriate error responses to clients in scenarios in which exceptions are thrown.</p>
<p>Create an <kbd>exceptions</kbd> package and add an <kbd>AppExceptions.kt</kbd> file to it. Include the following code into the file:</p>
<pre><span>package </span>com.example.messenger.api.exceptions<br/><span><br/></span><span>class </span>UsernameUnavailableException(<span>override val </span><span>message</span>: String) : RuntimeException()<br/><br/><span>class </span>InvalidUserIdException(<span>override val </span><span>message</span>: String) : RuntimeException()<br/><br/><span>class </span>MessageEmptyException(<span>override val </span><span>message</span>: String = <span>"A message cannot be empty."</span>) : RuntimeException()<br/><br/><span>class </span>MessageRecipientInvalidException(<span>override val </span><span>message</span>: String) : RuntimeException()<br/><br/><span>class </span>ConversationIdInvalidException(<span>override val </span><span>message</span>: String) : RuntimeException()<br/><br/><span>class </span>UserDeactivatedException(<span>override val </span><span>message</span>: String) : RuntimeException()<br/><br/><span>class </span>UserStatusEmptyException(<span>override val </span><span>message</span>: String = <span>"A user's status cannot be empty"</span>) : RuntimeException()</pre>
<p>Each exception&#160; extends <kbd>RuntimeException</kbd> as they occur during the server runtime. All exceptions also possess a <kbd>message</kbd> property. As the name implies, this is the exception message. Now that our exceptions have been added, we need to create controller advice classes. <kbd>ControllerAdvice</kbd>&#160;classes are used to handle errors that occur within a Spring application. They are created using the <kbd>@ControllerAdvice</kbd> annotation. In addition, a controller advice is a type of Spring component. Let's create a controller advice class to handle some of the preceding exceptions.</p>
<p>Looking at&#160;<span><kbd>UsernameUnavailableException</kbd>,&#160;</span><span><kbd>InvalidUserIdException</kbd>, and&#160;</span><span><kbd>UserStatusEmptyException</kbd>, we notice that these three exceptions are all pertaining to a user. As such, let's name the controller advice that caters to all these exceptions <kbd>UserControllerAdvice</kbd>. Create a <kbd>components</kbd> package and add a the following&#160;<kbd>UserControllerAdvice</kbd> class to it:</span></p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.constants.ErrorResponse<br/><span>import </span>com.example.messenger.api.constants.ResponseConstants<br/><span>import </span>com.example.messenger.api.exceptions.InvalidUserIdException<br/><span>import </span>com.example.messenger.api.exceptions.UserStatusEmptyException<br/><span>import </span>com.example.messenger.api.exceptions.UsernameUnavailableException<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.web.bind.annotation.<span>ControllerAdvice<br/></span><span>import </span>org.springframework.web.bind.annotation.<span>ExceptionHandler<br/></span><span><br/></span><span>@ControllerAdvice<br/></span><span>class </span>UserControllerAdvice {<br/><br/>  <span>@ExceptionHandler</span>(UsernameUnavailableException::<span>class</span>)<br/>  <span>fun </span><span>usernameUnavailable</span>(usernameUnavailableException: <br/>                          UsernameUnavailableException):<br/>      ResponseEntity&lt;ErrorResponse&gt; {<br/>    <span>val </span>res = ErrorResponse(ResponseConstants.<span>USERNAME_UNAVAILABLE<br/></span>                      .<span>value</span><span>, </span>usernameUnavailableException.<span>message</span>)<br/>    <span>return </span>ResponseEntity.unprocessableEntity().body(res)<br/>  }<br/><br/>  <span>@ExceptionHandler</span>(InvalidUserIdException::<span>class</span>)<br/>  <span>fun </span><span>invalidId</span>(invalidUserIdException: InvalidUserIdException):<br/>      ResponseEntity&lt;ErrorResponse&gt; {<br/>    <span>val </span>res = ErrorResponse(ResponseConstants.<span>INVALID_USER_ID</span>.<span>value</span><span>,<br/>                            </span>invalidUserIdException.<span>message</span>)<br/>    <span>return </span>ResponseEntity.badRequest().body(res)<br/>  }<br/><br/>  <span>@ExceptionHandler</span>(UserStatusEmptyException::<span>class</span>)<br/>  <span>fun </span><span>statusEmpty</span>(userStatusEmptyException: UserStatusEmptyException):<br/>      ResponseEntity&lt;ErrorResponse&gt; {<br/>    <span>val </span>res = ErrorResponse(ResponseConstants.<span>EMPTY_STATUS</span>.<span>value</span><span>,<br/>                            </span>userStatusEmptyException.<span>message</span>)<br/>    <span>return </span>ResponseEntity.unprocessableEntity().body(res)<br/>  }<br/>}</pre>
<p>&#160;We've just defined functions to cater to each of the three exceptions that can occur and annotated each of the functions with an <kbd>@ExceptionHanlder()</kbd> annotation. <kbd>@ExceptionHanlder()</kbd> takes a class reference to <span>the exception that is being handled by the function. Each function takes a single argument that is an instance of the exception thrown. In addition, all the defined functions return a <kbd>ResponseEntity&lt;ErrorResponse&gt;</kbd> instance. A response entity represents the entire HTTP response sent to the client.&#160;&#160;</span></p>
<p><kbd>ErrorResponse</kbd>&#160;has not yet been created. Create a <kbd>constants</kbd> package and add the following&#160;<kbd>ErrorResponse</kbd> class to it:</p>
<pre><span>package </span>com.example.messenger.api.constants<br/><span><br/></span><span>class </span><span>ErrorResponse</span>(<span>val </span><span>errorCode</span>: String<span>, val </span><span>errorMessage</span>: String)</pre>
<p><kbd>ErrorResponse</kbd> is a simple class with two properties: <kbd>errorCode</kbd> and <kbd>errorMessage</kbd>. Before we continue, go ahead and add the following&#160;<kbd>ResponseConstants</kbd> enum class to the <kbd>constants</kbd> package:</p>
<pre><span>package </span>com.example.messenger.api.constants<br/><span><br/></span><span>enum class </span>ResponseConstants(<span>val </span><span>value</span>: String) {<br/>  <span>SUCCESS</span>(<span>"success"</span>)<span>, </span><span>ERROR</span>(<span>"error"</span>)<span>,<br/></span><span>  </span><span>USERNAME_UNAVAILABLE</span>(<span>"USR_0001"</span>)<span>,<br/></span><span>  </span><span>INVALID_USER_ID</span>(<span>"USR_002"</span>)<span>,<br/></span><span>  </span><span>EMPTY_STATUS</span>(<span>"USR_003"</span>)<span>,<br/></span><span>  </span><span>MESSAGE_EMPTY</span>(<span>"MES_001"</span>)<span>,<br/></span><span>  </span><span>MESSAGE_RECIPIENT_INVALID</span>(<span>"MES_002"</span>)<span>,<br/></span><span>  </span><span>ACCOUNT_DEACTIVATED</span>(<span>"GLO_001"</span>)<br/>}</pre>
<p>Now, let's create three more controller advice classes. These classes are <kbd>MessageControllerAdvice</kbd>, <kbd>ConversationControllerAdvice</kbd>, and <kbd>RestControllerAdvice</kbd>. <kbd>RestControllerAdvice</kbd>&#160;will define exception handlers for errors that can happen anywhere within the server over the course of runtime.</p>
<p>The following is the <kbd>MessageControllerAdvice</kbd> class:</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.constants.ErrorResponse<br/><span>import </span>com.example.messenger.api.constants.ResponseConstants<br/><span>import </span>com.example.messenger.api.exceptions.<span>MessageEmptyException</span><br/><span>import </span>com.example.messenger.api.exceptions.MessageRecipientInvalidException<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.web.bind.annotation.<span>ControllerAdvice<br/></span><span>import </span>org.springframework.web.bind.annotation.<span>ExceptionHandler<br/></span><span><br/></span><span>@ControllerAdvice<br/></span><span>class </span>MessageControllerAdvice {<br/>  <span>@ExceptionHandler</span>(<span>MessageEmptyException</span>::<span>class</span>)<br/>  <span>fun </span><span>messageEmpty</span>(messageEmptyException: <span>MessageEmptyException</span>): <br/>      ResponseEntity&lt;ErrorResponse&gt; {<br/>    //ErrorResponse object creation<br/>    <span>val </span>res = ErrorResponse(ResponseConstants.<span>MESSAGE_EMPTY</span>.<span>value</span><span>,<br/>                            </span>messageEmptyException.<span>message</span>)<br/><br/>    // Returning ResponseEntity containing appropriate ErrorResponse<br/>    <span>return </span>ResponseEntity.unprocessableEntity().body(res)<br/>  }<br/><br/>  <span>@ExceptionHandler</span>(MessageRecipientInvalidException::<span>class</span>)<br/>    <span>fun </span><span>messageRecipientInvalid</span>(messageRecipientInvalidException: <br/>                                MessageRecipientInvalidException):<br/>        ResponseEntity&lt;ErrorResponse&gt; {<br/>    <span>val </span>res = ErrorResponse(ResponseConstants.<span>MESSAGE_RECIPIENT_INVALID<br/></span>                     .<span>value</span><span>, </span>messageRecipientInvalidException.<span>message</span>)<br/>    <span>return </span>ResponseEntity.unprocessableEntity().body(res)<br/>  }<br/>}</pre>
<p>Next,&#160;add the&#160;<kbd>ConversationControllerAdvice</kbd>&#160;class, which is as follows:</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.constants.<span>ErrorResponse</span><br/><span>import </span>com.example.messenger.api.exceptions.ConversationIdInvalidException<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.web.bind.annotation.<span>ControllerAdvice<br/></span><span>import </span>org.springframework.web.bind.annotation.<span>ExceptionHandler<br/></span><span><br/></span><span>@ControllerAdvice<br/></span><span>class </span>ConversationControllerAdvice {<br/>  <span>@ExceptionHandler<br/></span><span>  fun </span><span>conversationIdInvalidException</span>(conversationIdInvalidException:<br/>          ConversationIdInvalidException): ResponseEntity&lt;<span>ErrorResponse</span>&gt; {<br/>    <span>val </span>res = <span>ErrorResponse</span>(<span>""</span><span>, </span>conversationIdInvalidException.<span>message</span>)<br/>    <span>return </span>ResponseEntity.unprocessableEntity().body(res)<br/>  }<br/>}</pre>
<p>Finally, add the <kbd>RestControllerAdvice</kbd> class:</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.constants.ErrorResponse<br/><span>import </span>com.example.messenger.api.constants.ResponseConstants<br/><span>import </span>com.example.messenger.api.<span>exceptions</span>.UserDeactivatedException<br/><span>import </span>org.springframework.http.HttpStatus<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.web.bind.annotation.<span>ControllerAdvice<br/></span><span>import </span>org.springframework.web.bind.annotation.<span>ExceptionHandler<br/></span><span><br/></span><span>@ControllerAdvice<br/></span><span>class </span>RestControllerAdvice {<br/><br/>  <span>@ExceptionHandler</span>(UserDeactivatedException::<span>class</span>)<br/>  <span>fun </span><span>userDeactivated</span>(userDeactivatedException: <br/>                      UserDeactivatedException): <br/>      ResponseEntity&lt;ErrorResponse&gt; {<br/>    <span>val </span>res = ErrorResponse(ResponseConstants.<span>ACCOUNT_DEACTIVATED<br/></span>                     .<span>value</span><span>, </span>userDeactivatedException.<span>message</span>)<br/><br/>    // Return an HTTP 403 unauthorized error response<br/>    <span>return </span>ResponseEntity(res<span>, </span>HttpStatus.<span>UNAUTHORIZED</span>)<br/>  }<br/>}</pre>
<p><span>We have implemented our business logic and we are almost ready to facilitate HTTP&#160;</span><span>request&#160;</span><span>entries via REST endpoints into our API. Before we do that, we must secure our API.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Restricting API access</h1>
                </header>
            
            <article>
                
<p>From a security standpoint, it is a huge taboo to permit just anyone to have access to RESTful API resources. We must devise a way to restrict access to our server to only registered and logged-in users. We will do this using <strong>Spring Security</strong> and <strong>JSON Web Tokens</strong> (<strong>JWTs</strong>).</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Spring Security</h1>
                </header>
            
            <article>
                
<p>Spring Security is a highly customizable access-control framework for Spring applications. It is the accepted standard for securing applications built with Spring. As it is selected to add the Security dependency at the start of this project's creation, we do not need to add the Spring Security dependency to <kbd>pom.xml</kbd> as it has already been added.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">JSON Web Tokens</h1>
                </header>
            
            <article>
                
<p>According to the JWT website (<a href="https://tools.ietf.org/html/rfc7519">https://tools.ietf.org/html/rfc7519</a>), <em>JSON Web Tokens are an open, industry standard&#160;method for representing claims securely between two parties</em>. JWT allows you to decode, verify, and generate JWT. JWTs can be used easily with Spring Boot to implement authentication in applications. The following sections will demonstrate how to use a JWT and Spring Security combination to secure the messenger backend.</p>
<p>The first thing that must be done in order for you to get started with JWTs in a Spring application is add its dependency to the project <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependencies&gt; <br/>  ...<br/>  <span>&lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>io.jsonwebtoken<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>jjwt<span>&lt;/artifactId&gt;<br/></span><span>    &lt;version&gt;</span>0.7.0<span>&lt;/version&gt;<br/></span><span>  &lt;/dependency&gt;<br/></span>&lt;/dependencies&gt;</pre>
<p>Upon including a new maven dependency in <kbd>pom.xml</kbd>, IntelliJ will ask you to import the new dependencies:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/18791763-36e8-494a-88f0-2d207944906e.jpg" style="width:50.67em;height:14.92em;"/></div>
<p>Click on <span class="packt_screen">Import Changes</span>&#160;once the prompt shows up, and the JWT dependency will be imported into the project.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Configuring web security</h1>
                </header>
            
            <article>
                
<p>The first thing we need to do is create a custom web security configuration. Create a <kbd>config</kbd>&#160;package in <kbd>com.example.messenger.api</kbd>. Add a <kbd>WebSecurityConfig</kbd> class to the package and input the following code:&#160;</p>
<pre><span>package </span>com.example.messenger.api.config<br/><span><br/></span><span>import </span>com.example.messenger.api.filters.JWTAuthenticationFilter<br/><span>import </span>com.example.messenger.api.filters.JWTLoginFilter<br/><span>import </span>com.example.messenger.api.services.AppUserDetailsService<br/><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span>import </span>org.springframework.http.HttpMethod<br/><span>import </span>org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder<br/><span>import </span>org.springframework.security.config.annotation.web.builders.HttpSecurity<br/><span>import </span>org.springframework.security.config.annotation.web.configuration.<span>EnableWebSecurity<br/></span><span>import </span>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter<br/><span>import </span>org.springframework.security.core.userdetails.UserDetailsService<br/><span>import </span>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder<br/><span>import </span>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter<br/><br/><span>@Configuration<br/></span><span>@EnableWebSecurity<br/></span><span>class </span>WebSecurityConfig(<span>val </span><span>userDetailsService</span>: AppUserDetailsService)<br/>         : WebSecurityConfigurerAdapter() {<br/><br/>  <span>@Throws</span>(Exception::<span>class</span>)<br/>  <span>override fun </span><span>configure</span>(http: HttpSecurity) {<br/>    http.csrf().disable().authorizeRequests()<br/>        .antMatchers(HttpMethod.<span>POST</span><span>, </span><span>"/users/registrations"</span>)<br/>        .permitAll()<br/>        .antMatchers(HttpMethod.<span>POST</span><span>, </span><span>"/login"</span>).permitAll()<br/>        .anyRequest().authenticated()<br/>        .and()<br/>        </pre>
<p><span>Let's <kbd>Filter</kbd> the /login requests:</span></p>
<pre><span>        </span>.addFilterBefore(JWTLoginFilter(<span>"/login"</span><span>,<br/>                </span>authenticationManager())<span>,<br/>                </span>UsernamePasswordAuthenticationFilter::<span>class</span>.<span>java</span>)</pre>
<p><span>Let's filter other requests to check the presence of JWT in header:</span></p>
<pre><span>       </span>.addFilterBefore(JWTAuthenticationFilter()<span>,<br/>                </span>UsernamePasswordAuthenticationFilter::<span>class</span>.<span>java</span>)<br/>  }<br/><br/>  <span>@Throws</span>(Exception::<span>class</span>)<br/>  <span>override fun </span><span>configure</span>(auth: AuthenticationManagerBuilder) {<br/>    auth.userDetailsService&lt;UserDetailsService&gt;(<span>userDetailsService</span>)<br/>        .passwordEncoder(BCryptPasswordEncoder())<br/>  }<br/>}</pre>
<p><kbd>WebSecurityConfig</kbd> is annotated with <kbd>@EnableWebSecurity</kbd>. This enables Spring Security's web security support. In addition, <kbd>WebSecurityConfig</kbd> extends <kbd>WebSecurityConfigurerAdapter</kbd> and overrides some of its <kbd>configure()</kbd> methods to add some customization to the web security config.&#160;</p>
<p>The <kbd>configure(HttpSecurity)</kbd>&#160;method configures which URL paths are to be secured and which shouldn't be. In <kbd>WebSecurityConfig</kbd>, we permitted all <kbd>POST</kbd> requests to the <kbd>/users/registrations</kbd>&#160;and <kbd>/login</kbd> paths. These two endpoints don't need to be secured, as a user cannot be authenticated prior to login or his registration on the platform. In addition, we added filters for requests. Requests to <kbd>/login</kbd>&#160; will be filtered by <kbd>JWTLoginFilter</kbd> (we have yet to implement this); all requests that are&#160;<span>unauthenticated and unpermitted&#160;</span>will be filtered by <kbd>JWTAuthenticationFilter</kbd>&#160;<span>(we have yet to implement this, too)</span>.&#160;</p>
<p><kbd><span>configure</span>(AuthenticationManagerBuilder)</kbd> sets up the <kbd>UserDetailsService</kbd>&#160;and specifies a password encoder to be used.</p>
<p>There are a number of classes that we made use of that we have not implemented yet. We will start by implementing&#160;<span><kbd>JWTLoginFilter</kbd>&#160;. Create a new package named <kbd>filters</kbd>&#160;and add the following&#160;<kbd>JWTLoginFilter</kbd>&#160;class:</span></p>
<pre><span>package </span>com.example.messenger.api.filters<br/><br/><span>import </span>com.example.messenger.api.security.AccountCredentials<br/><span>import </span>com.example.messenger.api.services.TokenAuthenticationService<br/><span>import </span>com.fasterxml.jackson.databind.ObjectMapper<br/><span>import </span>org.springframework.security.authentication.AuthenticationManager<br/><span>import </span>org.springframework.security.authentication.UsernamePasswordAuthenticationToken<br/><span>import </span>org.springframework.security.core.Authentication<br/><span>import </span>org.springframework.security.core.AuthenticationException<br/><span>import </span>org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter<br/><span>import </span>org.springframework.security.web.util.matcher.AntPathRequestMatcher<br/><br/><span>import </span>javax.servlet.FilterChain<br/><span>import </span>javax.servlet.ServletException<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span>import </span>javax.servlet.http.HttpServletResponse<br/><span>import </span>java.io.IOException<span><br/></span><span><br/></span><span>class </span>JWTLoginFilter(url: String<span>, </span>authManager: AuthenticationManager) :<br/>    AbstractAuthenticationProcessingFilter(AntPathRequestMatcher(url)){<br/><br/>  <span>init </span>{<br/>    <span>authenticationManager </span>= authManager<br/>  }<br/><br/>  <span>@Throws</span>(AuthenticationException::<span>class, </span>IOException::<span>class,<br/>          </span>ServletException::<span>class</span>)<br/>  <span>override fun </span><span>attemptAuthentication</span>( req: HttpServletRequest<span>,<br/>                      </span>res: HttpServletResponse): Authentication{<br/>    <span>val </span><span>credentials</span> = ObjectMapper()<br/>        .readValue(req.<span>inputStream</span><span>, </span>AccountCredentials::<span>class</span>.<span>java</span>)<br/>    <span>return </span><span>authenticationManager</span>.authenticate(<br/>      UsernamePasswordAuthenticationToken(<br/>        <span>credentials</span>.<span>username</span><span>,<br/></span><span>        </span><span>credentials</span>.<span>password</span><span>,<br/></span><span>        </span>emptyList()<br/>      )<br/>    )<br/>  }<br/><br/>  <span>@Throws</span>(IOException::<span>class, </span>ServletException::<span>class</span>)<br/>  <span>override fun </span><span>successfulAuthentication</span>(<br/>               req: HttpServletRequest<span>,<br/></span><span>               </span>res: HttpServletResponse<span>, </span>chain: FilterChain<span>,<br/></span><span>               </span>auth: Authentication) {<br/>    TokenAuthenticationService.addAuthentication(res<span>, </span>auth.<span>name</span>)<br/>  }<br/>}</pre>
<p><kbd>JWTLoginFilter</kbd>&#160;takes a string URL and an <kbd>AuthenticationManager</kbd> instance as arguments to its primary constructor. You can also see it extends&#160;<kbd><span>AbstractAuthenticationProcessingFilter</span></kbd>. This filter intercepts incoming HTTP requests to the server and attempts to authenticate them. <kbd>attemptAuthentication()</kbd>&#160; performs the actual authentication process. It uses an <kbd>ObjectMapper()</kbd>&#160;instance to read the credentials present in the&#160;<kbd>via</kbd>&#160;HTTP request, after which&#160;<kbd>authenticationManager</kbd> is used to authenticate the request. <kbd>AccountCredentials</kbd> is another class that we have yet to implement. Create a new package, called&#160;<kbd>security</kbd>, and add an <kbd>AccountCredentials.kt</kbd> file to it:</p>
<pre><span>package </span>com.example.messenger.api.security<br/><span><br/></span><span><br/></span><span>class </span>AccountCredentials {<br/>  <span>lateinit var </span><span>username</span>: String<br/>  <span>lateinit var </span><span>password</span>: String<br/>}</pre>
<p>We have variables for a <kbd>username</kbd>&#160;and <kbd>password</kbd> because these are what will be used to authenticate the user.</p>
<p>The <kbd>SuccessfulAuthentication()</kbd>&#160;method is called upon successful authentication of a user. The only task done in the function is the addition of authentication tokens to the <kbd>Authorization</kbd> header of the HTTP response. The actual addition of this header is done by <kbd>TokenAuthenticationService.addAuthentication()</kbd>. Let's add this service to our <kbd>services</kbd> package:</p>
<pre><span>package </span>com.example.messenger.api.services<span><br/></span><span>import </span>io.jsonwebtoken.Jwts<br/><span>import </span>io.jsonwebtoken.SignatureAlgorithm<br/><span>import </span>org.springframework.security.authentication.UsernamePasswordAuthenticationToken<br/><span>import </span>org.springframework.security.core.Authentication<br/><span>import </span>org.springframework.security.core.GrantedAuthority<br/><br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span>import </span>javax.servlet.http.HttpServletResponse<br/><span>import </span>java.util.Date<br/><br/><span>import </span>java.util.Collections.emptyList<br/><br/><span>internal object </span>TokenAuthenticationService {<br/>  <span>private val </span><span>TOKEN_EXPIRY</span>: Long = <span>864000000</span><span><br/></span><span>  </span><span>private val </span><span>SECRET </span>= <span>"$78gr43g7g8feb8we"<br/></span><span>  </span><span>private val </span><span>TOKEN_PREFIX </span>= <span>"Bearer"<br/></span><span>  </span><span>private val </span><span>AUTHORIZATION_HEADER_KEY </span>= <span>"Authorization"<br/></span><span><br/></span><span>  </span><span>fun </span><span>addAuthentication</span>(res: HttpServletResponse<span>, </span>username: String) {<br/>    <span>val </span>JWT = Jwts.builder()<br/>                  .setSubject(username)<br/>                  .setExpiration(Date(System.currentTimeMillis() +<br/>                                      <span>TOKEN_EXPIRY</span>))<br/>                  .signWith(SignatureAlgorithm.<span>HS512</span><span>, </span><span>SECRET</span>)<br/>                  .compact()<br/>    res.addHeader(<span>AUTHORIZATION_HEADER_KEY</span><span>, </span><span>"</span><span>$</span><span>TOKEN_PREFIX </span><span>$</span>JWT<span>"</span>)<br/>  }<br/><br/>  <span>fun </span><span>getAuthentication</span>(request: HttpServletRequest): Authentication? {<br/>    <span>val </span>token = request.getHeader(<span>AUTHORIZATION_HEADER_KEY</span>)<br/>    <span>if </span>(token != <span>null</span>) {<br/>      </pre>
<p><span>Let's parse the token:</span></p>
<pre><span>      val </span>user = Jwts.parser().setSigningKey(<span>SECRET</span>)<br/>                     .parseClaimsJws(token.<span>replace</span>(<span>TOKEN_PREFIX</span><span>, </span><span>""</span>))<br/>                     .<span>body</span>.<span>subject<br/></span><span><br/></span><span>      </span><span>if </span>(user != <span>null</span>)<br/>        <span>return </span>UsernamePasswordAuthenticationToken(user<span>, null,<br/>                               </span>emptyList&lt;GrantedAuthority&gt;())<br/>    }<br/>    <span>return null<br/></span><span>  </span>}<br/>}</pre>
<p>As the names imply, <kbd>addAuthentication()</kbd> adds an authentication token to the <kbd>Authorization</kbd> header of the HTTP response and <kbd>getAuthentication()</kbd><span>&#160;authenticates the user</span>.&#160;</p>
<p>Now let's add <kbd>JWTAuthenticationFilter</kbd>&#160;to the <kbd>filters</kbd> package. Add the following&#160;<kbd>JWTAuthenticationFilter</kbd> class to the <kbd>filters</kbd> package:</p>
<pre><span>package </span>com.example.messenger.api.filters<br/><span><br/></span><span>import </span>com.example.messenger.api.services.TokenAuthenticationService<br/><span>import </span>org.springframework.security.core.context.<span>SecurityContextHolder</span><br/><span>import </span>org.springframework.web.filter.GenericFilterBean<br/><span>import </span>javax.servlet.FilterChain<br/><span>import </span>javax.servlet.ServletException<br/><span>import </span>javax.servlet.ServletRequest<br/><span>import </span>javax.servlet.ServletResponse<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span>import </span>java.io.IOException<br/><br/><span>class </span>JWTAuthenticationFilter : GenericFilterBean() {<br/><br/>  <span>@Throws</span>(IOException::<span>class, </span>ServletException::<span>class</span>)<br/>  <span>override fun </span><span>doFilter</span>(request: ServletRequest<span>,<br/></span><span>                        </span>response: ServletResponse<span>,<br/></span><span>                        </span>filterChain: FilterChain) {<br/>    <span>val </span>authentication = TokenAuthenticationService<br/>              .getAuthentication(request <span>as </span>HttpServletRequest)<br/>    <span>SecurityContextHolder</span>.getContext().<span>authentication </span>= authentication<br/>    filterChain.doFilter(request<span>, </span>response)<br/>  }<br/>}</pre>
<p>The <kbd>doFilter()</kbd> function&#160;<span>of the <kbd>JWTAuthenticationFilter</kbd> is called by the container each time a request/response pair is passed through the filter chain as a result of a client request for a resource. The <kbd>FilterChain</kbd> instance passed in to <kbd>doFilter()</kbd> allows the filter to pass the request and response on to the next entity in the filter chain.</span></p>
<p>Finally, we need to implement the <kbd>AppUserDetailsService</kbd> class as usual, we will put this in the <kbd>services</kbd> package of the project:</p>
<pre><span>package </span>com.example.messenger.api.services<br/><br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>org.springframework.security.core.GrantedAuthority<br/><span>import </span>org.springframework.security.core.authority.SimpleGrantedAuthority<br/><span>import </span>org.springframework.security.core.userdetails.User<br/><span>import </span>org.springframework.security.core.userdetails.UserDetails<br/><span>import </span>org.springframework.security.core.userdetails.UserDetailsService<br/><span>import </span>org.springframework.security.core.userdetails.UsernameNotFoundException<br/><span>import </span>org.springframework.stereotype.<span>Component<br/></span><span>import </span>java.util.ArrayList<br/><span><br/></span><span>@Component<br/></span><span>class </span>AppUserDetailsService(<span>val </span><span>userRepository</span>: UserRepository) : UserDetailsService {<br/><br/>  <span>@Throws</span>(UsernameNotFoundException::<span>class</span>)<br/>  <span>override fun </span><span>loadUserByUsername</span>(username: String): UserDetails {<br/>    <span>val </span>user = <span>userRepository</span>.findByUsername(username) ?:<br/>               <span>throw </span>UsernameNotFoundException(<span>"A user with the <br/>                             username </span><span>$username</span><span> doesn't exist"</span>)<br/><span><br/></span><span>    </span><span>return </span>User(user.<span>username</span><span>, </span>user.<span>password</span><span>,<br/>                </span>ArrayList&lt;GrantedAuthority&gt;())<br/>  }<br/>}</pre>
<p><kbd>loadUsername(String)</kbd>&#160;attempts to load the <kbd>UserDetails</kbd> of a user matching the <kbd>username</kbd> passed to the function. If the user matching the provided username cannot be found, a <kbd>UsernameNotFoundException</kbd> is thrown.</p>
<p>And, just like that, we have successfully configured Spring Security. We are now ready to expose some API functionality via RESTful endpoints with the use of controllers.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing server resources via RESTful endpoints</h1>
                </header>
            
            <article>
                
<p>So far, we have created models, components, services, and service implementations, as well as integrated Spring Security into the messenger application. One thing we have not done is actually created any means by which external clients can communicate with the messenger API. We are going to do this by creating controller classes that handles requests from different HTTP request paths. As always, the first thing we must do is create a package to contain the controllers we are about to create. Create a <kbd>controllers</kbd> package now.</p>
<p>The first controller we will implement is the <kbd>UserController</kbd>. This controller maps HTTP requests pertaining to a user resource to in-class actions that handle and respond to the HTTP request. First and foremost, we need an endpoint to facilitate the registration of new users. We will call the action that handles such a registration request <kbd>create</kbd>. The following is the <kbd>UserController</kbd>&#160;code with the <kbd>create</kbd> action:</p>
<pre><span>package </span>com.example.messenger.api.controllers<br/><br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>com.example.messenger.api.services.UserServiceImpl<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.validation.annotation.<span>Validated<br/></span><span>import </span>org.springframework.web.bind.annotation.*<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span><br/></span><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/users"</span>)<br/><span>class </span>UserController(<span>val </span><span>userService</span>: UserServiceImpl<span>,</span><span> <br/>                     val </span><span>userRepository</span>: UserRepository) {<br/><br/>  <span>@PostMapping<br/></span><span>  @RequestMapping</span>(<span>"/registrations"</span>)<br/>  <span>fun </span><span>create</span>(<span>@Validated @RequestBody </span>userDetails: User):<br/>             ResponseEntity&lt;User&gt; {<br/>    <span>val </span>user = <span>userService</span>.<span>attemptRegistration</span>(userDetails)<br/>    <span>return </span>ResponseEntity.ok(user)<br/>  }<br/>}</pre>
<p>The controller class is annotated with <kbd>@RestController</kbd> and <kbd>@RequestMapping</kbd>. The <kbd>@RestController</kbd> annotation specifies that a class is a REST controller. <kbd>@RequestMapping</kbd>, as it is used with the <kbd>UserController</kbd> class earlier, maps all requests with paths starting with <kbd>/users</kbd>&#160;to <kbd>UserController</kbd>.&#160;</p>
<p>The <kbd>create</kbd> function is annotated with <kbd>@PostMapping</kbd> and <kbd>@RequestMapping("/registrations")</kbd>. The combination of these two annotations maps all POST requests with the&#160;<kbd>/users/registrations</kbd>&#160;path to the create function. A <kbd>User</kbd>&#160;<span>instance&#160;</span>annotated with <kbd>@Validated</kbd> and <kbd>@RequestBody</kbd> is passed to <kbd>create</kbd>.&#160; <kbd>@RequestBody</kbd> binds the JSON values sent in the body of the POST request to <kbd>userDetails</kbd>. <kbd>@Validated</kbd>&#160;ensures that the JSON parameters are validated. Now that we have an endpoint up and running, let's test it out. Start the application and navigate to your terminal window. Send a request to the messenger API using CURL, as follows:</p>
<pre class="p1"><strong><span class="s1">curl -H "Content-Type: application/json" -X POST -d '{"username":"kevin.stacey",<br/>  "phoneNumber":"5472457893",<br/>  "password":"Hello123"}'<br/> http://localhost:8080/users/registrations</span></strong></pre>
<p>The server will create the user and send you a response similar to the following:</p>
<pre class="p1"><span class="s1">{<br/>  "username":"kevin.stacey",<br/>  "phoneNumber":"5472457893",<br/>  "password":"XXX XXXX XXX",<br/>  "status":"available",<br/>  "accountStatus":"activated",<br/>  "id":6,"createdAt":1508579448634<br/>}</span></pre>
<p>That's all fine and good, but we can see there are a number of unwanted values in the HTTP response, such as the <kbd>password</kbd> and <kbd>accountStatus</kbd> response parameters. In addition to this, we'd like for <kbd>createdAt</kbd> to contain a human-readable date. We are going to do all these things using an assembler and a value object.</p>
<p>First, let's make the value object. The value object we are creating is going to contain the data of the user that we want to be sent to the client in its appropriate form and nothing more. Create a <kbd>helpers.objects</kbd>&#160;package with a <kbd>ValueObjects.kt</kbd> file in it:</p>
<pre><span>package </span>com.example.messenger.api.helpers.objects<br/><span><br/></span><span>data class </span>UserVO(<br/>  <span>val </span><span>id</span>: Long<span>,<br/></span><span>  val </span><span>username</span>: String<span>,<br/></span><span>  val </span><span>phoneNumber</span>: String<span>,<br/></span><span>  val </span><span>status</span>: String<span>,<br/></span><span>  val </span><span>createdAt</span>: String<br/>)</pre>
<p>As you can see, <kbd>UserVO</kbd> is a data class that models the information we want to be sent to the user and nothing more. While we are at it, let's add value objects for some other responses we will cater for later, to avoid coming back to this file:</p>
<pre><span>package </span>com.example.messenger.api.helpers.objects<br/><span><br/></span><span>data class </span>UserVO(<br/>  <span>val </span><span>id</span>: <span>Long</span><span>,<br/></span><span>  val </span><span>username</span>: String<span>,<br/></span><span>  val </span><span>phoneNumber</span>: String<span>,<br/></span><span>  val </span><span>status</span>: String<span>,<br/></span><span>  val </span><span>createdAt</span>: String<br/>)<br/><br/>data class UserListVO(<br/>  val users: List&lt;UserVO&gt;<br/>)<br/><br/><span>data class </span>MessageVO(<br/>  <span>val </span><span>id</span>: <span>Long</span><span>,<br/></span><span>  val </span><span>senderId</span>: <span>Long</span>?<span>,<br/></span><span>  val </span><span>recipientId</span>: <span>Long</span>?<span>,<br/></span><span>  val </span><span>conversationId</span>: <span>Long</span>?<span>,<br/></span><span>  val </span><span>body</span>: String?<span>,<br/></span><span>  val </span><span>createdAt</span>: String<br/>)<br/><br/><span>data class </span>ConversationVO(<br/>  <span>val </span><span>conversationId</span>: <span>Long</span><span>,<br/></span><span>  val </span><span>secondPartyUsername</span>: String<span>,<br/></span><span>  val </span><span>messages</span>: ArrayList&lt;MessageVO&gt;<br/>)<br/><br/><span>data class </span>ConversationListVO(<br/>  <span>val </span><span>conversations</span>: List&lt;ConversationVO&gt;<br/>)</pre>
<p>Now that we have the required value objects set, let's create an assembler for <kbd>UserVO</kbd>. An assembler is simply a component that <kbd>assembles</kbd>&#160;a required object value. We will call the assembler we are creating <kbd>UserAssembler</kbd>. As it's a component, it belongs in the <kbd>components</kbd> package:</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.helpers.objects.UserListVO<br/><span>import </span>com.example.messenger.api.helpers.objects.UserVO<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>org.springframework.stereotype.<span>Component<br/></span><span><br/></span><span>@Component<br/></span><span>class </span>UserAssembler {<br/><br/>  <span>fun </span><span>toUserVO</span>(user: User): UserVO {<br/>    <span>return </span>UserVO(user.<span>id</span><span>, </span>user.<span>username</span><span>, </span>user.<span>phoneNumber</span><span>,<br/></span><span>                  </span>user.<span>status</span><span>, </span>user.<span>createdAt</span>.toString())<br/>  }<br/><br/>  <span>fun </span><span>toUserListVO</span>(users: List&lt;User&gt;): UserListVO {<br/>    <span>val </span>userVOList = users.<span>map </span><span>{ </span>toUserVO(<span>it</span>) <span>}<br/></span><span>    </span><span>return  </span>UserListVO(userVOList)<br/>  }<br/>}</pre>
<p>The assembler has a single <kbd>toUserVO()</kbd> function that takes a <kbd>User</kbd> as its argument and returns a corresponding <kbd>UserVO</kbd>.&#160; <kbd>toUserListVO()</kbd> takes a list of <kbd>User</kbd> instances and returns a corresponding <kbd>UserListVO</kbd>.</p>
<p>Now let's edit the create endpoint to make use of <kbd>UserAssembler</kbd> and <kbd>UserVO</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.controllers<br/><br/><span>import </span>com.example.messenger.api.components.UserAssembler<br/><span>import </span>com.example.messenger.api.helpers.objects.UserVO<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>com.example.messenger.api.services.UserServiceImpl<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.validation.annotation.<span>Validated<br/></span><span>import </span>org.springframework.web.bind.annotation.*<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><br/><span><br/></span><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/users"</span>)<br/><span>class </span>UserController(<span>val </span><span>userService</span>: UserServiceImpl<span>,<br/></span><span>                     val </span><span>userAssembler</span>: UserAssembler<span>, <br/>                     val </span><span>userRepository</span>: UserRepository) {<br/><br/>  <span>@PostMapping<br/></span><span>  @RequestMapping</span>(<span>"/registrations"</span>)<br/>  <span>fun </span><span>create</span>(<span>@Validated @RequestBody </span>userDetails: User): <br/>             ResponseEntity&lt;UserVO&gt; {<br/>    <span>val </span>user = <span>userService</span>.attemptRegistration(userDetails)<br/>    <span>return </span>ResponseEntity.ok(<span>userAssembler</span>.toUserVO(user))<br/>  }<br/>}</pre>
<p>Restart the server and send a new request to register a <kbd>User</kbd>. We will get a response that is much more appropriate from the API:</p>
<pre class="p1"><span class="s1">{<br/>  "id":6,<br/>  "username":"kevin.stacey",<br/>  "phoneNumber":"5472457893",<br/>  "status":"available",<br/>  "createdAt":"Sat Oct 21 11:11:36 WAT 2017"<br/>}</span></pre>
<p>Let's wrap up our endpoint creation process by creating all the necessary endpoints for the messenger Android application. Firstly, let's add endpoints to show the details of a <kbd>User</kbd>, list all users, get the details of the current user, and update the status of a <kbd>User</kbd> to <kbd>UserController</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.controllers<br/><br/><span>import </span>com.example.messenger.api.components.UserAssembler<br/><span>import </span>com.example.messenger.api.helpers.objects.UserListVO<br/><span>import </span>com.example.messenger.api.helpers.objects.UserVO<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>com.example.messenger.api.services.UserServiceImpl<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.validation.annotation.<span>Validated<br/></span><span>import </span>org.springframework.web.bind.annotation.*<br/><span>import </span>javax.servlet.http.<span>HttpServletRequest</span><br/><span><br/></span><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/users"</span>)<br/><span>class </span>UserController(<span>val </span><span>userService</span>: UserServiceImpl<span>,<br/></span><span>                     val </span><span>userAssembler</span>: UserAssembler<span>, <br/>                     val </span><span>userRepository</span>: UserRepository) {<br/><br/>  <span>@PostMapping<br/></span><span>  @RequestMapping</span>(<span>"/registrations"</span>)<br/>  <span>fun </span><span>create</span>(<span>@Validated @RequestBody </span>userDetails: User): <br/>             ResponseEntity&lt;UserVO&gt; {<br/>    <span>val </span>user = <span>userService</span>.attemptRegistration(userDetails)<br/>    <span>return </span>ResponseEntity.ok(<span>userAssembler</span>.toUserVO(user))<br/>  }<br/><br/>  <span>@GetMapping<br/></span><span>  @RequestMapping</span>(<span>"/{user_id}"</span>)<br/>  <span>fun </span><span>show</span>(<span>@PathVariable</span>(<span>"user_id"</span>) userId: Long):<br/>           ResponseEntity&lt;UserVO&gt; {<br/>    <span>val </span>user = <span>userService</span>.retrieveUserData(userId)<br/>    <span>return </span>ResponseEntity.ok(<span>userAssembler</span>.toUserVO(user))<br/>  }<br/><br/>  <span>@GetMapping<br/></span><span>  @RequestMapping</span>(<span>"/details"</span>)<br/>  <span>fun </span><span>echoDetails</span>(request: <span>HttpServletRequest</span>): ResponseEntity&lt;UserVO&gt;{<br/>    <span>val </span>user = <span>userRepository</span>.findByUsername<br/>               (request.<span>userPrincipal</span>.<span>name</span>) <span>as </span>User<br/>    <span>return </span>ResponseEntity.ok(<span>userAssembler</span>.toUserVO(user))<br/>  }<br/><br/>  <span>@GetMapping<br/></span><span>  fun </span><span>index</span>(request: <span>HttpServletRequest</span>): ResponseEntity&lt;UserListVO&gt; {<br/>    <span>val </span>user = <span>userRepository</span>.findByUsername<br/>               (request.<span>userPrincipal</span>.<span>name</span>) <span>as </span>User<br/>    <span>val </span>users = <span>userService</span>.listUsers(user)<br/><br/>    <span>return </span>ResponseEntity.ok(<span>userAssembler</span>.toUserListVO(users))<br/>  }<br/><br/>  <span>@PutMapping<br/></span><span>  fun </span><span>update</span>(<span>@RequestBody </span>updateDetails: User<span>,<br/>      </span>request: <span>HttpServletRequest</span>): ResponseEntity&lt;UserVO&gt; {<br/>    <span>val </span>currentUser = <span>userRepository</span>.findByUsername<br/>                      (request.<span>userPrincipal</span>.<span>name</span>)<br/>    <span>userService</span>.updateUserStatus(currentUser <span>as </span>User<span>, </span>updateDetails)<br/>    <span>return </span>ResponseEntity.ok(<span>userAssembler</span>.toUserVO(<span>currentUser</span>))<br/>  }<br/>}</pre>
<p>Now we are going to create controllers to handle message resources and conversation resources. These will be <kbd>MessageController</kbd> and <kbd>ConversationController</kbd>, respectively. Before creating the controllers, let's assemblers that will be used&#160;to assemble value objects from JPA entities. The following is the&#160;<kbd>MessageAssembler</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.helpers.objects.MessageVO<br/><span>import </span>com.example.messenger.api.models.Message<br/><span>import </span>org.springframework.stereotype.<span>Component<br/></span><span><br/></span><span>@Component<br/></span><span>class </span>MessageAssembler {<br/>  <span>fun </span><span>toMessageVO</span>(message: Message): MessageVO {<br/>    <span>return </span>MessageVO(message.<span>id</span><span>, </span>message.<span>sender</span>?.<span>id</span><span>,<br/>                     </span>message.<span>recipient</span>?.<span>id</span><span>, </span>message.<span>conversation</span>?.<span>id</span><span>,<br/>                     </span>message.<span>body</span><span>, </span>message.<span>createdAt</span>.toString())<br/>  }<br/>}</pre>
<p>And now, let's create the&#160;<kbd>ConversationAssembler</kbd>, as follows:</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.helpers.objects.ConversationListVO<br/><span>import </span>com.example.messenger.api.helpers.objects.ConversationVO<br/><span>import </span>com.example.messenger.api.helpers.objects.MessageVO<br/><span>import </span>com.example.messenger.api.models.Conversation<br/><span>import </span>com.example.messenger.api.services.ConversationServiceImpl<br/><span>import </span>org.springframework.stereotype.<span>Component<br/></span><span><br/></span><span><br/></span><span>@Component<br/></span><span>class </span>ConversationAssembler(<span>val </span><span>conversationService</span>: <br/>                            ConversationServiceImpl<span>, <br/>                            val </span><span>messageAssembler</span>: MessageAssembler) {<br/><br/>  <span>fun </span><span>toConversationVO</span>(conversation: Conversation<span>, </span>userId: Long): ConversationVO {<br/>    <span>val </span>conversationMessages: ArrayList&lt;MessageVO&gt; = ArrayList()<br/><span>    </span>conversation.<span>messages</span>.<span>mapTo</span>(conversationMessages) <span>{<br/>      </span><span>messageAssembler</span>.toMessageVO(<span>it</span>)<br/>    <span>}<br/></span><span>    </span><span>return </span>ConversationVO(conversation.<span>id</span><span>, </span><span>conversationService<br/></span><span>                          </span>.<span>nameSecondParty</span>(conversation<span>, </span>userId)<span>,<br/>                          </span>conversationMessages)<br/>  }<br/><br/>  <span>fun </span><span>toConversationListVO</span>(conversations: ArrayList&lt;Conversation&gt;<span>,<br/>                           </span>userId: Long): ConversationListVO {<br/>    <span>val </span>conversationVOList = conversations.<span>map </span><span>{ </span>toConversationVO(<span>it</span><span>,<br/>                                                 </span>userId) <span>}<br/></span><span>    </span><span>return  </span>ConversationListVO(conversationVOList)<br/>  }<br/>}</pre>
<p>All is in place for <kbd>MessageController</kbd> and <kbd>ConversationController</kbd>. For our simple messenger app, we only need to have a message creation action for <kbd>MessageController</kbd>. The following is <kbd>MessageController</kbd> with the message creation action,&#160;<kbd>create</kbd>:</p>
<pre><span>package </span>com.example.messenger.api.controllers<br/><br/><span>import </span>com.example.messenger.api.components.MessageAssembler<br/><span>import </span>com.example.messenger.api.helpers.objects.MessageVO<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>com.example.messenger.api.services.MessageServiceImpl<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.web.bind.annotation.*<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span><br/></span><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/messages"</span>)<br/><span>class </span>MessageController(<span>val </span><span>messageService</span>: MessageServiceImpl<span>,<br/></span><span>                        val </span><span>userRepository</span>: UserRepository<span>, <br/>                        val </span><span>messageAssembler</span>: MessageAssembler) {<br/><br/>  <span>@PostMapping<br/></span><span>  fun </span><span>create</span>(<span>@RequestBody </span>messageDetails: MessageRequest<span>, <br/></span>             request: HttpServletRequest): ResponseEntity&lt;MessageVO&gt; {<br/>    <span>val </span>principal = request.<span>userPrincipal<br/></span><span>    </span><span>val </span>sender = <span>userRepository</span>.findByUsername(principal.<span>name</span>) <span>as </span>User<br/>    <span>val </span>message = <span>messageService</span>.sendMessage(sender<span>,<br/>                  </span>messageDetails.<span>recipientId</span><span>, </span>messageDetails.<span>message</span>)<br/>    <span>return </span>ResponseEntity.ok(<span>messageAssembler</span>.toMessageVO(message))<br/>  }<br/><br/>  <span>data class </span>MessageRequest(<span>val </span><span>recipientId</span>: Long<span>, val </span><span>message</span>: String)<br/>}</pre>
<p>Lastly, we must create <kbd>ConversationController</kbd>. We need only two endpoints: one to list all the active conversations of a user and the other to get the messages existing in a conversation thread. These endpoints will be catered to by the <kbd>list()</kbd> and <kbd>show()</kbd> actions, respectively. The following is the <kbd>ConversationController</kbd> class:</p>
<pre><span>package </span>com.example.messenger.api.controllers<br/><br/><span>import </span>com.example.messenger.api.components.ConversationAssembler<br/><span>import </span>com.example.messenger.api.helpers.objects.ConversationListVO<br/><span>import </span>com.example.messenger.api.helpers.objects.ConversationVO<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>com.example.messenger.api.services.ConversationServiceImpl<br/><span>import </span>org.springframework.http.ResponseEntity<br/><span>import </span>org.springframework.web.bind.annotation.*<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span><br/></span><span>@RestController<br/></span><span>@RequestMapping</span>(<span>"/conversations"</span>)<br/><span>class </span>ConversationController(<br/><span>  val </span><span>conversationService</span>: ConversationServiceImpl<span>,<br/></span><span>  val </span><span>conversationAssembler</span>: ConversationAssembler<span>,<br/></span><span>  val </span><span>userRepository</span>: UserRepository<br/>) {<br/><br/>  <span>@GetMapping<br/></span><span>  fun </span><span>list</span>(request: HttpServletRequest): ResponseEntity&lt;ConversationListVO&gt; {<br/>    <span>val </span>user = <span>userRepository</span>.findByUsername(request<br/>                   .<span>userPrincipal</span>.<span>name</span>) a<span>s </span>User<br/>    <span>val </span>conversations = <span>conversationService</span>.listUserConversations<br/>                     (user.<span>id</span>)<br/>    <span>return </span>ResponseEntity.ok(<span>conversationAssembler<br/></span>                       .toConversationListVO(conversations<span>, </span>user.<span>id</span>))<br/>  }<br/><br/><br/><span>  @GetMapping<br/></span><span>  @RequestMapping</span>(<span>"/{conversation_id}"</span>)<br/><span>  fun </span><span>show</span>(<span>@PathVariable</span>(<span>name = </span><span>"conversation_id"</span>) conversationId: Long<span>,<br/>         </span>request: HttpServletRequest): ResponseEntity&lt;ConversationVO&gt; {<br/>    <span>val </span>user = <span>userRepository</span>.findByUsername(request<br/>                         .<span>userPrincipal</span>.<span>name</span>) <span>as </span>User<br/>    <span>val </span>conversationThread = <span>conversationService</span>.retrieveThread<br/>                           (conversationId)<br/>    <span>return </span>ResponseEntity.ok(<span>conversationAssembler<br/></span>                   .toConversationVO(conversationThread<span>, </span>user.<span>id</span>))<br/>  }<br/>}</pre>
<p>All is looking great! There's only one tiny problem. Remember, a user has an account status and it is possible for the account to be deactivated, right? In such a scenario, we, as API creators, will not want a deactivated user to be able to use our platform. As such, we have to come up with a way to prevent such a user from interacting with our API. There are a number of ways this can be done, but for this example we are going to use an interceptor. An interceptor intercepts an HTTP request and performs one or more operations on it before it continues down the request chain. Similar to assemblers, an interceptor is a component. We will call our interceptor that checks the validity of an account <kbd>AccountValidityInterceptor</kbd>. The following is the interceptor class (remember, it belongs in the <kbd>components</kbd> package):</p>
<pre><span>package </span>com.example.messenger.api.components<br/><br/><span>import </span>com.example.messenger.api.exceptions.UserDeactivatedException<br/><span>import </span>com.example.messenger.api.models.User<br/><span>import </span>com.example.messenger.api.repositories.UserRepository<br/><span>import </span>org.springframework.stereotype.<span>Component<br/></span><span>import </span>org.springframework.web.servlet.handler.HandlerInterceptorAdapter<br/><span>import </span>java.security.Principal<br/><span>import </span>javax.servlet.http.HttpServletRequest<br/><span>import </span>javax.servlet.http.HttpServletResponse<br/><span><br/></span><span>@Component<br/></span><span>class </span>AccountValidityInterceptor(<span>val </span><span>userRepository</span>: UserRepository) : <br/>      HandlerInterceptorAdapter() {<br/><br/>  <span>@Throws</span>(UserDeactivatedException::<span>class</span>)<br/>  <span>override fun </span><span>preHandle</span>(request: HttpServletRequest<span>, <br/></span>           response: HttpServletResponse<span>, </span>handler: Any?): Boolean {<br/>    <span>val </span>principal: Principal? = request.<span>userPrincipal<br/></span><span><br/></span><span>    i</span><span>f </span>(principal != <span>null</span>) {<br/>      <span>val </span>user = <span>userRepository</span>.findByUsername(<span>principal</span>.<span>name</span>) <br/><span>                 as </span>User<br/><br/>      <span>if </span>(user.<span>accountStatus </span>== <span>"deactivated"</span>) {<br/>        <span>throw </span>UserDeactivatedException(<span>"The account of this user has<br/>                                        been deactivated."</span>)<br/>      }<br/>    }<br/>    <span>return super</span>.<span>preHandle</span>(request<span>, </span>response<span>, </span>handler)<br/>  }<br/>}</pre>
<p>The <kbd>AccountValidityInterceptor</kbd> class overrides the <kbd>preHandle()</kbd> function of its super class. This function will be called to carry out some operations prior to the routing of the request to its necessary controller action. After the creation of an interceptor, the interceptor must be registered with the Spring application. This configuration can be done using a <kbd>WebMvcConfigurer</kbd>. Add an <kbd>AppConfig</kbd> file to the <kbd>config</kbd> package in the project. Input the following code within the file:</p>
<pre><span>package </span>com.example.messenger.api.config<br/><br/><span>import </span>com.example.messenger.api.components.<span>AccountValidityInterceptor</span><br/><span>import </span>org.springframework.beans.factory.annotation.<span>Autowired<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration<br/></span><span>import </span>org.springframework.web.servlet.config.annotation.InterceptorRegistry<br/><span>import </span>org.springframework.web.servlet.config.annotation.WebMvcConfigurer<br/><span><br/></span><span>@Configuration<br/></span><span>class </span>AppConfig : WebMvcConfigurer {<br/><span><br/></span><span>  </span><span>@Autowired<br/></span><span>  lateinit var </span><span>accountValidityInterceptor</span>: <span>AccountValidityInterceptor</span><br/><br/>  <span>override fun </span><span>addInterceptors</span>(registry: InterceptorRegistry) {<span><br/></span><span>    </span>registry.addInterceptor(<span>accountValidityInterceptor</span>)<br/>    <span>super</span>.addInterceptors(registry)<br/>  }<br/>}</pre>
<p><kbd>AppConfig</kbd> is a subclass of <kbd>WebMvcConfigurer</kbd> and overrides the <kbd>addInterceptor(InterceptorRegistry)</kbd> function in its superclass. <kbd>accountValidityInterceptor</kbd> is added to the interceptor registry with <kbd>registry.addInterceptor()</kbd>.</p>
<p>We are now done with all the code required to provide web resources to the messenger Android application. We must now deploy this code to a remote server.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying the messenger API to AWS</h1>
                </header>
            
            <article>
                
<p>Deploying a Spring Boot app to <strong>Amazon Web Services</strong>&#160;(<strong>AWS</strong>) is a straightforward and enjoyable process. The deployment procedure can be done well within 10 minutes. In this section, you will learn how to deploy applications based on Spring to AWS. Before application deployment, we must set up a PostgreSQL database on AWS that the application will connect to.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting up PostgreSQL on AWS</h1>
                </header>
            
            <article>
                
<p>The first thing you must do is create an AWS account. Go ahead and create one now by following this link:&#160;<a href="https://portal.aws.amazon.com/billing/signup#/start">https://portal.aws.amazon.com/billing/signup#/start</a> . Once you have signed up, login into the AWS console and head over to the Amazon <strong>Relational Database Service</strong> (<strong>RDS</strong>) (from the navigation bar, click <span class="packt_screen">Services</span> | <span class="packt_screen">Database</span> | <span class="packt_screen">RDS</span>). Once taken to the RDS dashboard, click on <span class="packt_screen">Get Started Now</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/07c9cbae-a86f-4647-9688-8659918739c3.jpg"/></div>
<p>You will be navigated to the <span class="packt_screen">Launch DB instance</span> web page. Here you will need to make some selections pertaining to the DB setup. Select <span class="packt_screen">PostgreSQL</span> as the DB engine to be used:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/f1b8c82a-b79b-468c-bcdc-1451777734c9.jpg"/></div>
<p>Ensure to check the <span class="packt_screen">Only enable options eligible for RDS Free Usage Tier</span>&#160;checkbox. Navigate to the next set of setup procedures by clicking <span class="packt_screen">Next</span>. On the next page, leave the instance specifications as is and input the necessary DB settings. Input a DB instance name, master username, and master password. We used <kbd>messenger-api</kbd> as our DB instance name, you may choose to use another name of your choice. Regardless your choice, ensure that you take note of all inputs you make. Once you are done entering the necessary, continue to the next screen.</p>
<p>You will be navigated to the <span><span class="packt_screen">Configure advanced settings</span>&#160;screen. In the <span class="packt_screen">Network &amp; Security</span> section, ensure to enable public accessibility and select the <span class="packt_screen">Create new VPC security group</span> option under <span class="packt_screen">VPC Security Groups</span>.&#160; Scroll down to the <span class="packt_screen">Database options</span>&#160;section of the screen and enter a DB name. Once again, we used <kbd>MessengerDB</kbd> as the DB name. Leave the remaining options as they are and click <span class="packt_screen">Launch DB instance</span>&#160;at the end of the web page:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/7a5dbaed-b509-40a6-924b-1b3a19ed767b.jpg"/></div>
<p>Your DB instance will be created by AWS. The creation process may take up to 10 minutes so it may be a good idea to take a coffee break at this point.</p>
<p>After waiting a little while, click <span class="packt_screen">View DB instance details</span>. This will take you to a page where you can see detailed information on your just deployed DB instance. Scroll to the <span class="packt_screen">Connect</span>&#160;section of the page to view the connection details of the DB instance:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/55fcbcde-cc98-414f-b8f0-8e26e151101d.jpg" style="width:50.50em;height:24.00em;"/></div>
<p>We need these details to successfully connect to the <kbd>MessengerDB</kbd> on this PostgreSQL DB instance. To enable <kbd>messenger-api</kbd> to connect to <kbd>MessengerDB</kbd>, you must edit the&#160;<span><kbd>spring.datasource.url</kbd>,&#160;<kbd>spring.datasource.username</kbd>, and&#160;<kbd>spring.datasource.password</kbd>&#160;</span>properties in the <kbd>application.properties</kbd> file. After doing this, <kbd>application.properties</kbd> should look similar to the following:</p>
<pre><span>spring.jpa.generate-ddl</span><span>=</span><span>true<br/></span><span>spring.jpa.hibernate.ddl-auto</span><span>=</span><span>create-drop<br/></span><span>spring.datasource.url</span><span>=</span><span>jdbc:postgresql://&lt;endpoint&gt;/MessengerDB<br/></span><span>spring.datasource.username</span><span>=&lt;master_username&gt;</span><span><br/></span><span>spring.datasource.password</span><span>=</span><span>&lt;password&gt;</span></pre>
<p>The final thing we will do is deploy the messenger API to an Amazon EC2 instance.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Deploying the messenger API to Amazon Elastic Beanstalk</h1>
                </header>
            
            <article>
                
<p>Deploying an application to AWS is simple as well. Navigate to the AWS console and select <span class="packt_screen">Services</span> | <span class="packt_screen">Compute</span> |&#160;<span class="packt_screen">Elastic Beanstalk</span><strong>.&#160;</strong>Once in the Elastic Beanstalk Management Console, click on <span class="packt_screen">Create New Application</span>. Once taken to the <span class="packt_screen">Create Application</span>&#160;page, you will be asked to provide a name and description for the new application to be created. Name the app <kbd>messenger-api</kbd> and proceed to the next screen. You will be taken to a screen in which you are prompted to create a new environment:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/1729dc3e-dd05-4dd6-9714-0cb63e172c40.jpg"/></div>
<p>Create a web server environment on this screen. Next up, you will need to configure the environment type. Select the <span class="packt_screen">Tomcat</span>&#160;predefined configuration and change the environment type to <span class="packt_screen">Single instance</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/b8c7749c-2754-4aaf-8ba5-20d7883ee28f.jpg"/></div>
<p>Continue to the next screen when you are ready. On the next screen, you will need to select a source for your application. Choose&#160;<span class="packt_screen">Upload your own</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/5656426d-6bf5-4700-9f15-7dd5ec47190c.jpg"/></div>
<p>Now we need to create a suitable project jar to be uploaded. We can package the messenger API into a jar with the help of Maven:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/3186ca6c-7136-4038-a045-1d2fb3a795f5.jpg" style="width:34.92em;height:36.92em;"/></div>
<p>Click the <span class="packt_screen">Maven Projects</span> button to the right of your project IDE screen and select <span class="packt_screen">messenger-api</span> | <span class="packt_screen">Lifecycle</span> | <span class="packt_screen">package</span>.&#160;A project jar will be packaged and stored in the target directory of the project.</p>
<p>Now go back to AWS and choose this jar file as the source file to be uploaded. Leave other properties as they are and click <span class="packt_screen">Next</span>.&#160; You may have to wait for a few minutes while the packaged jar is uploaded. Once the upload is done, you will be taken to a new screen where your environment information is presented to you. Proceed through the next few screens by clicking <span class="packt_screen">Next</span>&#160;until you are presented with a <span class="packt_screen">Configuration Details</span>&#160;screen. Change the instance type to <kbd>t2.micro</kbd>.</p>
<p>Proceed through the next screens until you reach the <span class="packt_screen">Review Information</span>&#160;section. Scroll through this page until you reach the <span class="packt_screen">Environment Info</span>&#160;section:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/bf72acae-808a-46c9-89a5-5f403f33e0d9.jpg" style="width:66.08em;height:10.75em;"/></div>
<p><span>Your environment URL will differ. Take note of this information as you will need it later on. Scroll to the bottom of the web page and click <span class="packt_screen">Launch</span>. Elastic Beanstalk will launch your new environment.</span></p>
<p>Once the launch finishes, you are good to go. You have successfully deployed the <kbd>messenger-api</kbd> to AWS.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we explored how to utilize Kotlin to build a Spring Boot REST application programming interface. In the process of doing so, we learned the basics of designing systems. We expressed the behavior of the messenger API system with a state diagram, and learned how to properly interpret the information represented in a state diagram. We went one step further by creating an E-R diagram to give a detailed diagrammatic representation of system entities and their relationships.</p>
<p>In addition, we learned how to set up PostgreSQL on a local machine and create a new PostgreSQL database. We also explored how to build a microservice with Spring Boot 2.0,&#160;<span>connect the microservice to a database, and interact with data existing in a database with Spring Data.</span></p>
<p>Besides all this, we learned how to properly secure a RESTful Spring Boot web application with Spring Security and <strong>JSON Web Tokens</strong> (<strong>JWTs</strong>). We created custom Spring Security configurations to facilitate user authentication with the help of JWTs and created custom filters for the authentication process. Lastly, we learned how to deploy a Spring Boot application to AWS.</p>
<p>In the next chapter, you will explore Kotlin further in the Android domain by building the Android<span>&#160;messenger</span> application.</p>


            </article>

            
        </section>
    </div>
</body>
</html>