- en: Chapter 8. Interacting with the Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。与网络交互
- en: So far, we have been using the HttpURLConnection HTTP client to transfer data
    from and to the network, such as when downloading images from an HTTP server and
    synchronizing information with a remote HTTP server. We have been using this Android
    HTTP client blindly without going into much detail about the internals and the
    features provided by this handy framework that deals transparently with the HTTP
    protocol for us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 HttpURLConnection HTTP 客户端来在网络之间传输数据，例如从 HTTP 服务器下载图像以及与远程 HTTP
    服务器同步信息。我们一直在盲目地使用这个 Android HTTP 客户端，而没有深入了解其内部结构和提供的功能，这个框架为我们透明地处理 HTTP 协议。
- en: In this chapter, we'll learn more about the advanced features of HttpURLConnection
    and fresh techniques to communicate asynchronously and securely with a remote
    server using the HTTP protocol.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解 HttpURLConnection 的高级功能以及使用 HTTP 协议异步和安全地与远程服务器通信的新技术。
- en: In the meantime, we will learn how use a customized HTTP client to communicate
    over secure channels, tweak the HTTP client to deal with network delays, and learn
    how to interact with web APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们将学习如何使用定制的 HTTP 客户端通过安全通道进行通信，调整 HTTP 客户端以处理网络延迟，以及如何与 Web API 交互。
- en: 'In this chapter, we will cover the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Introducing Android HTTP clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Android HTTP 客户端
- en: Performing HTTP requests asynchronously
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步执行 HTTP 请求
- en: Interacting with JSON web APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 JSON Web API 交互
- en: Interacting with XML web APIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 XML Web API 交互
- en: Optimizing HTTP timeouts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化 HTTP 超时
- en: Communicating securely over SSL sessions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 SSL 会话安全通信
- en: HTTP open source libraries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 开源库
- en: Introducing Android HTTP clients
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Android HTTP 客户端
- en: In recent times, the ability to send and receive data from remote servers has
    become an essential feature that all applications should enforce in order to create
    dynamic and impressive experiences. Today almost every application uses the network
    to pull up data information, execute remote business logic operations, and download
    or upload resources.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，从远程服务器发送和接收数据的能力已成为所有应用程序都应该强制执行的基本功能，以创建动态和令人印象深刻的体验。今天，几乎每个应用程序都使用网络来检索数据信息，执行远程业务逻辑操作，以及下载或上传资源。
- en: The network interactions that happen between the application and a remote server
    are typically defined as a set of request/response messages that traverse the
    network using a network protocol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序与远程服务器之间的网络交互通常定义为一系列请求/响应消息，这些消息通过网络协议在网络中传输。
- en: 'In general, the HTTP protocol is often used to transport messages between each
    peer, and the Android SDK comes with two high-level HTTP clients available out
    of the box to send and receive data: `AndroidHttpClient` and `HttpURLConnection`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，HTTP 协议常用于在各个对等体之间传输消息，Android SDK 提供了两个高级 HTTP 客户端，可以直接发送和接收数据：`AndroidHttpClient`
    和 `HttpURLConnection`。
- en: The HTTP communication protocol is a stateless, standard text-based application
    protocol maintained by **Internet Engineering Task Force** (**IETF**) and the
    **World Wide Web Consortium** (**W3C**) and is widely used on the Internet to
    exchange data between a client, normally called a user agent, and a server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 通信协议是一个无状态的、基于文本的应用协议，由 **互联网工程任务组**（**IETF**）和 **万维网联盟**（**W3C**）维护，并在互联网上广泛用于在客户端（通常称为用户代理）和服务器之间交换数据。
- en: The protocol has undergone some improvements over time, but most servers and
    clients base their implementation on HTTP 1.1, a revision of the original HTTP
    1.0, which introduced the connection re-use feature and chunked transfer encoding
    to the original protocol.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该协议随着时间的推移进行了一些改进，但大多数服务器和客户端基于 HTTP 1.1 的实现，这是原始 HTTP 1.0 的修订版，它引入了连接重用功能和分块传输编码到原始协议中。
- en: 'In a typical HTTP flow, the client, the entity that initiates the operation,
    sends a request to the server over a connection and waits for the server''s response.
    On the other end, the server reads the request from the communication channel,
    processes the request, and sends a response back to the client. In the next figure,
    we can visualize a request and response example exchanged between peers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的 HTTP 流程中，客户端，即启动操作的实体，通过连接向服务器发送请求并等待服务器的响应。在另一端，服务器从通信通道读取请求，处理请求，并将响应发送回客户端。在下一图中，我们可以可视化两个对等体之间交换的请求和响应示例：
- en: '![Introducing Android HTTP clients](img/Image_B05062_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Android HTTP 客户端](img/Image_B05062_08_01.jpg)'
- en: The new HTTP revision, 2.0, published in May 2015, hasn't been widely adopted
    and there is no official support on the Android SDK.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年5月发布的新的HTTP修订版2.0尚未得到广泛采用，并且在Android SDK中没有官方支持。
- en: After a preliminary HTTP protocol introduction, we will try to compare the HTTP
    clients available on the Android SDK.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在初步介绍HTTP协议之后，我们将尝试比较Android SDK上可用的HTTP客户端。
- en: AndroidHttpClient
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AndroidHttpClient
- en: The `AndroidHttpClient` client library, based on the Apache HTTP client, has
    been deprecated since API Level 9 (Gingerbread), but it provides a large and flexible
    API to access HTTP servers with support for cookie management, timeout customization,
    basic authentication schemes, and secure communication channels.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Apache HTTP客户端的`AndroidHttpClient`客户端库自API级别9（姜饼）以来已被弃用，但它提供了一个大而灵活的API，用于支持cookie管理、超时自定义、基本身份验证方案和安全通信通道的HTTP服务器访问。
- en: This client is more stable than `HttpURLConnection` on API Level 8 (Froyo) and
    API Level 7 (Eclair).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在API级别8（蜂巢）和API级别7（闪电）上，此客户端比`HttpURLConnection`更稳定。
- en: On API Level 23 (Marshmallow), support for this client has been removed in favor
    of `HttpURLConnection` due to the lack of transparent response compression and
    response caching.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在API级别23（棉花糖）中，由于缺乏透明的响应压缩和响应缓存，已移除对此客户端的支持，转而使用`HttpURLConnection`。
- en: HttpURLConnection
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HttpURLConnection
- en: This client framework supports secure communication sessions (HTTPS), transparent
    response compression, response caching, network timeout customization, network
    connection polling, IPV6 support, proxy servers, and streaming.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此客户端框架支持安全通信会话（HTTPS）、透明的响应压缩、响应缓存、网络超时自定义、网络连接轮询、IPv6支持、代理服务器和流式传输。
- en: According to Google, prior to API Level 8 (Froyo), this client has some important
    issues that could spoil the HTTP connection re-use.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Google的说法，在API级别8（蜂巢）之前，此客户端存在一些重要问题，可能会破坏HTTP连接的重用。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since Android 4.4 (KitKat), this implementation engine is based on the open
    source OkHttp Square library.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 4.4（奇巧）以来，此实现引擎基于开源的OkHttp Square库。
- en: 'Given that `HttpURLConnection` is the HTTP client recommended by Google for
    Android versions greater than API Level 9, we will base our code examples on this
    HTTP client. However, this fragmentation issue can be surpassed by using different
    Android HTTP clients based on the API Level:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`HttpURLConnection`是Google为API级别9以上的Android版本推荐的HTTP客户端，因此我们将基于此HTTP客户端编写代码示例。然而，通过使用基于API级别的不同Android
    HTTP客户端，我们可以超越这种碎片化问题：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the next section, we will start to write our HTTP asynchronous toolkit based
    on `HttpURLConnection` and explore the advanced features delivered by the client
    to communicate with remote peers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始编写基于`HttpURLConnection`的HTTP异步工具包，并探索客户端提供的先进功能，以与远程对等方进行通信。
- en: Performing HTTP requests asynchronously
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步执行HTTP请求
- en: So far we have been using the `HttpURLConnection` client and `AsyncTask` to
    retrieve remote data asynchronously in our code examples.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`HttpURLConnection`客户端和`AsyncTask`在我们的代码示例中异步检索远程数据。
- en: While this solution can work in most cases, we could end up with loads of duplicate
    code in our applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此解决方案在大多数情况下可以工作，但我们可能会在我们的应用程序中产生大量的重复代码。
- en: In this section, we will create a neat high-level asynchronous HTTP client to
    perform remote requests outside of the main thread that forwards the result of
    the request to the application's main thread using a callback handler. This approach
    fits well with the application UI model because the callback handler, which executes
    on the main thread, is able to update the UI with the data retrieved from the
    server.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个整洁的高级异步HTTP客户端，以在主线程之外执行远程请求，并使用回调处理程序将请求的结果转发到应用程序的主线程。这种方法与应用程序UI模型很好地配合，因为执行在主线程上的回调处理程序能够使用从服务器检索的数据更新UI。
- en: 'First of all, let''s define the basic interface that our asynchronous client
    should honor to execute remote requests in the background:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的异步客户端应该遵守的基本接口，以在后台执行远程请求：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `HTTPRequest` class is a Java model used to define all the parameters required
    to build the HTTP request. We will omit some of the implementation details, but
    with the help of the `Builder` class, we will be able to define the HTTP request
    verb, the request URL, the HTTP headers, the HTTP query parameters, and the HTTP
    body:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPRequest`类是一个Java模型，用于定义构建HTTP请求所需的所有参数。我们将省略一些实现细节，但借助`Builder`类，我们将能够定义HTTP请求动词、请求URL、HTTP头、HTTP查询参数和HTTP正文：'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`ResponseHandler` is the class that defines the callbacks that will be invoked
    when a success or failure response is sent from the server, or an exception happens
    during the operation execution. So, we''ll define an abstract `ResponseHandler`
    class for the subclasses to implement:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseHandler` 是一个类，它定义了当服务器发送成功或失败响应，或者在操作执行过程中发生异常时将被调用的回调。因此，我们将定义一个抽象的
    `ResponseHandler` 类供子类实现：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All callback methods are forwarded automatically to the main thread when a response
    or an error is ready to be dispatched to the handler. All the network and input/output
    operations and memory allocations have to be done on the background thread to
    avoid any UI undesired pauses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当响应或错误准备好被发送到处理器时，所有回调方法都会自动转发到主线程。所有网络和输入/输出操作以及内存分配都必须在后台线程上完成，以避免任何 UI 不希望的暂停。
- en: When the server returns an HTTP response, one of the following methods, `onSuccess`
    or `OnFailure`, is invoked based on the code returned by the response message.
    So, when any of the callbacks are called, an `HTTPResponse` object is delivered
    for further processing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器返回 HTTP 响应时，根据响应消息返回的代码，将调用以下方法之一，`onSuccess` 或 `OnFailure`。因此，当任何回调被调用时，将传递一个
    `HTTPResponse` 对象以进行进一步处理。
- en: 'For now, the `HTTPResponse` class carries information about the request code,
    the response headers, and the response body:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`HTTPResponse` 类携带有关请求代码、响应头和响应体的信息：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the base classes and interface already defined, let's implement our asynchronous
    high-level client with the help of the `HttpURLConnection` class.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了基类和接口后，让我们在 `HttpURLConnection` 类的帮助下实现我们的异步高级客户端。
- en: 'Since we already know how to construct a background-processing pipeline based
    on the `AsyncTask` class, for simplicity, we will base our implementation on this
    construct. In the future, you can replace `AsyncTask` with `AsyncTaskLoader` to
    support configuration changes:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经知道如何基于 `AsyncTask` 类构建后台处理管道，为了简单起见，我们将基于这个结构实现我们的实现。将来，你可以用 `AsyncTaskLoader`
    替换 `AsyncTask` 以支持配置更改：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As defined in the preceding code, the input parameter type for our `AsyncTask`
    is `HTTPRequest` and as a result an object of type `Result<HTTPResponse>` is sent
    to the UI thread. The result, is a generic class, as defined in previous chapters,
    that is able to carry an error or an `HTTPResponse` object.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们的 `AsyncTask` 的输入参数类型是 `HTTPRequest`，因此将一个类型为 `Result<HTTPResponse>`
    的对象发送到 UI 线程。结果是一个泛型类，如前几章所述，它能够携带错误或 `HTTPResponse` 对象。
- en: 'With the `HTTPAsyncTask` generic parameters already defined, now it is time
    to override `doInBackground` to send the HTTP request and process the response
    in the background:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 已经定义了 `HTTPAsyncTask` 的泛型参数后，现在是我们重写 `doInBackground` 以在后台发送 HTTP 请求并处理响应的时候了：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`openConnection` will establish a TCP connection with the resource specified
    in the `URL` object. Once the connection is established, and we try to retrieve
    the status line response code, our HTTP request headers and body are dispatched
    to the network.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`openConnection` 将与 `URL` 对象中指定的资源建立 TCP 连接。一旦建立连接，并且我们尝试检索状态行响应代码时，我们的 HTTP
    请求头和体被发送到网络。'
- en: As soon as the status line is read, we process the HTTP response headers received
    and we store them on our response object for further processing. As you probably
    already know, an HTTP response might contain data on the HTTP message body, related
    to the resource specified on the requested URL.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读取到状态行，我们就处理接收到的 HTTP 响应头，并将它们存储在我们的响应对象中以供进一步处理。你可能已经知道，HTTP 响应可能包含与请求 URL
    上指定的资源相关的 HTTP 消息体数据。
- en: For further processing, the data will be consumed from the connection `InputStream`
    in order to build a `Body` object. To detect the type of data content received
    on the HTTP Response, the client should look into the header Content-Type content.
    To simplify this recognition, the `HttpURLConnection` class provides the member
    method, `getContentType()`, that retrieves the content directly from the header.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步处理，数据将从连接的 `InputStream` 中消费，以构建一个 `Body` 对象。为了检测在 HTTP 响应中接收到的数据内容类型，客户端应该查看头
    Content-Type 的内容。为了简化这种识别，`HttpURLConnection` 类提供了一个成员方法 `getContentType()`，它直接从头中检索内容。
- en: 'The body consumption and construction is done on the `BodyFactory` class shown
    in the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 体的消费和构建是在以下代码中显示的 `BodyFactory` 类上完成的：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Since we know the content type, we are ready to consume the body and store the
    bytes received on a `Body` object for further processing by our `ResponseHandler`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道内容类型，我们准备好消费体并存储在 `Body` 对象上接收的字节，以便由我们的 `ResponseHandler` 进行进一步处理。
- en: '`Body` is an abstract class and itself is not able to read any kind of content,
    although we can extend the `Body` class directly to build a text body from the
    received data.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body` 是一个抽象类，它本身无法读取任何类型的内容，尽管我们可以直接扩展 `Body` 类来从接收到的数据构建文本体。'
- en: 'Our `Body` subclass, called `TextPlainBody`, will implement the abstract consume
    function in order to construct the body from the `InputStream`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Body` 子类，称为 `TextPlainBody`，将实现抽象的 consume 函数，以便从 `InputStream` 构建体。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The consume code for the `TextPlainBody` is omitted for brevity, though the
    full source code is available to download from the Packt Publishing website. Take
    a look at the `TextPlainBody` source code to appreciate how we build a string
    using the `InputStream`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，省略了 `TextPlainBody` 的消费代码，尽管完整的源代码可以从 Packt Publishing 网站下载。查看 `TextPlainBody`
    的源代码，以了解我们如何使用 `InputStream` 构建字符串。
- en: For now, we only support the `text/*` type; however, in the next sections we
    are going to extend the `BodyFactory` class to support other interesting mime
    types, such as JSON documents.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只支持 `text/*` 类型；然而，在接下来的章节中，我们将扩展 `BodyFactory` 类以支持其他有趣的 MIME 类型，例如 JSON
    文档。
- en: Once the response body has been fully read, the connection with the remote server
    will be closed and the resources held by the connection released.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完全读取响应体，与远程服务器的连接将被关闭，并且释放连接持有的资源。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The connection is not immediately destroyed but rather pushed to a connection
    pool for future use. After a finite amount of time idle (`idleTimeout`) on the
    pool, the connection is destroyed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 连接不会立即被销毁，而是推送到连接池以供将来使用。在池中空闲一定时间（`idleTimeout`）后，连接将被销毁。
- en: During the `doInBackground` execution, network or input/output exceptions are
    likely to arise, so to avoid an application crash we must catch and forward them
    over the `result.error` to the `postExecute` function and later to the `ResponseHandler`
    specified when the execution is initiated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `doInBackground` 执行期间，可能会出现网络或输入/输出异常，为了避免应用程序崩溃，我们必须捕获并将它们通过 `result.error`
    传递给 `postExecute` 函数，然后传递给在执行开始时指定的 `ResponseHandler`。
- en: Unchecked exceptions that propagate out of AsyncTask's methods will crash our
    application, so we must test carefully and handle those if necessary.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从 AsyncTask 的方法中传播的未检查异常将使我们的应用程序崩溃，因此我们必须仔细测试并在必要时处理这些异常。
- en: 'To make our `AsyncTask` subclass useful, we have to write the `onPostExecute`
    function that forwards the response or an error to the `ResponseHandler` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 `AsyncTask` 子类有用，我们必须编写 `onPostExecute` 函数，将响应或错误转发到 `ResponseHandler`
    对象：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As stated before in [Chapter 3](ch03.html "Chapter 3. Exploring the AsyncTask"),
    *Exploring AsyncTask*, the `onPostExecute` callback will be executed on the main
    thread, so you should avoid any time-consuming operations on the following callbacks:
    `onError`, `onSucess`, and `onFailure`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 [第 3 章](ch03.html "第 3 章。探索 AsyncTask") 中，*探索 AsyncTask*，`onPostExecute`
    回调将在主线程上执行，因此你应该避免在以下回调中进行任何耗时操作：`onError`、`onSucess` 和 `onFailure`。
- en: 'All that remains is to invoke our `AsyncTask` from our `AsyncHTTPClient` subclass—`PacktAsyncHTTPClient`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是调用我们的 `AsyncTask`，来自我们的 `AsyncHTTPClient` 子类—`PacktAsyncHTTPClient`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Great! Now we have a core asynchronous HTTP client implementation with support
    for text mime types. In the next section we will use our high-level client to
    retrieve a text message from a remote server.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们有一个支持文本 MIME 类型的核心异步 HTTP 客户端实现。在下一节中，我们将使用我们的高级客户端从远程服务器检索文本消息。
- en: Retrieving a text response
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取文本响应
- en: With our asynchronous HTTP client supporting text responses, we are able to
    make use of it to obtain a dynamic text so, let's create an activity that displays
    the text available on a remote URL resource.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用支持文本响应的异步 HTTP 客户端，我们能够利用它来获取动态文本，因此让我们创建一个活动来显示远程 URL 资源上可用的文本。
- en: 'First, we have to build our `HTTPRequest` using the `HTTPRequest.Builder` class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须使用 `HTTPRequest.Builder` 类构建我们的 `HTTPRequest`：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We wish to draw your attention to the fact that you should replace `<hostname>`
    and `<port>` to make it work for your HTTP server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望引起您的注意，您应该将 `<hostname>` 和 `<port>` 替换为使其适用于您的 HTTP 服务器。
- en: As defined before, in order to execute the request over our asynchronous client,
    `AsyncHTTPClient`, we must provide a `ResponseHandler` object to the `execute`
    method. Moreover, we want to define an object that updates the UI with the text
    obtained.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了在我们的异步客户端`AsyncHTTPClient`上执行请求，我们必须向`execute`方法提供一个`ResponseHandler`对象。此外，我们还想定义一个对象，该对象使用获取到的文本更新UI。
- en: 'First of all, we will extend our `ResponseHandler` abstract and create a class
    to process the body and forward the response to a callback that receives the text
    message as the input:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将扩展我们的`ResponseHandler`抽象类，创建一个类来处理体内容，并将响应转发给接收文本消息作为输入的回调。
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, we need to finish our `Activity` code to send the HTTP request and in
    the meantime we will also present a progress dialog making the user aware that
    something is going on in the background:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要完成我们的`Activity`代码以发送HTTP请求，同时我们还将显示一个进度对话框，让用户意识到后台正在进行某些操作：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, all we need is to define our `textResponseHandler`, an anonymous inner
    class that implements `TextReponseHandler`, updates the `View` with the `String`
    received, and dismisses the indeterminate progress dialog enabled:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要定义我们的`textResponseHandler`，这是一个实现了`TextReponseHandler`的匿名内部类，它更新`View`以显示接收到的字符串，并关闭已启用的不确定进度对话框：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Notice that all the callback functions are going to be executed on the main
    thread, so in these functions you should follow the golden rule of not blocking
    the thread to avoid UI delays.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有回调函数都将在主线程上执行，因此在这些函数中，你应该遵循黄金法则，不要阻塞线程，以避免UI延迟。
- en: When the server returns an error or an exception happens during the execution,
    the following callback methods, `onFailure` and `OnError`, are called respectively.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器返回错误或在执行过程中发生异常时，分别调用以下回调方法，`onFailure`和`OnError`。
- en: Support for reading text resources from a remote server is a good starting point,
    although in most cases we intend to communicate with the remote server to exchange
    structured document formats, such as JSON, XML, or even binary data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从远程服务器读取文本资源支持是一个良好的起点，尽管在大多数情况下，我们打算与远程服务器通信以交换结构化文档格式，例如JSON、XML，甚至是二进制数据。
- en: Interacting with JSON web APIs
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与JSON Web API交互
- en: Our previous `TextResponseHandler` is able to process the generic response `HTTPResponse`
    fulfilled with a text response and forward a String coming from JSON web APIs
    and forward a `String` to the `TextResponseHandler onReceive(String)` callback.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的`TextResponseHandler`能够处理填充有文本响应的通用响应`HTTPResponse`，并将来自JSON Web API的字符串转发给`TextResponseHandler
    onReceive(String)`回调。
- en: Now we want to go a little further and convert an `HTTPResponse` returned from
    the `doInBackground` to a **Plain Old Java Object** (**POJO**) that characterizes
    a model on our business logic. To achieve that, we must convert a JSON-structured
    content returned on the HTTP body to one Java defined previously.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想更进一步，将`doInBackground`返回的`HTTPResponse`转换为表示我们业务逻辑中模型的**普通Java对象**（**POJO**）。为了实现这一点，我们必须将HTTP体上返回的JSON结构化内容转换为之前定义的Java对象。
- en: 'To forward the processing to the callbacks defined above, we will create the
    `JSONResponseHandler`, an abstract subclass of `ResponseHandler` that implements
    `onSuccess(HTTPResponse)`, `onFailure(HTTPResponse)`, and convert the objects
    to `<ResponseType>` and `<ErrorType>` respectively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将处理转发到上面定义的回调，我们将创建`JSONResponseHandler`，它是`ResponseHandler`的抽象子类，实现了`onSuccess(HTTPResponse)`、`onFailure(HTTPResponse)`，并将对象分别转换为`<ResponseType>`和`<ErrorType>`。
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To support the processing of different body contents, our `BodyFactory` needs
    an update. So, before we move on to the `JSONResponseHandler` implementation,
    we will update our `BodyFactory` function to support the `application/json` mimetype:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持不同体内容的处理，我们的`BodyFactory`需要更新。因此，在我们继续到`JSONResponseHandler`实现之前，我们将更新我们的`BodyFactory`函数以支持`application/json`媒体类型：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that we read the content from the network and we store the data on a
    new `Body` class named `RawBody` that simply stores the content that comes from
    the HTTP Response body on an internal byte memory buffer.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们从网络读取内容，并将数据存储在一个名为`RawBody`的新`Body`类中，该类简单地存储来自HTTP响应体的内容，在一个内部字节数据缓冲区中。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Storing the full body might work for our simple client use cases. Although,
    if we are willing to process bodies with megabytes of data, we must use another
    strategy to read and consume the body, consume the body in chunks, or save the
    body on a local filesystem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 存储整个体可能适用于我们的简单客户端用例。尽管如此，如果我们愿意处理具有兆字节数据的体，我们必须使用另一种策略来读取和消费体，分块消费体，或将体保存到本地文件系统中。
- en: With the body already with JSON web APIs stored on the device memory, we are
    ready to process it with the help of our `JSONResponseHandler`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备内存中已经存储了带有JSON Web API的体之后，我们准备好使用我们的`JSONResponseHandler`来处理它。
- en: Converting Java objects to JSON
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Java对象转换为JSON
- en: 'To convert the JSON document format to a plain object we will make use of one
    open source library that''s very well known in the Android community—the Google
    GSON library: [https://github.com/google/gson](https://github.com/google/gson).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将JSON文档格式转换为普通对象，我们将使用一个在Android社区中非常著名的开源库——Google GSON库：[https://github.com/google/gson](https://github.com/google/gson)。
- en: The GSON library, a library developed and maintained by Google, is able to convert
    Java objects to a JSON object and vice versa.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: GSON库，这是一个由Google开发和维护的库，能够将Java对象转换为JSON对象，反之亦然。
- en: 'So, before you move on, make sure that you add the library to your Gradle or
    Eclipse project:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你继续之前，请确保将库添加到你的Gradle或Eclipse项目中：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To convert from a protocol encoded content body to a POJO, we will define the
    `BodyDecoder` interface:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将协议编码的内容体转换为POJO，我们将定义`BodyDecoder`接口：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To convert from a POJO to a `Body` object, we are going to define the `BodyEncoder`
    interface:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将POJO转换为`Body`对象，我们将定义`BodyEncoder`接口：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To decode a JSON document to a POJO, we will have to subclass this generic
    interface and write the code to deal with the JSON decoding with the help of the
    GSON library:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将JSON文档解码为POJO，我们必须继承这个泛型接口，并编写代码来使用GSON库处理JSON解码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we are ready to implement our generic `JSONResponseHandler` that forwards
    the converted JSON-structured documents returned on the `onSuccess` and `onFailure`
    methods to the generic types `Response` and `Error`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好实现我们的泛型`JSONResponseHandler`，它将`onSuccess`和`onFailure`方法返回的转换后的JSON结构文档转发到泛型类型`Response`和`Error`。
- en: 'Here is how the `JsonResponseHandler` code will look:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`JsonResponseHandler`代码的示例：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This generically typed class is able to consume the `RawBody` object forwarded
    from `onSuccess` or `onFailure` and expose two generic type parameters. The first
    `Response` is a generic type that specifies the type of POJO class for the success
    response (`onSuccess`) and the `Error` generic type that specifies the type of
    POJO class for the error function (`onFailure`).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个泛型类能够消费从`onSuccess`或`onFailure`传递过来的`RawBody`对象，并暴露两个泛型类型参数。第一个`Response`是一个泛型类型，它指定了成功响应（`onSuccess`）的POJO类类型，而`Error`泛型类型指定了错误函数（`onFailure`）的POJO类类型。
- en: When any of the callback functions that receive the `HTTPResponse` is invoked,
    with the help of the GSON library we convert the JSON document, stored on the
    `RawBody`, to a response/error object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何接收`HTTPResponse`的回调函数被调用时，借助GSON库，我们将存储在`RawBody`上的JSON文档转换为响应/错误对象。
- en: The `onFailure` function is omitted because its code is quite similar to the
    `onSuccess` method; however, you can take a look at the full source code on the
    Packt Publishing website to understand the differences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`onFailure`函数被省略了，因为它的代码与`onSuccess`方法非常相似；然而，你可以在Packt Publishing网站上查看完整的源代码以了解差异。'
- en: 'Finally, we are ready to exercise our asynchronous client by reading a model
    from an HTTP JSON body:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备好通过从HTTP JSON体中读取一个模型来测试我们的异步客户端：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To test our client we will take advantage of `JSONPlaceHolder` ([http://jsonplaceholder.typicode.com/](http://jsonplaceholder.typicode.com/)),
    a fake online REST API for testing and prototyping.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的客户端，我们将利用`JSONPlaceHolder`（[http://jsonplaceholder.typicode.com/](http://jsonplaceholder.typicode.com/)），一个用于测试和原型设计的假在线REST
    API。
- en: 'Before we try to access it, let''s define the `User` POJO class that we will
    use in our example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试访问它之前，让我们定义我们将用于示例的`User` POJO类：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And we will define a POJO class for the `failure` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为`failure`函数定义一个POJO类：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To display the models returned from the fake API, we'll create a new `UserListActivity`
    that will implement `JSONResponseHandler` and display the name and the e-mail
    of all the users with the JSON document returned from [http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示从模拟API返回的模型，我们将创建一个新的`UserListActivity`，该活动将实现`JSONResponseHandler`并显示所有用户的姓名和电子邮件，这些信息由从[http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users)返回的JSON文档提供。
- en: Let's start by defining the `JsonResponseHandler<List<User>,Error>` anonymous
    class that receives a list of users as an argument , `List<User>`, for the success
    callback and an `Error` object as the argument for the failure callback.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义一个`JsonResponseHandler<List<User>,Error>`匿名类，该类接收一个用户列表作为成功回调的参数`List<User>`，以及一个`Error`对象作为失败回调的参数。
- en: '`onSuccess(List<User>)` will update a `ListView` that displays the name followed
    by the e-mail:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSuccess(List<User>)`将更新一个显示姓名后跟电子邮件的`ListView`：'
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'All that remains is to write the Activity''s `onCreate` function that builds
    up the HTTP Request and dispatches the request, GET /users, to the `JSONPlaceHolder`
    API:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是编写Activity的`onCreate`函数，该函数构建HTTP请求并将请求GET /users分派给`JSONPlaceHolder` API：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When the server sends back a response to our request, the `JSONResponseHandler`
    object will decode the JSON document with a list of 10 users and convert the document
    to a `List<User>` object.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器向我们请求发送响应时，`JSONResponseHandler`对象将解码包含10个用户的JSON文档，并将文档转换为`List<User>`对象。
- en: The JSON data exchange format has predominantly been used on most recent APIs
    and web services deployed on the Internet because of its simplicity, readability,
    compactness, and lack of data structure rigidity.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据交换格式因其简单性、可读性、紧凑性和缺乏数据结构刚性，在互联网上部署的大多数最近API和Web服务中得到了广泛使用。
- en: However, XML-based remote web services, mainly based on the SOA data exchange
    protocol, are still around to cover advanced use cases where we want to have stricter
    data model schema validation and modelling, built-in namespace support, and advanced
    information extraction tools.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于XML的远程Web服务，主要基于SOA数据交换协议，仍然存在，以覆盖我们想要有更严格的数据模型模式验证和建模、内置命名空间支持和高级信息提取工具的高级用例。
- en: XML-based APIs have lost some traction in the industry, although the XML-based
    APIs are still common, so in the next section we will extend our toolkit to support
    the encoding and decoding of XML content on our HTTP requests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于XML的API仍然很常见，但基于XML的API在行业中已经失去了一些吸引力，因此在下一段中，我们将扩展我们的工具集以支持在HTTP请求上对XML内容的编码和解码。
- en: Interacting with XML web APIs
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与XML Web API交互
- en: Over the last 10 years, XML message-based APIs have been successfully used to
    exchange data (SOAP) and run remote procedures (XML-RPC) between applications
    and remote servers. Moreover, nowadays, some REST APIs are built with JSON and
    XML support, so it's up to the developer to decide whether they want to interact
    with the API using XML or JSON documents.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的10年里，基于XML的消息API已经成功用于在应用程序和远程服务器之间交换数据（SOAP）和运行远程过程（XML-RPC）。此外，如今，一些REST
    API使用JSON和XML支持构建，因此开发者需要决定他们是否想使用XML或JSON文档与API交互。
- en: With this in mind, we will extend our toolkit to exchange XML messages in order
    to communicate with the remote server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个想法的指导下，我们将扩展我们的工具集以交换XML消息，以便与远程服务器通信。
- en: In the preceding sections, we implemented a `ResponseHandler` to decode JSON
    documents sent on the HTTP body, but now we want to go further and add support
    for sending XML documents on the HTTP Request.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们实现了一个`ResponseHandler`来解码HTTP主体上发送的JSON文档，但现在我们想要更进一步，添加对在HTTP请求中发送XML文档的支持。
- en: 'If we go back into our `HTTPAsyncTask` details, the code required to support
    body transmissions on the request was lacking; therefore, this is the perfect
    time to rewrite the code to carry an entity body on the HTTP request:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下`HTTPAsyncTask`的细节，支持请求体传输所需的代码缺失；因此，这是重写代码以携带HTTP请求实体体的完美时机：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, when a body is available on the `HTTPRequest` object
    and before we try to read the `responseCode` of the response status line, we retrieve
    the output stream from the `HttpURLConnection` and we write the content stored
    on the `Body` object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当`HTTPRequest`对象上有可用体时，在我们尝试读取响应状态行的`responseCode`之前，我们从`HttpURLConnection`检索输出流，并将存储在`Body`对象上的内容写入。
- en: Apart from the data written, the header `Context-Type` is set on the HTTP request
    header section based on the body's mimetype.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了写入的数据外，`Context-Type` 标头根据正文的多媒体类型设置在 HTTP 请求头部分。
- en: Now, we are ready to send and receive entity bodies on the HTTP request and
    response respectively, so now we can start to work on our XML implementation example.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好在 HTTP 请求和响应中发送和接收实体体，因此现在我们可以开始编写我们的 XML 实现示例。
- en: In the next paragraphs, and following the JSON section, we will write the code
    to serialize an API Request into an XML document and the code to de-serialize
    XML documents, received on response, to an API Response object.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，并遵循 JSON 部分，我们将编写将 API 请求序列化为 XML 文档的代码，以及将接收到的 XML 文档反序列化为 API 响应对象的代码。
- en: Converting Java objects to XML
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Java 对象转换为 XML
- en: To de-serialize and serialize from Java objects to XML and vice-versa, we will
    use the open source library SimpleXML ([http://simple.sourceforge.net/](http://simple.sourceforge.net/));
    therefore, to make use of it, please add this library to your application list
    of external dependencies.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 Java 对象反序列化和序列化到 XML 以及反之亦然，我们将使用开源库 SimpleXML ([http://simple.sourceforge.net/](http://simple.sourceforge.net/))；因此，为了使用它，请将此库添加到您的应用程序外部依赖项列表中。
- en: 'If you use Android Studio, here is the content to add to your `build.gradle`
    list of dependencies:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Android Studio，以下是在您的 `build.gradle` 依赖项列表中需要添加的内容：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With the `User` model defined previously we will build up a `APIRequest` named
    `GetUserInfo` that will get the user details (`GetUserInfoResponse`) for the user
    identifier submitted in the request.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了 `User` 模型之后，我们将构建一个名为 `GetUserInfo` 的 `APIRequest`，它将获取请求中提交的用户标识符的用户详细信息（`GetUserInfoResponse`）。
- en: 'To describe this further, let''s define the API Request POJO objects:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步描述，让我们定义 API 请求 POJO 对象：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And let''s define the API Response POJO object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义 API 响应 POJO 对象：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The annotation for the other classes, `User`, `Address`, and `Company`, are
    quite similar to the ones above, with all the elements referring to the `https://www.packtpub.com/asynchronous_android`
    namespace, hence we will omit the POJO changes for brevity.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他类，如 `User`、`Address` 和 `Company` 的注解与上面类似，所有元素都引用了 `https://www.packtpub.com/asynchronous_android`
    命名空间，因此为了简洁，我们将省略 POJO 的更改。
- en: With the mapping between the Java objects and XML Request and response message
    finished, let's start to work on the code that converts the `GetUserInfo` object
    into an XML document.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 Java 对象与 XML 请求和响应消息之间的映射后，让我们开始编写将 `GetUserInfo` 对象转换为 XML 文档的代码。
- en: 'To encode an XML document from a Java object, we will subclass this generic
    interface to encode a POJO generic type into an XML document with the help of
    SimpleXML:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Java 对象编码为 XML 文档，我们将通过 SimpleXML 的帮助，将这个通用接口子类化，以将 POJO 通用类型编码到 XML 文档中：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Converting XML to Java objects
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 XML 转换为 Java 对象
- en: 'To decode an XML document to a Java POJO object we will add the `BodyDecoder<POJO>`
    to the `XMLConverter` class definition interface and write the code to convert
    the XML document to a POJO generic class with the help of the SimpleXML library:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 XML 文档解码为 Java POJO 对象，我们将向 `XMLConverter` 类定义接口中添加 `BodyDecoder<POJO>`，并编写使用
    SimpleXML 库将 XML 文档转换为 POJO 通用类的代码：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the XML serialization and deserialization already in place, let's start
    to write the activity that will retrieve the user information from a remote server
    using the `GetUserInfo` and `GetUserInfoResponse` defined above and display the
    user information on a UI.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 XML 序列化和反序列化已经就绪的情况下，让我们开始编写活动，该活动将使用上面定义的 `GetUserInfo` 和 `GetUserInfoResponse`
    从远程服务器检索用户信息，并在 UI 上显示用户信息。
- en: To test our client, we will create a fake XML WebService with the help of the
    mockable [https://www.mockable.io/](https://www.mockable.io/) web application.
    This web application allows us to create configurable REST APIs that return a
    static JSON or XML document as a response to the clients, so this tool will be
    extremely helpful to test our client in a controlled environment.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的客户端，我们将使用可模拟的 [https://www.mockable.io/](https://www.mockable.io/) 网络应用程序创建一个假
    XML WebService。这个网络应用程序允许我们创建可配置的 REST API，它返回静态 JSON 或 XML 文档作为对客户端的响应，因此这个工具将非常有助于在受控环境中测试我们的客户端。
- en: 'Our fake HTTP API will return the following XML document when any HTTP request
    is sent to the following URI, [http://demo1472539.mockable.io/GetUserInfo](http://demo1472539.mockable.io/GetUserInfo):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当向以下 URI 发送任何 HTTP 请求时，我们的假 HTTP API 将返回以下 XML 文档，[http://demo1472539.mockable.io/GetUserInfo](http://demo1472539.mockable.io/GetUserInfo)：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to convert the `HTTPResponse` objects received by the `onSuccess(HTTPRequest)`
    and `onFailure(HTTPResponse)` callbacks to domain models, we will have to subclass
    the `ResponseHandler` abstract class and create the code to de-serialize a generic
    POJO class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`onSuccess(HTTPRequest)`和`onFailure(HTTPResponse)`回调接收到的`HTTPResponse`对象转换为领域模型，我们必须子类化`ResponseHandler`抽象类并创建反序列化通用POJO类的代码：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we are ready to collect the `GetUserInfoResponse` dispatched from our fake
    server, so let''s implement, on our Activity, an anonymous inner `XMLResponseHandler`
    subclass that will update the UI with user details:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好收集从我们的模拟服务器发出的`GetUserInfoResponse`，因此让我们在我们的`Activity`中实现一个匿名内部`XMLResponseHandler`子类，该子类将使用用户详细信息更新UI：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To finish our `Activity`, we will have to build the request and ask our asynchronous
    client to execute our demand in the background with the help of the `HTTPAsyncTask`
    class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的`Activity`，我们需要构建请求，并使用`HTTPAsyncTask`类帮助我们的异步客户端在后台执行我们的需求：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Once the response is returned from the fake server, the UI will be updated to
    show the user name, e-mail, and other properties, based on the XML specified on
    the fake endpoint.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从模拟服务器返回响应，UI将根据模拟端点指定的XML更新，以显示用户名、电子邮件和其他属性。
- en: 'Nothing is mentioned about the error flow; however, I will challenge you to
    create a fake endpoint that returns an error object to exercise the `onError`
    callback. The full source code with the error flow is available to download from
    the Packt Publishing website. Take a look at it to appreciate how error handling
    is implemented. The error XML document might be something similar to this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于错误流程没有提及；然而，我将挑战你创建一个返回错误对象的模拟端点，以练习`onError`回调。带有错误流程的完整源代码可以从Packt Publishing网站下载。看看它，以欣赏错误处理是如何实现的。错误XML文档可能类似于以下内容：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: So far, we have covered most common formats (Text, XML, and JSON) used in the
    industry to exchange data between HTTP clients and servers. Each of these formats
    has its own strengths; however, for its compactness and simplicity (easy parsing,
    syntax, and so on), the JSON format has been widely adopted by API designers,
    electronics manufacturers, and **Software as a Service** (**SaaS**) vendors.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了在HTTP客户端和服务器之间交换数据时在行业中使用的最常见格式（文本、XML和JSON）。每种格式都有其自身的优势；然而，由于其紧凑性和简单性（易于解析、语法等），JSON格式已被API设计者、电子产品制造商和**软件即服务（SaaS**）供应商广泛采用。
- en: During this process, we will build up a core framework that could be easily
    extended to support different data exchange formats, such as YAML or binary protocols.
    Therefore, you might write your own `BodyEncoder`, `BodyDecoder`, and `ResponseHandler`
    to fit a standard data format or even your own data format.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将构建一个核心框架，它可以很容易地扩展以支持不同的数据交换格式，如YAML或二进制协议。因此，你可能需要编写自己的`BodyEncoder`、`BodyDecoder`和`ResponseHandler`以适应标准数据格式，甚至是你自己的数据格式。
- en: In this section, we will introduce the reader to a set of timeouts available
    on the `HttpUrlConnection` used to accommodate network delays on the request execution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向读者介绍在用于处理请求执行中网络延迟的`HttpUrlConnection`上可用的超时设置。
- en: Customizing HTTP timeouts
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义HTTP超时
- en: When `HttpUrlConnection` connects, reads, or writes content over a low bandwidth
    network (2G, 3G, and so on), the exposure to unpredictable communication delays
    can not be avoided. Moreover, apart from the mobile network delays, the HTTP servers
    might introduce significant response delays (server latency) when they are experiencing
    high volumes of traffic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当`HttpUrlConnection`通过低带宽网络（2G、3G等）连接、读取或写入内容时，不可避免地会暴露于不可预测的通信延迟。此外，除了移动网络延迟外，当HTTP服务器在高流量情况下，可能会引入显著的服务延迟（服务器延迟）。
- en: Although the default timeout values used by the the `HttpUrlConnection` are
    long enough to cope with these delays, there are some special use cases where
    you might want to customize the default values according to your needs. For example,
    when on the way to the application server, the HTTP request travels through some
    proxies.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`HttpUrlConnection`使用的默认超时值已经足够长，可以应对这些延迟，但在某些特殊情况下，你可能需要根据你的需求自定义默认值。例如，当前往应用服务器时，HTTP请求会经过一些代理。
- en: '`HttpUrlConnection` offers us two member methods that can be used to change
    the default timeouts:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpUrlConnection`提供了两个成员方法，可以用来更改默认的超时时间：'
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`setConnectTimeout(int)` is able to redefine the maximum time in milliseconds
    that our client is allowed to wait until the TCP connection to the remote host
    is established (server is down). `ConnectTimeoutException` will be thrown whenever
    the connection fails, for example, if the server is down or is not able to respond
    in time due to lack of resources, so you should be careful and handle this exception
    cleanly in your code.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`setConnectTimeout(int)`能够重新定义客户端被允许等待的最大时间（以毫秒为单位），直到与远程主机的TCP连接建立（服务器关闭）。每当连接失败时，例如，如果服务器关闭或由于资源不足无法及时响应，将抛出`ConnectTimeoutException`，因此你应该小心处理这个异常，并在你的代码中干净地处理它。'
- en: When the hostname resolves into multiple addresses, the client will try to connect
    one after the other and the timeout will be applicable multiple times. If the
    timeout is set to `0`, the connection will be blocked until the TCP timeout expires,
    which on Android is normally several minutes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当主机名解析为多个地址时，客户端将依次尝试连接，超时将适用多次。如果超时设置为`0`，连接将被阻塞，直到TCP超时到期，在Android上这通常是几分钟。
- en: '`setReadTimeout(int)` defines the maximum time that our client is allowed to
    be blocked on the read operation until any available data is allowed to be read.
    The default value `0` will block the read operation indefinitely until data becomes
    available, the connection is dropped by the remote peer, or an error occurs on
    the socket. When the timeout is longer than `0` and no data is available when
    the timeout expires, a `SocketTimeoutException` will be thrown.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`setReadTimeout(int)`定义了客户端被允许在读取操作上阻塞的最大时间，直到允许读取任何可用数据。默认值`0`将无限期地阻塞读取操作，直到数据变得可用、远程对等方断开连接或套接字上发生错误。当超时时间大于`0`且超时到期时没有数据可用，将抛出`SocketTimeoutException`。'
- en: 'Now that we understand the meaning of each timeout, let''s update our `HTTPRequest.Builder`
    with some new setter methods:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了每个超时时间的含义，让我们更新我们的`HTTPRequest.Builder`，添加一些新的设置方法：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we have to update `HTTPAsyncTask` to set the timeouts specified on
    the `HTTPRequest`, on the `HttpURLConnection` object used to connect to the remote
    server:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须更新`HTTPAsyncTask`，以设置在`HTTPRequest`上指定的超时，在用于连接远程服务器的`HttpURLConnection`对象上：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It's highly recommended that you test your customized timeouts under several
    network latency levels and take into account the time that your server could defer
    the response for a couple of seconds when it is under load.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你在几个网络延迟级别下测试你自定义的超时设置，并考虑到当服务器负载时，它可能延迟响应几秒钟的时间。
- en: A typical network delay could go from 80-120 ms on an LTE mobile network to
    150-550 ms on a GPRS mobile network
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的网络延迟可能在LTE移动网络上从80-120毫秒到GPRS移动网络上的150-550毫秒不等。
- en: When you run your application on the Internet and you have to deal with sensitive
    data, such as personal information, payment information, or business documentation,
    it is really important to protect your communication channels with a security
    layer that hides the exchanged data from an outside attacker or avoids any spoofing
    attacks. In the next section, we will expand our high-level client to support
    a secure SSL connection channel to the remote server.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在互联网上运行应用程序并需要处理敏感数据，例如个人信息、支付信息或商业文件时，使用一层安全层来保护你的通信渠道，以隐藏交换的数据免受外部攻击者或避免任何欺骗攻击，这一点非常重要。在下一节中，我们将扩展我们的高级客户端以支持到远程服务器的安全SSL连接通道。
- en: Communicating securely over SSL sessions
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SSL会话中安全通信
- en: So far, we have been using plain connections to communicate with a remote HTTP
    server. Despite the fact that these kinds of connections might fit your application
    requirements when the data exchanged is not sensitive, there are use cases where
    we must use a secure channel to send or receive, preventing any third party from
    reading or changing the data exchanged on the network.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用普通连接与远程HTTP服务器进行通信。尽管这些类型的连接在交换的数据不敏感时可能符合你的应用程序需求，但有些情况下我们必须使用安全通道来发送或接收数据，以防止第三方读取或更改网络上交换的数据。
- en: In order to setup an SSL session with a remote server, our client, with the
    help of some cryptographic tools, will create a cryptographic communication channel
    where all the data is encrypted with a symmetric cipher that uses a secret key
    exchanged during the secure connection handshake. Apart from that, the content
    received and encrypted with a previously exchanged secret key is validated against
    other peer public keys to prove that the data is coming and signed from the right
    source.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与远程服务器设置SSL会话，我们的客户端在加密工具的帮助下将创建一个加密通信通道，其中所有数据都使用在安全连接握手期间交换的秘密密钥进行加密的对称加密。除此之外，使用先前交换的秘密密钥接收和加密的内容将与其他对等公钥进行验证，以证明数据是从正确的来源发送和签名的。
- en: During the connection establishment, as part of the SSL handshake, the server
    has to prove that it holds a private key for a trusted certificate. A trusted
    certificate is a certificate that is available from our list of trusted **Certificate
    Authorities** (**CA**s) or it was signed by one of the certificates available
    from your trusted CAs.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立连接的过程中，作为SSL握手的一部分，服务器必须证明它持有受信任证书的私钥。受信任的证书是指可以从我们的受信任**证书颁发机构**（**CA**s）列表中获取的证书，或者它是由您的受信任CA之一签发的。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Android platform comes out-of-the-box with a list of well-known trusted
    CAs that help us to assure the identity of most servers on the Internet.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台自带一组知名受信任的CA列表，帮助我们确保大多数互联网上服务器的身份。
- en: 'Therefore, when we are contacting to a server with a certificate signed by
    a well-known CA, the code used before to create an HTTPS connection does not require
    any changes:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们联系由知名CA签发的证书的服务器时，之前用于创建HTTPS连接的代码不需要任何更改：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This code example will create an SSL connection using the default cryptographic
    cipher suite specified on the Android platform and validate the server against
    the platform CAs.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例将创建一个使用Android平台默认加密加密套件的SSL连接，并验证服务器是否与平台CA相匹配。
- en: Although this can work in most of the cases, it might be necessary to use a
    specific CA, a list of trusted certificates, or only the safest ciphersuite (TLSv1)i
    In the cases where the developer has to build their own `SSLContext` and specify
    their own `TrustManagers` and `KeyManagers` in order to connect successfully to
    the remote server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在大多数情况下都能工作，但可能需要使用特定的CA、一组受信任的证书，或者仅使用最安全的加密套件（TLSv1）。在开发者必须构建自己的`SSLContext`并指定自己的`TrustManagers`和`KeyManagers`以成功连接到远程服务器的情况下。
- en: In the next paragraphs we are going to extend our client to use private keys
    and CAs stored on Java keystores in order to validate and communicate with a server
    of which the **Certificate authority** (**CA**) is managed by us.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的段落中，我们将扩展我们的客户端以使用存储在Java密钥库中的私钥和CA，以便验证和与由我们管理的**证书颁发机构**（**CA**）管理的服务器进行通信。
- en: 'First of all, we will create an `SSLOptions` class where we define the cipher
    suite that we want to use in our SSL session:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`SSLOptions`类，在该类中我们定义了在SSL会话中想要使用的加密套件：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With the preceding code we are able the control the cipher suite used by our
    `SSLContext`; however, in order to use our own private key, certificates, and
    trusted CAs, we will have to initialize the `SSLContext` with our own `TrustManager`
    and `KeyManager`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们能够控制`SSLContext`使用的加密套件；然而，为了使用我们自己的私钥、证书和受信任的CA，我们必须使用自己的`TrustManager`和`KeyManager`初始化`SSLContext`：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For simplicity, we will load our `KeyManagers` and `TrustManager` from a keystore
    file stored on the application assets directory. The Java keystore is available
    on the Packt Publishing website. So, before we go any further, download the `asynchronous_client.ks`
    file from the Packt website with a ready-to-use private key, a certificate, and
    the custom CA certificate that signed the certificate as the trusted Authority.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将从存储在应用程序资源目录中的密钥库文件中加载我们的`KeyManagers`和`TrustManager`。Java密钥库可在Packt
    Publishing网站上找到。因此，在我们继续之前，请从Packt网站下载`asynchronous_client.ks`文件，其中包含一个可用的私钥、一个证书以及作为受信任权威机构签发证书的自定义CA证书。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that you can build your own `TrustManager` and `KeyManager` custom subclass
    that can load the private key and the certificates from a different source but
    for simplicity we will load them from a file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以构建自己的`TrustManager`和`KeyManager`自定义子类，可以从不同的来源加载私钥和证书，但为了简单起见，我们将从文件中加载它们。
- en: Let's take a look at our `asynchronous_client.ks java` keystore file with the
    help of the keytool application.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助 keytool 应用程序查看我们的 `asynchronous_client.ks java` 密钥库文件。
- en: 'On the command line, please run the following command to list the content of
    the keystore:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，请运行以下命令以列出密钥库的内容：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our keystore file, which will act as the trusted store file and keystore file,
    has a public and private key named `asynchronous_client` and a trusted CA named
    ca. The keytool requires the Bouncy Castle Provider JAR to read the the file contents,
    so before, please download the file from the Packt website.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义密钥库文件，它将作为受信任的存储文件和密钥库文件，包含一个名为 `asynchronous_client` 的公钥和私钥以及一个名为 ca
    的受信任 CA。keytool 需要Bouncy Castle提供者 JAR 来读取文件内容，因此，请在此之前从 Packt 网站下载该文件。
- en: Notice that since we have `C=UK`, `ST=Birmingham`, `L=Birmingham`, `O=Packt
    Publishing`, and `CN=packt` as a trusted CA, we will allow our HTTP to connect
    with SSL endpoints that present a certificate signed by this authority or a certificate
    where all intermediate certificates are trustworthy (a trusted certificate chain).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们有 `C=UK`，`ST=Birmingham`，`L=Birmingham`，`O=Packt Publishing` 和 `CN=packt`
    作为受信任 CA，我们将允许我们的 HTTP 连接到由该机构签署的 SSL 端点或所有中间证书都值得信赖的证书（一个受信任的证书链）。
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every Android device comes with a pre-installed list of trusted certificates
    that can be used to authenticate a secure remote peer.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android设备都预装了一个受信任证书列表，这些证书可以用来验证一个安全的远程对等实体。
- en: 'Now that we know the details about our keystore and truststore, let''s update
    our SSL options to load the `KeyManager` and `TrustManager` from the `asynchronous_client.ks`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了密钥库和受信任存储库的详细信息，让我们更新我们的 SSL 选项以从 `asynchronous_client.ks` 加载 `KeyManager`
    和 `TrustManager`：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice that we initialize SSLContext using the Keymanager list and `TrustManager`
    list returned by `KeyManagerFactory` and `TrustManagerFactory` respectively. Hence,
    the next step is to write the code member method to acquire our factories. So,
    let''s start with the `getKeyManagerFactory`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `KeyManagerFactory` 和 `TrustManagerFactory` 返回的 Keymanager 列表和 `TrustManager`
    列表初始化 SSLContext。因此，下一步是编写代码成员方法来获取我们的工厂。所以，让我们从 `getKeyManagerFactory` 开始：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The previous code will load up a public and private key from a BCS keystore
    that we previously prepared. So, all that remains is the `getTrustManagerFactory`
    function used to load our trusted CA:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将从我们之前准备的 BCS 密钥库中加载一个公钥和私钥。因此，剩下的就是 `getTrustManagerFactory` 函数，用于加载我们的受信任
    CA：
- en: '[PRE47]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now that we have the `SSLOptions` class to initialize our `SSLContext`, let''s
    move on to the `HTTPRequest` and update our `Builder` to store the `SSLOptions`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `SSLOptions` 类来初始化我们的 `SSLContext`，让我们继续到 `HTTPRequest` 并更新我们的 `Builder`
    以存储 `SSLOptions`：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we are ready to update our `HTTPAsyncTask` to use our `SSLOptions`
    object in order to customize our SSL client endpoint. Hence, we will be able to
    verify the identity of our server that has a certificate signed by our own CA
    (`C=UK`, `ST=Birmingham`, `L=Birmingham`, `O=Packt Publishing`, `CN=packt`) and
    vice-versa:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备更新我们的 `HTTPAsyncTask` 以使用我们的 `SSLOptions` 对象来自定义我们的 SSL 客户端端点。因此，我们将能够验证由我们自己的
    CA 签署的证书的服务器身份（`C=UK`，`ST=Birmingham`，`L=Birmingham`，`O=Packt Publishing`，`CN=packt`）以及反之亦然：
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that our implementation does not perform hostname verification, because
    the server CN might not match the server hostname used to contact the HTTP server.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的实现不执行主机名验证，因为服务器 CN 可能不会与用于联系 HTTP 服务器的服务器主机名匹配。
- en: However, if you want to be stricter about this, change the `setHostnameVerifier`
    line to use the default behavior, implement your own `HostnameVerifier`, or use
    the hostname verifiers available on the Android SDK, such as the Apache `X509HostnameVerifier`
    that checks whether the supplied hostname matches any of the supplied certificate
    CNs or Subject-Alts.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您想对此更加严格，请将 `setHostnameVerifier` 行更改为使用默认行为，实现您自己的 `HostnameVerifier`，或使用
    Android SDK 中可用的主机名验证器，例如 Apache 的 `X509HostnameVerifier`，该验证器检查提供的主机名是否与提供的证书
    CN 或 Subject-Alts 中的任何一个匹配。
- en: 'Finally, let''s illustrate how to use our client to connect to a server that
    possesses a certificate with the following certificate chain:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们说明如何使用我们的客户端连接到一个具有以下证书链的服务器：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following code shows how to establish an SSL session with a URL where the
    protocol is `https`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何与一个协议为 `https` 的 URL 建立一个 SSL 会话：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If the SSL handshake between the peers finishes with success, the server verifies
    our identity and our client verifies the server's identity. As a result, a cryptographic
    channel is opened between both entities keeping the data hidden from third-party
    intruders.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对等之间的SSL握手以成功结束，服务器将验证我们的身份，而我们的客户端将验证服务器的身份。因此，在两个实体之间打开了一个加密通道，使数据对第三方入侵者隐藏。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored in detail the `HttpUrlConnection` Android HTTP
    client and we built a basic and expandable asynchronous client to interact with
    HTTP web APIs.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了`HttpUrlConnection` Android HTTP客户端，并构建了一个基本且可扩展的异步客户端以与HTTP Web
    API交互。
- en: In the first section, we exposed the main differences between the `HttpUrlConnection`
    client and the deprecated Apache HTTP client available on pre-Marshmallow SDKs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们揭示了`HttpUrlConnection`客户端与在Marshmallow SDK之前可用的已弃用的Apache HTTP客户端之间的主要区别。
- en: Next, we wrote the core classes and callback interfaces for our asynchronous
    client and we expanded our high-level client to interact with JSON and Web APIs.
    Additionally, we built the code to convert from our Java models to a JSON or an
    XML document.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写了异步客户端的核心类和回调接口，并扩展了我们的高级客户端以与JSON和Web API交互。此外，我们还构建了将我们的Java模型转换为JSON或XML文档的代码。
- en: Later, we learned how to configure the HTTP timeouts and to set up secure communications
    that are able to use our own signed certificates, keys, and CAs. In our example,
    we created and prepared an SSL context to be used to establish a secure channel
    based on a prepared Java secure keystore.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们学习了如何配置HTTP超时并设置能够使用我们自己的签名证书、密钥和CA的安全通信。在我们的示例中，我们创建并准备了一个SSL上下文，用于基于准备好的Java安全密钥库建立安全通道。
- en: In the next chapter, we will introduce and explore the **JNI** (**Java Native
    Interface**) to create asynchronous tasks in native code (C/C++). This interface
    is able to interact with compiled code that runs directly on the device's CPU.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍并探讨**JNI（Java Native Interface**）以在本地代码（C/C++）中创建异步任务。此接口能够与直接在设备CPU上运行的编译代码进行交互。
