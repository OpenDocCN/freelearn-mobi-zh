- en: Chapter 8. Interacting with the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the HttpURLConnection HTTP client to transfer data
    from and to the network, such as when downloading images from an HTTP server and
    synchronizing information with a remote HTTP server. We have been using this Android
    HTTP client blindly without going into much detail about the internals and the
    features provided by this handy framework that deals transparently with the HTTP
    protocol for us.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn more about the advanced features of HttpURLConnection
    and fresh techniques to communicate asynchronously and securely with a remote
    server using the HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, we will learn how use a customized HTTP client to communicate
    over secure channels, tweak the HTTP client to deal with network delays, and learn
    how to interact with web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Android HTTP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing HTTP requests asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with JSON web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with XML web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing HTTP timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicating securely over SSL sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP open source libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Android HTTP clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent times, the ability to send and receive data from remote servers has
    become an essential feature that all applications should enforce in order to create
    dynamic and impressive experiences. Today almost every application uses the network
    to pull up data information, execute remote business logic operations, and download
    or upload resources.
  prefs: []
  type: TYPE_NORMAL
- en: The network interactions that happen between the application and a remote server
    are typically defined as a set of request/response messages that traverse the
    network using a network protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the HTTP protocol is often used to transport messages between each
    peer, and the Android SDK comes with two high-level HTTP clients available out
    of the box to send and receive data: `AndroidHttpClient` and `HttpURLConnection`.'
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP communication protocol is a stateless, standard text-based application
    protocol maintained by **Internet Engineering Task Force** (**IETF**) and the
    **World Wide Web Consortium** (**W3C**) and is widely used on the Internet to
    exchange data between a client, normally called a user agent, and a server.
  prefs: []
  type: TYPE_NORMAL
- en: The protocol has undergone some improvements over time, but most servers and
    clients base their implementation on HTTP 1.1, a revision of the original HTTP
    1.0, which introduced the connection re-use feature and chunked transfer encoding
    to the original protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a typical HTTP flow, the client, the entity that initiates the operation,
    sends a request to the server over a connection and waits for the server''s response.
    On the other end, the server reads the request from the communication channel,
    processes the request, and sends a response back to the client. In the next figure,
    we can visualize a request and response example exchanged between peers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing Android HTTP clients](img/Image_B05062_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The new HTTP revision, 2.0, published in May 2015, hasn't been widely adopted
    and there is no official support on the Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: After a preliminary HTTP protocol introduction, we will try to compare the HTTP
    clients available on the Android SDK.
  prefs: []
  type: TYPE_NORMAL
- en: AndroidHttpClient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AndroidHttpClient` client library, based on the Apache HTTP client, has
    been deprecated since API Level 9 (Gingerbread), but it provides a large and flexible
    API to access HTTP servers with support for cookie management, timeout customization,
    basic authentication schemes, and secure communication channels.
  prefs: []
  type: TYPE_NORMAL
- en: This client is more stable than `HttpURLConnection` on API Level 8 (Froyo) and
    API Level 7 (Eclair).
  prefs: []
  type: TYPE_NORMAL
- en: On API Level 23 (Marshmallow), support for this client has been removed in favor
    of `HttpURLConnection` due to the lack of transparent response compression and
    response caching.
  prefs: []
  type: TYPE_NORMAL
- en: HttpURLConnection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This client framework supports secure communication sessions (HTTPS), transparent
    response compression, response caching, network timeout customization, network
    connection polling, IPV6 support, proxy servers, and streaming.
  prefs: []
  type: TYPE_NORMAL
- en: According to Google, prior to API Level 8 (Froyo), this client has some important
    issues that could spoil the HTTP connection re-use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Android 4.4 (KitKat), this implementation engine is based on the open
    source OkHttp Square library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that `HttpURLConnection` is the HTTP client recommended by Google for
    Android versions greater than API Level 9, we will base our code examples on this
    HTTP client. However, this fragmentation issue can be surpassed by using different
    Android HTTP clients based on the API Level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will start to write our HTTP asynchronous toolkit based
    on `HttpURLConnection` and explore the advanced features delivered by the client
    to communicate with remote peers.
  prefs: []
  type: TYPE_NORMAL
- en: Performing HTTP requests asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have been using the `HttpURLConnection` client and `AsyncTask` to
    retrieve remote data asynchronously in our code examples.
  prefs: []
  type: TYPE_NORMAL
- en: While this solution can work in most cases, we could end up with loads of duplicate
    code in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create a neat high-level asynchronous HTTP client to
    perform remote requests outside of the main thread that forwards the result of
    the request to the application's main thread using a callback handler. This approach
    fits well with the application UI model because the callback handler, which executes
    on the main thread, is able to update the UI with the data retrieved from the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s define the basic interface that our asynchronous client
    should honor to execute remote requests in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HTTPRequest` class is a Java model used to define all the parameters required
    to build the HTTP request. We will omit some of the implementation details, but
    with the help of the `Builder` class, we will be able to define the HTTP request
    verb, the request URL, the HTTP headers, the HTTP query parameters, and the HTTP
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`ResponseHandler` is the class that defines the callbacks that will be invoked
    when a success or failure response is sent from the server, or an exception happens
    during the operation execution. So, we''ll define an abstract `ResponseHandler`
    class for the subclasses to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All callback methods are forwarded automatically to the main thread when a response
    or an error is ready to be dispatched to the handler. All the network and input/output
    operations and memory allocations have to be done on the background thread to
    avoid any UI undesired pauses.
  prefs: []
  type: TYPE_NORMAL
- en: When the server returns an HTTP response, one of the following methods, `onSuccess`
    or `OnFailure`, is invoked based on the code returned by the response message.
    So, when any of the callbacks are called, an `HTTPResponse` object is delivered
    for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the `HTTPResponse` class carries information about the request code,
    the response headers, and the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the base classes and interface already defined, let's implement our asynchronous
    high-level client with the help of the `HttpURLConnection` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we already know how to construct a background-processing pipeline based
    on the `AsyncTask` class, for simplicity, we will base our implementation on this
    construct. In the future, you can replace `AsyncTask` with `AsyncTaskLoader` to
    support configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As defined in the preceding code, the input parameter type for our `AsyncTask`
    is `HTTPRequest` and as a result an object of type `Result<HTTPResponse>` is sent
    to the UI thread. The result, is a generic class, as defined in previous chapters,
    that is able to carry an error or an `HTTPResponse` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `HTTPAsyncTask` generic parameters already defined, now it is time
    to override `doInBackground` to send the HTTP request and process the response
    in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`openConnection` will establish a TCP connection with the resource specified
    in the `URL` object. Once the connection is established, and we try to retrieve
    the status line response code, our HTTP request headers and body are dispatched
    to the network.'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the status line is read, we process the HTTP response headers received
    and we store them on our response object for further processing. As you probably
    already know, an HTTP response might contain data on the HTTP message body, related
    to the resource specified on the requested URL.
  prefs: []
  type: TYPE_NORMAL
- en: For further processing, the data will be consumed from the connection `InputStream`
    in order to build a `Body` object. To detect the type of data content received
    on the HTTP Response, the client should look into the header Content-Type content.
    To simplify this recognition, the `HttpURLConnection` class provides the member
    method, `getContentType()`, that retrieves the content directly from the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body consumption and construction is done on the `BodyFactory` class shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Since we know the content type, we are ready to consume the body and store the
    bytes received on a `Body` object for further processing by our `ResponseHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Body` is an abstract class and itself is not able to read any kind of content,
    although we can extend the `Body` class directly to build a text body from the
    received data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Body` subclass, called `TextPlainBody`, will implement the abstract consume
    function in order to construct the body from the `InputStream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The consume code for the `TextPlainBody` is omitted for brevity, though the
    full source code is available to download from the Packt Publishing website. Take
    a look at the `TextPlainBody` source code to appreciate how we build a string
    using the `InputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we only support the `text/*` type; however, in the next sections we
    are going to extend the `BodyFactory` class to support other interesting mime
    types, such as JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: Once the response body has been fully read, the connection with the remote server
    will be closed and the resources held by the connection released.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The connection is not immediately destroyed but rather pushed to a connection
    pool for future use. After a finite amount of time idle (`idleTimeout`) on the
    pool, the connection is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: During the `doInBackground` execution, network or input/output exceptions are
    likely to arise, so to avoid an application crash we must catch and forward them
    over the `result.error` to the `postExecute` function and later to the `ResponseHandler`
    specified when the execution is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: Unchecked exceptions that propagate out of AsyncTask's methods will crash our
    application, so we must test carefully and handle those if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our `AsyncTask` subclass useful, we have to write the `onPostExecute`
    function that forwards the response or an error to the `ResponseHandler` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As stated before in [Chapter 3](ch03.html "Chapter 3. Exploring the AsyncTask"),
    *Exploring AsyncTask*, the `onPostExecute` callback will be executed on the main
    thread, so you should avoid any time-consuming operations on the following callbacks:
    `onError`, `onSucess`, and `onFailure`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All that remains is to invoke our `AsyncTask` from our `AsyncHTTPClient` subclass—`PacktAsyncHTTPClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now we have a core asynchronous HTTP client implementation with support
    for text mime types. In the next section we will use our high-level client to
    retrieve a text message from a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a text response
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our asynchronous HTTP client supporting text responses, we are able to
    make use of it to obtain a dynamic text so, let's create an activity that displays
    the text available on a remote URL resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to build our `HTTPRequest` using the `HTTPRequest.Builder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We wish to draw your attention to the fact that you should replace `<hostname>`
    and `<port>` to make it work for your HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: As defined before, in order to execute the request over our asynchronous client,
    `AsyncHTTPClient`, we must provide a `ResponseHandler` object to the `execute`
    method. Moreover, we want to define an object that updates the UI with the text
    obtained.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will extend our `ResponseHandler` abstract and create a class
    to process the body and forward the response to a callback that receives the text
    message as the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to finish our `Activity` code to send the HTTP request and in
    the meantime we will also present a progress dialog making the user aware that
    something is going on in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all we need is to define our `textResponseHandler`, an anonymous inner
    class that implements `TextReponseHandler`, updates the `View` with the `String`
    received, and dismisses the indeterminate progress dialog enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that all the callback functions are going to be executed on the main
    thread, so in these functions you should follow the golden rule of not blocking
    the thread to avoid UI delays.
  prefs: []
  type: TYPE_NORMAL
- en: When the server returns an error or an exception happens during the execution,
    the following callback methods, `onFailure` and `OnError`, are called respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Support for reading text resources from a remote server is a good starting point,
    although in most cases we intend to communicate with the remote server to exchange
    structured document formats, such as JSON, XML, or even binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with JSON web APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our previous `TextResponseHandler` is able to process the generic response `HTTPResponse`
    fulfilled with a text response and forward a String coming from JSON web APIs
    and forward a `String` to the `TextResponseHandler onReceive(String)` callback.
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to go a little further and convert an `HTTPResponse` returned from
    the `doInBackground` to a **Plain Old Java Object** (**POJO**) that characterizes
    a model on our business logic. To achieve that, we must convert a JSON-structured
    content returned on the HTTP body to one Java defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'To forward the processing to the callbacks defined above, we will create the
    `JSONResponseHandler`, an abstract subclass of `ResponseHandler` that implements
    `onSuccess(HTTPResponse)`, `onFailure(HTTPResponse)`, and convert the objects
    to `<ResponseType>` and `<ErrorType>` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To support the processing of different body contents, our `BodyFactory` needs
    an update. So, before we move on to the `JSONResponseHandler` implementation,
    we will update our `BodyFactory` function to support the `application/json` mimetype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we read the content from the network and we store the data on a
    new `Body` class named `RawBody` that simply stores the content that comes from
    the HTTP Response body on an internal byte memory buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storing the full body might work for our simple client use cases. Although,
    if we are willing to process bodies with megabytes of data, we must use another
    strategy to read and consume the body, consume the body in chunks, or save the
    body on a local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: With the body already with JSON web APIs stored on the device memory, we are
    ready to process it with the help of our `JSONResponseHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Java objects to JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To convert the JSON document format to a plain object we will make use of one
    open source library that''s very well known in the Android community—the Google
    GSON library: [https://github.com/google/gson](https://github.com/google/gson).'
  prefs: []
  type: TYPE_NORMAL
- en: The GSON library, a library developed and maintained by Google, is able to convert
    Java objects to a JSON object and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, before you move on, make sure that you add the library to your Gradle or
    Eclipse project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert from a protocol encoded content body to a POJO, we will define the
    `BodyDecoder` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert from a POJO to a `Body` object, we are going to define the `BodyEncoder`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To decode a JSON document to a POJO, we will have to subclass this generic
    interface and write the code to deal with the JSON decoding with the help of the
    GSON library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we are ready to implement our generic `JSONResponseHandler` that forwards
    the converted JSON-structured documents returned on the `onSuccess` and `onFailure`
    methods to the generic types `Response` and `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the `JsonResponseHandler` code will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This generically typed class is able to consume the `RawBody` object forwarded
    from `onSuccess` or `onFailure` and expose two generic type parameters. The first
    `Response` is a generic type that specifies the type of POJO class for the success
    response (`onSuccess`) and the `Error` generic type that specifies the type of
    POJO class for the error function (`onFailure`).
  prefs: []
  type: TYPE_NORMAL
- en: When any of the callback functions that receive the `HTTPResponse` is invoked,
    with the help of the GSON library we convert the JSON document, stored on the
    `RawBody`, to a response/error object.
  prefs: []
  type: TYPE_NORMAL
- en: The `onFailure` function is omitted because its code is quite similar to the
    `onSuccess` method; however, you can take a look at the full source code on the
    Packt Publishing website to understand the differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to exercise our asynchronous client by reading a model
    from an HTTP JSON body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To test our client we will take advantage of `JSONPlaceHolder` ([http://jsonplaceholder.typicode.com/](http://jsonplaceholder.typicode.com/)),
    a fake online REST API for testing and prototyping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we try to access it, let''s define the `User` POJO class that we will
    use in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will define a POJO class for the `failure` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To display the models returned from the fake API, we'll create a new `UserListActivity`
    that will implement `JSONResponseHandler` and display the name and the e-mail
    of all the users with the JSON document returned from [http://jsonplaceholder.typicode.com/users](http://jsonplaceholder.typicode.com/users).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by defining the `JsonResponseHandler<List<User>,Error>` anonymous
    class that receives a list of users as an argument , `List<User>`, for the success
    callback and an `Error` object as the argument for the failure callback.
  prefs: []
  type: TYPE_NORMAL
- en: '`onSuccess(List<User>)` will update a `ListView` that displays the name followed
    by the e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All that remains is to write the Activity''s `onCreate` function that builds
    up the HTTP Request and dispatches the request, GET /users, to the `JSONPlaceHolder`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When the server sends back a response to our request, the `JSONResponseHandler`
    object will decode the JSON document with a list of 10 users and convert the document
    to a `List<User>` object.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON data exchange format has predominantly been used on most recent APIs
    and web services deployed on the Internet because of its simplicity, readability,
    compactness, and lack of data structure rigidity.
  prefs: []
  type: TYPE_NORMAL
- en: However, XML-based remote web services, mainly based on the SOA data exchange
    protocol, are still around to cover advanced use cases where we want to have stricter
    data model schema validation and modelling, built-in namespace support, and advanced
    information extraction tools.
  prefs: []
  type: TYPE_NORMAL
- en: XML-based APIs have lost some traction in the industry, although the XML-based
    APIs are still common, so in the next section we will extend our toolkit to support
    the encoding and decoding of XML content on our HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with XML web APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the last 10 years, XML message-based APIs have been successfully used to
    exchange data (SOAP) and run remote procedures (XML-RPC) between applications
    and remote servers. Moreover, nowadays, some REST APIs are built with JSON and
    XML support, so it's up to the developer to decide whether they want to interact
    with the API using XML or JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we will extend our toolkit to exchange XML messages in order
    to communicate with the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding sections, we implemented a `ResponseHandler` to decode JSON
    documents sent on the HTTP body, but now we want to go further and add support
    for sending XML documents on the HTTP Request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back into our `HTTPAsyncTask` details, the code required to support
    body transmissions on the request was lacking; therefore, this is the perfect
    time to rewrite the code to carry an entity body on the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when a body is available on the `HTTPRequest` object
    and before we try to read the `responseCode` of the response status line, we retrieve
    the output stream from the `HttpURLConnection` and we write the content stored
    on the `Body` object.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the data written, the header `Context-Type` is set on the HTTP request
    header section based on the body's mimetype.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to send and receive entity bodies on the HTTP request and
    response respectively, so now we can start to work on our XML implementation example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next paragraphs, and following the JSON section, we will write the code
    to serialize an API Request into an XML document and the code to de-serialize
    XML documents, received on response, to an API Response object.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Java objects to XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To de-serialize and serialize from Java objects to XML and vice-versa, we will
    use the open source library SimpleXML ([http://simple.sourceforge.net/](http://simple.sourceforge.net/));
    therefore, to make use of it, please add this library to your application list
    of external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Android Studio, here is the content to add to your `build.gradle`
    list of dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With the `User` model defined previously we will build up a `APIRequest` named
    `GetUserInfo` that will get the user details (`GetUserInfoResponse`) for the user
    identifier submitted in the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To describe this further, let''s define the API Request POJO objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s define the API Response POJO object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The annotation for the other classes, `User`, `Address`, and `Company`, are
    quite similar to the ones above, with all the elements referring to the `https://www.packtpub.com/asynchronous_android`
    namespace, hence we will omit the POJO changes for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: With the mapping between the Java objects and XML Request and response message
    finished, let's start to work on the code that converts the `GetUserInfo` object
    into an XML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'To encode an XML document from a Java object, we will subclass this generic
    interface to encode a POJO generic type into an XML document with the help of
    SimpleXML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Converting XML to Java objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To decode an XML document to a Java POJO object we will add the `BodyDecoder<POJO>`
    to the `XMLConverter` class definition interface and write the code to convert
    the XML document to a POJO generic class with the help of the SimpleXML library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With the XML serialization and deserialization already in place, let's start
    to write the activity that will retrieve the user information from a remote server
    using the `GetUserInfo` and `GetUserInfoResponse` defined above and display the
    user information on a UI.
  prefs: []
  type: TYPE_NORMAL
- en: To test our client, we will create a fake XML WebService with the help of the
    mockable [https://www.mockable.io/](https://www.mockable.io/) web application.
    This web application allows us to create configurable REST APIs that return a
    static JSON or XML document as a response to the clients, so this tool will be
    extremely helpful to test our client in a controlled environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our fake HTTP API will return the following XML document when any HTTP request
    is sent to the following URI, [http://demo1472539.mockable.io/GetUserInfo](http://demo1472539.mockable.io/GetUserInfo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to convert the `HTTPResponse` objects received by the `onSuccess(HTTPRequest)`
    and `onFailure(HTTPResponse)` callbacks to domain models, we will have to subclass
    the `ResponseHandler` abstract class and create the code to de-serialize a generic
    POJO class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to collect the `GetUserInfoResponse` dispatched from our fake
    server, so let''s implement, on our Activity, an anonymous inner `XMLResponseHandler`
    subclass that will update the UI with user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish our `Activity`, we will have to build the request and ask our asynchronous
    client to execute our demand in the background with the help of the `HTTPAsyncTask`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Once the response is returned from the fake server, the UI will be updated to
    show the user name, e-mail, and other properties, based on the XML specified on
    the fake endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nothing is mentioned about the error flow; however, I will challenge you to
    create a fake endpoint that returns an error object to exercise the `onError`
    callback. The full source code with the error flow is available to download from
    the Packt Publishing website. Take a look at it to appreciate how error handling
    is implemented. The error XML document might be something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have covered most common formats (Text, XML, and JSON) used in the
    industry to exchange data between HTTP clients and servers. Each of these formats
    has its own strengths; however, for its compactness and simplicity (easy parsing,
    syntax, and so on), the JSON format has been widely adopted by API designers,
    electronics manufacturers, and **Software as a Service** (**SaaS**) vendors.
  prefs: []
  type: TYPE_NORMAL
- en: During this process, we will build up a core framework that could be easily
    extended to support different data exchange formats, such as YAML or binary protocols.
    Therefore, you might write your own `BodyEncoder`, `BodyDecoder`, and `ResponseHandler`
    to fit a standard data format or even your own data format.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will introduce the reader to a set of timeouts available
    on the `HttpUrlConnection` used to accommodate network delays on the request execution.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing HTTP timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When `HttpUrlConnection` connects, reads, or writes content over a low bandwidth
    network (2G, 3G, and so on), the exposure to unpredictable communication delays
    can not be avoided. Moreover, apart from the mobile network delays, the HTTP servers
    might introduce significant response delays (server latency) when they are experiencing
    high volumes of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Although the default timeout values used by the the `HttpUrlConnection` are
    long enough to cope with these delays, there are some special use cases where
    you might want to customize the default values according to your needs. For example,
    when on the way to the application server, the HTTP request travels through some
    proxies.
  prefs: []
  type: TYPE_NORMAL
- en: '`HttpUrlConnection` offers us two member methods that can be used to change
    the default timeouts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`setConnectTimeout(int)` is able to redefine the maximum time in milliseconds
    that our client is allowed to wait until the TCP connection to the remote host
    is established (server is down). `ConnectTimeoutException` will be thrown whenever
    the connection fails, for example, if the server is down or is not able to respond
    in time due to lack of resources, so you should be careful and handle this exception
    cleanly in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: When the hostname resolves into multiple addresses, the client will try to connect
    one after the other and the timeout will be applicable multiple times. If the
    timeout is set to `0`, the connection will be blocked until the TCP timeout expires,
    which on Android is normally several minutes.
  prefs: []
  type: TYPE_NORMAL
- en: '`setReadTimeout(int)` defines the maximum time that our client is allowed to
    be blocked on the read operation until any available data is allowed to be read.
    The default value `0` will block the read operation indefinitely until data becomes
    available, the connection is dropped by the remote peer, or an error occurs on
    the socket. When the timeout is longer than `0` and no data is available when
    the timeout expires, a `SocketTimeoutException` will be thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the meaning of each timeout, let''s update our `HTTPRequest.Builder`
    with some new setter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to update `HTTPAsyncTask` to set the timeouts specified on
    the `HTTPRequest`, on the `HttpURLConnection` object used to connect to the remote
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It's highly recommended that you test your customized timeouts under several
    network latency levels and take into account the time that your server could defer
    the response for a couple of seconds when it is under load.
  prefs: []
  type: TYPE_NORMAL
- en: A typical network delay could go from 80-120 ms on an LTE mobile network to
    150-550 ms on a GPRS mobile network
  prefs: []
  type: TYPE_NORMAL
- en: When you run your application on the Internet and you have to deal with sensitive
    data, such as personal information, payment information, or business documentation,
    it is really important to protect your communication channels with a security
    layer that hides the exchanged data from an outside attacker or avoids any spoofing
    attacks. In the next section, we will expand our high-level client to support
    a secure SSL connection channel to the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating securely over SSL sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using plain connections to communicate with a remote HTTP
    server. Despite the fact that these kinds of connections might fit your application
    requirements when the data exchanged is not sensitive, there are use cases where
    we must use a secure channel to send or receive, preventing any third party from
    reading or changing the data exchanged on the network.
  prefs: []
  type: TYPE_NORMAL
- en: In order to setup an SSL session with a remote server, our client, with the
    help of some cryptographic tools, will create a cryptographic communication channel
    where all the data is encrypted with a symmetric cipher that uses a secret key
    exchanged during the secure connection handshake. Apart from that, the content
    received and encrypted with a previously exchanged secret key is validated against
    other peer public keys to prove that the data is coming and signed from the right
    source.
  prefs: []
  type: TYPE_NORMAL
- en: During the connection establishment, as part of the SSL handshake, the server
    has to prove that it holds a private key for a trusted certificate. A trusted
    certificate is a certificate that is available from our list of trusted **Certificate
    Authorities** (**CA**s) or it was signed by one of the certificates available
    from your trusted CAs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Android platform comes out-of-the-box with a list of well-known trusted
    CAs that help us to assure the identity of most servers on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, when we are contacting to a server with a certificate signed by
    a well-known CA, the code used before to create an HTTPS connection does not require
    any changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This code example will create an SSL connection using the default cryptographic
    cipher suite specified on the Android platform and validate the server against
    the platform CAs.
  prefs: []
  type: TYPE_NORMAL
- en: Although this can work in most of the cases, it might be necessary to use a
    specific CA, a list of trusted certificates, or only the safest ciphersuite (TLSv1)i
    In the cases where the developer has to build their own `SSLContext` and specify
    their own `TrustManagers` and `KeyManagers` in order to connect successfully to
    the remote server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next paragraphs we are going to extend our client to use private keys
    and CAs stored on Java keystores in order to validate and communicate with a server
    of which the **Certificate authority** (**CA**) is managed by us.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will create an `SSLOptions` class where we define the cipher
    suite that we want to use in our SSL session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With the preceding code we are able the control the cipher suite used by our
    `SSLContext`; however, in order to use our own private key, certificates, and
    trusted CAs, we will have to initialize the `SSLContext` with our own `TrustManager`
    and `KeyManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, we will load our `KeyManagers` and `TrustManager` from a keystore
    file stored on the application assets directory. The Java keystore is available
    on the Packt Publishing website. So, before we go any further, download the `asynchronous_client.ks`
    file from the Packt website with a ready-to-use private key, a certificate, and
    the custom CA certificate that signed the certificate as the trusted Authority.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that you can build your own `TrustManager` and `KeyManager` custom subclass
    that can load the private key and the certificates from a different source but
    for simplicity we will load them from a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at our `asynchronous_client.ks java` keystore file with the
    help of the keytool application.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the command line, please run the following command to list the content of
    the keystore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our keystore file, which will act as the trusted store file and keystore file,
    has a public and private key named `asynchronous_client` and a trusted CA named
    ca. The keytool requires the Bouncy Castle Provider JAR to read the the file contents,
    so before, please download the file from the Packt website.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that since we have `C=UK`, `ST=Birmingham`, `L=Birmingham`, `O=Packt
    Publishing`, and `CN=packt` as a trusted CA, we will allow our HTTP to connect
    with SSL endpoints that present a certificate signed by this authority or a certificate
    where all intermediate certificates are trustworthy (a trusted certificate chain).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every Android device comes with a pre-installed list of trusted certificates
    that can be used to authenticate a secure remote peer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know the details about our keystore and truststore, let''s update
    our SSL options to load the `KeyManager` and `TrustManager` from the `asynchronous_client.ks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we initialize SSLContext using the Keymanager list and `TrustManager`
    list returned by `KeyManagerFactory` and `TrustManagerFactory` respectively. Hence,
    the next step is to write the code member method to acquire our factories. So,
    let''s start with the `getKeyManagerFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will load up a public and private key from a BCS keystore
    that we previously prepared. So, all that remains is the `getTrustManagerFactory`
    function used to load our trusted CA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `SSLOptions` class to initialize our `SSLContext`, let''s
    move on to the `HTTPRequest` and update our `Builder` to store the `SSLOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we are ready to update our `HTTPAsyncTask` to use our `SSLOptions`
    object in order to customize our SSL client endpoint. Hence, we will be able to
    verify the identity of our server that has a certificate signed by our own CA
    (`C=UK`, `ST=Birmingham`, `L=Birmingham`, `O=Packt Publishing`, `CN=packt`) and
    vice-versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our implementation does not perform hostname verification, because
    the server CN might not match the server hostname used to contact the HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want to be stricter about this, change the `setHostnameVerifier`
    line to use the default behavior, implement your own `HostnameVerifier`, or use
    the hostname verifiers available on the Android SDK, such as the Apache `X509HostnameVerifier`
    that checks whether the supplied hostname matches any of the supplied certificate
    CNs or Subject-Alts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s illustrate how to use our client to connect to a server that
    possesses a certificate with the following certificate chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how to establish an SSL session with a URL where the
    protocol is `https`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If the SSL handshake between the peers finishes with success, the server verifies
    our identity and our client verifies the server's identity. As a result, a cryptographic
    channel is opened between both entities keeping the data hidden from third-party
    intruders.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored in detail the `HttpUrlConnection` Android HTTP
    client and we built a basic and expandable asynchronous client to interact with
    HTTP web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the first section, we exposed the main differences between the `HttpUrlConnection`
    client and the deprecated Apache HTTP client available on pre-Marshmallow SDKs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we wrote the core classes and callback interfaces for our asynchronous
    client and we expanded our high-level client to interact with JSON and Web APIs.
    Additionally, we built the code to convert from our Java models to a JSON or an
    XML document.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we learned how to configure the HTTP timeouts and to set up secure communications
    that are able to use our own signed certificates, keys, and CAs. In our example,
    we created and prepared an SSL context to be used to establish a secure channel
    based on a prepared Java secure keystore.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce and explore the **JNI** (**Java Native
    Interface**) to create asynchronous tasks in native code (C/C++). This interface
    is able to interact with compiled code that runs directly on the device's CPU.
  prefs: []
  type: TYPE_NORMAL
