- en: Mixing in Mixed Reality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mixed reality** (**MR**) is the evolution of combining **augmented reality**
    and **virtual reality** into the same experience or app. MR typically uses a wearable
    device to overlay the virtual world on top of the user''s reality. The concept
    first gained traction with Microsoft''s introduction of HoloLens. HoloLens is
    a wearable glasses device that allows you to overlay your real world with virtual
    content using hand gestures, not unlike what we have been doing with ARCore in
    this whole book, except the difference of the wearable part and, of course, the
    price tag.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft is currently leading the charge in mixed reality development with
    their platform of the same name, which is great exposure for the whole AR/VR and
    now MR space. Microsoft is a big technology company and, like many big technology
    giants, has decided to redefine the concept of mixed reality to also include virtual
    reality.
  prefs: []
  type: TYPE_NORMAL
- en: Wearable devices that allow users to experience mixed reality have been traditionally
    quite expensive, until just recently. Through group funding and other initiatives,
    there are now plenty of cheap, less-than $30 US wearable devices out there that
    will allow you to experience MR. This is perfect for anybody who wants to dive
    in and learn how to develop MR apps. Of course, not all MR platforms are designed
    for mobile devices, or will work with ARCore. Fortunately, an open source project
    called **HoloKit** has released a cardboard MR headset that is designed to work
    with ARCore.
  prefs: []
  type: TYPE_NORMAL
- en: '"I''m not confused. I''m just well mixed."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Robert Frost'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will build a combined AR / MR ARCore app that will be meant
    as a technology and learning demo that showcases the power of AR and MR. We will,
    of course, need to get our feet wet a little with VR as well, which should make
    things interesting. The following is the list of main items we will focus on in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Mixed reality and HoloKit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing WRLD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up WRLD for MR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping, GIS, and GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's next
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a really big chapter with lots of material to go over. Unfortunately,
    we cannot include the content in a completed package due to licensing. However,
    we have tried to write each section in this chapter so that it can be used on
    its own, almost like a cookbook. This will allow you to pick and choose the components
    you want and don't want to use.
  prefs: []
  type: TYPE_NORMAL
- en: To best experience the exercises in this chapter, it is recommended that you
    obtain a HoloKit. You should be able to obtain this device for around $30\. If
    you are feeling adventurous, there are even plans available to build your own.
    Here's a link to where you can learn more about HoloKit and order your own at [https://holokit.io/](https://holokit.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Mixed reality and HoloKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HoloKit was created by Botau Hu, a brilliant new tech innovator that will surely
    experience great success in the industry. It''s a *wearable* device that projects
    your mobile devices screen into a 3D holographic projection. This holographic
    projection is then overlaid onto the user''s view, thus allowing them to experience
    a more immersive environment that often teeters on the edge of VR. The following
    is an illustration of what a HoloKit looks like fully assembled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d033fadf-2219-44c8-8fa1-29155231c5df.png)'
  prefs: []
  type: TYPE_IMG
- en: Fully assembled HoloKit
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the diagram, the device is quite similar in construction
    to that of Google Cardboard. Cardboard was Google's way of democratizing VR to
    the masses, and it worked. If you are unable to quickly get a HoloKit, you can
    also use a modified Google Cardboard. Just cut a slot in the cardboard for the
    device's camera and ensure not to move around too much.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things you will note about most mixed reality headsets is the
    ability of the user to see through their environment. This allows the user to
    still be spatially aware of their surroundings, while experiencing what could
    be an almost virtual experience. Since a user is more aware, MR devices are generally
    considered safer, and the user is much less prone to experiencing motion sickness
    and/or falling down. Currently, VR devices are not considered appropriate for
    those under the age of thirteen due to those issues.
  prefs: []
  type: TYPE_NORMAL
- en: VR motion sickness is often more a result of poor app performance or resolution.
    As it turns out, visual artifacts caused by a lagging app or poor resolution are
    responsible for placing additional strain on the user's brain. That strain will
    then manifest itself in the form of a severe headache or nausea. In the early
    days of VR, this was a big problem, but now the technology has improved enough
    for most users to be able to use an app for several hours at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The **Mirage Solo** headset was developed by *Lenovo* for a game by Disney called
    *Jedi Challenges*. Jedi Challenges is really more a proof of concept and showcase
    for mixed reality and what is possible. It will likely also be a collector's item,
    since it is associated with the new Star Wars franchise and just happens to correspond
    to an up-and-coming tech revolution. The only truly unfortunate thing about this
    project is that Lenovo never released a developer kit; hopefully they will rectify
    this is in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an image of the Lenovo Mirage Solo headset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f21f5f8-0271-45d2-966b-ffa171264b1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Jedi Challenges Mixed Reality game
  prefs: []
  type: TYPE_NORMAL
- en: In order to complete the exercises in this chapter, you won't need HoloKit.
    HoloKit allows for you to switch from AR to MR/VR mode at the press of a button.
    This means that you can still work through all the exercises in this chapter.
    However, it does mean that you won't experience the magical experience of MR.
    In the next section, we set up HoloKit to work with ARCore and get ready to build
    our tech demo.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up HoloKit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The great thing about HoloKit is that it comes complete with its own Unity
    template project. This makes our job of getting up and running with HoloKit quite
    painless. Open up Command Prompt or a shell window and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t already done so, create a new folder from the root called `ARCore`
    and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone the HoloKit repository into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That command clones the specific **Android** branch, which we will use. HoloKit
    is also supported for **ARKit** on **iOS**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new instance of the Unity editor. Create and open a new project called
    `HoloCore` in the `ARCore` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Project window, create a new folder under Assets called `HoloCore`. Under
    that new folder, create our standard five new folders (`Scripts`, `Scenes`, `Materials`,
    `Models`, and `Prefabs`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `ARCore/holokitsdk/Assets` folder with a file explorer window. Make
    a copy of the `HoloKitSDK` folder and place it in the `ARCore/HoloCore/Assets`
    folder. When you are done, return to the editor, and you should see the assets
    getting imported and compiled. After the import is complete, confirm that your
    Project window resembles the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd6f2480-9553-4dab-8552-a125c461b64d.png)'
  prefs: []
  type: TYPE_IMG
- en: Project window folders showing HoloKitSDK
  prefs: []
  type: TYPE_NORMAL
- en: If you are prompted to switch to Android, elect to do so by clicking on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the menu, select **Edit** | **Project Settings** | **Player**. This will
    open the Player (as in app player) settings panel. Select the Android tab and
    uncheck the Multithreaded Rendering option, and set the Package name, API Levels,
    and ARCore Supported, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ef6bef3-3451-40b9-8b41-0b9928b067b0.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Player settings for Android
  prefs: []
  type: TYPE_NORMAL
- en: Open up the HoloKit sample scene `CubeOnTheFloor` in the `Assets/HoloKitSDK/Examples`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, select File | Save Scene as, and save the scene as Main in the
    **`Assets/HoloCore/Scenes`** folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up Build Settings and add the current scene to the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. You should see a rather small button in the top corner
    with the letter C. Press that button to switch from AR to the MR mode. When you
    are ready, put your device into the HoloKit headset and enjoy your first MR app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Unlike Google Cardboard, HoloKit needs to let the camera view the user''s surroundings
    in order to track. As such, you may need to modify the headset by cutting out
    a larger hole for the device''s camera to see through. Here''s a pic of a HoloKit
    that needed to be modified in order to accommodate a Samsung Galaxy S8:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5118ff56-d549-4d98-9596-54040dc2d87d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Modified HoloKit to allow camera to visibly track
  prefs: []
  type: TYPE_NORMAL
- en: If you have another device that you want to hack, like Cardboard, then just
    ensure that you cut a space so that the camera is not blocked. Some other mixed
    reality headsets that work with mobile devices already have camera extensions.
    These camera extensions may support a fish eye lens, which allows for the device
    to see a wider area. This works quite well, since it essentially converts the
    camera into a sensor with a wide angle lens.
  prefs: []
  type: TYPE_NORMAL
- en: How does it work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get too far ahead of ourselves, let''s break open the HoloKit project
    and take a look at how or what it does. Open up the Unity editor and complete
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the HoloKitCameraRig in the Hierarchy window, and then select and expand
    it. Expand the children''s children and so on until you can see the Left Eye and
    Right Eye objects, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/87e11eba-c03c-44ac-b224-10983823bbd0.png)'
  prefs: []
  type: TYPE_IMG
- en: View of the scene's 3 cameras in the Hierarchy window
  prefs: []
  type: TYPE_NORMAL
- en: The VideoSeeThroughCamera is the main camera used when the app is in AR mode.
    When the app is in MR mode, the Left Eye and Right Eye cameras are used to create
    the stereo 3D vision. Take a closer look at the Eye cameras, and you will note
    that their position is slightly adjusted on the *x* axis. For the right camera,
    the amount is 0.032, and for the left it is -0.032\. This is how we generate 3D
    stereo projections, using an offset camera for each eye.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other components are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'HoloKitAmbientLight: It is just a standard directional light with the `ARCore
    Environmental Light` script attached.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HoloKitPlaneGenerator: It is a base object for the `HelloARController` script,
    which we have seen plenty of before.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HoloKitPlacementRoot: It is our main anchor point for the scene''s virtual
    objects.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HoloKitCameraRig: It is what controls the app view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HoloKitGazeManager: It is new and allows the user to select objects just by
    positioning their gaze or view on the target. You can try this now with the current
    scene and the ball. Fix your gaze on the ball and see what happens.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HoloKitPointCloud: It serves the same function as its counterpart in ARCore.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Go through and continue to expand and inspect the rest of the objects in the
    scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run the scene again. This time, pay attention to the details
    and see if you can get the Gaze to work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Well, hopefully that was relatively painless. Now, with HoloKit setup, we have
    the framework in place for our combined AR and MR app. We should expand on what
    our tech demo will do. The premise of our tech demo will be an app that allows
    the user to move between a traditional map interface and an AR or MR interface.
    The name HoloCore is a play on the ability to allow a user to drill into a map
    and render a 3D view in AR or MR. This also nicely ties in with the name ARCore.
    In the next section, we will look at adding a 3D map of the world to our app.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing WRLD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixed reality apps, because they provide spatial awareness to the user, are
    excellent for viewing massive objects or areas like a map. Unlike virtual reality,
    mixed provides a more intuitive and natural interface for movement since the user
    can also physically move their position. So, what better way to fully explore
    MR than by using it to view a 3D map of the world. Fortunately, there is a relative
    newcomer called **WRLD** that has started to make significant waves in AR / VR
    and MR, because it provides an excellent and simple solution for rendering a fairly-good
    3D map.
  prefs: []
  type: TYPE_NORMAL
- en: WRLD is a great platform for general 3D mapping and visualization. It currently
    does not support more robust backend GIS services, but it certainly could. For
    those professional GIS developers with access to Esri CityEngine, there are also
    some great workflows for bringing CE models into Unity. This means that you can
    also experiment with CE models in MR.
  prefs: []
  type: TYPE_NORMAL
- en: 'WRLD is shipped as a Unity asset right to the Asset Store, so installation
    is a breeze. However, before we install, we need to go to the WRLD site and get
    a developer account. WRLD is a commercial service that charges by usage. Fortunately,
    they offer free developer access for a limited, which is perfect for our tech
    demo. Open up a browser and complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse to [wrld3d.com](https://www.wrld3d.com/) and Sign Up for an account.
    Ensure that you verify the account through email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the site and Sign In.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find and click on the Developers link at the top of the page. This will take
    you to the Developers page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the big Access API Keys button at the top of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the name for your key, `HoloCore`, and click on Create API Key to create
    the key, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6556db14-acba-4018-bf3d-7e3418ed1c22.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a WRLD API key
  prefs: []
  type: TYPE_NORMAL
- en: Click on Copy API Key to copy the key to your clipboard. We will use it shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the Unity editor and, from the menu, select Window | Asset Store.
    This will open a browser page inside the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter `WRLD` in the search box and click on the Search button. This will open
    the asset page for `WRLD`, offering you to Download the asset. Click on the Download
    button, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e33f27b-45e8-4b02-bd94-2d9d66a47bc2.png)'
  prefs: []
  type: TYPE_IMG
- en: Downloading the WRLD asset from the Asset Store
  prefs: []
  type: TYPE_NORMAL
- en: This will download the package. After the package downloads, you will be prompted
    with an asset import dialog. Just click on Import to import everything. This may
    take a while, so stretch your legs and grab some refreshments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In some cases, you may want to be more careful on what you bring into your projects.
    For instance, if you were building a non-tech demo or proof of concept, you would
    likely remove any sample scenes or other excess from a project. We will talk more
    about keeping projects lean in [Chapter 11](e7c0bdd1-e380-4498-af5a-fe9e627eb6cb.xhtml),
    *Performance Tips and Troubleshooting*.
  prefs: []
  type: TYPE_NORMAL
- en: You may get a warning prompting you that the versions don't match with your
    version of Unity. Accept the warning and continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are prompted to get a key after you import `WRLD`, just click on Later.
    After all, we already have a key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will probably be prompted to increase the shadow distance with the
    following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd30d3f9-efd8-442a-9bb7-b5b0a10ad4a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Skip the Shadow settings dialog
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Skip button. We will need to adjust the lighting, materials, and
    shadows later manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This imports the `WRLD` asset into our project. In the next section, we will
    cover how to set it up and run `WRLD` for our MR app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up WRLD for MR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the asset imported, we can now work on setting up `WRLD` to work in MR.
    The setup requires a little bit of customization, so jump back to Unity and complete
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select **Assets** | **Setup WRLD Resources For** | **Android**.
    This will ensure that the assets are optimized for Android. We will also talk,
    in a later section, about how the materials can be manually optimized by updating
    or creating your own shaders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the Main scene is loaded, and then select and expand the **HoloKitPlacementRoot**.
    Disable the DebugCube and GazeTargetExample child objects. If you forgot how to
    do this, check the Inspector window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new child `GameObject` of HoloKitPlacementRoot called `WRLD`. Go to
    the Inspector window and use Add Component to add the `Wrld Map` component to
    the object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the component properties of the `Wrld Map`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/eff839f7-795d-4bd8-96a9-0c6afdc94785.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting properties for the Wrld Map component
  prefs: []
  type: TYPE_NORMAL
- en: Select and drag the new `WRLD` object into your `Assets/HoloCore/Prefabs` folder
    to create a prefab that we can use later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select HoloKitCameraRig from the Hierarchy window and set the Transforms Y Position
    to `300`. Since our map is at `0`, `0`, `0`, we want our viewer to look down from
    a height of around 300 meters or about 1000 feet. Then, expand the object until
    you see all of the children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select each of the cameras, VideoSeeThroughCamera, Left Eye, and Right Eye,
    and, in the Inspector window, set the Clipping Planes Far to `5000`, as illustrated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4eba6d12-0d4f-4c26-b9e1-a5aa820b503f.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Far plane clipping distance
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the far clipping plane essentially expands our view to include all
    objects to a distance of `5000`. Previously, this was set for `1000`. You may
    also want to increase the Near Clipping Plane to a larger value; `1` to `10` works
    well. If you note a slight flashing on the map, this is likely caused by the clipping
    plane being set to close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. Set the app to run in MR by clicking on the C button
    and then inserting your device in HoloKit. Enjoy the experience of viewing a map
    in mixed reality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WRLD has several excellent examples on using their API on Unity and other platforms.
    We built this example in order to feature mixing realities, rather than recreating
    their examples. As such, we have omitted placing the map on a surface, but this
    is because WRLD already has a good example for ARKit and, likely, will in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: What you just experienced is quite fun, especially considering the minimal effort
    this example took to get setup, except that there are several things missing.
    Most certainly, we want to be able to move and zoom in and out of our map, so
    we will cover movement and navigating in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a traditional AR app, you rarely move the user or player. The user or player
    move themselves, and the AR app works around that. We spent a good portion of
    this book understanding how ARCore tracks the user and understands their environment,
    which has worked quite well when working with small objects such as Andy. Except,
    if we want to render massive virtual objects or even embed new environments, then
    we need a way for the user to navigate those as well. Therefore, in this section,
    we will look to implement a mix of navigation methods from a standard touch interface
    to AR and MR versions. If you don't have a HoloKit or are not interested in trying
    MR, then you can stick to just working with the AR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before adding navigation to our app, we probably should look at how navigation
    is handled by default in WRLD. Open up the Unity editor and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: Save your current scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new scene. Name it `Navigation` and save the scene in the `Assets/HoloCore/Scenes`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the `Assets/HoloCore/Prefabs` folder, drag the `WRLD` prefab we created
    earlier and drop it in the scene. Set the properties on the `Wrld Map`, as shown
    in this screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbf76eca-2a6e-4138-a9ed-4dc3a17c710c.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting properties for the WRLD prefab
  prefs: []
  type: TYPE_NORMAL
- en: This is more or less the default settings that you will use to just render the
    map to your device in a non-AR interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Build Settings dialog and add your new scene to the build. Uncheck
    the Main scene, but don't delete it; we will turn it back on later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. You will now see the map as the main element in your
    view. You can use touch gestures to move, pan, and zoom the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see by playing with the app, the map navigation is very slick using
    the touch interface. We will use this to allow the user to navigate the map with
    touch until they see an area of interest that they want to take a close look at.
    Then, they will be able to switch to AR or MR mode to view the items in more detail.
    In order to do this, we will use the scene we just created as our starting scene,
    and use our Main scene to let the user switch to AR or MR.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to switch between interface types like a regular touch-driven UI
    and AR or MR works all the time. An excellent example of this, of course, is the
    popular game *Pokemon Go* from Niantic Labs. This also happens to use a map and
    allows a user to switch to AR to catch Pokemon. If you are curious about how Pokemon
    Go was constructed, take a look at the book *Augmented Reality Game Development*
    by *Micheal Lanham*, also from *Packt*.
  prefs: []
  type: TYPE_NORMAL
- en: Switching from AR to MR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to switch scenes and maintain state is common task, but it seems
    to require a bit of work in Unity. Open up the Unity editor to the `Navigation`
    scene and complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `Assets/HoloCore/Scripts` folder and create a new script called
    `Singleton`. Go to the book's downloaded source `Code/Chapter_10` folder, copy
    the contents of the `Singleton.cs` file, and paste it into your new script. A
    `Singleton` is common pattern in Unity for creating an object you only want one
    of and when you never want that object destroyed. If you are new to `Singleton`,
    it will be in your best interest to spend some time and review the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new script in the same folder called `SceneController` and replace
    the generated code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`SceneController` is a `Singleton` with a `SceneController`. That circular
    reference may be a little confusing, so it is best to think of as a `SceneController`
    that is a `Singleton` which holds the `SceneController` type. Inside the class,
    we need to define a `protected` default constructor in order to force access through
    the `Instance`. We will look at how to use `Instance` shortly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following right after the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add a single property to hold the `position` where the camera
    was last fixed. That way, when we switch scenes, we can just pass the `position`
    property back to the scene so that it can determine where to setup. `LatLongAltitude`
    is a spatial data type that holds the position of the camera in latitude, longitude,
    and altitude.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following new method, `LoadScene`, with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`LoadScene`, is where all the work happens. We will call `LoadScene` on the
    `SceneController`, passing in the `scene` name we want to load at the current
    `map` or WRLD camera. Inside the method, we first test to see whether the current
    `map` is being controlled; if it is, we just ignore the camera and use the controlled
    camera. Next, we test whether the `mapCamera` is null; if it is, we want to exit
    with an error. Otherwise, we extract the current position with `ScreenToGeographicPoint`.
    This method extractsthe camera''s main screen focal point, which we assume is
    at half pixel width and height of the screen; `mapCamera.nearClipPlane` sets the
    front of view frustum or camera if you recall from our earlier discussions, which
    equals the altitude of the camera above ground level, or the map in this case.
    At the end of the method, we use `SceneManager`, which is the Unity helper class
    for loading scenes. We call `LoadScene` with the option to replace the scene using `LoadSceneMode.Single`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That completes our `SceneController`. Now, the useful thing about being a `Singleton`
    is that we never have to physically add the component, because it is now always
    considered available. WRLD bases most of their Unity API on this pattern as well.
    We do still have to add some further code that can be activated from our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Building the SceneSwitcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add another script/component that will just activate our `SceneController`.
    Open up the editor and complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script called `SceneSwitcher`, and replace all the pre-generated
    code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following property inside the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a placeholder for the `mapCamera`, the camera being used to render the
    `Wrld map`. We need this when the map is not being controlled by the camera, which
    is the case when the user is in AR / MR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method will be responsible for using the `LoadScene` on the `SceneController`.
    Note the use of `Instance` in between the class and method call. Remember that
    our `SceneController` is a `Singleton`, which is an object and not a static class.
    Therefore, we need an instance, and that is provided with a helper property called
    `Instance` in `Singleton` and so when calling a method on `SceneController`, we
    always call it through `Instance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save all your files, if you haven't already done so, and return to Unity. Ensure
    that you have no compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the SceneSwitcher prefab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the code complete, it is now time to build our `SceneSwitcher` prefab.
    Open the editor to the `Navigation` scene and complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select GameObject | UI | Canvas. Add the `SceneSwitcher` component
    (script) to the canvas and rename it as `SceneSwitcher`. Set the Map Camera property
    on the `Scene Switcher` to use the Main Camera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **SceneSwitcher** object in the Hierarchy window and then, from
    the menu, select GameObject | UI | Panel. Set the properties of the panel, as
    shown in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a9ab0a9-5b10-480e-87d2-b1168333b080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting the properties on the Panel
  prefs: []
  type: TYPE_NORMAL
- en: Set the Anchor by clicking on the button and then, when the Anchor Presets menu
    opens, simultaneously press the pivot and position keys (*Shift* + *Alt* on Windows)
    and then click on the top-left corner. This will set the panel to anchor to the
    top left. You will also need to add a Grid Layout Group component and set the
    properties specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Panel and, from the menu, choose GameObject | UI | Button. Rename
    the button Switch and set the button text to Switch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set an OnClick handler for the Switch button, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3a757e63-cb52-4f4f-b13e-bb07e5d1ab50.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a button OnClick handler
  prefs: []
  type: TYPE_NORMAL
- en: We set the parameter, which is a string, to Main. Main is the name of the scene
    we want to switch to when the user clicks on the button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `SceneSwitcher` object from the Hierarchy window and drop it into the
    `Assets/HoloCore/Prefabs` folder of the Project window. This will create a new
    prefab for us to use in the Main scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the Main scene in the `Assets/HoloCore/Scenes` folder. When
    prompted, save the `Navigation` scene changes, of course.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `SceneSwitcher` prefab from the `Assets/HoloCore/Prefabs` folder and
    drop it into an empty area of the Hierarchy window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Map Camera property on the `SceneSwitcher` component (on `SceneSwitcher`
    object) to the VideoSeeThroughCamera.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `SceneSwitcher` object and locate the Switch button. Change the OnClick
    event handler to pass `Navigation`,which is the scene we want to load from Main.
    Remember that the scene names must match exactly, so watch your case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scenes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying the Wrld map script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are almost done; the last thing we need to do is let the `Wrld Map` script
    pull the last camera''s position from our singleton `SceneController`. This means
    that we unfortunately have to modify the source of the `Wrld Map` script. Generally,
    we want to avoid modifying a third-party API, except that we have the source,
    and it really is our only option. Open up the `WrldMap` script, located in the
    `Assets/Wrld/API` folder, and follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following, between the lines identified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Scroll down to the `SetupApi` method and insert the following code between
    the lines identified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All this does is set the map to the last position the camera was pointed at.
    You can see that we are using the `SceneController` singleton here to access the
    camera's last known position. You can see in the `SetupApi` method where a configuration
    object is defined and set. Hopefully, in the future, `Wrld` allows for this configuration
    to be passed into the script. If that was possible, we could just modify that
    configuration before it is passed to the `WrldMap` script, thus eliminating the
    need for us to add our own code in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file and return to Unity. Check for any errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the Build Settings dialog and ensure that both scenes are added, active,
    and in the order shown in the following excerpt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e6692a0-5ea2-40fc-8c14-6f1a8311348a.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the scenes and scene order on Build Settings dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect, build, and run the app. Since we are starting at `0`, `0` in latitude
    and longitude spatial coordinates, the map will start just off the coast of Africa,
    which is `0`, `0`. Use a pinch touch gesture to zoom out until you see the global
    view of the world. Use a touch slide gesture to pan the map to North America,
    currently the best place to view `WRLD` data. Choose an area that is familiar
    and zoom in until you start to see 3D objects. Then, press the Switch button to
    switch the interface to MR and AR. You can switch back to the Main view by pressing
    Switch again. The following is an image showing the augmented reality mode and
    another user using the mixed reality mode with a HoloKit headset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d2c2037-bde3-4528-b0d2-baa90bd633c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Augmented reality view of the application running
  prefs: []
  type: TYPE_NORMAL
- en: We now have an app that lets a user navigate a map and then switch to view areas
    of interest in AR or MR mode. This works well, except that it would be better
    if the user started at their current position. In order to do that, we need to
    understand a bit more about mapping, GIS, and GPS, which we will cover in the
    next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mapping, GIS, and GPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unity, as we already learned, tracks its objects in 3D space using a point
    with a **Cartesian** coordinate reference system of x, y, and z. When we plot
    a point on a map of the world, it is no different; we need to reference the point,
    except that now we need to use a spherical or **geographic** reference system
    to represent a position on the earth, because as we all know, the earth is spherical.
    However, converting between a geographic system and Cartesian system is expensive.
    Many mapping applications, therefore, use an intermediary reference known as **earth-centered**, **earth-fixed** (**ECEF**),
    which represents mapping data on an earth-fixed Cartesian coordinate reference
    system. The following is a diagram shows the differences between Cartesian, geographic,
    and ECEF coordinate reference systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/32cf584a-1169-4fd4-8e23-210c0e0ccbf9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comparison of coordinate reference systems
  prefs: []
  type: TYPE_NORMAL
- en: Now, you may have already noticed that WRLD supports ECEF out of the box. As
    we mentioned, since ECEF is already in a Cartesian frame of reference, the conversions
    are much easier and quicker. However, for us, we just want to position the camera
    at the user's geographic coordinate reference, which we can easily obtain from
    the user's device using GPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing the user''s GPS on their device takes a bit of work, but fortunately,
    we can do this all in one place. Let''s open up the `SceneController` script and
    make the following modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two new properties at the top of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new method just under the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Awake` method is a special Unity method that runs when the `GameObject`
    first initializes. Inside of the method, we are calling `StartCoroutine`. `StartCoroutine`
    is another special method in Unity that allows you to create a `coroutine`. `Coroutines`
    are a way of interrupting or breaking your code flow, doing something else, and
    then returning to complete your original task. In the call, we are passing in
    a method call `GetLocationPoint()`, which sets up that method as a `coroutine`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following method to create the `coroutine`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A coroutine must return `IEnumerator`. By adding the return type, the method
    can now `yield` or interrupt its execution with a `yield return` statement that
    returns a `YieldInstruction`. We will see how to do that shortly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Just inside `GetLocationPoint`, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This line of code prompts the user for access to the `location` services, also
    known as GPS. We do this in order to explicitly identify the user's `location`,
    provided that their device's GPS is not being blocked or the user has the `location`
    service disabled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google has developed their own `location` service in essence by mapping wireless
    endpoint MAC addresses to geographic coordinates. Google does this by essentially
    war driving with its self-driving Street View cars. While those cars drive themselves
    around, they are also grabbing the MAC address of every wireless device that they
    can detect at the time of mapping that to a GPS `location`. As it turns out, this
    service can actually be more accurate for providing `location` in more dense metropolitan
    areas where GPS line of sight is difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This block of code checks whether the user had GPS enabled; if they don't, there
    is nothing we can do. We set `isLoaded` to `true`, which will be a flag to let
    outside methods know that we found or didn't find a `location`. Then, we `yield
    return` the results of a call to `SetStatus`. Remember that because we are in
    a `coroutine`, `yield return` means that we want to interrupt code execution at
    this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down just past the `GetLocationPoint` method and add the following new
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Inside the method, we are setting our `status` text, which will be a message
    we want to display back to the user. Then, we return a new `WaitForSeconds(time)`,
    where `time` represents the number of seconds to wait. There are many different
    forms of `YieldInstruction` that you can use to break your code. The `YieldInstruction`
    here just waits for a set number of seconds and then returns to continue the code
    where it left off. Keep in mind that after the `yield` has elapsed, for whatever
    reason, code will then resume from exactly where it left off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to where we left off in `GetLocationPoint`. Right after the `yield return
    SetStatus` call, we are executing `yield break`. This line breaks the `coroutine`
    and exits the method, which is equivalent to return in a normal method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we understand `coroutines`, let''s enter the next section of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we start by setting a `status` message and letting the user know that
    we are starting the service, which we then do. After that, we continually loop,
    breaking every second with `yield return new WaitForSeconds(1)`, adjusting our
    counter `maxWait` for every iteration. We need to wait for the `location` service
    to initialize; sometimes this can take a while.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code to handle when our counter has expired (`maxWait<1`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `if` block, we set the `status` and `loaded` flag. Then, we return
    from the `coroutine` with `yield break`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we want to handle when the service fails or starts by entering the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This code handles the service failure or success. In the failure path, we set
    an error message and exit. Otherwise, we set a `status` and wait for `10` seconds.
    We do this so that the user can read the message. Then, we set the position according
    to the geographic coordinates the device provides us with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we stop the service with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We stop the service because we don't need to continually get `location` updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you want to keep the service open and use it to track the user's `location`,
    such as Pokemon Go, then just ensure that you stop the service when the object
    is being destroyed. You can do this in a method called `OnDisable()`, which is
    another special Unity method that is used to clean up the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we also want to update and overload the `LoadScene` method with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We overloaded the method in order to allow two different behaviors when switching
    scenes. The new method we added won't worry about setting the `position` for the
    camera. We also added some logging, so we can see what values are being set by
    looking at our Android debug tools while running the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the file when you are done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code we just set up was originally derived from the Unity sample, but it
    has been modified for your reuse. Since accessing the `location` service can take
    a while, we will add a new scene in order to handle the `location` service starting
    up. This will be a splash screen that you can make prettier later on.
  prefs: []
  type: TYPE_NORMAL
- en: Making the Splash scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Splash` scene we are building is very basic for now, with just some status
    messages. You can, of course, style it and add any images you like later on. Open
    up the editor and complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene called `Splash` and save the scene to the `Assets/HoloCore/Scenes`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the menu, select GameObject | UI | Panel. This will add a new Canvas with
    a child Panel and EventSystem. Set the background color of Panel to a dark gray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the Panel and, from the menu, select GameObject | UI | Text. Change
    the name of the object to `Status` and set its properties in the Inspector window,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/decf2da0-be21-4626-9c74-3b8befc51038.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the Status text properties
  prefs: []
  type: TYPE_NORMAL
- en: This is the where we will display those status messages back to the user, which
    means that we need a script that can update the `status` messages as well as know
    when the service has been loaded and the application can start.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new C# script called `SceneLoader` in the `Assets/HoloCore/Scripts`
    folder and replace the pre-generated code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This simple class is what we will use to track the status of our `SceneController`.
    All the action takes place in the `Update` method. We first check whether the
    `SceneController` has loaded by testing `isLoaded`. If the scene has not loaded,
    we display the `status` text in the `statusText.text` object. Remember that the `Update` method
    is run every rendering frame, so we are testing this condition several times a
    second. Save the script, and next, we need to add it as a component to our scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return to the Unity editor and wait for the new class to compile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new object called `ScreenLoader` and add the new `ScreenLoader` script
    to it. Then, set the properties of `SceneLoader` to what is shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c6c0e1fe-e4d1-4a08-b4c7-9bded136ac6d.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting the SceneLoader component properties
  prefs: []
  type: TYPE_NORMAL
- en: Set the Status Text property to the `Status` object. You can use the bull's-eye
    icon to select the object from the scene or just drag the object from the Hierarchy
    window and drop it into the slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open Build Settings, add the `Splash` scene to the build, and ensure that it
    is the first scene, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3891abf3-6dc3-49c9-949f-e556357cd172.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding the Splash scene to the build
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead, connect, build, and run. You will now be taken to `location` as identified
    by the `Location` service, that is, if you allow the service to connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fixing the altitude issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may notice an issue if you live above 500 meters above sea level. This
    issue happens because our AR camera is fixed at 500 meters altitude. The problem
    is that we have our AR camera at a fixed height; we now need to adjust that based
    on the camera''s altitude. Open back up the editor and complete the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script and replace the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This script creates a new class called `SceneCameraMover`. The job of `SceneCameraMover` is
    to move the AR camera into position when the view switches to AR / MR.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the script and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Main scene from the `Assets/HoloCore/Scenes` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand HoloKitCameraRig and select VideoSeeThroughCamera. Then, add the script
    to the component using Add Component and searching for SceneCameraMover.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the Transform on the HoloKitCameraRig to `0`, `0`, `0`. We will now let
    the script move the camera to the position we need.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scenes and project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect, build, and run. Go to an area that is well above sea level, say the
    mountains, and switch to AR / MR view. The camera should now position itself correctly
    based on the altitude you were viewing the scene at.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you explore other areas of interest around the world. In the next
    section, we will finish up the chapter and our discussion of AR and ARCore with
    the next steps, and we'll see where you can go to build your own incredible tech
    demo or commercial app.
  prefs: []
  type: TYPE_NORMAL
- en: The online example demos from WRLD recommend using an alternate streaming camera
    for AR visuals in ARCore or ARKit apps. However, we found that adding an alternate
    camera, alongside the already two additional cameras for the HoloKit, caused the
    app to be more unstable than it already can be. If you don't plan to use MR or
    HoloKit, you likely want to experiment with the alternate streaming camera.
  prefs: []
  type: TYPE_NORMAL
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tech demo we developed is an excellent example of the possibilities of
    integrating technologies across user experiences. This has already been done extensively,
    and one popular example is Pokemon Go. In fact, you can say that Pokemon Go put
    AR into our vocabulary. So what is the next big AR app you will develop with ARCore?
    Are you still trying to think of some ideas or possibilities? The following is
    a list of app ideas or industries that are investing heavily in AR right now:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entertainment (Games)**: Gaming and entertainment is the most competitive
    space you can be in. Developing an app for this space requires hard work and a
    bit of luck. There have been some grand successes in this space, but that was
    after some hard work and considerable backing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Healthcare (Emergency services)**: The healthcare industry is diving into
    the AR / MR and VR world in full force. Since this industry is heavily funded,
    it is now a leader in these technologies. If you want to get into cutting-edge
    reality development, this is the space to be in. It can be more difficult to get
    into, since this industry has traditionally been more isolated, but now there
    are plenty of opportunities with the explosion of growth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marketing (Retail)**: As AR becomes more mainstream and readily available,
    we will come across new apps developed in this space. There have already been
    some great novel concepts used to encourage sales, which have worked, except that
    AR has become something of a novelty in this space as of late. However, if you
    talk to anyone in marketing, they will agree that some day a majority of advertising
    will be provided via AR. Until then though, perhaps you can think of the next
    great app that will sell hamburgers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Education (Knowledge transfer)**: This is another really big industry that
    can be hard to get into, that is, if you are planning to put your app in a classroom.
    Alternatively, you can build an educational app that perhaps teaches you how to
    cook but is delivered through an app store. Either way, this can be a difficult
    industry to get into but very rewarding, especially if you like teaching or learning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Military**: It''s very difficult to get into, unless you have a military
    background or other established credentials. This likely means a strong educational
    background as well. This is an interesting industry if you can get in, and is
    certainly not for everyone. If this is your choice though, you will most certainly
    be working on cutting-edge apps or tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Travel & tourism (History)**: This one crosses over with education, as some
    of the same principles may apply. Perhaps, it is showing someone a historical
    battle over the area where the real battle took place. There are plenty of opportunities
    for developers of all skill levels to work in this area building AR / MR apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design (All)**: This one can tie in a lot with retail applications. Perhaps
    demonstrating an outfit overlaid onto someone''s body or trying to determine whether
    a chair works in a room. We put this further down in the list because our expert
    survey listed this one lower as well. However, as we demonstrated, ARCore has
    plenty of great design applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Industrial (Manufacturing)**: Applications of AR can help human users as
    well as provide better foundations for future automation of systems or other processes.
    This means that the AR systems we build for humans now will also help us make
    the manufacturing robots of the future smarter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automotive**: We have already seen AR system in automobiles for a few years
    now. From heads-up displays to GPS devices, this industry has already embraced
    AR, although it isn''t likely that developing an embedded AR app for this industry
    makes a lot of sense. Most users, drivers, would likely prefer to use an AR off
    their device. Perhaps it makes more sense for the automotive industry to provide
    a docking station for a mobile device in vehicles with an AR interface?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Music**: Think of this as more for the musician and not the audience. This
    is a set of AR tools that help musicians compose and work with music. Not for
    everyone and not well suited to ARCore, perhaps they will embed voice recognition
    or other audio recognition into ARCore someday.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever you plan to build as your next app, we sincerely wish you the best
    of luck and would eagerly like to hear about any great apps. Be sure to contact
    the author with your great app concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Complete the following exercises on your own:**'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the `HoloCore` example and track the user's position with a block
    or sphere. Hint—the first part of this example is in the code download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track the user's position as they move on the map. Hint—you will now need to
    update the user's position from the most recent GPS readings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Track multiple users' positions around you. Hint—you can use the Firebase Realtime
    Database to track the user's position in geographic coordinates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we diverted away from AR a little and explored mixing augmented
    and mixed reality. We discovered that we can easily experience mixed reality apps
    with a simple device called a HoloKit or other cheap headset. ARCore tracks the
    user well and is a great fit for adding the MR experience. Who knows, in the future
    when everyone is wearing MR glasses, will we even distinguish AR and MR as different?
    We then set up the HoloKit template app and went to work building a quick MR demo.
    After that, we expanded on our demo by adding in WRLD. WRLD, as we learned, is
    a fun and easy-to-use API that can quickly give us some large-scale impressive
    3D scenery that is representative of the user's area. From there, we developed
    a number of scenes for all the users to move a map touch interface to a full mixed-reality
    view of the map, where we were able to obtain the user's geographic coordinates
    from their device's GPS and put them at the same position in WRLD. Finally, we
    looked to the future and industries that you can focus your app development skills
    on.
  prefs: []
  type: TYPE_NORMAL
- en: We complete our journey in the next chapter with a discussion of performance
    and troubleshooting, both of which will be helpful as you grow your skills to
    become a better AR developer.
  prefs: []
  type: TYPE_NORMAL
