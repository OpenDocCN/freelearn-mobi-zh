- en: 'Chapter 11: Conclusion and Next Steps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章：结论和下一步行动
- en: This book shows you how to write beautiful, fast, and maintainable Jetpack Compose
    apps. In Chapters 1 to 3, I introduced you to the fundamentals of Jetpack Compose,
    explained core techniques and principles, as well as important interfaces, classes,
    packages, and, of course, composable functions. Chapters 4 to 7 focused on building
    Compose UIs. You learned how to manage state and navigate to different screens.
    We also explored the ViewModel and Repository patterns. Chapters 8 to 10 covered
    advanced topics such as animation, interoperability, testing, and debugging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书向您展示了如何编写美观、快速且易于维护的Jetpack Compose应用程序。在第1章到第3章中，我向您介绍了Jetpack Compose的基础知识，解释了核心技术和原则，以及重要的接口、类、包，当然还有可组合函数。第4章到第7章专注于构建Compose
    UI。您学习了如何管理状态并导航到不同的屏幕。我们还探讨了ViewModel和Repository模式。第8章到第10章涵盖了高级主题，例如动画、互操作性、测试和调试。
- en: 'This final chapter is all about what you can do next. We''ll investigate the
    near future of Jetpack Compose and explore neighboring platforms, because you
    can apply your Compose knowledge there, too. The main sections of this chapter
    are the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章完全关于您接下来可以做什么。我们将探讨Jetpack Compose的近期未来，并探索邻近的平台，因为您也可以在那里应用您的Compose知识。本章的主要部分如下：
- en: Exploring the future
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索未来
- en: Migrating to Material You
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到Material You
- en: Moving beyond Android
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越Android
- en: We'll start by looking at the next version of Jetpack Compose, 1.1, which was
    not yet stable when this book went into production. This iteration will bring
    bug fixes, performance improvements, and new features, for example, `ExposedDropdownMenuBox()`,
    an exposed drop-down menu, and `NavigationRail()`. This vertical navigation bar
    is intended for foldables and large-screen devices.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看Jetpack Compose的下一个版本1.1，当本书进入生产阶段时，这个版本还不稳定。这次迭代将带来错误修复、性能改进和新功能，例如`ExposedDropdownMenuBox()`，一个暴露的下拉菜单，以及`NavigationRail()`。这个垂直导航栏旨在用于可折叠设备和大型屏幕设备。
- en: The second main section, *Migrating to Material You*, introduces you to Material
    3 for Compose. This package contains *Material You*, the latest iteration of Google's
    beautiful design language, to Jetpack Compose apps. We'll look at some differences
    between Material 2 and Material 3, for example, the simplified typography and
    color schemes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要部分，*迁移到Material You*，向您介绍了为Compose设计的Material 3。这个包包含了*Material You*，这是谷歌美丽设计语言的最新迭代，用于Jetpack
    Compose应用程序。我们将看看Material 2和Material 3之间的某些差异，例如简化的字体和配色方案。
- en: The *Moving beyond Android* section shows you how to use your Jetpack Compose
    knowledge on other platforms, for example, desktop and the web. I will briefly
    explain how to bring one of my sample composable functions to desktop.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*超越Android*部分向您展示了如何将您的Jetpack Compose知识应用于其他平台，例如桌面和网页。我将简要解释如何将我的一个示例可组合函数带到桌面。'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is based on the `ExposedDropdownMenuBoxDemo` and `NavigationRailDemo`
    samples. Please refer to the *Technical requirements* section in [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information about how to install and set
    up Android Studio, and how to get the repository accompanying this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于`ExposedDropdownMenuBoxDemo`和`NavigationRailDemo`示例。请参考[*第1章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建您的第一个Compose应用程序*，了解有关如何安装和设置Android
    Studio以及如何获取本书附带的存储库的信息。
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_11](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有代码文件都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_11](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_11)。
- en: Exploring the future
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索未来
- en: This book is based on Jetpack Compose 1.0, the first stable version of the library,
    which was released in July 2021\. Just like all other Jetpack components, Google
    is constantly enhancing and updating Compose. At the time of finishing the manuscript,
    version 1.1 was in beta. When it becomes stable, I will update the repository
    accompanying this book to reflect the changes. You can find the latest version
    of the samples of this book at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书基于Jetpack Compose 1.0，这是库的第一个稳定版本，于2021年7月发布。就像所有其他Jetpack组件一样，谷歌不断改进和更新Compose。在完成手稿时，1.1版本处于测试阶段。当它变得稳定时，我将更新本书附带的存储库以反映这些变化。您可以在[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose)找到本书的样本的最新版本。
- en: 'Jetpack Compose 1.1 will offer bug fixes, new functionality, and performance
    improvements. New features include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose 1.1将提供错误修复、新功能和性能改进。新功能包括以下内容：
- en: The Compose compiler will support older versions of the Compose runtime. This
    allows you to use the latest tooling while still targeting older Compose versions.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose编译器将支持较旧的Compose运行时版本。这允许您使用最新的工具，同时仍然针对较旧的Compose版本。
- en: Touch target sizing (UI elements may get extra spacing to make them more accessible).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触摸目标尺寸（UI元素可能获得额外的间距以使其更易于访问）。
- en: '`ImageVector` caching.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageVector`缓存。'
- en: Support for Android 12 stretch overscroll.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Android 12扩展滚动。
- en: Several previously experimental APIs (for example, `AnimatedVisibility`, `EnterTransition`,
    and `ExitTransition`) will become stable. Additionally, Jetpack Compose 1.1 will
    support newer versions of Kotlin. Unfortunately, you will also face some breaking
    changes. For example, lambdas in `EnterTransition` and `ExitTransition` factories
    may be moved to the last position in the parameter list.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 几个之前实验性的API（例如，`AnimatedVisibility`、`EnterTransition`和`ExitTransition`）将变为稳定。此外，Jetpack
    Compose 1.1将支持Kotlin的新版本。不幸的是，您还将面临一些破坏性变化。例如，`EnterTransition`和`ExitTransition`工厂中的lambda表达式可能被移动到参数列表的最后一个位置。
- en: Showing exposed drop-down menus
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示暴露的下拉菜单
- en: There are also new Material UI elements. For example, `ExposedDropdownMenuBox()`
    shows an exposed drop-down menu, which displays the currently selected menu item
    above the list of options. The `ExposedDropdownMenuBoxDemo` sample illustrates
    the usage of the composable function (*Figure 11.1*).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有新的Material UI元素。例如，`ExposedDropdownMenuBox()`显示一个暴露的下拉菜单，它将当前选中的菜单项显示在选项列表上方。`ExposedDropdownMenuBoxDemo`样本说明了composable函数（*图11.1*）的用法。
- en: '![Figure 11.1 – The ExposedDropdownMenuBoxDemo sample'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – ExposedDropdownMenuBoxDemo样本'
- en: '](img/B17505_11_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_11_1.jpg)'
- en: Figure 11.1 – The ExposedDropdownMenuBoxDemo sample
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – ExposedDropdownMenuBoxDemo样本
- en: 'Currently, `ExposedDropdownMenuBox()` is marked experimental. Therefore, you
    must add the `@ExperimentalMaterialApi` annotation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`ExposedDropdownMenuBox()`被标记为实验性。因此，您必须添加`@ExperimentalMaterialApi`注解：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ExposedDropdownMenuBoxDemo()` puts `ExposedDropdownMenuBox()` in a `Box()`
    and horizontally centers the menu at the top. The menu items are stored in a list
    (`titles`). The `expanded` state reflects the visibility of the menu items. `selectedTxt`
    represents the currently selected text. Here''s how they are used:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExposedDropdownMenuBoxDemo()`将`ExposedDropdownMenuBox()`放入`Box()`中，并将菜单水平居中于顶部。菜单项存储在列表（`titles`）中。`expanded`状态反映了菜单项的可见性。`selectedTxt`代表当前选中的文本。以下是它们的用法：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`ExposedDropdownMenuBox()` has two children, read-only `TextField()` and `ExposedDropdownMenu()`.
    The text field shows `selectedTxt`. As `readOnly` is set to `true`, the `onValueChange`
    block can be empty. `expanded` controls the trailing icon, which reflects the
    visibility of the menu items. The `onExpandedChange` lambda expression passed
    to `ExposedDropdownMenuBox()` is executed when the user clicks on the exposed
    drop-down menu. Usually, you will negate `expanded`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExposedDropdownMenuBox()`有两个子元素，只读的`TextField()`和`ExposedDropdownMenu()`。文本字段显示`selectedTxt`。由于`readOnly`设置为`true`，`onValueChange`块可以是空的。`expanded`控制尾随图标，它反映了菜单项的可见性。传递给`ExposedDropdownMenuBox()`的`onExpandedChange`
    lambda表达式在用户点击暴露的下拉菜单时执行。通常，您会否定`expanded`。'
- en: '`ExposedDropdownMenu()` has at least one `DropdownMenuItem()` as its content.
    Typically, you will want to hide the menu (`expanded = false`) and update the
    text field (`selectedTxt = title`). The `onDismissRequest` block passed to `ExposedDropdownMenu()`
    should also close the menu, but not update the text field.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExposedDropdownMenu()` 至少包含一个 `DropdownMenuItem()` 作为其内容。通常，您会希望隐藏菜单（`expanded
    = false`）并更新文本字段（`selectedTxt = title`）。传递给 `ExposedDropdownMenu()` 的 `onDismissRequest`
    块也应该关闭菜单，但不要更新文本字段。'
- en: So, `ExposedDropdownMenuBox()` is a very compact way of showing a selection
    of items and allowing the user to choose one. In the following section, I show
    you another Material UI element that debuts in Compose 1.1\. `NavigationRail()`
    presents top-level navigation destinations vertically.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`ExposedDropdownMenuBox()` 是显示一系列项目并允许用户选择其中之一的一种非常紧凑的方式。在下一节中，我将向您展示 Compose
    1.1 中首次亮相的另一个 Material UI 元素。`NavigationRail()` 以垂直方式呈现顶级导航目的地。
- en: Using NavigationRail()
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NavigationRail()
- en: Compose offers several ways to navigate to top-level destinations within your
    app. For example, you can place a navigation bar at the bottom of the screen using
    `BottomNavigation()`. I show you how to use it in the *Adding navigation* section
    of [*Chapter 6*](B17505_06_ePub.xhtml#_idTextAnchor105), *Putting Pieces Together*.
    Jetpack Compose 1.1 includes another UI element for top-level navigation. `NavigationRail()`
    implements the **navigation rail** interaction pattern, a vertical navigation
    bar especially for large screens such as tablets and open foldables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 提供了多种方式在您的应用中导航到顶级目的地。例如，您可以使用 `BottomNavigation()` 在屏幕底部放置一个导航栏。我在
    [*第 6 章*](B17505_06_ePub.xhtml#_idTextAnchor105) 的 *添加导航* 部分向您展示了如何使用它，*将部件组合在一起*。Jetpack
    Compose 1.1 包含另一个用于顶级导航的 UI 元素。`NavigationRail()` 实现了 **导航栏** 交互模式，这是一个专门为平板电脑和可折叠大屏设计的垂直导航栏。
- en: If the screen is not big enough, or the foldable is closed, a standard bottom
    navigation bar should be displayed instead. The `NavigationRailDemo` sample shows
    how to achieve this. In *Figure 11.2*, you can see the app in portrait mode.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果屏幕不够大，或者可折叠设备关闭，则应显示标准底部导航栏。`NavigationRailDemo` 示例展示了如何实现这一点。在 *图 11.2* 中，您可以看到应用在竖屏模式下的样子。
- en: '![Figure 11.2 – The NavigationRailDemo sample in portrait mode'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – NavigationRailDemo 示例在竖屏模式下的截图'
- en: '](img/B17505_11_2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17505_11_2.jpg)'
- en: Figure 11.2 – The NavigationRailDemo sample in portrait mode
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – NavigationRailDemo 示例在竖屏模式下的截图
- en: 'To continue, an elaborate approach would be to use the Jetpack `WindowManager`
    library, however this is beyond the scope of the book. Instead, we will use `NavigationRailDemo
    ( )` for the sake of simplicity, which determines whether the navigation rail
    should be used by simply comparing the current width of the screen with the minimum
    size (600 density-independent pixels):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，一个详细的方法是使用 Jetpack `WindowManager` 库，但这超出了本书的范围。相反，我们将使用 `NavigationRailDemo()`
    以简化起见，它通过比较当前屏幕宽度与最小尺寸（600 密度无关像素）来确定是否应使用导航栏：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Scaffold()` receives bottom bars through the `bottomBar` lambda expression.
    If the navigation rail should not be shown (`showNavigationRail` is `false`),
    my `BottomBar()` composable is invoked. Otherwise, no bottom bar is added. The
    currently active screen is stored in a mutable `Int` state (`index`). It is passed
    to `BottomBar()` and `Content()`. Next, let''s briefly revisit how `BottomNavigation()`
    works by looking at my `BottomBar()` composable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scaffold()` 通过 `bottomBar` 独占表达式接收底部栏。如果不应显示导航栏（`showNavigationRail` 为 `false`），则调用我的
    `BottomBar()` 可组合组件。否则，不添加底部栏。当前活动屏幕存储在一个可变的 `Int` 状态（`index`）中。它传递给 `BottomBar()`
    和 `Content()`。接下来，让我们简要回顾一下 `BottomNavigation()` 的工作原理，通过查看我的 `BottomBar()` 可组合组件：'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The content of `BottomNavigation()` consists of several `BottomNavigationItem()`
    elements with an icon, a label, and an `onClick` block. My implementation just
    updates the `index` state, which is also used inside `Content()`. This composable
    displays the navigation rail if needed, and the main content (screen), which is
    just a box with text centered inside:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`BottomNavigation()` 的内容由几个带有图标、标签和 `onClick` 块的 `BottomNavigationItem()` 元素组成。我的实现只是更新了
    `index` 状态，该状态也在 `Content()` 中使用。这个可组合组件在需要时显示导航栏，以及主要内容（屏幕），它只是一个内部文本居中的盒子：'
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The navigation rail and the screen are arranged horizontally in `Row()`. Like
    `BottomNavigation()`, `NavigationRail()` gets one or more child elements that
    represent the navigation destinations. The children (`NavigationRailItem()`) have
    a label, an icon, and an `onClick` block. *Figure 11.3* shows the `NavigationRailDemo`
    sample in landscape mode.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 导航栏和屏幕在 `Row()` 中水平排列。与 `BottomNavigation()` 类似，`NavigationRail()` 获取一个或多个子元素，这些子元素代表导航目的地。子元素（`NavigationRailItem()`）有一个标签、一个图标和一个
    `onClick` 块。*图 11.3* 展示了横屏模式下的 `NavigationRailDemo` 示例。
- en: '![Figure 11.3 – The NavigationRailDemo sample in landscape mode'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 横屏模式下的 NavigationRailDemo 示例](img/B17505_11_3.jpg)'
- en: '](img/B17505_11_3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B17505_11_3.jpg](img/B17505_11_3.jpg)'
- en: Figure 11.3 – The NavigationRailDemo sample in landscape mode
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 横屏模式下的 NavigationRailDemo 示例
- en: While Jetpack Compose 1.1 will add some Material UI elements and polish the
    existing ones, it still implements *Material Design* as present in previous Android
    versions, including 11 (sometimes referred to as Material 2). *Material You*,
    which debuted with Android 12, will be available for Compose, too. However, it
    is not an in-place update of the existing packages but comes as a new library.
    In the following section, we look at Material 3 for Jetpack Compose, which was
    in early alpha at the time this chapter was written.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Jetpack Compose 1.1 将添加一些 Material UI 元素并润色现有的元素，但它仍然实现了与之前 Android 版本（包括
    11，有时称为 Material 2）中存在的 *Material Design*。随着 Android 12 的推出，*Material You* 也将对
    Compose 可用。然而，它不是现有包的就地更新，而是一个新的库。在接下来的章节中，我们将探讨 Jetpack Compose 的 Material 3，当时这个章节正在编写时，它还处于早期
    alpha 版本。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may be wondering what the difference between Material You and Material 3
    is. I am referring to Material 3 as the latest version of the Material Design
    specification, whereas Material You is the implementation on Android 12.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道 Material You 和 Material 3 之间的区别。我指的是 Material 3 作为 Material Design 规范的最新版本，而
    Material You 是 Android 12 上的实现。
- en: Migrating to Material You
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到 Material You
- en: '**Material You** is the latest iteration of Google''s design language Material
    Design. It was announced during Google I/O 2021 and was first available on Pixel
    smartphones running Android 12\. Eventually, it will be rolled out to other devices,
    form factors, and frameworks. Like its predecessors, Material You is based on
    typography, animation, and layers. But it emphasizes personalization: depending
    on the platform, *Material You* implementations may use color palettes derived
    from the system wallpaper.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Material You** 是谷歌设计语言 Material Design 的最新迭代。它是在 2021 年的 Google I/O 上宣布的，并首次在运行
    Android 12 的 Pixel 智能手机上可用。最终，它将扩展到其他设备、形态和框架。像其前辈一样，Material You 基于排版、动画和层级。但它强调个性化：根据平台，*Material
    You* 的实现可能使用来自系统壁纸的颜色调色板。'
- en: Looking at some differences between Material 2 and Material 3 for Compose
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较 Material 2 和 Material 3 的差异
- en: To use *Material You* in your Compose app, you must add an implementation dependency
    to `androidx.compose.material3:material3` in the module-level `build.gradle` file.
    The base package for composables, classes, and interfaces changes to `androidx.compose.material3`.
    If you want to migrate an existing Compose app to this new version, you at least
    need to change imports. Unfortunately, the names of quite a few composable functions
    will change, too. To get an idea of the differences, I have reimplemented `NavigationRailDemo`
    for *Material You*. The project is named `NavigationRailDemo_Material3`. This
    way, you can easily examine the changes by comparing important files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的 Compose 应用中使用 *Material You*，您必须在模块级别的 `build.gradle` 文件中添加对 `androidx.compose.material3:material3`
    的实现依赖。可组合对象、类和接口的基本包更改为 `androidx.compose.material3`。如果您想将现有的 Compose 应用迁移到这个新版本，至少需要更改导入。不幸的是，相当多的可组合函数的名称也将改变。为了了解差异，我已经为
    *Material You* 重新实现了 `NavigationRailDemo`。该项目命名为 `NavigationRailDemo_Material3`。这样，您可以通过比较重要文件轻松地检查更改。
- en: '![Figure 11.4 – The NavigationRailDemo_Material3 sample in landscape mode'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – 横屏模式下的 NavigationRailDemo_Material3 示例](img/B17505_11_4.jpg)'
- en: '](img/B17505_11_4.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B17505_11_4.jpg](img/B17505_11_4.jpg)'
- en: Figure 11.4 – The NavigationRailDemo_Material3 sample in landscape mode
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – 横屏模式下的 NavigationRailDemo_Material3 示例
- en: 'Specifically, `TopAppBar()` needs to be replaced by `SmallTopAppBar()` or one
    of its bigger siblings, `MediumTopAppBar()` and `LargeTopAppBar()`. Other changes
    include the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，需要将 `TopAppBar()` 替换为 `SmallTopAppBar()` 或其更大的兄弟之一，`MediumTopAppBar()`
    和 `LargeTopAppBar()`。其他更改包括以下内容：
- en: '`BottomNavigation()` will be generalized to `NavigationBar()`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BottomNavigation()` 将被泛化为 `NavigationBar()`。'
- en: '`BottomNavigationItem()` is now called `NavigationBarItem()`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BottomNavigationItem()` 现在被称为 `NavigationBarItem()`。'
- en: '`NavigationRailItem()` remains unchanged.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavigationRailItem()` 保持不变。'
- en: 'The last bullet point is interesting: as `NavigationRailItem()` elements very
    much resemble `NavigationBarItem()`, I wonder if these two may be generalized
    in the future.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个要点很有趣：由于 `NavigationRailItem()` 元素与 `NavigationBarItem()` 非常相似，我想知道这两个是否可能在将来被泛化。
- en: Several properties that control the visual representation of UI elements will
    change considerably. For example, Material colors belong to `MaterialTheme.colorScheme`
    instead of the former `MaterialTheme.colors`. For more information about colors
    in Material 3, please refer to the official documentation at [https://m3.material.io/styles/color/dynamic-color/overview](https://m3.material.io/styles/color/dynamic-color/overview).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 几个控制 UI 元素视觉表示的属性将发生显著变化。例如，Material 颜色属于 `MaterialTheme.colorScheme` 而不是之前的
    `MaterialTheme.colors`。有关 Material 3 中颜色的更多信息，请参阅官方文档[https://m3.material.io/styles/color/dynamic-color/overview](https://m3.material.io/styles/color/dynamic-color/overview)。
- en: Styled texts may also require some adaptions because the members of the `Typography`
    class will be simplified. For example, instead of `h1`, `h2`, `h3`, and so on,
    you will use `headlineLarge`, `headlineMedium`, or `headlineSmall`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 样式化文本可能也需要一些调整，因为`Typography`类的成员将被简化。例如，你将不再使用`h1`、`h2`、`h3`等，而是使用`headlineLarge`、`headlineMedium`或`headlineSmall`。
- en: This concludes our brief look at the changes regarding Material 3 and the near
    future of Jetpack Compose. Did you know you can write Compose apps for the web
    and desktop, too? In the following section, we give it a try.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Material 3 和 Jetpack Compose 近期未来的简要探讨。你知道你还可以为网页和桌面编写 Compose 应用吗？在接下来的部分，我们将尝试一下。
- en: Moving beyond Android
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超越 Android
- en: 'While Jetpack Compose is the new UI toolkit on Android, its underlying ideas
    and principles make it attractive for other platforms, too. Let''s see why this
    is the case:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Jetpack Compose 是 Android 上的新 UI 工具包，但其底层思想和原则也使其对其他平台具有吸引力。让我们看看这是为什么：
- en: The declarative approach was first implemented on the web.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明式方法最初是在网页上实现的。
- en: SwiftUI, Apple's implementation of a declarative UI framework, works well for
    iPhones, iPads, watches, and macOS devices.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SwiftUI，苹果对声明式 UI 框架的实现，在 iPhone、iPad、手表和 macOS 设备上运行良好。
- en: Jetpack Compose UI elements use Material Design, which is designed for different
    platforms, device categories, and form factors.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jetpack Compose UI 元素使用 Material Design，它为不同的平台、设备类别和形态设计。
- en: Most importantly, core concepts such as state and composable functions are not
    Android-specific. Therefore, if someone provides the toolchain (for example, the
    Kotlin compiler and the Compose compiler), any platform capable of showing graphics
    *may* be able to execute Compose apps. Certainly, there is an awful lot of work
    to be done.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，核心概念如状态和可组合函数并非 Android 特有的。因此，如果有人提供了工具链（例如，Kotlin 编译器和 Compose 编译器），任何能够显示图形的平台
    *可能* 能够执行 Compose 应用。当然，还有大量的工作要做。
- en: For example, the Compose UI must be hosted *somewhere*. On Android, activities
    are used. On the web, this would be a browser window. And on desktop, it would
    be a window provided by some UI toolkit. Any other functionality (for example,
    network and file I/O, connectivity, memory management, threading) must be addressed
    by other libraries or frameworks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Compose UI 必须托管在 *某处*。在 Android 上，使用活动（activities）。在网页上，这将是一个浏览器窗口。在桌面上，它将是某个
    UI 工具包提供的窗口。任何其他功能（例如，网络和文件 I/O、连接性、内存管理、线程）必须由其他库或框架处理。
- en: JetBrains, the inventor of Kotlin and IntelliJ, decided to tackle this. In recent
    years, the company gained a lot of experience in targeting multiple platforms
    and sharing code among them. For example, with *Kotlin Multiplatform Mobile* you
    can use a single code base for the business logic of iOS and Android apps. *Compose
    Multiplatform* aims to simplify and speed up the development of UIs for desktop
    and the web, and to share UI code among them and Android.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains，Kotlin 和 IntelliJ 的发明者，决定解决这个问题。近年来，该公司在针对多个平台和在这些平台间共享代码方面积累了大量经验。例如，使用
    *Kotlin Multiplatform Mobile*，你可以为 iOS 和 Android 应用使用单个代码库进行业务逻辑。*Compose Multiplatform*
    的目标是简化并加快桌面和网页 UI 的开发，并在它们之间共享 UI 代码以及 Android。
- en: In the following section, I will briefly show how to create a simple Compose
    for Desktop application using the IntelliJ IDE.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我将简要展示如何使用 IntelliJ IDE 创建一个简单的 Compose 桌面应用程序。
- en: Setting up a sample project
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置示例项目
- en: The easiest way to create a Compose for Desktop project is to use the project
    wizard of the IntelliJ IDE. This requires IntelliJ IDEA Community Edition or Ultimate
    Edition 2020.3 or later. Setting up IntelliJ is beyond the scope of this book
    and is not detailed here. *Figure 11.5* shows you how to fill in the project wizard
    dialog.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Compose for Desktop 项目的最简单方法是使用 IntelliJ IDEA 的项目向导。这需要 IntelliJ IDEA Community
    Edition 或 Ultimate Edition 2020.3 或更高版本。设置 IntelliJ 超出了本书的范围，这里没有详细说明。*图 11.5*
    展示了如何填写项目向导对话框。
- en: '![Figure 11.5 – The IntelliJ project wizard'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5 – IntelliJ 项目向导'
- en: '](img/B17505_11_5.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_11_5.jpg)'
- en: Figure 11.5 – The IntelliJ project wizard
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – IntelliJ 项目向导
- en: JetBrains maintains a *Getting started with Compose Multiplatform* tutorial
    on GitHub at [https://github.com/JetBrains/compose-jb/blob/master/tutorials/Getting_Started/README.md](https://github.com/JetBrains/compose-jb/blob/master/tutorials/Getting_Started/README.md).
    Please refer to this for additional information.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: JetBrains 在 GitHub 上维护了一个 *使用 Compose Multiplatform 入门* 教程，网址为 [https://github.com/JetBrains/compose-jb/blob/master/tutorials/Getting_Started/README.md](https://github.com/JetBrains/compose-jb/blob/master/tutorials/Getting_Started/README.md)。请参阅此链接获取更多信息。
- en: The project wizard adds a simple `Main.kt` file inside `src/main/kotlin`. You
    can run it from the **Gradle** tool window by double-clicking on **Tasks** | **compose
    desktop** | **run** (*Figure 11.6*).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 项目向导在 `src/main/kotlin` 内部添加了一个简单的 `Main.kt` 文件。您可以通过双击 **Gradle** 工具窗口中的 **Tasks**
    | **compose desktop** | **run** 来运行它 (*图 11.6*)。
- en: '![Figure 11.6 – The IntelliJ Gradle tool window'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6 – IntelliJ Gradle 工具窗口'
- en: '](img/B17505_11_6.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_11_6.jpg)'
- en: Figure 11.6 – The IntelliJ Gradle tool window
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – IntelliJ Gradle 工具窗口
- en: 'The source code contains a composable called `App()`. It is invoked from the
    `main()` function. Let''s replace the body of `App()` with one of my samples,
    for example, `StateChangeDemo()` from [*Chapter 8*](B17505_08_ePub.xhtml#_idTextAnchor135),
    *Working with Animations*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含一个名为 `App()` 的可组合组件。它从 `main()` 函数中被调用。让我们用我的一个示例来替换 `App()` 的主体，例如，从 [*第
    8 章*](B17505_08_ePub.xhtml#_idTextAnchor135)，*与动画一起工作* 中的 `StateChangeDemo()`：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Have you noticed that I changed one line? The original version uses the `stringResource()`
    composable. However, Android resources are not available on desktop so you must
    replace the invocation with something different. A simple workaround is to hardcode
    the text. Real-world applications may want to choose a mechanism that supports
    multiple languages. Compose for Desktop relies on the Java Virtual Machine, so
    you can use Java's internationalization support.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到我改变了一行？原始版本使用 `stringResource()` 可组合组件。然而，桌面上的 Android 资源不可用，因此您必须用不同的东西替换调用。一个简单的解决方案是将文本硬编码。现实世界的应用程序可能希望选择支持多种语言的机制。Compose
    for Desktop 依赖于 Java 虚拟机，因此您可以使用 Java 的国际化支持。
- en: The app running on macOS is shown in *Figure 11.7*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上运行的应用程序显示在 *图 11.7* 中。
- en: '![Figure 11.7 – A simple Compose for Desktop app'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.7 – 一个简单的桌面 Compose 应用'
- en: '](img/B17505_11_7.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_11_7.jpg)'
- en: Figure 11.7 – A simple Compose for Desktop app
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 一个简单的桌面 Compose 应用
- en: This concludes our brief look at Compose for Desktop and Compose Multiplatform.
    To learn more, please visit the product page at [https://www.jetbrains.com/de-de/lp/compose-mpp/](https://www.jetbrains.com/de-de/lp/compose-mpp/).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Compose for Desktop 和 Compose Multiplatform 的简要探讨。要了解更多信息，请访问产品页面 [https://www.jetbrains.com/de-de/lp/compose-mpp/](https://www.jetbrains.com/de-de/lp/compose-mpp/)。
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we looked at the near future of Jetpack Compose and glimpsed
    neighboring platforms. Jetpack Compose 1.1 will bring bug fixes, performance improvements,
    and new features, for example, `ExposedDropdownMenuBox()` and `NavigationRail()`.
    Two samples (`ExposedDropdownMenuBoxDemo` and `NavigationRailDemo`) show you how
    to use them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们探讨了 Jetpack Compose 的近期未来，并瞥见了邻近的平台。Jetpack Compose 1.1 将带来错误修复、性能改进和新功能，例如，`ExposedDropdownMenuBox()`
    和 `NavigationRail()`。两个示例 (`ExposedDropdownMenuBoxDemo` 和 `NavigationRailDemo`)
    展示了如何使用它们。
- en: The second main section, *Migrating to Material You*, introduced you to Material
    3 for Compose. This package brings *Material You*, the latest iteration of Google's
    beautiful design language, to Jetpack Compose apps. We looked at some differences
    between Material 2 and Material 3, for example, the simplified typography and
    color schemes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要部分，*迁移到 Material You*，向您介绍了 Compose 的 Material 3。这个包将 Google 美丽设计语言的最新迭代
    *Material You* 带到 Jetpack Compose 应用中。我们查看了一些 Material 2 和 Material 3 之间的差异，例如，简化的字体和配色方案。
- en: '*Moving beyond Android* showed you how to use your Jetpack Compose knowledge
    on another platform. I explained how to bring one of my sample composable functions
    to desktop.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*超越Android* 向您展示了如何将您的 Jetpack Compose 知识应用于其他平台。我解释了如何将我的一个示例可组合函数带到桌面。'
- en: I sincerely hope you enjoyed reading this book. You now have a thorough understanding
    of the core principles of Jetpack Compose, as well as the important advantages
    over the traditional Android View system. Using a declarative approach makes writing
    great-looking apps easier than ever. I can't wait to see which beautiful ideas
    you are going to turn into code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望您喜欢阅读这本书。您现在对 Jetpack Compose 的核心原则有了全面的理解，以及相对于传统 Android 视图系统的重大优势。使用声明式方法使得编写外观出色的应用程序比以往任何时候都更容易。我迫不及待地想看看您将哪些美好的想法转化为代码。
