<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Setting the Stage – Camera Effects and Lighting</h1></div></div></div><p>
<em>In the previous chapter, you learned about the basic building blocks of any game: meshes, materials, and animations. We created a Tank Battle game that utilized all of these blocks.</em>
</p><p>
<em>In this chapter, we will expand upon the Tank Battle game. We will start with the addition of a skybox and distance fog. The exploration of camera effects continues with a target indicator overlay that uses a second camera. The creation of a turbo boost effect for the tank will round out our look at camera effects. Continuing with a look at lighting, we will finish off our tank environment with the addition of lightmaps and shadows.</em>
</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Skyboxes</li><li class="listitem" style="list-style-type: disc">Distance fog</li><li class="listitem" style="list-style-type: disc">Using multiple cameras</li><li class="listitem" style="list-style-type: disc">Adjusting the field of view</li><li class="listitem" style="list-style-type: disc">Adding lights</li><li class="listitem" style="list-style-type: disc">Creating lightmaps</li><li class="listitem" style="list-style-type: disc">Adding cookies</li></ul></div><p>We will be directly piggybacking off the project from <a class="link" href="ch03.html" title="Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations">Chapter 3</a>, <em>The Backbone of Any Game – Meshes, Materials, and Animation</em>. So, open it in Unity and we will get started.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec57"/>The camera effects</h1></div></div></div><p>There are many great camera effects that you should add to give your game the last great finishing touch. In this chapter, we will be<a id="id287" class="indexterm"/> covering a few options that are easy to add. These will also give our tank game a great finished look.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Skyboxes and distance fog</h2></div></div></div><p>When a camera renders a frame of a game, it starts by clearing the screen. By default, cameras in Unity do this by coloring everything in solid blue. All of the game's meshes are then drawn on top of this blank<a id="id288" class="indexterm"/> screen. Blue is rather boring for an exciting battle of tanks. So, lucky for us, Unity allows us to change the color. But, pink is not better than<a id="id289" class="indexterm"/> blue, so we have to change the method of clearing the screen. This is where the skybox comes in. A skybox is just a fancy word for the series of images that form the background sky of any game. Distance fog works in conjunction with the skybox by easing the visual transition between models and background.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec58"/>Time for action – adding a skybox and distance fog</h1></div></div></div><p>The very first thing we need is a skybox, obviously. We could create our own; however, Unity provides us with several <a id="id290" class="indexterm"/>excellent ones that will fit our needs just fine.</p><div><ol class="orderedlist arabic"><li class="listitem">At the top of the<a id="id291" class="indexterm"/> Unity Editor, select <strong>Assets</strong> followed by <strong>Import Package</strong>. About half way down this list, select <strong>Skyboxes</strong>.</li><li class="listitem">After a little bit of processing, a new window will pop up. A package in Unity is just a compressed group of assets that have already been set up in Unity. This window displays the contents and allows us to selectively import them. We want them all, so just click on <strong>Import</strong> in the bottom-right corner of this window.</li><li class="listitem">A new folder, <code class="literal">Standard Assets</code>, will be added to the <strong>Project</strong> window. This contains a folder, <code class="literal">Skyboxes</code>, which contains various skybox materials. Select any one of these. You can see in the <strong>Inspector</strong> window that they are normal materials that make use of the Skybox shader. They each have six images, one for each direction.</li><li class="listitem">To add the skybox of your choice to the game, first make sure you have the correct scene loaded. If you do not, simply double-click on it in the <strong>Inspector</strong> window. This is necessary because the settings we are about to change are specific to each scene.</li><li class="listitem">Go to the top of the Unity Editor and select <strong>Edit</strong>, followed by <strong>Render Settings</strong>. The new group of settings will appear in the <strong>Inspector</strong> window.</li><li class="listitem">At the moment we are concerned with the value that is fifth from the bottom, <strong>Skybox Material</strong>. Just drag-and-drop the skybox material into the <strong>Skybox Material</strong> slot and it will be automatically updated. The change can be viewed in the <strong>Game</strong> window.</li><li class="listitem">To add distance fog, <a id="id292" class="indexterm"/>we also adjust it in <strong>Render Settings</strong>. To turn it on, simply click on the <strong>Fog</strong> checkbox.</li><li class="listitem">The next setting, <strong>Fog Color</strong>, allows us to pick a color for the fog. It is good to pick a color that is close to the general color of the skybox.</li><li class="listitem"><strong>Fog Mode</strong> is a drop-down<a id="id293" class="indexterm"/> list of options that dictate the method Unity will use to calculate the distance fog. For nearly all cases, the default of <strong>Exp2</strong> is suitable.</li><li class="listitem">The next three settings, <strong>Fog Density</strong>, <strong>Linear Fog Start</strong>, and <strong>Linear Fog End</strong>, all determine how much fog there is and how close it starts. <strong>Fog Density</strong> is used for the <strong>Exponential</strong> and <strong>Exp2</strong> fog modes while the others are used for the <strong>Linear</strong> fog mode. Settings that put the fog at the edge of sight are generally good.<div><img src="img/2014OT_04_01.jpg" alt="Time for action – adding a skybox and distance fog"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>
<em>What just happened?</em>
</h2></div></div></div><p>We imported several skyboxes<a id="id294" class="indexterm"/> and added them to the scene. The distance fog <a id="id295" class="indexterm"/>settings were also turned on and adjusted. Now, our scene has started to look like a real game.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Target indicator</h2></div></div></div><p>Another camera effect that is <a id="id296" class="indexterm"/>rather interesting is the use of multiple cameras. A second camera could be used for making a 3D GUI, a minimap, or perhaps a security camera pop-up. In this next section, we will be creating a system that will point at targets that are nearby. Using a second camera, we will make it appear above the player's tank.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec59"/>Time for action – creating the pointer</h1></div></div></div><p>We are going to start by creating an <a id="id297" class="indexterm"/>object that will point at targets. We will be making a prefab that can be used repeatedly. However, you will need a model for the player to see. We will use a pie-slice type mesh. The size isn't particularly important; we will be adjusting the scale later. Let's perform the following steps to create the pointer:</p><div><ol class="orderedlist arabic"><li class="listitem">Once you have created and imported your mesh, add it to the scene.</li><li class="listitem">Create an empty <code class="literal">GameObject</code> and rename it to <code class="literal">IndicatorSlice</code>.</li><li class="listitem">Make your mesh a child of <code class="literal">IndicatorSlice</code> and position it so that it points along the GameObject's z axis. <code class="literal">IndicatorSlice</code> will be centered in our indicator. Each slice that is created will have its z axis pointing in the direction of a target.<div><img src="img/2014OT_04_02.jpg" alt="Time for action – creating the pointer"/></div></li><li class="listitem">Now, we need to create a new script that will control our indicator. Create a new script called <strong>TargetIndicator</strong> in the <strong>Project</strong> window.</li><li class="listitem">We start this script off with a pair of variables. The first will hold a reference to the target that this<a id="id298" class="indexterm"/> indicator piece will point at. The indicator is also going to grow and shrink based on how far away the target is. The second variable will control the distance at which the indicator will start to grow.<div><pre class="programlisting">public Transform target;
public float range = 25;</pre></div></li><li class="listitem">The next function will be used to set the <code class="literal">target</code> variable when the indicator piece is created.<div><pre class="programlisting">public void SetTarget(Transform newTarget) {
  target = newTarget;
}</pre></div></li><li class="listitem">The last set of code goes in the <code class="literal">LateUpdate</code> function<a id="id299" class="indexterm"/>. The <code class="literal">LateUpdate</code> function is used so the indicator pieces can point at a target after our tank moves in the <code class="literal">Update</code> function. We start the function with a check to make sure the target variable has a value. If it is null, the indicator slice is destroyed. The <code class="literal">Destroy</code> function can be used to remove any object that exists from the game. The <code class="literal">gameObject</code> variable is automatically provided by the <code class="literal">MonoBehaviour</code> class<a id="id300" class="indexterm"/> and holds a reference to the <code class="literal">GameObject</code> that the script component is attached to. Destroying it will also destroy everything that is a child of (or attached to) it.<div><pre class="programlisting">public void LateUpdate() {
  if(target == null) {
    Destroy(gameObject);
    return;
  }</pre></div></li><li class="listitem">The next bit of code sets the scale of the indicator slice. As you can see in the following code snippet, the first line of code uses <code class="literal">Vector3.Distance</code> to determine how far the two positions are from each other. The next code line determines the vertical scale, y axis, of the slice. It does so by using a bit of carefully applied math and the <code class="literal">Mathf.Clamp01</code> function<a id="id301" class="indexterm"/>. This function limits the supplied value to be between zero and one. The last line of code sets the indicator slice's local scale. By adjusting the local scale, we can easily control how big the whole indicator is by just changing the scale of the parent object.<div><pre class="programlisting">float distance = Vector3.Distance(transform.position, target.position);
float yScale = Mathf.Clamp01((range - distance) / range);
transform.localScale = new Vector3(1, yScale, 1);</pre></div></li><li class="listitem">One last set of code for this script. The <code class="literal">transform.LookAt</code> function<a id="id302" class="indexterm"/> is just a fancy, automatic way of rotating a <code class="literal">GameObject</code> so its z axis points to a specific spot in the world. However, we want all of the indicator slices to lay flat on the ground and not pointing into the air at any targets that might be above us. So, we collect the target's position. By setting the variable's Y value to the position of the slice, we ensure that the slice remains flat. That last line, of course, closes off the <code class="literal">LateUpdate</code> function.<div><pre class="programlisting">Vector3 lookAt = target.position;
lookAt.y = transform.position.y;
transform.LookAt(lookAt);
}</pre></div></li><li class="listitem">That is the last code for this script. Return to Unity and add the <code class="literal">TargetIndicator</code> script to the <code class="literal">IndicatorSlice</code> object in the scene.</li><li class="listitem">To finish off the indicator, create a prefab of it.</li><li class="listitem">Lastly, delete the <code class="literal">IndicatorSlice</code> object from the scene. We will be creating slices dynamically when the game starts. That requires the prefab, but not the one in the scene.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a prefab of the object we will be using to indicate the direction of targets. The script that was created and attached will rotate each instance of the prefab to point at the target. It will also adjust the scale to indicate how far the target is from the player.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec60"/>Time for action – controlling the indicator</h1></div></div></div><p>We now need to create a script <a id="id303" class="indexterm"/>that will control the indicator slices. This will include creating new slices as they are needed. Also, the <code class="literal">GameObject</code> it is attached to will act as a center point for the indicator slices, that we just created, to rotate around.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new script and name it <code class="literal">IndicatorControl</code>.</li><li class="listitem">We start this script off with a pair of variables. The first will hold a reference to the prefab that was just created. This will allow us to spawn instances of it whenever we desire. The second is a static variable, meaning it can be easily accessed without a reference to the component that exists in the scene. It will be filled when the game starts with a reference to the instance of this script that is in the scene.<div><pre class="programlisting">public GameObject indicatorPrefab;
private static IndicatorControl control;</pre></div></li><li class="listitem">This next function will be used by the targets. Soon, we will be updating the target's script to call this function at the beginning of the game. The function is static, just like the variable, and starts by checking to see whether there is a reference to any object in it. If it is empty, equal to null, <code class="literal">Object.FindObjectOfType</code> is used to attempt to fill the variable. By telling it what type of object we want to find, it will search in the game and try to find one. This is relatively a slow process and should not be used often, but we use this process and the variable so that we can always be sure that the system can find the script. The second part of the <code class="literal">CreateSlice</code> function checks to make sure our static variable is not empty. If so, it then tells the instance to create a new indicator slice and passes it to the target.<div><pre class="programlisting">public static void CreateSlice(Transform target) {
  if(control == null) {
    control = Object.FindObjectOfType(typeof(IndicatorControl)) as IndicatorControl;
  }

  if(control != null) {
    control.NewSlice(target);
  }
}</pre></div></li><li class="listitem">One more function for this script. The <code class="literal">NewSlice</code> function<a id="id304" class="indexterm"/> does as its name implies, it creates new indicator slices when called. It does this by first using the <code class="literal">Instantiate</code> function<a id="id305" class="indexterm"/> to create a copy of the <code class="literal">GameObject</code> that is passed to it. The second line of the function makes the new slice a child of the control's transform. The next line <a id="id306" class="indexterm"/>just zeroes out the local position of the new slice. This way it will be centered properly after it is created. The last line uses the slice's <code class="literal">SendMessage</code> function to call the <code class="literal">SetTarget</code> function that we created previously and passes it the desired target object.<div><pre class="programlisting">public void NewSlice(Transform target) {
  GameObject slice = Instantiate(indicatorPrefab) as GameObject;
  slice.transform.parent = transform;
  slice.transform.localPosition = Vector3.zero;
  slice.SendMessage("SetTarget", target);
}</pre></div></li><li class="listitem">Now that the script is created, we need to use it. Create an empty <code class="literal">GameObject</code> and name it <code class="literal">IndicatorControl</code>.</li><li class="listitem">The new <code class="literal">GameObject</code> needs to be made a child of your tank, followed by having its position set to zero on each axis.</li><li class="listitem">Add the script we just created to <code class="literal">IndicatorControl</code>.</li><li class="listitem">Finally, with the <code class="literal">GameObject</code> selected, add the reference to the <code class="literal">IndicatorSlice</code> prefab. Do this by dragging the prefab from the <strong>Project</strong> window to the proper slot in the <strong>Inspector</strong> window.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a script that will control the spawning of our target indicator slices. The <code class="literal">GameObject</code> we created at the end will also allow us to control the size of the whole indicator with ease. We are almost done with the target indicator.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec61"/>Time for action – working with a second camera</h1></div></div></div><p>If you were to play the game now, it would <a id="id307" class="indexterm"/>still look no different. This is because the targets do not yet make the call to create the indicator slices. We will also be adding that second camera in this section as we finish off the target indicator.</p><div><ol class="orderedlist arabic"><li class="listitem">Start by opening the <code class="literal">Target</code> script and adding the following line of code to the end of the <code class="literal">Awake</code> function. This line tells the <code class="literal">IndicatorControl</code> script to create a new indicator slice for this target.<div><pre class="programlisting">IndicatorControl.CreateSlice(transform);</pre></div><div><img src="img/2014OT_04_03.jpg" alt="Time for action – working with a second camera"/></div></li><li class="listitem">On playing the game now, you can see the indicator in action. However, it is probably too large and<a id="id308" class="indexterm"/> certainly appears inside the tank. A bad solution would be to move the <code class="literal">IndicatorControl</code> object until the whole thing appears above the tank. However, when explosions occur and things start flying through the air, they will obscure the target indicator all over again. A better solution is to add a second camera. Do so now by selecting <strong>GameObject</strong> from the top of the Unity Editor, followed by <strong>Create Other</strong>, and finally <strong>Camera</strong>.</li><li class="listitem">Additionally, make the camera a child of <code class="literal">Main Camera</code>. Be sure to set the new camera's position and <a id="id309" class="indexterm"/>rotation values to zero.</li><li class="listitem">By default, every camera in Unity is given a variety of components: <strong>Camera</strong>, <strong>Flare Layer</strong>, <strong>GUI Layer</strong>, and <strong>Audio Listener</strong>. Besides the <strong>Camera</strong> component, the others are generally unimportant to every other camera, and there should only be one <strong>Audio Listener</strong> component in the whole of the scene. Remove the excess components from the camera, leaving just the <strong>Camera</strong> component.</li><li class="listitem">Before we do anything else with the camera, we need to change the layer that the <code class="literal">IndicatorSlice</code> prefab is on. Layers are used to cause selective interaction between objects. They are used primarily for physics and rendering. First select the prefab in the <strong>Project</strong> window.</li><li class="listitem">At the top of the <strong>Inspector</strong> window is the <strong>Layer</strong> label with a drop-down list that reads <strong>Default</strong>. Click on the drop-down list and select <strong>Add Layer...</strong> from the list.</li><li class="listitem">A list of layers will now appear in the <strong>Inspector</strong> window. These are all the layers used in the game. The first few are reserved for use by Unity; hence, they are grayed out. The rest are for our use. Click on the right-hand side of <strong>User Layer 8</strong> and name it <strong>Indicator</strong>.</li><li class="listitem">Select the <code class="literal">IndicatorSlice</code> prefab again. This time select the new <strong>Indicator</strong> layer from the <strong>Layer</strong> drop-down list.</li><li class="listitem">Unity will ask if we want to change the layer of all the child objects as well. We would want the whole object rendered on this layer, so select <strong>Yes, change children</strong> and we will be able to do so.</li><li class="listitem">Now, back to our second camera. Select it and take a look in the <strong>Inspector</strong> window.</li><li class="listitem">The first attribute of the <strong>Camera</strong> component is <strong>Clear Flags</strong>. This list of options dictate what the camera will fill the background with before drawing all of the models in the game. The second camera does not block out everything drawn by the first camera. We select <strong>Depth only</strong> from the <strong>Clear Flags</strong> drop-down list. This means that, instead of putting the skybox in the background, it will leave what was already rendered and just draw new things on top.</li><li class="listitem">The next attribute, <strong>Culling Mask</strong>, controls which layers are rendered by the camera. The first two options, <strong>Nothing</strong> and <strong>Everything</strong>, are for deselection and quick selection of all of the layers. For this camera, deselect all other layers, so that only the <strong>Indicator</strong> layer has a check next to it.</li><li class="listitem">The last thing to do is<a id="id310" class="indexterm"/> to adjust the scale of <code class="literal">IndicatorControl</code> so that the target indicator is not too large or small.<div><img src="img/2014OT_04_04.jpg" alt="Time for action – working with a second camera"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a system to indicate the direction of potential targets. To do this, we used a second camera. By adjusting the layers in the <strong>Culling Mask</strong> attribute, we can make a camera render only a part of a scene.<a id="id311" class="indexterm"/> Also, by changing the <strong>Clear Flags</strong> attribute to <strong>Depth only</strong>, the second camera can draw on top of what was drawn by the first camera.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Have a go hero – adjusting the position</h2></div></div></div><p>It is possible to change where the indicator is drawn by moving the camera. If you were to instead move the <code class="literal">IndicatorControl</code> object, it <a id="id312" class="indexterm"/>will change how the distance from and direction to targets are calculated. Move and angle the second camera so that there is a more pleasing view of the target indicator.</p><p>When you were moving the second camera or when you use the boost from the next section, you probably noticed that the target indicator can still be seen in the tank. Adjust the main camera so that it does not render the target indicator. This is done very similarly to how we made the second camera only render the target indicator.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Turbo boost</h2></div></div></div><p>The last camera effect we will be looking at in this chapter is a turbo boost. It is going to be a button on the screen that will <a id="id313" class="indexterm"/>propel the player forward rapidly for a short amount of time. The camera effect comes in because a simple adjustment to the <strong>Field of View</strong> attribute can make it look as if we are going much faster. A similar method is used by movies to make the car chases look even faster.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec62"/>Time for action – using the boost effect</h1></div></div></div><p>We will only be making a single script<a id="id314" class="indexterm"/> in this section. It will move the tank in a similar manner to the <code class="literal">ChassisControls</code> script we created in the last chapter. The difference is, we won't have to hold down a button for the boost to work. Let's get to it.</p><div><ol class="orderedlist arabic"><li class="listitem">Start by creating a new script and calling it <code class="literal">TurboBoost</code>.</li><li class="listitem">To start the script off, we need four variables. The first is a reference to <code class="literal">CharacterController</code>. We need this for movement. The second is how fast we will be moving while boosting. The third is how long, in seconds, we will be boosting. The last is used internally for whether or not we can boost and when we should stop.<div><pre class="programlisting">public CharacterController controller;
public float boostSpeed = 50;
public float boostLength = 5;
public float startTime = -1;</pre></div></li><li class="listitem">The next bit of code returns to our good friend, the <code class="literal">OnGUI</code> function<a id="id315" class="indexterm"/>. Here we are just drawing a button on the screen, the same as we did several times before. If the button is pressed, it calls the <code class="literal">StartBoost</code> function that we will be writing in a moment.<div><pre class="programlisting">public void OnGUI() {
  Rect turboRect = new Rect(10, Screen.height – 220, 75, 75);
  if(GUI.Button(turboRect, "Turbo"))
    StartBoost();
}</pre></div></li><li class="listitem">The <code class="literal">StartBoost</code> function is pretty<a id="id316" class="indexterm"/> simple. It checks to see if the<a id="id317" class="indexterm"/> <code class="literal">startTime</code> variable is less than zero. If it is, the variable is set to the current time as provided by <code class="literal">Time.time</code>. Being less than zero means that we are not currently boosting.<div><pre class="programlisting">public void StartBoost() {
  if(startTime &lt; 0)
    startTime = Time.time;
}</pre></div></li><li class="listitem">The last function we are going to use is the <code class="literal">Update</code> function<a id="id318" class="indexterm"/>. It begins with a check of <code class="literal">startTime</code> to see if we are currently boosting. If we are not boosting, the function is exited early. The next line of code checks to make sure we have our <code class="literal">CharacterController</code> reference. If the variable is empty, then we can't make the tank move.<div><pre class="programlisting">public void Update() {
  if(startTime &lt; 0) return;
  if(controller == null) return;</pre></div></li><li class="listitem">The next line of code should look familiar. This is the line that makes the tank move.<div><pre class="programlisting">controller.Move(controller.transform.forward * boostSpeed * Time.deltaTime);</pre></div></li><li class="listitem">The following few lines of code actually apply the camera effect. First is a check to see whether we are in the first half-second of the boost. If we are, we transition the camera by adjusting the <code class="literal">fieldOfView</code> value. The <code class="literal">Camera.main</code> value is just a reference provided by Unity to the main camera used in the scene. The<a id="id319" class="indexterm"/> <code class="literal">Mathf.Lerp</code> function takes a starting value and moves it towards a goal value based on a third value between zero and one. Using this, the camera's <code class="literal">fieldOfView</code> is moved towards our goal over the half-second. The second half of this set of code checks for the last half-second of our boost and uses the same method to transition the <code class="literal">fieldOfView</code> value back to the default.<div><pre class="programlisting">if(Time.time – startTime &lt; 0.5f)
  Camera.main.fieldOfView = Mathf.Lerp(Camera.main.fieldOfView, 130, (Time.time - startTime) * 2);
else if(Time.time – startTime &gt; boostLength - 0.5f)
  Camera.main.fieldOfView = Mathf.Lerp(Camera.main.fieldOfView, 60, (Time.time – startTime – boostLength + 0.5f) * 2);</pre></div></li><li class="listitem">The last bit of code checks to see whether we are done boosting. If so, <code class="literal">startTime</code> is set to negative one to indicate that we can start another boost. That last curly brace, of course, closes off the <code class="literal">Update</code> function.<div><pre class="programlisting">if(Time.time &gt; startTime + boostLength)
  startTime = -1;
}</pre></div></li><li class="listitem">We are almost done. <a id="id320" class="indexterm"/>Add the script to your tank and connect the <code class="literal">CharacterController</code> reference.</li><li class="listitem">Try it out.<div><img src="img/2014OT_04_05.jpg" alt="Time for action – using the boost effect"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a turbo boost. The<a id="id321" class="indexterm"/> same method of movement used in the last chapter moves the tank here. By adjusting the <strong>Field of View</strong> attribute of the camera, we make it look like the tank is moving even faster.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Have a go hero – styling and control</h2></div></div></div><p>The easy and obvious challenge here is to style the button. To spice it up, try changing it so there is a label while boosting and a button when not boosting. The label and button could each have their own style.</p><p>Another thing you might notice while playing the game is that you can still turn while boosting. Try adding a check to the <code class="literal">ChassisControls</code> script to lock the controls, if we are boosting. You are going to need to add a reference to the <code class="literal">TurboBoost</code> script.</p><p>For an added, extra challenge try adding a cooldown to the boost. Make it so the player can't constantly use the boost. Also, try canceling the boost if the tank runs into something. This is a big one, so you will start off with a hint: take a look at <code class="literal">OnControllerColliderHit</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec63"/>Lights</h1></div></div></div><p>Unity provides a variety of light types<a id="id322" class="indexterm"/> for brightening the game world. They are <strong>Directional Light</strong>, <strong>Spotlight</strong>, <strong>Point Light</strong>, and <strong>Area Light</strong>. Each of them projects light in a different way and are explained in detail as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Directional Light</strong>: This functions<a id="id323" class="indexterm"/> very much like the sun. It projects all of its light in a single direction. The position of the light does not matter,<a id="id324" class="indexterm"/> only the rotation. Light is projected over the entirety of the scene in one direction. This makes it perfect for initially adding light to a scene.</li><li class="listitem" style="list-style-type: disc"><strong>Spotlight</strong>: This functions just like the ones on a stage. Light is projected in a cone-like shape in a specific direction. <a id="id325" class="indexterm"/>Because of this, it is also the most <a id="id326" class="indexterm"/>complex light type for the system to calculate. Unity has made significant improvements in how it calculates lights, but overuse of these lights should be avoided.</li><li class="listitem" style="list-style-type: disc"><strong>Point Light</strong>: This is the primary<a id="id327" class="indexterm"/> light type that will be used in your games. <a id="id328" class="indexterm"/>It emits light in every direction. This functions just like a light bulb.</li><li class="listitem" style="list-style-type: disc"><strong>Area Light</strong>: This is a special-use light. It emits light in a single direction from a plane. Think of it as the big neon<a id="id329" class="indexterm"/> sign used to advertise a hotel or restaurant. Because of their complexity, these lights can only be used<a id="id330" class="indexterm"/> when baking shadows. There are too many calculations for them to be used when the game is running.</li></ul></div><p>The next obvious question when talking about lights concerns shadows, especially real-time shadows. While real-time shadows add a lot to a scene and are technically possible on any platform, they are very expensive. On top of that, they are a Unity Pro feature. All in all, that makes them a bit too much for your average mobile game.</p><p>On the other hand, there are perfectly viable alternatives that do not cost nearly as much and often look more realistic than real-time shadows. The first is for your environment. In general, the environment in a game never moves and never changes within a specific scene. For this, we have lightmaps. They are extra textures that contain shadow data. Using Unity you can create these textures while making your game. Then, when the game is running, they are automatically applied and your shadows appear. This however does not work for dynamic objects (anything that moves).</p><p>For dynamic objects we have cookies. These are not your grandmother's cookies. In lighting, a cookie is a black and white<a id="id331" class="indexterm"/> image that is projected onto meshes in the game. This is similar to shadow puppets. The shadow puppets use a cutout to block a part of the light, whereas cookies use black and white images to tell the light where it can cast its light.</p><p>Cookies can also be used to create other nice effects, both static and dynamic, such as cloud cover that pans across the scene. Perhaps light projecting out from a cage. Or, you could use them for making the uneven focus point of a flashlight.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec64"/>Time for action – adding more lights</h1></div></div></div><p>Adding additional lights to the<a id="id332" class="indexterm"/> scene is rather simple. Also, as long as one sticks to point lights, the cost to render them stays low.</p><div><ol class="orderedlist arabic"><li class="listitem">At the top of the Unity Editor, select <strong>GameObject</strong>, followed by <strong>Create Other</strong>, and lastly <strong>Point Light</strong>.</li><li class="listitem">With the new light selected, there are a few attributes that we are concerned about in the <strong>Inspector</strong> window.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Range</strong>: This is how <a id="id333" class="indexterm"/>far light will be emitted from the object. The light emitted from this point is brightest at the center and fades to nothing as it reaches the extent of the range. The range is additionally represented as a yellow wire sphere in the <strong>Scene</strong> view.</li><li class="listitem" style="list-style-type: disc"><strong>Color</strong>: This is simply the <a id="id334" class="indexterm"/>color of the light. By default, it is white; however, any color can be used here. This setting is shared between all light types.</li><li class="listitem" style="list-style-type: disc"><strong>Intensity</strong>: This is the brightness<a id="id335" class="indexterm"/> of the light. The greater the intensity of the light, the brighter the light will be at its center. This setting is also shared between all light types.</li></ul></div></li><li class="listitem">Create and position several more lights, arranging them along the streets to add some more interest to the environment.</li><li class="listitem">Using <em>Ctrl</em> + <em>D</em> will duplicate the selected object. This can greatly speed up the creation process.<div><img src="img/2014OT_04_06.jpg" alt="Time for action – adding more lights"/></div></li><li class="listitem">While adding these lights, you probably noticed one of their major drawbacks. There is a limit to how many lights will affect a surface in real time. It is possible to <a id="id336" class="indexterm"/>somewhat get around this by using more complex meshes. The better option is to use lightmaps, which we'll be seeing in the next section.</li><li class="listitem">At the top of the Unity Editor again, select <strong>GameObject</strong>, followed by <strong>Create Other</strong>, and this time select <strong>Spotlight</strong>.</li><li class="listitem">Again, select the new light and take a look at it in the <strong>Inspector</strong> window.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Spot Angle</strong>: This is unique to this type of light. It dictates how wide a cone the light emits. Together with <strong>Range</strong>, it is represented by a<a id="id337" class="indexterm"/> yellow wire cone in the <strong>Scene</strong> view.</li></ul></div></li><li class="listitem">Add a few spotlights around the fountain in the center of our tank battle city.<div><img src="img/2014OT_04_07.jpg" alt="Time for action – adding more lights"/></div></li><li class="listitem">Having so many objects<a id="id338" class="indexterm"/> in a scene starts to clutter the <strong>Hierarchy</strong> window, making it hard to find anything. To organize it, you can use empty <code class="literal">GameObjects</code>. Create one and name it <code class="literal">PointLights</code>.</li><li class="listitem">By making all of your point lights children of this empty <code class="literal">GameObject</code>, the <strong>Hierarchy</strong> window becomes significantly less cluttered.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>
<em>What just happened?</em>
</h2></div></div></div><p>We added several lights to the game.<a id="id339" class="indexterm"/> By changing the lights of the colors, we make the scene much more interesting to look at and play in. However, a drawback of the lighting system is revealed. The city we are using is very simple and there is a limit to the number of lights that can affect a plane at one time. While the look of our scene is still improved, much of the impressiveness is stolen by this drawback.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Lightmaps</h2></div></div></div><p>Lightmaps are great for complex lighting setups that would be too expensive or simply won't work at runtime. They <a id="id340" class="indexterm"/>also allow you to add detailed shadows to your game world without the expense of real-time shadows. However, it will only work for objects that do not move over the course of a game.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec65"/>Time for action – creating a lightmap</h1></div></div></div><p>Lightmaps are a great effect for any game environment, but we need to explicitly tell Unity which objects will not<a id="id341" class="indexterm"/> move and then use lightmaps.</p><div><ol class="orderedlist arabic"><li class="listitem">The first thing to do is make our environment meshes static. To do this start by selecting a piece of your city.</li><li class="listitem">In the top-right corner of the <strong>Inspector</strong> window to the right of the object name field are a checkbox and a <strong>Static</strong> label. Checking this box will make the object static.</li><li class="listitem">Make all of the city's meshes static.<div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>Instead of selecting each checkbox one by one, if you have any sort of grouping (as we just did for the lights), this step can be completed much faster.</p></div></div><div><ol class="orderedlist arabic"><li class="listitem">Select the root object of your city, the one that is the parent to all the pieces of our city, the buildings, and streets.</li><li class="listitem">Now go and select the <strong>Static</strong> checkbox.</li><li class="listitem">On the new pop-up, select <strong>Yes, change children</strong> to cause all of the subobjects to become static as well.</li></ol></div></li><li class="listitem">Any mesh that is either not unwrapped or has UV positions outside the normalized UV space will be skipped when Unity generates a lightmap. In the <strong>Model Import Settings</strong> window, there is an option to have Unity automatically generate lightmap coordinates, <strong>Generate Lightmap</strong>. If you are using <code class="literal">TankBattleCity</code> for your environment, this option should be turned on now.</li><li class="listitem">Go to the top of the Unity Editor and select <strong>Window</strong> followed by <strong>Lightmapping</strong>, near the bottom.</li><li class="listitem">Most of your time will be spent on the <strong>Bake</strong> page looking at this window. Select <strong>Bake</strong> at the top <a id="id342" class="indexterm"/>of the window to switch to it.</li><li class="listitem"><strong>Mode</strong> dictates what types of lightmaps will be rendered by the system. To save on processing speed and file size, select <strong>Single Lightmaps</strong> from the <strong>Mode</strong> drop-down list to the right. This means that only a <strong>Far</strong> set of lightmaps is created rather than both <strong>Near</strong> and <strong>Far</strong>. Using <strong>Dual Lightmaps</strong> also requires special shaders that you won't use most of the time.</li><li class="listitem"><strong>Quality</strong> is a set of presets that dictates how good the lightmaps look. <strong>High</strong> is obviously the best and <strong>Low</strong> is the fastest to process. For our purposes, <strong>Low</strong> will look good enough and should be selected.</li><li class="listitem"><strong>Resolution</strong> is how much space an object will take up on a single lightmap. To the right of the input field, it reads texels per world unit. A texel is just a fancy type of pixel used for lightmaps. It is the number of pixels a single unit of space in the world will take up on the lightmap. A setting of 30 here will maintain the desired level of quality while making the whole thing run faster.</li><li class="listitem">At the bottom of the page is a <strong>Bake Scene</strong> button. Clicking on this button will start the render process. A loading bar will appear in the bottom-right corner of Unity so you can monitor the progress.<div><ol class="orderedlist arabic"><li class="listitem">If you are still adjusting lights and settings and desire to see what a portion of the game will look like, start by selecting the meshes you wish to see.</li><li class="listitem">Next, click on the little arrow to the right of the <strong>Bake Scene</strong> button.</li><li class="listitem">From the new drop-down list, select <strong>Bake Selected</strong>. This will run an identical process to <strong>Bake Scene</strong>, except it will only be for the selected objects rather than the entire scene.<div><div><h3 class="title"><a id="tip23"/>Tip</h3><p>Be warned, this process will likely take a while. Especially as the complexity of the environment and the number of lights increases, this will take longer and longer to run. And, unless you have a superior computer, there isn't much you can do in Unity while it is running.</p></div></div></li></ol></div></li><li class="listitem">If you clicked on the button and realized you made a mistake, don't fret. After <strong>Bake Scene</strong> is selected, the button changes to <strong>Cancel</strong>. At this time it is possible to select it and stop the process from continuing. However, once the textures have been <a id="id343" class="indexterm"/>created and Unity starts to import them, there is no stopping it.</li><li class="listitem">To the left of <strong>Bake Scene</strong> is <strong>Clear</strong>. This button is the quickest and easiest way to delete and remove all of the lightmaps that are currently being used in the scene. This cannot be undone.</li><li class="listitem">In order to add shadows to your buildings, select <strong>Directional Light</strong> in your scene and take a look at the <strong>Inspector</strong> window.</li><li class="listitem">From the <strong>Shadow Type</strong> drop-down list, select <strong>Soft Shadows</strong>. This simply turns shadows on for this light. It also turns on real-time shadows for this light, if you are using Unity Pro. The more lights with shadows turned on, the more expensive they become to render.</li><li class="listitem">When all of your lights and settings match your desires, select <strong>Bake Scene</strong> and gaze in wonder at the now beautiful scene before you.<div><img src="img/2014OT_04_08.jpg" alt="Time for action – creating a lightmap"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>
<em>What just happened?</em>
</h2></div></div></div><p>We added lightmaps to our game world. The length of time it takes to just process this step makes it difficult to<a id="id344" class="indexterm"/> make minor tweaks. However, our lighting has vastly improved with a few clicks. While before the lights were broken by the meshes, we now have smooth patches of color and light.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Have a go hero – reason and speed</h2></div></div></div><p>When playing a game, there is only one light that people will not question the source of: the Sun. Every other light looks weird if a source cannot be seen. Create a mesh and add it to the game to give the lights you are using a reason. This could be something along the lines of torches, or lamp posts, or even glowing alien goo balls. Whatever they end up being, having them adds that touch of completeness that makes the difference between an alright OK-looking game and a great-looking game.</p><p>As a second challenge, take a look at your lightmap's quality. Play with the various quality settings we discussed to see what the differences are. Also, find out how low the resolution can go before you notice any pixelation. Can the settings go even lower when running on the smaller, mobile device screens? Go find out.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Cookies</h2></div></div></div><p>Cookies are a great way to add <a id="id345" class="indexterm"/>interest to the lights in your game. They use a texture to adjust how the light is emitted. This effect can cover a wide range of uses from sparkling crystals to caged industrial lights and, in our case, headlights.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec66"/>Time for action – applying headlights</h1></div></div></div><p>By giving our tank headlights, we give the player the ability to control the light in their world. Using cookies, we can<a id="id346" class="indexterm"/> make them look more interesting than just circles of light.</p><div><ol class="orderedlist arabic"><li class="listitem">Start by creating a <strong>Spotlight</strong>.</li><li class="listitem">Position the light in front of the tank and pointing away.</li><li class="listitem">In the <strong>Inspector</strong> window, increase the value of the <strong>Intensity</strong> attribute to three. This will make our headlights bright like real headlights.</li><li class="listitem">Now we need some cookie textures. At the top of the Unity Editor, select <strong>Assets</strong>, followed by <strong>Import Package</strong>, and lastly <strong>Light Cookies</strong>.</li><li class="listitem">On the new window, select <strong>Import</strong> and wait for the loading bar to finish.</li><li class="listitem">We now have a few options to choose from. Inside the <code class="literal">Standard Assets</code> folder, a new folder was created, <code class="literal">Light Cookies</code> that contains the new textures. Drag <code class="literal">Flashlight</code> from the <strong>Project</strong> window and drop it onto the <strong>Cookie</strong> field on the <strong>Spotlight</strong> in the <strong>Inspector</strong> window. It is as simple as that to add a cookie to a light.</li><li class="listitem">To finish it off, duplicate the light for the second headlight and make them both children of the tank. What good is having headlights if they don't come with us?<div><img src="img/2014OT_04_09.jpg" alt="Time for action – applying headlights"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>
<em>What just happened?</em>
</h2></div></div></div><p>We created a pair of headlights<a id="id347" class="indexterm"/> for our tank using cookies. This is exactly how many other games, especially horror games, create flashlight effects.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Have a go hero – adding a switch</h2></div></div></div><p>Try making a script that will allow the player to turn the headlights on and off. It should be a simple button that toggles the lights. Take a look at the enabled variable that is supplied as part of the light.</p><p>As a simpler challenge, create a lamp that sits on the turret of the tank. Give it a light as well. With this, the player can point a light to where they are shooting and not just in the direction their tank is pointing.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec67"/>Blob shadow</h1></div></div></div><p>Blob shadows are a simpler and cheaper method for adding a shadow to a character. They have been around since the dawn of time. A normal shadow is a solid, dark projection of an object onto another surface. The contours of the shadow exactly match the contours of the object. This becomes expensive to <a id="id348" class="indexterm"/>calculate when characters start to move around randomly.</p><p>A blob shadow is a blot of black texture underneath a character or an object. It usually does not have a clearly definable shape and never matches the contours of the object it is meant to be the shadow of. The blob shadow also, generally, does not change sizes. This makes it significantly easier to calculate, making it the shadow of choice for many generations of video games. That also means it is a better option for our mobile devices where processing speed can quickly become an issue.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec68"/>Time for action – a tank with a shadow</h1></div></div></div><p>We are going to add a blob <a id="id349" class="indexterm"/>shadow to our tank. Unity has already done the bulk of the work for us; we just need to add it to the tank.</p><div><ol class="orderedlist arabic"><li class="listitem">We start this one off by importing Unity's blob shadow. Go to the top of the Unity Editor, select <strong>Assets</strong>, <strong>Import Package</strong>, and finally <strong>Projectors</strong>.</li><li class="listitem">Select <strong>Import</strong> in the new window and take a look in the <strong>Project</strong> window for a new folder called <code class="literal">Projectors</code> created under <code class="literal">Standard Assets</code>.</li><li class="listitem">Drag the <code class="literal">Blob Shadow Projector</code> prefab from the <strong>Project</strong> window to the scene and position it above the tank.<div><img src="img/2014OT_04_10.jpg" alt="Time for action – a tank with a shadow"/></div></li><li class="listitem">Unfortunately, the shadow is appearing on top of our tank. To fix this, we need to again <a id="id350" class="indexterm"/>make use of layers. So, select the tank.</li><li class="listitem">From the <strong>Layer</strong> drop-down list, select <strong>Add Layer...</strong>.</li><li class="listitem">Click on the right-hand side of <strong>User Layer 9</strong> and give it the name <code class="literal">PlayerTank</code>.</li><li class="listitem">Select your tank once more, but select <code class="literal">PlayerTank</code> from the <strong>Layer</strong> drop-down list this time.</li><li class="listitem">When the new window pops up, be sure to select <strong>Yes, change children</strong> to change the layer of the whole tank. If you don't, the blob shadow may appear on some parts of the tank while not on other parts.</li><li class="listitem">Now, select <code class="literal">Blob Shadow Projector</code> from the <strong>Hierarchy</strong> window.<div><div><h3 class="title"><a id="tip24"/>Tip</h3><p>The blob shadow is created by the <strong>Projector</strong> component. This component functions in a similar manner to the <strong>Camera</strong> component. However, it puts an image on the world rather than turning the world into an image and putting it on your screen.</p></div></div></li><li class="listitem">Take a look at the <strong>Inspector</strong> window. The value we are concerned with right now is that of <strong>Ignore Layers</strong>. Right now it is set to <strong>Nothing</strong>.</li><li class="listitem">Click on <strong>Nothing</strong> and select <code class="literal">PlayerTank</code> from the <strong>Layers</strong> drop-down list. This will make the projector ignore the tank and only make the blob shadow appear underneath it.</li><li class="listitem">The next step is to change the size of the shadow to roughly match the size of the tank. Adjust the value of the <a id="id351" class="indexterm"/><strong>Field of View</strong> attribute until the size is about right. A value of about 70 seems to be a good place to start from.<div><img src="img/2014OT_04_11.jpg" alt="Time for action – a tank with a shadow"/></div></li><li class="listitem">The final step is to make <code class="literal">Blob Shadow Projector</code> a child of the tank. We need to be able to bring our shadow with us; we don't want to lose it.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>
<em>What just happened?</em>
</h2></div></div></div><p>We gave our tank a shadow. <a id="id352" class="indexterm"/>Shadows are great for making objects, and especially characters, look like they are actually touching the ground. The blob shadow that we used is better than real-time shadows because it is processed faster.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>Have a go hero – making it square</h2></div></div></div><p>The texture that the blob shadow came with is round but our tank is mostly square. Try creating your own texture for the blob shadow and use that. Some sort of rectangle should work well.</p><p>If you managed to add your own texture to the blob shadow, then how about taking a look at that cannon? The cannon sticks out of our tank and ruins its otherwise square profile. Use a second blob shadow, attached to the turret, to project a shadow for the cannon. The texture for it will also have to be a rectangle-type shape.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec69"/>Summary</h1></div></div></div><p>At this point, you should be well and truly familiar with camera effects and lights.</p><p>In this chapter, we started with a look at using multiple cameras. We then played around with a turbo boost camera effect. The chapter continued with the lighting of our city. The lights improved greatly when we made use of lightmaps. We finished it off with a look at cookies and blob shadows for use with some special lighting effects.</p><p>In the next chapter, will see the creation of enemies for our game. We will use Unity's pathfinding system to make them move around and chase the player. After this, the player is going to need to be much more active if they hope to keep their points.</p></div></body></html>