["```swift\nclass DailyEvent {\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n}\n```", "```swift\nvar event1 = DailyEvent(name: \"have bath\")\nvar event2 = event1\nprint(\"Event 1 - \\(event1.name)\") // have bath\nprint(\"Event 2 - \\(event2.name)\") // have bath\nevent1.name = \"have shower\"\nprint(\"Event 1 - \\(event1.name)\") // have shower\nprint(\"Event 2 - \\(event2.name)\") // have shower\n```", "```swift\nclass ClockTime {\n    var hours: Int\n    var minutes: Int\n\n    init(hours: Int, minutes: Int) {\n        self.hours = hours\n        self.minutes = minutes\n    }\n}\n```", "```swift\nlet defaultEventTime = ClockTime(hours: 6, minutes: 30)\nvar event1Time = defaultEventTime // 6:30\nvar event2Time = defaultEventTime // 6:30\n// Event 2 has been moved to 9:30\nevent2Time.hours = 9\nprint(\"Event 1 - \\(event1Time.hours):\\(event1Time.minutes)\") \n  // Event 1 - 9:30\nprint(\"Event 2 - \\(event2Time.hours):\\(event2Time.minutes)\")\n  // Event 2 - 9:30\n```", "```swift\nstruct ClockTime {\n    var hours: Int\n    var minutes: Int\n}\n```", "```swift\nlet defaultEventTime = ClockTime(hours: 6, minutes: 30)\nvar event1Time = defaultEventTime // 6:30\nvar event2Time = defaultEventTime // 6:30\n// Event 2 has been moved to 9:30\nevent2Time.hours = 9\nprint(\"Event 1 - \\(event1Time.hours):\\(event1Time.minutes)\") // Event 1 - 6:30\nprint(\"Event 2 - \\(event2Time.hours):\\(event2Time.minutes)\") // Event 2 - 9:30\n```", "```swift\nclass DailyEvent {\n    var name: String\n    var time: ClockTime\n\n    init(name: String, time: ClockTime) {\n        self.name = name\n        self.time = time\n    }\n}\n```", "```swift\nvar event1Time = ClockTime(hours: 9, minutes: 0)\n```", "```swift\nvar event2Time = event1Time\n```", "```swift\nevent2Time.minutes = 30\n```", "```swift\ngit clone https://github.com/PacktPublishing/Swift-Cookbook-Second-\nEdition/tree/master/Chapter09/PhotobookCreator_DispatchGroups/ PhotobookCreator.git\n```", "```swift\nfunc generatePhotoBook(with photos: [UIImage]) {\n\n    let resizer = PhotoResizer()\n    let builder = PhotoBookBuilder()\n\n    // Scale down (can take a while)\n    var photosForBook = resizer.scaleToSmallest(of: photos)\n    // Crop (can take a while)\n    photosForBook = resizer.cropToSmallest(of: photosForBook)\n    // Generate PDF (can take a while)\n    let photobookURL = builder.buildPhotobook(with:  \n       photosForBook)\n\n    let previewController = UIDocumentInteractionController(url: \n      photobookURL)\n    previewController.delegate = self\n    previewController.presentPreview(animated: true)\n}\n```", "```swift\nimport Dispatch\n\nclass PhotoCollectionViewController: UIViewController {\n    //...\n    let processingQueue = DispatchQueue(label: \"Photo processing \n      queue\")\n\n    func generatePhotoBook(with photos: [UIImage]) {\n\n        processingQueue.async { [weak self] in\n\n            let resizer = PhotoResizer()\n            let builder = PhotoBookBuilder()            \n\n            // Get smallest common size\n            let size = resizer.smallestCommonSize(for: photos)\n\n            // Scale down (can take a while)\n            var photosForBook = resizer.scaleWithAspectFill(photos, \n              to: size)\n\n            // Crop (can take a while)\n            photosForBook = resizer.centerCrop(photosForBook, to: \n              size)\n            // Generate PDF (can take a while)\n            let pbURL = builder.buildPhotobook(with: photosForBook)\n\n            // Show preview with export options\n            let previewController = \n              UIDocumentInteractionController(url: pbURL)\n\n            previewController.delegate = self\n            previewController.presentPreview(animated: true)\n        }\n    }\n}\n```", "```swift\nfunc generatePhotoBook(with photos: [UIImage], using builder:  \n  PhotoBookBuilder) {\n\n    processingQueue.async { [weak self] in\n\n        let resizer = PhotoResizer()\n        let builder = PhotoBookBuilder()        \n\n        // Get smallest common size\n        let size = resizer.smallestCommonSize(for: photos)\n\n        // Scale down (can take a while)\n        var photosForBook = resizer.scaleWithAspectFill(photos, to: \n          size)\n        // Crop (can take a while)\n        photosForBook = resizer.centerCrop(photosForBook, to: size)\n        // Generate PDF (can take a while)\n        let pbURL = builder.buildPhotobook(with: photosForBook)\n\n        DispatchQueue.main.async {\n          // Show preview with export options\n          let previewController = UIDocumentInteractionController\n            (url: pbURL)\n          previewController.delegate = self\n          previewController.presentPreview(animated: true)\n        }\n    }\n}\n```", "```swift\nfunc generatePhotoBook(with photos: [UIImage], completion: @escaping \n  (URL) -> Void) {\n\n    processingQueue.async {\n\n        let resizer = PhotoResizer()\n        let builder = PhotoBookBuilder()\n\n        // Get smallest common size\n        let size = resizer.smallestCommonSize(for: photos)\n\n        // Scale down (can take a while)\n        var photosForBook = resizer.scaleWithAspectFill(photos, \n          to: size)\n        // Crop (can take a while)\n        photosForBook = resizer.centerCrop(photosForBook, to: size)\n        // Generate PDF (can take a while)\n        let photobookURL = builder.buildPhotobook(with: photosForBook)\n\n        DispatchQueue.main.async {\n            // Fire completion handler which will show the preview UI\n            completion(photobookURL)\n        }\n    }\n}\n```", "```swift\nlet group = DispatchGroup()\n```", "```swift\ngroup.enter()\n```", "```swift\ngroup.leave()\n```", "```swift\ngroup.notify(queue: processingQueue) {\n    //.. generate photo book\n    //.. execute completion handler\n}\n```", "```swift\nlet processingQueue = DispatchQueue(label: \"Photo processing \n  queue\", attributes: .concurrent)\n\nfunc generatePhotoBook(with photos: [UIImage], completion: @escaping \n  (URL) -> Void) {\n\n    let resizer = PhotoResizer()\n    let builder = PhotoBookBuilder()\n\n    // Get smallest common size\n    let size = resizer.smallestCommonSize(for: photos)\n\n    let processedPhotos = NSMutableArray(array: photos)\n\n    let group = DispatchGroup()\n\n    for (index, photo) in photos.enumerated() {\n\n        group.enter()\n\n        processingQueue.async {\n\n            // Scale down (can take a while)\n            var photosForBook = resizer.scaleWithAspectFill(\n              [photo], to: size)\n            // Crop (can take a while)\n            photosForBook = resizer.centerCrop([photo], to: size)\n\n            // Replace original photo with processed photo\n            processedPhotos[index] = photosForBook[0]\n\n            group.leave()\n        }\n    }\n\n    group.notify(queue: processingQueue) {\n\n        guard let photos = processedPhotos as? [UIImage] else { \n          return }\n\n        // Generate PDF (can take a while)\n        let photobookURL = builder.buildPhotobook(with: photos)\n\n        DispatchQueue.main.async {\n            completion(photobookURL)\n        }\n    }\n}\n```", "```swift\nlet processingQueue = DispatchQueue(label: \"Photo processing queue\", \n                                    attributes: .concurrent)\n```", "```swift\nlet resizer = PhotoResizer()\nlet builder = PhotoBookBuilder()\n// Get smallest common size\nlet size = resizer.smallestCommonSize(for: photos)\nlet processedPhotos = NSMutableArray(array: photos)\nlet group = DispatchGroup()\n```", "```swift\nfor (index, photo) in photos.enumerated() {\n\n    group.enter()\n\n    processingQueue.async {\n\n        // Scale down (can take a while)\n        var photosForBook = resizer.scaleWithAspectFill([photo], \n          to: size)\n        // Crop (can take a while)\n        photosForBook = resizer.centerCrop([photo], to: size)\n\n        // Replace original photo with processed photo\n        processedPhotos[index] = photosForBook[0]\n\n        group.leave()\n    }\n}\n```", "```swift\ngroup.notify(queue: processingQueue) {\n\n    guard let photos = processedPhotos as? [UIImage] else { return }\n\n    // Generate PDF (can take a while)\n    let photobookURL = builder.buildPhotobook(with: photos)\n\n    DispatchQueue.main.async {\n        completion(photobookURL)\n    }\n}\n```", "```swift\nimport UIKit\n\nclass PhotoResizeOperation: Operation {\n\n    override func main() {\n\n        // Scale down (can take a while)\n        var photosForBook = resizer.scaleWithAspectFill([photo], \n          to: size)\n        // Crop (can take a while)\n        photosForBook = resizer.centerCrop([photo], to: size)\n\n        // Replace original photo with processed photo\n        processedPhotos[index] = photosForBook[0]\n    }\n}\n```", "```swift\nclass PhotoResizeOperation: Operation {\n\n    let resizer: PhotoResizer\n    let size: CGSize\n    let photos: NSMutableArray\n    let photoIndex: Int\n\n    init(resizer: PhotoResizer, size: CGSize, \n         photos: NSMutableArray, photoIndex: Int) {\n\n        self.resizer = resizer\n        self.size = size\n        self.photos = photos\n        self.photoIndex = photoIndex\n    }\n\n    override func main() {\n\n        // Retrieve the photo to be resized.\n        guard let photo = photos[photoIndex] as? UIImage else { \n          return }\n\n        // Scale down (can take a while)\n        var photosForBook = resizer.scaleWithAspectFill([photo], \n          to: size)\n        // Crop (can take a while)\n        photosForBook = resizer.centerCrop(photosForBook, to: size)\n\n        photos[photoIndex] = photosForBook[0]\n    }\n}\n```", "```swift\nimport UIKit\n\nclass GeneratePhotoBookOperation: Operation {\n\n    let builder: PhotoBookBuilder\n    let photos: NSMutableArray\n    var photobookURL: URL?\n\n    init(builder: PhotoBookBuilder, photos: NSMutableArray) {\n        self.builder = builder\n        self.photos = photos\n    }\n\n    override func main() {\n\n        guard let photos = photos as? [UIImage] else { return }\n\n        // Generate PDF (can take a while)\n        photobookURL = builder.buildPhotobook(with: photos)\n    }\n}\n```", "```swift\nlet processingQueue = OperationQueue()\n\nfunc generatePhotoBook(with photos: [UIImage], completion: @escaping\n  (URL) -> Void) {\n\n    let resizer = PhotoResizer()\n    let builder = PhotoBookBuilder()\n\n    // Get smallest common size\n    let size = resizer.smallestCommonSize(for: photos)\n\n    let processedPhotos = NSMutableArray(array: photos)\n\n    let generateBookOp = GeneratePhotoBookOperation(builder: \n      builder, photos: processedPhotos)\n\n    for index in 0..<processedPhotos.count {\n\n        let resizeOp = PhotoResizeOperation(resizer: resizer,\n                                          size: size,\n                                          photos: processedPhotos,\n                                          photoIndex: index)\n\n        generateBookOp.addDependency(resizeOp)\n        processingQueue.addOperation(resizeOp)\n    }\n\n    generateBookOp.completionBlock = { [weak generateBookOp] in\n\n        guard let pbURL = generateBookOp?.photobookURL else {\n            return\n        }\n\n        OperationQueue.main.addOperation {\n            completion(pbURL)\n        }\n    }\n\n    processingQueue.addOperation(generateBookOp)\n}\n```", "```swift\nlet processingQueue = OperationQueue()\n```", "```swift\nfunc generatePhotoBook(with photos: [UIImage], completion: @escaping (URL) -> Void) {\n\n    let resizer = PhotoResizer()\n    let builder = PhotoBookBuilder()\n\n    // Get smallest common size\n    let size = resizer.smallestCommonSize(for: photos)\n\n    let processedPhotos = NSMutableArray(array: photos)\n```", "```swift\nlet generateBookOp = GeneratePhotoBookOperation(builder: builder, \n   photos: processedPhotos)\n```", "```swift\nfor index in 0..<processedPhotos.count {\n\n    let resizeOp = PhotoResizeOperation(resizer: resizer,\n                                        size: size,\n                                        photos: processedPhotos,\n                                        photoIndex: index)\n\n    generateBookOp.addDependency(resizeOp)\n    processingQueue.addOperation(resizeOp)\n}\n```", "```swift\ngenerateBookOp.completionBlock = { [weak generateBookOp] in\n\n    guard let pbURL = generateBookOp?.photobookURL else {\n        return\n    }\n\n    OperationQueue.main.addOperation {\n        completion(pbURL)\n    }\n}\n```", "```swift\nprocessingQueue.addOperation(generateBookOp)\n```", "```swift\n override func main() {\n\n    // Check if operation has been cancelled\n    guard isCancelled == false else { return }\n\n    guard let photo = photos[photoIndex] as? UIImage else { return }\n    // Scale down (can take a while)\n    var photosForBook = resizer.scaleWithAspectFill(\n      [photo], to: size)\n\n    // Check if operation has been cancelled\n    guard isCancelled == false else { return }\n\n    // Crop (can take a while)\n    photosForBook = resizer.centerCrop(photosForBook, to: size)\n\n    photos[photoIndex] = photosForBook[0]\n}\n```", "```swift\noverride func main() {\n\n    // Check if operation has been cancelled\n    guard isCancelled == false else { return }\n\n    guard let photos = photos as? [UIImage] else { return }\n\n    // Generate PDF (can take a while)\n    photobookURL = builder.buildPhotobook(with: photos)\n}\n```", "```swift\nprocessingQueue.cancelAllOperations()\n```", "```swift\n var isReady: Bool\n```", "```swift\n var isExecuting: Bool\n```", "```swift\n var isFinished: Bool\n```", "```swift\n var isCancelled: Bool\n```"]