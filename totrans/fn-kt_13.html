<html><head></head><body>
        

                            
                    <h1 class="header-title">Arrow Types</h1>
                
            
            
                
<p class="mce-root">Arrow contains many implementations of conventional functional types such as <kbd>Option</kbd>, <kbd>Either</kbd>, and <kbd>Try</kbd>, as well many other types classes, such as functor and monad.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Using <kbd>Option</kbd> to manage null</li>
<li><kbd>Either</kbd> and <kbd>Try</kbd> to manage errors</li>
<li>Combinations and transformers</li>
<li><kbd>State</kbd> to manage application state</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Option</h1>
                
            
            
                
<p>The <kbd>Option&lt;T&gt;</kbd> datatype is the representation of a presence or absence of a value <kbd>T</kbd>. In Arrow, <kbd>Option&lt;T&gt;</kbd> is a sealed class with two sub-types, <kbd>Some&lt;T&gt;</kbd>, a data class that represents the presence of value <kbd>T</kbd> and <kbd>None</kbd>, and an object that represents the absence of value. Defined as a sealed class, <kbd>Option&lt;T&gt;</kbd> can't have any other sub-types; therefore the compiler can check clauses exhaustively, if both cases, <kbd>Some&lt;T&gt;</kbd> and <kbd>None</kbd> are covered.</p>
<p>I know (or I pretend to know) what you're thinking at this very moment—why do I need <kbd>Option&lt;T&gt;</kbd> to represent the presence or absence of <kbd>T</kbd>, if in Kotlin we already have <kbd>T</kbd> for presence and <kbd>T?</kbd> for absence?</p>
<p>And you are right. But <kbd>Option</kbd> provides a lot more value than nullable types, let's jump directly to an example:</p>
<pre>fun divide(num: Int, den: Int): Int? {<br/>    return if (num % den != 0) {<br/>        null<br/>    } else {<br/>        num / den<br/>    }<br/>}<br/><br/>fun division(a: Int, b: Int, den: Int): Pair&lt;Int, Int&gt;? {<br/>    val aDiv = divide(a, den)<br/>    return when (aDiv) {<br/>        is Int -&gt; {<br/>            val bDiv = divide(b, den)<br/>            when (bDiv) {<br/>                is Int -&gt; aDiv to bDiv<br/>                else -&gt; null<br/>            }<br/>        }<br/>        else -&gt; null<br/>    }<br/>}</pre>
<p>The <kbd>division</kbd> function takes three parameters—two integers (<kbd>a</kbd>, <kbd>b</kbd>) and a denominator (<kbd>den</kbd>) and returns a <kbd>Pair&lt;Int, Int&gt;</kbd>, if both numbers are divisible by <kbd>den</kbd> or <kbd>null</kbd> otherwise.</p>
<p>We can express the same algorithm with <kbd>Option</kbd>:</p>
<pre>import arrow.core.*<br/>import arrow.syntax.option.toOption<br/><br/>fun optionDivide(num: Int, den: Int): Option&lt;Int&gt; = divide(num, den).toOption()<br/><br/>fun optionDivision(a: Int, b: Int, den: Int): Option&lt;Pair&lt;Int, Int&gt;&gt; {<br/>   val aDiv = optionDivide(a, den)<br/>   return when (aDiv) {<br/>      is Some -&gt; {<br/>         val bDiv = optionDivide(b, den)<br/>         when (bDiv) {<br/>            is Some -&gt; Some(aDiv.t to bDiv.t)<br/>            else -&gt; None<br/>         }<br/>      }<br/>      else -&gt; None<br/>   }<br/>}</pre>
<p>The function, <kbd>optionDivide</kbd> takes the nullable result from divide and returns it as an <kbd>Option</kbd>, using the <kbd>toOption()</kbd> extension function.</p>
<p>There are no major changes on <kbd>optionDivision</kbd> compared to <kbd>division</kbd>, it is the same algorithm expressed with different types. If we stop here, then <kbd>Option&lt;T&gt;</kbd> doesn't provide extra value on top of nullables. Luckily, that isn't the case; there are more ways to use <kbd>Option</kbd>:</p>
<pre>fun flatMapDivision(a: Int, b: Int, den: Int): Option&lt;Pair&lt;Int, Int&gt;&gt; {<br/>   return optionDivide(a, den).flatMap { aDiv: Int -&gt;<br/>      optionDivide(b, den).flatMap { bDiv: Int -&gt;<br/>         Some(aDiv to bDiv)<br/>      }<br/>   }<br/>}</pre>
<p><kbd>Option</kbd> provides several functions to process its internal value, in this case, <kbd>flatMap</kbd> (as a monad) and now our code looks a lot shorter.</p>
<p>Take a look at the following short list with some of the <kbd>Option&lt;T&gt;</kbd> functions:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Function</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>exists(p :Predicate&lt;T&gt;): Boolean</kbd></p>
</td>
<td>
<p>Returns predicate <kbd>p</kbd> result if value <kbd>T</kbd> exists, otherwise null.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>filter(p: Predicate&lt;T&gt;): Option&lt;T&gt;</kbd></p>
</td>
<td>
<p>Returns <kbd>Some&lt;T&gt;</kbd> if the value <kbd>T</kbd> exists and fulfills the predicate <kbd>p</kbd>, otherwise <kbd>None</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p> <kbd>flatMap(f: (T) -&gt; Option&lt;T&gt;): Option&lt;T&gt;</kbd></p>
</td>
<td>
<p>A <kbd>flatMap</kbd> transform function (like monad).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;R&gt; fold(ifEmpty: () -&gt; R, some: (T) -&gt; R): R&lt;R&gt;</kbd></p>
</td>
<td>
<p>Returns value transformed as <kbd>R</kbd>, invoking <kbd>ifEmpty</kbd> for <kbd>None</kbd> and some for <kbd>Some&lt;T&gt;</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getOrElse(default:() -&gt; T): T</kbd></p>
</td>
<td>
<p>Returns value <kbd>T</kbd> if exists, otherwise returns <kbd>default</kbd> result.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;R&gt; map(f: (T) -&gt; R):Option&lt;T&gt;</kbd></p>
</td>
<td>
<p>A transform function (like <kbd>functor</kbd>).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>orNull(): T?</kbd></p>
</td>
<td>
<p>Returns the value <kbd>T</kbd> as a nullable <kbd>T?</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">The last implementation of division will use comprehensions:</p>
<pre>import arrow.typeclasses.binding<br/><br/>fun comprehensionDivision(a: Int, b: Int, den: Int): Option&lt;Pair&lt;Int, Int&gt;&gt; {<br/>   return Option.monad().binding {<br/>      val aDiv: Int = optionDivide(a, den).bind()<br/>      val bDiv: Int = optionDivide(b, den).bind()<br/>      aDiv to bDiv<br/>   }.ev()<br/>}</pre>
<p>Comprehension is a technique to compute sequentially over any type (such as <kbd>Option</kbd>, <kbd>List</kbd>, and others) that contains a <kbd>flatMap</kbd> function and can provide an instance of monad (more on this later).</p>
<p>In Arrow, comprehensions use coroutines. Yes, coroutines are useful outside the asynchronous execution domain.</p>
<p>If we outline the continuations from our previous example it will look like this (which is a helpful mental model to understand coroutines)</p>
<pre>fun comprehensionDivision(a: Int, b: Int, den: Int): Option&lt;Pair&lt;Int, Int&gt;&gt; {<br/>   return Option.monad().binding {<br/>      val aDiv: Int = optionDivide(a, den).bind()<br/>      <strong>// start continuation 1</strong><br/>         val bDiv: Int = optionDivide(b, den).bind()<br/>          <strong>//start continuation 2</strong><br/>            aDiv to bDiv<br/>         <strong>//end continuation 2</strong><br/><strong>      // end continuation 1</strong><br/>   }.ev()<br/>}</pre>
<p><kbd>Option.monad().binding</kbd> is a coroutine builder and the <kbd>bind()</kbd> function is a suspended function. If you recall correctly from our coroutines chapter, a continuation is a representation of any code after a suspension point (that is, when a suspended function is invoked). In our example, we have two suspension points and two continuations, when we return (in the last block line) we are in the second continuation, and we have access to both values, <kbd>aDiv</kbd> and <kbd>bDiv</kbd>.</p>
<p>Reading this algorithm as continuations is very similar to our <kbd>flatMapDivision</kbd> function. Behind the scenes, <kbd>Option.monad().binding</kbd> uses <kbd>Option.flatMap</kbd> with continuations to create the comprehension; once compiled, both <kbd>comprehensionDivision</kbd> and <kbd>flatMapDivision</kbd> are equivalent, roughly speaking.</p>
<p>The <kbd>ev()</kbd> method will be explained in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Arrow's type hierarchy</h1>
                
            
            
                
<p>There is a limitation in Kotlin's types system—it doesn't support <strong>Higher-Kinded Types</strong> (<strong>HKT</strong>). Without getting too much into type theory, an HKT is a type that declares other generic values as type parameters:</p>
<pre>class MyClass&lt;T&gt;() //Valid Kotlin code<br/><br/>class MyHigherKindedClass&lt;K&lt;T&gt;&gt;() //Not valid kotlin code</pre>
<p>Lacking HKT is not great for Kotlin concerning functional programming, as many advanced functional constructs and patterns use them.</p>
<p>The Arrow team is working on <strong>Kotlin Evolution and Enhancement Process</strong> (<strong>KEEP</strong>)—the community process for adding new language features, called Type Classes as extensions in Kotlin (<a href="https://github.com/Kotlin/KEEP/pull/87">https://github.com/Kotlin/KEEP/pull/87</a>) to support HKT and other features. At this very moment, it isn't clear if this KEEP (coded as <em>KEEP-87</em>) will be included anytime soon in Kotlin, but right now is the most commented proposal and has attracted a lot of attention. Details aren't clear now as it is still a work in progress, but there is a glimpse of hope. </p>
<p>Arrow's solution to this problem is to simulate HKT through a technique called evidence-based HKTs.</p>
<p>Let's have a look at an <kbd>Option&lt;T&gt;</kbd> declaration:</p>
<div><pre style="padding-left: 30px">package arrow.core<br/><br/>import arrow.higherkind<br/>import java.util.*<br/><br/>/**<br/> * Represents optional values. Instances of `Option`<br/> * are either an instance of $some or the object $none.<br/> */<br/>@higherkind<br/>sealed class Option&lt;out A&gt; : OptionKind&lt;A&gt; {<br/>  //more code goes here<br/></pre>
<p><kbd>Option&lt;A&gt;</kbd> is annotated with <kbd>@higherkind</kbd> which is similar to <kbd>@lenses</kbd> from our previous chapter; this annotation is used to generate code to support evidence-based HKTs. <kbd>Option&lt;A&gt;</kbd> extends from <kbd>OptionKind&lt;A&gt;</kbd>:<br/></p>
</div>
<pre style="padding-left: 30px">package arrow.core<br/><br/>class OptionHK private constructor()<br/>typealias OptionKind&lt;A&gt; = arrow.HK&lt;OptionHK, A&gt;<br/><br/>@Suppress("UNCHECKED_CAST", "NOTHING_TO_INLINE")<br/>inline fun &lt;A&gt; OptionKind&lt;A&gt;.ev(): Option&lt;A&gt; =<br/>  this as Option&lt;A&gt;</pre>
<p><kbd>OptionKind&lt;A&gt;</kbd> is a type alias for <kbd>HK&lt;OptionHK, A&gt;</kbd>, all this code is generated using the <kbd>@higherkind</kbd> annotation processor. <kbd>OptionHK</kbd> is an uninstanciable class that is used as a unique tag name for <kbd>HK</kbd> and <kbd>OptionKind</kbd> is a kind of intermediate representation of HKT. <kbd>Option.monad().binding</kbd> returns <kbd>OptionKind&lt;T&gt;</kbd>, that is why we need to call <kbd>ev()</kbd> at the end to return a proper <kbd>Option&lt;T&gt;</kbd>:</p>
<pre>package arrow<br/><br/>interface HK&lt;out F, out A&gt;<br/><br/>typealias HK2&lt;F, A, B&gt; = HK&lt;HK&lt;F, A&gt;, B&gt;<br/><br/>typealias HK3&lt;F, A, B, C&gt; = HK&lt;HK2&lt;F, A, B&gt;, C&gt;<br/><br/>typealias HK4&lt;F, A, B, C, D&gt; = HK&lt;HK3&lt;F, A, B, C&gt;, D&gt;<br/><br/>typealias HK5&lt;F, A, B, C, D, E&gt; = HK&lt;HK4&lt;F, A, B, C, D&gt;, E&gt;<br/></pre>
<p><kbd>HK</kbd> interface (short-hand for <strong>higher-kinded</strong>) is used to represent an HKT of arity one up to <kbd>HK5</kbd> for arity 5. On <kbd>HK&lt;F, A&gt;</kbd>, <kbd>F</kbd> represents the type and <kbd>A</kbd> the generic parameter, so <kbd>Option&lt;Int&gt;</kbd> is <kbd>OptionKind&lt;Int&gt;</kbd> value which is <kbd>HK&lt;OptionHK, Int&gt;</kbd>.</p>
<p>Let's have a look now at <kbd>Functor&lt;F&gt;</kbd>:</p>
<pre>package arrow.typeclasses<br/><br/>import arrow.*<br/><br/>@typeclass<br/>interface Functor&lt;F&gt; : TC {<br/><br/>    fun &lt;A, B&gt; map(fa: HK&lt;F, A&gt;, f: (A) -&gt; B): HK&lt;F, B&gt;<br/><br/>}<br/></pre>
<p><kbd>Functor&lt;F&gt;</kbd> extends <kbd>TC</kbd>, a marker interface and, as you can guess, it has a <kbd>map</kbd> function. The <kbd>map</kbd> function receives <kbd>HK&lt;F, A&gt;</kbd> as the first parameter and a lambda <kbd>(A) -&gt; B</kbd> to transform the value of <kbd>A</kbd> into <kbd>B</kbd> and transform it into <kbd>HK&lt;F, B&gt;.</kbd></p>
<p>Let's create our basic datatype <kbd>Mappable</kbd> that can provide instances for the <kbd>Functor</kbd> type class:</p>
<pre>import arrow.higherkind<br/><br/>@higherkind<br/>class Mappable&lt;T&gt;(val t: T) : MappableKind&lt;T&gt; {<br/>   fun &lt;R&gt; map(f: (T) -&gt; R): Mappable&lt;R&gt; = Mappable(f(t))<br/><br/>   override fun toString(): String = "Mappable(t=$t)"<br/><br/>   companion object<br/>}</pre>
<p>Our class, <kbd>Mappable&lt;T&gt;</kbd> is annotated with <kbd>@higherkind</kbd> and extends <kbd>MappableKind&lt;T&gt;</kbd> and must have a companion object, it doesn't matter if is empty or not.</p>
<p>Now, we need to create our implementation of <kbd>Functor&lt;F&gt;</kbd>:</p>
<pre>import arrow.instance<br/>import arrow.typeclasses.Functor<br/><br/>@instance(Mappable::class)<br/>interface MappableFunctorInstance : Functor&lt;MappableHK&gt; {<br/>   override fun &lt;A, B&gt; map(fa: MappableKind&lt;A&gt;, f: (A) -&gt; B): Mappable&lt;B&gt; {<br/>      return fa.ev().map(f)<br/>   }<br/>}</pre>
<p>Our <kbd>MappableFunctorInstance</kbd> interface extends <kbd>Functor&lt;MappableHK&gt;</kbd> and is annotated with <kbd>@instance(Mappable::class)</kbd>. Inside the <kbd>map</kbd> function, we use the first parameter, <kbd>MappableKind&lt;A&gt;</kbd> and use its <kbd>map</kbd> function.</p>
<p>The <kbd>@instance</kbd> annotation will generate an object extending the interface, <kbd>MappableFunctorInstance</kbd>. It will create an <kbd>Mappable.Companion.functor()</kbd> extension function to get the object implementing <kbd>MappableFunctorInstance</kbd> using <kbd>Mappable.functor()</kbd> (which is how we can use <kbd>Option.monad()</kbd>).</p>
<p>Another alternative is to let Arrow-derived instances automatically provided that your datatypes have the right functions:</p>
<pre>import arrow.deriving <br/><br/>@higherkind<br/>@deriving(Functor::class)<br/>class DerivedMappable&lt;T&gt;(val t: T) : DerivedMappableKind&lt;T&gt; {<br/>   fun &lt;R&gt; map(f: (T) -&gt; R): DerivedMappable&lt;R&gt; = DerivedMappable(f(t))<br/><br/>   override fun toString(): String = "DerivedMappable(t=$t)"<br/><br/>   companion object<br/>}</pre>
<p>The <kbd>@deriving</kbd> annotation will generate <kbd>DerivedMappableFunctorInstance</kbd> that normally you will write manually.</p>
<p>Now, we can create a generic function to use our <kbd>Mappable</kbd> functor:</p>
<pre>import arrow.typeclasses.functor<br/><br/>inline fun &lt;reified F&gt; buildBicycle(mapper: HK&lt;F, Int&gt;,<br/>                           noinline f: (Int) -&gt; Bicycle,<br/>                           FR: Functor&lt;F&gt; = functor()): HK&lt;F, Bicycle&gt; = FR.map(mapper, f)</pre>
<p>The <kbd>buildBicycle</kbd> function will take as parameter any <kbd>HK&lt;F, Int&gt;</kbd> and apply the function <kbd>f</kbd> using its <kbd>Functor</kbd> implementation, returned by the function <kbd>arrow.typeclasses.functor</kbd> and returns <kbd>HK&lt;F, Bicycle&gt;</kbd>.</p>
<p>The function <kbd>arrow.typeclass.functor</kbd> resolves at runtime, instances that adhere to the <kbd>Functor&lt;MappableHK&gt;</kbd> requirement:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/><br/>   val mappable: Mappable&lt;Bicycle&gt; = buildBicycle(Mappable(3), ::Bicycle).ev()<br/>   println("mappable = $mappable") //Mappable(t=Bicycle(gears=3))<br/><br/>   val option: Option&lt;Bicycle&gt; = buildBicycle(Some(2), ::Bicycle).ev()<br/>   println("option = $option") //Some(Bicycle(gears=2))<br/><br/>   val none: Option&lt;Bicycle&gt; = buildBicycle(None, ::Bicycle).ev()<br/>   println("none = $none") //None<br/><br/>}</pre>
<p>We can use <kbd>buildBicycle</kbd> with <kbd>Mappeable&lt;Int&gt;</kbd>, or any other HKT class such as <kbd>Option&lt;T&gt;</kbd>.</p>
<p>One problem with the Arrows approach to HKTs is that it must resolve its instances at runtime. This is because Kotlin does not have support for implicits or can solve type class instances at compile time, leaving Arrow with this only alternative until <em>KEEP-87</em> is approved and included in the language:</p>
<pre>@higherkind<br/>class NotAFunctor&lt;T&gt;(val t: T) : NotAFunctorKind&lt;T&gt; {<br/>   fun &lt;R&gt; map(f: (T) -&gt; R): NotAFunctor&lt;R&gt; = NotAFunctor(f(t))<br/><br/>   override fun toString(): String = "NotAFunctor(t=$t)"<br/>}</pre>
<p>So, you can have an HKT that has a <kbd>map</kbd> function but without an instance of <kbd>Functor</kbd> can't be used, yet isn't a compilation error:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/><br/>   val not: NotAFunctor&lt;Bicycle&gt; = buildBicycle(NotAFunctor(4), ::Bicycle).ev()<br/>   println("not = $not")<br/><br/>}</pre>
<p>Calling <kbd>buildBicycle</kbd> with a <kbd>NotAFunctor&lt;T&gt;</kbd> function compiles, but it will throw a <kbd>ClassNotFoundException</kbd> exception at runtime.</p>
<p>Now that we understand how Arrow's hierarchy works, we can cover other classes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Either</h1>
                
            
            
                
<p><kbd>Either&lt;L, R&gt;</kbd> is a representation of one of two possible values <kbd>L</kbd> or <kbd>R</kbd>, but not both at the same time. <kbd>Either</kbd> is a sealed class (similar to <kbd>Option</kbd>) with two subtypes <kbd>Left&lt;L&gt;</kbd> and <kbd>Right&lt;R&gt;</kbd>. Usually <kbd>Either</kbd> is used to represent results that can fail, using the left side to represent the error and the right side to represent a successful result. Because representing operations that can fail is a common scenario, Arrow's <kbd>Either</kbd> is right biased, in other words, unless it is documented otherwise all operations run on the right side.</p>
<p>Let's translate our division example from <kbd>Option</kbd> to <kbd>Either</kbd>:</p>
<pre>import arrow.core.Either<br/>import arrow.core.Either.Right<br/>import arrow.core.Either.Left<br/><br/>fun eitherDivide(num: Int, den: Int): Either&lt;String, Int&gt; {<br/>   val option = optionDivide(num, den)<br/>   return when (option) {<br/>      is Some -&gt; Right(option.t)<br/>      None -&gt; Left("$num isn't divisible by $den")<br/>   }<br/>}</pre>
<p>Now instead of returning a <kbd>None</kbd> value, we're returning valuable information to our user:</p>
<pre>import arrow.core.Tuple2<br/><br/>fun eitherDivision(a: Int, b: Int, den: Int): Either&lt;String, Tuple2&lt;Int, Int&gt;&gt; {<br/>   val aDiv = eitherDivide(a, den)<br/>   return when (aDiv) {<br/>      is Right -&gt; {<br/>         val bDiv = eitherDivide(b, den)<br/>         when (bDiv) {<br/>            is Right -&gt; Right(aDiv.getOrElse { 0 } toT bDiv.getOrElse { 0 })<br/>            is Left -&gt; bDiv as Either&lt;String, Nothing&gt;<br/>         }<br/>      }<br/>      is Left -&gt; aDiv as Either&lt;String, Nothing&gt;<br/>   }<br/>}</pre>
<p>In <kbd>eitherDivision</kbd>, we're using Arrow's <kbd>Tuple&lt;A, B&gt;</kbd> instead of Kotlin's <kbd>Pair&lt;A, B&gt;</kbd>. Tuples provide more features than Pair/Triple, and from now on we'll use it. To create a <kbd>Tuple2</kbd>, you can use the extension <kbd>infix</kbd> function, <kbd>toT</kbd>.</p>
<p>Next, a short list of the <kbd>Either&lt;L, R&gt;</kbd> functions:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Function</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>bimap(fa:(L) -&gt; T, fb:(R) -&gt; X): Either&lt;T, X&gt;</kbd></p>
</td>
<td>
<p>Transform using <kbd>fa</kbd> on <kbd>Left</kbd> and <kbd>fb</kbd> on <kbd>Right</kbd> to return <kbd>Either&lt;T, X&gt;</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>contains(elem:R): Boolean</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if the <kbd>Right</kbd> value is the same as <kbd>elem</kbd> parameter, <kbd>false</kbd> for <kbd>Left</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>exists(p:Predicate&lt;R&gt;):Boolean</kbd></p>
</td>
<td>
<p>If <kbd>Right</kbd>, returns Predicate <kbd>p</kbd> result, always <kbd>false</kbd> for <kbd>Left</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>flatMap(f: (R) -&gt; Either&lt;L, T&gt;): Either&lt;L, T&gt;</kbd></p>
</td>
<td>
<p>A <kbd>flatMap</kbd> function as in <kbd>Monad</kbd>, using the value of  <kbd>Right</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>fold(fa: (L) -&gt; T, fb: (R) -&gt; T): T</kbd></p>
</td>
<td>
<p>Returns a <kbd>T</kbd> value executing <kbd>fa</kbd> for <kbd>Left</kbd> and <kbd>fb</kbd> for <kbd>Right</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getOrElse(default:(L) -&gt; R): R</kbd></p>
</td>
<td>
<p>Returns <kbd>Right</kbd> value, or results from the <kbd>default</kbd> function.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>isLeft(): Boolean</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if is an instance of <kbd>Left</kbd> and <kbd>false</kbd> for <kbd>Right</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>isRight(): Boolean</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if is an instance of <kbd>Right</kbd> and <kbd>false</kbd> for <kbd>Left</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>map(f: (R) -&gt; T): Either&lt;L, T&gt;</kbd></p>
</td>
<td>
<p>A <kbd>map</kbd> function as in <kbd>Functor</kbd>, if <kbd>Right</kbd>, uses function <kbd>f</kbd> to transform it to <kbd>Right&lt;T&gt;</kbd>, if <kbd>Left</kbd>, returns same value without transformation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>mapLeft(f: (L) -&gt; T): Either&lt;T, R&gt;</kbd></p>
</td>
<td>
<p>A <kbd>map</kbd> function as in <kbd>Functor</kbd>, if <kbd>Left</kbd>, uses function <kbd>f</kbd> to transform it to <kbd>Left&lt;T&gt;</kbd>, if <kbd>Right</kbd>, returns same value without transformation.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>swap(): Either&lt;R, L&gt;</kbd></p>
</td>
<td>
<p>Returns <kbd>Either</kbd> with its types and value swapped.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>toOption(): Option&lt;R&gt;</kbd></p>
</td>
<td>
<p><kbd>Some&lt;T&gt;</kbd> for <kbd>Right</kbd> and <kbd>None</kbd> for <kbd>Left</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p class="mce-root">The <kbd>flatMap</kbd> version looks as expected:</p>
<pre>fun flatMapEitherDivision(a: Int, b: Int, den: Int): Either&lt;String, Tuple2&lt;Int, Int&gt;&gt; {<br/>   return eitherDivide(a, den).flatMap { aDiv -&gt;<br/>      eitherDivide(b, den).flatMap { bDiv -&gt;<br/>         Right(aDiv toT bDiv)<br/>      }<br/>   }<br/>}</pre>
<p><kbd>Either</kbd> has a monad implementation, so we can invoke the binding function:</p>
<pre>fun comprehensionEitherDivision(a: Int, b: Int, den: Int): Either&lt;String, Tuple2&lt;Int, Int&gt;&gt; {<br/>   return Either.monad&lt;String&gt;().binding {<br/>      val aDiv = eitherDivide(a, den).bind()<br/>      val bDiv = eitherDivide(b, den).bind()<br/><br/>      aDiv toT bDiv<br/>   }.ev()</pre>
<p>Pay attention to <kbd>Either.monad&lt;L&gt;()</kbd>; for <kbd>Either&lt;L, R&gt;</kbd> it must define the <kbd>L</kbd> type:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   eitherDivision(3, 2, 4).fold(::println, ::println) //3 isn't divisible by 4<br/>}<br/></pre>
<p>In our next section, we'll learn about monad transformers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Monad transformers</h1>
                
            
            
                
<p><kbd>Either</kbd> and <kbd>Option</kbd> are simple to use, but what happens if we combine both?</p>
<pre>object UserService {<br/>  <br/>   fun findAge(user: String): Either&lt;String, Option&lt;Int&gt;&gt; {<br/>       //Magic  <br/>   }<br/>}</pre>
<p><kbd>UserService.findAge</kbd> returns <kbd>Either&lt;String, Option&lt;Int&gt;&gt;</kbd>; <kbd>Left&lt;String&gt;</kbd> for errors accessing the database or any other infrastructure, <kbd>Right&lt;None&gt;</kbd> for no value found on the database, and <kbd>Right&lt;Some&lt;Int&gt;&gt;</kbd> for a value found:</p>
<pre>import arrow.core.*<br/>import arrow.syntax.function.pipe<br/><br/>fun main(args: Array&lt;String&gt;) {<br/> val anakinAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Anakin")<br/><br/> anakinAge.fold(::identity, { op -&gt;<br/>         op.fold({ "Not found" }, Int::toString)<br/>     }) pipe ::println <br/>}</pre>
<p>To print an age, we need two nested folds, nothing too complicated. Problems arrive when we need to do operations accessing multiple values:</p>
<pre>import arrow.core.*<br/>import arrow.syntax.function.pipe<br/>import kotlin.math.absoluteValue<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val anakinAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Anakin")<br/>   val padmeAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Padme")<br/><br/>   val difference: Either&lt;String, Option&lt;Either&lt;String, Option&lt;Int&gt;&gt;&gt;&gt; = anakinAge.map { aOp -&gt;<br/>      aOp.map { a -&gt;<br/>         padmeAge.map { pOp -&gt;<br/>            pOp.map { p -&gt;<br/>               (a - p).absoluteValue<br/>            }<br/>         }<br/>      }<br/>   }<br/><br/>   difference.fold(::identity, { op1 -&gt;<br/>      op1.fold({ "Not Found" }, { either -&gt;<br/>         either.fold(::identity, { op2 -&gt; <br/>            op2.fold({ "Not Found" }, Int::toString) })<br/>      })<br/>   }) pipe ::println<br/>}</pre>
<p>Monads don't compose, making these operations grow in complexity, very quickly. But, we can always count on comprehensions, can't we? Now, let's look at the following codes:</p>
<pre>import arrow.core.*<br/>import arrow.syntax.function.pipe<br/>import arrow.typeclasses.binding<br/>import kotlin.math.absoluteValue<br/><br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val anakinAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Anakin")<br/>   val padmeAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Padme")<br/><br/>   val difference: Either&lt;String, Option&lt;Option&lt;Int&gt;&gt;&gt; = Either.monad&lt;String&gt;().binding {<br/>      val aOp: Option&lt;Int&gt; = anakinAge.bind()<br/>      val pOp: Option&lt;Int&gt; = padmeAge.bind()<br/>      aOp.map { a -&gt;<br/>         pOp.map { p -&gt;<br/>            (a - p).absoluteValue<br/>         }<br/>      }<br/>   }.ev()<br/><br/>   difference.fold(::identity, { op1 -&gt;<br/>      op1.fold({ "Not found" }, { op2 -&gt;<br/>         op2.fold({ "Not found" }, Int::toString) }) }) pipe ::println<br/>}</pre>
<p> This is better, the returning type is not that long, and <kbd>fold</kbd> is more manageable. Let's take a look at the nested comprehensions in the following code snippet:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>   val anakinAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Anakin")<br/>   val padmeAge:  Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Padme")<br/><br/>   val difference: Either&lt;String, Option&lt;Int&gt;&gt; = Either.monad&lt;String&gt;().binding {<br/>      val aOp: Option&lt;Int&gt; = anakinAge.bind()<br/>      val pOp: Option&lt;Int&gt; = padmeAge.bind()<br/>      Option.monad().binding {<br/>         val a: Int = aOp.bind()<br/>         val p: Int = pOp.bind()<br/>         (a - p).absoluteValue<br/>      }.ev()<br/>   }.ev()<br/><br/>   difference.fold(::identity, { op -&gt;<br/>      op.fold({ "Not found" }, Int::toString)<br/>   }) pipe ::println<br/>}</pre>
<p>Now, we have the same type of both values and result. But we still have another option, monad transformers.</p>
<p>A <strong>monad transformer</strong> is a combination of two monads that can be executed as one. For our example, we will use <kbd>OptionT</kbd>, (shorthand for <strong>Option Transformer</strong>) as <kbd>Option</kbd> is the monad type that is nested inside <kbd>Either</kbd>:</p>
<pre>import arrow.core.*<br/>import arrow.data.OptionT<br/>import arrow.data.monad<br/>import arrow.data.value<br/>import arrow.syntax.function.pipe<br/>import arrow.typeclasses.binding<br/>import kotlin.math.absoluteValue<br/><br/><br/>fun main(args: Array&lt;String&gt;) {<br/>   val anakinAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Anakin")<br/>   val padmeAge: Either&lt;String, Option&lt;Int&gt;&gt; = UserService.findAge("Padme")<br/><br/>   val difference: Either&lt;String, Option&lt;Int&gt;&gt; = OptionT.monad&lt;EitherKindPartial&lt;String&gt;&gt;().binding {<br/>      val a: Int = OptionT(anakinAge).bind()<br/>      val p: Int = OptionT(padmeAge).bind()<br/>      (a - p).absoluteValue<br/>   }.value().ev()<br/><br/>   difference.fold(::identity, { op -&gt;<br/>      op.fold({ "Not found" }, Int::toString)<br/>   }) pipe ::println<br/>}</pre>
<p>We use <kbd>OptionT.monad&lt;EitherKindPartial&lt;String&gt;&gt;().binding</kbd>. The <kbd>EitherKindPartial&lt;String&gt;</kbd> monad means that the wrapper type is an <kbd>Either&lt;String, Option&lt;T&gt;&gt;</kbd>.</p>
<p>Inside the <kbd>binding</kbd> block, we use <kbd>OptionT</kbd> on values of type <kbd>Either&lt;String, Option&lt;T&gt;&gt;</kbd> (technically on values of type <kbd>HK&lt;HK&lt;EitherHK, String&gt;, Option&lt;T&gt;&gt;</kbd>) to call <kbd>bind(): T</kbd>, in our case <kbd>T</kbd>, is <kbd>Int</kbd>.</p>
<p>Previously we used just the <kbd>ev()</kbd> method, but now we need to use the <kbd>value()</kbd> method to extract the <kbd>OptionT</kbd> internal value.</p>
<p>In our next section, we'll learn about the <kbd>Try</kbd> type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Try</h1>
                
            
            
                
<p><strong>Try</strong> is a representation of a computation that may or may not fail. <kbd>Try&lt;A&gt;</kbd> is a sealed class with two possibles sub-classes—<kbd>Failure&lt;A&gt;</kbd>, representing a fail and <kbd>Success&lt;T&gt;</kbd> representing a successful operation.</p>
<p>Let's write our division example with <kbd>Try</kbd>:</p>
<pre>import arrow.data.Try<br/><br/>fun tryDivide(num: Int, den: Int): Try&lt;Int&gt; = Try { divide(num, den)!! }</pre>
<p> The easiest way to create a <kbd>Try</kbd> instance is to use the <kbd>Try.invoke</kbd> operator. If the block inside throws an exception, it will return <kbd>Failure</kbd>; if everything goes well, <kbd>Success&lt;Int&gt;</kbd>, for example, the <kbd>!!</kbd> operator will throw <kbd>NPE</kbd> if divide returns a null:</p>
<pre>fun tryDivision(a: Int, b: Int, den: Int): Try&lt;Tuple2&lt;Int, Int&gt;&gt; {<br/>   val aDiv = tryDivide(a, den)<br/>   return when (aDiv) {<br/>      is Success -&gt; {<br/>         val bDiv = tryDivide(b, den)<br/>         when (bDiv) {<br/>            is Success -&gt; {<br/>               Try { aDiv.value toT bDiv.value }<br/>            }<br/>            is Failure -&gt; Failure(bDiv.exception)<br/>         }<br/>      }<br/>      is Failure -&gt; Failure(aDiv.exception)<br/>   }<br/>}</pre>
<p>Let's take a look at a short list of the <kbd>Try&lt;T&gt;</kbd> functions:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Function</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>exists(p: Predicate&lt;T&gt;): Boolean</kbd></p>
</td>
<td>
<p>If <kbd>Success&lt;T&gt;</kbd> returns <kbd>p</kbd> result, on <kbd>Failure</kbd> always return <kbd>false</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>filter(p:  Predicate&lt;T&gt;): Try&lt;T&gt;</kbd></p>
</td>
<td>
<p>Returns <kbd>Success&lt;T&gt;</kbd> if operation is successful and pass predicate <kbd>p</kbd>, otherwise <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;R&gt; flatMap(f: (T) -&gt; Try&lt;R&gt;): Try&lt;R&gt;</kbd></p>
</td>
<td>
<p><kbd>flatMap</kbd> function as in monad.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;R&gt; fold(fa: (Throwable) -&gt; R, fb:(T) -&gt; R): R</kbd></p>
</td>
<td>
<p>Returns value transformed as <kbd>R</kbd>, invoking <kbd>fa</kbd> if <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getOrDefault(default: () -&gt; T): T</kbd></p>
</td>
<td>
<p>Returns value <kbd>T</kbd>, invoking default if <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getOrElse(default: (Throwable) -&gt; T): T</kbd></p>
</td>
<td>
<p>Returns value <kbd>T</kbd>, invoking default if <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>isFailure(): Boolean</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if <kbd>Failure</kbd>, otherwise <kbd>false</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>isSuccess(): Boolean</kbd></p>
</td>
<td>
<p>Returns <kbd>true</kbd> if <kbd>Success</kbd>, otherwise <kbd>false</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>&lt;R&gt; map(f: (T) -&gt; R): Try&lt;R&gt;</kbd></p>
</td>
<td>
<p>Transforming function as in functor.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>onFailure(f: (Throwable) -&gt; Unit): Try&lt;T&gt;</kbd></p>
</td>
<td>
<p>Act on <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>onSuccess(f: (T) -&gt; Unit): Try&lt;T&gt;</kbd></p>
</td>
<td>
<p>Act on <kbd>Success</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>orElse(f: () -&gt; Try&lt;T&gt;): Try&lt;T&gt;</kbd></p>
</td>
<td>
<p>Returns itself on <kbd>Success</kbd> or <kbd>f</kbd> result on <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>recover(f: (Throwable) -&gt; T): Try&lt;T&gt;</kbd></p>
</td>
<td>
<p>Transform <kbd>map</kbd> function for <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>recoverWith(f: (Throwable) -&gt; Try&lt;T&gt;): Try&lt;T&gt;</kbd></p>
</td>
<td>
<p>Transform <kbd>flatMap</kbd> function for <kbd>Failure</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>toEither() : Either&lt;Throwable, T&gt;</kbd></p>
</td>
<td>
<p>Transform into <kbd>Either</kbd>—<kbd>Failure</kbd> to <kbd>Left&lt;Throwable&gt;</kbd> and <kbd>Success&lt;T&gt;</kbd> to <kbd>Right&lt;T&gt;</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>toOption(): Option&lt;T&gt;</kbd></p>
</td>
<td>
<p>Transform into <kbd>Option</kbd>—<kbd>Failure</kbd> to <kbd>None</kbd> and <kbd>Success&lt;T&gt;</kbd> to <kbd>Some&lt;T&gt;</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p class="mce-root">The <kbd>flatMap</kbd> implementation is very similar to <kbd>Either</kbd> and <kbd>Option</kbd> and shows the value of having a common set of name and behavior conventions:</p>
<pre>fun flatMapTryDivision(a: Int, b: Int, den: Int): Try&lt;Tuple2&lt;Int, Int&gt;&gt; {<br/>   return tryDivide(a, den).flatMap { aDiv -&gt;<br/>      tryDivide(b, den).flatMap { bDiv -&gt;<br/>         Try { aDiv toT bDiv }<br/>      }<br/>   }<br/>}</pre>
<p>Monadic comprehensions are available for <kbd>Try</kbd> too:</p>
<pre>fun comprehensionTryDivision(a: Int, b: Int, den: Int): Try&lt;Tuple2&lt;Int, Int&gt;&gt; {<br/>   return Try.monad().binding {<br/>      val aDiv = tryDivide(a, den).bind()<br/>      val bDiv = tryDivide(b, den).bind()<br/>      aDiv toT bDiv<br/>   }.ev()<br/>}</pre>
<p>There is another kind of monadic comprehension using an instance of <kbd>MonadError</kbd>:</p>
<pre>fun monadErrorTryDivision(a: Int, b: Int, den: Int): Try&lt;Tuple2&lt;Int, Int&gt;&gt; {<br/>   return Try.monadError().bindingCatch {<br/>      val aDiv = divide(a, den)!!<br/>      val bDiv = divide(b, den)!!<br/>      aDiv toT bDiv<br/>   }.ev()<br/>}</pre>
<p>With <kbd>monadError.bindingCatch</kbd> any operation that throws an exception is lifted to <kbd>Failure</kbd>, at the end the returns is wrapped into <kbd>Try&lt;T&gt;</kbd>. <kbd>MonadError</kbd> is also available for <kbd>Option</kbd> and <kbd>Either</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">State</h1>
                
            
            
                
<p><strong>State</strong> is a structure that provides a functional approach for handling application state. <kbd>State&lt;S, A&gt;</kbd> is an abstraction over <kbd>S -&gt; Tuple2&lt;S, A&gt;</kbd>. <strong>S</strong> represents the state type, and <kbd>Tuple2&lt;S, A&gt;</kbd> is the result, with <kbd>S</kbd> for the newly updated state and <kbd>A</kbd> for the function return.</p>
<p>We can start with a simple example, a function that returns two things, a price and the steps to calculate it. To calculate a price, we need to add  <kbd>VAT</kbd> of 20% and apply a discount if the <kbd>price</kbd> value goes above some threshold:</p>
<pre>import arrow.core.Tuple2<br/>import arrow.core.toT<br/>import arrow.data.State<br/><br/>typealias PriceLog = MutableList&lt;Tuple2&lt;String, Double&gt;&gt;<br/><br/>fun addVat(): State&lt;PriceLog, Unit&gt; = State { log: PriceLog -&gt;<br/>    val (_, price) = log.last()<br/>    val vat = price * 0.2<br/>    log.add("Add VAT: $vat" toT price + vat)<br/>    log toT Unit<br/>}</pre>
<p>We have a type alias <kbd>PriceLog</kbd> for <kbd>MutableList&lt;Tuple2&lt;String, Double&gt;&gt;</kbd>. <kbd>PriceLog</kbd> will be our <kbd>State</kbd> representation; each step represented with <kbd>Tuple2&lt;String, Double&gt;</kbd>.</p>
<p>Our first function, <kbd>addVat(): State&lt;PriceLog, Unit&gt;</kbd> represents the first step. We write the function using a <kbd>State</kbd> builder that receives <kbd>PriceLog</kbd>, the state before applying any step and must return a <kbd>Tuple2&lt;PriceLog, Unit&gt;</kbd>, we use <kbd>Unit</kbd> because we don't need the price at this point:</p>
<pre>fun applyDiscount(threshold: Double, discount: Double): State&lt;PriceLog, Unit&gt; = State { log -&gt;<br/>    val (_, price) = log.last()<br/>    if (price &gt; threshold) {<br/>        log.add("Applying -$discount" toT price - discount)<br/>    } else {<br/>        log.add("No discount applied" toT price)<br/>    }<br/>    log toT Unit<br/>}</pre>
<p>The <kbd>applyDiscount</kbd> function is our second step. The only new element that we introduce here are two parameters, one for <kbd>threshold</kbd> and the other for <kbd>discount</kbd>:</p>
<pre>fun finalPrice(): State&lt;PriceLog, Double&gt; = State { log -&gt;<br/>    val (_, price) = log.last()<br/>    log.add("Final Price" toT price)<br/>    log toT price<br/>}</pre>
<p>The last step is represented by the function <kbd>finalPrice()</kbd>, and now we return <kbd>Double</kbd> instead of <kbd>Unit</kbd>:</p>
<pre>import arrow.data.ev<br/>import arrow.instances.monad<br/>import arrow.typeclasses.binding<br/><br/>fun calculatePrice(threshold: Double, discount: Double) = State().monad&lt;PriceLog&gt;().binding {<br/>    addVat().bind() //Unit<br/>    applyDiscount(threshold, discount).bind() //Unit<br/>    val price: Double = finalPrice().bind()<br/>    price<br/>}.ev()</pre>
<p>To represent the sequence of steps, we use a monad comprehension and use the <kbd>State</kbd> functions sequentially. From one function to the next one, the <kbd>PriceLog</kbd> state is flowing implicitly (is just some coroutine continuations magic). At the end, we yield the final price. Adding new steps or switching existing ones is as easy as adding or moving lines:</p>
<pre>import arrow.data.run<br/>import arrow.data.runA<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    val (history: PriceLog, price: Double) = calculatePrice(100.0, 2.0).run(mutableListOf("Init" toT 15.0))<br/>    println("Price: $price")<br/>    println("::History::")<br/>    history<br/>            .map { (text, value) -&gt; "$text\t|\t$value" }<br/>            .forEach(::println)<br/><br/>    val bigPrice: Double = calculatePrice(100.0, 2.0).runA(mutableListOf("Init" toT 1000.0))<br/>    println("bigPrice = $bigPrice")<br/>}</pre>
<p>To use the <kbd>calculatePrice</kbd> function, you must provide the threshold and discount values and then invoke the extension function <kbd>run</kbd> with an initial state. If you're interested just in the price, you can use <kbd>runA</kbd> or for just the history, <kbd>runS</kbd>.</p>
<p>Avoid problems using <kbd>State</kbd>. Don't confuse the extension function <kbd>arrow.data.run</kbd> with the extension function, <kbd>kotlin.run</kbd> (imported by default).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Corecursion with State</h1>
                
            
            
                
<p><kbd>State</kbd> is beneficial on corecursion; we can rewrite our old examples with <kbd>State</kbd>:</p>
<div><pre>fun &lt;T, S&gt; unfold(s: S, f: (S) -&gt; Pair&lt;T, S&gt;?): Sequence&lt;T&gt; {<br/>   val result = f(s)<br/>   return if (result != null) {<br/>      sequenceOf(result.first) + unfold(result.second, f)<br/>   } else {<br/>      sequenceOf()<br/>   }<br/>}</pre></div>
<p>Our original <kbd>unfold</kbd> function use a function, <kbd>f: (S) -&gt; Pair&lt;T,S&gt;?</kbd> which is very similar to <kbd>State&lt;S, T&gt;</kbd>:</p>
<div><pre>fun &lt;T, S&gt; unfold(s: S, state: State&lt;S, Option&lt;T&gt;&gt;): Sequence&lt;T&gt; {<br/>    val (actualState: S, value: Option&lt;T&gt;) = state.run(s)<br/>    return value.fold(<br/>            { sequenceOf() },<br/>            { t -&gt;<br/>                sequenceOf(t) + unfold(actualState, state)<br/>            })<br/>}</pre></div>
<p>Instead of having a lambda <kbd>(S) -&gt; Pair&lt;T, S&gt;?</kbd>, we use <kbd>State&lt;S, Option&lt;T&gt;&gt;</kbd> and we use the function fold from <kbd>Option</kbd>, with an empty <kbd>Sequence</kbd> for <kbd>None</kbd> or a recursive call for <kbd>Some&lt;T&gt;</kbd>:</p>
<pre>fun factorial(size: Int): Sequence&lt;Long&gt; {<br/>   return sequenceOf(1L) + unfold(1L to 1) { (acc, n) -&gt;<br/>      if (size &gt; n) {<br/>         val x = n * acc<br/>         (x) to (x to n + 1)<br/>      } else<br/>         null<br/>   }<br/>}</pre>
<p>Our old factorial function uses <kbd>unfold</kbd> with <kbd>Pair&lt;Long, Int&gt;</kbd> and a lambda—<kbd>(Pair&lt;Long, Int&gt;) -&gt; Pair&lt;Long, Pair&lt;Long, Int&gt;&gt;?</kbd>:</p>
<pre>import arrow.syntax.option.some<br/><br/>fun factorial(size: Int): Sequence&lt;Long&gt; {<br/>    return sequenceOf(1L) + unfold(1L toT 1, State { (acc, n) -&gt;<br/>        if (size &gt; n) {<br/>            val x = n * acc<br/>            (x toT n + 1) toT x.some()<br/>        } else {<br/>            (0L toT 0) toT None<br/>        }<br/>    })<br/>}</pre>
<p>The refactored factorial uses <kbd>State&lt;Tuple&lt;Long, Int&gt;, Option&lt;Long&gt;&gt;</kbd> but internal logic is almost the same, although our new factorial doesn't use null, which is a significant improvement:</p>
<pre>fun fib(size: Int): Sequence&lt;Long&gt; {<br/>   return sequenceOf(1L) + unfold(Triple(0L, 1L, 1)) { (cur, next, n) -&gt;<br/>      if (size &gt; n) {<br/>         val x = cur + next<br/>         (x) to Triple(next, x, n + 1)<br/>      }<br/>      else<br/>         null<br/>   }<br/>}<br/><br/></pre>
<p>Similarly, <kbd>fib</kbd> uses unfold with <kbd>Triple&lt;Long, Long, Int&gt;</kbd> and a lambda <kbd>(Triple&lt;Long, Long. Int&gt;) -&gt; Pair&lt;Long, Triple&lt;Long, Long, Int&gt;&gt;?</kbd>:</p>
<pre>import arrow.syntax.tuples.plus<br/><br/>fun fib(size: Int): Sequence&lt;Long&gt; {<br/>    return sequenceOf(1L) + unfold((0L toT 1L) + 1, State { (cur, next, n) -&gt;<br/>        if (size &gt; n) {<br/>            val x = cur + next<br/>            ((next toT x) + (n + 1)) toT x.some()<br/>        } else {<br/>            ((0L toT 0L) + 0) toT None<br/>        }<br/>    })<br/>}</pre>
<p>And the refactored <kbd>fib</kbd> uses <kbd>State&lt;Tuple3&lt;Long, Long, Int&gt;, Option&lt;Long&gt;&gt;</kbd>. Pay close attention to the extension operator function <kbd>plus</kbd>, used with <kbd>Tuple2&lt;A, B&gt;</kbd> and <kbd>C</kbd> will return <kbd>Tuple3&lt;A, B, C&gt;</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) {<br/>    factorial(10).forEach(::println)<br/>    fib(10).forEach(::println)<br/>}</pre>
<p>And now, we can use our corecursive functions to generate sequences. There are many other uses for <kbd>State</kbd> that we can't cover here, such as <em>Message History</em> from <em>Enterprise Integration Patterns</em> (<a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html">http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html</a>) or navigation on forms with multiple steps such as plane checking or long registration forms.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Arrow provides many datatypes and type classes that reduce significantly complex tasks and provide a standard set of idioms and expressions. In this chapter, we learned how to abstract over null values with <kbd>Option</kbd> and to express computations with <kbd>Either</kbd> and <kbd>Try</kbd>. We created a datatype class, and we also learned about monadic comprehensions and transformations. Last but not least, we used <kbd>State</kbd> to represent the application state.</p>
<p>And with this chapter, we reach the final of this journey, but rest assured, this isn't the end of your journey learning functional programming. As we learned in the first chapters, functional programming is all about using functions as building blocks to create complex programs. In the same way, with all the concepts that you learn here, now you can understand and master new, exciting and more powerful ideas. </p>
<p>Now a new learning journey begins for you.</p>


            

            
        
    </body></html>