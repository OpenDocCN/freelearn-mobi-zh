- en: Making Overviews Even Better
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使概览/仪表板屏幕更加完善
- en: 'When you built the overview/dashboard screen in [Chapter 7](22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml),
    *Creating Overview Screens*, you used a `RecyclerView` and used Room and data
    binding to retrieve the list of records from the database and display them to
    the user, and it worked fantastically well. However, it can be done even better.
    `RecyclerView` is an incredibly powerful engine for data display, and we''ve only
    really scratched the surface of what it''s capable of. In this chapter, we''ll
    take a deeper look at some of the ecosystem surrounding the `RecyclerView` and
    integrate some big improvements into the claim example. Specifically, we''ll explore
    the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在[第7章](22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml)“创建概览屏幕”中构建概览/仪表板屏幕时，使用了`RecyclerView`，并通过Room和数据绑定从数据库检索记录列表并显示给用户，效果非常好。然而，还可以做得更好。`RecyclerView`是一个功能强大的数据展示引擎，我们实际上只是触及了它能力的一小部分。在本章中，我们将更深入地探讨`RecyclerView`周围的一些生态系统，并将一些重大改进集成到示例中。具体来说，我们将探讨以下内容：
- en: Different ways to lay out a `RecyclerView` with more than one view type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以多种方式布局具有多个视图类型的`RecyclerView`
- en: Ways to improve the `RecyclerView` performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高`RecyclerView`性能的方法
- en: Animating changes to `RecyclerView`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画化`RecyclerView`中的更改
- en: Keeping the complexity off the main thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将复杂性从主线程中移除
- en: Multiple view types
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多种视图类型
- en: '`RecyclerView` is capable of handling almost any number of different types
    of widgets for display on the screen, and recycling them all independently. This
    is an amazingly powerful and useful technique, not just for being able to display
    different types of data on the screen, but also to adjust the layout of the `RecyclerView`
    in a way that is mostly transparent. However, you''ll need to look at how exactly
    you want to break the layout up.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`能够处理几乎任何数量的不同类型的屏幕小部件，并独立地回收它们。这是一种非常强大且有用的技术，不仅能够显示不同类型的数据，而且还能以大多数情况下对用户透明的方式调整`RecyclerView`的布局。然而，你需要考虑如何具体地分割布局。'
- en: 'There are generally two main reasons you will want to use different view types
    in a `RecyclerView`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你会在`RecyclerView`中使用不同视图类型的主要原因有两个：
- en: To break up a long list of items with a divider
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分隔符将长列表项分割开
- en: As you have different types of data you want to render together
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要渲染不同类型的数据时
- en: Let's start with creating and adding dividers; you can just adjust the margin
    of each of the widgets when the data is bound to them, but that doesn't help the
    user understand why the divider is there. Often, you'll want a divider to carry
    details of what it actually represents, such as a date label. In these cases,
    you need widgets to render the label.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建和添加分隔符开始；当数据绑定到每个小部件时，你可以调整每个小部件的边距，但这并不能帮助用户理解分隔符为什么存在。通常，你希望分隔符携带它所代表的具体细节，例如日期标签。在这些情况下，你需要小部件来渲染标签。
- en: 'You can create a special variant of your normal item layout that includes the
    divider, by embedding it in a `LinearLayout`. For example, if you wanted to add
    a divider label to the claim items displayed in the overview of the travel claim
    application, you could add a special layout named `card_claim_item_with_divider`,
    and have it look something like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个特殊的布局变体，包括分隔符，通过将其嵌入`LinearLayout`中实现。例如，如果你想向旅行报销应用的概览中显示的报销项添加分隔符标签，你可以添加一个名为`card_claim_item_with_divider`的特殊布局，其外观可能如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach is very simple to implement, because the divider is made part
    of the item that appears below it. This, in turn, means that your `Adapter` implementation
    only needs to decide whether or not an item needs a divider or not, as opposed
    to keeping track of the dividers as their own object type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法实现起来非常简单，因为分隔符被制作成出现在其下方项的一部分。这反过来意味着你的`Adapter`实现只需要决定一个项是否需要分隔符，而不是像跟踪分隔符作为自己的对象类型那样。
- en: However, the approach also has several large disadvantages; each divider now
    carries an entire card with it, and if there are no dividers on the screen, the
    `RecyclerView` will still maintain a pool of them off-screen. This means that
    the entire unused card is unusable, and takes up much more memory and data than
    it should. The other problem with this approach is that you have nested the widgets
    another layer deep, within a `LinearLayout`. The `LinearLayout` renders the contained
    widgets in exactly the same way as the `LinearLayoutManager` attached to the `RecyclerView`.
    So, this layout introduces a widget into the layout system that doesn't really
    add any value and will negatively impact the application's performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法也有几个显著的缺点；每个分隔符现在都携带一个整个卡片，如果没有分隔符在屏幕上，`RecyclerView`仍然会在屏幕外维护一个分隔符的池。这意味着整个未使用的卡片都无法使用，并且占用了比应有的更多内存和数据。这种方法的其他问题是，你将小部件嵌套在另一个`LinearLayout`层中。`LinearLayout`以与`RecyclerView`附加的`LinearLayoutManager`完全相同的方式渲染包含的小部件。因此，这个布局引入了一个对布局系统实际上没有增加任何价值的控件，并且会负面影响应用程序的性能。
- en: So, what is the alternative? It's quite simple, really; treat dividers as special
    items in your `RecyclerView`. When you break up a `RecyclerView`, each view type
    is given an integer identifier that allows the `RecyclerView` to keep track of
    them independently in different recycling pools, and ensure that each one is only
    used in the right place. The easiest way to introduce dividers as special items,
    is to introduce them as special items in your dataset. This can be as simple as
    adding null values into the `List` of `ClaimItem` objects where dividers are required,
    but that won't play very nicely with data binding layers, and doesn't scale well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，替代方案是什么呢？实际上非常简单；将分隔符视为`RecyclerView`中的特殊项目。当你拆分`RecyclerView`时，每个视图类型都会被赋予一个整数标识符，这使得`RecyclerView`能够独立地在不同的回收池中跟踪它们，并确保每个分隔符只用在正确的位置。将分隔符作为特殊项目引入的最简单方法，就是在数据集中将其作为特殊项目引入。这可以通过在需要分隔符的`ClaimItem`对象`List`中添加null值来实现，但这与数据绑定层不太兼容，并且扩展性不好。
- en: 'A better way is to use a `wrapper` object in the dataset that tells the `Adapter`
    implementation how to render each of the items. This list can be calculated upfront
    and reduces the complexity of the layout and rendering. This also allows for very
    complex choices to be made for every item in the dataset, without affecting the
    user''s perceived performance of the application. Let''s build a `DisplayItem`
    class that can be used along with the `DataBoundViewHolder` class, to allow for
    any number of different item types to be used together in a single `Adapter`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用数据集中的`wrapper`对象，告诉`Adapter`实现如何渲染每个项目。这个列表可以预先计算，并减少了布局和渲染的复杂性。这也允许为数据集中的每个项目做出非常复杂的选择，而不会影响用户对应用程序性能的感知。让我们构建一个`DisplayItem`类，它可以与`DataBoundViewHolder`类一起使用，允许在单个`Adapter`中使用任意数量的不同项目类型：
- en: Right-click on the `com.packtpub.claim.ui` package in the travel claim example
    project and select New| Java Class.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旅行索赔示例项目中，在`com.packtpub.claim.ui`包上右键单击，并选择“新建| Java类”。
- en: Name the new class `DisplayItem` and click OK.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`DisplayItem`并点击“确定”。
- en: 'Declare an integer field to represent the layout resource for each `DisplayItem`
    object. These will be used by the `Adapter` class to figure out which layout to
    load and render:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个整数字段来表示每个`DisplayItem`对象的布局资源。这些将由`Adapter`类用来确定加载和渲染哪个布局：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This class is expected to be used as part of a mixed list, making generics
    inappropriate at this level. Declare a plain `Object` field to hold the data (if
    there is any) for the `DisplayItem` to bind to its layout:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类预期将作为混合列表的一部分使用，因此在这一级别使用泛型是不合适的。声明一个普通的`Object`字段来保存`DisplayItem`要绑定到其布局的数据（如果有）：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, you''ll need a constructor to assign these two fields:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你需要一个构造函数来分配这两个字段：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As a convenience to the `Adapter` classes, the `DisplayItem` will offer a `bindItem`
    method to help with the `DataBoundViewHolder` class:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了方便`Adapter`类，`DisplayItem`将提供一个`bindItem`方法来帮助`DataBoundViewHolder`类：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a very simple class to implement, but makes a very big difference in
    how the `Adapter` implementation works. As the dataset in the `Adapter` is no
    longer the raw dataset read from the database or network, you're free to mix various
    data sources without having to do any of the work in the `onBindViewHolder` method.
    The `DisplayItem` is a bit like a `ViewHolder` that doesn't actually hold the
    user-interface widgets; instead, it just signals which layout needs to be used
    for the data it carries.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类来实现，但它在`Adapter`的实现方式上产生了非常大的差异。由于`Adapter`中的数据集不再是直接从数据库或网络读取的原始数据集，你可以自由地混合各种数据源，而无需在`onBindViewHolder`方法中做任何工作。`DisplayItem`有点像`ViewHolder`，但实际上并不持有用户界面小部件；相反，它只是指示需要使用哪种布局来显示携带的数据。
- en: Introducing dividers
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入分隔符
- en: In order to introduce dividers into the claim overview screen, you'll need to
    run a second pass over the data being delivered from the Room database layer,
    and figure which items require a divider. This should be done on a background
    worker thread, so that larger datasets won't impact the user experience. Let's
    get to work and add some simple dividers to the travel claim app to appear between
    claim items made on different days; this will require some major changes to how
    the `ClaimItemAdapter` class works. The most obvious change is that it will now
    have a `List` of `DisplayItem` objects instead of directly containing a `List`
    of `ClaimItem` objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在声明概览屏幕中引入分隔符，你需要对从Room数据库层传递的数据进行第二次遍历，并确定哪些项需要分隔符。这应该在后台工作线程中完成，以便较大的数据集不会影响用户体验。让我们开始工作，并在旅行声明应用中添加一些简单的分隔符，以显示在不同天制作的声明项之间；这将需要对`ClaimItemAdapter`类的工作方式做出一些重大更改。最明显的变化是，它现在将有一个`DisplayItem`对象的`List`，而不是直接包含`ClaimItem`对象的`List`。
- en: 'Follow these steps to restructure the `ClaimItemAdapter` to use `DisplayItem`
    objects to mix both claim items and dividers in the `RecyclerView`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤重构`ClaimItemAdapter`以使用`DisplayItem`对象在`RecyclerView`中混合声明项和分隔符：
- en: First, you'll need a nice line that you can use as a divider. This will be a
    drawable that can be rendered using an `ImageView` widget. Right-click on the
    `res/drawable` directory and select New| Drawable resource file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要一条漂亮的线，可以用作分隔符。这将是一个可以使用`ImageView`小部件渲染的可绘制资源。在`res/drawable`目录上右键单击，然后选择“新建|可绘制资源文件”。
- en: Name the new file `horizontal_divider`, and click OK to create the new resource.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`horizontal_divider`，然后点击“确定”以创建新的资源。
- en: Change to the Text editor.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到文本编辑器。
- en: 'By default, Android Studio will have created a `selector` drawable, but you
    want to declare a `shape` drawable. Replace the generated template code with the
    following XML drawable:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Android Studio将创建一个`selector`可绘制资源，但你想要声明一个`shape`可绘制资源。用以下XML可绘制资源替换生成的模板代码：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You'll also need a layout to use for the dividers in the `RecyclerView`. Right-click
    on the `res/layout` directory and select New| Layout resource file.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要一个用于`RecyclerView`中分隔符的布局。在`res/layout`目录上右键单击，然后选择“新建|布局资源文件”。
- en: Name the new layout file `widget_divider`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新布局文件命名为`widget_divider`。
- en: Change the Root element to `layout`.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素更改为`layout`。
- en: Click OK to create the new layout resource file.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的布局资源文件。
- en: 'The new layout doesn''t actually need any variables to be bound, so you can
    leave the `data` section empty. Use an `ImageView` to render the new `horizontal_divider`
    at full width:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新布局实际上不需要绑定任何变量，因此你可以将`data`部分留空。使用`ImageView`来渲染全宽度的新的`horizontal_divider`：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, open the `ClaimItemAdapter` source file.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`ClaimItemAdapter`源文件。
- en: 'Change the `List` of `ClaimItem` objects to a `List` of `DisplayItem` objects:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ClaimItem`对象的`List`改为`DisplayItem`对象的`List`：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Declare a new override method--`getItemViewType`--and use the `DisplayItem.layout`
    value to identify the differences between the layouts that will be used in the
    `RecyclerView`. This method will delegate to the `DisplayItem` objects and use
    the layout resource ID as an identifier:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的重写方法--`getItemViewType`--并使用`DisplayItem.layout`值来识别在`RecyclerView`中将使用的布局之间的差异。此方法将委托给`DisplayItem`对象，并使用布局资源ID作为标识符：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's a common trick to directly use the layout resource ID to determine the
    different view types in a `RecyclerView`. This avoids any mapping between internal
    ID numbers and the layout resources.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用布局资源ID来确定`RecyclerView`中的不同视图类型是一个常见的技巧。这避免了内部ID数字和布局资源之间的映射。
- en: 'Now, change the `onCreateViewHolder` method to use the `viewType` to decide
    which layout resource to load. The `viewType` will be passed in by the `RecyclerView`,
    and will be the same value that was returned by `getItemViewType`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`onCreateViewHolder`方法更改为使用`viewType`来决定加载哪个布局资源。`viewType`将由`RecyclerView`传入，并将与`getItemViewType`返回的值相同：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change the `onBindViewHolder` method to use the `DisplayItem.bindItem` method,
    rather than directly invoking `DataBoundViewHolder.setItem`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`onBindViewHolder`方法更改为使用`DisplayItem.bindItem`方法，而不是直接调用`DataBoundViewHolder.setItem`：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At the bottom of the `ClaimItemAdapter` class, you''ll need a new `ActionCommand`
    inner class to do the work of calculating where the dividers should be placed,
    and wrapping all the `ClaimItem` objects in `DisplayItem` objects:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ClaimItemAdapter`类底部，你需要一个新的`ActionCommand`内部类来完成计算分隔符位置的工作，并将所有`ClaimItem`对象包装在`DisplayItem`对象中：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `CreateDisplayListCommand` will need a utility method to decide whether
    or not to insert a divider between two items. This utility method will simply
    check whether both items have timestamps on the same day:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`CreateDisplayListCommand`需要一个实用方法来决定是否在两个项目之间插入分隔符。这个实用方法将简单地检查两个项目是否在同一天有时间戳：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, you''ll need to implement the `onBackground` method of `ActionCommand`,
    and process the list of `ClaimItem` objects into a `List` of `DisplayItem` objects:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要实现`ActionCommand`的`onBackground`方法，并将`ClaimItem`对象列表处理成`DisplayItem`对象列表：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To complete the `CreateDisplayListCommand` implementation, you''ll need to
    implement the `onForeground` method. This will assign the new `List` of `DisplayItem`
    objects up to the `ClaimItemAdapter` and notify the `RecyclerView` of the changes:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成`CreateDisplayListCommand`的实现，你需要实现`onForeground`方法。这将把新的`DisplayItem`对象列表分配给`ClaimItemAdapter`，并通知`RecyclerView`发生变化：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll need an instance of `CreateDisplayListCommand` for the `ClaimItemAdapter`
    to use each time the `LiveData` is updated. Create a new field at the top of the
    `ClaimItemAdapter` class, and instantiate it:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要为每次`LiveData`更新提供一个`CreateDisplayListCommand`实例供`ClaimItemAdapter`使用。在`ClaimItemAdapter`类顶部创建一个新字段，并实例化它：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, you can change the constructor to use the `CreateDisplayListCommand` instead
    of directly referencing the `List` of `ClaimItem` objects returned by the Room
    database:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以将构造函数更改为使用`CreateDisplayListCommand`而不是直接引用Room数据库返回的`ClaimItem`对象列表：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run the travel claim application now, you'll have a lovely thin and light
    divider between any claim items that were captured for different dates. Try creating
    a few using the datepicker to shift the days and force the user interface to produce
    different groupings of cards. You'll also find that because all the data still
    comes from the database, you can add and remove the data, and the user interface
    will remain up to date.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行旅行报销应用程序，你会在不同日期捕获的任何报销项目之间看到一个漂亮而轻薄的分隔符。尝试使用日期选择器来改变日期并强制用户界面产生不同的卡片分组。你还会发现，因为所有数据仍然来自数据库，你可以添加和删除数据，用户界面将保持最新。
- en: Updating by Delta Events
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Delta事件更新
- en: Up until this point, when the data changes in the database, the `ClaimItemAdapter`
    simply tells the `RecyclerView` that the data has changed. This is not the most
    efficient use of resources, because the `RecyclerView` doesn't actually know what
    in the model has changed, and it's forced to relayout the entire scene as though
    the entire model has changed (although it will reuse the widgets it has already
    pooled).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当数据库中的数据发生变化时，`ClaimItemAdapter`只是告诉`RecyclerView`数据已经改变。这不是最有效率的资源使用方式，因为`RecyclerView`实际上并不知道模型中的哪些内容发生了变化，它被迫重新布局整个场景，仿佛整个模型都发生了变化（尽管它会重用已经池化的小部件）。
- en: '`RecyclerView` actually has a secondary mechanism that allows you to tell it
    what has changed, rather than just saying that the data has changed. This is provided
    through a series of notifications the signal single items, or ranges being added,
    removed, and moved. The problem is that in order to use these methods, you need
    to know what has actually changed.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`实际上有一个二级机制，允许你告诉它哪些内容发生了变化，而不仅仅是说数据已经改变。这是通过一系列通知来实现的，这些通知会指示单个项目、范围被添加、删除或移动。问题是，为了使用这些方法，你需要知道实际上发生了什么变化。'
- en: Most developer's first instincts here will be to use more events and signal
    from the DAO or a delegate layer what is changing, and then catch those events
    in the `Adapter` and forward them to the `RecyclerView.` This can be made to work,
    and in fact, it can work quite well when done through an event bus rather than
    having the `Adapter` directly attach itself to the DAO layer. The problem is that
    it also forces you to generate these events, translate them, and they can become
    unwieldy as the possible list of simultaneous changes becomes more complex.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者的第一反应可能是使用更多的事件和信号从DAO或代理层来表示变化，然后在`Adapter`中捕获这些事件并将它们转发到`RecyclerView`。这可以工作，实际上，如果通过事件总线而不是`Adapter`直接附加到DAO层来实现，效果可能相当好。问题是，这也迫使你必须生成这些事件，翻译它们，并且当可能的并发更改列表变得更加复杂时，它们可能会变得难以控制。
- en: 'Another way is to leave the events up to Room. When new data is provided via
    `LiveData`, you can compare the dataset currently displayed to the user with the
    new dataset and calculate what has changed. This is the same way that version
    control software such as Git or Mercurial work; they compare what you have done
    with what you started with to create a delta, or diff of the changes. This can
    be complicated and hard work, but Android support library has you covered; it
    provides a class named `DiffUtil` that can not only be used to compute the differences
    between virtually any two datasets, but also produce the correct set of events
    to deliver to the `RecyclerView`. Let''s use `DiffUtil` in the `ClaimItemAdapter`,
    to only apply the changes to the `RecyclerView`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是让Room处理事件。当通过`LiveData`提供新数据时，你可以比较当前显示给用户的dataset与新的dataset，并计算发生了什么变化。这与版本控制软件（如Git或Mercurial）的工作方式相同；它们比较你所做的与开始时的内容，以创建delta或diff，即更改的差异。这可能很复杂且工作量很大，但Android支持库为你提供了支持；它提供了一个名为`DiffUtil`的类，不仅可以用于计算几乎任何两个dataset之间的差异，还可以生成正确的events集，以传递给`RecyclerView`。让我们在`ClaimItemAdapter`中使用`DiffUtil`，只应用更改到`RecyclerView`：
- en: Before searching for differences, it's important to be able to determine whether
    two `ClaimItem` objects refer to the same database record, but are different.
    For that, you'll need a complete `equals` method, which can be generated by Android
    Studio. Open the `ClaimItem` source file in Android Studio.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索差异之前，能够确定两个`ClaimItem`对象是否指向相同的数据库记录，但内容不同，这是非常重要的。为此，你需要一个完整的`equals`方法，这可以通过Android
    Studio生成。在Android Studio中打开`ClaimItem`源文件。
- en: Click on the class name in the editor, and then select Code|Generate from the
    main menu bar.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中单击类名，然后从主菜单栏中选择代码|生成。
- en: Select equals() and hashCode() from the pop-up menu.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出菜单中选择equals()和hashCode()。
- en: Use all the defaults that are provided by the IDE, clicking on Next and Finish
    until the wizard is complete.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用IDE提供的所有默认设置，点击“下一步”和“完成”，直到向导完成。
- en: Open the `ClaimItemAdapter` source file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ClaimItemAdapter`源文件。
- en: 'At the bottom of the `ClaimItemAdapter` class below the `CreateDisplayListCommand`
    inner class, declare a new `ActionCommand` inner class to deal with updating the
    existing list of `DisplayItem` objects, and triggering the required change notifications:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ClaimItemAdapter`类中`CreateDisplayListCommand`内部类下面，声明一个新的`ActionCommand`内部类来处理更新现有的`DisplayItem`对象列表，并触发所需的变化通知：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class takes and processes `Pair` objects containing two parameters each.
    As input, we'll be passing the old `List` of `DisplayItem` objects, and the new
    `List` of `ClaimItem` objects that it needs to process. As output, it will produce
    the new `List` of `DisplayItem` objects, and a `DiffResult` that can be used to
    trigger the update events.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类接收并处理包含两个参数的`Pair`对象。作为输入，我们将传递旧的`DisplayItem`对象`List`，以及它需要处理的新的`ClaimItem`对象`List`。作为输出，它将生成新的`DisplayItem`对象`List`，以及一个`DiffResult`，可以用来触发更新事件。
- en: 'The first thing you''ll need in the `UpdateDisplayListCommand` is the `onBackground`
    method. This method will use the `List` of `DisplayItem` objects passed in through
    the `Pair` as the "old" `List` of items, and will generate a "new" `List` of `DisplayItem`
    objects by invoking the `CreateDisplayListCommand` directly:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UpdateDisplayListCommand`中，你首先需要的是`onBackground`方法。这个方法将使用通过`Pair`传入的`DisplayItem`对象`List`作为“旧”的项`List`，并通过直接调用`CreateDisplayListCommand`来生成一个“新”的`DisplayItem`对象`List`：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that you have the `List` that is currently being displayed to the user
    and the `List` that needs to be displayed, it''s time to calculate the differences
    between them. In order to keep things completely generic, the `DiffUtil` defines
    a callback interface that is queried to find the details of the two lists. In
    the `UpdateDisplayListCommand` class, we''ll simply use an anonymous inner class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有了当前显示给用户的`List`和需要显示的`List`，是时候计算它们之间的差异了。为了保持完全通用，`DiffUtil`定义了一个回调接口，用于查询两个列表的详细信息。在`UpdateDisplayListCommand`类中，我们将简单地使用匿名内部类：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Callback` implementation also requires a method to compare items at two
    different positions, to see whether they appear to be the same item. The first
    thing to do is to check whether their layouts appear to be the same. If the layouts
    aren''t the same, we can be sure that they are not the same object. If the layouts
    are the same, then we can look at the layout integer as an indicator of what type
    of data is in the `DisplayItem` object. If it''s a `ClaimItem`, we use the database
    ID of the objects to see whether they represent the same record in the database:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Callback`实现还需要一个方法来比较两个不同位置的项目，以查看它们是否看起来是相同的项。首先，我们需要检查它们的布局是否看起来相同。如果布局不相同，我们可以确信它们不是同一个对象。如果布局相同，那么我们可以查看布局整数作为`DisplayItem`对象中数据类型的指示器。如果是`ClaimItem`，我们使用对象的数据库ID来查看它们是否代表数据库中的相同记录：'
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `Callback` also needs another method to test whether the contents of the
    two objects has actually changed. This method will only be invoked by the `DiffUtil`
    if the `areItemsTheSame` method returned true, which permits you to take some
    shortcuts through the implementation by assuming that both sides represent the
    same record:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Callback`还需要另一个方法来测试两个对象的实际内容是否已更改。此方法仅在`areItemsTheSame`方法返回true时由`DiffUtil`调用，这允许你通过假设两边代表相同的记录来在实现中采取一些捷径：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That concludes the `Callback` implementation. Now, you''ll need to close the
    `onBackground` method by returning a `Pair` containing the new list of `DisplayItem`
    objects and the `DiffResult`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就完成了`Callback`的实现。现在，你需要通过返回一个包含新的`DisplayItem`对象列表和`DiffResult`的`Pair`来关闭`onBackground`方法：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `onForeground` method of the `UpdateDisplayListCommand`, you''ll need
    to assign the new list of `DisplayItem` objects up to the `ClaimItemAdapter`,
    just as before. However, instead of notifying the `RecyclerView` that the whole
    model has changed, you can use the `DiffResult` to relay the differences you found
    as a series of events:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UpdateDisplayListCommand`类的`onForeground`方法中，你需要将新的`DisplayItem`对象列表分配给`ClaimItemAdapter`，就像之前一样。然而，你不需要通知`RecyclerView`整个模型已更改，而是可以使用`DiffResult`来传递你发现的一系列差异事件：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Back at the top of the `ClaimItemAdapter`, you''ll now need a field with an
    instance of the new `UpdateDisplayListCommand` class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ClaimItemAdapter`的顶部，你现在需要一个包含新`UpdateDisplayListCommand`类实例的字段：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the `ClaimItemAdapter` class''s constructor, the `LiveData` observer
    changes again. If the data is from the first notification, there is no point in
    calculating the differences between the two lists, but if it''s any invocation
    after that, you can now run it through the `UpdateDisplayListCommand`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`ClaimItemAdapter`类构造函数中，`LiveData`观察者再次发生变化。如果数据来自第一次通知，计算两个列表之间的差异没有意义，但如果是在之后的任何调用中，你现在可以通过`UpdateDisplayListCommand`来运行它：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These changes might seem like a lot of work just to change the events produced
    by the `Adapter` implementation, but they can be made relatively generic with
    some work so that they can be reused in various different list implementations.
    The changes also bring a much nice user experience to the table: animations. Because
    you are now telling the `RecyclerView` exactly what is changing, it will automatically
    animate the changes for you.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改可能看起来只是为了改变`Adapter`实现产生的事件而做的大量工作，但通过一些工作，它们可以相对通用，以便在不同的列表实现中重用。这些更改还带来了非常好的用户体验：动画。因为你现在告诉`RecyclerView`确切的变化，它将自动为你动画化这些变化。
- en: The `DiffUtil` is also an excellent tool in this case because of the dividers.
    Although the model changes one `ClaimItem` at a time, the `DiffUtil` also takes
    care of adding and removing any dividers that are affected by these changes. If
    you triggered each of these events from the database layer, you would need to
    handle these extra changes manually, and while `DiffUtil` might not be the most
    efficient tool, it keeps the data absolutely consistent.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分隔符，`DiffUtil` 在这个情况下也是一个出色的工具。尽管模型每次只更改一个 `ClaimItem`，但 `DiffUtil` 也负责添加和删除受这些更改影响的任何分隔符。如果你从数据库层触发这些事件中的每一个，你需要手动处理这些额外的更改，而尽管
    `DiffUtil` 可能不是最有效的工具，但它保持了数据的绝对一致性。
- en: Test your knowledge
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: How many different view types can you use in a single `RecyclerView` instance?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单个 `RecyclerView` 实例中，你可以使用多少种不同的视图类型？
- en: One or two
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或两个
- en: Any number
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何数量
- en: '256'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '256'
- en: When using a `DiffUtil`, which of the following applies to the data you are
    comparing?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用 `DiffUtil` 时，以下哪一项适用于你正在比较的数据？
- en: It must be a database entity
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是一个数据库实体
- en: It must be comparable
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须是可比较的
- en: It is exposed through a Callback
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过回调函数暴露
- en: When adding dividers to a `RecyclerView`, you should do which of these?
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当向 `RecyclerView` 添加分隔符时，你应该做以下哪一项？
- en: Make them part of the item above the divider
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们作为分隔符上方的项目的一部分
- en: Add them to the display in the `onBindViewHolder` method
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `onBindViewHolder` 方法中将它们添加到显示中
- en: Make them distinct items in the dataset
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们作为数据集中的独立项目
- en: Summary
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we largely focused on the `RecyclerView` and how to make it
    work even better within your application, and especially for overview/dashboard
    screens. Changes such as adding the dividers and animations don't change the functionality
    of an application, but they do change the user experience. In this case, they
    make it easier for the user to understand the screen and easier for them to understand
    what happened when things changed.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要关注 `RecyclerView` 以及如何在你的应用程序中使其工作得更好，特别是对于概览/仪表板屏幕。添加分隔符和动画等更改不会改变应用程序的功能，但它们确实会改变用户体验。在这种情况下，它们使用户更容易理解屏幕，并更容易理解当事情发生变化时发生了什么。
- en: These sorts of changes can be seen as "polishing" the application. You can build
    the application without them to ensure that everything works, and then add them
    in afterward. It's a good idea to slowly build a list of generic structures that
    can be used to quickly polish any application. A good example will be a generic
    `ActionCommand` to use the `DiffUtil` and apply the changes to an `Adapter`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的更改可以被视为“润色”应用程序。你可以不使用它们来构建应用程序以确保一切正常工作，然后之后添加它们。慢慢地构建一个可以快速润色任何应用程序的通用结构列表是个好主意。一个很好的例子是使用
    `DiffUtil` 的通用 `ActionCommand` 来应用更改到 `Adapter`。
- en: In the next chapter, we'll spend some more time on polishing applications. We'll
    look at animations, colors, and styling, and explore how to define and use them
    throughout an application to apply a consistent theme.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将花更多的时间来润色应用程序。我们将探讨动画、颜色和样式，并探索如何在应用程序中定义和使用它们以应用一致的主题。
