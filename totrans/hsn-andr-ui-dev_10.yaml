- en: Making Overviews Even Better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you built the overview/dashboard screen in [Chapter 7](22614b94-ebc1-40cb-8f19-3bd00ee2478b.xhtml),
    *Creating Overview Screens*, you used a `RecyclerView` and used Room and data
    binding to retrieve the list of records from the database and display them to
    the user, and it worked fantastically well. However, it can be done even better.
    `RecyclerView` is an incredibly powerful engine for data display, and we''ve only
    really scratched the surface of what it''s capable of. In this chapter, we''ll
    take a deeper look at some of the ecosystem surrounding the `RecyclerView` and
    integrate some big improvements into the claim example. Specifically, we''ll explore
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Different ways to lay out a `RecyclerView` with more than one view type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to improve the `RecyclerView` performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating changes to `RecyclerView`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping the complexity off the main thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple view types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RecyclerView` is capable of handling almost any number of different types
    of widgets for display on the screen, and recycling them all independently. This
    is an amazingly powerful and useful technique, not just for being able to display
    different types of data on the screen, but also to adjust the layout of the `RecyclerView`
    in a way that is mostly transparent. However, you''ll need to look at how exactly
    you want to break the layout up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are generally two main reasons you will want to use different view types
    in a `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: To break up a long list of items with a divider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you have different types of data you want to render together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with creating and adding dividers; you can just adjust the margin
    of each of the widgets when the data is bound to them, but that doesn't help the
    user understand why the divider is there. Often, you'll want a divider to carry
    details of what it actually represents, such as a date label. In these cases,
    you need widgets to render the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a special variant of your normal item layout that includes the
    divider, by embedding it in a `LinearLayout`. For example, if you wanted to add
    a divider label to the claim items displayed in the overview of the travel claim
    application, you could add a special layout named `card_claim_item_with_divider`,
    and have it look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This approach is very simple to implement, because the divider is made part
    of the item that appears below it. This, in turn, means that your `Adapter` implementation
    only needs to decide whether or not an item needs a divider or not, as opposed
    to keeping track of the dividers as their own object type.
  prefs: []
  type: TYPE_NORMAL
- en: However, the approach also has several large disadvantages; each divider now
    carries an entire card with it, and if there are no dividers on the screen, the
    `RecyclerView` will still maintain a pool of them off-screen. This means that
    the entire unused card is unusable, and takes up much more memory and data than
    it should. The other problem with this approach is that you have nested the widgets
    another layer deep, within a `LinearLayout`. The `LinearLayout` renders the contained
    widgets in exactly the same way as the `LinearLayoutManager` attached to the `RecyclerView`.
    So, this layout introduces a widget into the layout system that doesn't really
    add any value and will negatively impact the application's performance.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the alternative? It's quite simple, really; treat dividers as special
    items in your `RecyclerView`. When you break up a `RecyclerView`, each view type
    is given an integer identifier that allows the `RecyclerView` to keep track of
    them independently in different recycling pools, and ensure that each one is only
    used in the right place. The easiest way to introduce dividers as special items,
    is to introduce them as special items in your dataset. This can be as simple as
    adding null values into the `List` of `ClaimItem` objects where dividers are required,
    but that won't play very nicely with data binding layers, and doesn't scale well.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way is to use a `wrapper` object in the dataset that tells the `Adapter`
    implementation how to render each of the items. This list can be calculated upfront
    and reduces the complexity of the layout and rendering. This also allows for very
    complex choices to be made for every item in the dataset, without affecting the
    user''s perceived performance of the application. Let''s build a `DisplayItem`
    class that can be used along with the `DataBoundViewHolder` class, to allow for
    any number of different item types to be used together in a single `Adapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.claim.ui` package in the travel claim example
    project and select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `DisplayItem` and click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare an integer field to represent the layout resource for each `DisplayItem`
    object. These will be used by the `Adapter` class to figure out which layout to
    load and render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is expected to be used as part of a mixed list, making generics
    inappropriate at this level. Declare a plain `Object` field to hold the data (if
    there is any) for the `DisplayItem` to bind to its layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''ll need a constructor to assign these two fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As a convenience to the `Adapter` classes, the `DisplayItem` will offer a `bindItem`
    method to help with the `DataBoundViewHolder` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple class to implement, but makes a very big difference in
    how the `Adapter` implementation works. As the dataset in the `Adapter` is no
    longer the raw dataset read from the database or network, you're free to mix various
    data sources without having to do any of the work in the `onBindViewHolder` method.
    The `DisplayItem` is a bit like a `ViewHolder` that doesn't actually hold the
    user-interface widgets; instead, it just signals which layout needs to be used
    for the data it carries.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing dividers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to introduce dividers into the claim overview screen, you'll need to
    run a second pass over the data being delivered from the Room database layer,
    and figure which items require a divider. This should be done on a background
    worker thread, so that larger datasets won't impact the user experience. Let's
    get to work and add some simple dividers to the travel claim app to appear between
    claim items made on different days; this will require some major changes to how
    the `ClaimItemAdapter` class works. The most obvious change is that it will now
    have a `List` of `DisplayItem` objects instead of directly containing a `List`
    of `ClaimItem` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to restructure the `ClaimItemAdapter` to use `DisplayItem`
    objects to mix both claim items and dividers in the `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need a nice line that you can use as a divider. This will be a
    drawable that can be rendered using an `ImageView` widget. Right-click on the
    `res/drawable` directory and select New| Drawable resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `horizontal_divider`, and click OK to create the new resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, Android Studio will have created a `selector` drawable, but you
    want to declare a `shape` drawable. Replace the generated template code with the
    following XML drawable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You'll also need a layout to use for the dividers in the `RecyclerView`. Right-click
    on the `res/layout` directory and select New| Layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new layout file `widget_divider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Root element to `layout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The new layout doesn''t actually need any variables to be bound, so you can
    leave the `data` section empty. Use an `ImageView` to render the new `horizontal_divider`
    at full width:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `ClaimItemAdapter` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `List` of `ClaimItem` objects to a `List` of `DisplayItem` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a new override method--`getItemViewType`--and use the `DisplayItem.layout`
    value to identify the differences between the layouts that will be used in the
    `RecyclerView`. This method will delegate to the `DisplayItem` objects and use
    the layout resource ID as an identifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It's a common trick to directly use the layout resource ID to determine the
    different view types in a `RecyclerView`. This avoids any mapping between internal
    ID numbers and the layout resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, change the `onCreateViewHolder` method to use the `viewType` to decide
    which layout resource to load. The `viewType` will be passed in by the `RecyclerView`,
    and will be the same value that was returned by `getItemViewType`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `onBindViewHolder` method to use the `DisplayItem.bindItem` method,
    rather than directly invoking `DataBoundViewHolder.setItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `ClaimItemAdapter` class, you''ll need a new `ActionCommand`
    inner class to do the work of calculating where the dividers should be placed,
    and wrapping all the `ClaimItem` objects in `DisplayItem` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CreateDisplayListCommand` will need a utility method to decide whether
    or not to insert a divider between two items. This utility method will simply
    check whether both items have timestamps on the same day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you''ll need to implement the `onBackground` method of `ActionCommand`,
    and process the list of `ClaimItem` objects into a `List` of `DisplayItem` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete the `CreateDisplayListCommand` implementation, you''ll need to
    implement the `onForeground` method. This will assign the new `List` of `DisplayItem`
    objects up to the `ClaimItemAdapter` and notify the `RecyclerView` of the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll need an instance of `CreateDisplayListCommand` for the `ClaimItemAdapter`
    to use each time the `LiveData` is updated. Create a new field at the top of the
    `ClaimItemAdapter` class, and instantiate it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can change the constructor to use the `CreateDisplayListCommand` instead
    of directly referencing the `List` of `ClaimItem` objects returned by the Room
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you run the travel claim application now, you'll have a lovely thin and light
    divider between any claim items that were captured for different dates. Try creating
    a few using the datepicker to shift the days and force the user interface to produce
    different groupings of cards. You'll also find that because all the data still
    comes from the database, you can add and remove the data, and the user interface
    will remain up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Updating by Delta Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, when the data changes in the database, the `ClaimItemAdapter`
    simply tells the `RecyclerView` that the data has changed. This is not the most
    efficient use of resources, because the `RecyclerView` doesn't actually know what
    in the model has changed, and it's forced to relayout the entire scene as though
    the entire model has changed (although it will reuse the widgets it has already
    pooled).
  prefs: []
  type: TYPE_NORMAL
- en: '`RecyclerView` actually has a secondary mechanism that allows you to tell it
    what has changed, rather than just saying that the data has changed. This is provided
    through a series of notifications the signal single items, or ranges being added,
    removed, and moved. The problem is that in order to use these methods, you need
    to know what has actually changed.'
  prefs: []
  type: TYPE_NORMAL
- en: Most developer's first instincts here will be to use more events and signal
    from the DAO or a delegate layer what is changing, and then catch those events
    in the `Adapter` and forward them to the `RecyclerView.` This can be made to work,
    and in fact, it can work quite well when done through an event bus rather than
    having the `Adapter` directly attach itself to the DAO layer. The problem is that
    it also forces you to generate these events, translate them, and they can become
    unwieldy as the possible list of simultaneous changes becomes more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to leave the events up to Room. When new data is provided via
    `LiveData`, you can compare the dataset currently displayed to the user with the
    new dataset and calculate what has changed. This is the same way that version
    control software such as Git or Mercurial work; they compare what you have done
    with what you started with to create a delta, or diff of the changes. This can
    be complicated and hard work, but Android support library has you covered; it
    provides a class named `DiffUtil` that can not only be used to compute the differences
    between virtually any two datasets, but also produce the correct set of events
    to deliver to the `RecyclerView`. Let''s use `DiffUtil` in the `ClaimItemAdapter`,
    to only apply the changes to the `RecyclerView`:'
  prefs: []
  type: TYPE_NORMAL
- en: Before searching for differences, it's important to be able to determine whether
    two `ClaimItem` objects refer to the same database record, but are different.
    For that, you'll need a complete `equals` method, which can be generated by Android
    Studio. Open the `ClaimItem` source file in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the class name in the editor, and then select Code|Generate from the
    main menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select equals() and hashCode() from the pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use all the defaults that are provided by the IDE, clicking on Next and Finish
    until the wizard is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `ClaimItemAdapter` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of the `ClaimItemAdapter` class below the `CreateDisplayListCommand`
    inner class, declare a new `ActionCommand` inner class to deal with updating the
    existing list of `DisplayItem` objects, and triggering the required change notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This class takes and processes `Pair` objects containing two parameters each.
    As input, we'll be passing the old `List` of `DisplayItem` objects, and the new
    `List` of `ClaimItem` objects that it needs to process. As output, it will produce
    the new `List` of `DisplayItem` objects, and a `DiffResult` that can be used to
    trigger the update events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you''ll need in the `UpdateDisplayListCommand` is the `onBackground`
    method. This method will use the `List` of `DisplayItem` objects passed in through
    the `Pair` as the "old" `List` of items, and will generate a "new" `List` of `DisplayItem`
    objects by invoking the `CreateDisplayListCommand` directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the `List` that is currently being displayed to the user
    and the `List` that needs to be displayed, it''s time to calculate the differences
    between them. In order to keep things completely generic, the `DiffUtil` defines
    a callback interface that is queried to find the details of the two lists. In
    the `UpdateDisplayListCommand` class, we''ll simply use an anonymous inner class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Callback` implementation also requires a method to compare items at two
    different positions, to see whether they appear to be the same item. The first
    thing to do is to check whether their layouts appear to be the same. If the layouts
    aren''t the same, we can be sure that they are not the same object. If the layouts
    are the same, then we can look at the layout integer as an indicator of what type
    of data is in the `DisplayItem` object. If it''s a `ClaimItem`, we use the database
    ID of the objects to see whether they represent the same record in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Callback` also needs another method to test whether the contents of the
    two objects has actually changed. This method will only be invoked by the `DiffUtil`
    if the `areItemsTheSame` method returned true, which permits you to take some
    shortcuts through the implementation by assuming that both sides represent the
    same record:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That concludes the `Callback` implementation. Now, you''ll need to close the
    `onBackground` method by returning a `Pair` containing the new list of `DisplayItem`
    objects and the `DiffResult`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onForeground` method of the `UpdateDisplayListCommand`, you''ll need
    to assign the new list of `DisplayItem` objects up to the `ClaimItemAdapter`,
    just as before. However, instead of notifying the `RecyclerView` that the whole
    model has changed, you can use the `DiffResult` to relay the differences you found
    as a series of events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Back at the top of the `ClaimItemAdapter`, you''ll now need a field with an
    instance of the new `UpdateDisplayListCommand` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `ClaimItemAdapter` class''s constructor, the `LiveData` observer
    changes again. If the data is from the first notification, there is no point in
    calculating the differences between the two lists, but if it''s any invocation
    after that, you can now run it through the `UpdateDisplayListCommand`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These changes might seem like a lot of work just to change the events produced
    by the `Adapter` implementation, but they can be made relatively generic with
    some work so that they can be reused in various different list implementations.
    The changes also bring a much nice user experience to the table: animations. Because
    you are now telling the `RecyclerView` exactly what is changing, it will automatically
    animate the changes for you.'
  prefs: []
  type: TYPE_NORMAL
- en: The `DiffUtil` is also an excellent tool in this case because of the dividers.
    Although the model changes one `ClaimItem` at a time, the `DiffUtil` also takes
    care of adding and removing any dividers that are affected by these changes. If
    you triggered each of these events from the database layer, you would need to
    handle these extra changes manually, and while `DiffUtil` might not be the most
    efficient tool, it keeps the data absolutely consistent.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How many different view types can you use in a single `RecyclerView` instance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One or two
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '256'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When using a `DiffUtil`, which of the following applies to the data you are
    comparing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must be a database entity
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It must be comparable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is exposed through a Callback
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When adding dividers to a `RecyclerView`, you should do which of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make them part of the item above the divider
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add them to the display in the `onBindViewHolder` method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make them distinct items in the dataset
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we largely focused on the `RecyclerView` and how to make it
    work even better within your application, and especially for overview/dashboard
    screens. Changes such as adding the dividers and animations don't change the functionality
    of an application, but they do change the user experience. In this case, they
    make it easier for the user to understand the screen and easier for them to understand
    what happened when things changed.
  prefs: []
  type: TYPE_NORMAL
- en: These sorts of changes can be seen as "polishing" the application. You can build
    the application without them to ensure that everything works, and then add them
    in afterward. It's a good idea to slowly build a list of generic structures that
    can be used to quickly polish any application. A good example will be a generic
    `ActionCommand` to use the `DiffUtil` and apply the changes to an `Adapter`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll spend some more time on polishing applications. We'll
    look at animations, colors, and styling, and explore how to define and use them
    throughout an application to apply a consistent theme.
  prefs: []
  type: TYPE_NORMAL
