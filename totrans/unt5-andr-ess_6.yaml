- en: Chapter 6. Optimization and Transformation Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce you to the usage of **occlusion culling** (**OC**)
    and level of detail in optimization techniques. Also, you will learn to optimize
    Unity C# and Unity JS code. Finally, you will see how to transform Unity C# code
    to Unity JavaScript code and vice versa.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in the chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Occlusion culling and level of detail in optimization techniques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity C# and Unity JS optimization tips and tricks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming Unity C# code to Unity JavaScript code and vice versa
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Occlusion culling and level of detail in optimization techniques
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look more closely and carefully at the basic principles of occlusion culling
    in Unity (only Pro license) and how to use them in your projects to achieve excellent
    performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'You can open the occlusion culling editor from the Unity menu as shown in the
    following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: The main aim of the occlusion culling mechanism is sifting and filtering off
    objects that are not visible in the camera area in order to improve optimization.
    This primarily means that the objects will not be using resources, only when necessary,
    with the result that of helping you create a game or app that will work much faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Frustum culling is different from occlusion culling because it disables the
    renderers that are outside the view of the camera, but does not disable the renderers
    that overlap other renderers; for example, if a wall hides an object, it will
    be invisible for the camera. Using occlusion culling, you can automatically take
    the advantage of frustum culling. With the usage of visual occlusion culling technique,
    we can see in two examples as shown in the following screenshots:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'In the screenshot shown here, you can see occlusion culling in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_03.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: The occlusion culling process in Unity uses a virtual camera that will scan
    the entire scene and create a hierarchy of potentially visible sets of objects.
    Then, this information will be used by other cameras in your game or in your application
    in real time, in order to reduce the number of draw calls and to improve your
    performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In order to use occlusion culling, you need to set the **Occluder Static** tag
    for each object in the scene to be processed by this optimization mechanism. Also,
    you can use another object's tag, which is called **Occludee Static** as shown
    in the next screenshot. Occludees may be obscured by other objects and will be
    disabled in a similar situation to improve performance, but these objects cannot
    overlap other objects. Therefore, they will increase the performance of your entire
    project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_04.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also very important to create areas for occlusion culling, only where
    the camera will render objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We just opened the basic and key aspects of the optimization by occlusion culling
    approach. We cannot describe all the details of the settings and features in this
    chapter. The following sections describe the various ideas, methods, approaches,
    and ways to optimize and improve performance. The purpose of the next section
    is to direct you on the right path to improve performance. You will use the desired
    optimization techniques from this chapter, and if it is necessary, you can find
    more detailed information about methods, implementations, and customizations from
    the web. Let's now consider another optimization technique known as **Level Of
    Detail** (**LOD**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing by LOD
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LOD optimization technique is a method of reducing the complexity of frame
    rendering by reducing the total number of polygons, textures, and other resources
    in the scene, the general decline in its complexity. A simple example is that
    the main character model consists of 10,000 polygons. In cases where the treated
    stage is located close to the camera, it is important to use all the polygons.
    However, at a great distance from the camera, in the final image, it will take
    only a few pixels; there is no sense in handling all 10,000 polygons. Perhaps,
    in this case, it would be enough for hundreds of polygons, or even a couple of
    pieces and textures, specially prepared for about the same display model. Accordingly,
    at intermediate distances, it makes sense to use a model consisting of a number
    of triangles greater than the simplest model and smaller than the most complex.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The LOD method is commonly used for modeling and rendering three-dimensional
    scenes using multiple difficulty levels (geometric or some other) for the objects
    in proportion to their distance from the camera. Changing complexity, particularly
    in the number of triangles in the model may be performed automatically, is based
    on a three-dimensional model of highest complexity, but can be on the basis of
    several predefined patterns with different levels of detail. Using a model with
    less detail for different distances, you will reduce rendering design complexity,
    almost without compromising the overall image detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The method is particularly effective when the number of objects in the scene
    is large, and they are located at different distances from the camera. For example,
    consider a sports game, such as football game or a hockey simulator. Low-poly
    character models are used when they are away from the camera, but when it approaches,
    the models are replaced by a large number of polygons. This example is very simple,
    and it shows that the essence of the method is based on two levels of detail of
    the model, but no one bothers to create multiple levels of detail. In order to
    effect change, the LOD level was not too obvious, so the object detail gradually
    grows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following factors that have an effect on the level of detail technique:
    the total number of objects on the screen (when one or two characters in the frame,
    use complex models, and when 10–20, they are switched to a simpler model) or the
    FPS (predetermined limited values of the FPS, which varies with the level of detail,
    such as FPS below 30 reduces the complexity of the models on the screen, while
    60 FPS raises the complexity). Other possible factors that affect the level of
    detail are as follows: the speed of movement of the object (in case of a rocket
    in motion you see it moving fast, but a snail moves slowly), the importance of
    a character from the game''s point of view (for example, in football, the player
    models you see the closest and most often uses more complex geometry and texture).
    It all depends on the desires and capabilities of a particular developer. The
    main thing is to not overdo it; frequent and noticeable changes in the level of
    detail will be annoying.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to remind you that the level of detail does not necessarily refer only
    to the geometry. The method can also be used to save other resources: texturing
    (although GPUs use mipmapping, sometimes it makes sense to change the texture
    on the fly on the other with some detail), lighting technician (close objects
    covered by a complex algorithm, and distant objects covered by a prime), and texturing
    techniques.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Unity C# and Unity JS optimization tips and tricks
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, we will consider some aspects of optimization concerning the JavaScript
    programming language. Try to avoid the use of dynamic typing in JavaScript. The
    best solution for your performance is undoubtedly static typing. The use of dynamic
    typing of variables will be consumed while executing a code to find the appropriate
    data type for a particular variable, which in principle could and should be avoided
    by specifying the data types for all your variables. Bad and good examples are
    shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following example shows what you should not do if you want to improve your
    performance. This example uses dynamic typing for our variable, `yourVariableName`,
    which in turn affects the performance of the whole system in the negative sense.
    Before calling any function of this object, there will be time spent searching
    for the right object type and checking if the called function is accessible. The
    bad example is shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of wasting CPU time on unnecessary expenses, you should always use
    static typing for all your variables in order to improve performance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Use Static Typing instead of Dynamic Typing wherever possible**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: You can use `#pragma` strict preprocessor directive in order to help you not
    to forget about using static typing instead of dynamic typing everywhere in your
    JavaScript script. You should write this directive at the top of your script before
    any code. In the event of utilizing `#pragma` strict and dynamic typing in your
    script, the compiler will throw errors. Therefore, this preprocessor directive
    forces you to use static typing only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to mention the other techniques to optimize your code. One of
    them is the technique of caching components or variables. During optimization,
    you first need to turn your attention to the functions that are very often performed
    in your code, especially callbacks such as `Update` and `FixedUpdate` and similar
    functions that are called in every frame, or almost each frame, or in other words,
    many times per second. Therefore, reference to any component or variable in such
    risky functions depends on the situation. Of course, there are situations for
    the overall system performance, where such things are not so bad for your performance
    in general, and there are situations where performance drops almost to zero because
    of the many unnecessary expenses. In such functions, it is best not to call the
    Unity method `GetComponent` each time, which will very often look for a component
    or other similar functions of the Unity library to find objects and so on. Instead,
    you can call the function you want, when it is necessary to obtain a desired component
    or desired object(s) and store them in local variables or arrays, as you like.
    The following examples demonstrate this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code shown in the second example is much faster then the respective code
    in the first example, because Unity will not look up the transform component each
    `Update` cycle or in other words each frame.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should call a function only if necessary, not more and not less, just exactly
    when needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The best optimization for your code and generally for the whole system is when
    the code is as small as possible, or rather when nothing unnecessary is executed
    at all. Unnecessary calculations lead to unnecessary overhead; for mobile devices,
    in general, this question is one of the most acute. A good example of a small
    optimization is shown in the following example, but this example is not the best
    solution for your performance. After each frame, checking the distance between
    the two points will take away your precious time:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To not waste time on unnecessary mistakes, you should use the `OnBecameInvisible`
    and `OnBecameVisible` callbacks. With these callbacks, Unity calls in an event
    in which none of the cameras can see (for `OnBecameInvisible`) or at least one
    camera sees (for `OnBecameVisible`) your renderer. Certainly, these callbacks
    are only good in certain situations and not in others. For example, if your object
    does not contain a renderer component, then you will need to invent a way to enable
    or disable the execution of your code accordingly. A simple example of these two
    callbacks is shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To achieve the performance that you need, you will need to take care of many
    details in your code and many other details that are discussed in this book. Code
    optimization in most cases impedes readability and therefore impedes understanding
    of the code. Keep this in mind, or at least do not forget about it. Like everything
    else in life, we need to find a middle ground or, in other words, the golden balance
    between quality and performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how static functions behave and how much time we need for them, since
    the use of these functions significantly reduces the time of the function call
    as compared to call a non-static function. If we examine the question of what
    happens with static functions when you compile your code, it is, however, no secret
    that all the code is translated into machine code or assembler as it is called,
    which is the lowest programming level. If we consider the very assembly instructions
    to call static functions, we see that it requires fewer machine instructions and
    consequently less CPU time than calling a nonstatic function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: In the call, each function with parameters passed by value requires memory duplication.
    As discussed earlier in text, this may impair your performance. Therefore, it
    is better to call a function with parameters passed by reference rather than by
    value. It is easy to bypass this problem. The best thing for enhancing your performance
    is to use local variables of a class or object that is used in the function. You
    can create a set of variables within a function, which in turn will significantly
    increase the consumption of memory and CPU time of the function call with a lot
    of variables. The function must be remembered in the stack for further opportunities
    to work with these variables. Even if these variables are not used in the function,
    they are still in the stack and they will occupy memory space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The following discussion focuses on the constants. Constants do not require
    RAM allocation, since their values are directly sewed in the instruction stream.
    Using constants instead of creating a large number of local or global variables
    can significantly accelerate the performance of your software, avoiding the overhead
    of memory and CPU time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Static variables (variables of a class) as well as static functions (methods
    of a class) require less CPU time, since static variables belong to the whole
    class, rather than to an object of this class. The time spent on searching for
    supplies is declining, which has obvious advantages in optimization. For variables
    or functions of any object machine, instructions will be executed to locate the
    appropriate object to which they belong, which obviously require the overhead
    of CPU time and memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` and `switch` statements can be easily changed for each other; for
    example, to increase the understanding and readability of the code or to optimize
    all the same code. If you look at the postcompilation machine instructions and
    directions through any disassembler, you can see the difference between these
    two expressions. The `switch` statement**,** for example, after compiling becomes
    ago-to mechanism, which in turn makes jumping through machine instructions in
    its transition table. It needs to find the desired transition in the first place,
    and then those going to the command assembly. If construction behaves low bit
    differently, it turns normal branching as in high-level programming language;
    for example, in our case, the C# language. In some cases, some `switch` design
    may be executed faster than the same `if`/`else if`/`else` design. Performance
    of these two structures solely depends on their correct application or in other
    words the correct use. For example, let''s consider two simple cases, where in
    the first case will be quicker and faster `switch`, and in the second situation
    the `if` design is better for performance than a `switch` solution, as shown in
    the following code example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing the first example in the
    Unity editor the results were:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Based on the preceding results, we can say that the design of `switch` affects
    your performance better, but it is not always true. Let''s now consider the second
    case, where the `if` construction turns out to be the best design solution for
    your optimization, as shown in code example here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On a Mac OS X, Intel Core i5 2.7 GHz, after testing the second example in the
    Unity editor, the results were:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since different situations require different designs, the most important thing
    is for you to understand the true meaning of what is happening in the construction
    machine after compiling your code. Then, it will be much easier to make the right
    choices to improve and enhance your performance. In both examples, discussed earlier,
    we saw that in different situations the `if` and `switch` designs, which at first
    sight are absolutely equivalent, may differ in speed and efficiency with respect
    to performance. We also saw that different situations give a performance advantage
    with different designs, although they have the same semantics, or in other words,
    the same algorithm designed in different forms. However, the meaning does not
    change when dealing with any problems, except for the time of execution, as we
    have already considered earlier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two-dimensional arrays can be used in the form of one-dimensional
    arrays, and this will increase your performance. For example, we have a two-dimensional
    array with **N** rows and **M** of columns: the table size is N × M:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the case of optimization of the two-dimensional array by switching it to
    the one-dimensional array, we can refer to an element (i, j) of our table with
    the size N × M as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a complete sample code in Unity C# as shown in the following code example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see a difference in the implementation of the same ideas, but in
    different forms as two-dimensional and one-dimensional arrays. Also consider the
    next simple example code as shown here, which shows a two-level array in comparison
    with one-dimensional arrays for speed of execution:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For convenience, you can use the two-level array if you are satisfied with its
    performance. You will need to make the right decision starting from your tasks,
    not forgetting about the middle ground between the readability of the code and
    its performance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'As for strings and character arrays, let''s see which among them is faster
    and more efficient. In the following code example, we represent our test performance
    between the two variables:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The difference is obvious, but readability of this optimization falls down
    rapidly. As always everything in life needs a strong balance sheet or, in other
    words, the golden mean. Here is another example, in which we compare the performance
    of `StringBuilder` and character array as shown in the following code example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`StringBuilder` is slightly inferior to the performance of a character array.
    However, do not forget that for the garbage collector, `StringBuilder` is very
    well optimized and does not create a memory leak with large volumes of data. You
    have to solve various problems in the course of software development. If every
    decision will confidently and firmly take any criticism, then success is not far
    away. You should definitely prioritize your tasks for all to see where you need
    to go with compromises.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we will examine and study the performance of collections
    in C#. Collection is very useful in certain situations, but you always have to
    remember that it is a wrapper for ordinary arrays. When using large data, collections
    can utilize significant costs of processing time, which in turn negatively affects
    the whole performance of your code. In the following code example, a list collection
    execution speed is compared with the conventional one-dimensional array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As can be seen from the results discussed earlier in the text, the list collection
    is significantly inferior in performance compared to simple one-dimensional arrays.
    Next, as shown in the following code example, the performance of the `ArrayList`
    class is compared with the same simple one-dimensional array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The difference is awesome and more than in the previous example, while using
    the class `List`. Thus, we demonstrated the obvious advantages of a simple one-dimensional
    array, compared with collections when large amounts of data can greatly ruin your
    performance. What cannot be said about the simple one-dimensional arrays is which
    of them are the building blocks for a variety of collections. As always, the choice
    is yours. The most important thing is not to forget the basic axioms in optimization
    decisions. Let''s look at another example with the class `Dictionary` as shown
    in code example here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, I want to show you the following code example using the `Hashtable` collection
    for our performance testing, as shown in code example here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor, the following results were obtained:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, all the collections are significantly inferior to the simple
    one-dimensional array in performance, but the benefit in many situations is more
    convenient because of the use of a more readable code. However, you lose a lot
    of CPU time and memory, and have to sacrifice clarity of code. The rest of the
    collection and all other constructions you are interested in, you can easily perform
    your own tests for your system's performance, on the basis of the examples discussed
    earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not leave without attention on loops that are used very often in code-like
    branching structure. Loops `for`, `while`, and `do`-`while` are the fastest compared
    to other cycles such as `foreach`. Another trick when using loops is that we can
    deploy loops for fewer passes as shown in code example here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results are obtained:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The results speak for themselves. So, do not forget about optimizing your loops.
    The first step is to draw attention to the cycles with a huge number of passes,
    since they can lower your performance by several orders of magnitude. Before optimizing
    anything, you need to find the bottlenecks in your code and only then decide which
    optimization techniques you prefer or require.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the loop `foreach`, we recommend that you use this cycle only in exceptional
    situations. Let''s look at a small sample code for each loop, and the next step
    as it is transformed into a completely different code loop. The next example shows
    a simple `foreach` loop:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let''s look at what happens to a piece of code **foreach** loop. As we
    can see in the code example here, our cycle turns into a loop while using the
    enumerator object. The code is given here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As for the characters, it is better to use a single character than a string
    consisting of a single character. A symbol is passed by value, and it is necessary
    and requires only two bytes of memory, while the string with one character requires
    more than 20 bytes of memory, since the string is passed by reference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'I would also like to mention the `ToString` function that is best used only
    when necessary, otherwise you risk degrading your performance. For example, using
    this function for characters is not always exact: there is rarely a decision justified.
    Generally, you should remember one simple and most important axiom of code optimization—with
    less code executed, less CPU time and memory is used that significantly improves
    your productivity. Let''s look at a simple code example shown here, which covers
    one of the simplest options for optimizing the transfer of an integer to a string:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz after testing this example in the Unity
    editor I got the following results:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Try to build your own tests for your functions on the basis of the preceding
    examples. In optimization, you should often trust your own instincts to find the
    cause of all ills, but to make the right decisions you need to rely on the results
    of the tests, that is, just pure mathematics and well-defined numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Unity C# code into Unity JavaScript code and vice versa
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of how easy it is to convert your Unity C# code
    to Unity JavaScript code and vice versa. You can find on the web a lot of different
    automatic tools that you can use for free in order get conversation between Unity
    Scripts done as early as possible. As an example, you can convert Unity JS to
    Unity C# on this [http://www.m2h.nl/files/js_to_c.php](http://www.m2h.nl/files/js_to_c.php).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript variables and types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the Unity JS code variables are public and visible in Unity Inspector.
    In order to hide your variables from Unity inspector or from other classes, you
    should mark all those variables with a `private` keyword as shown in the following
    simple examples:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: C# variables and types
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Float values in C# must have a lowercase **f** or an uppercase **F** at the
    end. Otherwise, it will be treated as a double value. Also notice that in JS code,
    the string type should be written with the first letter uppercase. However, in
    C# code with lowercase letters you can see our simple examples here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By default, in Unity C# code, variables are private and invisible in the Unity
    inspector. In order to show your variables in the Unity inspector, you should
    mark all these variables with the `public` keyword as shown in our previous simple
    examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Converting types in Unity JS
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following code to convert types in Unity JS:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Converting types in Unity C#
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following code to convert types in Unity C#:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Unity JS function versus Unity C# function
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code snippet shows the syntax of the code as written in Unity
    JS and Unity C#
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Unity JS return versus Unity C# return
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unity JS, you don''t need to declare return type as shown in a simple function
    example here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In Unity C#, you have to always declare a `return` type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Unity JS yielding versus Unity C# yielding
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JS yielding is quite simple, like the `return` keyword. You can just use
    yield statements without any declarations as shown in the simple example here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In C# code, you should declare the `IEnumerator` type in your method declaration
    as shown in the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Unity JS directives versus Unity C# directives
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity has a number of **script directives**, for example, `AddComponentMenu`.
    The difference in syntax is shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced different details about occlusion culling and LOD optimization
    techniques. Also, this chapter showed how to optimize Unity C# and Unity JS code.
    Finally, you saw main differences in syntax between Unity C# and Unity JS codes
    and learned how it is easy to transform between them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will explore how to enhance the quality in games and
    applications using different techniques such as physically-based shaders and global
    illumination in Unity 5\. At the end of the chapter, you will know how to optimize
    any shader code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索如何使用不同的技术，如基于物理的着色器和Unity 5中的全局照明，来提高游戏和应用程序的质量。本章结束时，你将了解如何优化任何着色器代码。
