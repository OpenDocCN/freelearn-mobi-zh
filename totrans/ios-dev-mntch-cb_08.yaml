- en: Chapter 8. Integrating iOS Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。集成 iOS 功能
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Starting phone calls
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始电话通话
- en: Sending text messages and e-mails
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送短信和电子邮件
- en: Using text messaging in our application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用短信
- en: Using e-mail messaging in our application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用电子邮件消息
- en: Managing the address book
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理地址簿
- en: Displaying contacts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示联系人
- en: Managing the calendar
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理日历
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Mobile devices offer a handful of features to the user. Creating an application
    that interacts with those features to provide a complete experience to users can
    surely be considered as an advantage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备为用户提供了一系列功能。创建一个与应用程序这些功能交互以向用户提供完整体验的应用程序当然可以被视为一种优势。
- en: 'In this chapter, we will discuss some of the most common features of iOS and
    how to integrate some or all of their functionality to our applications. We will
    see how to offer the user the ability to make telephone calls and send SMS and
    e-mails, either by using the native platform applications, or by integrating the
    native user interface in our projects. Also, we will discuss the following components:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 iOS 的一些最常见功能以及如何将它们的一些或全部功能集成到我们的应用程序中。我们将看到如何使用原生平台应用程序或通过在我们的项目中集成原生用户界面来使用户能够进行电话通话、发送短信和电子邮件。此外，我们还将讨论以下组件：
- en: '`MFMessageComposeViewController:` This controller is suitable for sending text
    (SMS) messages'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MFMessageComposeViewController:` 这个控制器适合发送文本（SMS）消息'
- en: '`MFMailComposeViewController:` This is the controller for sending e-mails with
    or without attachments'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MFMailComposeViewController:` 这是一个用于发送带或不带附件的电子邮件的控制器'
- en: '`ABAddressBook:` This is the class that provides us access to the address book
    database'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABAddressBook:` 这是一个提供我们访问地址簿数据库的类'
- en: '`ABPersonViewController:` This is the controller that displays and/or edits
    contact information from the address book'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABPersonViewController:` 这是一个显示和/或编辑地址簿中联系人信息的控制器'
- en: '`EKEventStore:` This is the class that is responsible for managing calendar
    events'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EKEventStore:` 这是一个负责管理日历事件的类'
- en: Furthermore, we will learn how to read and save contact information, how to
    display contact details, and interact with the device calendar.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将学习如何读取和保存联系人信息，如何显示联系人详细信息，以及如何与设备日历交互。
- en: Note that some of the examples in this chapter will require a device. For example,
    the simulator does not contain the messaging application. To deploy to a device,
    you will need to enroll as an iOS Developer through Apple's Developer Portal and
    obtain a commercial license of MonoTouch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，本章中的一些示例可能需要设备。例如，模拟器不包含消息应用程序。要将应用程序部署到设备，您需要通过 Apple 的开发者门户注册为 iOS 开发者，并获得
    MonoTouch 的商业许可证。
- en: Starting phone calls
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始电话通话
- en: In this recipe, we will learn how to invoke the native phone application to
    allow the user to place a call.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何调用原生电话应用程序，允许用户进行通话。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `PhoneCallApp`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `PhoneCallApp`。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The native phone application is not available on the simulator. It is only available
    on an iPhone device.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 原生电话应用程序在模拟器上不可用。它仅在 iPhone 设备上可用。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a button on the view of `MainController`, and override the `ViewDidLoad`
    method. Implement it with the following code. Replace the number with a real phone
    number, if you actually want the call to be placed:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的视图中添加一个按钮，并重写 `ViewDidLoad` 方法。使用以下代码实现它。如果您实际上想要拨打电话，请将数字替换为真实的电话号码：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compile and run the application on the device. Tap the **Call!** button to
    start the call. The following screenshot shows the phone application placing a
    call:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击 **Call!** 按钮开始通话。以下截图显示了电话应用程序正在拨打电话：
- en: '![How to do it...](img/1468EXP_08_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_08_01.jpg)'
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Through the `UIApplication.SharedApplication` static property, we have access
    to the application''s `UIApplication` object. We can use its `OpenUrl` method,
    which accepts an `NSUrl` variable to initiate a call:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `UIApplication.SharedApplication` 静态属性，我们可以访问应用程序的 `UIApplication` 对象。我们可以使用它的
    `OpenUrl` 方法，该方法接受一个 `NSUrl` 变量来发起通话：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since not all iOS devices support the native phone application, it would be
    useful to check for availability first:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于并非所有 iOS 设备都支持原生电话应用程序，因此首先检查其可用性将是有用的：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the `OpenUrl` method is called, the native phone application will be executed,
    and it will start calling the number immediately. Note that the `tel:` prefix
    is needed to initiate the call.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `OpenUrl` 方法时，原生电话应用将被执行，并且它将立即开始拨打电话。请注意，需要 `tel:` 前缀来发起通话。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'MonoTouch also supports the `CoreTelephony` framework, through the `MonoTouch.CoreTelephony`
    namespace. This is a simple framework that provides information on call state,
    connection, carrier info, and so on. Note that when a call starts, the native
    phone application enters into the foreground, causing the application to be suspended.
    The following is a simple usage of the `CoreTelephony` framework:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch 也支持 `CoreTelephony` 框架，通过 `MonoTouch.CoreTelephony` 命名空间。这是一个简单的框架，提供了有关通话状态、连接、运营商信息等方面的信息。请注意，当通话开始时，原生电话应用进入前台，导致应用挂起。以下是对
    `CoreTelephony` 框架的简单使用：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the handler is assigned with an equals sign (=) instead of the common
    plus-equals (+=) combination. This is because `CallEventHandler` is a property
    and not an event. When the application enters into the background, events are
    not distributed to it. Only the last occured event will be distributed when the
    application returns to the foreground.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，处理程序是用等号（=）而不是常见的加等号（+=）组合赋值的。这是因为 `CallEventHandler` 是一个属性而不是一个事件。当应用进入后台时，事件不会分配给它。当应用返回前台时，只有最后发生的事件会被分配。
- en: More info on OpenUrl
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于 OpenUrl 的更多信息
- en: 'The `OpenUrl` method can be used to open various native and non-native applications.
    For example, to open a web page in Safari, just create an `NSUrl` object with
    the following link:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenUrl` 方法可以用来打开各种原生和非原生应用。例如，要在 Safari 中打开网页，只需创建一个包含以下链接的 `NSUrl` 对象：'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关链接
- en: 'In this chapter:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容：
- en: '*Sending text messages and e-mails*'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*发送短信和电子邮件*'
- en: Sending text messages and e-mails
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送短信和电子邮件
- en: In this recipe, we will learn how to invoke the native mail and messaging applications
    within our own application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在我们的应用中调用原生邮件和消息应用。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `SendTextApp`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `SendTextApp`。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add two buttons on the main view of `MainController`. Override the `ViewDidLoad`
    method of the `MainController` class, and implement it with the following code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的主视图中添加两个按钮。覆盖 `MainController` 类的 `ViewDidLoad` 方法，并使用以下代码实现：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Compile and run the application on the device. Tap on one of the buttons to
    open the corresponding application.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击其中一个按钮以打开相应的应用。
- en: How it works...
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Once again, using the `OpenUrl` method, we can send text or e-mail messages.
    In this example code, just using the `sms:` prefix will open the native text messaging
    application. Adding a cell phone number after the `sms:` prefix will open the
    native messaging application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `OpenUrl` 方法，我们可以发送文本或电子邮件消息。在这个示例代码中，只需使用 `sms:` 前缀就会打开原生短信应用。在 `sms:`
    前缀后添加手机号码将打开原生消息应用：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How it works...](img/1468EXP_08_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_08_02.jpg)'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apart from the recipient number, there is no other data that can be set before
    the native text message application is displayed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了收件人号码外，在显示原生短信应用之前，没有其他数据可以设置。
- en: For opening the native e-mail application, the process is similar. Passing the
    `mailto:` prefix opens the edit mail controller.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于打开原生电子邮件应用，过程类似。传递 `mailto:` 前缀将打开编辑邮件控制器。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![How it works...](img/1468EXP_08_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_08_03.jpg)'
- en: 'The `mailto:` url scheme supports various parameters for customizing an e-mail
    message. These parameters allows us to enter sender address, subject, and message:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`mailto:` URL 方案支持各种参数来定制电子邮件消息。这些参数允许我们输入发送者地址、主题和消息：'
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Although iOS provides access to opening the native messaging applications, pre-defining
    message content in the case of e-mails, this is where the control from inside
    the application stops. There is no way of actually sending the message through
    code. It is the user that will decide whether to send the message or not.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然iOS提供了打开原生消息应用的方法，但在电子邮件的情况下，预先定义消息内容，这里的控制从应用内部停止。实际上通过代码发送消息是没有办法的。是否发送消息将由用户决定。
- en: More info on opening external applications
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于打开外部应用的更多信息
- en: 'The `OpenUrl` method provides an interface for opening the native messaging
    applications. Opening external applications has one drawback: the application
    that calls the `OpenUrl` method transitions to the background. Up to iOS version
    3.*, this was the only way of providing messaging through an application. Since
    iOS version 4.0, Apple has provided the messaging controllers to the SDK. The
    following recipes discuss their usage.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenUrl`方法提供了一个打开原生消息应用程序的接口。打开外部应用程序有一个缺点：调用`OpenUrl`方法的程序会转到后台。在iOS版本3.*之前，这是通过应用程序提供消息的唯一方式。从iOS版本4.0开始，Apple向SDK提供了消息控制器。以下菜谱讨论了它们的用法。'
- en: See also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Starting phone calls*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开始电话*'
- en: '*Using text messaging in our application*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在我们的应用程序中使用文本消息*'
- en: Using text messaging in our application
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用文本消息
- en: In this recipe, we will learn how to provide text messaging functionality within
    our application using the native messaging user interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在我们的应用程序中使用原生消息用户界面提供文本消息功能。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `TextMessageApp`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`TextMessageApp`。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add a button on the view of `MainController`. Enter the following using directive
    in the `MainController.cs` file:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加一个按钮。在`MainController.cs`文件中输入以下指令：
- en: '[PRE9]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement the `ViewDidLoad` method with the following code, changing the recipient
    number and/or the message body at your discretion:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现`ViewDidLoad`方法，根据您的意愿更改接收者号码和/或消息正文：
- en: '[PRE10]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following nested class:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下嵌套类：
- en: '[PRE11]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Compile and run the application on the device.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Tap the **Send message** button to open the message controller. Tap the **Send**
    button to send the message, or the **Cancel** button to return to the application.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送消息**按钮以打开消息控制器。点击**发送**按钮发送消息，或点击**取消**按钮返回应用程序。
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.MessageUI` namespace contains the necessary UI elements that
    allow us to implement messaging in an iOS application. For text messaging (SMS),
    we need the `MFMessageComposeViewController` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.MessageUI`命名空间包含允许我们在iOS应用程序中实现消息的必要UI元素。对于文本消息（SMS），我们需要`MFMessageComposeViewController`类。'
- en: 'Only the iPhone is capable of sending text messages out of the box. With iOS
    5, both the iPod and the iPad can send text messages, but the user might not have
    enabled this feature on the device. For this reason, checking for availability
    is the best practice. The `MFMessageComposeViewController` class contains a static
    method, named `CanSendText`, which returns a boolean value indicating whether
    we can use this functionality. The important thing in this case is that we should
    check if sending text messages is available prior to initializing the controller.
    This is because when you try to initialize the controller on a device that does
    not support text messaging, or the simulator, you will get the following message
    on the screen:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 只有iPhone能够直接发送短信。在iOS 5中，iPod和iPad也可以发送短信，但用户可能没有在设备上启用此功能。因此，检查可用性是最佳实践。《MFMessageComposeViewController》类包含一个名为`CanSendText`的静态方法，它返回一个布尔值，指示我们是否可以使用此功能。在这种情况下，重要的是我们应该在初始化控制器之前检查发送短信是否可用。这是因为当你在不支持短信的设备或模拟器上尝试初始化控制器时，你将在屏幕上看到以下消息：
- en: '![How it works...](img/1468EXP_08_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/1468EXP_08_04.jpg)'
- en: 'To determine when the user has taken action in the message UI, we implement
    a `Delegate` object and override the `Finished` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定用户在消息UI中采取了哪些操作，我们实现一个`Delegate`对象并重写`Finished`方法：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Another option, provided by MonoTouch, is to subscribe to the `Finished` event
    of the `MFMessageComposeViewController` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: MonoTouch提供的另一个选项是订阅`MFMessageComposeViewController`类的`Finished`事件。
- en: 'Inside the `Finished` method, we can provide functionality according to the
    `MessageComposeResult` parameter. Its value can be one of the following three:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Finished`方法中，我们可以根据`MessageComposeResult`参数提供功能。它的值可以是以下三个之一：
- en: '`Sent:` This value indicates that the message was sent successfully.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sent:` 这个值表示消息已成功发送。'
- en: '`Cancelled:` This value indicates that the user has tapped the **Cancel** button,
    and the message will not be sent.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cancelled:` 这个值表示用户点击了**取消**按钮，消息将不会发送。'
- en: '`Failed:` This value indicates that message sending failed.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Failed:` 这个值表示消息发送失败。'
- en: 'The last thing to do is to dismiss the message controller, which is done as
    follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是取消消息控制器，操作如下：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After initializing the controller, we can set the recipients and body message
    to the appropriate properties:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化控制器后，我们可以将收件人和正文消息设置到相应的属性中：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Recipients` property accepts a string array that allows for multiple recipient
    numbers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recipients`属性接受一个字符串数组，允许有多个收件人号码。'
- en: You may have noticed that the `Delegate` object for the message controller is
    set to its `MessageComposeDelegate` property, instead of the common `Delegate`.
    This is because the `MFMessageComposeViewController` class directly inherits from
    the `UINavigationController` class, so the `Delegate` property accepts values
    of the type `UINavigationControllerDelegate`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，消息控制器的`Delegate`对象被设置为它的`MessageComposeDelegate`属性，而不是常见的`Delegate`。这是因为`MFMessageComposeViewController`类直接继承自`UINavigationController`类，所以`Delegate`属性接受`UINavigationControllerDelegate`类型的值。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The fact that the SDK provides the user interface to send text messages does
    not mean that it is customizable. Just like invoking the native messaging application,
    it is the user who will decide whether to send the message or discard it. In fact,
    after the controller is presented on the screen, any attempts to change the actual
    object or any of its properties will simply fail. Furthermore, the user can change
    or delete both the recipient and the message body. The real benefit though is
    that the messaging user interface is displayed within our application, instead
    of running separately.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: SDK提供了发送文本消息的用户界面，并不意味着它是可定制的。就像调用原生消息应用一样，是否发送消息或丢弃消息的决定权在用户手中。实际上，在控制器显示在屏幕上之后，任何尝试更改实际对象或其任何属性的操作都将失败。此外，用户可以更改或删除收件人和消息正文。真正的优势在于，消息用户界面是在我们的应用程序内显示的，而不是单独运行。
- en: SMS only
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅限短信
- en: The `MFMessageComposeViewController` can only be used for sending **Short Message
    Service (SMS)** messages and not **Multimedia Messaging Service (MMS)** .
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`MFMessageComposeViewController`只能用于发送**短消息服务（SMS）**消息，而不能发送**多媒体消息服务（MMS）**。'
- en: Using e-mail messaging in our application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中使用电子邮件消息
- en: In this recipe, we will learn how to use the e-mail messaging interface within
    an application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在应用程序中使用电子邮件消息界面。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `EmailMessageApp`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`EmailMessageApp`。
- en: How to do it...
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add a button on the view of `MainController` and the `MonoTouch.MessageUI` namespace
    in the `MainController.cs` file.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`的视图中添加一个按钮，并在`MainController.cs`文件中的`MonoTouch.MessageUI`命名空间中。
- en: 'Enter the following code in the `ViewDidLoad` method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中输入以下代码：
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Compile and run the application either on the simulator or on the device.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。
- en: Tap the **Send email** button to display the mail user interface. Send or cancel
    the message. The application will work on the simulator and behave just like the
    native mail application on devices, except for the fact that messages will not
    actually be sent or saved.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**发送电子邮件**按钮以显示邮件用户界面。发送或取消消息。应用程序将在模拟器上工作，并且行为与设备上的原生邮件应用相同，只是消息实际上不会发送或保存。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MFMailComposeViewController` class provides the native mail composing interface.
    To determine whether the device is capable of sending e-mails, we first check
    its `CanSendMail` property.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`MFMailComposeViewController`类提供了原生邮件编写界面。为了确定设备是否能够发送电子邮件，我们首先检查其`CanSendMail`属性。'
- en: 'Like the `MFMessageComposeViewController`, it contains a `Finished` event,
    which we use to respond to user actions, without having to implement a `Delegate`
    object. We do this inside the `MailController_Finished` method, based on the `MFComposeResultEventArgs.Result`
    property, which is of the type `MFMailComposeResult`. Its possible values will
    be one of the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与`MFMessageComposeViewController`类似，它包含一个`Finished`事件，我们使用它来响应用户操作，而无需实现`Delegate`对象。我们通过`MailController_Finished`方法来实现，基于`MFComposeResultEventArgs.Result`属性，该属性的类型为`MFMailComposeResult`。其可能的值将包括以下之一：
- en: '`Sent:` This value indicates that the e-mail message is queued for sending'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sent:` 这个值表示电子邮件消息已排队待发送'
- en: '`Saved:` This value indicates that the user tapped the **Cancel** button, and
    the **Save Draft** option of the action sheet automatically appeared'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Saved:` 这个值表示用户点击了**取消**按钮，动作表单中的**保存草稿**选项自动出现'
- en: '![How it works...](img/1468EXP_08_05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_08_05.jpg)'
- en: '`Cancelled:` This value indicates that the user tapped the **Cancel** button
    on the controller and selected the **Delete Draft** option on the action sheet'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cancelled:` 此值表示用户在控制器上点击 **取消** 按钮并在动作表中选择了 **删除草稿** 选项'
- en: '`Failed:` This value indicates that e-mail message sending failed'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Failed:` 此值表示电子邮件消息发送失败'
- en: 'After initializing the object, we can assign a recipient list, subject, and
    message body through the corresponding set of `Set` prefixed methods:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化对象之后，我们可以通过相应的 `Set` 前缀方法来分配收件人列表、主题和消息正文：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second parameter of the `SetMessageBody` message, if set to `true`, informs
    the controller that the message should be treated as HTML.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetMessageBody` 消息的第二个参数，如果设置为 `true`，则通知控制器该消息应被视为 HTML 格式。'
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Apart from simple or HTML-formatted text, we can also send attachments. We
    can do this with the `AddAttachmentData` method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的或 HTML 格式的文本外，我们还可以发送附件。我们可以使用 `AddAttachmentData` 方法来完成此操作：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first parameter is of the type `NSData` and should contain the contents
    of the attachment. In this case, we attach an image through the `UIImage.AsJPEG()`
    method, which returns the image contents inside an `NSData` object. The second
    parameter represents the **Multipurpose Internet Mail Extensions (MIME)** type
    of the attachment, and the third parameter its file name. The project's source
    code contains a full and commented example.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是 `NSData` 类型，应包含附件的内容。在这种情况下，我们通过 `UIImage.AsJPEG()` 方法附加一个图片，该方法返回一个包含在
    `NSData` 对象中的图片内容。第二个参数代表附件的 **Multipurpose Internet Mail Extensions (MIME)**
    类型，第三个参数是文件名。项目源代码包含一个完整并带有注释的示例。
- en: Action sheet for drafts
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 草稿动作表
- en: The action sheet displayed when the user taps the **Cancel** button is automatically
    handled by the `MFMailComposeViewController`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 **取消** 按钮时显示的动作表由 `MFMailComposeViewController` 自动处理。
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using text messaging in our application*'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在我们的应用程序中使用短信*'
- en: Managing the address book
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理地址簿
- en: In this recipe, we will discuss how to access and manage the user's stored contacts
    in the device's address book.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何访问和管理设备地址簿中存储的用户联系人。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Create a new project in MonoDevelop, and name it `AddressBookApp`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `AddressBookApp`。
- en: How to do it...
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Add a button on the view of `MainController`. Enter the following `using` directive
    in the `MainController.cs` file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的视图中添加一个按钮。在 `MainController.cs` 文件中输入以下 `using` 指令：
- en: '[PRE19]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Override the `ViewDidLoad` method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `ViewDidLoad` 方法：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compile and run the application on the simulator.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap the **Get contacts** button, and watch the contact's names displayed in
    MonoDevelop's **Application Output** pad.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **获取联系人** 按钮，并观察联系人名称在 MonoDevelop 的 **应用程序输出** 面板中显示。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After installation of the iOS SDK, the simulator does not contain any contacts.
    You can add contacts the same way you can do it on the device.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 iOS SDK 之后，模拟器不包含任何联系人。您可以像在设备上一样添加联系人。
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The `MonoTouch.AddressBook` namespace contains all the classes that allow us
    to manage the device''s address book. To access the data directly, we need an
    instance of the `ABAddressBook` class:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.AddressBook` 命名空间包含所有允许我们管理设备地址簿的类。要直接访问数据，我们需要 `ABAddressBook`
    类的一个实例：'
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To get all the contacts stored in the address book, we call its `GetPeople()`
    method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取地址簿中存储的所有联系人，我们调用其 `GetPeople()` 方法：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method returns an array of `ABPerson` objects, which contains all the
    information of individual contacts. To read the contacts'' details, we iterate
    over the `ABPerson` array and get each contact''s first and last names with the
    `FirstName` and `LastName` properties respectively:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个 `ABPerson` 对象数组，其中包含所有单个联系人的信息。要读取联系人的详细信息，我们遍历 `ABPerson` 数组，并使用 `FirstName`
    和 `LastName` 属性分别获取每个联系人的名和姓：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'To get a contact''s stored phone number(s), call the `GetPhones()` method:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取联系人的存储电话号码，请调用 `GetPhones()` 方法：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It returns an object of type `ABMultiValue<string>. ABMultiValue<T>` is a generic
    collection, especially designed for multiple address book values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个 `ABMultiValue<string>` 类型的对象。`ABMultiValue<T>` 是一个泛型集合，特别设计用于地址簿的多个值。
- en: Adding a phone number to a contact
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向联系人添加电话号码
- en: 'To add a phone number to a contact, we can use the `ABPerson` class'' `SetPhones`
    method. It accepts an `ABMultiValue<string>` object as its parameter, but we cannot
    add new values to `ABMultiValue` objects. We can, however, write values to an
    `ABMutableMultiValue<T>` object:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要向联系人添加电话号码，我们可以使用`ABPerson`类的`SetPhones`方法。它接受一个`ABMultiValue<string>`对象作为其参数，但我们不能向`ABMultiValue`对象添加新值。然而，我们可以将值写入`ABMutableMultiValue<T>`对象：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This line of code creates a new instance of `ABMutableMultiValue<string>` object,
    which we then use to add the phone number(s) we want:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码创建了一个新的`ABMutableMultiValue<string>`对象实例，然后我们使用它来添加我们想要的电话号码：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The second parameter of the `Add` method is the label the phone number will
    have when it is saved to the contact. It is important to call the `ABAddressBook.Save()`
    method, or else the changes will not be saved.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`方法的第二个参数是电话号码在保存到联系人时将拥有的标签。调用`ABAddressBook.Save()`方法很重要，否则更改将不会保存。'
- en: Displaying contacts
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示联系人
- en: In this recipe, we will learn how to use the native address book user interface
    to display contact information.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用原生地址簿用户界面来显示联系人信息。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `DisplayContactApp`. Add a
    button on the view of `MainController`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的项目，并将其命名为`DisplayContactApp`。在`MainController`的视图中添加一个按钮。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Create a field in the `AppDelegate` class for a `UINavigationController:`
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类中为`UINavigationController`创建一个字段：
- en: '[PRE27]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Instantiate the navigation controller, passing as its root controller an instance
    of the `MainController:`
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化导航控制器，将其根控制器传递为`MainController`的实例：
- en: '[PRE28]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Set the navigation controller as the window''s root view controller:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将导航控制器设置为窗口的根视图控制器：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Add the namespaces `MonoTouch.AddressBook` and `MonoTouch.AddressBookUI` in
    the `MainController.cs` file.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController.cs`文件中添加命名空间`MonoTouch.AddressBook`和`MonoTouch.AddressBookUI`。
- en: 'Override the `ViewDidLoad` method of the `MainController` class, and implement
    it with the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`MainController`类的`ViewDidLoad`方法，并使用以下代码实现：
- en: '[PRE30]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compile and run the application on the simulator or the device.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。
- en: Tap the **Display first contact** button to display the contact details.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**显示第一个联系人**按钮以显示联系人详细信息。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.AddressBookUI` namespace contains the controllers that the native
    `Contacts` application uses to allow the user to display and manage contacts.
    Each contact's details can be viewed with the `ABPersonViewController`. This controller
    must be presented through a `UINavigationController`, or else it will not display
    correctly.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.AddressBookUI`命名空间包含原生`Contacts`应用程序使用的控制器，允许用户显示和管理联系人。每个联系人的详细信息都可以使用`ABPersonViewController`查看。此控制器必须通过`UINavigationController`来展示，否则将无法正确显示。'
- en: 'After initializing it, we set the `ABPerson` object we want to be displayed
    to its `DisplayedPerson` property:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，我们将想要显示的`ABPerson`对象设置为其`DisplayedPerson`属性：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, we push it to the navigation controller''s stack:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其推送到导航控制器的堆栈中：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ABPersonViewController` can also be used for editing. To do this, set the
    `AllowsEditing` property to `true:`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`ABPersonViewController`也可以用于编辑。为此，将`AllowsEditing`属性设置为`true`：'
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result will be exactly the same as the native `Contacts` application:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将与原生`Contacts`应用程序完全相同：
- en: '![There''s more...](img/1468EXP_08_06.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1468EXP_08_06.jpg)'
- en: Note that changes are saved normally through the `ABPersonViewController`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，更改通常通过`ABPersonViewController`保存。
- en: Other address book controllers
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他地址簿控制器
- en: 'The `MonoTouch.AddressBookUI` namespace contains all the controllers we need
    to create our own custom contacts application:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.AddressBookUI`命名空间包含我们创建自定义联系人应用程序所需的所有控制器：'
- en: '`ABPeoplePickerNavigationController:` This is a navigation controller that
    displays the saved contacts. The user can select a contact from the list.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABPeoplePickerNavigationController`：这是一个显示已保存联系人的导航控制器。用户可以从列表中选择一个联系人。'
- en: '`ABPersonViewController` : This controller is described in the previous example.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABPersonViewController`：这个控制器在之前的示例中有描述。'
- en: '`ABNewPersonViewController:` This is the controller that creates a new contact.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABNewPersonViewController`：这是创建新联系人的控制器。'
- en: '`ABUnknownPersonViewController:` This is the controller that is displayed with
    partial data for creating a new contact. This is similar to the controller that
    is displayed when we tap on an unknown number in the list of recent calls on the
    device.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ABUnknownPersonViewController:` 这是用于创建新联系人的部分数据显示的控制器。这与我们在设备上最近通话列表中点击未知号码时显示的控制器类似。'
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Managing the address book*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理地址簿*'
- en: Managing the calendar
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理日历
- en: In this recipe, we will learn how to create an event and save it to the device's
    calendar database.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何创建一个事件并将其保存到设备的日历数据库中。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in MonoDevelop, and name it `CalendarEventsApp`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的项目，并将其命名为 `CalendarEventsApp`。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This project must be executed on a device. The native `Calendar` application
    is not installed on the simulator.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目必须在设备上执行。本机 `Calendar` 应用程序未安装在模拟器上。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add a button on the main view of the `MainController`. Add the namespace `MonoTouch.EventKit`
    in the `MainController.cs` file.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 的主视图中添加一个按钮。在 `MainController.cs` 文件中添加命名空间 `MonoTouch.EventKit`。
- en: 'Finally, enter the following code in the `ViewDidLoad` method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `ViewDidLoad` 方法中输入以下代码：
- en: '[PRE34]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and run the application on the device.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。
- en: Tap the **Display events** button to output the calendar events of the next
    30 days in the **Application Output** pad.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **显示事件** 按钮以在 **应用程序输出** 面板中输出未来 30 天的日历事件。
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `MonoTouch.EventKit` namespace is responsible for managing the calendar
    events. To read the stored events, we first initialize an `EKEventStore` object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.EventKit` 命名空间负责管理日历事件。为了读取已存储的事件，我们首先初始化一个 `EKEventStore` 对象：'
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `EKEventStore` class provides us access to the stored events. To retrieve
    the calendar events, we need a predicate of the type `NSPredicate`. We can create
    an instance through the `PredicateForEvents` method of the `EKEventStore` class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`EKEventStore` 类为我们提供了访问已存储事件的权限。要检索日历事件，我们需要一个类型为 `NSPredicate` 的谓词。我们可以通过
    `EKEventStore` 类的 `PredicateForEvents` 方法创建一个实例：'
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The two first parameters are of the type `NSDate` (which can be implicitly converted
    to `DateTime)` and represent the start and end dates for which to search events.
    The third parameter is of the type `EKCalendar[]`, and it is an array of the calendars
    to search into. To search in all the available calendars, we pass the `EKEventStore.Calendars`
    property.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数的类型为 `NSDate`（可以隐式转换为 `DateTime`），表示要搜索事件的开始和结束日期。第三个参数的类型为 `EKCalendar[]`，它是要搜索的日历数组。要搜索所有可用的日历，我们传递
    `EKEventStore.Calendars` 属性。
- en: 'Finally, we call the `EnumerateEvents` method:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 `EnumerateEvents` 方法：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We pass the predicate we created earlier to the first parameter. The second
    parameter is a delegate of type `EKEventSearchCallback`. To read each event's
    data, we use its `EKEvent` object. Note that the process of enumerating calendar
    events is similar to the one that is used for enumerating assets from the assets
    library, as discussed in the previous chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前创建的谓词传递给第一个参数。第二个参数是类型为 `EKEventSearchCallback` 的委托。为了读取每个事件的数据，我们使用其 `EKEvent`
    对象。请注意，枚举日历事件的过程与在上一章中讨论的从资产库枚举资产的过程类似。
- en: There's more...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: 'As well as enumerating events, the `EKEventStore` allows us to create new ones.
    The following example creates and saves a new calendar event:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了枚举事件外，`EKEventStore` 允许我们创建新的事件。以下示例创建并保存了一个新的日历事件：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For creating a new `EKEvent` instance, we use the `EKEvent.FromStore` static
    method. We then set a start and end date, a title, and the calendar to which the
    event will be stored. Here, we use the default calendar that we can get with the
    `DefaultCalendarForNewEvents` property of `EKEventStore`. When we have everything
    set up, we call the `SaveEvent` method to save it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个新的 `EKEvent` 实例，我们使用 `EKEvent.FromStore` 静态方法。然后我们设置开始和结束日期、标题以及事件将要存储的日历。在这里，我们使用
    `EKEventStore.DefaultCalendarForNewEvents` 属性可以获取的默认日历。当一切设置完毕后，我们调用 `SaveEvent`
    方法来保存它。
- en: Info on calendars
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于日历的信息
- en: 'By default, the device has two calendars set up: `Home` and `Work`. Although
    we cannot create new calendars on the device, new calendars that are created on
    the computer that we use to synchronize the device are automatically added when
    syncing.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，设备已设置两个日历：`Home` 和 `Work`。尽管我们无法在设备上创建新日历，但我们在用于同步设备的计算机上创建的新日历在同步时将自动添加。
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this book:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 7](ch07.html "Chapter 7. Multimedia Resources"),Multimedia Resources:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章. 多媒体资源"), 多媒体资源：'
- en: '*Managing album items directly*'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接管理专辑项目*'
