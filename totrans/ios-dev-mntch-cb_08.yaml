- en: Chapter 8. Integrating iOS Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting phone calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending text messages and e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using text messaging in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using e-mail messaging in our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the address book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the calendar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile devices offer a handful of features to the user. Creating an application
    that interacts with those features to provide a complete experience to users can
    surely be considered as an advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss some of the most common features of iOS and
    how to integrate some or all of their functionality to our applications. We will
    see how to offer the user the ability to make telephone calls and send SMS and
    e-mails, either by using the native platform applications, or by integrating the
    native user interface in our projects. Also, we will discuss the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MFMessageComposeViewController:` This controller is suitable for sending text
    (SMS) messages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MFMailComposeViewController:` This is the controller for sending e-mails with
    or without attachments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABAddressBook:` This is the class that provides us access to the address book
    database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABPersonViewController:` This is the controller that displays and/or edits
    contact information from the address book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EKEventStore:` This is the class that is responsible for managing calendar
    events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, we will learn how to read and save contact information, how to
    display contact details, and interact with the device calendar.
  prefs: []
  type: TYPE_NORMAL
- en: Note that some of the examples in this chapter will require a device. For example,
    the simulator does not contain the messaging application. To deploy to a device,
    you will need to enroll as an iOS Developer through Apple's Developer Portal and
    obtain a commercial license of MonoTouch.
  prefs: []
  type: TYPE_NORMAL
- en: Starting phone calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to invoke the native phone application to
    allow the user to place a call.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `PhoneCallApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The native phone application is not available on the simulator. It is only available
    on an iPhone device.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a button on the view of `MainController`, and override the `ViewDidLoad`
    method. Implement it with the following code. Replace the number with a real phone
    number, if you actually want the call to be placed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compile and run the application on the device. Tap the **Call!** button to
    start the call. The following screenshot shows the phone application placing a
    call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1468EXP_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Through the `UIApplication.SharedApplication` static property, we have access
    to the application''s `UIApplication` object. We can use its `OpenUrl` method,
    which accepts an `NSUrl` variable to initiate a call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since not all iOS devices support the native phone application, it would be
    useful to check for availability first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the `OpenUrl` method is called, the native phone application will be executed,
    and it will start calling the number immediately. Note that the `tel:` prefix
    is needed to initiate the call.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MonoTouch also supports the `CoreTelephony` framework, through the `MonoTouch.CoreTelephony`
    namespace. This is a simple framework that provides information on call state,
    connection, carrier info, and so on. Note that when a call starts, the native
    phone application enters into the foreground, causing the application to be suspended.
    The following is a simple usage of the `CoreTelephony` framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the handler is assigned with an equals sign (=) instead of the common
    plus-equals (+=) combination. This is because `CallEventHandler` is a property
    and not an event. When the application enters into the background, events are
    not distributed to it. Only the last occured event will be distributed when the
    application returns to the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: More info on OpenUrl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `OpenUrl` method can be used to open various native and non-native applications.
    For example, to open a web page in Safari, just create an `NSUrl` object with
    the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sending text messages and e-mails*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending text messages and e-mails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to invoke the native mail and messaging applications
    within our own application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `SendTextApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add two buttons on the main view of `MainController`. Override the `ViewDidLoad`
    method of the `MainController` class, and implement it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device. Tap on one of the buttons to
    open the corresponding application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, using the `OpenUrl` method, we can send text or e-mail messages.
    In this example code, just using the `sms:` prefix will open the native text messaging
    application. Adding a cell phone number after the `sms:` prefix will open the
    native messaging application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/1468EXP_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from the recipient number, there is no other data that can be set before
    the native text message application is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: For opening the native e-mail application, the process is similar. Passing the
    `mailto:` prefix opens the edit mail controller.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![How it works...](img/1468EXP_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `mailto:` url scheme supports various parameters for customizing an e-mail
    message. These parameters allows us to enter sender address, subject, and message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although iOS provides access to opening the native messaging applications, pre-defining
    message content in the case of e-mails, this is where the control from inside
    the application stops. There is no way of actually sending the message through
    code. It is the user that will decide whether to send the message or not.
  prefs: []
  type: TYPE_NORMAL
- en: More info on opening external applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `OpenUrl` method provides an interface for opening the native messaging
    applications. Opening external applications has one drawback: the application
    that calls the `OpenUrl` method transitions to the background. Up to iOS version
    3.*, this was the only way of providing messaging through an application. Since
    iOS version 4.0, Apple has provided the messaging controllers to the SDK. The
    following recipes discuss their usage.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Starting phone calls*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using text messaging in our application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using text messaging in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to provide text messaging functionality within
    our application using the native messaging user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `TextMessageApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a button on the view of `MainController`. Enter the following using directive
    in the `MainController.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `ViewDidLoad` method with the following code, changing the recipient
    number and/or the message body at your discretion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following nested class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Send message** button to open the message controller. Tap the **Send**
    button to send the message, or the **Cancel** button to return to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.MessageUI` namespace contains the necessary UI elements that
    allow us to implement messaging in an iOS application. For text messaging (SMS),
    we need the `MFMessageComposeViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the iPhone is capable of sending text messages out of the box. With iOS
    5, both the iPod and the iPad can send text messages, but the user might not have
    enabled this feature on the device. For this reason, checking for availability
    is the best practice. The `MFMessageComposeViewController` class contains a static
    method, named `CanSendText`, which returns a boolean value indicating whether
    we can use this functionality. The important thing in this case is that we should
    check if sending text messages is available prior to initializing the controller.
    This is because when you try to initialize the controller on a device that does
    not support text messaging, or the simulator, you will get the following message
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1468EXP_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To determine when the user has taken action in the message UI, we implement
    a `Delegate` object and override the `Finished` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Another option, provided by MonoTouch, is to subscribe to the `Finished` event
    of the `MFMessageComposeViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Finished` method, we can provide functionality according to the
    `MessageComposeResult` parameter. Its value can be one of the following three:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sent:` This value indicates that the message was sent successfully.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Cancelled:` This value indicates that the user has tapped the **Cancel** button,
    and the message will not be sent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Failed:` This value indicates that message sending failed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last thing to do is to dismiss the message controller, which is done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing the controller, we can set the recipients and body message
    to the appropriate properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `Recipients` property accepts a string array that allows for multiple recipient
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the `Delegate` object for the message controller is
    set to its `MessageComposeDelegate` property, instead of the common `Delegate`.
    This is because the `MFMessageComposeViewController` class directly inherits from
    the `UINavigationController` class, so the `Delegate` property accepts values
    of the type `UINavigationControllerDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fact that the SDK provides the user interface to send text messages does
    not mean that it is customizable. Just like invoking the native messaging application,
    it is the user who will decide whether to send the message or discard it. In fact,
    after the controller is presented on the screen, any attempts to change the actual
    object or any of its properties will simply fail. Furthermore, the user can change
    or delete both the recipient and the message body. The real benefit though is
    that the messaging user interface is displayed within our application, instead
    of running separately.
  prefs: []
  type: TYPE_NORMAL
- en: SMS only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MFMessageComposeViewController` can only be used for sending **Short Message
    Service (SMS)** messages and not **Multimedia Messaging Service (MMS)** .
  prefs: []
  type: TYPE_NORMAL
- en: Using e-mail messaging in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the e-mail messaging interface within
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `EmailMessageApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a button on the view of `MainController` and the `MonoTouch.MessageUI` namespace
    in the `MainController.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application either on the simulator or on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Send email** button to display the mail user interface. Send or cancel
    the message. The application will work on the simulator and behave just like the
    native mail application on devices, except for the fact that messages will not
    actually be sent or saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MFMailComposeViewController` class provides the native mail composing interface.
    To determine whether the device is capable of sending e-mails, we first check
    its `CanSendMail` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `MFMessageComposeViewController`, it contains a `Finished` event,
    which we use to respond to user actions, without having to implement a `Delegate`
    object. We do this inside the `MailController_Finished` method, based on the `MFComposeResultEventArgs.Result`
    property, which is of the type `MFMailComposeResult`. Its possible values will
    be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sent:` This value indicates that the e-mail message is queued for sending'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Saved:` This value indicates that the user tapped the **Cancel** button, and
    the **Save Draft** option of the action sheet automatically appeared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How it works...](img/1468EXP_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Cancelled:` This value indicates that the user tapped the **Cancel** button
    on the controller and selected the **Delete Draft** option on the action sheet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed:` This value indicates that e-mail message sending failed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After initializing the object, we can assign a recipient list, subject, and
    message body through the corresponding set of `Set` prefixed methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter of the `SetMessageBody` message, if set to `true`, informs
    the controller that the message should be treated as HTML.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from simple or HTML-formatted text, we can also send attachments. We
    can do this with the `AddAttachmentData` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is of the type `NSData` and should contain the contents
    of the attachment. In this case, we attach an image through the `UIImage.AsJPEG()`
    method, which returns the image contents inside an `NSData` object. The second
    parameter represents the **Multipurpose Internet Mail Extensions (MIME)** type
    of the attachment, and the third parameter its file name. The project's source
    code contains a full and commented example.
  prefs: []
  type: TYPE_NORMAL
- en: Action sheet for drafts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The action sheet displayed when the user taps the **Cancel** button is automatically
    handled by the `MFMailComposeViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Using text messaging in our application*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the address book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to access and manage the user's stored contacts
    in the device's address book.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `AddressBookApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a button on the view of `MainController`. Enter the following `using` directive
    in the `MainController.cs` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Override the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Get contacts** button, and watch the contact's names displayed in
    MonoDevelop's **Application Output** pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After installation of the iOS SDK, the simulator does not contain any contacts.
    You can add contacts the same way you can do it on the device.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MonoTouch.AddressBook` namespace contains all the classes that allow us
    to manage the device''s address book. To access the data directly, we need an
    instance of the `ABAddressBook` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all the contacts stored in the address book, we call its `GetPeople()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This method returns an array of `ABPerson` objects, which contains all the
    information of individual contacts. To read the contacts'' details, we iterate
    over the `ABPerson` array and get each contact''s first and last names with the
    `FirstName` and `LastName` properties respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a contact''s stored phone number(s), call the `GetPhones()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It returns an object of type `ABMultiValue<string>. ABMultiValue<T>` is a generic
    collection, especially designed for multiple address book values.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a phone number to a contact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a phone number to a contact, we can use the `ABPerson` class'' `SetPhones`
    method. It accepts an `ABMultiValue<string>` object as its parameter, but we cannot
    add new values to `ABMultiValue` objects. We can, however, write values to an
    `ABMutableMultiValue<T>` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code creates a new instance of `ABMutableMultiValue<string>` object,
    which we then use to add the phone number(s) we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter of the `Add` method is the label the phone number will
    have when it is saved to the contact. It is important to call the `ABAddressBook.Save()`
    method, or else the changes will not be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying contacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the native address book user interface
    to display contact information.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `DisplayContactApp`. Add a
    button on the view of `MainController`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a field in the `AppDelegate` class for a `UINavigationController:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instantiate the navigation controller, passing as its root controller an instance
    of the `MainController:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the navigation controller as the window''s root view controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the namespaces `MonoTouch.AddressBook` and `MonoTouch.AddressBookUI` in
    the `MainController.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Override the `ViewDidLoad` method of the `MainController` class, and implement
    it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the simulator or the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Display first contact** button to display the contact details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `MonoTouch.AddressBookUI` namespace contains the controllers that the native
    `Contacts` application uses to allow the user to display and manage contacts.
    Each contact's details can be viewed with the `ABPersonViewController`. This controller
    must be presented through a `UINavigationController`, or else it will not display
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'After initializing it, we set the `ABPerson` object we want to be displayed
    to its `DisplayedPerson` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we push it to the navigation controller''s stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ABPersonViewController` can also be used for editing. To do this, set the
    `AllowsEditing` property to `true:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be exactly the same as the native `Contacts` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](img/1468EXP_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that changes are saved normally through the `ABPersonViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Other address book controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MonoTouch.AddressBookUI` namespace contains all the controllers we need
    to create our own custom contacts application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ABPeoplePickerNavigationController:` This is a navigation controller that
    displays the saved contacts. The user can select a contact from the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABPersonViewController` : This controller is described in the previous example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABNewPersonViewController:` This is the controller that creates a new contact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ABUnknownPersonViewController:` This is the controller that is displayed with
    partial data for creating a new contact. This is similar to the controller that
    is displayed when we tap on an unknown number in the list of recent calls on the
    device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Managing the address book*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create an event and save it to the device's
    calendar database.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new project in MonoDevelop, and name it `CalendarEventsApp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This project must be executed on a device. The native `Calendar` application
    is not installed on the simulator.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a button on the main view of the `MainController`. Add the namespace `MonoTouch.EventKit`
    in the `MainController.cs` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, enter the following code in the `ViewDidLoad` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the application on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the **Display events** button to output the calendar events of the next
    30 days in the **Application Output** pad.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MonoTouch.EventKit` namespace is responsible for managing the calendar
    events. To read the stored events, we first initialize an `EKEventStore` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EKEventStore` class provides us access to the stored events. To retrieve
    the calendar events, we need a predicate of the type `NSPredicate`. We can create
    an instance through the `PredicateForEvents` method of the `EKEventStore` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The two first parameters are of the type `NSDate` (which can be implicitly converted
    to `DateTime)` and represent the start and end dates for which to search events.
    The third parameter is of the type `EKCalendar[]`, and it is an array of the calendars
    to search into. To search in all the available calendars, we pass the `EKEventStore.Calendars`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we call the `EnumerateEvents` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We pass the predicate we created earlier to the first parameter. The second
    parameter is a delegate of type `EKEventSearchCallback`. To read each event's
    data, we use its `EKEvent` object. Note that the process of enumerating calendar
    events is similar to the one that is used for enumerating assets from the assets
    library, as discussed in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As well as enumerating events, the `EKEventStore` allows us to create new ones.
    The following example creates and saves a new calendar event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: For creating a new `EKEvent` instance, we use the `EKEvent.FromStore` static
    method. We then set a start and end date, a title, and the calendar to which the
    event will be stored. Here, we use the default calendar that we can get with the
    `DefaultCalendarForNewEvents` property of `EKEventStore`. When we have everything
    set up, we call the `SaveEvent` method to save it.
  prefs: []
  type: TYPE_NORMAL
- en: Info on calendars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the device has two calendars set up: `Home` and `Work`. Although
    we cannot create new calendars on the device, new calendars that are created on
    the computer that we use to synchronize the device are automatically added when
    syncing.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Multimedia Resources"),Multimedia Resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Managing album items directly*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
