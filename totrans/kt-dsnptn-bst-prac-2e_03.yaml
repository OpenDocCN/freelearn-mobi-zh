- en: '*Chapter 2*: Working with Creational Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover how classic **creational patterns** are implemented
    using **Kotlin**. These patterns deal with *how* and *when* you *create* your
    objects. For each design pattern, we will discuss what it aims to achieve and
    how Kotlin accommodates those needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory Method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering these design patterns will allow you to manage your objects better,
    adapt well to changes, and write code that is easy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to install the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IntelliJ IDEA** **Community Edition** ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenJDK** **11** (or higher) ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on **GitHub** at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Singleton** – the most popular bachelor in town. Everybody knows him, everybody
    talks about him, and everybody knows where to look for him.'
  prefs: []
  type: TYPE_NORMAL
- en: Even people who don't like using design patterns will know Singleton by name.
    At one point, it was even proclaimed an **anti-pattern**, but only because of
    its wide popularity.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, for those who are encountering it for the first time, what is this design
    pattern all about?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, if you have a class, you can create as many instances of it as you
    want. For example, let''s say that we both are asked to list all of our favorite
    movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can create as many instances of `List` as we want, and there's
    no problem with that. Most classes can have multiple instances.
  prefs: []
  type: TYPE_NORMAL
- en: '*Next, what if we both want to list the best movies in the Quick and Angry
    series?*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that these two lists are exactly the same because they are empty. And they
    will stay empty because they are immutable and because the *Quick and Angry* series
    is simply horrendous. I hope you would agree with that.
  prefs: []
  type: TYPE_NORMAL
- en: Since these two instances of a class are exactly the same, according to the
    **equals method**, it doesn't make much sense to keep them in memory multiple
    times. It would be great if all references to an empty list pointed to the same
    instance of an object. And in fact, that's what happens with null, if you think
    about it. All nulls are the same.
  prefs: []
  type: TYPE_NORMAL
- en: That's the main idea behind the Singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of requirements for the Singleton design pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: We should have exactly one instance in our system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This instance should be accessible from any part of our system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `private` class. Then, you also need to make sure that instantiation is
    preferably lazy, thread-safe, and performant, with the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lazy**: We might not want to instantiate a singleton object when our program
    starts, as this may be an expensive operation. We would like to instantiate it
    only when it''s needed for the first time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Thread-safe**: If two threads are trying to instantiate a singleton object
    at the same time, they both should receive the same instance and not two different
    instances. If you''re not familiar with this concept, we''ll cover it in [*Chapter
    5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional Programming*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performant**: If many threads are trying to instantiate a singleton object
    at the same time, we shouldn''t block them for a long period of time, as this
    will be halting their execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meeting all of these requirements in Java or **C++** is quite difficult, or
    at least very verbose.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin makes creating singletons easy by introducing a keyword called `object`.
    You may recognize this keyword from **Scala**. By using this keyword, we'll get
    an implementation of a singleton object, which accommodates all of our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: The `object` keyword is used for more than just creating singletons. We'll discuss
    this in depth later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare objects just like a regular class but with no constructor, as a
    singleton object cannot be instantiated by us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, we can access `NoMoviesList` from anywhere in our code, and there
    will be exactly one instance of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Take note of the referential equality sign that checks that two variables point
    to the same object in memory. *Is this really a list though?*
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function that prints the list of our movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pass an initial list of movies, the code compiles just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we pass it our empty movie list, the code won''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this is that our function only accepts arguments of the *list
    of strings* type, while there's nothing to tell the function that `NoMoviesList`
    is of this type (even though its name suggests it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, in Kotlin, singleton objects can implement interfaces, and a generic
    `List` interface is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our compiler will prompt us to implement the required functions. We''ll
    do that by adding a body to `object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll leave it to you to implement the other functions if you wish. This should
    be a good exercise of everything you''ve learned about Kotlin until now. However,
    you don''t have to do this. Kotlin already provides a function to create empty
    lists of any type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you're curious, this function returns a singleton object that implements
    a `List`. You can see the complete implementation in the Kotlin source code using
    your IntelliJ IDEA or on GitHub ([https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt)).
    This is an excellent example of how design patterns are still actively applied
    in modern software.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Kotlin `object` has one major difference from a class – it can''t have constructors.
    If you need to implement initialization for your Singleton, such as loading data
    from a configuration file for the first time, you can use the `init` block instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note that if a Singleton is never invoked, it won't run its initialization logic
    at all, thereby saving resources. This is called **lazy initialization**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to limit object creation, let's discuss how to
    create objects without using a constructor directly.
  prefs: []
  type: TYPE_NORMAL
- en: Factory Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Factory Method** design pattern is all about creating objects.
  prefs: []
  type: TYPE_NORMAL
- en: '*But why do we need a method to create objects? Isn''t that what constructors
    are for?*'
  prefs: []
  type: TYPE_NORMAL
- en: Well, constructors have limitations.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, imagine we're building a game of chess. We would like to allow
    our players to save the state of the game into a text file and then restore the
    game from that position.
  prefs: []
  type: TYPE_NORMAL
- en: Since the size of the board is predetermined, we only need to record the position
    and type of each piece. We'll use algebraic notation for this – for example, the
    Queen piece at C3 will be stored in our file as `qc3`, the pawn piece at A8 will
    be stored as `pa8`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that we already read this file into a list of strings (which, by
    the way, would be an excellent application of the Singleton design pattern we
    discussed earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the list of notations, we would like to populate our board with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can implement our `createPiece` function, we need to decide what''s
    common to all chess pieces. We''ll create an interface for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that interfaces in Kotlin can declare properties, which is a very powerful
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each chess piece will be a `data class` that implements our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the other chess pieces is left as an exercise for you
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what''s left is to implement our `createPiece` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Before we can discuss what this function achieves, let's cover three new syntax
    elements we haven't seen before.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `toCharArray` function splits a string into an array of characters.
    Since we assume that all of our notations are three characters long, the element
    at the `0` position will represent the *type* of the chess piece, the element
    at the `1` position will represent its vertical column – also known as `file`
    – and the last element will represent its horizontal column – also known as `rank`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can see three values: `type`, `file`, and `rank`, surrounded by parentheses.
    This is called a `data class` can be destructured.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code example is similar to the following, much more verbose code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's focus on the `when` expression. Based on the letter representing
    the type, it instantiates one of the implementations of the `ChessPiece` interface.
    Remember, this is what the Factory Method design pattern is all about.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure you grasp this design pattern well, feel free to implement the
    classes and logic for other chess pieces as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's look at the bottom of our function, where we see the first use
    of a `throw` expression.
  prefs: []
  type: TYPE_NORMAL
- en: This expression, as the name suggests, *throws* an exception, which will stop
    the normal execution of our simple program. We'll discuss how to handle exceptions
    in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, the Factory Method design pattern is often used by libraries
    that need to parse configuration files – be they of the XML, JSON, or YAML format
    – into runtime objects.
  prefs: []
  type: TYPE_NORMAL
- en: Static Factory Method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a similarly named design pattern (which has a slightly different implementation)
    that is often confused with the Factory Method design pattern, and it is described
    in the *Gang of Four* book – the **Static Factory Method** design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Static Factory Method design pattern was popularized by Joshua Bloch in
    his book, *Effective Java*. To understand this better, let''s look at some examples
    from the Java standard library: the `valueOf()` methods. There are at least two
    ways to construct a `Long` (that is, a 64-bit integer) from a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Both the constructor and the `valueOf()` method receive string as input and
    produce `Long` as output.
  prefs: []
  type: TYPE_NORMAL
- en: '*So, why should we prefer the Static Factory Method design pattern to a simple
    constructor?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the advantages of using the Static Factory Method compared
    to constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides an opportunity to explicitly name different object constructors.
    This is especially useful when your class has multiple constructors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We usually don't expect exceptions from a constructor. That doesn't mean that
    the instantiation of a class can't fail. Exceptions from a regular method, on
    the other hand, are much more accepted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaking of expectations, we expect the constructor to be fast. But construction
    of some objects is inherently slow. Consider using the Static Factory Method instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are mostly style advantages; however, there are also technological advantages
    to this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Static Factory Method design pattern may provide `Long` actually does. Instead
    of always returning a new instance for any value, `valueOf()` checks in the cache
    whether this value was already parsed. If it was, it returns a cached instance.
    Repeatedly calling the Static Factory Method with the same values may produce
    less garbage for collection than using constructors all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When calling the constructor, we always instantiate the class we specify. On
    the other hand, calling a Static Factory Method is less restrictive and may produce
    either an instance of the class itself or one of its subclasses. We'll come to
    this after discussing the implementation of this design pattern in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Static Factory Method in Kotlin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We discussed the `object` keyword earlier in this chapter in the *Singleton*
    section. Now, we'll see another use of it as a **companion object**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, Static Factory Methods are declared `static`. But in Kotlin, there''s
    no such keyword. Instead, methods that don''t belong to an instance of a class
    can be declared inside `companion object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Companion objects may have a name – for example, `companion object` parser.
    But this is only to provide clarity about what the goal of the object is.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this time, we have declared an object that is prefixed by the
    `companion` keyword. Also, it's located inside a class, and not at the package
    level in the way we saw in the Singleton design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'This object has its own methods, and you may wonder what the benefit of this
    is. Just like a Java static method, calling a `companion` `object` will lazily
    instantiate it when the containing class is accessed for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, calling it on an instance of a class simply won''t work, unlike in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: A class may have only one `companion object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we also want the Static Factory Method to be the only way to instantiate
    our object. In order to do that, we can declare the default constructor of our
    object as `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that now there''s only one way of constructing an instance of our
    class – through our Static Factory Method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Let's now discuss another design pattern that is often confused with the Factory
    Method – Abstract Factory.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Factory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Abstract Factory** is a greatly misunderstood design pattern. It has a notorious
    reputation for being very complex and bizarre. Actually, it''s quite simple. If
    you understood the Factory Method design pattern, you''ll understand this one
    in no time. This is because the Abstract Factory design pattern is a factory of
    factories. That''s all there is to it. The *factory* is a function or class that''s
    able to create other classes. In other words, an abstract factory is a class that
    wraps multiple factory methods.'
  prefs: []
  type: TYPE_NORMAL
- en: You may understand this and still wonder what the use of such a design pattern
    may be. In the real world, the Abstract Factory design pattern is often used in
    frameworks and libraries that get their configuration from files. The **Spring
    Framework** is just one example of these.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the design pattern works, let''s assume we have a
    configuration for our server written in a YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Our task is to construct objects from this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we discussed how to use Factory Method to construct
    objects from the same family. But here, we have two families of objects that are
    related to each other but are not *siblings*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s describe them as interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of a `data class`, we''ll return an interface. You''ll see how this
    helps us later in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can provide basic implementations to be used later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The server configuration simply contains the list of properties – and a *property*
    is a pair comprising a `name` object and a `value` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first time we have seen the `Any` type being used. The `Any` type
    is Kotlin''s version of Java''s `object`, but with one important distinction:
    it cannot be null.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write our first Factory Method, which will create `Property` given
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'As in many other languages, `trim()` is a function that is declared on strings
    that removes any spaces in the string. Now, let''s create two properties to represent
    the port (`port`) and environment (`environment`) of our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a slight issue with this code. To understand what it is, let''s try
    to store the value of the `port` property into another variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We already ensured that `port` is parsed to an `Int` in our Factory Method.
    But now, this information is lost because the type of the value is declared as
    `Any`. It can be `String`, `Int`, or any other type, for that matter. We need
    a new tool to solve this issue, so let's take a short detour and discuss casts
    in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Casts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Casts** in typed languages are a way to try and force the compiler to use
    the type we specify, instead of the type it has inferred. If we are sure what
    type the value is, we can use an *unsafe* cast on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The reason it is called *unsafe* is that if the value is not of the type we
    expect, our program will crash without the compiler being able to warn us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could use a *safe* cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '*Safe* casts won''t crash our program, but if the type of the object is not
    what we expect, it will return null. Notice that our `port` variable now is declared
    as the nullable `Int`, so we have to explicitly deal with the possibility of not
    getting what we want during compilation time.'
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of resorting to casts, let''s try another approach. Instead of using
    a single implementation with a value of the `Any` type, we''ll use two separate
    implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Our Factory Method will have to change a little to be able to return one of
    the two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks fine, but if we try to compile our code again, it still won''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we now have two concrete classes, the compiler doesn''t know if the
    parsed property is `IntProperty` or `StringProperty`. All it knows is that it''s
    `Property`, and the type of the value is still `Any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We need another trick, and that trick is called **smart casts**.
  prefs: []
  type: TYPE_NORMAL
- en: Smart casts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can check if an object is of a given type by using the `is` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: However, the Kotlin compiler is very smart. *If we performed a type check on
    an* `if` *expression, it would mean that* `portProperty` *was indeed* `IntProperty`*,
    right?* So, it could be safely cast.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin compiler will do just that for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: There is no compilation error anymore, and we also do not have to deal with
    nullable values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smart casts also work on nulls. In Kotlin''s type hierarchy, the non-nullable
    `Int` type is a subclass of a nullable type, `Int?`, and this is true for all
    types. Previously, we mentioned that a *safe* cast will return `null` if it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'We could check if `port` is null, and if it isn''t, it will be smartly cast
    to a non-nullable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '*Nice!* *But wait, what''s going on in this code?*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we said that values cannot be reassigned. But here,
    we defined the `port` value twice. *How is this possible?* This is not a bug,
    but another Kotlin feature, and it is called **variable shadowing**.
  prefs: []
  type: TYPE_NORMAL
- en: Variable shadowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s consider how our code would look if there was no shadowing. We
    would have to declare two variables with different names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: However, this is a waste, for two reasons. First, the variable names become
    quite verbose. Second, the `portOrNull` variable would most probably never be
    used past this point because null is not a very useful value to begin with. Instead,
    we can declare values with the same names in different scopes, denoted by curly
    brackets (`{}`).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that variable shadowing may confuse you, and it is error-prone by
    nature. However, it is important to be aware that it exists, but the recommendation
    is to name your variables explicitly whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Collection of Factory Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we''ve had our detour into casts and variable shadowing, let''s go
    back to the previous code example and implement a second Factory Method, that
    will create a `server` configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the lines from our configuration file and converts them into
    `Property` objects using the `property()` Factory Method that we've already implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test that our second Factory Method works as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Since these two methods are related, it would be good to put them together under
    the same class. Let's call this class `Parser`. Although we didn't parse any actual
    file and agreed that we get its contents line by line already, by the end of this
    book, you would probably agree that implementing the actual reading logic is quite
    trivial.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use Static Factory Method and the `companion object` syntax we learned
    about in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting implementation will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: This pattern allows us to create *families* of objects – in this case, `ServerConfig`
    is the *parent* of a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code is just one way to implement an Abstract Factory. You may
    find some implementations that rely on implementing an interface instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: This approach may be better if your Factory Methods grow to contain lots of
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One last question you may have is where we can see Abstract Factory used in
    real code. One example is the `java.util.Collections` class. It has methods such
    as `emptyMap`, `emptyList`, and `emptySet`, which each generate a different class.
    However, what is common to all of them is that they are all collections.
  prefs: []
  type: TYPE_NORMAL
- en: Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, our objects are very simple and have only one constructor, be it
    an empty or non-empty one. But sometimes, their creation is very complex and based
    on a lot of parameters. We've seen one pattern already that provides *a better
    constructor* – the Static Factory Method design pattern. Now, we'll discuss the
    **Builder** design pattern, which will help us create complex objects.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of such an object, imagine we need to design a system that sends
    emails. We won't implement the actual mechanism of sending them, we will just
    design a class that represents it.
  prefs: []
  type: TYPE_NORMAL
- en: 'An email may have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: An address (at least one is mandatory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CC (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Title (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important flag (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can describe an email in our system as a `data class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Look at the definition of the last argument in the preceding code. This comma
    is not a typo. It is called a **trailing comma**, and these were introduced in
    **Kotlin 1.4**. This is done so you can easily change the order of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s attempt to create an email addressed to our manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have defined *carbon copy* (that's what `CC` stands for) as nullable
    so that it can receive either a list of emails or null. Another option would be
    to define it as `List<String>` and force our code to pass `listOf()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since our constructor receives a lot of arguments, we had to put in some comments
    in order not to get confused.
  prefs: []
  type: TYPE_NORMAL
- en: '*But what happens if we need to change this class now?*'
  prefs: []
  type: TYPE_NORMAL
- en: First, our code will stop compiling. Second, we need to keep track of the comments.
    In short, constructors with a long list of arguments quickly become a mess.
  prefs: []
  type: TYPE_NORMAL
- en: This is the problem the Builder design pattern sets out to solve. It decouples
    the assigning of arguments from the creation of objects and allows the creation
    of complex objects one step at a time. In this section, we'll see a number of
    approaches to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new class, `MailBuilder`, which will wrap our `Mail`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Our builder has exactly the same properties as our resulting class. But these
    properties are all mutable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the constructor is marked using the `internal` visibility modifier.
    This means that our `Mail` class will be accessible to any code inside our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finalize the creation of our class, we''ll introduce the `build()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'And for each property, we''ll have another function to be able to set it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our builder to create an email in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: After setting a new value, we return a reference to our object by using `this`,
    which provides us with access to the next setter to allow us to perform chaining
    (please refer to the *Fluent setters* section in this chapter for an explanation
    of this).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a working approach. But it has a couple of downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: The properties of our resulting class must be repeated insider the builder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every property, we need to declare a function to set its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin provides two other ways that you may find even more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Fluent setters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The approach using `data class` constructor will contain only the mandatory
    fields. All other fields will become `private`, and we''ll provide setters for
    these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Important Note:'
  prefs: []
  type: TYPE_NORMAL
- en: Using underscores for `private` variables is a common convention in Kotlin.
    It allows us to avoid repeating `this.message = message` and mistakes such as
    `message = message`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code example, we used the `apply` function. This is part of the family
    of scoping functions that can be invoked on every Kotlin object, and we''ll cover
    them in detail in [*Chapter 9*](B17816_09_ePub.xhtml#_idTextAnchor216), *Idioms
    and Anti-Patterns*. The `apply` function returns the reference to an object after
    executing the block. So, it''s a shorter version of the setter function from the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'This provides us with the same API as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: However, we may not need setters at all. Instead, we can use the `apply()` function
    we previously discussed on the object itself. This is one of the extension functions
    that every object in Kotlin has. This approach will work only if all of the optional
    fields are *variables* instead of *values*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can create our email like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a nice approach, and it requires less code to implement. However, there
    are a few downsides to this approach too:'
  prefs: []
  type: TYPE_NORMAL
- en: We had to make all of the optional arguments mutable. Immutable fields should
    always be preferred to mutable ones, as they are thread-safe and easier to reason
    about.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of our optional arguments are also nullable. Kotlin is a null-safe language,
    so every time we access them, we first have to check that their value was set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This syntax is very verbose. For each field, we need to repeat the same pattern
    over and over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's discuss the last approach to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Default arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Kotlin, we can specify default values for constructor and function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Default arguments are set using the `=` operator after the type. This means
    that although our constructor still has all the arguments, we don't need to provide
    them any.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you would like to create an email without a body, you can do it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: However, note that we had to specify that we don't want anyone in the CC field
    by providing an empty list, which is a bit inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: '*What if we wanted to send an email that is only flagged as important?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Not having to specify order with fluent setters was very handy. Kotlin has
    *named arguments* for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Combining default parameters with named arguments makes creating complex objects
    in Kotlin rather easy. For that reason, you will rarely need the Builder design
    pattern at all in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: In real applications, you'll often see the Builder design pattern used to construct
    instances of servers. A server would accept an optional host and an optional port
    and so on, and then when all of the arguments were set, you'd invoke a listen
    method to start it.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Prototype** design pattern is all about customization and creating objects
    that are similar but slightly different. To understand it better, Let's look at
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have a system that manages users and their permissions. A `data
    class` representing a user might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Each user must have a role, and each role has a set of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll describe a role as an `enum` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: The `enum` classes are a way to represent a collection of constants. This is
    more convenient than representing a role as a string, for example, as we check
    at compile time that such an object exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we create a new *user*, we assign them permissions that are similar to
    another user with the same *role*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s imagine that we now need to add a new field to the `User` class, which
    we will name `tasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `createUser` function will stop compiling. We''ll have to change it by
    copying the value of this newly added field to the new instance of our class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: This work will have to be repeated every time the `User` class is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s a bigger problem still: *What if a new requirement is introduced,
    making the* `permissions` *property, for example,* `private`*?*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Our code will stop compiling again, and we'll have to change it again. The constant
    requirement of changes to the code is a clear indication that we need another
    approach to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from a prototype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The whole idea of a *prototype* is to be able to clone an object easily. There
    are at least two reasons you may want to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps in instances where creating your object is very expensive – for example,
    if you need to fetch it from the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps if you need to create objects that are similar but vary slightly and
    you don't want to repeat similar parts over and over again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Important Note:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are also more advanced reasons to use the Prototype design pattern. JavaScript,
    for example, uses prototypes to implement inheritance-like behavior without having
    classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Luckily, Kotlin fixes the somewhat broken Java `clone()` method. Data classes
    have a `copy()` method, which takes an existing `data class`, and creates a new
    copy of it, optionally changing some of its attributes in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: In a similar way to what we saw with the Builder design pattern, named arguments
    allow us to specify attributes that we can change in any order. And we need to
    specify only the attributes we want to change. All of the other data will be copied
    for us, even the `private` properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `data class` is yet another example of a design pattern that is so common
    that it became part of a language syntax. They are an extremely useful feature,
    and we will see them being used many more times in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned when and how to use creational design patterns.
    We started by discussing how to use the `object` keyword to construct a singleton
    class, and then we discussed the use of `companion object` if you need a Static
    Factory Method. We also covered how to assign multiple variables at once using
    destructuring declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we discussed smart casts, and how they can be applied in the Abstract
    Factory design pattern to create families of objects. We then moved to the Builder
    design pattern and learned that functions can have default parameter values. We
    then learned that we can refer to their arguments using not only positions but
    also names.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we covered the `copy()` function of the data classes, and how it helps
    us when implementing the Prototype design pattern to produce similar objects with
    slight changes. You should now understand how to use creational design patterns
    to better manage your objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll cover the second family of design patterns: **structural
    patterns**. These design patterns will help us create extensible and maintainable
    object hierarchies.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name two uses for the `object` keyword we learned about in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `apply()` function used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide one example of a Static Factory Method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
