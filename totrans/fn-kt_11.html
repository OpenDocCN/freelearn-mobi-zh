<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with Streams in Kotlin</h1>
                </header>
            
            <article>
                
<p>So, we are gradually moving towards completing this book. In this chapter, we are going to cover Streams in Kotlin and how to work with them.</p>
<p>Streams were first introduced in Java from Java 8. The Streams API in Kotlin is almost identical to the Java API, but contains a few little additions and extension functions.</p>
<p>This is the contents that we will be covering in this chapter:</p>
<ul>
<li>Introduction to Streams</li>
<li>Collections versus Streams</li>
<li>Streams versus Observable (ReactiveX-RxKotlin/RxJava)</li>
<li>Working with Streams</li>
<li>Different ways to create Streams</li>
<li>Collecting Streams</li>
</ul>
<p>So, let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to Streams</h1>
                </header>
            
            <article>
                
<p>As we mentioned earlier, Streams were first introduced from Java 8. Starting from Java 8, Java started to give more focus to functional programming and started to add functional features gradually.</p>
<p>Kotlin, on the other hand, started to add functional features from day one. Kotlin added functional features and interfaces. While working with Java, you can use Streams only if you use Java 8 and later versions, but with Kotlin you can still use Streams, even when working with JDK 6.</p>
<p>So, what are Streams? You can think of Streams as an abstract layer over a sequence of elements to perform aggregate operations. Confused? Let's take a code example and then try to understand:</p>
<pre class="mce-root">  fun main(args: Array&lt;String&gt;) { 
      val stream = 1.rangeTo(10).asSequence().asStream() 
      val resultantList = stream.skip(5).collect(Collectors.toList()) 
      println(resultantList) 
  } </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="45" width="398" src="assets/eedf1b52-a70a-4df2-a3fd-bb9be43d9878.jpg"/></div>
<p>In the preceding program, what we did was create an <kbd>IntRange</kbd> value, create a <kbd>Sequence</kbd> value from it, and then get the <kbd>stream</kbd> value from it. We then skipped the first five items and then collected it back to a <kbd>List</kbd> instance. We will have a detailed look at all the functions used in the preceding code later in this chapter.</p>
<p>The preceding program utilized the functional interfaces of the Stream API.</p>
<div class="packt_infobox">Stream API has a rich set of functional interfaces like we saw in the Collections.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collections versus Streams</h1>
                </header>
            
            <article>
                
<p>Reading up till here, you're probably thinking that all operations we performed in that program is possible with Collections itself in Kotlin, so why should we use Streams? To answer that, we should first learn the differences between Streams and Collections. So, let's have a look at the following list consisting of differences between Collections and Streams:</p>
<ul>
<li>As the definition of Collections says, a <strong>Collection</strong> is a data structure which stores and lets you work with a group of data. <strong>Streams</strong>, on the other hand, aren't data structures and don't store anything; they work like a pipeline or IO channel, which fetches data from its source on demand.</li>
<li>Every data structure must have a finite size limit, and the same applies to Collections as well. But, as Streams are not data structures, they don't need to have any specific size limit.</li>
<li>While accessing elements of a Collection directly, you can do it any time, even for the same position, without the requirement of recreating the Collection. But when working with Streams, elements of a Stream are only visited once during the life of a Stream. Like an iterator, a new Stream must be generated to revisit the same elements of the source.</li>
<li>The Collection API constructs objects in an eager manner, always ready to be consumed. The Stream API creates objects in a lazy, on-demand basis.</li>
<li>The Collection API is used for storing data in different kinds of data structures. The Stream API is used for the computation of data on a large set of objects.</li>
</ul>
<p>So, these were very basic differences between the Collection API and the Stream API. At a glance, the Streams seem like RxKotlin, Observables which provide a way to consume the data, but there are a lot of significant differences between Streams and Observables. These are the differences between Streams and Observables:</p>
<ul>
<li>The first notable difference is that Streams are pull-based, and Observables are push-based. This may sound too abstract, but it has significant consequences that are very concrete.</li>
<li>With Observables, it's easy to change threads or specify thread pools for a chain with ease, thanks to Schedulers. But, with Streams, it's a bit tricky.</li>
<li>Observables are synchronized all the way through. This spares you from checking all the time whether these basic operations are thread safe.</li>
<li>One more significant difference is that Observables have a lot more functional interfaces than the Streams API, which makes Observables easy to use with a lot of options to accomplish a certain task.</li>
</ul>
<p>So, we learned that Streams are not a data structure but are like an abstract layer on top of the data source (which may be Collections or anything else), and even though Streams construct objects in a lazy, on-demand basis, they are still pull-based and use loops inside them.</p>
<div class="packt_tip">To know more about push-based architecture and Observables, you can have a read of the book, <em>Reactive Programming in Kotlin, </em>by Rivu Chakraborty.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with Streams</h1>
                </header>
            
            <article>
                
<p>So, we learned a lot of theories regarding Streams, and we also learned that Streams have a set of functional interfaces to work with (actually, the functional interfaces is the only way to work with Streams), but as I mentioned before, they work in a slightly different way than the Collections API.</p>
<p>To make things clearer, have a look back at the following example:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val stream = 1.rangeTo(10).asSequence().asStream() 
       val resultantList = stream.filter{ 
          it%2==0 
      }.collect(Collectors.toList()) 
      println(resultantList) 
  } </pre>
<p>The preceding program is a simple one; we just grabbed a stream of numbers <kbd>1</kbd> through <kbd>10</kbd> and filtered out the odd numbers from that stream, and then collected the results inside a new <kbd>List</kbd>.</p>
<p>But let's try to understand the mechanism of how it works. We <span>are </span>already familiar with functional interfaces and with the <kbd>filter</kbd> function, as we got introduced to them in the previous chapters, but the thing that's different here is the <kbd>collect</kbd> function and the <kbd>Collectors</kbd> value, which help collect the resultant data in a new <kbd>List</kbd>. We will have a closer look at the <kbd>collect</kbd> method and the <kbd>Collectors</kbd> value later in this chapter, but for now, let's have a look at the functional interfaces Streams offers, and types of Streams.</p>
<p>So, the following is the list of operations/functional interfaces from the Stream API and their descriptions:</p>
<ul>
<li><kbd>filter()</kbd>: Works in the same way like <kbd>Collection.filter</kbd> in Kotlin. It returns a <kbd>stream</kbd> values consisting of the elements of this <kbd>stream</kbd> that match the given predicate.</li>
<li><kbd>map()</kbd>: Works in the same way as <kbd>Collection.map</kbd> in Kotlin. It returns a <kbd>stream</kbd> value consisting of the results of applying the given function to each element of this <kbd>stream</kbd>.</li>
<li><kbd>mapToInt()</kbd>/<kbd>mapToLong()</kbd>/<kbd>mapToDouble()</kbd>: Works the same way as <kbd>map</kbd>, but instead of returning a <kbd>stream</kbd> value, they return <kbd>IntStream</kbd>, <kbd>LongStream</kbd> and <kbd>IntStream</kbd> values, respectively. We are covering <kbd>IntStream</kbd>, <kbd>LongStream</kbd>, and <kbd>IntStream</kbd> in detail later in this chapter.</li>
</ul>
<ul>
<li><kbd>flatMap()</kbd>: Works the same way as <kbd>Collection.flatMap</kbd> in Kotlin.</li>
<li><kbd>flatMapToInt()</kbd>/<kbd>flatMapToLong()</kbd>/<kbd>flatMapToDouble()</kbd>: Works the same way as <kbd>flatMap</kbd>, but instead of returning a <kbd>stream</kbd> value, they return the <kbd>IntStream</kbd>, <kbd>LongStream</kbd>, and <kbd>IntStream</kbd> values, respectively.</li>
<li><kbd>distinct()</kbd>: Works in the same way as <kbd>Collection.distinct</kbd>. It returns a <kbd>stream</kbd> value of distinct elements.</li>
<li><kbd>peek()</kbd>: This function doesn't have any Kotlin Collection counterpart, however, it has a counterpart in RxKotlin/RxJava. This function returns the <kbd>stream</kbd> value consisting of the elements of this <kbd>stream</kbd>, additionally performing the provided action on each element, as elements are consumed from the resulting <kbd>stream</kbd>, much like the <kbd>doOnNext</kbd> operator of RxJava.</li>
<li><kbd>anyMatch()</kbd>: Similar to <kbd>Collection.any()</kbd>, it returns whether any elements of this <kbd>stream</kbd> match the provided predicate. It may not evaluate the predicate on all elements, if not necessary for determining the result. If the <kbd>stream</kbd> value is empty, then the <kbd>false</kbd> value is returned and the predicate is not evaluated.</li>
<li><kbd>allMatch()</kbd>: Similar to <kbd>Collection.all</kbd>, it returns whether all elements of this <kbd>stream</kbd> match the provided predicate. It may not evaluate the predicate on all elements, if not necessary for determining the result. If the <kbd>stream</kbd> value is empty, then the <kbd>true</kbd> value is returned and the predicate is not evaluated.</li>
<li><kbd>noneMatch()</kbd>: Similar to <kbd>Collection.none</kbd>, it returns whether no elements of this <kbd>stream</kbd> match the provided predicate. It may not evaluate the predicate on all elements, if not necessary for determining the result. If the <kbd>stream</kbd> is empty, then the <kbd>false</kbd> value is returned and the predicate is not evaluated.</li>
</ul>
<p>We are skipping examples of these functions, as they are similar to the <kbd>Collection</kbd> functions and RxJava/RxKotlin operators.</p>
<div class="packt_tip">If you're wondering about it then yes, if your project is purely in Kotlin (without any Java or any other language code), you can safely ditch Streams in favor of Collections and coroutines altogether.</div>
<p>So, let's now take a look at the <kbd>IntStream</kbd>, <kbd>DoubleStream</kbd>, and <kbd>LongStream</kbd> values we mentioned earlier and explore what purpose<span> </span>they serve.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Primitive streams</h1>
                </header>
            
            <article>
                
<p><strong>Primitive streams</strong> were introduced in Java 8, to take advantage of primitive data types in Java while using Streams (again, Streams are basically from Java, and Kotlin just adds a few extension functions to the Streams API). <kbd>IntStream</kbd>, <kbd>LongStream</kbd>, and <kbd>DoubleStream</kbd> are part of those primitive Streams.</p>
<p>These primitive streams work similarly to the normal Stream with some added features of the primitive data types.</p>
<p>So, let's take an example; have a look at the following program:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val intStream = IntStream.range(1,10) 
      val result = intStream.sum() 
      println("The sum of elements is $result") 
  } </pre>
<p>So, we created an <kbd>IntStream</kbd> value with the <kbd>IntStream.range()</kbd> function, the <kbd>range</kbd> function takes two integers as the starting and ending point and creates a Stream ranging from the specified integers, with both included. We then calculated the sum and printed it. The program seems quite easy, and credit goes to <kbd>IntStream</kbd> obviously, why? Think of calculating the sum of elements with that ease; without <kbd>IntStream</kbd>, we would have to loop through all the elements to calculate the sum.</p>
<p>The following is another example of primitive streams:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val doubleStream = DoubleStream.iterate(1.5,{item -&gt;     item*1.3})//(1) 
      val avg = doubleStream 
              .limit(10)//(2) 
              .peek { 
                  println("Item $it") 
              }.average()//(3) 
      println("Average of 10 Items $avg") 
  } </pre>
<p>Have a look at the following output before we explain the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="300" width="420" src="assets/5d610692-ea36-4f48-a0ce-6250c7695cdd.jpg"/></div>
<p>So, let's explain the program:</p>
<ul>
<li>On comment <kbd>(1)</kbd>, we created a <kbd>DoubleStream</kbd> value with the factory method <kbd>iterate()</kbd>. The iterate method takes a <kbd>double</kbd> as the seed of the Stream, and an operand, which will be iteratively applied to generate the elements of the Stream, for example if you pass <em>x</em> as the seed and <em>f</em> as the operator, the Stream will return <em>x</em> as the first element, <em>f(x)</em> as the second element, <em>f(f(x))</em> as the third element, and so on. This function creates a Stream of infinite size.</li>
<li>We used the <kbd>limit</kbd> operator at comment <kbd>(2)</kbd>, as we wanted only 10 elements from that stream, not all the elements till infinity. On comment <kbd>(3)</kbd>, we calculated <kbd>average</kbd>.</li>
</ul>
<p>So, let's have a look at the different ways to create a Stream.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stream factory methods</h1>
                </header>
            
            <article>
                
<p>The Streams API provides numerous ways to get a <kbd>Stream</kbd> instance. The following is the list of ways to create Streams that we are covering:</p>
<ul>
<li><kbd>Stream Builder</kbd></li>
<li><kbd>Stream.empty()</kbd></li>
<li><kbd>Stream.of()</kbd></li>
<li><kbd>Stream.generate()</kbd></li>
<li><kbd>Stream.iterate()</kbd></li>
<li>Kotlin extension—<kbd>asStream()</kbd></li>
</ul>
<p>Among the preceding list, we've already seen how the Kotlin extension—<kbd>asStream</kbd> and the <kbd>Stream.iterate</kbd> function works (it'll work in the same way as the <kbd>DoubleStream.iterate</kbd> value, covered in the previous example). We will have a look at the rest.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stream Builder</h1>
                </header>
            
            <article>
                
<p>The <kbd>Stream Builder</kbd> interface makes it really easy to create an instance of Stream with ease. Have a look at the following example:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val stream = Stream.builder&lt;String&gt;() 
              .add("Item 1") 
              .add("Item 2") 
              .add("Item 3") 
              .add("Item 4") 
              .add("Item 5") 
              .add("Item 6") 
              .add("Item 7") 
              .add("Item 8") 
              .add("Item 9") 
              .add("Item 10") 
              .build() 
      println("The Stream is ${stream.collect(Collectors.toList())}") 
  } </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5845a533-33b5-4825-9357-accd2a26e701.jpg"/></div>
<p>The <kbd>Stream.builder()</kbd> method returns an instance of <kbd>Streams.Builder</kbd>. Then, we used the <kbd>Builder.add</kbd> function; the <kbd>add</kbd> function accepts an item for the <kbd>stream</kbd> value to be built, and returns the same instance of <kbd>Stream.Builder</kbd>. The <kbd>build</kbd> function then created the <kbd>stream</kbd> instance with the items provided to the builder.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating empty Streams – Stream.empty()</h1>
                </header>
            
            <article>
                
<p>Creating empty Streams is really easy with the <kbd>Streams.empty()</kbd> factory method. Consider the following example:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val emptyStream = Stream.empty&lt;String&gt;() 
      val item = emptyStream.findAny() 
      println("Item is $item") 
 } </pre>
<p>In the preceding example, we created an <kbd>emptyStream</kbd> value with <kbd>Stream.empty()</kbd>, we then used the <kbd>findAny()</kbd> function to get hold of any element randomly selected from that Stream. The <kbd>findAny()</kbd> method returns an <kbd>Optional</kbd> value with a randomly selected item from the Stream, or an empty <kbd>Optional</kbd>, if the Stream is empty.</p>
<p>The following is the output of the preceding program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="85" width="408" src="assets/5fdd9fe5-4c3e-423f-adc3-e9771bf2701b.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Stream by passing elements – Stream.of()</h1>
                </header>
            
            <article>
                
<p>We can also get an instance of Stream by providing its elements to the <kbd>of</kbd> function. The <kbd>of</kbd> function works in a similar way to the <kbd>Observable.just</kbd> method from RxJava/RxKotlin.</p>
<p>Have a look at the following example:</p>
<pre> fun main(args: Array&lt;String&gt;) { 
      val stream = Stream.of("Item 1",2,"Item 3",4,5.0,"Item 6") 
      println("Items in Stream =            ${stream.collect(Collectors.toList())}") 
  } </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="86" width="436" src="assets/65744259-056b-4ad5-8524-3dd958898399.jpg"/></div>
<p>Straightforward and easy, isn't it?</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating Streams – Stream.generate()</h1>
                </header>
            
            <article>
                
<p>We can also create a Stream by using the <kbd>Stream.generate()</kbd> factory method. It accepts a lambda/supplier instance as a parameter, and will use it to generate the item for each time the item is demanded. This method also creates an infinite Stream.</p>
<p>Consider the following example:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val stream = Stream.generate { 
          //return a random number 
          (1..20).random() 
      } 
      val resultantList = stream 
              .limit(10) 
              .collect(Collectors.toList()) 
      println("resultantList = $resultantList") 
  } </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="82" width="408" src="assets/209892c9-f76a-4891-8697-07b88b05c32d.jpg"/></div>
<p>So, the Stream API called the lambda to get each of the elements of the Stream—awesome.</p>
<p>So, now as we are quite familiar with how to use Streams and we know about primitive Streams, let's move forward and see how to work with <kbd>Collectors</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collector and Stream.collect – collecting Streams</h1>
                </header>
            
            <article>
                
<p>We can perform numerous operations with Stream, but we may come into a situation where we need to repack the elements from the Stream into a data structure. The <kbd>Stream.collect()</kbd> method helps us achieve the same. It's one of the terminal methods of the Streams API. It allows you to perform mutable <kbd>fold</kbd> operations (repackaging elements to some data structures and applying some additional logic, concatenating them, and many more) on data elements held in a Stream instance.</p>
<p>The <kbd>collect()</kbd> method takes a <kbd>Collector</kbd> interface implementation as a parameter, for the strategy (whether to repackage them to a data structure, concatenate them, or anything else) of collecting.</p>
<p>So, do we need to write our own implementation of the <kbd>Collector</kbd> interface for repackaging the Stream into a <kbd>List</kbd>/<kbd>Set</kbd> values? Of course not, the Streams API provides you with some of the predefined <kbd>Collector</kbd> implementations for some of the most common use cases.</p>
<p>The <kbd>Collectors</kbd> class holds the predefined <kbd>Collector</kbd> implementations. All of them can be imported with the following line:</p>
<pre>import java.util.stream.Collectors </pre>
<p>The following list contains the predefined <kbd>Collector</kbd> implementations:</p>
<ul>
<li><kbd>Collectors.toList()</kbd></li>
<li><kbd>Collectors.toSet()</kbd></li>
<li><kbd>Collectors.toMap()</kbd></li>
<li><kbd>Collectors.toCollection()</kbd></li>
<li><kbd>Collectors.joining()</kbd></li>
<li><kbd>Collectors.groupingBy()</kbd></li>
</ul>
<p>So, let's have a brief look at each of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Collectors.toList(), Collectors.toSet(), and Collectors.toCollection() methods</h1>
                </header>
            
            <article>
                
<p>We've already seen the implementations of <kbd>Collectors.toList()</kbd>. The <kbd>Collectors.toList()</kbd> method helps collect the elements of a Stream into a <kbd>List</kbd>. The important thing to note here is that you can't specify which <kbd>List</kbd> implementation to use; instead, it'll always use the default one.</p>
<p><kbd>Collectors.toSet()</kbd> is similar to the <kbd>Collectors.toList()</kbd> method, just instead of <kbd>List,</kbd> it repackages the elements into a set. Again, with <kbd>Collectors.toSet(),</kbd> you won't be able to specify which set implementation to use.</p>
<p>The <kbd>Collectors.toCollection()</kbd> method is a complementing version of the <kbd>toList()</kbd> and <kbd>toSet()</kbd>; it lets you provide a custom Collection to accumulate the list into.</p>
<p>Consider the following example to explain it:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val resultantSet = (0..10).asSequence().asStream() 
              .collect(Collectors.toCollection{LinkedHashSet&lt;Int&gt;()}) 
      println("resultantSet $resultantSet") 
  } </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="86" width="413" src="assets/703b52ce-d51e-4885-90c5-df8ebe17827f.jpg"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collecting into Map – Collectors.toMap()</h1>
                </header>
            
            <article>
                
<p>The <kbd>Collectors.toMap()</kbd> function helps us repackage the Stream into <kbd>Map</kbd> implementation. This function offers a lot of customizations. The simplest version accepts two lambdas; the first one is to determine the key of Map Entry, and the second lambda is to determine the value of Map Entry. Please note, each element in the Stream will be represented in an entry in the <kbd>Map</kbd>.</p>
<p>Those two lambdas will get each element of the Stream in separate iterations and are expected to generate a key/value based on them.</p>
<p>Have a look at the following example:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val resultantMap = (0..10).asSequence().asStream() 
              .collect(Collectors.toMap&lt;Int,Int,Int&gt;({ 
                  it 
              },{ 
                  it*it 
              })) 
      println("resultantMap = $resultantMap") 
  } </pre>
<p>In this program, we have used the simplest version of the <kbd>Collectors.toMap()</kbd> function. We passed two lambdas to it, the first one, determining the key for the entry will return the same value passed to it, the second one, on the other hand, computing and returning the square of the value passed. The important thing to note here is that both the lambdas will have the same parameter.</p>
<p>The output is shown as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3689bcd5-aafe-4565-b7d2-1cb5d9932bf7.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Joining Stream of strings – Collectors.joining()</h1>
                </header>
            
            <article>
                
<p>The <kbd>Collectors.joining()</kbd> function helps you join elements of a Stream, containing strings. It has three optional parameters, namely—<kbd>delimiter</kbd>, <kbd>prefix</kbd>, and <kbd>postfix</kbd>.</p>
<p>Consider the following example of the program:</p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val resultantString = Stream.builder&lt;String&gt;() 
              .add("Item 1") 
              .add("Item 2") 
              .add("Item 3") 
              .add("Item 4") 
              .add("Item 5") 
              .add("Item 6") 
              .build() 
              .collect(Collectors.joining(" - ","Starts Here=&gt;","&lt;=Ends   Here")) 
 
      println("resultantString $resultantString") 
  } </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/618b5cbc-e614-41a3-b846-a98955c87cc7.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Grouping elements of Stream – Collectors.groupingBy()</h1>
                </header>
            
            <article>
                
<p>This function lets us collect the elements of a Stream into a <kbd>Map</kbd> function while grouping them. The basic difference of this function with <kbd>Collectors.toMap</kbd> is that this function lets you create a <kbd>Map&lt;K,List&lt;T&gt;&gt;</kbd> function, that is, it lets you create a <kbd>Map</kbd> function that will hold a <kbd>List</kbd> value as its value for each of the groups.</p>
<p>Consider the following example: </p>
<pre>  fun main(args: Array&lt;String&gt;) { 
      val resultantSet = (1..20).asSequence().asStream() 
              .collect(Collectors.groupingBy&lt;Int,Int&gt; { it%5 }) 
      println("resultantSet $resultantSet") 
  } </pre>
<p>The output is as follows:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img height="133" width="323" src="assets/d9845b5e-654c-4512-9e5d-362cafc3a4aa.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>So, in this chapter, we learned about Streams. We learned how to create Streams, learned how to work with Streams, and how to repackage a Stream into Collections.</p>
<p>In the next chapter, we will get started with the Arrow library, which makes it easy to implement functional programming in Kotlin. So, don't just wait, turn the page and get started with Arrow.</p>


            </article>

            
        </section>
    </body></html>