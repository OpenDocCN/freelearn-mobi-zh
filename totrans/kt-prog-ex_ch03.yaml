- en: Implementing Tetris Logic and Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we embarked on the development of the classic game
    *Tetris*. We determined the layout requirements of our application and implemented
    the layout elements we identified. In the process, we created two activities for
    the application: `MainActivity` and `GameActivity`. We also implemented the basic
    characteristics and behaviors of the views, but nothing pertaining to the core
    gameplay of the app was done. In this chapter, we are going to implement this
    gameplay. Over the course of this chapter, you will learn about the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Model-View-Presenter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Tetris gameplay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are concerned with implementing gameplay, the activity that we will focus
    on developing further in this chapter is `GameActivity`. The following screenshot
    shows the final product of all the development done in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6aba391-1b5b-4a5f-afb3-2d658b51b417.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have an idea of what the final game is going to look like, let's
    get going with its development.
  prefs: []
  type: TYPE_NORMAL
- en: Under the section *Understanding Tetris* in [Chapter 2](kt-prog-ex_ch02.html), *Building
    an Android Application – Tetris* we got to understand that Tetris is a puzzle-matching
    game that makes use of tiles. These tiles combine to form bigger shapes called
    tetrominoes. As a reminder, a tetromino is a geometric shape composed of four
    squares connected orthogonally.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling a tetromino
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As tetrominoes are very crucial to the gameplay of Tetris, we must properly
    model these elements programmatically. In order to do this, let's think of every
    tetromino piece as a building block. Building blocks have a set of features that
    they possess. These features can be categorized into characteristics and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of a block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are some characteristics that a block possesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shape**: A block has a fixed shape that cannot be changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dimensions**: A block possesses dimensional characteristics. These characteristics
    are height and width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Color**: A block always possesses a color. The color a block possesses is
    fixed and is maintained throughout the course of its existence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spatial characteristic**: A block takes up a fixed amount of space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Positional characteristic**: At any given point in time, a block has a position
    that exists in along two axes, – *X* and *Y*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behaviors of a block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main behavior of a block is its ability to experience distinct motions.
    These motions are translational motion and rotational motion. Translational motion
    is a type of motion in which a body shifts from one point in space to another.
    In Tetris, a block can experience leftward, rightward, and downward translational
    motions. Rotational motion is a type of motion that exists in rigid bodies and
    follows a curved path. In other words, rotational motion involves the rotation
    of an object in free space. All blocks in Tetris can be rotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the basic characteristics and behaviors of a block,
    you may be wondering how we can translate them to be relevant to tetrominoes.
    The truth is no translation of these characteristic features is necessary. All
    characteristics of a block apply to a tetromino. The only two things to keep in
    mind are:'
  prefs: []
  type: TYPE_NORMAL
- en: Tetrominoes are made up of four tiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All tiles in a tetromino are orthogonally arranged
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having said that, let's get to translating these characteristics into programmatic
    models. We will start with modeling shape.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling block shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The approach used to modeling shape varies depending on numerous variables,
    such as the kind of shape that must be measured and in what spacial dimension
    the shape is to be modeled. Modeling three-dimensional shapes—all things being
    equal—is more difficult than modeling two-dimensional shapes. Lucky for us, tetrominoes
    are two-dimensional in nature. Before we start modeling our shapes programmatically,
    it is important we know the exact shapes we are attempting to model. There are
    seven fundamental tetromino pieces that exist in Tetris. These pieces are the
    O, I, T, L, J, S and Z tetrominos. The following image shows the fundamental tetromino
    shapes that exist in Tetris:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c708a0f-28ff-409d-afa6-0cb42c2882e2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All preceding shapes take up space within the confines of their edges. The area
    of space covered by a shape can be seen as an outline or a frame. This is similar
    to how a picture is held within a frame. We need to model this frame that will
    contain individual shapes. As the shapes being held within the frame are two-dimensional
    in nature, we will utilize a two-dimensional byte array to hold frame-specific
    information. A byte is a digital unit of information that generally consists of
    eight bits. A bit is a binary digit. It is the smallest unit of data in a computer
    and has a value of either 1 or 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to model the frame of a shape with a two-dimensional array by representing
    areas covered by the frame with a byte value of 1 and those not covered by it
    with a value of 0. Take the following frame, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72cbf058-414b-432d-ae4c-4c861b69d2aa.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Instead of visualizing it as a whole shape, we can visualize it as a two-dimensional
    array of bytes possessing two rows and three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf833d5a-b988-4f3e-985e-eb02c07a211c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A byte value of 1 is assigned to cells in the array that make up the frame''s
    shape. On the other hand, a byte value of 0 is assigned to cells that are not
    part of the frame''s shape. Modeling this with a class is fairly easy. Firstly,
    we will need a function that generates the required byte array structure we will
    use for storing frame bytes. Create a new package within your source package and
    give it the name `helpers`. Within this package, create a `HelperFunctions.kt` file.
    This file will contain all helper functions used in the course of the development
    of this app. Open `HelperFunctions.kt` and type the following code into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines a `array2dOfByte()` function, which takes two arguments.
    The first argument is the desired row number of the array to be generated and
    the second is the desired column number of the generated byte array. The `array2dOFByte()` method
    generates and returns a new array with the specified properties. Now that we have
    our byte array generating helper function set up, let''s go ahead and create the
    `Frame` class. Create a new package within your source package and give it the
    name `models`. All object models will be packaged within this created package.
    Within the `models` package, create a `Frame` class in the `Frame.kt` file and
    type the following code into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Frame` class has two properties: `width` and `data`. Width is an integer
    property that holds the desired width of the frame to be generated (the number
    of columns in the frame''s byte array). The data property holds an array list
    of elements in the `ByteArray` value space. We declare two distinct functions,
    `addRow()` and `get()`. `addRow()` takes a string, converts each individual character
    of the string into a byte representation, and adds the byte representation into
    a byte array, after which it adds the byte array to the data list. `get()` converts
    the data array list into a byte array and returns the array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having modeled a suitable frame to hold our block, we can go ahead and model
    the distinct shapes of possible tetrominoes in the game. In order to do this,
    we will make use of an `enum` class.  Create a `Shape.kt` file in the models package
    before proceeding. We will start by modeling the following simple tetromino shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18286cf8-7f71-4e2f-9bf2-7288fa033d5b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Applying the concept of envisioning frames as a two-dimensional array of bytes,
    we can envision the frame of the preceding shape as a two-dimensional array of
    bytes with four rows and a single column with each cell filled with the byte value
    of `1`. With this in mind, let''s model the shape. In `Shape.kt`, create a `Shape`
    enum class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An `enum` class is declared by placing the `enum` keyword before the `class`
    keyword. The primary constructor of the preceding `Shape` enum class takes two
    arguments. The first argument is `frameCount`, which is an integer variable that
    specifies the number of possible frames a shape can be in. The second argument
    is `startPosition`, which specifies the intended start position of the shape along
    the *X* axis within the gameplay field. Further down the `enum` class file, a
    `getFrame()` function is declared. There''s a notable difference between this
    function and the functions we have declared until now. `getFrame()` has been declared
    with the abstract keyword. An abstract function possesses no implementation (thus
    no body) and is used to abstract a behavior that must be implemented by an extending
    class. Let''s scrutinize the following lines of code within the `enum` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, an instance of the `enum` that provides an implementation
    of the declared abstract function is being created. The instance''s identifier
    is `Tetromino`. We passed the integer value `2` as the argument for both the `frameCount`
    and `startPosition` properties of the `Tetromino`''s constructor. In addition,
    `Tetromino` provides an implementation for the `getFrame()` function in its corresponding
    block by overriding the `getFrame()` function declared in `Shape`. Functions are
    overriden with the `override` keyword. The implementation of `getFrame()` in `Tetromino`
    takes a `frameNumber` integer. This frame number determines the frame of `Tetromino`
    that will be returned. You may be asking at this point why `Tetromino` possesses
    more than one frame. This is simply a result of the possibility of rotation of
    a tetromino. The single-column tetromino we previously looked at can be rotated
    either leftwards or rightwards to take the form shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5004bafa-4a1f-4859-9f68-379817672dfe.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When `frameNumber` passed to `getFrame()` is `0`, `getFrame()` returns a `Frame`
    object that models the frame for the `Tetromino` in its horizontal state, as shown
    earlier. When `frameNumber` is `1`, it returns a frame object modeling the shape
    in its vertical state.
  prefs: []
  type: TYPE_NORMAL
- en: In the case that `frameNumber` is neither `0` nor `1`, an `IllegalArgumentException`
    is thrown by the function.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that along with being an object, `Tetromino` is a constant.
    Generally, `enum` classes are used to create constants. An `enum` class is a perfect
    choice for modeling our tetromino shapes because we have a fixed set of shapes
    that we need to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having understood how the `Shape` enum class works, we can model the rest of
    the possible tetromino shapes as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with one frame and a start position of 1\. The
    tetromino modeled here is the square or 'O' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with two frames and a start position of 1\. The
    tetromino modeled here is the 'Z' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with two frames and a start position of `1`.
    The tetromino modeled here is the 'S' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with two frames and a start position of 2\. The
    tetromino modeled here is the 'I' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with four frames and a start position of 1\.
    The tetromino modeled here is the 'T' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with four frames and a start position of 1. The
    tetromino modeled here is the 'J' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a tetromino shape with four frames and a start position of 1\.
    The tetromino modeled here is the 'L' shaped tetromino.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Having modeled both the block frame and shape, the next thing we must model
    programmatically is the block itself. We will use this as an opportunity to demonstrate
    Kotlin''s seamless interoperability with Java by implementing the model with Java.
    Create a new Java class in the `models` directory (models | New | Java Class)
    with the name `Block`. We will start the modeling process by adding instance variables
    that represent the characteristics of a block. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we add four instance variables: `shapeIndex`,
    `frameNumber`, `color`, and `position`. `shapeIndex` will hold the index of the
    shape of the block, `frameNumber` will keep track of the number of frames the
    block''s shape has, `color` will hold the color characteristic of the block, and
    `position` will be used to keep track of the block''s current spatial position
    in the gaming field.'
  prefs: []
  type: TYPE_NORMAL
- en: An `enum` template, `BlockColor`, is added within the `Block` class. This `enum`
    creates a constant set of `BlockColor` instances, with each possessing `rgbValue`
    and `byteValue` properties. `rgbValue` is an integer that uniquely identifies
    an RGB color specified with the `Color.rgb()` method. `Color` is a class provided
    by the Android application framework and `rgb()` is a class method defined within
    the `Color` class. The five `Colour.rgb()` calls specify the colors pink, green,
    orange, yellow, and cyan, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In `Block`, we made use of the `private` and `public` keywords. These were not
    added for eye candy; they each have a use. These two keywords, along with the
    `protected` keyword, are called access modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access modifiers are keywords used to specify access restrictions on classes,
    methods, functions, variables, and structures. Java has three access modifiers:
    `private`, `public`, and `protected`. In Kotlin, access modifiers are called visibility
    modifiers. The available visibility modifiers in Kotlin are `public`, `protected`,
    `private`, and `internal`.'
  prefs: []
  type: TYPE_NORMAL
- en: Private access modifier (private)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Methods, variables, constructors, and structures that are declared private
    can only be accessed within the declaring class. This is with the exception of
    private top-level functions and properties that are visible to all members of
    the same file. Private variables within a class can be accessed from outside the
    class be declaring getter and setter methods that permit access. Defining setter
    and getter methods in Java is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, setter and getter creation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using the private access modifier is the main means of information hiding within
    programs. Information hiding is also known as encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: Public access modifier (public)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Methods, variables, constructors, and structures declared public can be accessed
    freely from outside the declaring class. A public class existing in a different
    package from an accessing class must be imported before it can be used. The following
    class makes use of the public access modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Protected access modifier (protected)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables, methods, functions, and structures declared protected can be accessed
    only by classes in the same package as the defining class or by subclasses of
    their defining class that exist in a separate package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Internal visibility modifier (internal)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The internal visibility modifier is used to declare a member visible within
    the same module. A module is a collection of Kotlin files compiled together. 
    A module may be a Maven project, a Gradle source set, and IntelliJ IDEA module,
    or a set of files compiled with an Ant task invocation. Using the internal modifier
    is similar to using other visibility modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Having understood access and visibility modifiers, we can continue with the
    implementation of the `Block` class. The next thing we need to do is create a
    constructor for the class that initializes the instance variables we have created
    to their initial states. Constructor definitions in Java are syntactically different
    from Kotlin constructor definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the constructor definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the preceding constructor definition has been given private access.
    We did this because we do not want this constructor to be accessed outside of `Block`.
    As we still want other classes to have a means of creating a block instance, we
    have to define a static method that permits this. We will call this method `createBlock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the Constructor definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`createBlock()` randomly selects the index of a tetromino shape in the `Shape`
    enum class and a `BlockColor` and assigns two randomly selected values to `shapeIndex`
    and `blockColor`. A new `Block` instance is created with the two values passed
    as arguments and the position of the block along the *X* axis is set. Lastly,
    `createBlock()` returns the created and initialized block.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a few getter and setter methods to `Block`. These methods will
    give access to crucial properties of instances of the block. Add the following
    methods to the `Block` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`@NonNull` is an annotation provided by the Android application framework that
    denotes that a field, parameter, or method return can never be null. In the preceding
    code snippet, it is used in the line prior to the `getShape()` method definition
    to denote that the method cannot return a null value.'
  prefs: []
  type: TYPE_NORMAL
- en: In Java, an annotation is a form of metadata that can be added to Java source
    code. Annotations can be used on classes, methods, variables, parameters, and
    packages. Annotations can also be declared and used in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@NotNull` annotation exists in the `android.support.annotation` package.
    Add the package import to the package imports at the top of `Block.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one last thing we should take care of in the `Block` class before
    moving on. In the final line of the `Block` constructor, the position of the current
    block instance''s position instance variable is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `10` is the column count of the field in which the tetrominoes will be
    generated. This is a constant value that will be used several times within the
    code for this application, and as such, is best declared as a constant. Create
    a package named constants in the base application source package and add a new
    Kotlin file with the name `FieldConstants` to the package. Next, add constants
    for the number of columns and rows that the playing field will possess. The field
    should possess ten columns and twenty rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the package with the `FieldConstants` enum class into `Block.java` and
    replace the `10` integer with the constant value of the `COLUMN_COUNT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We are done with the programmatic modeling of the `Block` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have been concerned with modeling specific components that make
    up tetromino blocks. Now it is time to concern ourselves with defining application
    logic. We will create an application model to implement the necessary Tetris gameplay
    logic, as well as to serve as an intermediary interface between views and the
    block components we have created.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ec55ffe-9589-494a-8b13-8f99d41bd288.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A view will send a request for the performance to the application model, and
    the model will execute the action if it is valid and send feedback to the view.
    Similar to the models we have created so far, we need a separate class file for
    the application model. Go ahead and create a new Kotlin file named `AppModel.kt`
    and add a class named `AppModel` to the file with imports for `Point`, `FieldConstants`,
    `array2dOfByte`, and `AppPreferences`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Some functions of `AppModel` are to keep track of the current score, the `tetris`
    gameplay field state, the current block, the current state of the game, the current
    status of the game, and the motions being experienced by the current block. `AppModel`
    must also have direct access to values stored within the application's `SharedPreferences`
    file via the `AppPreferences` class we created. Catering to these different demands
    may seem daunting at first, but is easy as pie.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we must do is add the necessary constants that will be utilized
    by `AppModel`. We will need to create constants for the possible game statuses
    and the possible motions that can occur during gameplay. These constants are created
    with ease with the use of `enum` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We created four status constants earlier. `AWAITING_START` is the status of
    the game before the game has been started. `ACTIVE` is the status in which the
    game exists when gameplay is currently in progress. `OVER` is the status that
    the game takes when the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, it was stated that four distinct motions can occur
    on a block. Blocks can be moved to the right, to the left, up, down, and rotated.
    `LEFT`, `RIGHT`, `UP`, `DOWN`, and `ROTATE` are defined in the `Motions` enum
    class to represent these distinct motions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having added the constants required, we can proceed by adding the necessary
    class properties of `AppModel`, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`score` is an integer property that will be used to hold the current score
    of the player within a gaming session. `preferences` is a private property that
    will hold an `AppPreferences` object to provide direct access to the application''s
    `SharedPreferences` file. `currentBlock` is a property that will hold the current
    block translating across the play field. `currentState` holds the state of the
    game. `Statuses.AWAITING_START.name` returns the name of `Statuses.AWAITING_START`
    in the form of an `AWAITING_START` string. The current state of the game is initialized
    to `AWAITING_START` immediately because this is the first state that `GameActivity`
    must transition into upon launch. Lastly, `field` is a two-dimensional array that
    will be used as the playing field for the game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we must add a few setter and getter functions. These functions are `setPreferences()`,
    `setCellStatus()`, and `getCellStatus()`. Add the following functions to `AppModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `setPreferences()` method sets the preferences property of `AppModel` to
    the `AppPreferences` instance passed as an argument to the function. The `getCellStatus()`
    method returns the status of a cell existing in a specified row-column position
    within the field's two-dimensional array. The `setCellStatus()` method sets the
    status of a cell existing in the field to a specified byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions for checking state are necessary in the model as well. These will
    serve as a medium to assert the state that the game is currently in. As we have
    three possible game statuses corresponding to three possible game states, three
    functions are required for each individual game state. These methods are `isGameAwaitingStart()`,
    `isGameActive()`, and `isGameOver()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All three methods return Boolean values of either `true` or `false` depending
    on whether the game is existing in their respective states. So far, we have not
    made use of the `score` in `AppModel`. Let's add a function that can be used to
    increase the score value held by the `score`. We will name the function `boostScore()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When called, `boostScore()` increases the current score of the player by 10
    points, after which it checks whether the current score of the player is greater
    than the high score recorded in the preferences file. If the current score is
    greater than the saved high score, the high score is overwritten with the current
    score.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having gotten the basic functions and fields up and running, we can progress
    to creating slightly more complicated functions. The first of these functions
    is `generateNextBlock()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `generateNextBlock()` function creates a new block instance and sets `currentBlock`
    to the newly created instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going any further with method definitions, let''s create one more `enum`
    class to hold constant cell values. Create a `CellConstants.kt` file in the constants
    package and add the following source code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You may be wondering what these constants are for. Recall when we created the
    `Frame` class to model a blocks frame, we defined `addRow()`, which took a string
    of 1s and 0s as its argument—with 1 representing cells that made up the frame
    and 0 representing cells excluded from the frame—and converted these 1s and 0s
    to byte representations. We are going to be manipulating these bytes in upcoming
    functions and we need to have corresponding constants for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the newly created `enum` class into `AppModel`. We will make use of
    it in the upcoming function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Add the preceding `validTranslation()` method to `AppModel`. As the name implies,
    this function is used to check whether a translational motion of a tetromino in
    the playing field is valid based on a set of conditions. It returns a `true` 
    Boolean value if the translation is valid, and `false` otherwise. The first three
    conditionals test whether the position the tetromino is being translated in the
    field to is a valid one. The `else` block checks whether the cells the tetromino
    is attempting to translate into are empty. If they are not, `false` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a calling function for `validTranslation()`. We will declare `moveValid()`
    to serve this purpose. Add the following function to `AppModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`moveValid()` utilizes `validTranslation()` to check whether a move performed
    by the player is permitted. If the move is permitted, it returns `true`, otherwise `false`
    is returned. We need to create a few other important methods. These are `generateField()`,
    `resetField()`, `persistCellData()`, `assessField()`, `translateBlock()`, `blockAdditionPossible()`,
    `shiftRows()`, `startGame()`, `restartGame()`, `endGame()`, and `resetModel()`.'
  prefs: []
  type: TYPE_NORMAL
- en: We will firstly work on the `generateField()` method. Add the code shown below
    to `AppModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`generateField()` generates a refresh of the field. This field refresh is determined
    by the action that is passed as the argument of `generateField()`.'
  prefs: []
  type: TYPE_NORMAL
- en: First, `generateField()` checks whether the game is currently in its active
    state when called. If the game is active, the frame number and coordinates of
    the block are retrieved. The action requested is then determined via the `when` expression.
    Having determined the requested action, the coordinates of the block are changed
    appropriately if the action requested is a leftward, rightward, or downward motion.
    If a rotational motion is requested, `frameNumber` is changed to an appropriate
    number of a frame that represents the tetromino in the rotation exerted.
  prefs: []
  type: TYPE_NORMAL
- en: The `generateField()` method then checks whether the motion requested is a valid
    motion via `moveValid()`. If the move is not valid, the current block is fixed
    in the field to its current position with the use of `translateBlock()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `resetField()`, `persistCellData()` and `assessField()` methods invoked
    by `generateField()` are given below. Add them to `AppModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, `translateBlock()` has not been implemented. Go ahead
    and add this method along with `blockAdditionPossible()`, `shiftRows()`, `startGame()`,
    `restartGame()`, `endGame()`, and `resetModel()` to `AppModel` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In a scenario where the requested move is a downward motion and the move is
    not valid, it implies that the block has reached the bottom of the field. In this
    case, the player''s score is boosted via `boostScore()` and the states of all
    cells in the field are persisted via `persistCellData()`. The `assessField()` method
    is then called to scan through the field row by row and check whether all cells
    in a row have been filled up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where all cells in a row are filled up, the row is cleared and
    shifted by `shiftRow()`. After the assessment of the field is complete, a new
    block is generated with `generateNextBlock()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the newly generated block can be pushed to the field, `AppModel` makes
    sure that the field is not already filled up and the block can be moved into the
    field with `blockAdditionPossible()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If block addition is not possible, that means all blocks have been stacked to
    the top edge of the field. This results in a game over. As a result, the current
    state of the game is set to `Statuses.OVER` and the `currentBlock` is set to `null`.
    Lastly, the field is cleared.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if the move was valid from the start, the block is translated
    to its new coordinates via `translateBlock()` and the state of the current block
    is set to its new coordinates and `frameNumber`.
  prefs: []
  type: TYPE_NORMAL
- en: With those additions in place, we have been able to successfully create the
    application model to handle the gameplay logic. Now we have to create a view that
    exploits `AppModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating TetrisView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, so good. We have successfully implemented classes to model blocks, frames,
    and shapes of different tetrominoes that will be used within the application,
    as well as implemented an `AppModel` class to coordinate all the interactions
    between views and these programmatic components created. Without this view existing,
    there is no means by which a user can interact with `AppModel`. If a user cannot
    interact with the game, the game might as well not exist. In this section, we
    will implement `TetrisView`, the user interface by which a user will play Tetris.
  prefs: []
  type: TYPE_NORMAL
- en: Create a package named `view` in your source package and add a `TetrisView.kt`
    file in it. As we want `TestrisView` to be a `View`, we must declare it to extend
    the View class. Add the code below to `TetrisView.kt`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `TetrisView` class is declared to extend `View`. `View` is a class that
    all application view elements must extend. As the `View` type has a constructor
    that must be initialized, we are declaring two secondary constructors for `TetrisView`
    that initialize two distinct constructors of the view class, depending on which
    secondary constructor is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `paint` property is an instance of `android.graphics.Paint`. The `Paint`
    class holds style and color information concerning how to draw texts, bitmaps,
    and geometries. `lastMove` will be used to keep track of the last time in milliseconds
    that a move was made. The `model` instance will be used to hold an `AppModel`
    instance that will be interacted with by `TetrisView` to control gameplay. Activity
    is an instance of the `GameActivity` class we created. The `cellSize` and `frameOffset`
    are properties that will hold dimensions for the size of cells in the game and
    the frame offset, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Neither `ViewHandler` nor `Dimension` is a class provided to us by the Android
    application framework. We must implement these two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ViewHandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As blocks will be moving along the fields in intervals with a constant time
    delay, we need a means of putting the thread that handles the movement of blocks
    to sleep and waking the thread to make a block motion after a period of time.
    A good way to take care of this requirement is to use a handler to process message
    delay requests and continue message handling after the delay has completed. Putting
    this in more direct terms, according to Android's documentation, *the handler
    allows you to send and process Message objects associated with a thread's MessageQueue*.
    Every handler instance is associated with a thread and the thread's message queue.
  prefs: []
  type: TYPE_NORMAL
- en: '`ViewHandler` is a custom handler we will implement for `TetrisView` that caters
    to the view’s message-sending and processing needs. As `ViewHandler` is subclass
    of `Handler`, we must extend `Handler` and add our necessary behavior to the `ViewHandler`
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `VieHandler` class as a private class within `TetrisView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `ViewHandler` class takes an instance of `TetrisView` as an argument in
    its constructor. `ViewHandler` overrides the `handleMessage()` function existing
    in its superclass class. `handleMessage()` checks that the what message was sent.
    The `what` is an integer value denoting the message sent. If `what` is equal to
    `0`, and the instance—owner—of `TetrisView` passed possesses a model that is not
    equal to `0`, some statuses of the game are checked. If the game is over, it will
    call `endGame()` of `AppModel` function and show a popup alerting the player that
    the game is over. If the game is in its active state, a down motion is fired.
  prefs: []
  type: TYPE_NORMAL
- en: The `sleep()` method simply removes any previously sent message and sends a
    new message with a delay specified by the delay argument.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Dimension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Dimension` only needs to be able to hold two properties: width and height.
    As such, it is a perfect candidate for the utilization of a data class. Add the
    following private class to the `TetrisView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The preceding one-liner provides us with the properties, as well as the setter
    and getters we need for them.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing TetrisView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have guessed, at this point `TetrisView` is far from completion.
    First and foremost we must implement a few setter methods for the `model` and
    `activity` properties of the view. These methods are shown below. Make sure to
    add them to your `TetrisView` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`setModel()` and `setActivity()` are setter functions for the model and activity
    instance properties. As the names imply, `setModel()` sets the current model in
    use by the view and `setActivity()` sets the activity in use. Now, let us add
    three additional methods `setGameCommand()`, `setGameCommandWithDelay()` and `updateScore()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`setGameCommand()` sets the current motion command being executed by the game.
    If a `DOWN` motion command is in execution, the application model generates the
    field for a block experiencing a downward motion. The `invalidate()` method being
    called within `setGameCommand()` can be taken as a request to draw a change on
    the screen. `invalidate()` ultimately results in a call to `onDraw()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`onDraw()` is a method that is inherited from the `View` class. It is called
    when a view should render its content. We will need to provide a custom implementation
    of this for our view. Add the code below to your `TetrisView` class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `onDraw()` method in `TetrisView` overrides the `onDraw()` in its superclass.
    `onDraw()`, takes a canvas object as its only argument and must call the `onDraw()`
    function in its superclass. This is done by invoking `super.onDraw()` and passing
    the canvas instance as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: After invoking `super.onDraw()`, `onDraw()` in `TetrisView` invokes `drawFrame()`,
    which draws the frame for `TetrisView`. After which, individual cells are drawn
    within the canvas by utilizing the `drawCell()` functions we created.
  prefs: []
  type: TYPE_NORMAL
- en: The `setGameCommandWithDelay()` works similarly to `setGameCommand()` with the
    exception that updates the game score and it puts `viewHandler` to sleep after
    executing the game command. The `updateScore()` function is used to update the
    current score and high score text views in game activity.
  prefs: []
  type: TYPE_NORMAL
- en: The `onSizeChanged()` is a function that is called when the size of a view has
    changed. The function provides access to the current width and height of the view,
    as well as its former width and height. As with other overriden functions we have
    used, we invoke its counterpart function in its super class. We use the width
    and height arguments provided to us to calculate and set dimensions for the size
    of each cell—`cellSize`. Finally, in `onSizeChanged()`, the `offsetX` and `offsetY`
    are calculated and used to set `frameOffset`.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up GameActivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you have successfully implemented the views, handlers, helper functions,
    classes, and models necessary to put the Tetris game together. Now we are going
    to finish up the work we started by putting it all together in `GameActivity`.
    The first thing on our agenda is to add the newly created `tetris` view to the
    game activity''s layout. We can easily add `TetrisView` as a child element anywhere
    within a layout file by utilizing the `<com.mydomain.tetris.views.TetrisView>`
    layout tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have added the `tetris` view to `activity_game.xml`, open the `GameActivity`
    class and employ the changes to the class shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We added an object reference to the `tetris` view layout element in `activity_game.xml`
    in the form of the `tetrisView` property; we also created an instance of `AppModel`
    that will be used by `GameActivity`. In `oncreate()`, we set the activity in use
    by `tetrisView` to the current instance of the `GameActivity` and set the model
    in use by `tetrisView` to `appModel` – the `AppModel` instance property we created.
    In addition, the on-touch listener for `tetrisView` was set to the `onTetrisViewTouch()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: If `tetrisView` is touched and the game is in an `AWAITING_START` or `OVER`
    state, a new game is started. If `tetrisView` is touched and the game is in its
    `ACTIVE` state, the direction in which the touch on `tetrisView` occurred is resolved
    with the help of `resolveTouchDirection()`. `moveTetromino()` is used to move
    a tetromino block based on the action passed to it. If a left touch occurred,
    `moveTetromino()` is called with `AppModel.Motions.LEFT` set as its argument.
    This results in the movement of the tetromino to the left on the field. Right,
    down, and up touches on `tetrisView` result in rightward, downward, and rotational
    motions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having made all the additions, build and run the project. Once the project
    launches on your desired device, navigate to game activity and touch the `tetris`
    view to the right of the screen. The game will start:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47512283-ebce-429b-aa3c-9014c625a66d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to play around with the game you created. You deserve it!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Model-View-Presenter (MVP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of developing the Tetris application, we attempted to add structure
    across our code base by separating out program files into different packages based
    on the tasks they performed. We tried to abstract application logic into the `AppModel`
    class, and user interactions related to gameplay to be handled by the `TetrisView`
    view class. This certainly brought some order into our code base in contrast with,
    say, putting all logic into one big class file.
  prefs: []
  type: TYPE_NORMAL
- en: Needless to say, there are better ways to separate concerns within an Android
    application. One way is the MVP pattern.
  prefs: []
  type: TYPE_NORMAL
- en: What is MVP?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVP is a common pattern in Android that is derived from the **Model-View-Controller** (**MVC**)
    pattern. MVP attempts to view related concerns from application logic. There are
    many reasons for which this is done, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: To increase the maintainability of a code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve application reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c1c00988-da9a-422a-80ae-784431176d2f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's familiarize ourselves with the actors in the MVP pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MVP, models are interfaces that have the task of managing data. The responsibilities
    of models include interacting with databases, making API calls, communicating
    over networks, and coordinating objects and other programmatic components to perform
    specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Views are application entities that display content to users and serve as an
    interface for user input. A view can be an activity, a fragment, or an Android
    widget. A view is responsible for rendering data in a way decided upon by the
    presenter.
  prefs: []
  type: TYPE_NORMAL
- en: Presenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A presenter is a layer that acts as a middleman between a view and a model.
    The major responsibility of the presenter is querying the model and updating a
    view. Put simply, presentation logic goes into the presenter. An important thing
    to keep in mind is that a presenter has a one-to-one relationship with a view.
  prefs: []
  type: TYPE_NORMAL
- en: Varying implementations of MVP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MVP pattern has varying means by which it is implemented in practice. For
    example, some implementations of MVP utilize a *contract* to describe the interaction
    between the view and presenter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are implementations of MVP that utilize lifecycle callbacks
    within the presenter, such as `onCreate()`. This is in an attempt to mirror callbacks
    existing in the activity lifecycle. Other implementations discard the implementation
    of these callbacks entirely.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, there is no one true implementation of MVP in Android applications,
    but there are best practices that can be followed while implementing MVP. You
    will learn about these best practices and have hands-on experience with developing
    an MVP application with Kotlin in [Chapter 5](kt-prog-ex_ch05.html), *Building
    the Messenger Android App*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got down and dirty with Kotlin by implementing a classic
    game, *Tetris*. Over the course of this chapter, we learned about a vast array
    of things, such as how to model logical components of an application with classes,
    access and visibility modifiers, how to create views and handlers in Android applications,
    the utilization of data classes to easily create data models, and the MVP pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will apply our knowledge of Kotlin to the web domain
    by implementing the backend of a messenger application.
  prefs: []
  type: TYPE_NORMAL
