- en: Chapter 10. Best Practices and Securing Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Android operating system was designed in anticipation of hackers attempting
    to perform common attacks, such as social engineering attacks that try to trick
    the user into handing over their personal information or installing malware.
  prefs: []
  type: TYPE_NORMAL
- en: Android comes with built-in security features that significantly reduce the
    chances of security exploits succeeding, and that limit the impact of any attacks
    that *do* succeed.
  prefs: []
  type: TYPE_NORMAL
- en: These built-in security controls provide you, your application, and your users
    with a certain level of protection by default. Nevertheless, following security
    best practices is essential for further reducing the chances of your app leaving
    users vulnerable to exploits, data leaks, and other security-related issues.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to look at how you can make the most of Android's
    built-in security features. Towards the end of this chapter, I'll also look at
    some best practices we haven't covered in detail in any of the previous chapters,
    including how to design more effective notifications and ensuring that your app
    is accessible to all users.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping user data secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common security concern for your typical Android user is whether the
    applications they've chosen to install can access the sensitive data stored on
    their device.
  prefs: []
  type: TYPE_NORMAL
- en: If your app has access to the user's data, then you have a responsibility to
    make sure that data remains secure. One of the quickest and easiest ways of protecting
    user data is to take a long hard look at whether your app really needs access
    to this data at all. If you minimize the data your app has access to in the first
    place, then you minimize the risk of your app inadvertently exposing personal
    information. You also reduce the chances of attackers being tempted to try and
    exploit your application in order to gain access to the sensitive data it's privy
    to. You should always be on the lookout for ways to create the same effect *without*
    your app requiring direct access to sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, don't store usernames or passwords on the user's device.
    Instead, your app should perform initial authentication using the username and
    password supplied by the user, and then switch to a short-lived, service-specific
    authorization token.
  prefs: []
  type: TYPE_NORMAL
- en: To help protect your users from phishing attacks, you should also minimize the
    number of times your app asks for user credentials. This way, a phishing attack
    is more likely to strike the user as suspicious, as it'll be out of character
    for your app to ask for sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your app does need access to passwords and usernames, keep in mind that you
    may be legally required to provide a privacy policy explaining how your app uses
    and stores this data.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Network transactions pose an inherent security risk, particularly since mobile
    users are more likely to connect to unsecured wireless networks such as public
    Wi-Fi hotspots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever your app connects to a network, it''s crucial that you implement the
    following best practices, in order to help keep your users safe:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `HTTPS` over `HTTP` wherever possible. Also, never automatically trust *any*
    data downloaded from insecure protocols such as `HTTP`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement authenticated, encrypted, socket-level communication using the `SSLSocket`
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're handling sensitive IPC, use an Android IPC mechanism that can authenticate
    the identity of the application connecting to your IPC, such as a `Binder`, `Intent`, `BroadcastReceiver`,
    or `Messenger with a Service`. This is more secure than using localhost network
    ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use unauthenticated SMS data to perform sensitive commands. SMS are neither
    encrypted nor strongly authenticated by default, and are therefore susceptible
    to interception on the network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When sending data messages from a web server to your app, you should use the **Google
    Cloud Messaging APIs** and IP networking wherever possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android N also introduces the concept of a **network security configuration**
    file, which you can use to create custom network security settings for your app
    without having to modify your actual application code. You can use this new network
    security configuration file to:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify which certificate authorities are trusted for your app's secure connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict an app's secure connections to specific, named certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug secure connections in your app without added risk to the installed base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect apps from accidentally using clear-text traffic, which is a particular
    security risk as it transmits potentially sensitive data in a human-readable format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a network security configuration file, create a new XML values resource
    file with the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then reference this file in your project''s Manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of a simple network configuration file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Requesting permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android devices do a lot—from snapping photos and recording videos, to providing
    directions, posting to social media, and sending SMS messages. This means your
    typical Android device has access to *huge* amounts of sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that Android does a lot to help keep this information secure.
    The platform is based on a privilege-separated system where apps run separately
    from one another and from the system, in a limited-access sandbox. This restricts
    the data and features each app has access to. By default, no Android app has permission
    to perform any operation that could adversely affect the operating system, the
    user, or other applications, which helps prevent malicious apps from corrupting
    data or accessing sensitive information. These permissions also restrict each
    app's access to device features not provided by the basic sandbox, protecting
    the user from apps making unauthorized use of hardware (such as accessing the
    device's camera) or external communication channels (such as connecting to the
    Internet).
  prefs: []
  type: TYPE_NORMAL
- en: However, there are legitimate reasons why your app might need to access the
    user's information or device capabilities, such as an SMS app that requires access
    to your contacts list or a video recording app that needs to access the device's
    camera. If your app does require access to protected information or features,
    then you'll need to prompt the user for access. The user then has the choice to
    accept or deny this permission request.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, Android apps requested all the permissions they might possibly need
    up front before the user could even download the app from Google Play. If the
    user didn't want to grant the app one or more of the requested permissions, their
    only option was to abandon the installation altogether, and go looking for an
    alternative app.
  prefs: []
  type: TYPE_NORMAL
- en: Android 6.0 completely overhauled this permissions model, replacing it with
    new **runtime permissions**.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Android 6.0, apps request permissions one by one while the app
    is running, as and when that app requires access to protected services, data,
    or device features.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine you'd developed a note-taking app that supports traditional
    text notes, but also gives users the option to record voice memos. Before Android
    6.0, the user would have to grant this app permission to access the microphone
    at install time. However, under the new permissions model, the user can launch
    your note-taking app and write as many text memos as they want, potentially without
    the app ever requesting access to the microphone. Your app will only request microphone
    access when the user tries to record a voice memo for the first time, as this
    permission is required to complete the current task.
  prefs: []
  type: TYPE_NORMAL
- en: In Android 6.0 and higher, users can change an app's permissions manually at
    any time, by opening their device's **Settings** and selecting **Apps**. At this
    point, they'll see a list of all the apps installed on their device. They can
    then select any app from the list, and tap **Permissions** to see all the permission
    categories this particular app has access to.
  prefs: []
  type: TYPE_NORMAL
- en: '![Requesting permissions](img/B05061_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The user can revoke any permission, by dragging that permission's slider to
    the **Off** position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Requesting permissions](img/B05061_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This new permission model has a number of benefits for both users and developers:'
  prefs: []
  type: TYPE_NORMAL
- en: The user no longer has to read through a list of permissions before they can
    install an app, which makes for a more streamlined installation process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you release an update that requires new permissions, previously the user
    had to accept these permissions before they could install the update. In Android
    6.0 and higher, apps update automatically and will then make any new permission
    requests associated with the update, as and when (and if) those permissions are
    required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users have more control over the information and features each app has access
    to. The new permission model gives users the option to deny individual permission
    requests, something that wasn't possible in previous versions of Android. For
    example, a user who has downloaded an image-editing app may be happy to give that
    app access to their gallery, but more hesitate to grant that same app access to
    their device's camera. In previous versions of Android, the user *had* to grant
    that app all the permissions it requested up front, or not install the app at
    all. However in Android 6.0 and higher, the user is free to deny the app access
    to their camera, if they're not comfortable with that particular permission request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users are more likely to understand why your app is requesting each permission,
    as requests now happen in context when the user is trying to access a related
    feature for the first time. And when users understand why your app is requesting
    access to sensitive information or device features, they're more likely to grant
    those requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new permissions model – backwards compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Under the new permissions model, users can revoke any permission they've previously
    granted to any app, at any time, even if that app targets API level 22 or lower.
    This means you need to test that your app continues to function normally if the
    user denies one or more of its permission requests—*regardless* of your app's `targetSdkVersion`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, if your app winds up on a device running Android 5.1 (API level 22)
    or lower, *or* your app's `targetSdkVersion` is 22 or lower, the system defaults
    to the old permissions model and makes all permission requests up front, at install
    time. If the user denies these permissions requests, then the system won't install
    the app. Similarly, if you add a new permission to an updated version of your
    app, the system will ask the user to grant these new permissions before they can
    install the update.
  prefs: []
  type: TYPE_NORMAL
- en: However, users can *still* revoke previously granted permissions manually by
    selecting their device's **Settings**, followed by **Apps**, and then selecting
    your app from the list.
  prefs: []
  type: TYPE_NORMAL
- en: If your app targets an earlier version of the Android platform and you *haven't*
    accounted for the new permissions model, your app may no longer function normally
    (or at all) if the user chooses to revoke one or more of your app's permissions
    manually. The system will warn the user that revoking permissions for apps targeting
    earlier versions of Android can cause the app in question to stop working, but
    the user still has the option to go ahead and revoke these permissions, if they
    really want to.
  prefs: []
  type: TYPE_NORMAL
- en: Even if your app targets pre-6.0 versions of the Android platform only, you
    shouldn't just assume that you can ignore the new permissions model. You should
    still aim to create an app that provides a good user experience, even if the user
    chooses to revoke some (or all) of its previously granted permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Permission groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android''s permissions are divided into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal permissions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions give your app access to data or resources outside of its sandbox,
    but pose very little direct risk to the user's privacy, the operation of the device,
    or to other apps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you declare that your app requires a normal permission in its `Manifest`,
    the system will automatically grant your app that permission.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Dangerous permissions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions give your app access to data or resources that could pose
    a risk to the user's privacy, or that may affect the user's stored data, other
    apps, or the device's normal operation. For example, being able to read the user's
    contacts list is considered a dangerous permission.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the user's device is running Android 6.0 (API Level 23) or higher *and* your
    app's `targetSdkVersion` is 23 or higher, then dangerous permissions trigger a
    permission request only when the user tries to perform an operation that requires
    this permission. For example, if your app requires the `READ_CONTACTS` permission,
    the system may ask for that permission the first time the user tries to create
    an SMS message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your app winds up on a device running Android 5.1 or lower, or its `targetSdkVersion`
    is 22 or lower, the Android system will ask the user to grant all dangerous permissions
    at install time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In addition to the *normal* and *dangerous* ratings, Android groups related
    permissions into permission groups. When your app requests access to a permission,
    the user will be presented with a dialogue requesting access to that entire permissions
    group.
  prefs: []
  type: TYPE_NORMAL
- en: If your app requests a dangerous permission and the user has already granted
    your app access to another dangerous permission from that same group, the system
    will grant that permission automatically without requiring any additional input
    from the user.
  prefs: []
  type: TYPE_NORMAL
- en: This approach helps mobile users make more informed decisions about what parts
    of their device and what information each app should have access to *without*
    overwhelming them with technical information or too many permission requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions are divided into nine groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Calendar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microphone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you develop your app, make a note every time your app requires access to
    resources or information that it doesn't create itself, or whenever it attempts
    to perform actions that could impact the user's privacy, the behavior of other
    apps, or the device in general. Most of the time these actions will require your
    app to make a permissions request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a permission, open your project''s `Manifest` and add a `<uses-permission>`
    element as a child of the top-level `<manifest>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the string resources for this permission''s label and description
    might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Verifying permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your app won't always need to ask for permission to access protected information
    or features—if your app currently has access to the microphone, then it won't
    need to request this permission, for example. However, since users running Android
    6.0 and higher can revoke previously granted permissions at any time, your app
    will need to check whether it currently has access to protected information or
    features, every time it needs to act on the related permission. Even if the user
    granted this permission previously, in Android 6.0 and higher there's no guarantee
    the user hasn't manually revoked that permission at some point.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine whether your app currently has permission to access information
    or features, you need to call the `ContextCompat.checkSelfPermission()`method.
    For example, this code snippet shows you how to check whether your app has permission
    to access the Internet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ContextCompat.checkSelfPermission()` is available as part of revision 23 of
    the `support-v4 library` for backwards compatibility ([http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&utm_source=dac&utm_medium=blog#v4](http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&utm_source=dac&utm_medium=blog#v4)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your app currently has access to the requested permission, `ContextCompat.checkSelfPermission`
    will return `PackageManager.PERMISSION_GRANTED` and your app can proceed with
    the operation. If the user hasn''t granted your app this permission, or they granted
    the permission but then revoked it at some point, this method returns `PackageManager.PERMISSION_DENIED`
    and you''ll need to request that permission by calling one of the `requestPermission`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Handling the permissions request response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When your app makes a permission request, the system presents a dialogue to
    the user. When the user responds, the system invokes your app''s `onRequestPermissionsResult()`
    method and passes it the user''s response. To find out whether the user has granted
    or denied the permission request, your app needs to override that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Permissions and <uses-feature>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's possible that your app may rely on certain hardware or software features
    being present on the user's device, for example your typical camera app will almost
    certainly require a device with camera hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent users from installing your app on devices that don''t have the hardware
    or software necessary to support it, you need to add the `<uses-feature`> declaration
    to your project''s `Manifest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You then specify whether your app requires this feature to function at all
    (`true`) or whether it prefers to have this feature but can function without it
    if necessary (`false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Although the Android system won't check your app's `Manifest` for `<uses-feature>`
    elements, Google Play does use your app's `<uses-feature>` elements to decide
    whether your app is compatible with the user's device. Google Play won't allow
    any user to install an app that it deems incompatible with their device's hardware
    or software.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you add `<uses-feature>` elements to your `Manifest` but don't include the `android:required`
    attribute, Google Play assumes that your app requires this feature (`android:required="true"`).
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you should declare all your project's hardware and software requirements,
    but there are a few safeguards in place just in case you forget to mention one
    or more `<uses-feature>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Google Play checks your app's *regular* permissions for any implicit hardware-related
    features. If it finds any, it adds the corresponding hardware or software feature
    to your app's metadata, and then takes these into account when deciding whether
    each potential user can or cannot install your app.
  prefs: []
  type: TYPE_NORMAL
- en: This does help to prevent users from downloading incompatible apps, but it can
    also be a bit of a nuisance. Imagine your app requests `android.permission.CAMERA`
    but you didn't include `<uses-feature android:name="android.hardware.camera">`
    in your `Manifest.` In this scenario, Google Play will assume that your app requires
    camera hardware to function, and consequently won't allow anyone to install your
    app on a device that doesn't have a camera. If your app doesn't actually require
    a camera, this misunderstanding could prevent people with perfectly compatible
    devices from installing your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this misunderstanding, you need to open your project''s `Manifest`
    and specify that a camera is preferred, but not essential:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For a full list of all the permissions that imply feature requirements, check
    out the official Android docs ( [http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions](http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Declaring a `<uses-feature>` doesn't automatically grant your app permission
    to access the related features or information. You'll *still* need to request
    every permission your app requires, as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for app permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite everything this new runtime permissions model has to offer, it does
    present developers with a few new challenges. Firstly, since your app can request
    permissions at any time, issuing your permission requests at exactly the right
    time is now an important part of the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, since the user can now deny individual permissions, you'll need to
    ensure that your app continues to provide a good experience regardless of whether
    the user chooses to deny one or more of your application's permission requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This doesn't mean that your app has to function even if the user consistently
    denies its requests. It's possible that denying a certain permission may render
    your app completely unable to perform its core functionality. However, even if
    this is the case, you can still provide a good user experience by letting the
    user know *why* your app has suddenly stopped working. For example, whenever the
    user tries to launch your app, you might display a dialogue box listing all the
    missing permissions that your app requires in order to function, and then giving
    the user an easy way of granting these permissions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to look at all the best practices surrounding permissions,
    so you can make more informed decisions about which permissions your app requests,
    in addition to *when* and *where* it issues those requests.
  prefs: []
  type: TYPE_NORMAL
- en: Making as few permission requests as possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the golden rule of permission requests.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions are designed to protect the user and the device, so your app should
    *only* request permissions that it requires to function. Research ([http://repository.cmu.edu/hcii/268](http://repository.cmu.edu/hcii/268))
    suggests that the amount and type of permissions an app requests directly affects
    user behavior. When confronted with two apps that have similar functionality,
    users are more likely to opt for the one that requires fewer permissions.
  prefs: []
  type: TYPE_NORMAL
- en: If you're going to reach the widest possible audience, you need to limit the
    number of permissions your app requires. This is particularly important under
    the new permissions model, as requests are made as the user is interacting with
    your app. Imagine you've got lost on your way to an important meeting—you open
    up the map application you downloaded the night before, only to be confronted
    with permission requests every time you try to interact with the app. Not what
    you want when you're in a rush! It's incredibly easy to overwhelm a busy, multi-tasking
    mobile user with too much information.
  prefs: []
  type: TYPE_NORMAL
- en: If in doubt, remember that it's easier to add permissions to your app later
    via updates, than it is to remove them—so it's better to play it safe with a less-is-more
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Automatic permission adjustments**'
  prefs: []
  type: TYPE_NORMAL
- en: New releases of the Android platform may bring new restrictions, which can result
    in your app needing to request permissions that it didn't previously require.
    To make sure your app continues to work for users who are running the latest and
    greatest version of Android, the system may step in and automatically add these
    new permission requests to your project's `Manifest`.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding whether to automatically add permissions to your app, Android
    takes a look at your app's `targetSdkVersion`. If the value is lower than the
    version where the new permissions were added, the system may add these permissions
    automatically. This can result in your app requesting permissions that it doesn't
    necessarily need—definitely not a good thing!
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this, make it a priority to test your project against new releases
    of the Android platform, and then update your `targetSdkVersion` as soon as you're
    confident that your app is compatible with this latest release.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting critical permissions up front
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your app's core functionality hinges on having access to certain permissions,
    you should request these critical permissions up front. This is because users
    are more likely to take the time to read and therefore *grant* permission dialogues
    the first time they launch your app, rather than grant permission requests that
    interrupt them when they're midway through performing an important task in your
    app.
  prefs: []
  type: TYPE_NORMAL
- en: For non-critical permissions, you should wait until the user tries to access
    a related feature and then request that permission in context.
  prefs: []
  type: TYPE_NORMAL
- en: Providing extra information where necessary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, your permission requests should be self-explanatory, *especially* on
    devices running Android 6.0 or higher, where apps request permissions in context.
    For example, if a user taps your app's **Take a photo for your profile picture**
    button, chances are they aren't going to be confused when your app requests access
    to their camera.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you suspect that it may not be immediately obvious why your app
    is requesting a certain permission, then you'll want to provide the user with
    some more information. Your users are always going to feel more comfortable when
    they understand why an app is requesting access to information or features. If
    you *don't* provide this information, then your users may suspect that you're
    leaving them in the dark on purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Just be wary of explaining *everything*. You shouldn't need to provide an explanation
    for every permission your app requests. If you overwhelm the user with too much
    information, they're going to get frustrated by the constant interruptions, and
    may end up either skim-reading your explanations (bad) or skipping them completely
    (worse).
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself providing an explanation *every time* your app makes a
    permission request, this may be an indication of a deeper problem with how your
    app is handling sensitive data or using device features. Maybe your app is requesting
    too many permissions? Or maybe it's requesting miscellaneous permissions that
    are unrelated to its core functionality?
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that permission request dialogues aren''t the only way of communicating
    with your users. You may want to consider other ways of giving the user the information
    they need to better understand the context of your app''s permission requests.
    For example, you could:'
  prefs: []
  type: TYPE_NORMAL
- en: Add this information to your app's Google Play description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a privacy policy outlining the information your app needs access to and
    how it uses this information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create support documentation that your users can turn to if they need more information,
    such as an online user manual or a **Help** section inside your app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update your UI so permission requests are more self-explanatory. Your users
    may be confused if they tap a stock avatar and your app suddenly requests access
    to their camera, however if the stock photo has a **Tap here to take a profile
    picture** label, then your users are *far* less likely to be confused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create dedicated support channels for your users such as forums, social media
    pages, or an e-mail address where they can reach out to you with any questions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paying attention to permissions required by libraries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you include a library in your project, your project inherits any permissions
    that library requests. Before you use *any* library, always check what permissions
    that library requires, and what it uses those permissions for.
  prefs: []
  type: TYPE_NORMAL
- en: Adding multiple libraries to your project without checking their permissions
    first can quickly land you in hot water with your users, as from the user's perspective
    it's your app that's making these requests, and not an external library. These
    libraries may even request permissions that seem completely unrelated to your
    app, potentially making your users even more suspicious.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to include a library in your project but are concerned that it requires
    too many permissions, then you can always look for an alternative library that
    provides similar functionality but doesn't make quite so many permission requests.
  prefs: []
  type: TYPE_NORMAL
- en: Being transparent about accessing the camera and microphone
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes your app may need to access particularly sensitive features, such
    as the device's camera or microphone. Most of the time your app won't require
    *constant* access to these features, but once the user has granted your app access,
    how do they know that it isn't constantly pulling information from their microphone
    and camera?
  prefs: []
  type: TYPE_NORMAL
- en: No one likes to feel they're being watched, so you should be up front about
    when your app is accessing the device's camera or microphone. For example, you
    could display a pop-up with a timer indicating that your app is going to turn
    the device's camera on in 3, 2, 1, or you could display a flashing microphone
    icon in the corner of the screen whenever your app is *listening* to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Considering alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if your app does require access to protected information or features, you
    may be able to engineer your app so it doesn't have to make these requests itself.
  prefs: []
  type: TYPE_NORMAL
- en: An app only needs to request permissions for actions that it performs directly
    - *not* when it's asking other apps to perform a task on its behalf, or supply
    it with information. For example, instead of requesting access to the device's
    camera, you could use `MediaStore.ACTION_IMAGE_CAPTURE` to launch a camera app
    that the user has already installed on their device. You can also use system intents
    to request information from other apps, such as requesting contact information
    from the user's Contacts app, rather than issuing the `READ_CONTACTS` permission.
  prefs: []
  type: TYPE_NORMAL
- en: The major downside to this approach is that it presents the user with a dialogue
    every time your app needs to access the protected information or feature, so consider
    whether the frequency or timing of these requests is likely to irritate your users.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notifications underwent a massive overhaul in Android Lollipop, getting both
    a Material Design makeover *and* new methods that help Android sort notifications
    more intelligently.
  prefs: []
  type: TYPE_NORMAL
- en: In Android 5.0 and higher, you can annotate your notifications with the `setPriority()`
    method. Low-priority notifications may be hidden from the user, while higher-priority
    notifications are more likely to interrupt whatever the user is currently doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The different priority levels are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Notification.PRIORITY_MAX`: Used for critical and urgent notifications that
    alert the user to a condition that''s time-sensitive, or that they may need to
    resolve before they can continue with the current task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notification.PRIORITY_HIGH`: Typically used for important communications such
    as chat messages. High-priority notifications appear in a floating *heads-up* window
    that contains action buttons. Action buttons allow the user to act on, or dismiss,
    the heads-up notification without having to navigate away from the current screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notification.PRIORITY_LOW`: Used for less urgent notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notification.PRIORITY_MIN`: Used for contextual or background information.
    Minimum-priority notifications aren''t usually shown to the user except under
    special circumstances, such as detailed notification logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notification.PRIORITY_DEFAULT`: You can use this priority flag for all notifications
    that don''t fall into any of the more specific priority categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many Android devices feature a notification LED that you can use to inform users
    about events that are happening inside your app, even when the screen is off.
    Assigning your app's notifications a priority level of `MAX`, `HIGH`, or `DEFAULT`
    should cause the LED to glow.
  prefs: []
  type: TYPE_NORMAL
- en: In Android 5.0 and higher, notifications also appear on the device's lockscreen,
    which means you need to consider whether your notifications contain information
    that users might not want to appear on their lockscreen for the whole world to
    see.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `setVisibility()` to tell Android how much information it should
    display on the lockscreen, and assign it one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VISIBILITY_SECRET`: No part of the notification appears on the lockscreen.
    This is recommended if your app''s notifications contain personal or potentially
    embarrassing information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VISIBILITY_PRIVATE`: The notification displays some basic information on the
    lockscreen, but most of the information is hidden.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VISIBILITY_PUBLIC`: The notification appears on the lockscreen in its entirety.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design your notifications well, and they'll provide real value to your users—plus,
    they'll serve as a handy way of enticing users back to your app, by presenting
    them with interesting and timely updates about events that are happening inside
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: To make the most out of Android's notification system, you should keep the following
    best practices in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the right content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the very least, your notifications should contain:'
  prefs: []
  type: TYPE_NORMAL
- en: A title (`setContentTitle`) and secondary text (`setContentText`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timestamp; note this indicates when the event occurred and *not* when the
    notification was posted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The notification type (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure the user can recognize your app's pending notifications in the
    system bar, you should include a distinct app icon (`setSmallIcon`).
  prefs: []
  type: TYPE_NORMAL
- en: Your notification icon should be simple and avoid any excessive detail, but
    at the same time it must be eye-catching and distinct from the other notification
    icons users may encounter. You should use the Material Light action bar icon style
    and avoid opaque backgrounds—basically, your notification icon should be a white-on-transparent
    background image.
  prefs: []
  type: TYPE_NORMAL
- en: If you're struggling for inspiration, try booting up your Android device and
    taking a look at the kind of notification icons other applications are using.
  prefs: []
  type: TYPE_NORMAL
- en: Using notifications sparingly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time you issue a notification, you're interrupting whatever the user is
    doing at that moment, so it's important you use notifications sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: You should *never* use notifications to alert the user about background operations
    that don't require their input or that aren't time-sensitive. You also shouldn't
    use notifications to alert the user about events that are already happening on
    screen. Instead, inform the user about these events in context via your app's
    UI. For example, if the user has unlocked a new level in your gaming app, and
    that app is currently on screen, you should alert them via an on screen message
    rather than firing off a notification.
  prefs: []
  type: TYPE_NORMAL
- en: Even though notifications can be useful for reminding the user about your application,
    you should *never* use unnecessary notifications to tempt the user into launching
    your app. In the long run, unimportant or unwanted notifications are only going
    to make users view your app as an attention-seeker, which may even lead to them
    uninstalling your app and leaving you a negative review on Google Play.
  prefs: []
  type: TYPE_NORMAL
- en: Giving users a choice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, you should give your users the option to change your app's notifications
    settings, such as switching between sound alerts and vibration alerts, or even
    allowing users to disable notifications entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Categorising notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When ranking and filtering notifications, the Android system may take an app''s
    category into consideration, so you should assign a suitable category to each
    of your app''s notifications. To do this, use the `setCategory()` option and choose
    from the following supported categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CATEGORY_ALARM`: Alarm or timer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_CALL`: An incoming voice or video call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_EMAIL`: Asynchronous bulk message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_ERROR`: An error in a background operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_EVENT`: Calendar event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_MESSAGE`: Incoming direct message, such as an SMS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_PROGRESS`: The progress of an operation running in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_PROMO`: A promotion or advert'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_RECOMMENDATION`: A specific, timely recommendation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_SERVICE`: An indication of a service that''s running in the background'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_SOCIAL`: A social network or sharing update'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_STATUS`: Ongoing information about device or contextual status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_SYSTEM`: This category is reserved for system or device status updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CATEGORY_TRANSPORT`: Media transport control for playback'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making use of actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also add action buttons to your notifications. Action buttons allow
    users to perform common tasks from the notification UI, without them having to
    open the originating app.
  prefs: []
  type: TYPE_NORMAL
- en: 'You add a button to your notification using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each action should have its own icon and its own name.
  prefs: []
  type: TYPE_NORMAL
- en: Although optional, it's generally a good idea to add at least one action to
    each of your app's notifications. Just don't get carried away—limit yourself to
    a maximum of three actions per notification.
  prefs: []
  type: TYPE_NORMAL
- en: Using expanded layouts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For users running Android 4.1 and higher, you can supply two different visual
    styles for each of your app''s notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal view**: This is the default, compact layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Big view style**: A separate layout that appears when the user expands your
    notification by pinching or dragging it open.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a choice of three different big view styles.
  prefs: []
  type: TYPE_NORMAL
- en: Big text style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This layout provides additional text that''s displayed in the detail area of
    the expanded notification, in place of the notification''s regular `setContentText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Big picture style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This layout includes a large image attachment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inbox style
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This layout includes a list of up to five items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Direct reply notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google are adding a few new features to notifications in the upcoming release
    of Android *N*, including an **inline reply** action button that allows users
    to reply directly from the notification UI.
  prefs: []
  type: TYPE_NORMAL
- en: Direct reply notifications are particularly big news for messaging apps, as
    they give users the ability to reply without even having to launch the messaging
    app. You may have already encountered direct reply notifications in Google Hangouts.
  prefs: []
  type: TYPE_NORMAL
- en: To create a notification action that supports direct reply, you need to create
    an instance of `RemoteInput.Builder` and then add it to your notification action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code adds a `RemoteInput` to a `Notification.Action`, and creates
    a **Quick Reply** key. When the user triggers the action, the notification prompts
    the user to input their response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the user''s input from the notification interface, you need to
    call `getResultsFromIntent(Intent)` and pass the notification action''s intent
    as the input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Bundled notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don't you just hate it when you connect to the Internet first thing in the morning
    and your Gmail app instantly bombards you with a **4 new messages** notification,
    but doesn't give you any more information about those individual e-mails? Not
    particularly helpful!
  prefs: []
  type: TYPE_NORMAL
- en: When you receive a notification that consists of multiple items, the only thing
    you can really do is open the app and take a look at the individual events that
    make up this grouped notification.
  prefs: []
  type: TYPE_NORMAL
- en: However, the upcoming release of Android N promises to fix this problem by introducing
    **bundled notifications**. This new notification style allows you to group multiple
    notifications from the same app into a single, bundled notification. A bundled
    notification consists of a parent notification that displays summary information
    for that group, plus individual notification items.
  prefs: []
  type: TYPE_NORMAL
- en: If the user wants to see more information about these individual items, they
    can *unfurl* the bundled notification card into separate, smaller notifications
    by swiping down with two fingers. When the user expands a bundled notification,
    the system reveals more information about each child notification. The user can
    then act on each of these mini-notifications individually, for example they might
    choose to dismiss the first three notifications about spam e-mails, but open the
    fourth e-mail. This is similar to the Notification Stacks feature you may have
    encountered in Android Wear.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bundled notifications are particularly useful when your app has the potential
    to generate multiple notifications where each child notification is actionable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To group notifications, call `setGroup()` for each notification you want to
    add to the same notification stack, and then assign these notifications the same
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you create another notification that belongs to this stack, you just need
    to assign it the same group key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Application widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Widgets provide users with a small, convenient sample of your application's
    most important data, typically from the comfort of their home screen.
  prefs: []
  type: TYPE_NORMAL
- en: To create a basic app widget, you need to complete the process described in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring an AppWidgetProvider class in your project's Manifest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `AppWidgetProvider` class defines the methods that allow you to programmatically
    interact with your app widget based on broadcast events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a basic `AppWidgetProvider` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating an AppWidgetProviderInfo file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is defining the basic qualities of your widget, such as its minimum
    width and height, and how often it''s updated. Create a `res/xml` directory, if
    your project doesn''t already contain one, and then create a new XML layout file.
    In this example, we''re using `my_appwidget_info.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating the widget's layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You define your widget's layout in XML in the same way you create a regular
    layout resource file. The only major difference is that app widget layouts are
    based on `RemoteViews`, which don't support every layout and view.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, app widgets support the following layout classes only:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FrameLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinearLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RelativeLayout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They also only support the following widget classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AdapterViewFlipper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AnalogClock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chronometer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GridView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageButton`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProgressBar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextView`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewFlipper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`RemoteViews` also support `ViewStubs`.'
  prefs: []
  type: TYPE_NORMAL
- en: App widget best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well-designed app widgets that display useful information serve as a constant
    reminder about how great your app is, tempting the user to launch your application—or
    at the very least, making them less likely to uninstall your app.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure your widget presents your application in the best possible light,
    make sure you adhere to the following best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Including margins for earlier versions of Android
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Your widgets shouldn't extend to the edges of the screen or bump up against
    other widgets, as this can make the user's home screen look messy and cluttered.
    The solution is to add a margin around each edge of your widgets, something that
    Android 4.0 and higher does automatically whenever the user places a widget on
    their home screen. To take advantage of this behavior, you just need to set your
    app's `targetSdkVersion` to `14` or greater.
  prefs: []
  type: TYPE_NORMAL
- en: Since Android 4.0 and greater applies margins to your app automatically, you
    shouldn't add any extra margins to your widget when it's installed on devices
    running Android 4.0 and over. However you *will* still need to add margins when
    your app is installed on devices running earlier versions of Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to create two `dimens.xml` files that specify different margins
    for different versions of Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '`res/values-v14/dimens.xml`: This file defines the 0dp margins for devices
    running Android 4.0 and greater:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`res/values/dimens.xml`: This file defines the margins for devices running
    versions of Android lower than 4.0:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then reference these `dimens.xml` values in your widget''s layout resource
    file, and the Android system will select the appropriate `widget_margins` value
    at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Providing flexible graphics and layouts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Android home screen is divided into a grid. The user can place app widgets
    inside free cells, and then stretch them horizontally and/or vertically to occupy
    a different number of cells.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure your widget's layout is flexible enough to be able to adapt to different
    grid sizes, you should define your widget's background using stretchable nine-patch
    images, and then use flexible layouts such as `LinearLayout`, `RelativeLayout`
    or `FrameLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Not updating too often
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the device is asleep when the app widget framework requests an update from
    the `AppWidgetProvider`, the device will wake up in order to perform this operation.
    Requesting too many updates is a surefire way to drain the user's battery and
    may result in them uninstalling your app, or at the very least banishing your
    app widget from their home screen.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to consider how often your widget really needs to receive new
    information, for example you'll typically need to update a weather or news widget
    less often than a widget that alerts users about incoming e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: If you're building a widget that *does* require frequent updates, then it's
    generally a good idea to perform these updates based on an alarm that won't wake
    the device. If this alarm goes off while the device is asleep, this update won't
    be performed until the next time the device wakes up, so it has less impact on
    the device's battery.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this kind of alarm, use the `AlarmManager` to set an alarm with an `Intent`
    that your `AppWidgetProvider` receives, and then set the alarm type to either `ELAPSED_REALTIME`
    or `RTC`, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Finally, set the widget's `updatePeriodMillis` to zero so it won't override
    your alarm and wake the device.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your app is only truly accessible when everyone can navigate it, understand
    it, and use it successfully, including people who may have visual, physical, or
    age-related limitations.
  prefs: []
  type: TYPE_NORMAL
- en: Android has several in built accessibility features that help you optimize your
    app for users with visual or physical disabilities, so the good news is that,
    in most cases, creating an accessible app won't require any extensive changes
    to your code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I'll show you how to use these built-in platform features to
    make sure *everyone* can enjoy using your app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your app is part of a team effort, then it's important that everyone on your
    team keeps accessibility in mind. If you're working with a designer or a team
    of testers, then it's a good idea to make sure they're also familiar with the
    following accessibility guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Adding descriptive text to your UI controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've designed your UI well, you shouldn't have to add an explicit label
    to every on screen element, for example a button with a telephone icon inside
    a **Contacts** app has a pretty obvious purpose. However, users with vision impairments
    may not be able to pick up on these visual clues, so you'll need to provide them
    with some additional information.
  prefs: []
  type: TYPE_NORMAL
- en: You should provide content descriptions for every UI component that doesn't
    feature visible text. Also consider whether these descriptions alone provide sufficient
    context for the user to fully understand the related visual elements—without any
    visual context, a **Delete** or **Call the selected contact** content description
    may not be particularly helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The text in the description attribute *doesn't* appear on screen, but if the
    user enables speech-based accessibility services such as TalkBack, this description
    is read aloud when the user navigates to that item.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a description using the `android:contentDescription` XML layout
    attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Imagine that the value of `@string/newSMS` is `Create a new SMS message`. When
    the user hovers over this icon with an accessibility service enabled, this description
    will be read aloud and the user will then understand what this UI element does.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For `EditTexts,` your top priority should be helping the user to understand
    what content they're expected to enter into this empty field, so you should provide
    an `android:hint` attribute *instead* of a content description. Once the user
    has entered some text into the `EditText`, the accessibility service will read
    this text aloud, instead of the `android:hint` value.
  prefs: []
  type: TYPE_NORMAL
- en: There'll be situations where you want to base an item's content description
    on dynamic elements, such as the state of a slider or the currently selected text
    in a list. If this is the case, then you'll need to edit the content description
    at runtime using the `setContentDescription()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Providing descriptions is particularly important for `ImageButton`, `ImageView`,
    and `Checkbox` components, but you should add content descriptions wherever you
    suspect that users with different abilities might benefit from some additional
    information. Just don't get carried away and add unnecessary descriptions, as
    this just increases the noise the user encounters as they're trying to decipher
    your UI, making it more difficult for them to pull useful information from their
    accessibility service.
  prefs: []
  type: TYPE_NORMAL
- en: Wherever possible, use Android's standard controls as they have `ContentDescriptions`
    built in by default, and therefore work automatically with accessibility services
    such as TalkBack.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for focus navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Focus navigation is where your users employ directional controls to navigate
    the individual elements that make up your app's UI, similar to the four-way remote
    control navigation on a television. Users with limited vision or limited manual
    dexterity often use this mode of navigation instead of touchscreen navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Directional controllers can be software-based or hardware-based, such as a trackball,
    D-pad, or external keyboard. Users may also choose to enable the gestures navigation
    mode available in devices running Android 4.1 and higher.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure your users can successfully navigate your app using a directional
    controller, you need to verify that all your UI input controls can be reached
    and activated without using the touchscreen. You should also verify that clicking
    a directional controller's center, or **OK** button, has the same effect as touching
    a control that already has focus.
  prefs: []
  type: TYPE_NORMAL
- en: In order to support focus navigation, you should ensure that all your app's
    navigational elements are focusable. You can achieve this by adding the `android:focusable="true"`
    attribute to your UI elements, or perform this modification at runtime using the `View.setFocusable()` method
    on each UI control.
  prefs: []
  type: TYPE_NORMAL
- en: The UI controls provided by the Android framework are focusable by default,
    and the system visually indicates focus by changing the control's appearance.
  prefs: []
  type: TYPE_NORMAL
- en: When a user navigates in any direction using directional controls, focus is
    passed from one UI element to another, as determined by the focus order. The system
    determines the focus order automatically based on an algorithm that finds the
    nearest neighbor in a given direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes the results may not be quite what you had in mind, or they
    may not provide the best experience for the user. If this is the case, Android
    provides four optional XML attributes that you can use to override this automatic
    focus order and dictate *exactly* which view will receive focus when the user
    navigates in that direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android:nextFocusUp`: Defines the next view to receive focus when the user
    navigates up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:nextFocusDown`: Defines the next view to receive focus when the user
    navigates down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:nextFocusLeft`: Defines the next view to receive focus when the user
    navigates left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android:nextFocusRight`: Defines the next view to receive focus when the user
    navigates right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example XML shows two focusable UI elements where the `android:nextFocusDown`
    and `android:nextFocusUp` attributes have been set explicitly. The `Button` is
    located to the right of the `TextView`, however thanks to the magic of `nextFocus`
    properties, the user can reach the `Button` element by pressing the down arrow
    when the focus is on `TextView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The easiest way to test your navigation is to run your app in the emulator and
    navigate around your UI using the emulator's arrow keys and **OK** button only.
    Check that the navigation works as expected in all directions, including when
    you're navigating in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also modify the focus order of UI components at runtime, using methods
    such as `setNextFocusDownId()` and `setNextFocusRightId().`
  prefs: []
  type: TYPE_NORMAL
- en: Custom view controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you build custom interface controls, make sure you implement accessibility
    interfaces for these custom views and provide content descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your custom controls to be compatible with all versions of Android
    back to 1.6, you'll need to use the Support Library to implement the latest accessibility
    features.
  prefs: []
  type: TYPE_NORMAL
- en: When creating custom views, you need to make sure these views are successfully
    creating `AccessibilityEvents` whenever the user selects an item or changes focus,
    as accessibility events are an important part of providing accessibility features
    such as text-to-speech.
  prefs: []
  type: TYPE_NORMAL
- en: To generate `AccessibilityEvents`, call `sendAccessibilityEvent(int)` with a
    parameter representing the type of event that's occurred. You'll find a complete
    list of the event types Android currently supports in the `AccessibilityEvent`
    reference documentation ([http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html](http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Providing alternatives to audio prompts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To assist users who are hearing impaired, you should avoid including any audio-only
    feedback in your app. You should always accompany your app's audio feedback with
    a secondary feedback mechanism, such as closed captions, a transcript, on screen
    notifications, or another visual alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Testing various font sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android users can change the size of the font that appears across their device
    manually, from their device's **Settings |** **Accessibility** screen. To make
    sure these size changes also affect the text within your app, define your app's
    text and associated containers in scaled pixels (`sp`).
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that when users have large fonts enabled, your app's text
    may become larger than the space you originally allocated for it, so you'll need
    to check that your text and UI looks good and functions normally even when the
    user has large text enabled. In particular, make sure that your UI elements don't
    overlap and that all touchable elements remain reachable across various text sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Using recommended touch target sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure all your app's touch targets are at least 48 x 48dp, and ensure that
    the space between on screen elements is always at least 8dp. This helps to ensure
    your UI is easier to navigate for people with manual dexterity challenges, but
    also for children with developing motor skills.
  prefs: []
  type: TYPE_NORMAL
- en: Providing alternatives to affordances that time out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some apps feature icons or controls that disappear after a certain amount of
    time, for example it's common for video playback controls to fade out once the
    user is a few seconds into the video.
  prefs: []
  type: TYPE_NORMAL
- en: This poses a problem for people who are using accessibility features such as
    TalkBack, as TalkBack waits until the user has focused on a control before it
    reads that control's description. If your UI has controls that fade out quickly,
    these controls may actually vanish before the user has a chance to focus on them—which
    means they never get read out, and therefore the user won't be aware of their
    existence.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you shouldn't rely on timed-out controls for high-priority
    tasks or important functions. If your UI does feature timed-out controls, you
    may want to disable this functionality when accessibility services are enabled,
    so these timed-out controls no longer disappear.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure users with visual impairments can read your text more easily, it's
    recommended that you use a contrast ratio of 4.5:1 between your app's background
    and text. As a general rule, the smaller your text, the more contrast you'll need
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Also bear in mind that some of your users may be colorblind, so you shouldn't
    use color signals as the only means of conveying important information. In addition
    to color, you can use elements such as patterns, shapes, size, textures, or text.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your application's accessibility features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a crucial part of creating an accessible app, as it can uncover problems
    with user interaction that you might not otherwise have spotted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing your app''s accessibility features typically involves:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your app with audible feedback enabled:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audible accessibility services provide audio prompts that dictate the on screen
    content to your users as they move around your UI. The most effective way of testing
    the experience you're providing to users with visual impairments is to enable
    an audible accessibility service on your Android device and then interact with
    your app using sound alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For Android users, feedback is typically provided via the TalkBack accessibility
    service. TalkBack comes preinstalled on many Android devices (open your device's
    **Settings** and select **Accessibility**, followed by **TalkBack**) but you can
    also download TalkBack for free from Google Play.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you've enabled an audible accessibility service, spend some time navigating
    around your app using the spoken feedback only. Look for any opportunities to
    improve the experience for users who might be interacting with your app without
    sighted assistance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should also check that your app provides enough information for the user
    to understand and act on each on screen element using a service such as TalkBack,
    *without* overloading them with too much information. This can be a tricky balancing
    act—too much or too little information will make it equally difficult for the
    user to decipher your UI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigating your app using directional controls only, instead of the touchscreen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of accessibility testing, you should verify that your app is easy to
    navigate using directional controls only, meaning without using the touchscreen,
    and ensure that users can move focus between your app's UI elements in a way that
    makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: If available, you can use a physical device with a D-pad or trackball, but if
    your device doesn't have these hardware features you can use a software-based
    directional controller instead, or use the Android emulator and its simulated
    keyboard controls. You may even want to use TalkBack gestures ([https://support.google.com/accessibility/android/answer/6151827](https://support.google.com/accessibility/android/answer/6151827)),
    which allow users to navigate apps (and their device in general) using very specific
    gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we covered some best practices that I hadn't explored
    in detail in previous chapters, including app security and accessibility best
    practices. You also learned how to create more useful notifications, and began
    to explore the new notification options coming up in Android N.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about developing effective Android apps, you'll find
    lots of additional information in the Android docs ([http://developer.android.com/training/index.html](http://developer.android.com/training/index.html)),
    at the Android blog ([http://android-developers.blogspot.co.uk/](http://android-developers.blogspot.co.uk/)),
    or by checking out some of Google's code samples ([http://developer.android.com/samples/index.html](http://developer.android.com/samples/index.html)).
  prefs: []
  type: TYPE_NORMAL
