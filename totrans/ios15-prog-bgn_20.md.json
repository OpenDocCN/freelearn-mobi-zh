["```swift\n    class RestaurantItem: NSObject, MKAnnotation, \n    Decodable {\n    ```", "```swift\n    enum CodingKeys: String, CodingKey {\n       case name\n       case cuisines \n       case lat\n       case long \n       case address\n       case postalCode = \"postal_code\" \n       case state\n       case imageURL = \"image_url\"\n       case restaurantID = \"id\"\n    }\n    ```", "```swift\n    class RestaurantDataManager {\n\n    }\n    ```", "```swift\n    private var restaurantItems: [RestaurantItem] = []\n    ```", "```swift\n    func fetch(location: String, selectedCuisine: \n    String = \"All\", completionHandler: (_ \n    restaurantItems: [RestaurantItem]) -> Void) { \n       if let file = Bundle.main.url(forResource: \n       location, withExtension: \"json\") {\n          do {\n             let data = try Data(contentsOf: file)\n             let restaurants = try JSONDecoder().decode(\n             [RestaurantItem].self, from: data)\n             if selectedCuisine != \"All\" {\n                restaurantItems = restaurants.filter {\n                  ($0.cuisines.contains(selectedCuisine))\n                }\n             } else { \n                restaurantItems = restaurants \n             }\n          } catch {\n             print(\"There was an error \\(error)\")\n          }\n       }\n       completionHandler(restaurantItems)\n    }\n    ```", "```swift\n    func fetch(location: String, selectedCuisine: \n    String = \"All\", completionHandler: (_ restaurantItems:\n    [RestaurantItem]) -> Void)\n    ```", "```swift\n    if let file = Bundle.main.url(forResource: location, \n    withExtension: \"json\")\n    ```", "```swift\n    completionHandler(items)\n    ```", "```swift\n    func numberOfRestaurantItems() -> Int {\n       restaurantItems.count\n    }\n    ```", "```swift\n    func restaurantItem(at index: Int) -> \n    RestaurantItem {\n       restaurantItems[index]\n    }\n    ```", "```swift\nfunc fetch(completion: (_ annotations: [RestaurantItem]) -> ()){\n   let manager = RestaurantDataManager()\nmanager.fetch(location: \"Boston\", completionHandler: { \n      (restaurantItems) in self.items = restaurantItems\n      completion(items)\n   })\n}\n```", "```swift\nfunc fetch(completion: (_ annotations: [RestaurantItem]) -> ())\n```", "```swift\nlet manager = RestaurantDataManager() \n```", "```swift\nmanager.fetch(location: \"Boston\", completionHandler: { \n   (restaurantItems) in self.items = restaurantItems\n   completion(items)\n})\n```", "```swift\n    struct LocationItem { \n       let city: String?\n       let state: String?\n    }\n    extension LocationItem {\n       init(dict: [String: String]) {\n          self.city = dict[\"city\"]\n          self.state = dict[\"state\"]\n       }\n       var cityAndState: String {\n          guard let city = self.city, let state = \n          self.state else { \n             return \"\" \n          }\n          return \"\\(city), \\(state)\"\n       }\n    }\n    ```", "```swift\n    private var locations:[LocationItem] = []\n    ```", "```swift\n    func fetch() {\n       for location in loadData() {\n          loadData() method is now used to initialize LocationItem instances instead of strings, which are then appended to the locations array. The loadData() method still uses the same Locations.plist file that you created in *Chapter 15*, *Getting Started with Table Views*.\n    ```", "```swift\n    func locationItem(at index: Int) -> \n    LocationItem {\n       locations[index]\n    }\n    ```", "```swift\n    func tableView(_ tableView: UITableView, cellForRowAt \n    indexPath: IndexPath) -> UITableViewCell {\n       let cell = tableView.dequeueReusableCell(\n       withIdentifier: \"locationCell\", for: indexPath)\n       cityAndState property of the LocationItem structure returns a string that combines a location's city and state strings, fixing the error.\n    ```", "```swift\n    let manager = LocationDataManager()\n    var selectedCity: LocationItem?\n    ```", "```swift\n    // MARK: UITableViewDelegate\n    extension LocationViewController: \n    UITableViewDelegate {\n\n    }\n    ```", "```swift\n    // MARK: UITableViewDelegate\n    extension LocationViewController: UITableViewDelegate \n    {\n    selectedCity property is assigned the corresponding LocationItem instance in the locations array. For example, if you tap the third row, the LocationItem instance with the values \"Charleston\" and \"NC\" is assigned to selectedCity. \n    ```", "```swift\n    class ExploreHeaderView: UICollectionReusableView {\n\n    }\n    ```", "```swift\n    let manager = ExploreDataManager()\n    var selectedCity: LocationItem?\n    ```", "```swift\n    let manager = ExploreDataManager()\n    var selectedCity: LocationItem?\n    var headerView: ExploreHeaderView!\n    ```", "```swift\n    func collectionView(_ collectionView: UICollectionView, \n    viewForSupplementaryElementOfKind kind: String, at \n    indexPath: IndexPath) -> UICollectionReusableView {\n       let UICollectionViewDataSource protocol. It returns the view that will be used as the collection view section header. Here, the collection view section header in the ExploreHeaderView instance.Important InformationYou can learn more about the `UICollectionViewDataSource` protocol at this link: [ https://developer.apple.com/documentation/uikit/uicollectionviewdatasource/1618037-collectionview](https://developer.apple.com/documentation/uikit/uicollectionviewdatasource/1618037-collectionview).\n    ```", "```swift\n    struct LocationItem: LocationItem instances are equal.\n    ```", "```swift\n    private func setCheckmark(for cell: UITableViewCell, \n    location: LocationItem) {\n       if selectedCity == location {\n          cell.accessoryType = .checkmark {\n       } else {\n          cell.accessoryType = .none\n       }\n    }\n    ```", "```swift\n    func tableView(_ tableView: UITableView, cellForRowAt \n    indexPath: IndexPath) -> UITableViewCell {\n       let cell = tableView.dequeueReusableCell(\n       withIdentifier: \"locationCell\", for: indexPath)\n       let location = manager.locationItem(at \n       indexPath.row)\n       cell.textLabel?.text = location.cityAndState \n       setCheckmark(for:at:) will be called when each row in the table view is rendered, and the checkmark will only be set on the row containing the selected location.\n    ```", "```swift\n    if let cell = tableView.cellForRow(at: indexPath) {\n       cell.accessoryType = .checkmark\n       selectedCity = manager.locationItem(at:\n       indexPath.row)\n       tableView.reloadData()\n    }\n    ```", "```swift\n    func showLocationList(segue: UIStoryboardSegue) {\n       guard let navController = segue.destination as? \n       UINavigationController, let viewController = \n       navController.topViewController as? \n       LocationViewController else {\n          return\n       }\n       viewController.selectedCity = selectedCity\n    }\n    ```", "```swift\n    selectedRestaurant will be set if you pick a restaurant in the selectedCity stores the city you picked in the selectedCuisine stores the cuisine you picked in the Explore screen.\n    ```", "```swift\n    override func viewDidAppear(_ animated: Bool) {\n       super.viewDidAppear(animated)\n       print(\"selected city \\(selectedCity as Any)\")\n       print(\"selected cuisine \\(selectedCuisine as Any)\")\n    }\n    ```", "```swift\n    func showRestaurantList(segue: UIStoryboardSegue) {\n       if let viewController = segue.destination as? \n       RestaurantListViewController, let city = \n       selectedCity, let index = \n       collectionView.indexPathsForSelectedItems?.first?\n       .row {\n          viewController.selectedCuisine = \n          manager.exploreItem(at: index).name\n          viewController.selectedCity = city\n       }\n    }\n    ```", "```swift\n    func showLocationRequiredAlert() {\n       let alertController = UIAlertController(title: \n       \"Location Needed\", message: \"Please select a \n       location.\", preferredStyle: .alert)\n       let okAction = UIAlertAction(title: \"OK\", style: \n       .default, handler: nil)\n       alertController.addAction(okAction)\n       present(alertController, animated: true, \n       completion: nil)\n    }\n    ```", "```swift\n    override func shouldPerformSegue(withIdentifier \n    identifier: String, sender: Any?) -> Bool {\n       if identifier == Segue.restaurantList.rawValue, \n       selectedCity == nil {\n          showLocationRequiredAlert()\n          return false\n       }\n       return true\n    }\n    ```", "```swift\noverride func prepare(for segue: UIStoryboardSegue, sender: Any?) {\n   switch segue.identifier! {\n   case Segue.locationList.rawValue:\n     showLocationList(segue: segue)\n   case Segue.restaurantList.rawValue:\n     showRestaurantList(segue: segue)\n   default:\n      print(\"Segue not added\")\n   }\n}\n```", "```swift\noverride func viewDidAppear(_ animated: Bool) {\n   super.viewDidAppear(animated)\nguard let city = selectedCity?.city, let cuisine = \nselectedCuisine else { \nreturn \n   }\n   let manager = RestaurantDataManager()\n   manager.fetch(location: city, selectedCuisine: cuisine) {\n      restaurantItems in if !restaurantItems.isEmpty {\n         for restaurantItem in restaurantItems {\n            if let restaurantName = restaurantItem.name {\n               print(restaurantName)\n            }\n         }\n      } else {\n         print(\"No data\")\n      }\n   }\n}\n```", "```swift\n    import UIKit\n    class RestaurantCell: UICollectionViewCell {\n    }\n    ```", "```swift\n    class NoDataView: UIView {\n       var view: UIView!\n       @IBOutlet var titleLabel: UILabel!\n       @IBOutlet var descLabel: UILabel!\n       override init(frame: CGRect) { \n          super.init(frame: frame) \n          setupView()\n       }\n       required init?(coder: NSCoder) { \n          super.init(coder: coder)\n          setupView()\n       }\n       func loadViewFromNib() -> UIView {\n          let nib = UINib(nibName: \"NoDataView\", bundle: \n          Bundle.main)\n          let view = nib.instantiate(withOwner: self, \n          options: nil) [0] as! UIView \n          return view\n       }\n       func setupView() {\n          view = loadViewFromNib()\n          view.frame = bounds\n          view.autoresizingMask = [.flexibleWidth, \n          .flexibleHeight]\n          addSubview(view)\n       }\n       func set(title: String, desc: String) {\n          titleLabel.text = title\n          descLabel.text = desc\n       }\n    }\n    ```", "```swift\nvar view: UIView!\n@IBOutlet var titleLabel: UILabel!\n@IBOutlet var descLabel: UILabel!\n```", "```swift\noverride init(frame: CGRect) { \n   super.init(frame:frame) \n   setupView()\n}\nrequired init?(coder: NSCoder) { \n   super.init(coder: coder)\n   setupView()\n}\n```", "```swift\nfunc loadViewFromNib() -> UIView {\n   let nib = UINib(nibName: \"NoDataView\", bundle: \n   Bundle.main)\n   let view = nib.instantiate(withOwner: self, \n   options: nil) [0] as! UIView\n   return view\n}\n```", "```swift\nfunc setupView() {\n   view = loadViewFromNib()\n   view.frame = bounds\n   view.autoresizingMask = [.flexibleWidth, .flexibleHeight]\n   addSubview(view)\n}\n```", "```swift\nfunc set(title: String, desc: String) {\n   titleLabel.text = title\n   descLabel.text = desc\n}\n```", "```swift\n    private let manager = RestaurantDataManager()\n    var selectedRestaurant: RestaurantItem?\n    ```", "```swift\n    manager.fetch(location: city, selectedCuisine: cuisine)\n    ```", "```swift\n    { restaurantItems in\n       if !restaurantItems.isEmpty {\n          collectionView.backgroundView = nil\n       } else {\n          let view = NoDataView(frame: CGRect(x: 0, y: 0, \n          width: collectionView.frame.width, height: \n          collectionView.frame.height))\n          view.set(title: \"Restaurants\", desc: \n          \"No restaurants found.\") \n          collectionView.backgroundView = view\n       }\n    ```", "```swift\n    collectionView.reloadData()\n    ```", "```swift\n    func collectionView(_ collectionView: \n    UICollectionView, cellForItemAt indexPath: IndexPath) \n    -> UICollectionViewCell {\n       RestaurantItem instance from the restaurantItems array of the RestaurantDataManager instance corresponding to the RestaurantCell instance's position.\n\n    ```", "```swift\n\n    This sets the text of the `RestaurantCell` instance's `titleLabel` to the value of the `RestaurantItem` instance's `name`.\n\n    ```", "```swift\n\n    This sets the text of the `RestaurantCell` instance's `cuisineLabel` to the value of the `RestaurantItem` instance's `subtitle`.\n\n    ```", "```swift\n\n    This downloads the picture of the restaurant from the URL specified in the `RestaurantItem` instance's `imageURL` and assigns it to the `image` property of the `RestaurantCell` instance's `imgRestaurant` property.\n\n    ```", "```swift\n\n    Returns the collection view cell.Important InformationYou will notice that scrolling is jerky, and if there is no internet connection, the **Restaurant List** screen will be blank. This is because downloading images from the internet takes time, and is interrupting the rendering of the collection view. These issues will be fixed in [*Chapter 24*](B17469_24_Final_VK_ePub.xhtml#_idTextAnchor469)*, Swift Concurrency*.\n    ```", "```swift\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n       manager.numberOfRestaurantItems()\n    }\n    ```", "```swift\n    override func viewDidAppear(animated: Bool) {\n       super.viewDidAppear(animated)\n       createData()\n    }\n    ```", "```swift\n    func setupTitle() {\n       navigationController?.setNavigationBarHidden(\n       false, animated: false)\n       title = selectedCity?.cityAndState.uppercased()\n       navigationController?.navigationBar.\n       prefersLargeTitles = true\n    }\n    ```", "```swift\n    override func viewDidLoad(_ animated: Bool){\n       super.viewDidLoad(animated)\n       createData()\n       setupTitle() method when the Restaurant List screen appears.\n    ```"]