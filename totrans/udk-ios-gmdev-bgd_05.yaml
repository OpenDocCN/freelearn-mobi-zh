- en: Chapter 5. Action Sequences for Urban Warrior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built up a basic understanding of the lovely tools
    of Kismet and Matinee and how they can work together in some simple examples.
    But now that we know the basics can't we do more? Oh yes, we certainly can.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter we are going to create a series of sequences and prefabs to
    set the groundwork, allowing us to easily create our level in the next chapter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss what sequences are and how we use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn an enemy into our level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop a rudimentary AI system that will shoot at us if we are close
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand upon that system by adding chasing and retreating behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import/export subsequences to create additional enemies easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement regenerating health using remote events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss prefabs and their use in our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a door prefab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss workflow and things to consider when creating combat scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So with that, let's take a look at what we can do with sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Sequences and you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequences are UDK's ways of helping you organize your code as well as compartmentalize
    all of the actions that you want to have happen in a certain area. Events and
    their associated actions, that you will be re-using, are also prime candidates
    for being placed inside sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who works with Kismet has worked with sequences before. You have already
    been using sequences without even knowing it. UDK provides us with a **LevelName**
    sequence within the Kismet editor that we have used in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Life, or something like it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have an idea of what sequences are, let's create one of our own!
    It will enable us to bring the characters to life, such as enemies, explained
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—spawning AI into our level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are creating the building blocks of our game, creating a third person
    shooter is kind of hard to do without having enemies to fight. Thankfully UDK
    has helped us out and made it incredibly easy to add enemies into our level!
  prefs: []
  type: TYPE_NORMAL
- en: Go into to the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there you will see a list of classes that we can place within
    our level. Type `Path` in the **Search** bar and left-click on the **PathNode**
    selection. The following screenshot explains this:![Time for action—spawning AI
    into our level](img/image_1901_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the **Actor Classes** browser and right-click anywhere in your level.
    From the menu that pops up select **Add PathNode Here**. This will create an actor
    on the ground on the spot where you clicked. I have placed my **PathNode** away
    from the player but still visible from the camera for our opening sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left click-and-drag the background of the workspace to move the graph plane,
    bringing some open space for us to work with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click somewhere in the background and select **Create New Sequence: 0
    Objs**. A pop-up window should come up asking you for the name of the sequence.
    Type `EnemyAI` and press *Enter*. A little box with the name should be created
    at the position where you right-clicked.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the **EnemyAI** sequence. You will notice that we have now moved
    into this sequence and there is nothing there, and that our Sequences pane on
    the bottom at right-hand side has the **EnemyAI** sequence highlighted. This is
    shown in the following screenshot:![Time for action—spawning AI into our level](img/image_1901_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a **Sequence Activated** event by choosing **New Event**
    | **Sequence Activated** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Actor Factory** action by right-clicking and choosing **New Action**
    | **Actor** | **Actor Factory** from the menu. Go into the Properties pane and
    click on the blue triangle on the right-hand side of the **Factory** variable
    and select **UTActorFactoryAI** from the pop-up menu that comes out to create
    a new **Actor Factory** to use. Inside our new factory's properties set the **Pawn
    Class** to **UTPawn** and check the **Give Default Inventory** option. Finally,
    change the **Team Index** to **1**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the **Spawn Point** variable create an external object variable by
    right-clicking and selecting **New Variable** | **External Variable** from the
    menu. Left-click on the variable and in its properties set **Expected Type** to
    **SeqVar_Object** and **Variable Label** to **Spawn Point**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Finish Sequence** action by right-clicking and selecting **New Action**
    | **Misc** | **Finish Sequence**. Under the **Output Label** property type `Spawned`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the **Out** of the **Sequence Activated "In"** event to the **Spawn
    Actor** input of the Actor Factory action. Connect the **Spawn Point** link to
    the **External Object** variable we created. Finally, connect the **Finished**
    output of the **Actor Factory** to the **Finish Sequence "Spawned"** action. At
    this point our sequence should look as shown in the following screenshot:![Time
    for action—spawning AI into our level](img/image_1901_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the bottom right-hand side of our Kismet editor click on the **LevelName**
    sequence to return to the main level sequence. We should now see the sequence
    look similar to a Kismet node with inputs, outputs, and variable chains, as shown
    in the following screenshot:![Time for action—spawning AI into our level](img/image_1901_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and create a **Level Loaded** event by choosing **New Event** |
    **Level Loaded** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go into our level and left-click on the PathNode that you created earlier and
    go back into Kismet. Right-click on our Spawn Point link and select **Create New
    Variable from PathNode_0**. This is shown in the following screenshot:![Time for
    action—spawning AI into our level](img/image_1901_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our game by selecting **Build** | **Build All** and pressing Close when
    finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project. Now start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in following screenshot:![Time for action—spawning
    AI into our level](img/image_1901_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Upon the level being loaded (via the **Level Loaded** event) we call our **EnemyAI**
    sequence which spawns an enemy (via an **Actor Factory**) and places him in the
    level where our **PathNode** is. Putting these events and actions into a sequence
    will enable us to put code relevant to our AI in one place making it as simple
    as possible to create new AIs in our future levels.
  prefs: []
  type: TYPE_NORMAL
- en: It lives! but...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can now tell, our actor is in the level, but it isn't really doing anything.
    That is because it lacks **artificial intelligence** (**AI**). Surely we could
    force the actor to use the **Deathmatch** AI that is included in UDK, but if we
    had more than one AI they would fight each other. One thing that experienced UDK
    developers may come to realize is that you lose a lot of functionality when making
    a game for iOS. For example, if we were creating the game on PC I could just use
    the `UTTeamGame` type which would take care of not attacking actors other than
    the player, but that functionality is broken if you were to use the iOS build.
    Fear not dear reader; I do have a solution and you'll learn about sequences and
    some advanced Kismet in the process!
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—base enemy AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will be creating a rudimentary AI using Kismet and using our sequence
    we will be able to attach this behavior to every AI that we use.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **EnemyAI** sequence by either double-clicking on the sequence in
    the **Graph** pane or clicking on the **EnemyAI** text in the **Sequences** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the **Spawned** variable inside the **Actor Factory** create an external
    object variable by right-clicking and selecting **New Variable** | **External
    Variable** from the menu. Left-click on the variable and inside of its properties
    set **Expected Type** to **SeqVar_Object** and **Variable Label** to **Spawned**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Is Alive** conditional by right-clicking and selecting **New Condition**
    | **Is Alive?** Connect the **Spawned** variable link to the **Players** link
    underneath the conditional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Finish Sequence** action by right-clicking and selecting **New Action**
    | **Misc** | **Finish Sequence**. Under the **Output Label** property type `Dead`.
    Connect the **False** output of the **Is Alive** conditional to the **In** of
    the **Finish** sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Trace** action by right-clicking and selecting **New Action** | **Misc**
    | **Trace**. Connect the **True** output of the **Is Alive** conditional to the
    In of the **Trace**. Connect the **Start** variable link on the bottom of the
    trace equal to the **Spawned** variable used previously. Set the **End** variable
    link to a **Player 0** variable (**New Variable** | **Player** | **Player** with
    **All Players** unchecked). Right-click under the **Distance** variable link and
    create a new Float variable. This is shown in the following screenshot:![Time
    for action—base enemy AI](img/image_1901_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Compare Float** conditional by right-clicking and selecting **New
    Condition** | **Comparison** | **Compare Float**. Underneath the **A** variable
    link connect the variable under Distance in our trace. Underneath **B** create
    a new Float variable and enter a value of `600.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Start Firing At** action by right-clicking and selecting **New Action**
    | **AI** | **Start Firing At**. Set the **Target** variable to the Spawned object
    variable and the **Fire At** link to a **Player 0** object. Connect the **A <
    B** of the **Compare Float** conditional to the **In** of the **Start Firing At**
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Stop Firing** action by right-clicking and selecting **New Action**
    | **AI** | **Stop Firing**. Set the **Target** variable to the Spawned object
    variable. Connect the **A >= B** of the **Compare Float** conditional to the In
    of the **Start Firing At** action. We will see the output as shown in the following
    screenshot:![Time for action—base enemy AI](img/image_1901_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if our enemy is alive, we will perform a trace on the screen which will
    create a line between the actor and the player and will see whether there is anything
    between them that would break **line-of-sight** (**LOS**). If the AI can see the
    player and he's within a certain distance of the player, he will start fi ring
    at him. If something is in the way he will stop. Of course, right now this is
    only called once. So aft er it happens once it won't be called again. What if
    the player runs away from the fight? We want to have the enemy chase aft er the
    player.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a **Compare Bool** conditional by right-clicking and selecting **New
    Condition** | **Comparison** | **Compare Bool**. Underneath the Bool variable
    link create a **Bool** variable with a **False** value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Move To Actor** action by right-clicking and selecting **New Action**
    | **AI** | **Move To Actor**. Underneath the **Target** variable link connect
    the Spawned object. Under **Destination** create a Player variable and connect
    it. Connect the **True** output from the **Compare Bool** conditional to the In
    input on the **Move To Actor** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Toggle** action by right-clicking and selecting **New Action** |
    **Toggle** | **Toggle**. Underneath the **Bool** variable link connect the **Bool**
    variable we created earlier with `False` as the value. Connect the Out output
    of the **Start Firing At** action to the **Turn On** input of this **Toggle**
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Delay** action by right-clicking and selecting **New Action** | **Misc**
    | **Delay**. In the **Properties** pane change the **Duration** to `0.20`. Connect
    the **Out** from the **Toggle** and **Move to Actor** actions as well as the **False**
    output from the Compare Bool conditional to the **Start** input of our **Delay**.
    Connect the **Finished** output of our **Delay** action to the **In** of the **Is
    Alive** conditional we created at the beginning of this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in the following screenshot:![Time for action—base
    enemy AI](img/image_1901_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our enemy now responds to what we do in the world! If we come within a distance
    of `600` or closer to the enemy, and it has a clear line-of-sight, it will start
    firing at us. If the player runs a certain distance away or goes behind some cover,
    it will attempt to travel to us. However there is still a lot of work to do.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements to be made
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of running to the player's position, the enemy we spawned goes towards
    the spawn point, or rather the place where the character was initially created,
    rather than where they currently are. It will continue to follow delete us, until
    it can fire at us again as well. Shouldn't it give up after a while? If we start
    attacking the enemy at a distance, the player will not react and will just take
    hits as well. With this basis, we can now extend our AI to be much more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—base enemy AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we will be creating a rudimentary AI using Kismet and using our sequence
    we will be able to attach this behavior to every AI that we use.
  prefs: []
  type: TYPE_NORMAL
- en: Go into the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there, you will see a list of classes that we can place within
    our level. Type `Path` in the **Search** bar and left-click on the **PathNode_Dynamic**
    selection. The following screenshot shows this:![Time for action—base enemy AI](img/image_1901_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the **Actor Classes** browser and right-click anywhere in your level.
    From the menu that pops up, select **Add PathNode_Dynamic Here**. This will create
    an actor on the ground in the spot where you clicked. Place it nearby the player's
    spawn point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the **EnemyAI** sequence by either double-clicking on the sequence in
    the **Graph** pane or clicking on the **EnemyAI** text in the **Sequences** pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the connections to the **Start** input on the **Delay** action by holding
    *Alt* and clicking on the black square. Left-click on the **Delay** action, hold
    *Shift* and drag it to the right-hand side to give some room for our new additions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Move to Actor** action and its attached variables by holding down
    *Ctrl* + *Alt* and left-clicking slightly above and to the left-hand side of the
    **Move to Actor** action, and drag until the box you create covers all of the
    items we want to move. Alternatively, hold *Ctrl* and click on each item. Move
    the objects to beside the **Delay** position. Delete the connection from the **In**
    of the **Move To Actor** action and connect the **Out** from the **Move To Actor**
    action to the **Start** of the **Delay** action. Connect the **Out** of our **Toggle**
    action to the **Start** of the **Delay** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Compare Float** conditional next to our **Compare Bool** action by
    right-clicking and selecting **New Condition** | **Conditional** | **Compare Float**.
    Connect the **True** of the **Compare Bool** conditional to the **In** input of
    this **Compare Float**. Connect the **False** output of the **Compare Bool** to
    the **Start** input on the **Delay** action. Create a float variable in both the
    **A** and **B** section of our **Compare Float** action. Inside the **A** float
    variable, create a comment saying **timeSinceCaught** with a value of `0.0`. Set
    the **B** variable to have a value of `2.0`. What I'm trying to accomplish in
    this section, is making it so that if the AI chases after the player and a certain
    time passes, he will give up and stop where he is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Add Float** action by right-clicking and selecting **New Action**
    | **Math** | **Add Float**. Connect the **A** and **Float Result** variables of
    **Add Float** action to the float variable that we placed a comment saying **timeSinceCaught**,
    which is connected to the **A** link on our **Compare Float**. Connect the **A
    < B** output of our **Compare Float** to the **In** of our **Add Float** action.
    Create a float variable below **B** with a value of `0.2`. The following screenshot
    shows this:![Time for action—base enemy AI](img/image_1901_05_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this acti on is called every 0.2 seconds (due to our delay), we add 0.2 to
    our counter if it has been less than 2 seconds since we started chasing the player
    after seeing them for the fi rst ti me. What do we do if we have waited 2 seconds
    or more? That's what we're going to do next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Below the **Add Float** action we just created add a **Set Float** action by
    using **New Action** | **Set Variable** | **Float**. Create a new float with a
    value of `0.0` for the **Value** link and connect the **Target** variable to the
    **timeSinceCaught** float variable. Connect the **A >= B** output from the **Compare
    Float** conditional to the **In** of our **Set Float** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Toggle** action by right-clicking and selecting **New Action** |
    **Toggle** | **Toggle**. Underneath the **Bool** variable link connect the **Bool**
    variable we created earlier with **False** value. Connect the **Out** output of
    the **Set Float** action to the **Turn Off** input of this **Toggle** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Modify Property** action by using **New Action** | **Object Property**
    | **Modify Property**. Go to the **Properties** pane and left-click on the green
    **+** sign beside the **Properties** variable, to create a new property to change.
    Click on the black triangle on the left-hand side to expand the options. Inside
    the **Property Name** property type `bLockLocation`. Click on the checkbox for
    **Modify Property**. Finally, in the **Property Value** section type `1`. This
    is shown in the following screenshot:![Time for action—base enemy AI](img/image_1901_05_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **bLockLocati** on variable is a **Bool** contained within our **Actor**
    class that will prevent an actor from being moved. With a value other than 0,
    a **Bool** will treat the value to mean true which will freeze our AI unti l we
    set the value back to 0\. Note that UDK will give us a warning about using the
    **Modify Property** acti on, but as we are not going to be using UnrealScript
    for our project it will be fine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Connect the **Out** from the **Toggle** action to the **In** of our **Modify
    Property** action. Connect the **Target** to the **Spawned** external variable.
    Connect the **Out** output of the **Modify Property** action to the **Start**
    on our **Delay** action on the far right-hand side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next to the **Add Float** that we created in step 8 create a **Modify Property**
    action by using **New Action** | **Object Property** | **Modify Property**. Go
    to the **Properties** pane and left-click on the green **+** sign beside the **Properties**
    variable to create a new property to change. Click on the black triangle on the
    left-hand side to expand the options. Inside the **Property Name** property type
    `bLockLocation`. Click on the checkbox for **Modify Property**. Finally, in the
    **Property Value** section type `0`. Connect the **Out** output of the **Add Float**
    action to the **In** of our new **Modify Property** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back into the editor and confirm that you have the **PathNode_Dynamic_0**
    selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in Kismet create a **Get Location and Rotation** action **New Action**
    | **Actor** | **Get Location and Rotation**. Set the **Target** variable to **Player
    0** by creating a player object variable. Right-click under the **Location** link
    and select **Create New Vector Variable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the **Player** variable under the **Move to Actor** action and right-click
    under the **Destination** variable and select **New Object Var using PathNode_Dynamic_0**.
    Create a **Set Actor Location** action **New Action** | **Actor** | **Set Actor
    Location**. Connect the **Location** variable link to the location that we created
    in the previous step. Connect the **Target** of the **Set Actor Location** action
    to the **Destination** variable link on the **Move to Actor**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Above our **Trace** action create a **Take Damage** event by right-clicking
    and selecting **New Event** | **Actor** | **Take Damage**. In the **Properties**
    pane set **Max Trigger Count** to `0`. Connect the **Instigator** to the **Spawned**
    object. Connect the **Out** output to the **In** input of the **Start Firing At**
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will make it so that if the player decides to att ack someone from far
    away, that the enemy will react in some way by chasing aft er the player. Finally
    we will see something similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—base enemy AI](img/image_1901_05_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Back in the editor window, click on the **Door** we created in the previous
    chapter. Open its properties by pressing *F4* and type `path` in the search box.
    You will see a box checked for the value **Path Colliding**. Uncheck it. Unchecking
    the **Path Colliding** value lets the editor know that it is possible for AI to
    pass through the door, as it will treat the area as being open even though we
    have a door there. If you intend to not allow enemies to use doors then you'd
    want to make sure this is checked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in following screenshot:![Time for action—base
    enemy AI](img/image_1901_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We breathed much more life into the routines of our AIs; they are now reacting
    to us in a much more believable way, and are good enough for what we are doing
    in our project. Now the enemies will chase to where you are for a period of time,
    giving up after a while, and if you attack them from anywhere, they will react
    to you. We've also been exposed to much more advanced Kismet scripting, showing
    us how we can manipulate the game environment based on events happening in the
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—taking your AI further
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are plenty of other things that you can add to your AI, such as different
    states depending on how close the player is to them (distance of the **Trace**
    action was discussed in the *Base enemy AI* section). Right now as long as the
    **timeSinceCaught** variable is less than 2.0, the `PathNode_Dynamic` is set to
    your actual position as well. You could make it so that the AI could only know
    where you were at that point (only setting the position once). You can use the
    **Bool** (true/false statement) the variable red in color as a way of checking
    whether it was already set or not.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that you can do is use a **Timer** (**Action** | **Misc** | **Timer**)
    rather than using float comparisons and addition, toggling a timer on and off
    as necessary to add one other tool to your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting subsequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After setting up a useful subsequence such as our **EnemyAI** event that we
    created, we may want to share it between other levels. One way to do this is just
    copy/pasting; but what if we want to share our sequence with other developers/designers
    or on different computers? One of the neat things that we can do with sequences
    is export them so that we can place them inside our levels much in the same way
    that we place meshes or **Actor Classes**. One thing to note though is that when
    a sequence is imported it will remove all references to objects within the level
    that was created, so for that reason having external variables for items is vital
    to make sure that the sequence performs the way we'd like it to.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—creating a second enemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, it's a good idea to save our **EnemyAI** subsequence as we are
    going to use it inside our final level. As this is the first time we've exported
    something to the content editor, I'm going to be very thorough.
  prefs: []
  type: TYPE_NORMAL
- en: Go into to the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there you will see a list of classes that we can place within
    our level. Type `Path` in the **Search** bar and left-click on the **PathNode**
    selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the **Actor Classes** browser and right-click in front of the door we
    created in the previous chapter. From the menu that pops up, select **Add PathNode
    Here**. Select the **PathNode**, hold **Option** and drag the object behind the
    door, creating a copy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on our **EnemyAI** subsequence and select **Export Sequence to Package**.
    This is shown in the following screenshot:![Time for action—creating a second
    enemy](img/image_1901_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A prompt will come up asking for the package, group, and name of your object.
    Under **Package** put `UrbanWarrior`, in **Group** put `Sequences`, and under
    **Name** put `EnemyAI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the **Content Browser**, and in the **Search** bar underneath **Packages**
    type `urban`. You should see your package come up on top with your sequence being
    the first item selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the package (it should have a ***** next to it) and click on
    **Save**. This is shown in the following screenshot:![Time for action—creating
    a second enemy](img/image_1901_05_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the **EnemyAI** sequence and open up the Kismet editor. Move to
    the left-hand side of our **EnemyAI** sequence, right-click and select **Import
    EnemyAI Sequence**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may not see anything change, but there is a good reason for that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Left-click on the **EnemyAI** subsequence and move it by holding *Alt* and dragging
    it to the left-hand side. You will notice that the new subsequence that we imported
    has the same position as when we exported it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the **PathNode** behind where the player is and go back into Kismet.
    Underneath the **Spawn Point**, right-click and select **New Object Var using
    PathNode_2 Here**. Create a new **Object** variable for the **Spawned** variable
    link. Connect the **Dead** output from the first **EnemyAI** sequence up to the
    **In** input of this **EnemyAI**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Move To Actor** action by right-clicking and selecting **New Action**
    | **AI** | **Move To Actor**. Underneath the **Target** variable link connect
    the **Spawned** object. Under **Destination** connect it to the **PathNode** in
    front of the door. Connect the **Spawned** output from the **EnemyAI** subsequence
    to the **In** input on the **Move To Actor** action. We will see the output as
    shown in the following screenshot:![Time for action—creating a second enemy](img/image_1901_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar, as shown in the following screenshot:![Time for action—creating
    a second enemy](img/image_1901_05_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The world is becoming more and more dynamic. By using an imported subsequence
    we made it so that if our first enemy died, a second enemy would spawn and rush
    through the door to see what was going on.
  prefs: []
  type: TYPE_NORMAL
- en: Remote events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As seen in the previous sequence that we created, Kismet can often get quite
    complex and over time may become quite jumbled up. One possible solution to stop
    stay connections going all over the place is to use **Remote Events**. Similarly
    to our **Level Loaded** or **Player Spawned** events, whenever we activate a remote
    event through the **Activate Remote Event** Kismet action the actions and conditionals
    connected to it are called.
  prefs: []
  type: TYPE_NORMAL
- en: When we can use a remote event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remote events sound quite amazing, but they can't always be used. Each remote
    event needs to have a specific name and UDK will get confused if you have multiple
    versions of the same remote event. This is also why we cannot have variables with
    the same name. If you are planning on re-using the same sequence for multiple
    objects, you cannot use them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a remote event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a **Remote Event** you right-click inside the **Graph** pane in Kismet
    and select **New Event** | **Remote Event**. After creating the event, go into
    its **Properties** and under the **Event Name** variable type a unique identifier.
    When you want the actions associated with the Remote Event to be called you just
    need to create an **Activate Remote Event** action **New Action** | **Event**
    | **Activate Remote Event** and in the **Properties** pane find the variable **Event
    Name** and set it to that same identifier. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a remote event](img/image_1901_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Named variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In programming there is such a thing as global variables. **Global variables**
    are things that you wish to have at all times within the game; for example, a
    player's gold or the number of enemies currently spawned. This can be very useful
    if it's a piece of data that you use quite often. **Named variables** are basically
    Kismet's version of global variables; however, they are only global in terms of
    the level currently loaded.
  prefs: []
  type: TYPE_NORMAL
- en: When we can use a named variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **named variable**, just like a remote event, needs to have unique names which
    is why we used a comment instead of a variable name for our **timeSinceCaught**
    variable in our **EnemyAI** sequence. The nice thing about having variables with
    names is that instead of creating links to the one variable every single time,
    like we did with the **Spawned** external variable in our **EnemyAI** sequence,
    we can just create new named variables to hook it up to make our script much more
    organized.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a named variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a named variable you right-click inside the **Graph** pane in Kismet
    and select **New Variable** | **Named Variable.** After creating the variable
    and going into its properties you can set the expected type to what it is and
    under the **Find Var Name** property just fill in the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything goes correctly, you''ll see a green checkmark in its position
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a named variable](img/image_1901_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Manipulating the player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have worked in such a way to create actions that work with the AIs we are
    going to place within the world, but there is one thing in the game that is more
    important that we haven''t worked on yet at all: the player! Adding new types
    of gameplay or new mechanics are often tested out in Kismet before writing in
    UnrealScript, making it a lot easier to iterate. Make sure that the mechanics
    are? fun and interesting. Now that we have someone to shoot at us and some smarts,
    let''s add a new mechanics to our player.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—regenerating player health over time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Made popular in *Halo* and seen in hit games such as *Gears of War* and *Batman:
    Arkham City*, regenerating health is a modern game mainstay that features in many
    *games* and are here to stay. Surprisingly, it is not that difficult at all to
    implement within Kismet, and you may notice some overlap between the behavior
    we use here and what we did previously.'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Kismet editor and enter our main sequence and drag the screen till
    you have a large amount of open space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a remote event by selecting **New Event** | **Remote Event**. In the
    **Properties** pane set the **Event Name** variable to `RegenHealth`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Directly above the remote event create a **Level Loaded** event by right-clicking
    and selecting **New Event** | **Level Loaded**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To the right of the **Level Loaded** event create an **Activate Remote Event**
    action by right-clicking and selecting **New Action** | **Event** | **Activate
    Remote Event**. In the **Properties** pane find the variable **Event Name** and
    set it to `RegenHealth`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that both the **Activate Remote Event** and remote event **RegenHealth**
    may still have a large red **X** in them. This is either due to a misspelling,
    or the sequence has not been refreshed. If you exit and enter Kismet again, you
    will see both of the objects have a green checkmark next to them as shown in the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action—regenerating player health over time](img/image_1901_05_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: To the right-hand side of the remote event **RegenHealth** create a **Get Property**
    action by right-clicking and selecting **New Action** | **Object Property** |
    **Get Property**. In the **Properties** pane set the **Property Name** variable
    to `Health`. Underneath the **Target** variable link create a **Player 0** object
    variable. Underneath the **Int** variable link create a new **Int** variable by
    right-clicking underneath it and selecting **Create New Int Variable**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the UnrealScript file for the **Player** in the **Pawn Class** there
    exists an integer that has the name of **Health** which stores the player's health.
    The **Get Property** acti on allows us to see the value that it contains in our
    target, if it contains that variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a **Compare Int** conditional by right-clicking and selecting **New Condition**
    | **Comparison** | **Compare Int**. Underneath the **A** variable link connect
    the variable under **Int** in our **Get Property**. Underneath **B** create a
    new **Int** variable and put a value of `100`. Connect the **Out** from the **Get
    Property** action to the **In** input of the **Compare Int** conditional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Basically, we're going to compare whether our **Health** is lower than **100**
    (the maximum value it can be at the moment) or not.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a **Modify Property** action by using **New Action** | **Object Property**
    | **Modify Property**. Go to the **Properties** pane and left-click on the green
    **+** sign beside the **Properties** variable to create a new property to change.
    Click on the black triangle on the left-hand side to expand the options. Inside
    the **Property Name** property type `Health`. Click on the checkbox for **Modify
    Property**. Finally, in the **Property Value** section type `100`. Under the **Target**
    variable link place a **Player 0** object. Connect the **A >= B** from the **Compare
    Int** conditional to the **In** of the **Modify Property** that we just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Compare Float** conditional by right-clicking and selecting **New
    Condition** | **Comparison** | **Compare Float**. Underneath the **A** variable
    link create a new **Float** variable and put a value of `0.0` with the **Var Name**
    of **TimeSinceDamaged**. Underneath **B** create a new **Float** variable with
    a Float Value of `2.0` and **Obj Comment of TimeSinceLastDamaged**. Connect the
    **A < B** output of the **Compare Int** conditional to the **In** input of this
    **Compare Float** conditional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Set Float** action by using **New Action** | **Set Variable** | **Float**.
    Create a new float with a value of `0.0` for the **Value** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a named variable with an **Expected Type of SeqVar_Float** and a **Find
    Var Name of TimeSinceDamaged** and connect the **Target** variable link from the
    **Set Float** action to it. Connect the **Out** of the **Modify Property** (**Health**)
    to the **In** input of our **Set Float** action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Activate Remote Event** action **New Action** | **Event** | **Activate
    Remote Event** and in the **Properties** pane, find the variable **Event Name**
    and set it to **RegenHealth**. Connect the **Out** output of our **Set Float**
    action to the **In** of our **Activate Remote Event** variable **RegenHealth**.
    This is shown in the following screenshot:![Time for action—regenerating player
    health over time](img/image_1901_05_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a **Modify Health** action **New Action** | **Actor** | **Modify Health**.
    Under the **Target** variable link create a **Player 0** object variable. Under
    amount create a **Float** variable with a value of `1.0`. Inside the **Properties**
    pane check the **Heal** checkbox and connect the **A >= B** from our **Compare
    Float** conditional to the **In** of this action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may noti ce that we are not using **Modify Property** like we did in the
    previous example; this is merely to show you that there are oft en multi ple ways
    of doing the exact same thing within Kismet and by experimenti ng you can discover
    all sorts of things that you can do.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy (*Ctrl* + *C*) and Paste (*Ctrl* + *V*) the **Activate Remote Event** variable
    **RegenHealth** that we created earlier. Drag the action till it is beside the
    **Modify Health** action we just created. Delete this one's connection to its
    **In** input by left-clicking while holding the *Alt* key. Copy and paste another
    one with the **In** removed and place it above this one. Hook the **Out** from
    our **Modify Health** to the one beside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Add Float** action by right-clicking and selecting **New Action**
    | **Math** | **Add Float**. Connect the **A** and **Float Result** variables of
    **Add Float** to a named variable with the value of **TimeSinceDamaged** like
    we did in step 10\. Connect the **A < B** output of our **Compare Float** to the
    **In** of our **Add Float** action. Create a **Float** variable below **B** with
    a value of `0.2`. Finally, connect the **Out** output of this **Add Float** to
    the extra **Activate Remote Event** variable **RegenHealth** we created in the
    previous step.![Time for action—regenerating player health over time](img/image_1901_05_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in the following screenshot:![Time for action—regenerating
    player health over time](img/image_1901_05_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can't tell by a still image, but we're one step closer to having a fully
    featured game, with the fantastic addition of a regenerating health system. When
    our health is not at maximum, we wait for a period of time and if we are not hit
    within that time period, we will slowly increase our health over time. We've also
    gained a good knowledge of how to use named variables, getting and setting object
    properties in Kismet, as well as experience in using remote events.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero—regenerating player health over time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this base system, there are plenty of things that you can do to extend
    the functionality. It would be easy to do something similar to *Halo''s* shield
    recovery, by having the recovery go faster than the lower health you have, by
    changing the float value under the **Modify Health** action. You could also use
    the same sequence with a few changes to make it into something that will damage
    you if you spend too much time in it like with the water in *Sonic: The Hedgehog*.'
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often when constructing a level, you want to create some arrangement of
    actors and associated Kismet, and then re-use that collection in the same or other
    levels, like the door we created. Prefabs allow you to create an object once,
    and then save it in a package as a prefab. You can then select the **Prefab**
    in the **Content Browser**, and add it as many times as you like throughout the
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Note that prefabs can cause problems in UDK and may break and/or stop working
    for seemingly no reason so SAVE OFTEN after making sure that things work.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action—door prefab
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now we have one single door, and while it is an awesome door, we would
    probably like to have more than one inside our game. To make it easier to work
    with and place in new areas of our game, let's make a door prefab!
  prefs: []
  type: TYPE_NORMAL
- en: In Kismet, go to the door behavior that we wrote in the previous chapter. Hold
    *Alt+Ctrl* and drag from the top left-hand side of the objects to the bottom,
    to select all of the items used in the creation. Right-click and select **Create
    New Sequence**. In the following menu name the sequence `Door`. This is shown
    in the following screenshot:![Time for action—door prefab](img/image_1901_05_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly in the regular editor window, select all of the objects used to create
    our door, including the walls surrounding it and the trigger volume used in its
    creation. Right-click and select **Create Prefab**.![Time for action—door prefab](img/image_1901_05_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the popup that is created under **Packages** use the name `UrbanWarrior`
    and inside the **Name** use `Door.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another popup will come up telling you that it detected a Kismet sequence using
    items of this prefab and wants to confirm that we want it to be part of the prefab.
    Click on **Yes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that a prefab can only have one sequence associated with it, and you cannot
    use the main sequence as your sequence that uses that prefab. Unlike the subsequences
    that we exported/imported earlier, these objects will have the variable links
    in the sequence corresponding to the new copies made inside the prefab, which
    is a really neat thing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally the popup will ask if you'd like to convert your door to an instance
    of the prefab; this is a good idea so click on **Yes**. You will now notice a
    red **P** symbol next to our door letting us know that it is a prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Left-click on the prefab object and hold *Alt* while dragging it along an axis
    to create a copy of the door a distance away from the base point. You should see
    a second prefab being created and moved, as you drag along making another door
    in the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The walls will not appear inside the perspective view until you build the game,
    due to it not being able to render changes in BSP at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar, saying **Yes** when it asks you to save the package.
    The following screenshot shows the modified views:![Time for action—door prefab](img/image_1901_05_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now quickly and easily created a second door inside our level. The same
    functionality included in our previous door is still there, allowing us to enter
    and exit through both of them quite easily with the sound effects and everything.
    Using the prefab, it will be trivial to make new doors, and as they aren't forced
    to be the same (like Unity) we can change anything about each individual prefab
    without worrying about how it will affect the others.
  prefs: []
  type: TYPE_NORMAL
- en: Building combat sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As someone who enjoys playing games can attest to, there are always moments
    in gameplay that stand out from others. We've also played games where it just
    seemed that you were going through corridor after corridor, with little to no
    exciting things happening, with the game turning into a bore. Crafting a satisfying
    combat experience is something that every designer strives to do, and here are
    some suggestions on my end as to ways of doing just that.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By failing to prepare, you are preparing to fail. - Benjamin Franklin
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A good layout is the basis of a solid foundation for the creation of your level,
    and as such is probably the most important thing to consider when beginning a
    level. This is one of the numerous reasons why pre-production on game projects
    is so important. It may go against your initial thoughts, but it is not a good
    idea to just go in the editor and try to make something. While every once in a
    while you may stumble into something, it is far more likely that if you plan something
    out that the resulting level will be much better. That's not to say that what
    you plan in pre-production will be the same as how you planned it. Playtesting
    your level may teach you that certain things in the layout are confusing and/or
    too easy or hard which are important things to take note of. One of the most important
    things to keep in mind when working on a layout is making it easy to read at a
    first glance. Keep action in the player's **field of view** (**FOV**) when creating
    action.
  prefs: []
  type: TYPE_NORMAL
- en: You may have already noticed how in our current version of our layout our door
    is not in the player's view when spawned, making it confusing to where the player
    should continue in the game. This sends mixed signals, which is never a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Spawning and enemy placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, having a great layout is good, but if there is nothing to do in the
    environment, players will soon grow bored and as such we spawn opponents to face
    them. It is terribly important that enemies get spawned out of sight of the player,
    because seeing an enemy suddenly appear out of nowhere will suddenly break the
    suspension of disbelief that our player should be feeling, unless of course it
    is known as an ability of an enemy such as the Houdini splicers in *Bioshock*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we also don't always want our enemies to be static; which is why
    we will often have enemies walking according to a path, or coming in from an area.
    This movement should give our player a visual cue, as just like the real world
    there is usually a reason why something is where it is. If your game has stealth
    elements, the player may wait to see a pattern emerging in the enemy's path to
    avoid conflict. If your game is an action based shooter, our player will be likely
    travel to where they see things come from. Another thing to keep in mind is to
    know your engine's limitations, especially working within the mobile gamespace,
    as mobile platforms are much more demanding on the hardware when spawning enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pretty art is pretty, but it can't make up for poor design. For artistic people,
    like me, it can be incredibly easy to fall into the trap of starting to polish
    up an area before finishing it. After doing preproduction by designing a layout,
    build your level using BSP additive brushes at first. At this point, the focus
    in the level is creating an environment that is fun, and has some semblance to
    the environment that we want the level to take place in. It is important to do
    whatever we can, to exploit the type of gameplay that we want to occur as well.
    For example, we could give the player places to hide from enemies and take pot
    shots, making the player feel smart for outsmarting the enemies.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important things you can do as a designer is empowering the
    players as they are not your enemies, they're your best friends, and are ultimately
    who gives you your pay check, so it's important to respect them. Aside from the
    actual physical environment, an environment's lighting can be used in many different
    ways to affect players. Primarily, light draws focus to things and leads players
    to travel towards it. Darkness and the unknown are uncomfortable areas for players
    to be in and not lighting areas as much as others adds to the foreboding nature
    that an area could have. *Monolith's* F.E.A.R. does this quite nicely by turning
    a regular everyday office into an intense and dangerous place to be in, even though
    you are fully armed and equipped to handle anything that may come by your way.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As important as the placement and spawning of an enemy is, if the enemy doesn't
    do anything the game will get old quickly. We've created a basic AI for what an
    enemy could do to enemies, and there are a lot of ways to expand upon it and create
    unique situations based on what is going on in the game. In large open areas,
    as long as the player does something resembling intelligence, things seem to go
    well to which our AI, though limited, can be used to good effect. In general,
    the tighter the environment, the more you'll want to hand-script the enemy's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Flanking is a type of behavior in which an enemy is able to come at a target
    from its sides or behind it, catching it off guard. Flanking in games can be both
    good and bad. If done well, it can make the player improvise and feel a rush of
    excitement. If done poorly however, it will make player think AI is cheating,
    and cause the player to resent the encounter. If you do decide to implement flanking,
    wait and let the player engage the area before attempting to flank, and make the
    first shot miss and let the player notice where the shot came from so they can
    adjust.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool that designers can utilize is the idea of waves in an environment
    where you spawn different enemies at different times, in order to extend the gameplay
    and time spent in a certain area. However, each wave should be unique or else
    the player will get bored easily. *Dungeon Defenders* does this in a good way
    by incrementing difficulty over time making sure that things don't get boring.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind the difficulty of your waves and encounters in general, and modify
    the elements that you can in order to curve up the difficulty in each encounter,
    but also give the player a chance to take a breather once in a while to reflect
    on how powerful he has become.
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In my opinion, a game designer is the player's advocate and in that role, their
    main responsibility is to make a game that your target audience will love. Because
    of this, playtesters are a game designer's best friend. They are the voice of
    how a normal person is going to react to your game, and as such it is important
    that you take what they say seriously. They are the people that are going to find
    and exploit anything they can get their hands on within your world as well and
    you will find things you never thought of possible in your game. They are going
    to suggest changes and it will be your decision whether or not those changes are
    really worth having or not.
  prefs: []
  type: TYPE_NORMAL
- en: It is also very important that you have people to play your game without your
    input. Most designers believe that they have covered every possible thing a player
    can do, but it is almost guaranteed that something has been forgotten. In level
    design, it is important to see what directions players go in, and whether they
    are being guided in the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have all of the pieces that we need to create our game and have learned
    a lot of things in the process. By using the same principles given in this chapter
    it is possible to expand and create many different types of enemies and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this short period of time we managed to cover quite a lot of things. We
    specifically learned the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What sequences are and how we use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to spawn an enemy into our level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we can do to develop a rudimentary AI system that will shoot at us if we
    are close to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to expand upon that system by adding chasing and retreating behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create additional enemies using import/export subsequences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement regenerating health using remote events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What prefabs are and how we can and their use them in our project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make a door prefab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Things to consider when creating combat scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we've learned how to build all of the base elements that we will need to
    implement our game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be bringing all of these pieces together to create
    our full-fledged game by discussing a workflow for creating levels using **Geometry
    Mode**, how to use modular pieces to create our level quickly, and advice on building
    levels on
  prefs: []
  type: TYPE_NORMAL
