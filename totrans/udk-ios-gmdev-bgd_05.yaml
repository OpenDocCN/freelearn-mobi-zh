- en: Chapter 5. Action Sequences for Urban Warrior
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章.城市战士的动作序列
- en: In the previous chapter, we built up a basic understanding of the lovely tools
    of Kismet and Matinee and how they can work together in some simple examples.
    But now that we know the basics can't we do more? Oh yes, we certainly can.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在上一章中，我们建立了对可爱的Kismet和Matinee工具的基本理解以及它们如何在一些简单示例中协同工作。但现在我们已经了解了基础知识，我们不能再做更多了吗？哦，是的，我们当然可以。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter we are going to create a series of sequences and prefabs to
    set the groundwork, allowing us to easily create our level in the next chapter.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一系列序列和预制件，为下一章中轻松创建我们的关卡打下基础。
- en: 'In this chapter we shall:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Discuss what sequences are and how we use them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论序列是什么以及我们如何使用它们
- en: Spawn an enemy into our level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将敌人生成到我们的关卡中
- en: Develop a rudimentary AI system that will shoot at us if we are close
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个基本的AI系统，如果我们在附近，它会向我们射击
- en: Expand upon that system by adding chasing and retreating behavior
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加追逐和撤退行为来扩展该系统。
- en: Import/export subsequences to create additional enemies easily
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入/导出子序列以轻松创建额外的敌人。
- en: Implement regenerating health using remote events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用远程事件实现健康恢复
- en: Discuss prefabs and their use in our project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论预制件及其在我们项目中的使用
- en: Make a door prefab
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个门预制件
- en: Discuss workflow and things to consider when creating combat scenarios
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论创建战斗场景时的流程和注意事项
- en: So with that, let's take a look at what we can do with sequences.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看我们可以用序列做什么。
- en: Sequences and you
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列与您
- en: Sequences are UDK's ways of helping you organize your code as well as compartmentalize
    all of the actions that you want to have happen in a certain area. Events and
    their associated actions, that you will be re-using, are also prime candidates
    for being placed inside sequences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是UDK帮助我们组织代码以及将所有希望在特定区域发生的动作分区的途径。您将重新使用的事件及其相关动作也是放置在序列中的理想候选者。
- en: Anyone who works with Kismet has worked with sequences before. You have already
    been using sequences without even knowing it. UDK provides us with a **LevelName**
    sequence within the Kismet editor that we have used in the previous chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何使用过Kismet的人之前都使用过序列。您已经在不知不觉中使用了序列。UDK在Kismet编辑器中为我们提供了一个**LevelName**序列，我们在上一章中使用过。
- en: Life, or something like it
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命，或者类似的东西
- en: Now that we have an idea of what sequences are, let's create one of our own!
    It will enable us to bring the characters to life, such as enemies, explained
    in this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了序列是什么，让我们创建一个自己的序列！这将使我们能够使角色栩栩如生，如本节中解释的敌人。
- en: Time for action—spawning AI into our level
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——将AI实体生成到我们的关卡中
- en: As we are creating the building blocks of our game, creating a third person
    shooter is kind of hard to do without having enemies to fight. Thankfully UDK
    has helped us out and made it incredibly easy to add enemies into our level!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在创建游戏的基础模块，如果没有敌人来战斗，制作第三人称射击游戏有点困难。幸运的是，UDK帮助我们并使添加敌人到我们的关卡变得极其简单！
- en: Go into to the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there you will see a list of classes that we can place within
    our level. Type `Path` in the **Search** bar and left-click on the **PathNode**
    selection. The following screenshot explains this:![Time for action—spawning AI
    into our level](img/image_1901_05_01.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**演员类**浏览器**视图** | **浏览器窗口** | **演员类**。从那里您将看到我们可以放置在我们关卡中的类列表。在**搜索**栏中输入`Path`，然后左键单击**PathNode**选择。以下截图解释了这一点：![行动时间——将AI实体生成到我们的关卡中](img/image_1901_05_01.jpg)
- en: Close the **Actor Classes** browser and right-click anywhere in your level.
    From the menu that pops up select **Add PathNode Here**. This will create an actor
    on the ground on the spot where you clicked. I have placed my **PathNode** away
    from the player but still visible from the camera for our opening sequence.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**演员类**浏览器，并在您的关卡中任何地方右键单击。从弹出的菜单中选择**在此处添加PathNode**。这将创建一个在您点击的位置地面的演员。我已经将我的**PathNode**放置在玩家附近，但仍然在摄像机视图中可见，以便我们的开场序列。
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击UDK界面主工具栏顶部的**K**图标来打开Kismet编辑器。
- en: Left click-and-drag the background of the workspace to move the graph plane,
    bringing some open space for us to work with.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击并拖动工作空间的背景以移动图形平面，为我们提供一些可以工作的开放空间。
- en: 'Right-click somewhere in the background and select **Create New Sequence: 0
    Objs**. A pop-up window should come up asking you for the name of the sequence.
    Type `EnemyAI` and press *Enter*. A little box with the name should be created
    at the position where you right-clicked.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击在背景中的某个位置，并选择 **创建新序列：0 Objs**。应该会弹出一个窗口询问你序列的名称。输入 `EnemyAI` 并按 *Enter*。在右键点击的位置应该会创建一个带有该名称的小框。
- en: Double-click on the **EnemyAI** sequence. You will notice that we have now moved
    into this sequence and there is nothing there, and that our Sequences pane on
    the bottom at right-hand side has the **EnemyAI** sequence highlighted. This is
    shown in the following screenshot:![Time for action—spawning AI into our level](img/image_1901_05_02.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 **EnemyAI** 序列。你会注意到我们现在已经进入了这个序列，里面没有任何内容，而且我们底部的右侧序列面板中高亮显示的是 **EnemyAI**
    序列。这如图所示：![执行动作——将 AI 孵化到我们的关卡](img/image_1901_05_02.jpg)
- en: Right-click and create a **Sequence Activated** event by choosing **New Event**
    | **Sequence Activated** from the menu.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并在背景中创建一个 **Sequence Activated** 事件，通过菜单选择 **新建事件** | **Sequence Activated**。
- en: Create an **Actor Factory** action by right-clicking and choosing **New Action**
    | **Actor** | **Actor Factory** from the menu. Go into the Properties pane and
    click on the blue triangle on the right-hand side of the **Factory** variable
    and select **UTActorFactoryAI** from the pop-up menu that comes out to create
    a new **Actor Factory** to use. Inside our new factory's properties set the **Pawn
    Class** to **UTPawn** and check the **Give Default Inventory** option. Finally,
    change the **Team Index** to **1**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并从菜单中选择 **新建动作** | **演员** | **演员工厂** 来创建一个 **演员工厂** 动作。进入属性面板，点击 **工厂**
    变量右侧的蓝色三角形，并从弹出的菜单中选择 **UTActorFactoryAI** 以创建一个新的 **演员工厂** 来使用。在我们新工厂的属性中设置 **Pawn
    类** 为 **UTPawn**，并勾选 **给予默认库存** 选项。最后，将 **团队索引** 更改为 **1**。
- en: Underneath the **Spawn Point** variable create an external object variable by
    right-clicking and selecting **New Variable** | **External Variable** from the
    menu. Left-click on the variable and in its properties set **Expected Type** to
    **SeqVar_Object** and **Variable Label** to **Spawn Point**.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **出生点** 变量下，通过右键点击并从菜单中选择 **新建变量** | **外部变量** 来创建一个外部对象变量。左键点击该变量，并在其属性中设置
    **期望类型** 为 **SeqVar_Object**，**变量标签** 为 **Spawn Point**。
- en: Create a **Finish Sequence** action by right-clicking and selecting **New Action**
    | **Misc** | **Finish Sequence**. Under the **Output Label** property type `Spawned`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **新建动作** | **杂项** | **完成序列** 来创建一个 **完成序列** 动作。在 **输出标签** 属性下输入 `Spawned`。
- en: Connect the **Out** of the **Sequence Activated "In"** event to the **Spawn
    Actor** input of the Actor Factory action. Connect the **Spawn Point** link to
    the **External Object** variable we created. Finally, connect the **Finished**
    output of the **Actor Factory** to the **Finish Sequence "Spawned"** action. At
    this point our sequence should look as shown in the following screenshot:![Time
    for action—spawning AI into our level](img/image_1901_05_03.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Sequence Activated "In"** 事件的 **Out** 连接到演员工厂动作的 **Spawn Actor** 输入。将 **Spawn
    Point** 链接连接到我们创建的外部对象变量。最后，将 **Actor Factory** 的 **Finished** 输出连接到 **Finish
    Sequence "Spawned"** 动作。此时，我们的序列应该如图所示：![执行动作——将 AI 孵化到我们的关卡](img/image_1901_05_03.jpg)
- en: On the bottom right-hand side of our Kismet editor click on the **LevelName**
    sequence to return to the main level sequence. We should now see the sequence
    look similar to a Kismet node with inputs, outputs, and variable chains, as shown
    in the following screenshot:![Time for action—spawning AI into our level](img/image_1901_05_04.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kismet 编辑器的右下角点击 **LevelName** 序列以返回主关卡序列。现在我们应该看到序列看起来类似于一个带有输入、输出和变量链的 Kismet
    节点，如图所示：![执行动作——将 AI 孵化到我们的关卡](img/image_1901_05_04.jpg)
- en: Right-click and create a **Level Loaded** event by choosing **New Event** |
    **Level Loaded** from the menu.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击并在背景中创建一个 **Level Loaded** 事件，通过菜单选择 **新建事件** | **Level Loaded**。
- en: Go into our level and left-click on the PathNode that you created earlier and
    go back into Kismet. Right-click on our Spawn Point link and select **Create New
    Variable from PathNode_0**. This is shown in the following screenshot:![Time for
    action—spawning AI into our level](img/image_1901_05_05.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入我们的关卡，左键点击之前创建的 PathNode，然后返回 Kismet。右键点击我们的出生点链接，并选择 **从 PathNode_0 创建新变量**。这如图所示：![执行动作——将
    AI 孵化到我们的关卡](img/image_1901_05_05.jpg)
- en: Build our game by selecting **Build** | **Build All** and pressing Close when
    finished.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**构建** | **构建全部**并完成时按关闭来构建我们的游戏。
- en: Save your project. Now start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in following screenshot:![Time for action—spawning
    AI into our level](img/image_1901_05_06.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目。现在，如以下截图所示，通过点击主工具栏上的**开始移动预览器**按钮来开始你的游戏：![行动时间——将AI生成到我们的关卡中](img/image_1901_05_06.jpg)
- en: What just happened?
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Upon the level being loaded (via the **Level Loaded** event) we call our **EnemyAI**
    sequence which spawns an enemy (via an **Actor Factory**) and places him in the
    level where our **PathNode** is. Putting these events and actions into a sequence
    will enable us to put code relevant to our AI in one place making it as simple
    as possible to create new AIs in our future levels.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当关卡加载完毕（通过**关卡加载**事件）时，我们调用我们的**EnemyAI**序列，通过**演员工厂**生成一个敌人，并将其放置在我们**PathNode**所在的关卡中。将这些事件和动作放入一个序列中，将使我们能够将与我们AI相关的代码放在一个地方，使创建我们未来关卡中的新AI尽可能简单。
- en: It lives! but...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它活过来了！但是...
- en: As you can now tell, our actor is in the level, but it isn't really doing anything.
    That is because it lacks **artificial intelligence** (**AI**). Surely we could
    force the actor to use the **Deathmatch** AI that is included in UDK, but if we
    had more than one AI they would fight each other. One thing that experienced UDK
    developers may come to realize is that you lose a lot of functionality when making
    a game for iOS. For example, if we were creating the game on PC I could just use
    the `UTTeamGame` type which would take care of not attacking actors other than
    the player, but that functionality is broken if you were to use the iOS build.
    Fear not dear reader; I do have a solution and you'll learn about sequences and
    some advanced Kismet in the process!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你现在所知，我们的演员已经在关卡中，但它实际上并没有做什么。这是因为它缺少**人工智能**（**AI**）。当然，我们可以强制演员使用UDK中包含的**Deathmatch**
    AI，但如果我们有多个AI，它们会互相战斗。经验丰富的UDK开发者可能会意识到，当为iOS制作游戏时，你会失去很多功能。例如，如果我们是在PC上创建游戏，我可以使用`UTTeamGame`类型，它会处理不攻击玩家以外的演员，但如果使用iOS构建，这个功能就会损坏。不要担心，亲爱的读者；我确实有一个解决方案，你将在学习序列和高级Kismet的过程中了解到它！
- en: Time for action—base enemy AI
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——基础敌人AI
- en: Now we will be creating a rudimentary AI using Kismet and using our sequence
    we will be able to attach this behavior to every AI that we use.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个基本的AI，使用Kismet，并通过我们的序列，我们将能够将此行为附加到我们使用的每个AI上。
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击UDK界面主工具栏顶部的**K**图标来打开Kismet编辑器。
- en: Enter the **EnemyAI** sequence by either double-clicking on the sequence in
    the **Graph** pane or clicking on the **EnemyAI** text in the **Sequences** pane.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**Graph**面板中双击序列或在**Sequences**面板中点击**EnemyAI**文本来进入**EnemyAI**序列。
- en: Underneath the **Spawned** variable inside the **Actor Factory** create an external
    object variable by right-clicking and selecting **New Variable** | **External
    Variable** from the menu. Left-click on the variable and inside of its properties
    set **Expected Type** to **SeqVar_Object** and **Variable Label** to **Spawned**.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Actor Factory**中的**Spawned**变量下方创建一个外部对象变量，通过右键单击并从菜单中选择**新建变量** | **外部变量**。左键单击变量，在其属性中设置**期望类型**为**SeqVar_Object**，**变量标签**为**Spawned**。
- en: Create an **Is Alive** conditional by right-clicking and selecting **New Condition**
    | **Is Alive?** Connect the **Spawned** variable link to the **Players** link
    underneath the conditional.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择**新建条件** | **是否存活**来创建一个**Is Alive**条件。将**Spawned**变量链接连接到条件下方的**Players**链接。
- en: Create a **Finish Sequence** action by right-clicking and selecting **New Action**
    | **Misc** | **Finish Sequence**. Under the **Output Label** property type `Dead`.
    Connect the **False** output of the **Is Alive** conditional to the **In** of
    the **Finish** sequence.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择**新建动作** | **杂项** | **完成序列**来创建一个**Finish Sequence**动作。在**输出标签**属性中输入`Dead`。将**Is
    Alive**条件的**False**输出连接到**Finish**序列的**In**。
- en: Create a **Trace** action by right-clicking and selecting **New Action** | **Misc**
    | **Trace**. Connect the **True** output of the **Is Alive** conditional to the
    In of the **Trace**. Connect the **Start** variable link on the bottom of the
    trace equal to the **Spawned** variable used previously. Set the **End** variable
    link to a **Player 0** variable (**New Variable** | **Player** | **Player** with
    **All Players** unchecked). Right-click under the **Distance** variable link and
    create a new Float variable. This is shown in the following screenshot:![Time
    for action—base enemy AI](img/image_1901_05_07.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **New Action** | **Misc** | **Trace** 创建一个 **Trace** 动作。将 **Is Alive**
    条件的 **True** 输出连接到 **Trace** 的 **In**。将追踪底部的 **Start** 变量链接设置为之前使用的 **Spawned**
    变量。将 **End** 变量链接设置为 **Player 0** 变量（**New Variable** | **Player** | **Player**，不勾选
    **All Players**）。在 **Distance** 变量链接下方右键点击并创建一个新的 Float 变量。这如图所示：![Time for action—base
    enemy AI](img/image_1901_05_07.jpg)
- en: Create a **Compare Float** conditional by right-clicking and selecting **New
    Condition** | **Comparison** | **Compare Float**. Underneath the **A** variable
    link connect the variable under Distance in our trace. Underneath **B** create
    a new Float variable and enter a value of `600.`
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **New Condition** | **Comparison** | **Compare Float** 创建一个 **Compare
    Float** 条件。在 **A** 变量链接下方连接我们追踪中的距离变量。在 **B** 下创建一个新的 Float 变量并输入值 `600.`。
- en: Create a **Start Firing At** action by right-clicking and selecting **New Action**
    | **AI** | **Start Firing At**. Set the **Target** variable to the Spawned object
    variable and the **Fire At** link to a **Player 0** object. Connect the **A <
    B** of the **Compare Float** conditional to the **In** of the **Start Firing At**
    action.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **New Action** | **AI** | **Start Firing At** 创建一个 **Start Firing
    At** 动作。将 **Target** 变量设置为 Spawned 对象变量，并将 **Fire At** 链接到一个 **Player 0** 对象。将
    **Compare Float** 条件的 **A < B** 连接到 **Start Firing At** 动作的 **In**。
- en: Create a **Stop Firing** action by right-clicking and selecting **New Action**
    | **AI** | **Stop Firing**. Set the **Target** variable to the Spawned object
    variable. Connect the **A >= B** of the **Compare Float** conditional to the In
    of the **Start Firing At** action. We will see the output as shown in the following
    screenshot:![Time for action—base enemy AI](img/image_1901_05_08.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **New Action** | **AI** | **Stop Firing** 创建一个 **Stop Firing** 动作。将
    **Target** 变量设置为 Spawned 对象变量。将 **Compare Float** 条件的 **A >= B** 连接到 **Start Firing
    At** 动作的 **In**。我们将看到如图所示的输出：![Time for action—base enemy AI](img/image_1901_05_08.jpg)
- en: Now, if our enemy is alive, we will perform a trace on the screen which will
    create a line between the actor and the player and will see whether there is anything
    between them that would break **line-of-sight** (**LOS**). If the AI can see the
    player and he's within a certain distance of the player, he will start fi ring
    at him. If something is in the way he will stop. Of course, right now this is
    only called once. So aft er it happens once it won't be called again. What if
    the player runs away from the fight? We want to have the enemy chase aft er the
    player.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，如果我们的敌人是活着的，我们将在屏幕上执行一个追踪，这将创建一个从演员到玩家的线条，并查看他们之间是否有任何东西会阻断 **视线**（**LOS**）。如果
    AI 能看到玩家并且他距离玩家一定距离内，他将开始向他射击。如果有什么东西挡在路上，他将停止射击。当然，现在这只会调用一次。所以一旦发生一次，就不会再次调用。如果玩家从战斗中逃跑怎么办？我们希望敌人追逐玩家。
- en: Create a **Compare Bool** conditional by right-clicking and selecting **New
    Condition** | **Comparison** | **Compare Bool**. Underneath the Bool variable
    link create a **Bool** variable with a **False** value.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **New Condition** | **Comparison** | **Compare Bool** 创建一个 **Compare
    Bool** 条件。在布尔变量链接下方创建一个具有 **False** 值的 **Bool** 变量。
- en: Create a **Move To Actor** action by right-clicking and selecting **New Action**
    | **AI** | **Move To Actor**. Underneath the **Target** variable link connect
    the Spawned object. Under **Destination** create a Player variable and connect
    it. Connect the **True** output from the **Compare Bool** conditional to the In
    input on the **Move To Actor** action.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **New Action** | **AI** | **Move To Actor** 创建一个 **Move To Actor**
    动作。在 **Target** 变量链接下方连接 Spawned 对象。在 **Destination** 下创建一个 Player 变量并将其连接。将 **Compare
    Bool** 条件的 **True** 输出连接到 **Move To Actor** 动作的 **In** 输入。
- en: Create a **Toggle** action by right-clicking and selecting **New Action** |
    **Toggle** | **Toggle**. Underneath the **Bool** variable link connect the **Bool**
    variable we created earlier with `False` as the value. Connect the Out output
    of the **Start Firing At** action to the **Turn On** input of this **Toggle**
    action.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择 **新建动作** | **切换** | **切换** 来创建一个 **切换** 动作。在 **布尔** 变量链接下，将我们之前创建的布尔变量与值为
    `False` 的变量连接起来。将 **Start Firing At** 动作的 **Out** 输出连接到这个 **切换** 动作的 **Turn On**
    输入。
- en: Create a **Delay** action by right-clicking and selecting **New Action** | **Misc**
    | **Delay**. In the **Properties** pane change the **Duration** to `0.20`. Connect
    the **Out** from the **Toggle** and **Move to Actor** actions as well as the **False**
    output from the Compare Bool conditional to the **Start** input of our **Delay**.
    Connect the **Finished** output of our **Delay** action to the **In** of the **Is
    Alive** conditional we created at the beginning of this section.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择 **新建动作** | **杂项** | **延迟** 来创建一个 **延迟** 动作。在 **属性** 面板中，将 **持续时间**
    修改为 `0.20`。将 **Toggle** 和 **移动到演员** 动作的 **Out** 以及比较布尔条件输出的 **False** 连接到我们的 **延迟**
    动作的 **Start** 输入。将我们的 **延迟** 动作的 **Finished** 输出连接到我们在本节开头创建的 **Is Alive** 条件输入的
    **In**。
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **构建** | **构建全部** 并在完成后按 **关闭** 来构建我们的游戏。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in the following screenshot:![Time for action—base
    enemy AI](img/image_1901_05_09.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目并开始游戏，通过单击主工具栏上的 **开始移动预览器** 按钮如图所示：![是时候进行基础敌人 AI 的操作了](img/image_1901_05_09.jpg)
- en: What just happened?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Our enemy now responds to what we do in the world! If we come within a distance
    of `600` or closer to the enemy, and it has a clear line-of-sight, it will start
    firing at us. If the player runs a certain distance away or goes behind some cover,
    it will attempt to travel to us. However there is still a lot of work to do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的敌人会对我们在世界中的行为做出反应！如果我们进入距离敌人 `600` 或更近的位置，并且有清晰的视线，它将开始向我们开火。如果玩家跑得足够远或躲在某个掩护物后面，它将尝试向我们移动。然而，还有很多工作要做。
- en: Improvements to be made
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要改进的地方
- en: Instead of running to the player's position, the enemy we spawned goes towards
    the spawn point, or rather the place where the character was initially created,
    rather than where they currently are. It will continue to follow delete us, until
    it can fire at us again as well. Shouldn't it give up after a while? If we start
    attacking the enemy at a distance, the player will not react and will just take
    hits as well. With this basis, we can now extend our AI to be much more robust.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接跑向玩家位置不同，我们生成的敌人会朝向出生点，或者说最初创建角色的位置，而不是他们当前所在的位置。它将继续跟随我们，直到它可以再次向我们开火。它不应该在一段时间后放弃吗？如果我们从远处开始攻击敌人，玩家将不会做出反应，只会挨打。有了这个基础，我们现在可以扩展我们的
    AI，使其更加健壮。
- en: Time for action—base enemy AI
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行基础敌人 AI 的操作了
- en: Now we will be creating a rudimentary AI using Kismet and using our sequence
    we will be able to attach this behavior to every AI that we use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Kismet 创建一个基本的 AI，并使用我们的序列，我们将能够将此行为附加到我们使用的每个 AI 上。
- en: Go into the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there, you will see a list of classes that we can place within
    our level. Type `Path` in the **Search** bar and left-click on the **PathNode_Dynamic**
    selection. The following screenshot shows this:![Time for action—base enemy AI](img/image_1901_05_10.jpg)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 **演员类** 浏览器 **视图** | **浏览器窗口** | **演员类**。从那里，您将看到我们可以放置在我们关卡中的类列表。在 **搜索**
    框中输入 `Path` 并左键单击 **PathNode_Dynamic** 选择项。以下截图显示了这一点：![是时候进行基础敌人 AI 的操作了](img/image_1901_05_10.jpg)
- en: Close the **Actor Classes** browser and right-click anywhere in your level.
    From the menu that pops up, select **Add PathNode_Dynamic Here**. This will create
    an actor on the ground in the spot where you clicked. Place it nearby the player's
    spawn point.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 **演员类** 浏览器，并在你的关卡中任何地方右键单击。从弹出的菜单中选择 **在此处添加 PathNode_Dynamic**。这将创建一个在点击位置地面的演员。将其放置在玩家出生点附近。
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击 UDK 界面主工具栏顶部的 **K** 图标来打开 Kismet 编辑器。
- en: Enter the **EnemyAI** sequence by either double-clicking on the sequence in
    the **Graph** pane or clicking on the **EnemyAI** text in the **Sequences** pane.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **图** 面板中双击序列或单击 **序列** 面板中的 **EnemyAI** 文本来进入 **EnemyAI** 序列。
- en: Delete the connections to the **Start** input on the **Delay** action by holding
    *Alt* and clicking on the black square. Left-click on the **Delay** action, hold
    *Shift* and drag it to the right-hand side to give some room for our new additions.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住*Alt*并点击黑色方块来删除连接到**延迟**动作的**开始**输入的连接。左键点击**延迟**动作，按住*Shift*并将其拖到右侧，为我们新增的内容腾出空间。
- en: Select the **Move to Actor** action and its attached variables by holding down
    *Ctrl* + *Alt* and left-clicking slightly above and to the left-hand side of the
    **Move to Actor** action, and drag until the box you create covers all of the
    items we want to move. Alternatively, hold *Ctrl* and click on each item. Move
    the objects to beside the **Delay** position. Delete the connection from the **In**
    of the **Move To Actor** action and connect the **Out** from the **Move To Actor**
    action to the **Start** of the **Delay** action. Connect the **Out** of our **Toggle**
    action to the **Start** of the **Delay** action.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**移动到演员**动作及其附加变量，通过按住*Ctrl* + *Alt*并左键点击**移动到演员**动作稍上方和左侧，然后拖动直到你创建的框覆盖所有我们想要移动的项目。或者，按住*Ctrl*并点击每个项目。将对象移动到**延迟**位置旁边。删除**移动到演员**动作的**输入**连接，并将**移动到演员**动作的**输出**连接到**延迟**动作的**开始**。将我们的**切换**动作的**输出**连接到**延迟**动作的**开始**。
- en: Create a **Compare Float** conditional next to our **Compare Bool** action by
    right-clicking and selecting **New Condition** | **Conditional** | **Compare Float**.
    Connect the **True** of the **Compare Bool** conditional to the **In** input of
    this **Compare Float**. Connect the **False** output of the **Compare Bool** to
    the **Start** input on the **Delay** action. Create a float variable in both the
    **A** and **B** section of our **Compare Float** action. Inside the **A** float
    variable, create a comment saying **timeSinceCaught** with a value of `0.0`. Set
    the **B** variable to have a value of `2.0`. What I'm trying to accomplish in
    this section, is making it so that if the AI chases after the player and a certain
    time passes, he will give up and stop where he is.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择**新建条件** | **条件** | **比较浮点数**，在**比较布尔值**动作旁边创建一个**比较浮点数**条件。将**比较布尔值**条件的**真**连接到这个**比较浮点数**的**输入**。将**比较布尔值**的**假**输出连接到**延迟**动作的**开始**输入。在我们的**比较浮点数**动作的**A**和**B**部分都创建一个浮点变量。在**A**浮点变量内，创建一个注释说**timeSinceCaught**，值为`0.0`。将**B**变量设置为`2.0`。我在这个部分试图实现的是，如果AI追逐玩家并且经过一段时间后，它会放弃并停在原地。
- en: Create an **Add Float** action by right-clicking and selecting **New Action**
    | **Math** | **Add Float**. Connect the **A** and **Float Result** variables of
    **Add Float** action to the float variable that we placed a comment saying **timeSinceCaught**,
    which is connected to the **A** link on our **Compare Float**. Connect the **A
    < B** output of our **Compare Float** to the **In** of our **Add Float** action.
    Create a float variable below **B** with a value of `0.2`. The following screenshot
    shows this:![Time for action—base enemy AI](img/image_1901_05_11.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择**新建动作** | **数学** | **添加浮点数**来创建一个**添加浮点数**动作。将**添加浮点数**动作的**A**和**浮点结果**变量连接到我们放置注释说**timeSinceCaught**的浮点变量，该变量连接到我们的**比较浮点数**的**A**链接。将我们的**比较浮点数**的**A
    < B**输出连接到我们的**添加浮点数**动作的**输入**。在**B**下方创建一个值为`0.2`的浮点变量。以下截图显示了这一点：![行动时间——基础敌人AI](img/image_1901_05_11.jpg)
- en: As this acti on is called every 0.2 seconds (due to our delay), we add 0.2 to
    our counter if it has been less than 2 seconds since we started chasing the player
    after seeing them for the fi rst ti me. What do we do if we have waited 2 seconds
    or more? That's what we're going to do next.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这个动作每0.2秒被调用一次（由于我们的延迟），如果自我们第一次看到玩家后开始追逐玩家已经不到2秒，我们就将0.2加到计数器上。如果我们已经等待了2秒或更长时间，我们该怎么办？这就是我们接下来要做的。
- en: Below the **Add Float** action we just created add a **Set Float** action by
    using **New Action** | **Set Variable** | **Float**. Create a new float with a
    value of `0.0` for the **Value** link and connect the **Target** variable to the
    **timeSinceCaught** float variable. Connect the **A >= B** output from the **Compare
    Float** conditional to the **In** of our **Set Float** action.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们刚刚创建的**添加浮点数**动作下方添加一个**设置浮点数**动作，使用**新建动作** | **设置变量** | **浮点数**。创建一个新的浮点变量，值为`0.0`，并将其连接到**目标**变量和**timeSinceCaught**浮点变量。将**比较浮点数**条件的**A
    >= B**输出连接到我们的**设置浮点数**动作的**输入**。
- en: Create a **Toggle** action by right-clicking and selecting **New Action** |
    **Toggle** | **Toggle**. Underneath the **Bool** variable link connect the **Bool**
    variable we created earlier with **False** value. Connect the **Out** output of
    the **Set Float** action to the **Turn Off** input of this **Toggle** action.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择**新建动作** | **切换** | **切换**来创建一个**切换**动作。在**布尔**变量链接下方连接我们之前创建的**布尔**变量与**False**值。将**设置浮点数**动作的**输出**连接到这个**切换**动作的**关闭**输入。
- en: Create a **Modify Property** action by using **New Action** | **Object Property**
    | **Modify Property**. Go to the **Properties** pane and left-click on the green
    **+** sign beside the **Properties** variable, to create a new property to change.
    Click on the black triangle on the left-hand side to expand the options. Inside
    the **Property Name** property type `bLockLocation`. Click on the checkbox for
    **Modify Property**. Finally, in the **Property Value** section type `1`. This
    is shown in the following screenshot:![Time for action—base enemy AI](img/image_1901_05_12.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用**新建动作** | **对象属性** | **修改属性**来创建一个**修改属性**动作。转到**属性**面板，在**属性**变量旁边的绿色**+**符号上左键点击，以创建一个新属性进行更改。点击左侧的黑三角以展开选项。在**属性名称**属性中输入`bLockLocation`。点击**修改属性**复选框。最后，在**属性值**部分输入`1`。这如图所示：![行动时间——基础敌人AI](img/image_1901_05_12.jpg)
- en: The **bLockLocati** on variable is a **Bool** contained within our **Actor**
    class that will prevent an actor from being moved. With a value other than 0,
    a **Bool** will treat the value to mean true which will freeze our AI unti l we
    set the value back to 0\. Note that UDK will give us a warning about using the
    **Modify Property** acti on, but as we are not going to be using UnrealScript
    for our project it will be fine.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**bLockLocation**变量是我们**演员**类中的一个**布尔值**，它将阻止演员被移动。当值不为0时，**布尔值**将值视为真，这将冻结我们的AI，直到我们将值设置回0。请注意，UDK将给我们一个关于使用**修改属性**动作的警告，但因为我们不会在我们的项目中使用UnrealScript，所以这将是可以的。'
- en: Connect the **Out** from the **Toggle** action to the **In** of our **Modify
    Property** action. Connect the **Target** to the **Spawned** external variable.
    Connect the **Out** output of the **Modify Property** action to the **Start**
    on our **Delay** action on the far right-hand side.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**切换**动作的**输出**连接到我们的**修改属性**动作的**输入**。将**目标**连接到**已生成**外部变量。将**修改属性**动作的**输出**连接到最右侧的**延迟**动作的**开始**上。
- en: Next to the **Add Float** that we created in step 8 create a **Modify Property**
    action by using **New Action** | **Object Property** | **Modify Property**. Go
    to the **Properties** pane and left-click on the green **+** sign beside the **Properties**
    variable to create a new property to change. Click on the black triangle on the
    left-hand side to expand the options. Inside the **Property Name** property type
    `bLockLocation`. Click on the checkbox for **Modify Property**. Finally, in the
    **Property Value** section type `0`. Connect the **Out** output of the **Add Float**
    action to the **In** of our new **Modify Property** action.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤8中创建的**添加浮点数**旁边创建一个**修改属性**动作，使用**新建动作** | **对象属性** | **修改属性**。转到**属性**面板，在**属性**变量旁边的绿色**+**符号上左键点击以创建一个新属性进行更改。点击左侧的黑三角以展开选项。在**属性名称**属性中输入`bLockLocation`。点击**修改属性**复选框。最后，在**属性值**部分输入`0`。将**添加浮点数**动作的**输出**连接到我们新的**修改属性**动作的**输入**。
- en: Go back into the editor and confirm that you have the **PathNode_Dynamic_0**
    selected.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到编辑器并确认已选择**PathNode_Dynamic_0**。
- en: Back in Kismet create a **Get Location and Rotation** action **New Action**
    | **Actor** | **Get Location and Rotation**. Set the **Target** variable to **Player
    0** by creating a player object variable. Right-click under the **Location** link
    and select **Create New Vector Variable**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kismet中创建一个**获取位置和旋转**动作，**新建动作** | **演员** | **获取位置和旋转**。通过创建一个玩家对象变量将**目标**变量设置为**玩家0**。在**位置**链接下方右键点击并选择**创建新向量变量**。
- en: Delete the **Player** variable under the **Move to Actor** action and right-click
    under the **Destination** variable and select **New Object Var using PathNode_Dynamic_0**.
    Create a **Set Actor Location** action **New Action** | **Actor** | **Set Actor
    Location**. Connect the **Location** variable link to the location that we created
    in the previous step. Connect the **Target** of the **Set Actor Location** action
    to the **Destination** variable link on the **Move to Actor**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**移动到演员**动作下删除**玩家**变量，并在**目的地**变量下右键点击，选择**使用路径节点_Dynamic_0新建对象变量**。创建一个**设置演员位置**动作**新建动作**
    | **演员** | **设置演员位置**。将**位置**变量链接连接到我们在上一步创建的位置。将**设置演员位置**动作的**目标**连接到**移动到演员**的**目的地**变量链接。
- en: Above our **Trace** action create a **Take Damage** event by right-clicking
    and selecting **New Event** | **Actor** | **Take Damage**. In the **Properties**
    pane set **Max Trigger Count** to `0`. Connect the **Instigator** to the **Spawned**
    object. Connect the **Out** output to the **In** input of the **Start Firing At**
    action.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Trace**动作上方，通过右键点击并选择**新建事件** | **演员** | **受到伤害**创建一个**受到伤害**事件。在**属性**面板中将**最大触发次数**设置为`0`。将**发起者**连接到**已生成**对象。将**输出**连接到**开始射击**动作的**输入**。
- en: 'This will make it so that if the player decides to att ack someone from far
    away, that the enemy will react in some way by chasing aft er the player. Finally
    we will see something similar to the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做将使得如果玩家决定从远处攻击某人，敌人将以某种方式追逐玩家做出反应。最后我们会看到以下类似的截图：
- en: '![Time for action—base enemy AI](img/image_1901_05_13.jpg)'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间——基础敌人AI](img/image_1901_05_13.jpg)'
- en: Back in the editor window, click on the **Door** we created in the previous
    chapter. Open its properties by pressing *F4* and type `path` in the search box.
    You will see a box checked for the value **Path Colliding**. Uncheck it. Unchecking
    the **Path Colliding** value lets the editor know that it is possible for AI to
    pass through the door, as it will treat the area as being open even though we
    have a door there. If you intend to not allow enemies to use doors then you'd
    want to make sure this is checked.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到编辑器窗口，点击上一章中创建的**门**。通过按*F4*键打开其属性，并在搜索框中输入`path`。你会看到一个值为**路径碰撞**的复选框被选中。取消选中它。取消选中**路径碰撞**值让编辑器知道AI可以穿过门，因为它会将该区域视为开放，即使我们那里有门。如果你打算不允许敌人使用门，那么你需要确保这个选项被选中。
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**构建** | **构建全部**并完成时按**关闭**来构建我们的游戏。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in following screenshot:![Time for action—base
    enemy AI](img/image_1901_05_14.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的项目并开始游戏，通过在主工具栏上点击**开始移动预览器**按钮，如图所示：![行动时间——基础敌人AI](img/image_1901_05_14.jpg)
- en: What just happened?
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We breathed much more life into the routines of our AIs; they are now reacting
    to us in a much more believable way, and are good enough for what we are doing
    in our project. Now the enemies will chase to where you are for a period of time,
    giving up after a while, and if you attack them from anywhere, they will react
    to you. We've also been exposed to much more advanced Kismet scripting, showing
    us how we can manipulate the game environment based on events happening in the
    world.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为AI的常规程序注入了更多的活力；现在它们以更可信的方式对我们做出反应，并且对于我们在项目中的工作来说已经足够好了。现在敌人会追逐你一段时间，然后放弃，如果你从任何地方攻击他们，他们会对你做出反应。我们还接触到了更高级的Kismet脚本，展示了我们如何根据世界中的事件来操纵游戏环境。
- en: Have a go hero—taking your AI further
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄尝试——将你的AI进一步发展
- en: There are plenty of other things that you can add to your AI, such as different
    states depending on how close the player is to them (distance of the **Trace**
    action was discussed in the *Base enemy AI* section). Right now as long as the
    **timeSinceCaught** variable is less than 2.0, the `PathNode_Dynamic` is set to
    your actual position as well. You could make it so that the AI could only know
    where you were at that point (only setting the position once). You can use the
    **Bool** (true/false statement) the variable red in color as a way of checking
    whether it was already set or not.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为你的AI添加很多其他东西，比如根据玩家与它们之间的距离（在*基础敌人AI*部分讨论了**Trace**动作的距离），设置不同的状态。目前，只要**timeSinceCaught**变量小于2.0，`PathNode_Dynamic`就设置为你的实际位置。你可以让它只知道你在那个点的位置（只设置一次位置）。你可以使用**Bool**（真/假语句）变量红色作为检查它是否已经设置的一种方式。
- en: Another thing that you can do is use a **Timer** (**Action** | **Misc** | **Timer**)
    rather than using float comparisons and addition, toggling a timer on and off
    as necessary to add one other tool to your toolbox.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以做的一件事是使用**Timer**（**Action** | **Misc** | **Timer**）而不是使用浮点比较和加法，根据需要切换定时器的开关，为你的工具箱添加一个额外的工具。
- en: Exporting subsequences
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出子序列
- en: After setting up a useful subsequence such as our **EnemyAI** event that we
    created, we may want to share it between other levels. One way to do this is just
    copy/pasting; but what if we want to share our sequence with other developers/designers
    or on different computers? One of the neat things that we can do with sequences
    is export them so that we can place them inside our levels much in the same way
    that we place meshes or **Actor Classes**. One thing to note though is that when
    a sequence is imported it will remove all references to objects within the level
    that was created, so for that reason having external variables for items is vital
    to make sure that the sequence performs the way we'd like it to.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了一个有用的子序列，例如我们创建的**EnemyAI**事件之后，我们可能希望在不同关卡之间共享它。做到这一点的一种方法就是复制/粘贴；但如果我们想与其他开发者/设计师或在不同电脑上共享我们的序列呢？我们可以对序列做的酷炫事情之一就是导出它们，这样我们就可以像放置网格或**Actor
    Classes**一样将它们放置在我们的关卡中。但需要注意的是，当序列被导入时，它将删除对创建的关卡内对象的全部引用，因此为了这个原因，为项目使用外部变量是至关重要的，以确保序列按我们希望的方式执行。
- en: Time for action—creating a second enemy
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行动作——创建第二个敌人
- en: At this point, it's a good idea to save our **EnemyAI** subsequence as we are
    going to use it inside our final level. As this is the first time we've exported
    something to the content editor, I'm going to be very thorough.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，保存我们的**EnemyAI**子序列是一个好主意，因为我们将在最终关卡中使用它。由于这是我们第一次将内容导出到内容编辑器，我会非常仔细。
- en: Go into to the **Actor Classes** browser **View** | **Browser Windows** | **Actor
    Classes**. From there you will see a list of classes that we can place within
    our level. Type `Path` in the **Search** bar and left-click on the **PathNode**
    selection.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入**Actor Classes**浏览器，选择**View** | **Browser Windows** | **Actor Classes**。从那里，你将看到我们可以放置在我们关卡中的类列表。在**Search**栏中输入`Path`，然后左键单击**PathNode**选择。
- en: Close the **Actor Classes** browser and right-click in front of the door we
    created in the previous chapter. From the menu that pops up, select **Add PathNode
    Here**. Select the **PathNode**, hold **Option** and drag the object behind the
    door, creating a copy.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭**Actor Classes**浏览器，在上一章创建的门前面右键单击。从弹出的菜单中选择**Add PathNode Here**。选择**PathNode**，按住**Option**并拖动对象到门后面，创建一个副本。
- en: Open the Kismet editor by clicking on the **K** icon at the top of the UDK interface
    on the main toolbar.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击UDK界面主工具栏顶部的**K**图标打开Kismet编辑器。
- en: Right-click on our **EnemyAI** subsequence and select **Export Sequence to Package**.
    This is shown in the following screenshot:![Time for action—creating a second
    enemy](img/image_1901_05_15.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击我们的**EnemyAI**子序列，并选择**Export Sequence to Package**。这将在以下屏幕截图中显示：![执行动作——创建第二个敌人](img/image_1901_05_15.jpg)
- en: A prompt will come up asking for the package, group, and name of your object.
    Under **Package** put `UrbanWarrior`, in **Group** put `Sequences`, and under
    **Name** put `EnemyAI`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会出现一个提示，要求输入你的对象的包、组和名称。在**Package**中输入`UrbanWarrior`，在**Group**中输入`Sequences`，在**Name**中输入`EnemyAI`。
- en: Open up the **Content Browser**, and in the **Search** bar underneath **Packages**
    type `urban`. You should see your package come up on top with your sequence being
    the first item selected.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Content Browser**，在**Packages**下方的**Search**栏中输入`urban`。你应该会看到你的包出现在顶部，你的序列作为第一个选中的项目。
- en: Right-click on the package (it should have a ***** next to it) and click on
    **Save**. This is shown in the following screenshot:![Time for action—creating
    a second enemy](img/image_1901_05_16.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击包（它旁边应该有一个*****），然后单击**保存**。如图所示：![创建第二个敌人的行动时间](img/image_1901_05_16.jpg)
- en: Left-click on the **EnemyAI** sequence and open up the Kismet editor. Move to
    the left-hand side of our **EnemyAI** sequence, right-click and select **Import
    EnemyAI Sequence**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家所在位置的**EnemyAI**序列上左键单击并打开Kismet编辑器。移动到**EnemyAI**序列的左侧，右键单击并选择**导入EnemyAI序列**。
- en: You may not see anything change, but there is a good reason for that.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能看不到任何变化，但这是有充分理由的。
- en: Left-click on the **EnemyAI** subsequence and move it by holding *Alt* and dragging
    it to the left-hand side. You will notice that the new subsequence that we imported
    has the same position as when we exported it.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**EnemyAI**子序列上左键单击，并按住*Alt*键将其拖动到左侧。你会注意到我们导入的新子序列与导出时的位置相同。
- en: Left-click on the **PathNode** behind where the player is and go back into Kismet.
    Underneath the **Spawn Point**, right-click and select **New Object Var using
    PathNode_2 Here**. Create a new **Object** variable for the **Spawned** variable
    link. Connect the **Dead** output from the first **EnemyAI** sequence up to the
    **In** input of this **EnemyAI**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在玩家所在位置的**PathNode**上左键单击并返回Kismet。在**Spawn Point**下方，右键单击并选择**使用PathNode_2
    Here创建新对象变量**。为**Spawned**变量链接创建一个新的**Object**变量。将第一个**EnemyAI**序列的**Dead**输出连接到这个**EnemyAI**的**In**输入。
- en: Create a **Move To Actor** action by right-clicking and selecting **New Action**
    | **AI** | **Move To Actor**. Underneath the **Target** variable link connect
    the **Spawned** object. Under **Destination** connect it to the **PathNode** in
    front of the door. Connect the **Spawned** output from the **EnemyAI** subsequence
    to the **In** input on the **Move To Actor** action. We will see the output as
    shown in the following screenshot:![Time for action—creating a second enemy](img/image_1901_05_17.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择**新建动作** | **AI** | **移动到演员**创建一个**Move To Actor**动作。在**Target**变量链接下连接**Spawned**对象。在**Destination**下将其连接到门前的**PathNode**。将**EnemyAI**子序列的**Spawned**输出连接到**Move
    To Actor**动作的**In**输入。我们将看到如图所示的输出：![创建第二个敌人的行动时间](img/image_1901_05_17.jpg)
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**构建** | **构建全部**并完成时按**关闭**来构建我们的游戏。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar, as shown in the following screenshot:![Time for action—creating
    a second enemy](img/image_1901_05_18.jpg)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在主工具栏上单击**开始移动预览器**按钮保存你的项目并开始游戏，如图所示：![创建第二个敌人的行动时间](img/image_1901_05_18.jpg)
- en: What just happened?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The world is becoming more and more dynamic. By using an imported subsequence
    we made it so that if our first enemy died, a second enemy would spawn and rush
    through the door to see what was going on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 世界正变得越来越动态。通过使用导入的子序列，我们使得如果我们的第一个敌人死亡，第二个敌人会孵化并冲进门去看看发生了什么。
- en: Remote events
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程事件
- en: As seen in the previous sequence that we created, Kismet can often get quite
    complex and over time may become quite jumbled up. One possible solution to stop
    stay connections going all over the place is to use **Remote Events**. Similarly
    to our **Level Loaded** or **Player Spawned** events, whenever we activate a remote
    event through the **Activate Remote Event** Kismet action the actions and conditionals
    connected to it are called.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个我们创建的序列所示，Kismet可能会变得相当复杂，随着时间的推移可能会变得相当混乱。一个可能的解决方案是使用**远程事件**来停止连接四处蔓延。类似于我们的**Level
    Loaded**或**Player Spawned**事件，每次我们通过**激活远程事件**Kismet动作激活远程事件时，都会调用与之连接的动作和条件。
- en: When we can use a remote event
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当我们可以使用远程事件时
- en: Remote events sound quite amazing, but they can't always be used. Each remote
    event needs to have a specific name and UDK will get confused if you have multiple
    versions of the same remote event. This is also why we cannot have variables with
    the same name. If you are planning on re-using the same sequence for multiple
    objects, you cannot use them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 远程事件听起来相当神奇，但并不总是可以使用。每个远程事件都需要一个特定的名称，如果存在多个相同远程事件的版本，UDK会感到困惑。这也是为什么我们不能有同名变量。如果你打算为多个对象重复使用相同的序列，则不能使用它们。
- en: Creating a remote event
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建远程事件
- en: 'To create a **Remote Event** you right-click inside the **Graph** pane in Kismet
    and select **New Event** | **Remote Event**. After creating the event, go into
    its **Properties** and under the **Event Name** variable type a unique identifier.
    When you want the actions associated with the Remote Event to be called you just
    need to create an **Activate Remote Event** action **New Action** | **Event**
    | **Activate Remote Event** and in the **Properties** pane find the variable **Event
    Name** and set it to that same identifier. This is shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建**远程事件**，你可以在Kismet的**图形**面板中右键单击，然后选择**新建事件**|**远程事件**。创建事件后，进入其**属性**，在**事件名称**变量中输入一个唯一的标识符。当你想要调用与远程事件关联的动作时，只需创建一个**激活远程事件**动作：**新建动作**|**事件**|**激活远程事件**，然后在**属性**面板中找到变量**事件名称**并将其设置为相同的标识符。这如下面的截图所示：
- en: '![Creating a remote event](img/image_1901_05_19.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![创建远程事件](img/image_1901_05_19.jpg)'
- en: Named variables
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名变量
- en: In programming there is such a thing as global variables. **Global variables**
    are things that you wish to have at all times within the game; for example, a
    player's gold or the number of enemies currently spawned. This can be very useful
    if it's a piece of data that you use quite often. **Named variables** are basically
    Kismet's version of global variables; however, they are only global in terms of
    the level currently loaded.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，存在全局变量的概念。**全局变量**是你在游戏中的所有时间都希望拥有的东西；例如，玩家的金币或当前生成的敌人数量。如果这是一些你经常使用的数据，这会非常有用。**命名变量**基本上是Kismet的全局变量版本；然而，它们仅在当前加载的水平面上是全局的。
- en: When we can use a named variable
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们何时可以使用命名变量
- en: A **named variable**, just like a remote event, needs to have unique names which
    is why we used a comment instead of a variable name for our **timeSinceCaught**
    variable in our **EnemyAI** sequence. The nice thing about having variables with
    names is that instead of creating links to the one variable every single time,
    like we did with the **Spawned** external variable in our **EnemyAI** sequence,
    we can just create new named variables to hook it up to make our script much more
    organized.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名变量**，就像远程事件一样，需要具有唯一的名称，这就是为什么我们在**EnemyAI**序列中用注释代替变量名来命名**timeSinceCaught**变量的原因。拥有命名变量的好处是，我们不必每次都创建到单个变量的链接，就像我们在**EnemyAI**序列中使用的**Spawned**外部变量那样，我们只需创建新的命名变量来连接它，从而使我们的脚本更加有序。'
- en: Creating a named variable
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命名变量
- en: To create a named variable you right-click inside the **Graph** pane in Kismet
    and select **New Variable** | **Named Variable.** After creating the variable
    and going into its properties you can set the expected type to what it is and
    under the **Find Var Name** property just fill in the variable name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个命名变量，你可以在Kismet的**图形**面板中右键单击，然后选择**新建变量**|**命名变量**。创建变量并进入其属性后，你可以设置期望的类型，并在**查找变量名**属性下填写变量名。
- en: 'If everything goes correctly, you''ll see a green checkmark in its position
    as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将看到其位置上有一个绿色的勾选标记，如下面的截图所示：
- en: '![Creating a named variable](img/image_1901_05_20.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![创建命名变量](img/image_1901_05_20.jpg)'
- en: Manipulating the player
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作玩家
- en: 'We have worked in such a way to create actions that work with the AIs we are
    going to place within the world, but there is one thing in the game that is more
    important that we haven''t worked on yet at all: the player! Adding new types
    of gameplay or new mechanics are often tested out in Kismet before writing in
    UnrealScript, making it a lot easier to iterate. Make sure that the mechanics
    are? fun and interesting. Now that we have someone to shoot at us and some smarts,
    let''s add a new mechanics to our player.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经以这种方式创建了一些动作，这些动作将与我们将要放置在游戏世界中的AI一起工作，但游戏中还有一件事比这更重要，我们还没有着手处理：玩家！在用UnrealScript编写之前，通常会在Kismet中测试添加新的游戏类型或新的机制，这使得迭代变得容易得多。确保机制是**有趣且引人入胜的**。现在我们有了可以射击的目标和一些智慧，让我们给玩家添加一个新的机制。
- en: Time for action—regenerating player health over time
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——随时间恢复玩家生命值
- en: 'Made popular in *Halo* and seen in hit games such as *Gears of War* and *Batman:
    Arkham City*, regenerating health is a modern game mainstay that features in many
    *games* and are here to stay. Surprisingly, it is not that difficult at all to
    implement within Kismet, and you may notice some overlap between the behavior
    we use here and what we did previously.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '在*Halo*中流行起来，并在*Gears of War*和*Batman: Arkham City*等热门游戏中出现，恢复生命值是现代游戏中的一个主要元素，出现在许多*游戏中*，并且会一直存在。令人惊讶的是，在Kismet中实现它并不困难，你可能会注意到我们在这里使用的行为与我们之前所做的一些重叠。'
- en: Open the Kismet editor and enter our main sequence and drag the screen till
    you have a large amount of open space.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Kismet编辑器并输入我们的主序列，拖动屏幕直到你有大量的空白空间。
- en: Create a remote event by selecting **New Event** | **Remote Event**. In the
    **Properties** pane set the **Event Name** variable to `RegenHealth`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**New Event** | **Remote Event**来创建一个远程事件。在**Properties**面板中，将**Event Name**变量设置为`RegenHealth`。
- en: Directly above the remote event create a **Level Loaded** event by right-clicking
    and selecting **New Event** | **Level Loaded**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程事件上方，通过右键点击并选择**New Event** | **Level Loaded**来创建一个**Level Loaded**事件。
- en: To the right of the **Level Loaded** event create an **Activate Remote Event**
    action by right-clicking and selecting **New Action** | **Event** | **Activate
    Remote Event**. In the **Properties** pane find the variable **Event Name** and
    set it to `RegenHealth`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Level Loaded**事件的右侧，通过右键点击并选择**New Action** | **Event** | **Activate Remote
    Event**来创建一个**Activate Remote Event**动作。在**Properties**面板中找到变量**Event Name**并将其设置为`RegenHealth`。
- en: 'Note that both the **Activate Remote Event** and remote event **RegenHealth**
    may still have a large red **X** in them. This is either due to a misspelling,
    or the sequence has not been refreshed. If you exit and enter Kismet again, you
    will see both of the objects have a green checkmark next to them as shown in the
    following screenshot:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，**Activate Remote Event**和远程事件**RegenHealth**可能仍然有一个大红色的**X**。这可能是因为拼写错误，或者序列没有被刷新。如果你退出并再次进入Kismet，你将看到这两个对象旁边都有一个绿色的勾号，如图所示：
- en: '![Time for action—regenerating player health over time](img/image_1901_05_21.jpg)'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Time for action—regenerating player health over time](img/image_1901_05_21.jpg)'
- en: To the right-hand side of the remote event **RegenHealth** create a **Get Property**
    action by right-clicking and selecting **New Action** | **Object Property** |
    **Get Property**. In the **Properties** pane set the **Property Name** variable
    to `Health`. Underneath the **Target** variable link create a **Player 0** object
    variable. Underneath the **Int** variable link create a new **Int** variable by
    right-clicking underneath it and selecting **Create New Int Variable**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在远程事件**RegenHealth**的右侧，通过右键点击并选择**New Action** | **Object Property** | **Get
    Property**来创建一个**Get Property**动作。在**Properties**面板中，将**Property Name**变量设置为`Health`。在**Target**变量链接下方创建一个**Player
    0**对象变量。在**Int**变量链接下方，通过右键点击并选择**Create New Int Variable**来创建一个新的**Int**变量。
- en: Inside the UnrealScript file for the **Player** in the **Pawn Class** there
    exists an integer that has the name of **Health** which stores the player's health.
    The **Get Property** acti on allows us to see the value that it contains in our
    target, if it contains that variable.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**Pawn Class**中的**Player**的UnrealScript文件内部存在一个名为**Health**的整数，它存储玩家的生命值。**Get
    Property**动作允许我们查看我们的目标中包含的值，如果它包含该变量。
- en: Create a **Compare Int** conditional by right-clicking and selecting **New Condition**
    | **Comparison** | **Compare Int**. Underneath the **A** variable link connect
    the variable under **Int** in our **Get Property**. Underneath **B** create a
    new **Int** variable and put a value of `100`. Connect the **Out** from the **Get
    Property** action to the **In** input of the **Compare Int** conditional.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择**New Condition** | **Comparison** | **Compare Int**来创建一个**Compare
    Int**条件。在**A**变量链接下方连接我们**Get Property**中的**Int**变量。在**B**下方创建一个新的**Int**变量并设置值为`100`。将**Get
    Property**动作的**Out**连接到**Compare Int**条件的**In**输入。
- en: Basically, we're going to compare whether our **Health** is lower than **100**
    (the maximum value it can be at the moment) or not.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 基本上，我们将比较我们的**Health**是否低于**100**（目前它能达到的最大值）。
- en: Create a **Modify Property** action by using **New Action** | **Object Property**
    | **Modify Property**. Go to the **Properties** pane and left-click on the green
    **+** sign beside the **Properties** variable to create a new property to change.
    Click on the black triangle on the left-hand side to expand the options. Inside
    the **Property Name** property type `Health`. Click on the checkbox for **Modify
    Property**. Finally, in the **Property Value** section type `100`. Under the **Target**
    variable link place a **Player 0** object. Connect the **A >= B** from the **Compare
    Int** conditional to the **In** of the **Modify Property** that we just created.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 **新建动作** | **对象属性** | **修改属性** 来创建一个 **修改属性** 动作。转到 **属性** 面板，在 **属性**
    变量旁边的绿色 **+** 符号上左键单击以创建一个新属性进行更改。单击左侧的黑三角以展开选项。在 **属性名称** 属性中输入 `Health`。单击 **修改属性**
    复选框。最后，在 **属性值** 部分输入 `100`。在 **目标** 变量链接处放置一个 **Player 0** 对象。将 **Compare Int**
    条件的 **A >= B** 连接到我们刚刚创建的 **修改属性** 的 **In** 输入。
- en: Create a **Compare Float** conditional by right-clicking and selecting **New
    Condition** | **Comparison** | **Compare Float**. Underneath the **A** variable
    link create a new **Float** variable and put a value of `0.0` with the **Var Name**
    of **TimeSinceDamaged**. Underneath **B** create a new **Float** variable with
    a Float Value of `2.0` and **Obj Comment of TimeSinceLastDamaged**. Connect the
    **A < B** output of the **Compare Int** conditional to the **In** input of this
    **Compare Float** conditional.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键点击并选择 **新建条件** | **比较** | **比较浮点数** 来创建一个 **比较浮点数** 条件。在 **A** 变量链接下创建一个新的
    **浮点数** 变量，并赋予其值为 `0.0`，**变量名** 为 **TimeSinceDamaged**。在 **B** 下创建一个新的 **浮点数**
    变量，其浮点值为 `2.0`，**对象注释** 为 **TimeSinceLastDamaged**。将 **Compare Int** 条件的 **A <
    B** 输出连接到这个 **比较浮点数** 条件的 **In** 输入。
- en: Add a **Set Float** action by using **New Action** | **Set Variable** | **Float**.
    Create a new float with a value of `0.0` for the **Value** link.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 **新建动作** | **设置变量** | **浮点数** 来添加一个 **Set Float** 动作。为 **值** 链接创建一个新的浮点数，其值为
    `0.0`。
- en: Create a named variable with an **Expected Type of SeqVar_Float** and a **Find
    Var Name of TimeSinceDamaged** and connect the **Target** variable link from the
    **Set Float** action to it. Connect the **Out** of the **Modify Property** (**Health**)
    to the **In** input of our **Set Float** action.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 **预期类型为 SeqVar_Float** 和 **查找变量名为 TimeSinceDamaged** 的命名变量，并将 **Set Float**
    动作的 **Target** 变量链接连接到它。将 **Modify Property** （**健康**）的 **Out** 连接到我们的 **Set Float**
    动作的 **In** 输入。
- en: Create an **Activate Remote Event** action **New Action** | **Event** | **Activate
    Remote Event** and in the **Properties** pane, find the variable **Event Name**
    and set it to **RegenHealth**. Connect the **Out** output of our **Set Float**
    action to the **In** of our **Activate Remote Event** variable **RegenHealth**.
    This is shown in the following screenshot:![Time for action—regenerating player
    health over time](img/image_1901_05_22.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **激活远程事件** 动作 **新建动作** | **事件** | **激活远程事件**，并在 **属性** 面板中找到变量 **事件名称**
    并将其设置为 **RegenHealth**。将我们的 **Set Float** 动作的 **Out** 输出连接到我们的 **激活远程事件** 变量 **RegenHealth**。这如图所示：![行动时间——随时间恢复玩家健康](img/image_1901_05_22.jpg)
- en: Create a **Modify Health** action **New Action** | **Actor** | **Modify Health**.
    Under the **Target** variable link create a **Player 0** object variable. Under
    amount create a **Float** variable with a value of `1.0`. Inside the **Properties**
    pane check the **Heal** checkbox and connect the **A >= B** from our **Compare
    Float** conditional to the **In** of this action.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 **修改健康** 动作 **新建动作** | **演员** | **修改健康**。在 **目标** 变量链接下创建一个 **Player 0**
    对象变量。在数量创建一个 **浮点数** 变量，其值为 `1.0`。在 **属性** 面板中勾选 **治疗** 复选框，并将我们的 **Compare Float**
    条件的 **A >= B** 连接到这个动作的 **In**。
- en: You may noti ce that we are not using **Modify Property** like we did in the
    previous example; this is merely to show you that there are oft en multi ple ways
    of doing the exact same thing within Kismet and by experimenti ng you can discover
    all sorts of things that you can do.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会注意到我们没有使用 **修改属性**，就像我们在上一个例子中做的那样；这只是为了向你展示在 Kismet 中经常有多种方式做完全相同的事情，通过实验你可以发现所有
    sorts of things 你可以做到。
- en: Copy (*Ctrl* + *C*) and Paste (*Ctrl* + *V*) the **Activate Remote Event** variable
    **RegenHealth** that we created earlier. Drag the action till it is beside the
    **Modify Health** action we just created. Delete this one's connection to its
    **In** input by left-clicking while holding the *Alt* key. Copy and paste another
    one with the **In** removed and place it above this one. Hook the **Out** from
    our **Modify Health** to the one beside it.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 (*Ctrl* + *C*) 并粘贴我们之前创建的 **激活远程事件** 变量 **RegenHealth**。将动作拖动到刚刚创建的 **修改生命值**
    动作的旁边。通过按住 *Alt* 键并左键单击删除此动作与其 **In** 输入的连接。复制并粘贴另一个移除了 **In** 的动作，并将其放在这个动作的上方。将我们的
    **修改生命值** 的 **Out** 连接到旁边的动作。
- en: Create an **Add Float** action by right-clicking and selecting **New Action**
    | **Math** | **Add Float**. Connect the **A** and **Float Result** variables of
    **Add Float** to a named variable with the value of **TimeSinceDamaged** like
    we did in step 10\. Connect the **A < B** output of our **Compare Float** to the
    **In** of our **Add Float** action. Create a **Float** variable below **B** with
    a value of `0.2`. Finally, connect the **Out** output of this **Add Float** to
    the extra **Activate Remote Event** variable **RegenHealth** we created in the
    previous step.![Time for action—regenerating player health over time](img/image_1901_05_23.jpg)
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击并选择 **新建动作** | **数学** | **添加浮点数** 来创建一个 **添加浮点数** 动作。将 **添加浮点数** 的 **A**
    和 **浮点结果** 变量连接到具有 **TimeSinceDamaged** 值的命名变量，就像我们在第 10 步中做的那样。将我们的 **比较浮点数**
    的 **A < B** 输出连接到我们的 **添加浮点数** 动作的 **In**。在 **B** 下方创建一个值为 `0.2` 的 **浮点数** 变量。最后，将此
    **添加浮点数** 的 **Out** 输出连接到我们在上一步中创建的额外 **激活远程事件** 变量 **RegenHealth**。![行动时间——随时间恢复玩家生命值](img/image_1901_05_23.jpg)
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar as shown in the following screenshot:![Time for action—regenerating
    player health over time](img/image_1901_05_24.jpg)
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目，并点击主工具栏上的 **开始移动预览器** 按钮来开始你的游戏，如图所示：![行动时间——随时间恢复玩家生命值](img/image_1901_05_24.jpg)
- en: What just happened?
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: You can't tell by a still image, but we're one step closer to having a fully
    featured game, with the fantastic addition of a regenerating health system. When
    our health is not at maximum, we wait for a period of time and if we are not hit
    within that time period, we will slowly increase our health over time. We've also
    gained a good knowledge of how to use named variables, getting and setting object
    properties in Kismet, as well as experience in using remote events.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过静态图像你可能看不出来，但我们又迈出一步，离拥有一个功能齐全的游戏更近了，这得益于一个令人惊叹的恢复生命值系统的加入。当我们的生命值不是最大值时，我们会等待一段时间，如果我们在这段时间内没有被击中，我们的生命值会随着时间的推移慢慢增加。我们还获得了如何使用命名变量、在
    Kismet 中获取和设置对象属性以及使用远程事件的经验。
- en: Have a go hero—regenerating player health over time
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼——随时间恢复玩家生命值
- en: 'With this base system, there are plenty of things that you can do to extend
    the functionality. It would be easy to do something similar to *Halo''s* shield
    recovery, by having the recovery go faster than the lower health you have, by
    changing the float value under the **Modify Health** action. You could also use
    the same sequence with a few changes to make it into something that will damage
    you if you spend too much time in it like with the water in *Sonic: The Hedgehog*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '使用这个基础系统，你可以做很多事情来扩展其功能。通过将恢复速度设置得比你的低生命值更快，可以轻松地做类似 *Halo* 的护盾恢复，在 **修改生命值**
    动作下更改浮点值。你也可以通过一些修改使用相同的序列，使其变成一个如果你在其中花费太多时间就会对你造成伤害的东西，就像在 *Sonic: The Hedgehog*
    中的水一样。'
- en: Prefabs
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预制件
- en: Quite often when constructing a level, you want to create some arrangement of
    actors and associated Kismet, and then re-use that collection in the same or other
    levels, like the door we created. Prefabs allow you to create an object once,
    and then save it in a package as a prefab. You can then select the **Prefab**
    in the **Content Browser**, and add it as many times as you like throughout the
    level.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建关卡时，你通常会创建一些演员和相关的 Kismet 安排，然后在同一关卡或其他关卡中重用这个集合，就像我们创建的门一样。预制件允许你创建一个对象一次，然后将其保存为预制件包。你可以在关卡中多次选择
    **预制件** 并添加它。
- en: Note that prefabs can cause problems in UDK and may break and/or stop working
    for seemingly no reason so SAVE OFTEN after making sure that things work.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，预制件可能会在 UDK 中引起问题，并且可能在没有明显原因的情况下损坏和/或停止工作，所以请确保一切正常后经常保存。
- en: Time for action—door prefab
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——门预制件
- en: Right now we have one single door, and while it is an awesome door, we would
    probably like to have more than one inside our game. To make it easier to work
    with and place in new areas of our game, let's make a door prefab!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们只有一个门，虽然它是一个很棒的门，但我们可能希望在游戏中有多于一个。为了使其更容易在新区域的游戏中使用和放置，让我们制作一个门预制对象！
- en: In Kismet, go to the door behavior that we wrote in the previous chapter. Hold
    *Alt+Ctrl* and drag from the top left-hand side of the objects to the bottom,
    to select all of the items used in the creation. Right-click and select **Create
    New Sequence**. In the following menu name the sequence `Door`. This is shown
    in the following screenshot:![Time for action—door prefab](img/image_1901_05_25.jpg)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kismet 中，转到我们在上一章中编写的门行为。按住 *Alt+Ctrl* 并从对象的左上角拖动到底部，以选择用于创建的所有项目。右键单击并选择
    **创建新序列**。在以下菜单中命名序列为 `Door`。这如图所示：![操作时间——门预制对象](img/image_1901_05_25.jpg)
- en: Similarly in the regular editor window, select all of the objects used to create
    our door, including the walls surrounding it and the trigger volume used in its
    creation. Right-click and select **Create Prefab**.![Time for action—door prefab](img/image_1901_05_26.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，在常规编辑器窗口中，选择用于创建我们的门的所有对象，包括围绕它的墙壁和用于其创建的触发体积。右键单击并选择 **创建预制对象**。![操作时间——门预制对象](img/image_1901_05_26.jpg)
- en: In the popup that is created under **Packages** use the name `UrbanWarrior`
    and inside the **Name** use `Door.`
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **包** 下创建的弹出窗口中，使用名称 `UrbanWarrior`，并在 **名称** 中使用 `Door.`。
- en: Another popup will come up telling you that it detected a Kismet sequence using
    items of this prefab and wants to confirm that we want it to be part of the prefab.
    Click on **Yes**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个弹出窗口将出现，告诉你它检测到一个使用此预制对象项目的 Kismet 序列，并询问我们是否希望它成为预制对象的一部分。点击 **是**。
- en: Note that a prefab can only have one sequence associated with it, and you cannot
    use the main sequence as your sequence that uses that prefab. Unlike the subsequences
    that we exported/imported earlier, these objects will have the variable links
    in the sequence corresponding to the new copies made inside the prefab, which
    is a really neat thing.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，一个预制对象只能关联一个序列，你不能使用主序列作为使用该预制对象的序列。与之前导出/导入的子序列不同，这些对象在序列中将具有与预制对象内新创建的副本相对应的变量链接，这是一件非常巧妙的事情。
- en: Finally the popup will ask if you'd like to convert your door to an instance
    of the prefab; this is a good idea so click on **Yes**. You will now notice a
    red **P** symbol next to our door letting us know that it is a prefab.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，弹出窗口将询问你是否想将你的门转换为预制对象的实例；这是一个好主意，所以点击 **是**。你现在会注意到门旁边有一个红色的 **P** 符号，这让我们知道它是一个预制对象。
- en: Left-click on the prefab object and hold *Alt* while dragging it along an axis
    to create a copy of the door a distance away from the base point. You should see
    a second prefab being created and moved, as you drag along making another door
    in the process.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左键单击预制对象，并在沿轴拖动时按住 *Alt* 键，以在基点外一定距离处创建门的副本。当你拖动时，你应该会看到第二个预制对象被创建并移动，同时在这个过程中制作了另一扇门。
- en: The walls will not appear inside the perspective view until you build the game,
    due to it not being able to render changes in BSP at runtime.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于在运行时无法渲染 BSP 的更改，墙壁在透视视图中不会显示，直到你构建游戏。
- en: Build our game by selecting **Build** | **Build All** and pressing **Close**
    when finished.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择 **构建** | **构建所有** 并在完成后按 **关闭** 来构建我们的游戏。
- en: Save your project and start your game by clicking on the **Start Mobile Previewer**
    button on the main toolbar, saying **Yes** when it asks you to save the package.
    The following screenshot shows the modified views:![Time for action—door prefab](img/image_1901_05_27.jpg)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存你的项目并开始你的游戏，通过在主工具栏上单击 **开始移动预览器** 按钮，当它询问你保存包时说 **是**。以下截图显示了修改后的视图：![操作时间——门预制对象](img/image_1901_05_27.jpg)
- en: What just happened?
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发生了什么？
- en: We have now quickly and easily created a second door inside our level. The same
    functionality included in our previous door is still there, allowing us to enter
    and exit through both of them quite easily with the sound effects and everything.
    Using the prefab, it will be trivial to make new doors, and as they aren't forced
    to be the same (like Unity) we can change anything about each individual prefab
    without worrying about how it will affect the others.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经快速简单地在我们关卡内创建了一个第二个门。我们之前门中包含的功能仍然存在，允许我们通过它们中的任何一个相当容易地进入和退出，包括声音效果等。使用预制对象，制作新门将变得非常简单，而且由于它们不必相同（如
    Unity），我们可以更改每个预制对象的任何内容，而不用担心它将如何影响其他对象。
- en: Building combat sequences
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建战斗序列
- en: As someone who enjoys playing games can attest to, there are always moments
    in gameplay that stand out from others. We've also played games where it just
    seemed that you were going through corridor after corridor, with little to no
    exciting things happening, with the game turning into a bore. Crafting a satisfying
    combat experience is something that every designer strives to do, and here are
    some suggestions on my end as to ways of doing just that.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个喜欢玩游戏的人可以证明，在游戏过程中总有一些时刻会脱颖而出。我们也玩过一些游戏，感觉就像是在走廊里一个接一个地走，几乎没有令人兴奋的事情发生，游戏变得无聊。制作一个令人满意的战斗体验是每个设计师都力求做到的事情，以下是我提出的一些关于如何做到这一点的建议。
- en: Layouts
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局
- en: By failing to prepare, you are preparing to fail. - Benjamin Franklin
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有准备，就是准备失败。 —— 本杰明·富兰克林
- en: A good layout is the basis of a solid foundation for the creation of your level,
    and as such is probably the most important thing to consider when beginning a
    level. This is one of the numerous reasons why pre-production on game projects
    is so important. It may go against your initial thoughts, but it is not a good
    idea to just go in the editor and try to make something. While every once in a
    while you may stumble into something, it is far more likely that if you plan something
    out that the resulting level will be much better. That's not to say that what
    you plan in pre-production will be the same as how you planned it. Playtesting
    your level may teach you that certain things in the layout are confusing and/or
    too easy or hard which are important things to take note of. One of the most important
    things to keep in mind when working on a layout is making it easy to read at a
    first glance. Keep action in the player's **field of view** (**FOV**) when creating
    action.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的布局是你创建关卡坚实基础的基石，因此，在开始创建关卡时，这可能是最重要的考虑因素之一。这也是为什么游戏项目的前期制作如此重要的众多原因之一。虽然这可能与你最初的思考相反，但直接进入编辑器尝试制作东西并不是一个好主意。虽然偶尔你可能会偶然发现一些东西，但如果你事先规划，最终生成的关卡会好得多。这并不是说你在前期制作的计划会与你计划的一模一样。在规划布局时，要确保它一眼就能看懂。在创建动作时，保持动作在玩家的**视野**（**FOV**）内。
- en: You may have already noticed how in our current version of our layout our door
    is not in the player's view when spawned, making it confusing to where the player
    should continue in the game. This sends mixed signals, which is never a good thing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在我们当前的布局版本中，当门生成时，它不在玩家的视野中，这使得玩家不清楚在游戏中应该继续往哪里走。这发出了混乱的信号，这从来都不是好事。
- en: Spawning and enemy placement
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成和敌人放置
- en: Of course, having a great layout is good, but if there is nothing to do in the
    environment, players will soon grow bored and as such we spawn opponents to face
    them. It is terribly important that enemies get spawned out of sight of the player,
    because seeing an enemy suddenly appear out of nowhere will suddenly break the
    suspension of disbelief that our player should be feeling, unless of course it
    is known as an ability of an enemy such as the Houdini splicers in *Bioshock*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，拥有一个出色的布局是好事，但如果环境中没有可做的事情，玩家很快就会感到无聊，因此我们生成对手来面对他们。敌人必须在玩家视线之外生成，这一点非常重要，因为如果玩家突然看到敌人从无到有地出现，会突然打破他们应该感受到的不信感，除非当然，这是敌人的一种能力，比如《生化奇兵》中的Houdini拼接者。
- en: Of course, we also don't always want our enemies to be static; which is why
    we will often have enemies walking according to a path, or coming in from an area.
    This movement should give our player a visual cue, as just like the real world
    there is usually a reason why something is where it is. If your game has stealth
    elements, the player may wait to see a pattern emerging in the enemy's path to
    avoid conflict. If your game is an action based shooter, our player will be likely
    travel to where they see things come from. Another thing to keep in mind is to
    know your engine's limitations, especially working within the mobile gamespace,
    as mobile platforms are much more demanding on the hardware when spawning enemies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也不总是想让我们的敌人保持静止；这就是为什么我们经常让敌人沿着路径行走，或者从一个区域进入。这种移动应该给我们的玩家一个视觉提示，就像现实世界一样，通常有理由解释为什么某物会出现在某个地方。如果你的游戏有潜行元素，玩家可能会等待看到敌人路径中出现的模式，以避免冲突。如果你的游戏是动作射击游戏，玩家很可能会前往他们看到事物出现的地方。另一个需要注意的事情是了解你引擎的限制，尤其是在移动游戏空间中工作，因为移动平台在生成敌人时对硬件的要求更高。
- en: Environment
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境
- en: Pretty art is pretty, but it can't make up for poor design. For artistic people,
    like me, it can be incredibly easy to fall into the trap of starting to polish
    up an area before finishing it. After doing preproduction by designing a layout,
    build your level using BSP additive brushes at first. At this point, the focus
    in the level is creating an environment that is fun, and has some semblance to
    the environment that we want the level to take place in. It is important to do
    whatever we can, to exploit the type of gameplay that we want to occur as well.
    For example, we could give the player places to hide from enemies and take pot
    shots, making the player feel smart for outsmarting the enemies.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 精美的艺术作品固然美丽，但它无法弥补糟糕的设计。对于像我这样的艺术人士来说，在完成作品之前就开始打磨某个区域，很容易陷入这种陷阱。在进行预生产并设计布局后，首先使用BSP添加式刷子构建你的关卡。在这个阶段，关卡的重点是创建一个有趣的环境，并且与我们要关卡发生的环境有某种相似之处。重要的是尽我们所能，利用我们想要的玩法类型。例如，我们可以给玩家提供躲避敌人的地方，让他们能够进行射击，这样玩家就会觉得自己很聪明，因为他们比敌人更聪明。
- en: One of the most important things you can do as a designer is empowering the
    players as they are not your enemies, they're your best friends, and are ultimately
    who gives you your pay check, so it's important to respect them. Aside from the
    actual physical environment, an environment's lighting can be used in many different
    ways to affect players. Primarily, light draws focus to things and leads players
    to travel towards it. Darkness and the unknown are uncomfortable areas for players
    to be in and not lighting areas as much as others adds to the foreboding nature
    that an area could have. *Monolith's* F.E.A.R. does this quite nicely by turning
    a regular everyday office into an intense and dangerous place to be in, even though
    you are fully armed and equipped to handle anything that may come by your way.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计师，你可以做的最重要的事情之一是赋予玩家权力，因为他们不是你的敌人，他们是你的最好的朋友，最终是给你发薪水的人，所以尊重他们是重要的。除了实际的物理环境之外，环境的光照可以以多种方式影响玩家。主要来说，光线将注意力引向事物，并引导玩家向其移动。黑暗和未知是玩家感到不舒服的区域，而且不如其他区域明亮的光线增加了该区域可能具有的威胁感。*单碑*的《恐惧》就做得相当不错，它将一个普通的日常办公室变成了一个充满紧张和危险的地方，即使你全副武装，装备齐全，可以应对任何可能发生的事情。
- en: Scripting
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本
- en: As important as the placement and spawning of an enemy is, if the enemy doesn't
    do anything the game will get old quickly. We've created a basic AI for what an
    enemy could do to enemies, and there are a lot of ways to expand upon it and create
    unique situations based on what is going on in the game. In large open areas,
    as long as the player does something resembling intelligence, things seem to go
    well to which our AI, though limited, can be used to good effect. In general,
    the tighter the environment, the more you'll want to hand-script the enemy's behavior.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 敌人的放置和生成与敌人本身的行为一样重要，如果敌人不做任何事情，游戏很快就会变得乏味。我们已经为敌人可能对敌人做的事情创建了一个基本的AI，并且有很多方法可以在此基础上扩展，并基于游戏中的情况创造独特的情况。在开阔的大区域中，只要玩家做出类似智能的行为，事情似乎就会顺利进行，尽管我们的AI有限，但可以很好地发挥作用。一般来说，环境越紧凑，你就越想手动编写敌人的行为。
- en: Flanking is a type of behavior in which an enemy is able to come at a target
    from its sides or behind it, catching it off guard. Flanking in games can be both
    good and bad. If done well, it can make the player improvise and feel a rush of
    excitement. If done poorly however, it will make player think AI is cheating,
    and cause the player to resent the encounter. If you do decide to implement flanking,
    wait and let the player engage the area before attempting to flank, and make the
    first shot miss and let the player notice where the shot came from so they can
    adjust.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 侧翼包抄是一种行为，敌人能够从目标两侧或后方接近，使其措手不及。在游戏中，侧翼包抄既有好的一面也有不好的一面。如果做得好，它可以促使玩家即兴发挥，感受到一阵兴奋。然而，如果做得不好，会让玩家认为AI在作弊，并导致玩家对这次遭遇产生反感。如果你决定实施侧翼包抄，请等待并让玩家进入区域后再尝试侧翼包抄，并让第一枪打偏，让玩家注意到枪声的来源，以便他们调整。
- en: Another tool that designers can utilize is the idea of waves in an environment
    where you spawn different enemies at different times, in order to extend the gameplay
    and time spent in a certain area. However, each wave should be unique or else
    the player will get bored easily. *Dungeon Defenders* does this in a good way
    by incrementing difficulty over time making sure that things don't get boring.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师可以利用的另一项工具是环境中的波浪概念，在不同的时间点生成不同的敌人，以延长游戏时间和特定区域的时间。然而，每一波都应该独特，否则玩家会很快感到无聊。“地牢守护者”通过随着时间的推移逐渐增加难度，确保事情不会变得无聊，做得很好。
- en: Keep in mind the difficulty of your waves and encounters in general, and modify
    the elements that you can in order to curve up the difficulty in each encounter,
    but also give the player a chance to take a breather once in a while to reflect
    on how powerful he has become.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住你波浪和遭遇的难度，并修改你可以修改的元素，以便在每个遭遇中调整难度，同时也给玩家一个机会偶尔休息一下，反思自己变得多么强大。
- en: Playtesting
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: In my opinion, a game designer is the player's advocate and in that role, their
    main responsibility is to make a game that your target audience will love. Because
    of this, playtesters are a game designer's best friend. They are the voice of
    how a normal person is going to react to your game, and as such it is important
    that you take what they say seriously. They are the people that are going to find
    and exploit anything they can get their hands on within your world as well and
    you will find things you never thought of possible in your game. They are going
    to suggest changes and it will be your decision whether or not those changes are
    really worth having or not.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，游戏设计师是玩家的代言人，在这个角色中，他们的主要责任是制作出目标受众会喜爱的游戏。正因为如此，测试玩家是游戏设计师最好的朋友。他们是普通人将如何对你的游戏做出反应的代言人，因此，认真对待他们的话是非常重要的。他们也是那些会找到并利用他们能触及到你游戏世界中的任何东西的人，你也会发现你从未想过可能在你游戏中出现的事情。他们会提出建议，而是否采纳这些建议将由你决定，这些改变是否真的值得拥有。
- en: It is also very important that you have people to play your game without your
    input. Most designers believe that they have covered every possible thing a player
    can do, but it is almost guaranteed that something has been forgotten. In level
    design, it is important to see what directions players go in, and whether they
    are being guided in the correct way.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有你的输入的情况下，让其他人玩你的游戏也非常重要。大多数设计师认为他们已经涵盖了玩家可能做的每一件事，但几乎可以肯定的是，有些事情已经被遗忘了。在关卡设计中，重要的是要看到玩家会走向哪个方向，以及他们是否被正确引导。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We now have all of the pieces that we need to create our game and have learned
    a lot of things in the process. By using the same principles given in this chapter
    it is possible to expand and create many different types of enemies and behaviors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了创建游戏所需的所有部件，并在过程中学到了很多东西。通过使用本章给出的相同原则，我们可以扩展并创建许多不同类型的敌人和行为。
- en: 'In this short period of time we managed to cover quite a lot of things. We
    specifically learned the following topics:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个短暂的时间内，我们设法覆盖了很多内容。我们特别学习了以下主题：
- en: What sequences are and how we use them
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序是什么以及我们如何使用它们
- en: How to spawn an enemy into our level
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在我们的关卡中生成敌人
- en: What we can do to develop a rudimentary AI system that will shoot at us if we
    are close to it
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做什么来开发一个基本的AI系统，如果我们在它附近，它会向我们射击
- en: How to expand upon that system by adding chasing and retreating behavior
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过添加追逐和撤退行为来扩展该系统
- en: How to create additional enemies using import/export subsequences
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用导入/导出子序列创建额外的敌人
- en: How to implement regenerating health using remote events
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用远程事件实现恢复生命值
- en: What prefabs are and how we can and their use them in our project
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制件是什么以及我们如何在项目中使用它们
- en: How to make a door prefab
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何制作门预制件
- en: Things to consider when creating combat scenarios
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建战斗场景时需要考虑的事项
- en: Now we've learned how to build all of the base elements that we will need to
    implement our game.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何构建我们将需要实现游戏的所有基础元素。
- en: In the next chapter, we will be bringing all of these pieces together to create
    our full-fledged game by discussing a workflow for creating levels using **Geometry
    Mode**, how to use modular pieces to create our level quickly, and advice on building
    levels on
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把这些部件组合起来，通过讨论使用**几何模式**创建关卡的工作流程，如何使用模块化部件快速创建我们的关卡，以及关于在
