<html><head></head><body><div><div><h1 id="_idParaDest-71"><a id="_idTextAnchor089"/>Chapter 5: Managing the State of Your Composable Functions</h1>
			<p>In <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>, I showed you how to set the red, green, and blue portions of a color by dragging sliders. We used <strong class="bold">state</strong> to share these values among composable functions. Quite a few other sample apps of the previous chapters dealt with state, too. In fact, reacting to state changes is critical to how modern mobile apps work. </p>
			<p>So far, I have described state as data that can change over time. You learned about a few important functions, for example, <code>remember { }</code> and <code>mutableStateOf()</code>. I also briefly touched on a concept called <strong class="bold">state hoisting</strong>.</p>
			<p>This chapter builds on these foundations. For example, you will understand the difference between stateless and stateful composables, and when to choose which. Also, I will show you how events should flow in a well-behaving Compose app.</p>
			<p>The main sections of this chapter are the following:</p>
			<ul>
				<li><a id="_idTextAnchor090"/>Understanding stateful and stateless composable functions</li>
				<li>Hoisting state and passing events</li>
				<li>Surviving configuration changes</li>
			</ul>
			<p>We will start by exploring the differences between stateful and stateless composable functions. You will learn their typical use cases and understand why you should try to keep your composables stateless. Hoisting state is a tool to achieve that; we will cover this important topic in the second main section. Also, I will show you that you can make your composable functions reusable by passing logic as parameters, rather than implementing it inside the composable.</p>
			<p>Finally, the <em class="italic">Surviving configuration changes</em> section will explore the integration of a Compose UI hierarchy in activities, concerning how to retain user input. If the user changes from portrait to landscape mode (or vice versa), activities are destroyed and recreated. Of course, input should not be lost. We look at several ways that a Compose app can achieve this.</p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>This chapter includes three sample apps. Please refer to the <em class="italic">Technical requirements</em> section in <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, and how to get them. <code>StateDemo</code> contains all examples from the <em class="italic">Understanding stateful and stateless composable functions</em> section. The <em class="italic">Hoisting state and passing events</em> section discusses the <code>FlowOfEventsDemo</code> sample. Finally, <code>ViewModelDemo</code> belongs to the <em class="italic">Surviving configuration changes</em> section.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_05">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_05</a>.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor092"/>Understanding stateful and stateless composable functions</h1>
			<p>In this section, I will show you the difference between stateful and stateless composable functions. To understand <a id="_idIndexMarker175"/>why this is important, let's first focus on the <strong class="bold">state</strong> term. In previous <a id="_idIndexMarker176"/>chapters, I described state as <em class="italic">data that can change over time</em>. Where <a id="_idIndexMarker177"/>the data is held (an SQLite database, a file, or a value inside an object) does not matter. What is important is that the UI must always show the current data. Therefore, if a value changes, the UI must be notified. To achieve this, we use <strong class="bold">observable</strong> types. This is not specific to <a id="_idIndexMarker178"/>Jetpack Compose, but a common pattern in many frameworks, programming languages, and platforms. For example, Kotlin supports observables through property delegates:</p>
			<pre>var counter by observable(-1) { _, oldValue, newValue -&gt;
  println("$oldValue -&gt; $newValue")
}
for (i in 0..3) counter = i</pre>
			<p><code>observable()</code> returns a delegate for a property that can be read and written to. In the previous code snippet, the initial value is set to <code>-1</code>. The property calls a specified function when its value is changed (<code>counter = i</code>). My example prints the old and new values. In an imperative UI framework, state changes require modifying the component tree. Such code could be put in the callback function. Fortunately, Jetpack Compose doesn't require this, because state changes automatically trigger a recomposition of the relevant UI elements. Let's see how this works.</p>
			<p>The <code>androidx.compose.runtime.State</code> base interface defines a value holder, an object that stores a value of a particular type in a property named <code>value</code>. If this property is read during <a id="_idIndexMarker179"/>the execution of a composable function, the composable <a id="_idIndexMarker180"/>will be recomposed whenever <code>value</code> changes, because internally the current <code>RecomposeScope</code> interface will be subscribed to changes of that value. Please note that to be able to change the value, state must be an implementation of <code>MutableState</code>; unlike its immediate predecessor (<code>State</code>), this interface defines <code>value</code> using <code>var</code> instead of <code>val</code>.</p>
			<p>The easiest way to create <code>State</code> instances is to invoke <code>mutableStateOf()</code>. This function returns a new <code>MutableState</code> instance, initialized with the value that was passed in. The next section explains how to use <code>mutableStateOf()</code> to create a stateful composable function.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor093"/>Using state in a composable function</h2>
			<p>A composable <a id="_idIndexMarker181"/>function is said to be <code>remember {}</code>. Let's take a look:</p>
			<pre>@Composable
@Preview
fun SimpleStateDemo1() {
  val num = remember { mutableStateOf(Random.nextInt(0,
    10)) }
  Text(text = num.value.toString())
}</pre>
			<p><code>SimpleStateDemo1()</code> creates a mutable state holding a random integer. By invoking <code>remember {}</code>, we save the state, and in using <code>=</code>, we assign it to <code>num</code>. We get the random number through <code>num.value</code>. Please note that although we defined <code>num</code> with the <code>val</code> keyword, we could change the value with <code>num.value = …</code>, because <code>num</code> holds the reference to a mutable value holder (whose <code>value</code> property is writeable). Think of it as modifying an item in a list, not changing to another list. We can slightly alter the code, as shown in the following snippet. Can you spot the difference?</p>
			<pre>@Composable
@Preview
fun SimpleStateDemo2() {
  val num by remember { mutableStateOf(Random.nextInt(0,
   10)) }
  Text(text = num.toString())
}</pre>
			<p><code>SimpleStateDemo2()</code> creates a mutable state holding a random integer number, too. Using <code>by</code>, we do not <a id="_idIndexMarker183"/>assign the state itself to <code>num</code> but the <a id="_idIndexMarker184"/>value it stores (the random number). This spares us from using <code>.value</code>, which makes the code a little shorter and hopefully more understandable. However, if we want to change <code>num</code>, we must change <code>val</code> to <code>var</code>. Otherwise, we see a <code>Val cannot be reassigned</code> error message.</p>
			<p>You may be wondering what <code>remember {}</code> does under the hood. Let's peek into its code and find out:</p>
			<div><div><img src="img/B17505_05_1.jpg" alt="Figure 5.1 – The source code of remember {}&#13;&#10;" width="732" height="133"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – The source code of remember {}</p>
			<p>The read-only, top-level <code>currentComposer</code> property belongs to the <code>androidx.compose.runtime</code> package. It references an instance of <code>Composer</code>. This interface is targeted by the Compose Kotlin compiler plugin and used by code generation helpers. You should not call it directly, because the runtime assumes that calls are generated by the compiler and therefore do not contain much validation logic. <code>Cache()</code> is an extension function of <code>Composer</code>. It stores a value in the composition data of a composition. So, <code>remember {}</code> creates internal state. Therefore, composable functions that contain <code>remember {}</code> are stateful.</p>
			<p><code>calculation</code> represents a lambda expression that creates the value to be remembered. It is <a id="_idIndexMarker185"/>evaluated only once, during the <a id="_idIndexMarker186"/>composition. Subsequent calls to <code>remember {}</code> (during recompositions) always return this value. The expression is not evaluated again. But what if we need to reevaluate the calculation, that is, remember a new value? After all, isn't state data that can change over time? Here's how you can do this:</p>
			<pre>@Composabl<a id="_idTextAnchor094"/>e
@Preview
fun RememberWithKeyDemo() {
  var key by remember { mutableStateO<a id="_idTextAnchor095"/>f(false) }
  val date by remember(key) { mutableStateOf(Date()) }
  Column(horizontalAlignment =
         Alignment.CenterHorizontally) {
    Text(date.toString())
    Button(onClick = { key = !key }) {
      Text(text = stringResource(id = R.string.click))
    }
  }
}</pre>
			<p>The preview of <code>RememberWithKeyDemo()</code> is shown in <em class="italic">Figure 5.2</em>:</p>
			<div><div><img src="img/B17505_05_2.jpg" alt="Figure 5.2 – Preview of RememberWithKeyDemo()&#13;&#10;" width="505" height="184"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Preview of RememberWithKeyDemo()</p>
			<p><code>RememberWithKeyDemo()</code> emits <code>Column()</code> with two horizontally centered children:</p>
			<ul>
				<li><code>Text()</code> shows the string representation of a remembered <code>Date</code> instance.</li>
				<li><code>Button()</code> toggles a Boolean value (<code>key</code>).</li>
			</ul>
			<p>Have you noticed that I pass <code>key</code> to <code>remember { mutableStateOf(Date()) }</code>? Here's what <a id="_idIndexMarker187"/>happens – when <code>remember {}</code> is invoked for the <a id="_idIndexMarker188"/>first time, the result of the calculation (<code>mutableStateOf(Date())</code>) is remembered and returned. During recompositions, the calculation is not reevaluated unless <code>key</code> is <em class="italic">not</em> equal to the previous composition. In this case, a new value is calculated, remembered, and returned.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can pass any number of keys to <code>remember {}</code>. If one of them has changed since the previous composition, the calculation is reevaluated, and the new value is remembered and returned.</p>
			<p>Passing keys to <code>remember {}</code> allows you to change remembered values. Please keep in mind, though, that this makes the composable function less predictable. Therefore, you should consider whether such logic needs to be composable or whether you could pass all state to it.</p>
			<p>In the next section, we turn to stateless composables.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor096"/>Writing stateless composable functions</h2>
			<p><code>remember {}</code> makes a <a id="_idIndexMarker189"/>composable function stateful. A stateless composable, on the other hand, doesn't hold any state. Here's an example:</p>
			<pre>@Composable
@Preview
fun SimpleStatelessComposable1() {
  Text(text = "Hello Compose")
}</pre>
			<p><code>SimpleStatelessComposable1()</code> doesn't receive parameters and it always calls <code>Text()</code>with the same parameters. Clearly, it doesn't hold any state. But how about the following one?</p>
			<pre>@Composable
fun SimpleStatelessComposable2(text: State&lt;String&gt;) {
  Text(text = text.value)
}</pre>
			<p>While it receives state through the <code>text</code> parameter, it doesn't store it, and it doesn't remember other state. Consequently, <code>SimpleStatelessComposable2()</code> is stateless, too. It behaves <a id="_idIndexMarker190"/>the same way when called with the same argument multiple times. Such functions are said to be <code>SimpleStatelessComposable2()</code> a good blueprint for your own composable functions. They should be as follows:</p>
			<ul>
				<li><strong class="bold">Fast</strong>: Your composable must not do heavy (that is, time-consuming) computations. Never invoke a web service or do any other I/O. Data that is used by a composable should be passed to it.</li>
				<li><strong class="bold">Free of side-effects</strong>: Do not modify global properties or produce unintended observable effects (modifying state that has been passed to a composable is certainly intentional).</li>
				<li><code>remember {}</code>, do not access global properties, and do not call unpredictable code. For example, <code>SimpleStateDemo1()</code> and <code>SimpleStateDemo2()</code> use <code>Random.nextInt()</code>, which, by definition, is (practically) not predictable.</li>
			</ul>
			<p>Such composable functions <a id="_idIndexMarker191"/>are both easy to reuse and test because they don't rely on anything that isn't passed in as parameters.</p>
			<p>When developing reusable composables, you may want to expose both a stateful and a stateless version. Let's see how this looks:</p>
			<pre>@Composable
fun TextFieldDemo(state: MutableState&lt;TextFieldValue&gt;) {
  TextField(
    value = state.value,
    onValueChange = {
      state.value = it
    },
    placeholder = { Text("Hello") },
    modifier = Modifier.fillMaxWidth()
  )
}</pre>
			<p>This version is stateless because it receives state and does not remember anything. Stateless versions are necessary for callers that need to control the state or hoist it themselves:</p>
			<pre>@Composable
@Preview
fun TextFieldDemo() {
  val state = remember { mutableStateOf(TextFieldValue("")) }
  TextFieldDemo(state)
}</pre>
			<p>This version is <a id="_idIndexMarker192"/>stateful because it remembers the state it creates. Stateful versions are convenient for callers that don't care about the state.</p>
			<p>To conclude, try to make your composables stateless by not relying on <code>remember {}</code> or other functions that remember state (for example, <code>rememberLazyListState()</code> or <code>rememberSaveable()</code>). Instead, pass state to the composable. You will see more use cases in the next section.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor097"/>Hoisting state and passing events</h1>
			<p>So, state is any value that can change over time. As Jetpack Compose is a declarative UI framework, the only <a id="_idIndexMarker193"/>way to update a composable is to call it with new arguments. This happens <a id="_idIndexMarker194"/>automatically when state a composable is using changes. State hoisting is a pattern of moving state up to make a composable stateless.</p>
			<p>Besides making a composable more easily reusable and testable, moving state up is necessary to use it in more than one composable function. You have already seen this in quite a few of my sample apps. For example, in the <em class="italic">Composing and recomposing the UI</em> section of <a href="B17505_03_ePub.xhtml#_idTextAnchor054"><em class="italic">Chapter 3</em></a>, <em class="italic">Exploring the Key Principles of Compose</em>, we used three sliders to create and display a color.</p>
			<p>While state controls the visual representation of a composable function (that is, how it looks on screen), <code>FlowOfEventsDemo</code> app is a simple temperature converter. The user enters a value, specifies whether it represents degrees Celsius or Fahrenheit, and then hits the <strong class="bold">C<a id="_idTextAnchor098"/>onvert</strong> button:</p>
			<div><div><img src="img/B17505_05_3.jpg" alt="Figure 5.3 – Sample FlowOfEventsDemo app &#13;&#10;" width="1064" height="570"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Sample FlowOfEventsDemo app </p>
			<p>The UI <a id="_idIndexMarker195"/>consists of <code>Column()</code> with four children: a text input field, a group <a id="_idIndexMarker196"/>of radio buttons with text, a button, and some result text. Let's look at the text input field first:</p>
			<pre>@Composable
fun TemperatureTextField(
  temperature: MutableState&lt;String&gt;,
  modifier: Modifier = Modifier,
<strong class="bold">  callback: () -&gt; Unit</strong>
) {
  TextField(
    value = temperature.value,
<strong class="bold">    onValueChange = {</strong>
<strong class="bold">      temperature.value = it</strong>
<strong class="bold">    },</strong>
    …
    modifier = modifier,
<strong class="bold">    keyboardActions = KeyboardActions(onAny = {</strong>
<strong class="bold">      callback()</strong>
<strong class="bold">    }),</strong>
    keyboardOptions = KeyboardOptions(
      keyboardType = KeyboardType.Number,
      imeAction = ImeAction.Done
    ),
    singleLine = true
  )
}</pre>
			<p>It receives <code>MutableState&lt;String&gt;</code>, to which it pushes changes to the text in <code>onValueChange {}</code>. The virtual keyboard is configured to show a <em class="italic">Done</em> button. If it is invoked, code passed to <a id="_idIndexMarker197"/>the composable through <code>callback</code> is executed. As you will <a id="_idIndexMarker198"/>see a little later, that same code will run if the user clicks on the <em class="italic">Convert</em> button.</p>
			<p>In the next section, I'll show you how to create radio buttons and put them in groups so that only one button is selected at a time. The section also covers the button and the result text, which you can see in <em class="italic">Fig. 5.3</em>.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor099"/>Creating radio button groups</h2>
			<p>The app converts between degrees Celsius and Fahrenheit. Therefore, the user must choose the target scale. Such selections <a id="_idIndexMarker199"/>can be implemented easily in Jetpack Compose using <code>androidx.compose.material.RadioButton()</code>. This composable doesn't show some descriptive text, but it is easy to add some. Here's how:</p>
			<pre>@Composable
fun TemperatureRadioButton(
  selected: Boolean,
  resId: Int,
<strong class="bold">  onClick: (Int) -&gt; Unit,</strong>
  modifier: Modifier = Modifier
) {
  Row(
    verticalAlignment = Alignment.CenterVertically,
    modifier = modifier
  ) {
    RadioButton(
      selected = selected,
<strong class="bold">      onClick = {</strong>
<strong class="bold">        onClick(resId)</strong>
<strong class="bold">      }</strong>
    )
    Text(
      text = stringResource(resId),
      modifier = Modifier
        .padding(start = 8.dp)
    )
  }
}</pre>
			<p><code>RadioButton()</code> and <code>Text()</code> are simply added to <code>Row()</code> and vertically centered. <code>TemperatureRadioButton()</code> receives a lambda expression with the <code>onClick</code> parameter. That code is <a id="_idIndexMarker200"/>executed when the radio button is clicked. My implementation passes the <code>resId</code> parameter to the lambda expression, which will be used to determine the button in a group. Here's how:</p>
			<pre>@Composable
fun TemperatureScaleButtonGroup(
<strong class="bold">  selected: MutableState&lt;Int&gt;,</strong>
  modifier: Modifier = Modifier
) {
  val sel = selected.value
<strong class="bold">  val onClick = { resId: Int -&gt; selected.value = resId }</strong>
  Row(modifier = modifier) {
    TemperatureRadioButton(
      selected = sel == R.string.celsius,
      resId = R.string.celsius,
      onClick = onClick
    )
    TemperatureRadioButton(
      selected = sel == R.string.fahrenheit,
      resId = R.string.fahrenheit,
      onClick = onClick,
      modifier = Modifier.padding(start = 16.dp)
    )
  }
}</pre>
			<p>Two <code>TemperatureRadioButton()</code> are put in a <code>Row()</code>. The first one is configured to represent degrees Celsius, the second one degrees Fahrenheit. Both receive the same <code>onClick</code> lambda. It sets the <code>resId</code> parameter it received from <code>TemperatureRadioButton()</code> as the new value of the <code>selected</code> parameter, a mutable state. So, what is <a id="_idIndexMarker201"/>happening here? Clicks on a radio button are not handled inside <code>TemperatureRadioButton()</code> but passed to the parent, <code>TemperatureScaleButtonGroup()</code>. The event, a button click, is said to <strong class="bold">bubble up</strong>. This way, the parent can orchestrate its children and notify its parent. In my <a id="_idIndexMarker202"/>example, this means changing some state.</p>
			<p>Next, let's see what happens when the user clicks the <code>FlowOfEventsDemo()</code>. Here's the overall structure of this composable function:</p>
			<pre>@Composable
@Preview
fun FlowOfEventsDemo() {
  ...
<strong class="bold">  val calc = {</strong>
<strong class="bold">    val temp = temperature.value.toFloat()</strong>
<strong class="bold">    convertedTemperature = if (scale.value ==</strong>
<strong class="bold">                               R.string.celsius)</strong>
<strong class="bold">      (temp * 1.8F) + 32F</strong>
<strong class="bold">    else</strong>
<strong class="bold">      (temp - 32F) / 1.8F</strong>
<strong class="bold">  }</strong>
  val result = remember(convertedTemperature) {
    if (convertedTemperature.isNaN())
      ""
    else
      "${convertedTemperature}${
        if (scale.value == R.string.celsius)
          strFahrenheit
        else strCelsius
      }"
  }
  val enabled = temperature.value.isNotBlank()
  Column( ... ) {
    TemperatureTextField(
      temperature = temperature,
      modifier = Modifier.padding(bottom = 16.dp),
<strong class="bold">      callback = calc</strong>
    )
    TemperatureScaleButtonGroup(
      selected = scale,
      modifier = Modifier.padding(bottom = 16.dp)
    )
    Button(
<strong class="bold">      onClick = calc,</strong>
      enabled = enabled
    ) {
      Text( ... )
    }
    if (result.isNotEmpty()) {
      Text(text = result, …
      )
    }
  }
}</pre>
			<p>The conversion logic is assigned to a read-only variable called <code>calc</code>. It is passed to <code>TemperatureTextField()</code> and <code>Button()</code>. Passing the code that is going to be executed in response to an event to a composable function rather than hard coding it inside makes the composable more easily reusable and testable.</p>
			<p>The text that is displayed after conversion is remembered and assigned to <code>result</code>. It is re-evaluated <a id="_idIndexMarker203"/>when <code>convertedTemperature</code> changes. This happens inside the <code>calc</code> lambda expression. Please note that I need to pass a key to <code>remember {}</code>; otherwise, the result would be changed also if the user picks another scale.</p>
			<p>In the next section, we will look at how state can be persisted. To be more precise, we turn to configuration changes. If the user rotates a device, the UI should not be reset. Unfortunately, this is what happens with all sample apps I have shown you so far. It's time to fix this.</p>
			<h1 id="_idParaDest-78">Surviv<a id="_idTextAnchor100"/>ing configuration changes</h1>
			<p>Please recall that our definition of state as data that may change over time is quite broad. For example, we do not specify where the data is stored. If it resides in a database, a file, or some <a id="_idIndexMarker204"/>backend in the cloud, the app should include a dedicated persistence layer. However, until Google introduced the Android Architecture Components back in 2017, there had been practically no guidance for developers on how to structure their apps. Consequently, persistence code, UI logic, and domain logic were often crammed into one activity. Such code was difficult to maintain and often prone to errors. To make matters a little more complicated, there are situations when an activity is destroyed and recreated shortly after. For example, this happens when a user rotates a device. Certainly, data should then be remembered.</p>
			<p>The <code>Activity</code> class has a few methods to handle this. For example, <code>onSaveInstanceState()</code> is invoked when the activity is (temporarily) destroyed. Its counterpart <code>onRestoreInstanceState()</code> method is called only when such an instance state has been saved before. Both methods receive an instance of <code>Bundle</code>, which has getters and setters for various data types. However, the concept of instance state has been designed for the traditional view system. Most activities held references to UI elements and therefore could be accessed easily inside <code>onSaveInstanceState()</code> and <code>onRestoreInstanceState()</code>. </p>
			<p>Composables, on the other hand, are usually implemented as top-level functions. So, how can their state be set or queried from inside an activity? To temporarily save state in a Compose app, you <a id="_idIndexMarker205"/>can use <code>rememberSaveable {}</code>. This composable function remembers the value produced by a factory function. It behaves similarly to <code>remember {}</code>. The stored value will survive the activity or process recreation. Internally, the <code>savedInstanceState</code> mechanism is used. The sample <code>ViewModelDemo</code> app shows how to use <code>rememberSaveable {}</code>. Here's what the main activity looks like:</p>
			<pre>class ViewModelDemoActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContent {
      ViewModelDemo()
    }
  }
}</pre>
			<p>We don't need to override <code>onSaveInstanceState()</code> to temporarily save our state used with composables:</p>
			<pre>@Composable
@Preview
fun ViewModelDemo() {
  ...
  val state1 = remember {
    mut<a id="_idTextAnchor101"/>ableStateOf("Hello #1")
  }
  val state2 = rememberSaveable {
    mutableStateOf("Hello #2")
  }
  ...
  state3.value?.let {
    Column(modifier = Modifier.fillMaxWidth()) {
      MyTextField(state1) { state1.value = it }
      MyTextField(state2) { state2.value = it }
      ...
    }
  }
}</pre>
			<p>The app shows three text input fields that receive their values from states assigned to <code>state1</code>, <code>state2</code>, and <code>state3</code>. For now, we will focus on the first two. <code>state3</code> will be the subject of the <em class="italic">Using ViewModel</em> section. <code>state1</code> invokes <code>remember {}</code>, whereas <code>state2</code> uses <code>rememberSaveable {}</code>. If you ran <code>ViewModelDemo</code>, changed the content <a id="_idIndexMarker206"/>of the text input fields, and rotated the device, the first one would be reset to the original text, whereas the second one would keep your changes.</p>
			<p><code>MyTextField</code> is a very simple composable. It looks like this:</p>
			<pre>@Composable
fun MyTextField(
  value: State&lt;String?&gt;,
  onValueChange: (String) -&gt; Unit
) {
  value.value?.let {
    TextField(
      value = it,
      onValueChange = onValueChange,
      modifier = Modifier.fillMaxWidth()
    )
  }
}</pre>
			<p>Have you noticed that <code>value</code> is of <code>State&lt;String?&gt;</code>? Why would I need a value holder whose value can be <code>null</code>, and therefore need to check with <code>value.value?.let {}</code> that it isn't? We will be reusing the composable in the following section, and <a id="_idIndexMarker207"/>you will find the answer to this question there. Please note, though, that for both <code>state1</code> and <code>state2</code>, this would not have been necessary.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor102"/>Using ViewModel</h2>
			<p>While temporarily storing state with <code>rememberSaveable {}</code> works great, an app still must get data that <a id="_idIndexMarker208"/>is persisted for a longer time (for example, in a database or file) and make it available as state that can be used in composables. The Android Architecture Components include <code>ViewModel</code> and <code>LiveData</code>. Both can be used seamlessly with Jetpack Compose.</p>
			<p>First, you need to add a few implementation dependencies to the module-level <code>build.gradle</code> file:</p>
			<pre>implementation "androidx.compose.runtime:runtime-
  livedata:$compose_version"
implementation 'androidx.lifecycle:lifecycle-runtime-
  ktx:2.4.0'
implementation 'androidx.lifecycle:lifecycle-viewmodel-
  compose:2.4.0'</pre>
			<p>The next step is to define a <code>ViewModel</code> class. It extends <code>androidx.lifecycle.ViewModel</code>. A <code>ViewModel</code> class stores and manages UI-related data in a lifecycle-conscious way. This means that data will survive configuration changes, such as <a id="_idIndexMarker209"/>screen rotations. <code>MyViewModel</code> exposes one property called <code>text</code> and a me<a id="_idTextAnchor103"/>thod named <code>setText()</code> to set it:</p>
			<pre>class MyViewModel : ViewModel() {
    private val _text: MutableLiveData&lt;String&gt; =
        MutableLiveData&lt;String&gt;("Hello #3")
    val text: LiveData&lt;String&gt;
        get() = _text
    fun setText(value: String) {
        _text.value = value
    }
}</pre>
			<p>My example shows a <code>ViewModel</code> class using <code>LiveData</code>. Depending on the architecture of an app, you can utilize other mechanisms for working with observable data. Going into more detail is, however, beyond the scope of this book. You can find additional <a id="_idIndexMarker210"/>information in <em class="italic">Guide to app architecture</em> at <a href="https://developer.android.com/jetpack/guide#fetching_data">https://developer.android.com/jetpack/guide</a>.</p>
			<p>To access the <code>ViewModel</code> class from inside a composable function, we invoke the composable <code>viewModel()</code>. It belongs to the <code>androidx.lifecycle.viewmodel.compose</code> package:</p>
			<pre>val viewModel: MyViewModel = viewModel()</pre>
			<p><code>LiveData</code> is made available as state like this:</p>
			<pre>val state3 = viewModel.text.observeAsState()</pre>
			<p>Let's take a quick look at its source code:</p>
			<div><div><img src="img/B17505_05_4.jpg" alt="Figure 5.4 – Source code of the observeAsState() extension function&#13;&#10;" width="725" height="196"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4 – Source code of the observeAsState() extension function</p>
			<p><code>observeAsState()</code> is an extension function of <code>LiveData</code>. It passes the <code>value</code> property of its <code>LiveData</code> instance to a variant of <code>observeAsState()</code> that takes parameters. Have you <a id="_idIndexMarker211"/>noticed that the return type is <code>State&lt;T?&gt;</code>? That is why I defined <code>MyTextField()</code> in the previous section to receive <code>State&lt;String?&gt;</code>. To be able to use <code>State&lt;String&gt;</code> as with <code>remember {}</code> and <code>rememberSaveable {}</code>, we would need to define <code>state3</code> like this:</p>
			<pre>val state3 =
   viewModel.text.observeAsState(viewModel.text.value) as
   State&lt;String&gt;</pre>
			<p>In my opinion, this is less favorable than using <code>State&lt;String?&gt;</code> because we use an unchecked cast.</p>
			<p>To reflect changes in state in the <code>ViewModel</code> class, we need code like this:</p>
			<pre>MyTextField(state3) {
  viewModel.setText(it)
}</pre>
			<p>Unlike using <code>MutableState</code>, we must explicitly invoke the <code>setText()</code> method of <code>MyViewModel</code> and pass the changed text.</p>
			<p>To conclude, <code>rememberSaveable {}</code> is simple and easy to use. For more complex scenarios than presented in this chapter, you can provide <code>androidx.compose.runtime.saveable.Saver</code> implementations, which make your data objects simpler and convert them to something saveable. Bigger apps should use <code>ViewModel</code> classes, as <a id="_idIndexMarker212"/>recommended for quite a while now by Google. The combination of <code>ViewModel</code> and <code>LiveData</code> classes can be integrated nicely into composable apps using <code>observerAsState()</code>.</p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor104"/>Summary</h1>
			<p>This chapter aimed to give a more detailed look at state in Compose apps. We started by exploring the differences between stateful and stateless composable functions. You learned their typical use cases and why you should try to keep your composables stateless. Hoisting state is a tool to achieve that. We covered this important topic in the second main section. I also showed you that you can make your composable functions more reusable by passing logic as parameters, rather than implementing it inside the composable. The previous section explored the integration of a Compose UI hierarchy in activities concerning how to retain user input. We looked at the differences between <code>remember {}</code> and <code>rememberSaveable {}</code>, and I gave you a glimpse of how bigger Compose apps can benefit from <code>ViewModel</code> classes.</p>
			<p>Chapters 1 to 5 introduced you to various aspects of Jetpack Compose, such as composable functions, state, and layout. <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>, focuses on one app, providing you with a bigger picture of how these pieces work together to form a real-world app. We will implement a simple unit converter app, focusing on app architecture and UI, including theming and navigation.</p>
		</div>
	</div></body></html>