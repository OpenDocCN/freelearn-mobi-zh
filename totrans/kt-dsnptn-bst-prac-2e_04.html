<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-80"><em class="italic"><a id="_idTextAnchor080"/>Chapter 3</em>: Understanding Structural Patterns</h1>&#13;
			<p>This chapter covers <strong class="bold">structural patterns</strong> in <strong class="bold">Kotlin</strong>. In general, structural patterns deal with relationships between <strong class="bold">objects</strong>.</p>&#13;
			<p>We'll discuss how to extend the functionality of our objects without producing complex class hierarchies. We'll also discuss how to adapt to changes in the future or fix some of the design decisions taken in the past, as well as how to reduce the memory footprint of our program.</p>&#13;
			<p>In this chapter, we will cover the following patterns:</p>&#13;
			<ul>&#13;
				<li>Decorator</li>&#13;
				<li>Adapter</li>&#13;
				<li>Bridge</li>&#13;
				<li>Composite</li>&#13;
				<li>Facade</li>&#13;
				<li>Flyweight</li>&#13;
				<li>Proxy</li>&#13;
			</ul>&#13;
			<p>By the end of this chapter, you'll have a better understanding of how to compose your objects so that they can be simpler to extend and adapt to different types of changes.</p>&#13;
			<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Technical requirements</h1>&#13;
			<p>The requirements <a id="_idIndexMarker204"/>for this chapter <a id="_idIndexMarker205"/>are the same as the previous chapters—you'll need <strong class="bold">IntelliJ IDEA</strong> and the <strong class="bold">JDK</strong>.</p>&#13;
			<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03">https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter03</a>.</p>&#13;
			<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/>Decorator</h1>&#13;
			<p>In the previous <a id="_idIndexMarker206"/>chapter, we discussed the <strong class="bold">Prototype</strong> design pattern, which allows us to create instances of classes with slightly (or not so slightly) different data. This raises a question:</p>&#13;
			<p><em class="italic">What if we want to create a set of classes that all have slightly different behavior?</em></p>&#13;
			<p>Well, since <a id="_idIndexMarker207"/>functions in Kotlin are <em class="italic">first-class citizens</em> (which we will explain in this chapter), you could use the Prototype design pattern to achieve this aim. After all, creating a set of classes with slightly different behavior is what JavaScript does successfully. But the goal of this chapter is to discuss another approach to the same problem. After all, design patterns are all about <em class="italic">approaches</em>.</p>&#13;
			<p>By implementing the <strong class="bold">Decorator</strong> design pattern, we allow the users of our code to specify the abilities they want to add.</p>&#13;
			<h2 id="_idParaDest-83"><a id="_idTextAnchor083"/>Enhancing a class</h2>&#13;
			<p>Let's say that <a id="_idIndexMarker208"/>we have a rather simple class that registers all of the captains in the Star Trek universe along with their vessels:</p>&#13;
			<pre>open class StarTrekRepository {</pre>&#13;
			<pre>    private val starshipCaptains = mutableMapOf("USS </pre>&#13;
			<pre>        Enterprise" to "Jean-Luc Picard")</pre>&#13;
			<pre> </pre>&#13;
			<pre>    open fun getCaptain(starshipName: String): String {</pre>&#13;
			<pre>        return starshipCaptains[starshipName] <strong class="bold">?:</strong> "Unknown"</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    open fun addCaptain(starshipName: String, captainName:         String) {</pre>&#13;
			<pre>        starshipCaptains[starshipName] = captainName</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>One day, your captain—sorry, <em class="italic">scrum master</em>—comes to you with an urgent requirement. From now on, every time someone searches for a captain, we must also log this into a console. However, there's a catch to this simple task: you cannot modify the <code>StarTrekRepository</code> class directly. There are other consumers for this class, and they don't need this logging behavior.</p>&#13;
			<p>But before <a id="_idIndexMarker209"/>we dive deeper into this problem, let's discuss one peculiarity we can observe in our class – that is, a strange operator you can see in the <code>getCaptain</code> function.</p>&#13;
			<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>The Elvis operator</h2>&#13;
			<p>In <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>, we learned that Kotlin is not only strongly typed, but it is also a null-safe language.</p>&#13;
			<p><em class="italic">What happens if, as in our example, there could be no value stored in a map for a particular key?</em></p>&#13;
			<p>If we're <a id="_idIndexMarker210"/>working with a map, one option is to use the <code>getOrDefault</code> method that maps provide in Kotlin. This might be a viable option in this particular case, but it won't work in situations where you might have to deal with a null value.</p>&#13;
			<p>Another <a id="_idIndexMarker211"/>option is to use the <code>?:</code>). If you're wondering about how this operator got its name, it does resemble Elvis Presley's hairstyle somewhat:</p>&#13;
			<div>&#13;
				<div>&#13;
					<img src="img/B17816_03_01.jpg" alt="Figure 3.1 – If we turn the Elvis operator 90 degrees clockwise, it looks a bit like a pompadour hairstyle&#13;&#10;" width="100" height="127"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="figure-caption">Figure 3.1 – If we turn the Elvis operator 90 degrees clockwise, it looks a bit like a pompadour hairstyle</p>&#13;
			<p>The goal of the Elvis operator is to provide a default value in case we receive a null value. Take another look at the <code>getCaptain</code> function to see how this is done. The <em class="italic">desugared</em> form of the same function would be as follows:</p>&#13;
			<pre>return if (starshipCaptains[starshipName] == null) </pre>&#13;
			<pre>    "Unknown" else starshipCaptains[starshipName]</pre>&#13;
			<p>So, you can see that this operator saves us a lot of typing.</p>&#13;
			<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>The inheritance problem</h2>&#13;
			<p>Let's go <a id="_idIndexMarker212"/>back to the task at hand. Since our class and its methods are declared open, we can extend the class and override the function we need:</p>&#13;
			<pre>class LoggingGetCaptainStarTrekRepository : </pre>&#13;
			<pre>  StarTrekRepository() {</pre>&#13;
			<pre>    override fun getCaptain(starshipName: String): String {</pre>&#13;
			<pre>        println("Getting captain for $starshipName")</pre>&#13;
			<pre>        return <strong class="bold">super</strong>.getCaptain(starshipName)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>That was quite easy! Although the name of that class is getting quite long.</p>&#13;
			<p>Note how we delegate to the implementation in our parent class by using the <code>super</code> keyword here. However, the next day, your boss (sorry, <em class="italic">scrum-master</em>) comes again and asks for another feature. When adding a captain, we need to check that their name is no longer than 15 characters. That may be a problem for some Klingons, but you decide to implement it anyway. And, by the way, this feature should not be related to the logging feature we developed previously. Sometimes we just want the logging, and sometimes we just want the validation. So, here's what our new class will look like:</p>&#13;
			<pre>class ValidatingAddCaptainStarTrekRepository : </pre>&#13;
			<pre>  StarTrekRepository() {</pre>&#13;
			<pre>    override fun addCaptain(starshipName: String, </pre>&#13;
			<pre>        captainName: String) {</pre>&#13;
			<pre>        if (captainName.length &gt; 15) {</pre>&#13;
			<pre>            throw RuntimeException("$captainName is longer                 than 20 characters!")</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        super.addCaptain(starshipName, captainName)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Another task done.</p>&#13;
			<p>However, the next day, another requirement arises: in some cases, we need <code>StarTrekRepository</code> to have logging enabled and also perform validation at the same time. I guess we'll have to name it <code>LoggingGetCaptainValidatingAddCaptainStarTrekRepository</code> now.</p>&#13;
			<p>Problems like this are surprisingly common, and they are a clear indication that a design pattern may help us here.</p>&#13;
			<p>The purpose <a id="_idIndexMarker213"/>of the Decorator design pattern is to add new behaviors to our objects dynamically. In our example, <em class="italic">logging</em> and <em class="italic">validating</em> are two behaviors that we sometimes want to be applied to our object and sometimes don't want to be applied.</p>&#13;
			<p>We'll start by converting our <code>StarTrekRepository</code> into an interface:</p>&#13;
			<pre>interface StarTrekRepository {</pre>&#13;
			<pre>    fun getCaptain(starshipName: String): String</pre>&#13;
			<pre>    fun addCaptain(starshipName: String, captainName:       <a id="_idTextAnchor086"/>  String)</pre>&#13;
			<pre>    }</pre>&#13;
			<p>Then, we'll implement that interface using the same logic as before:</p>&#13;
			<pre>class DefaultStarTrekRepository : StarTrekRepository {</pre>&#13;
			<pre>    private val starshipCaptains = mutableMapOf("USS Enter         prise" to "Jean-Luc Picard")</pre>&#13;
			<pre>    override fun getCaptain(starshipName: String): String {</pre>&#13;
			<pre>        return starshipCaptains[starshipName] ?: "Unknown"</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    override fun addCaptain(starshipName: String, captain         Name: String) {</pre>&#13;
			<pre>        starshipCaptains[starshipName] = captainNam<a id="_idTextAnchor087"/>e</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Next, instead of extending our concrete implementation, we'll implement the interface and use a new <a id="_idIndexMarker214"/>keyword called <code>by</code>:</p>&#13;
			<pre>class LoggingGetCaptain(private val repository:</pre>&#13;
			<pre>  StarTrekRepository): StarTrekRepository by repository {</pre>&#13;
			<pre>    override fun getCaptain(starshipName: String): String {</pre>&#13;
			<pre>        println("Getting captain for $starshipName")</pre>&#13;
			<pre>        return repository.getCaptain(starshipNa<a id="_idTextAnchor088"/>me)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The <code>by</code> keyword delegates the implementation of an interface to another object. That's why the <code>LoggingGetCaptain</code> class doesn't have to implement any of the functions declared in the interface. They are all implemented by default by another object that the instance wraps.</p>&#13;
			<p>In this case, the <a id="_idIndexMarker215"/>hardest part to understand is the signature. What we need from the Decorator design pattern is as follows:</p>&#13;
			<ul>&#13;
				<li>We need to be able to receive the object we're decorating.</li>&#13;
				<li>We need to be able to keep a reference to the object.</li>&#13;
				<li>When our decorator is called, we need to be able to decide if we would like to change the behavior of the object we're holding or to delegate the call.</li>&#13;
				<li>We need to be able to extract an interface or have one provided already by the (library) author.</li>&#13;
			</ul>&#13;
			<p>Note that we don't use the <code>super</code> keyword anymore. If we tried to, it wouldn't work, as there is a class that we're implementing now. Instead, we use the reference to the <code>wrapped</code> interface. </p>&#13;
			<p>To make sure we understand this pattern, let's implement our second decorator:</p>&#13;
			<pre>class ValidatingAdd(private val repository: </pre>&#13;
			<pre>  StarTrekRepository): StarTrekRepository by repository {</pre>&#13;
			<pre>    private val maxNameLength = 15</pre>&#13;
			<pre>    override fun addCaptain(starshipName: String,</pre>&#13;
			<pre>        captainName: String) {</pre>&#13;
			<pre>        require (captainName.length &lt; maxNameLength) {</pre>&#13;
			<pre>            "$captainName name is longer than                 $maxNameLength characters!"</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>        repository.addCaptain(starshipName, captainN<a id="_idTextAnchor089"/>ame)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The only difference <a id="_idIndexMarker216"/>between the preceding example and the <code>ValidatingAddCaptainStarTrekRepository</code> implementation is that we use the <code>require</code> function instead of an <code>if</code> expression. This is often more readable, and it will also throw <code>IllegalArgumentException</code> if the expression is <code>false</code>.</p>&#13;
			<p>Let's see how it<a id="_idTextAnchor090"/> works now:</p>&#13;
			<pre>val starTrekRepository = DefaultStarTrekRepository()</pre>&#13;
			<pre>val withValidating = ValidatingAdd(starTrekRepository)</pre>&#13;
			<pre>val withLoggingAndValidating =     LoggingGetCaptain(withValidating)</pre>&#13;
			<pre>withLoggingAndValidating.getCaptain("USS Enterprise")</pre>&#13;
			<pre>withLoggingAndValidating.addCaptain("USS Voyager",    "Kathryn Janeway")</pre>&#13;
			<p>The last line will throw an exception:</p>&#13;
			<pre>&gt; Kathryn Janeway name is longer than 15 characters!</pre>&#13;
			<p>As you <a id="_idIndexMarker217"/>can see, this pattern allows us to <em class="italic">compose behavior</em>, just as we wanted. Now, let's take a short detour and discuss <em class="italic">operator overloading</em> in Kotlin, as this will help us to improve our design pattern even more.</p>&#13;
			<h2 id="_idParaDest-86"><a id="_idTextAnchor091"/>Operator overloading</h2>&#13;
			<p>Let's take another look at the interface that was extracted. Here, we are describing basic operations <a id="_idIndexMarker218"/>on a map that are usually <a id="_idIndexMarker219"/>associated with array/map access and assignment. In Kotlin, we have some nice syntactic sugar called <code>DefaultStarTrekRepository</code>, we can see that working with maps is very intuitive in Kotlin:</p>&#13;
			<pre>starshipCaptains[starshipName]</pre>&#13;
			<pre>starshipCaptains[starshipName] = captainName</pre>&#13;
			<p>It would be useful if we could work with our repository as if it was a map:</p>&#13;
			<pre>withLoggingAndValidating["USS Enterprise"]</pre>&#13;
			<pre>withLoggingAndValidating["USS Voyager"] = "Kathryn Janeway"</pre>&#13;
			<p>Using Kotlin, we can actually achieve this behavior quite easily. First, let's change our interface:</p>&#13;
			<pre>interface StarTrekRepository {</pre>&#13;
			<pre>    operator fun get(starshipName: String): String</pre>&#13;
			<pre>    operator fun set(starshipName: String, captainName:         String)</pre>&#13;
			<pre>}</pre>&#13;
			<p>Note that we've added the <code>operator</code> keyword that prefixes the function definition. Let's understand what this keyword means.</p>&#13;
			<p>Most programming languages support some form of operator overloading. Let's take <strong class="bold">Java</strong> as an <a id="_idIndexMarker220"/>example and look at the following two lines:</p>&#13;
			<pre>System.out.println(1 + 1); // Prints 2 </pre>&#13;
			<pre>System.out.println("1" + "1") // Prints 11</pre>&#13;
			<p>We can see that the <code>+</code> operator acts differently depending on whether the arguments are strings or integers. That is, it can add two numbers, but it can also concatenate two strings. You can <a id="_idIndexMarker221"/>imagine that the <em class="italic">plus</em> operation <a id="_idIndexMarker222"/>can be defined on other types. For example, it makes a lot of sense to concatenate two lists using the same operator:</p>&#13;
			<pre>List.of("a") + List.of("b")</pre>&#13;
			<p>Unfortunately, this code won't compile in Java, and we can't do anything about it. That's because operator overloading is a feature reserved to the language itself, and not for its users.</p>&#13;
			<p>Let's look <a id="_idIndexMarker223"/>at another extreme, the <strong class="bold">Scala</strong> programming language. In Scala, any set of characters can be defined as an operator. So, you may encounter code such as the following:</p>&#13;
			<pre>Seq("a") ==== Seq("b") // You'll have to guess what   this code does</pre>&#13;
			<p>Kotlin takes a middle ground between these two approaches. It allows you to overload certain <em class="italic">well-known</em> operations, but it limits what can and cannot be overloaded. Although this list is limited, it is quite long, so we'll not write it in full here. However, you can find <a id="_idIndexMarker224"/>it in the official Kotlin documentation: <a href="https://kotlinlang.org/docs/operator-overloading.html">https://kotlinlang.org/docs/operator-overloading.html</a>.</p>&#13;
			<p>If you use the <code>operator</code> keyword with a function that is unsupported or with the wrong set of arguments, you'll get a compilation error. The square brackets that we started with in the previous code example are called indexed access operators and correlate with the <code>get(x)</code> and <code>set(x, y)</code> methods we have just defined.</p>&#13;
			<h2 id="_idParaDest-87"><a id="_idTextAnchor092"/>Caveats of the Decorator design pattern</h2>&#13;
			<p>The Decorator design pattern is great because it lets us compose objects <em class="italic">on the fly</em>. And using Kotlin's <code>by</code> keyword <a id="_idIndexMarker225"/>makes it easy to implement. But there are still limitations that you need to be aware of.</p>&#13;
			<p>First, you cannot see <em class="italic">inside</em> of the Decorator. This means that there's no way of knowing which specific object it wraps:</p>&#13;
			<pre>println(withLoggingAndValidating is LoggingGetCaptain)</pre>&#13;
			<pre>// This is our top level decorator, no problem here</pre>&#13;
			<pre>println(withLoggingAndValidating is StarTrekRepository)</pre>&#13;
			<pre>// This is the interface we implement, still no problem</pre>&#13;
			<pre>println(withLoggingAndValidating is ValidatingAdd)</pre>&#13;
			<pre>// We wrap this class, but compiler cannot validate it</pre>&#13;
			<pre>println(withLoggingAndValidating is DefaultStarTrekRepository)</pre>&#13;
			<pre>// We wrap this class, but compiler cannot validate it</pre>&#13;
			<p>Although <code>withLoggingAndValidating</code> contains <code>ValidatingAdd</code> (and it may behave like it), it is not an instance of <code>ValidatingAdd</code>! Keep that in mind when performing casts and type checks.</p>&#13;
			<p>So, you might wonder where this pattern would be used in the real world. One example is the <code>java.io.*</code> package, with classes implementing the <code>Reader</code> and <code>Writer</code> interfaces.</p>&#13;
			<p>For example, if you want to read a file efficiently, you can use <code>BufferedReader</code>, which receives another reader as its constructor argument:</p>&#13;
			<pre>val reader = BufferedReader(FileReader("/some/file"))</pre>&#13;
			<p><code>FileReader</code> serves this purpose, as it implements the <code>Reader</code> interface. So does <code>BufferedReader</code> itself. </p>&#13;
			<p>Let's move on to our next design pattern.</p>&#13;
			<h1 id="_idParaDest-88"><a id="_idTextAnchor093"/>Adapter</h1>&#13;
			<p>The main goal of the <strong class="bold">Adapter</strong> design pattern is to convert one interface to another interface. In the <a id="_idIndexMarker226"/>physical world, the best example of this idea would be an electrical plug adapter or a USB adapter.</p>&#13;
			<p>Imagine yourself in a hotel room late in the evening, with 7% battery left on your phone. Your phone charger was left in the office at the other end of the city. You only have an EU plug charger with a Mini USB cable. But your phone uses USB-C, as you had to upgrade. You're in New York, so all of your outlets are (of course) USB-A. So, what do you do? Oh, it's easy. You look for a Mini USB to USB-C adapter in the middle of the night and hope that you have remembered to bring your EU to US plug adapter as well. Only 5% battery left – time is running out!</p>&#13;
			<p>So, now that we understand what adapters are for in the physical world, let's see how we can apply the same principle in code.</p>&#13;
			<p>Let's start with interfaces. </p>&#13;
			<p><code>USPlug</code> assumes that power is <code>Int</code>. It has <code>1</code> as its value if it has power and any other value if it doesn't:</p>&#13;
			<pre>interface USPlug {</pre>&#13;
			<pre>    val hasPower: Int</pre>&#13;
			<pre>}</pre>&#13;
			<p><code>EUPlug</code> treats power as <code>String</code>, which is either <code>TRUE</code> or <code>FALSE</code>:</p>&#13;
			<pre>interface EUPlug {</pre>&#13;
			<pre>    val hasPower: String // "TRUE" or "FALSE"</pre>&#13;
			<pre>}</pre>&#13;
			<p>For <code>UsbMini</code>, power is an <code>enum</code>:</p>&#13;
			<pre>interface UsbMini {</pre>&#13;
			<pre>    val hasPower: Power</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>enum class Power {</pre>&#13;
			<pre>    TRUE, FALSE</pre>&#13;
			<pre>}</pre>&#13;
			<p>Finally, for <code>UsbTypeC</code>, power is a <code>Boolean</code> value:</p>&#13;
			<pre>interface UsbTypeC {</pre>&#13;
			<pre>    val hasPower: Boolean</pre>&#13;
			<pre>}</pre>&#13;
			<p>Our goal is <a id="_idIndexMarker227"/>to bring the power value from a US power outlet to our cellphone, which will be represented by this function:</p>&#13;
			<pre>fun cellPhone(chargeCable: UsbTypeC) {</pre>&#13;
			<pre>    if (chargeCable.hasPower) {</pre>&#13;
			<pre>        println("I've Got The Power!")</pre>&#13;
			<pre>    } else {</pre>&#13;
			<pre>        println("No power")</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Let's start by declaring what a US power outlet will look like in our code. It will be a function that returns a <code>USPlug</code>:</p>&#13;
			<pre>// Power outlet exposes USPlug interface</pre>&#13;
			<pre>fun usPowerOutlet(): USPlug {</pre>&#13;
			<pre>    return <strong class="bold">object </strong>: USPlug {</pre>&#13;
			<pre>        override val hasPower = 1</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>In the previous chapter, we discussed two different uses of the <code>object</code> keyword. In the global scope, it creates a Singleton object. When used together with the <code>companion</code> keyword inside of a class, it creates a place for defining <code>static</code> functions. The same keyword can also be used to generate anonymous classes. Anonymous classes are classes that are created <em class="italic">on the fly</em>, usually to implement an interface in an ad-hoc manner.</p>&#13;
			<p>Our charger will be a function that takes <code>EUPlug</code> as an input and outputs <code>UsbMini</code>:</p>&#13;
			<pre>// Charger accepts EUPlug interface and exposes UsbMini </pre>&#13;
			<pre>// interface</pre>&#13;
			<pre>fun charger(plug: EUPlug): UsbMini {</pre>&#13;
			<pre>    return object : UsbMini {</pre>&#13;
			<pre>        override val hasPower=Power.valueOf(plug.hasPower)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Next, let's <a id="_idIndexMarker228"/>try to combine our <code>cellPhone</code>, <code>charger</code>, and <code>usPowerOutlet</code> functions:</p>&#13;
			<pre>cellPhone(</pre>&#13;
			<pre>    // Type mismatch: inferred type is UsbMini but     // UsbTypeC was expected</pre>&#13;
			<pre>    charger(</pre>&#13;
			<pre>        // Type mismatch: inferred type is USPlug but         // EUPlug was expected</pre>&#13;
			<pre>        usPowerOutlet()</pre>&#13;
			<pre>    )</pre>&#13;
			<pre>)</pre>&#13;
			<p>As you can see, we get two different type errors – the Adapter design pattern should help us solve these.</p>&#13;
			<h2 id="_idParaDest-89"><a id="_idTextAnchor094"/>Adapting existing code</h2>&#13;
			<p>We need two types of adapters: one for our power plugs and another one for our USB ports.</p>&#13;
			<p>In Java, you <a id="_idIndexMarker229"/>would usually create a pair of classes for this purpose. In Kotlin, we can replace these classes with <strong class="bold">extension functions</strong>. We already <a id="_idIndexMarker230"/>mentioned extension functions briefly in <a href="B17816_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Kotlin</em>. Now, it's time to cover them in more detail.</p>&#13;
			<p>We could adapt the US plug to work with the EU plug by defining the following extension function:</p>&#13;
			<pre>fun USPlug.toEUPlug(): EUPlug {</pre>&#13;
			<pre>    val hasPower = if (this.hasPower == 1) "TRUE" else       "FALSE"</pre>&#13;
			<pre>    return object : EUPlug {</pre>&#13;
			<pre>        // Transfer power</pre>&#13;
			<pre>        override val hasPower = hasPower</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The <code>this</code> keyword in the context of an extension function refers to the object we're extending – just as if we were implementing this method inside of the class definition. Again, we use an anonymous class to implement the required interface on the fly.</p>&#13;
			<p>We can create a USB adapter between the Mini USB and USB-C instances in a similar way:</p>&#13;
			<pre>fun UsbMini.toUsbTypeC(): UsbTypeC {</pre>&#13;
			<pre>    val hasPower = this.hasPower == Power.TRUE</pre>&#13;
			<pre>    return object : UsbTypeC {</pre>&#13;
			<pre>        override val hasPower = hasPower</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Finally, we can get back online again by combining all those adapters together:</p>&#13;
			<pre>cellPhone(</pre>&#13;
			<pre>    charger(</pre>&#13;
			<pre>        usPowerOutlet()<strong class="bold">.toEUPlug()</strong></pre>&#13;
			<pre>    )<strong class="bold">.toUsbTypeC()</strong></pre>&#13;
			<pre>)</pre>&#13;
			<p>As you <a id="_idIndexMarker231"/>can see, we didn't have to create any new classes that implement these interfaces. By using Kotlin's extension functions, our code stays short and to the point.</p>&#13;
			<p>The Adapter design pattern is more straightforward than the other design patterns, and you'll see it used widely. Now, let's discuss some of its real-world uses in more detail.</p>&#13;
			<h2 id="_idParaDest-90"><a id="_idTextAnchor095"/>Adapters in the real world</h2>&#13;
			<p>You've probably encountered many uses of the Adapter design pattern already. These are <a id="_idIndexMarker232"/>normally used to adapt between <em class="italic">concepts</em> and <em class="italic">implementations</em>. For example, let's take the concept of a JVM collection versus the concept of a JVM stream.</p>&#13;
			<p>We already <a id="_idIndexMarker233"/>discussed <code>listOf()</code> function:</p>&#13;
			<pre>val list = listOf("a", "b", "c")</pre>&#13;
			<p>A <strong class="bold">stream</strong> is a <em class="italic">lazy</em> collection <a id="_idIndexMarker235"/>of elements. You cannot simply pass a collection to a function that receives a stream, even though it may make sense:</p>&#13;
			<pre>fun printStream(stream: Stream&lt;String&gt;) {</pre>&#13;
			<pre>    stream.forEach(e -&gt; println(e))</pre>&#13;
			<pre>}</pre>&#13;
			<pre>printStream(list) // Doesn't compile</pre>&#13;
			<p>Luckily, collections provide us with the <code>.stream()</code> adapter method:</p>&#13;
			<pre>printStream(list.stream()) // Adapted successfully</pre>&#13;
			<p>Many other Kotlin objects have adapter methods that usually start with <code>to</code> as a prefix. For example, <code>toTypedArray()</code> converts a list to an array.</p>&#13;
			<h2 id="_idParaDest-91"><a id="_idTextAnchor096"/>Caveats of using adapters</h2>&#13;
			<p><em class="italic">Have you ever plugged a 110 V US appliance into a 220 V EU socket through an adapter, and fried it totally?</em> </p>&#13;
			<p>If you're <a id="_idIndexMarker236"/>not careful, that's something that could also happen to your code. The following example uses another adapter, and it also compiles well:</p>&#13;
			<pre>val stream = Stream.generate { 42 } </pre>&#13;
			<pre>stream.toList()</pre>&#13;
			<p>But it never completes because <code>Stream.generate()</code> produces an infinite list of integers. So, be careful and adopt this design pattern wisely.</p>&#13;
			<h1 id="_idParaDest-92"><a id="_idTextAnchor097"/>Bridge</h1>&#13;
			<p>While the Adapter design pattern helps you to work with legacy code, the <strong class="bold">Bridge</strong> design pattern <a id="_idIndexMarker237"/>helps you to avoid abusing inheritance. The way it works is actually very simple.</p>&#13;
			<p>Let's imagine we want to build a system to manage different kinds of troopers for the Galactic Empire.</p>&#13;
			<p>We'll start with an interface:</p>&#13;
			<pre>interface Trooper {</pre>&#13;
			<pre>    fun move(x: Long, y: Long)</pre>&#13;
			<pre>    fun attackRebel(x: Long, y: Long)</pre>&#13;
			<pre>}</pre>&#13;
			<p>And we'll create multiple implementations for different types of troopers:</p>&#13;
			<pre>class StormTrooper : Trooper {</pre>&#13;
			<pre>    override fun move(x: Long, y: Long) {</pre>&#13;
			<pre>        // Move at normal speed</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun attackRebel(x: Long, y: Long) {</pre>&#13;
			<pre>        // Missed most of the time </pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>class ShockTrooper : Trooper {</pre>&#13;
			<pre>    override fun move(x: Long, y: Long) {</pre>&#13;
			<pre>        // Moves slower than regular StormTrooper</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun attackRebel(x: Long, y: Long) {</pre>&#13;
			<pre>        // Sometimes hits</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>There are <a id="_idIndexMarker238"/>also stronger versions of them: </p>&#13;
			<pre>class RiotControlTrooper : StormTrooper() {</pre>&#13;
			<pre>    override fun attackRebel(x: Long, y: Long) {</pre>&#13;
			<pre>        // Has an electric baton, stay away!</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre> </pre>&#13;
			<pre>class FlameTrooper : ShockTrooper() {</pre>&#13;
			<pre>    override fun attackRebel(x: Long, y: Long) {</pre>&#13;
			<pre>        // Uses flametrower, dangerous!</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>And there are also scout troopers that can run faster than the others:</p>&#13;
			<pre>class ScoutTrooper : ShockTrooper() {</pre>&#13;
			<pre>    override fun move(x: Long, y: Long) {</pre>&#13;
			<pre>        // Runs faster</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>That's a lot of classes!</p>&#13;
			<p>One day, our <a id="_idIndexMarker239"/>dear designer comes and asks that all stormtroopers should be able to shout, and each will have a different phrase. Without thinking twice, we add a new function to our interface:</p>&#13;
			<pre>interface Infantry {</pre>&#13;
			<pre>    fun move(x: Long, y: Long) </pre>&#13;
			<pre>    fun attackRebel(x: Long, y: Long)</pre>&#13;
			<pre>    <strong class="bold">fun shout(): String</strong></pre>&#13;
			<pre>}</pre>&#13;
			<p>By doing that, all the classes that implement this interface stop compiling. And we have a lot of them. That's a lot of changes that we'll have to make. So, we'll just have to suck it up and get to work.</p>&#13;
			<p><em class="italic">Or will we?</em></p>&#13;
			<p>We go and change the implementations of five different classes, feeling lucky that there are only five and not fifty.</p>&#13;
			<h2 id="_idParaDest-93"><a id="_idTextAnchor098"/>Bridging changes</h2>&#13;
			<p>The idea behind the Bridge design pattern is to flatten the class hierarchy and have fewer <a id="_idIndexMarker240"/>specialized classes in our system. It also helps us to avoid the <em class="italic">fragile base class</em> problem when modifying the superclass introduces subtle bugs to classes that inherit from it.</p>&#13;
			<p>First, let's try to understand why we have this complex hierarchy and many classes. It's because we have two orthogonal, unrelated properties: <em class="italic">weapon type</em> and <em class="italic">movement speed</em>.</p>&#13;
			<p>Let's say that instead, we wanted to pass those properties to the constructor of a class that implements the same interface we have been using all along:</p>&#13;
			<pre>data class StormTrooper(</pre>&#13;
			<pre>    private val weapon: Weapon,</pre>&#13;
			<pre>    private val legs: Legs</pre>&#13;
			<pre>) : Trooper {</pre>&#13;
			<pre>    override fun move(x: Long, y: Long) {</pre>&#13;
			<pre>        legs.move(x, y)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun attackRebel(x: Long, y: Long) {</pre>&#13;
			<pre>        weapon.attack(x, y)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>The properties that <code>StormTrooper</code> receives should be interfaces, so we can choose their implementation later:</p>&#13;
			<pre>typealias PointsOfDamage = Long </pre>&#13;
			<pre>typealias Meters = Int</pre>&#13;
			<pre>interface Weapon {</pre>&#13;
			<pre>    fun attack(): PointsOfDamage</pre>&#13;
			<pre>}</pre>&#13;
			<pre>interface Legs {</pre>&#13;
			<pre>    fun move(): Meters</pre>&#13;
			<pre>}</pre>&#13;
			<p>Notice that <a id="_idIndexMarker241"/>these methods return <code>Meters</code> and <code>PointsOfDamage</code> instead of simply returning <code>Long</code> and <code>Int</code>. This feature is called <strong class="bold">type aliasing</strong>. To understand how this works, let's take a short detour.</p>&#13;
			<h2 id="_idParaDest-94"><a id="_idTextAnchor099"/>Type aliasing</h2>&#13;
			<p>Kotlin allows <a id="_idIndexMarker242"/>us to provide alternative names for <a id="_idIndexMarker243"/>existing types. These <a id="_idIndexMarker244"/>are called <strong class="bold">aliases</strong>. </p>&#13;
			<p>To declare an alias, we use a new keyword: <code>typealias</code>. From now on, we can use <code>Meters</code> instead of plain old <code>Int</code> to return from our <code>move()</code> method. These aren't new types. The Kotlin compiler will always translate <code>PointsOfDamage</code> to <code>Long</code> during compilation. Using <a id="_idIndexMarker245"/>them provides two advantages:</p>&#13;
			<ul>&#13;
				<li>The first advantage is <em class="italic">better semantics</em> (as in our case). We can tell exactly what the <em class="italic">meaning</em> of the value we're returning is.</li>&#13;
				<li>The second advantage is being <em class="italic">concise</em>. Type aliases allow us to hide complex generic expressions. We'll expand on this in the following sections.</li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-95"><a id="_idTextAnchor100"/>Constants</h2>&#13;
			<p>Let's go <a id="_idIndexMarker246"/>back to our <code>StormTrooper</code> class. It's time to <a id="_idIndexMarker247"/>provide some implementations for the <code>Weapon</code> and <code>Legs</code> interfaces.</p>&#13;
			<p>First, let's define the regular damage and speed of <code>StormTrooper</code>, using imperial units:</p>&#13;
			<pre>const val RIFLE_DAMAGE = 3L</pre>&#13;
			<pre>const val REGULAR_SPEED: Meters = 1</pre>&#13;
			<p>These values are very effective since they are known during compilation.</p>&#13;
			<p>Unlike <code>static final</code> variables in Java, they cannot be placed inside a class. You should place them either at the top level of your package or nest them inside of an object.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Although Kotlin has type inference, we can specify the types of our constants explicitly and even use type aliases. <em class="italic">How about having</em> <code>DEFAULT_TIMEOUT : Seconds = 60</code> <em class="italic">instead of</em> <code>DEFAULT_TIMEOUT_SECONDS = 60</code> <em class="italic">in your code?</em></p>&#13;
			<p>Now, we <a id="_idIndexMarker248"/>can provide <a id="_idIndexMarker249"/>some implementations for our interfaces:</p>&#13;
			<pre>class Rifle : Weapon {</pre>&#13;
			<pre>    override fun attack(x: Long, y: Long) = RIFLE_DAMAGE</pre>&#13;
			<pre>}</pre>&#13;
			<pre>class Flamethrower : Weapon {</pre>&#13;
			<pre>    override fun attack(x: Long, y: Long)= RIFLE_DAMAGE * 2</pre>&#13;
			<pre>}</pre>&#13;
			<pre>class Batton : Weapon {</pre>&#13;
			<pre>    override fun attack(x: Long, y: Long)= RIFLE_DAMAGE * 3</pre>&#13;
			<pre>}</pre>&#13;
			<p>Next, let's look at how we can move the following:</p>&#13;
			<pre>class RegularLegs : Legs {</pre>&#13;
			<pre>    override fun move() = REGULAR_SPEED</pre>&#13;
			<pre>}</pre>&#13;
			<pre>class AthleticLegs : Legs {</pre>&#13;
			<pre>    override fun move() = REGULAR_SPEED * 2</pre>&#13;
			<pre>}</pre>&#13;
			<p>Finally, we need to make sure that we can implement the same functionality without the complex class hierarchy we had before:</p>&#13;
			<pre>val stormTrooper = StormTrooper(Rifle(), RegularLegs())</pre>&#13;
			<pre>val flameTrooper = StormTrooper(Flamethrower(),     RegularLegs())</pre>&#13;
			<pre>val scoutTrooper = StormTrooper(Rifle(), AthleticLegs())</pre>&#13;
			<p>Now we have <a id="_idIndexMarker250"/>a flat class hierarchy, which is much simpler <a id="_idIndexMarker251"/>to extend and also to understand. If we need more functionality, such as the shouting ability we mentioned earlier, we would add a new interface and a new constructor argument for our class.</p>&#13;
			<p>In the real world, this pattern is often used in conjunction with dependency injection frameworks. For example, this would allow us to replace an implementation that used a real database with a mocked interface. This would make our code easier to set up and faster to test.</p>&#13;
			<h1 id="_idParaDest-96"><a id="_idTextAnchor101"/>Composite</h1>&#13;
			<p>This chapter is dedicated to composing objects within one another, so it may look strange to <a id="_idIndexMarker252"/>have a separate section for the <strong class="bold">Composite</strong> design pattern. As a result, this raises a question:</p>&#13;
			<p><em class="italic">Shouldn't this design pattern encompass all of the others?</em></p>&#13;
			<p>As in the case of the Bridge design pattern, the name may not reflect its true uses and benefits.</p>&#13;
			<p>Let's continue with our <code>StormTrooper</code> example from before. Lieutenants of the Empire quickly discover that no matter how well equipped, stormtroopers cannot hold their ground against the rebels because they are uncoordinated.</p>&#13;
			<p>To provide better coordination, the Empire decides to introduce the concept of a <em class="italic">squad</em> for the stormtroopers. A squad should contain one or more stormtrooper of any kind, and when given commands, it should behave exactly as if it was a single unit.</p>&#13;
			<p><code>Squad</code>, clearly, consists of a collection of stormtroopers:</p>&#13;
			<pre>class Squad(val units: List&lt;Trooper&gt;)</pre>&#13;
			<p>Let's add a couple of them to begin with:</p>&#13;
			<pre>val bobaFett = StormTrooper(Rifle(), RegularLegs()) </pre>&#13;
			<pre>val squad = Squad(listOf(bobaFett.copy(), bobaFett.copy(), bobaFett.copy()))</pre>&#13;
			<p>To make our squad act as if it was a single unit, we'll add two methods to it called <code>move</code> and <code>attack</code>:</p>&#13;
			<pre>class Squad(private val units: List&lt;Trooper&gt;) {</pre>&#13;
			<pre>    fun move(x: Long, y: Long) {</pre>&#13;
			<pre>        for (u in units) {</pre>&#13;
			<pre>            u.move(x, y)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    fun attack(x: Long, y: Long) {</pre>&#13;
			<pre>        for (u in units) {</pre>&#13;
			<pre>            u.attackRebel(x, y)</pre>&#13;
			<pre>        }</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Both functions <a id="_idIndexMarker253"/>will repeat any received orders to all of the units they contain. At first, the approach seems to be working. However, what happens if we change our <code>Trooper</code> interface by adding a new function? Consider the following code:</p>&#13;
			<pre>interface Trooper {</pre>&#13;
			<pre>    fun move(x: Long, y: Long)</pre>&#13;
			<pre>    fun attackRebel(x: Long, y: Long)</pre>&#13;
			<pre>    <strong class="bold">fun retreat()</strong></pre>&#13;
			<pre>}</pre>&#13;
			<p>Nothing seems to break, but our <code>Squad</code> class stops doing what it was supposed to do – that is, act as if it was a single unit. A single unit now has a method that our composite class does not.</p>&#13;
			<p>In order to prevent this from happening in the future, let's see what happens if our <code>Squad</code> class implements the same interface as the units it contains:</p>&#13;
			<pre>class Squad(private val units: List&lt;StormTrooper&gt;):  <strong class="bold">Trooper </strong>{ ... }</pre>&#13;
			<p>That change <a id="_idIndexMarker254"/>will force us to implement the <code>retreat</code> function and mark the other two functions with the <code>override</code> keyword:</p>&#13;
			<pre>class Squad(private val units: List&lt;StormTrooper&gt;): Trooper {</pre>&#13;
			<pre>    override fun move(x: Long, y: Long) {</pre>&#13;
			<pre>        ...    </pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun attackRebel(x: Long, y: Long) {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    override fun retreat() {</pre>&#13;
			<pre>        ...</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, we'll take a short detour to discuss an alternative and more convenient approach to this example – one that would allow us to construct the same object but result in a composite that is more pleasant to use.</p>&#13;
			<h2 id="_idParaDest-97"><a id="_idTextAnchor102"/>Secondary constructors</h2>&#13;
			<p>Our code did achieve its goals. However, it would be good if instead of passing a list of stormtroopers <a id="_idIndexMarker255"/>to the constructor (as we do now), we could pass our stormtroopers directly, without wrapping them in a list:</p>&#13;
			<pre>val squad = Squad(bobaFett.copy(), bobaFett.copy(), </pre>&#13;
			<pre>  bobaFett.copy())</pre>&#13;
			<p>One way <a id="_idIndexMarker256"/>to achieve this is to add <code>Squad</code> class.</p>&#13;
			<p>Up until now, we were always using the <em class="italic">primary constructor</em> of the class. That's the constructor declared after the class name. But we can define more than one constructor for a class. We can define secondary constructors for a class using the <code>constructor</code> keyword inside the class body:</p>&#13;
			<pre>class Squad(private val units: List&lt;Trooper&gt;): Trooper {</pre>&#13;
			<pre>    constructor(): this(listOf())</pre>&#13;
			<pre>    constructor(t1: Trooper): this(listOf(t1))</pre>&#13;
			<pre>    constructor(t1: Trooper, t2: Trooper): this(listOf(t1, </pre>&#13;
			<pre>      t2))</pre>&#13;
			<pre>}</pre>&#13;
			<p>Unlike Java, there's no need to repeat the class name for each constructor. That also means fewer changes are required if you decide to rename the class.</p>&#13;
			<p>Note how each secondary constructor must call the primary constructor. This is similar to using the <code>super</code> keyword in Java.</p>&#13;
			<h2 id="_idParaDest-98"><a id="_idTextAnchor103"/>The varargs keyword</h2>&#13;
			<p>This is clearly <a id="_idIndexMarker257"/>not the way to go, since we cannot predict how many more <a id="_idIndexMarker258"/>elements someone might want to pass us. If you come from Java, you have probably thought about <code>Trooper... units</code>.</p>&#13;
			<p>Kotlin provides us with the <code>vararg</code> keyword for the same purpose. By combining a secondary constructor with <code>varargs</code>, we get the following piece of code, which is very nice:</p>&#13;
			<pre>class Squad(private val units: List&lt;Trooper&gt;): Trooper {</pre>&#13;
			<pre>    constructor(vararg units: Trooper): </pre>&#13;
			<pre>        this(units.toList())</pre>&#13;
			<pre>    ...</pre>&#13;
			<pre>}</pre>&#13;
			<p>Now, we are <a id="_idIndexMarker260"/>able to create a squad with any <a id="_idIndexMarker261"/>number of stormtroopers without the need to wrap them in a list first:</p>&#13;
			<pre>val squad = Squad(bobaFett.copy(), bobaFett.copy(), bobaFett.copy())</pre>&#13;
			<p>Let's try to understand how this works under the hood. The Kotlin compiler translates a <code>vararg</code> argument to an <code>Array</code> of the same type:</p>&#13;
			<pre>constructor(units: Array&lt;Trooper&gt;) : this(units.toList())</pre>&#13;
			<p>Arrays in Kotlin have an Adapter method that allows them to be converted to a list of the same type. Interestingly, we can use the Adapter design pattern to help us implement the Composite design pattern.</p>&#13;
			<h2 id="_idParaDest-99"><a id="_idTextAnchor104"/>Nesting composites</h2>&#13;
			<p>The Composite <a id="_idIndexMarker262"/>design pattern has another <a id="_idIndexMarker263"/>interesting property. Previously, we proved that we can create a squad containing multiple stormtroopers. We can also create a squad of squads:</p>&#13;
			<pre>val platoon = Squad(Squad(), Squad())</pre>&#13;
			<p>Now, giving an order to the platoon will work in exactly the same way as giving it to a squad. In fact, this pattern allows us to support a tree-like structure of arbitrary complexity and to perform operations on all of its nodes.</p>&#13;
			<p>The Composite design pattern may seem a bit incomplete until we reach the next chapter, where we <a id="_idIndexMarker264"/>will discover its partner: the <strong class="bold">Iterator</strong> design pattern. When both design patterns <a id="_idIndexMarker265"/>are combined, they really shine. If you <a id="_idIndexMarker266"/>are still unsure how this pattern is useful after completing this section, come back to it after you have also learned about the Iterator design pattern.</p>&#13;
			<p>In the real <a id="_idIndexMarker267"/>world, the Composite design pattern is widely used in <code>Group</code> widget in <code>View</code> interface in order to be able to act on their behalf.</p>&#13;
			<p>As long as all the objects in the hierarchy implement the same interface, no matter how deep the nesting is, we can ask the top-level object to invoke an action on everything beneath it.</p>&#13;
			<h1 id="_idParaDest-100"><a id="_idTextAnchor105"/>Facade</h1>&#13;
			<p>The use of <em class="italic">facade</em> as a term to refer to a design pattern comes directly from building architecture. That is, a facade is the face of a building that is normally made to look more appealing than the rest of it. In programming, <em class="italic">facades</em> can help to hide the ugly details of an implementation. </p>&#13;
			<p>The <strong class="bold">Facade</strong> design pattern <a id="_idIndexMarker268"/>itself aims to provide a nicer, simpler way to work with a family of classes or interfaces. We previously discussed the idea of a <a id="_idIndexMarker269"/>family of classes when covering the <strong class="bold">Abstract Factory</strong> design pattern. The Abstract Factory design pattern focuses on creating related classes, while the Facade design pattern focuses on working with them once they have been created.</p>&#13;
			<p>To better understand this, let's go back to the example we used for the Abstract Factory design pattern. In order to be able to start our server from a configuration using our Abstract Factory, we could provide users of our library with a set of instructions:</p>&#13;
			<ul>&#13;
				<li>Check if the <a id="_idIndexMarker270"/>given file is <code>.json</code> or <code>.yaml</code> by trying to parse it with a <strong class="bold">JSON</strong> parser.</li>&#13;
				<li>If we received an <a id="_idIndexMarker271"/>error, try parsing it using a <strong class="bold">YAML</strong> parser.</li>&#13;
				<li>If there were no errors, pass the results to the Abstract Factory to create the necessary objects.</li>&#13;
			</ul>&#13;
			<p>While helpful, following this set of instructions may require quite a bit of skill and knowledge. Developers may struggle to find the correct parser, or they might ignore any exceptions thrown from a JSON parser in instances where it's dealing with a <code>.yaml</code> file, for example.</p>&#13;
			<p><em class="italic">What problems are our users facing at the moment? </em></p>&#13;
			<p>To load a configuration, they will need to interact with at least three different interfaces:</p>&#13;
			<ul>&#13;
				<li>A JSON parser (covered in the <em class="italic">Abstract Factory </em>section in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>)</li>&#13;
				<li>YAML Parser (covered in the <em class="italic">Abstract Factory </em>section in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>)</li>&#13;
				<li>Server Factory (covered in the <em class="italic">Factory Method </em>section in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>) </li>&#13;
			</ul>&#13;
			<p>Instead, it would be great to have a single function (<code>startFromConfiguration()</code>) that would <a id="_idIndexMarker272"/>take a path to a configuration file, parse it, and then, if there were no errors in the process, start our server.</p>&#13;
			<p>We'll be providing a <em class="italic">facade</em> to our users to simplify working with a set of classes. One way to achieve this goal would be to provide a new class to encapsulate all of this logic for us. This is a common tactic in most languages.</p>&#13;
			<p>However, in Kotlin, we have a better option that uses a technique we already discussed in this chapter when covering the Adapter design pattern. We can make <code>startFromConfiguration()</code> an <em class="italic">extension function</em> on the <code>Server</code> class:</p>&#13;
			<pre>@ExperimentalPathApi</pre>&#13;
			<pre>fun Server.startFromConfiguration(fileLocation: String) {</pre>&#13;
			<pre>    val path = Path(fileLocation)</pre>&#13;
			<pre>    val lines = path.toFile().readLines()</pre>&#13;
			<pre>    val configuration = try {</pre>&#13;
			<pre>        JsonParser().server(lines)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>    catch (e: RuntimeException) {</pre>&#13;
			<pre>        YamlParser().server(lines)</pre>&#13;
			<pre>    }</pre>&#13;
			<pre> </pre>&#13;
			<pre>    Server.withPort(configuration.port)</pre>&#13;
			<pre>}</pre>&#13;
			<p>You can see that this implementation is exactly the same as in the Adapter design pattern. The only difference is the end goal. In the case of the Adapter design pattern, the goal is to <a id="_idIndexMarker273"/>make an otherwise <em class="italic">unusable</em> class <em class="italic">usable</em>. Remember, one of the goals of the Kotlin language is to <em class="italic">reuse</em> as much as possible. For the Façade design pattern, the goal is to make a <em class="italic">complex</em> group of classes <em class="italic">easy to use</em>.</p>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">Depending on when you read this book, you may not need the <code>ExperimentalPathApi</code> annotation anymore. This feature was introduced in Kotlin 1.4, and once it is stable it will be made an integral part of the language.</p>&#13;
			<p>We already discussed that in Kotlin, <code>try</code> is an <em class="italic">expression</em> that returns a <em class="italic">value</em>. Here, you can see that we can also return a value from a <code>catch</code> block, further reducing the need for mutable variables.</p>&#13;
			<p>Next, let's understand <a id="_idIndexMarker274"/>what happens in the first two lines of this function. <code>Path</code> is a rather new API that was introduced in <code>toFile</code> is an example of the Adapter design pattern that converts between a path and an actual file. Finally, the <code>readLine()</code> function will attempt to read the entire file into memory, split line by line. Consider using the Facade design pattern when working with any code base that would benefit from being simplified.</p>&#13;
			<h1 id="_idParaDest-101"><a id="_idTextAnchor106"/>Flyweight</h1>&#13;
			<p><code>data</code> class. But a <code>data</code> class is all about state.</p>&#13;
			<p><em class="italic">So, is the data class related to the Flyweight design pattern at all?</em></p>&#13;
			<p>To understand this design pattern better, we need to jump back in time some twenty years. Back in 1994, when the original <em class="italic">Design Patterns</em> book was published, your regular PC had 4 MB of RAM. During this period, one of the main goals of any process was to save that precious RAM, as you could fit only so much into it.</p>&#13;
			<p>Nowadays, some <em class="italic">cellphones</em> have 8 GB of RAM. Bear that in mind when we discuss what the Flyweight design pattern is all about in this section.</p>&#13;
			<p>Having said that, let's see how we can use our resources more efficiently, as this is always important!</p>&#13;
			<h2 id="_idParaDest-102"><a id="_idTextAnchor107"/>Being conservative</h2>&#13;
			<p>Imagine we're building a 2D side-scrolling arcade platform game. That is, you have your game <a id="_idIndexMarker276"/>character, which you control with arrow keys or a gamepad. Your character can move left, right, and jump.</p>&#13;
			<p>Since we're a really small indie company consisting of one developer (who is also a graphic designer, product manager, and sales representative), two cats, and a canary named Michael, we use only 16 colors in our game. And our character is 64 pixels tall and 64 pixels wide.</p>&#13;
			<p>Our character has a lot of enemies, which consist mostly of carnivorous Tanzanian snails:</p>&#13;
			<pre>class TanzanianSnail</pre>&#13;
			<p>Since it's a 2D game, each snail has only two directions of movement: <code>LEFT</code> and <code>RIGHT</code>. We can represent these directions using an <code>enum</code> class:</p>&#13;
			<pre>enum class Direction {</pre>&#13;
			<pre>   LEFT,</pre>&#13;
			<pre>   RIGHT</pre>&#13;
			<pre>}</pre>&#13;
			<p>To <a id="_idIndexMarker277"/>be able to draw itself on a screen, each snail will hold a pair of images and a direction:</p>&#13;
			<pre>class TansanianSnail {</pre>&#13;
			<pre>    val directionFacing = Direction.LEFT</pre>&#13;
			<pre>    val sprites = listOf(File("snail-left.jpg"), </pre>&#13;
			<pre>                         File("snail-right.jpg"))</pre>&#13;
			<pre>    // More information about the state of a snail comes </pre>&#13;
			<pre>        here</pre>&#13;
			<pre>    // This may include its health, for example</pre>&#13;
			<pre>}</pre>&#13;
			<p class="callout-heading">Important Note:</p>&#13;
			<p class="callout">The definition of the <code>File</code> class comes from <code>java.io.File</code>. Remember that you can always refer to our GitHub project to see the needed imports.</p>&#13;
			<p>Based on the direction, we can get the current sprite that shows us which direction the snail is facing and use this to draw it:</p>&#13;
			<pre>fun getCurrentSprite(): File {</pre>&#13;
			<pre>    return when (directionFacing) {</pre>&#13;
			<pre>        Direction.LEFT -&gt; sprites[0]</pre>&#13;
			<pre>        Direction.RIGHT -&gt; sprites[1]</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>When any of the enemies move, they basically just slide left or right.</p>&#13;
			<p>What <a id="_idIndexMarker278"/>we would like is to have multiple animated sprites to reproduce the snail's movements in each direction. We can generate a list of such sprites for each snail enemy using a <code>List</code> generator:</p>&#13;
			<pre>class Ta<a id="_idTextAnchor108"/>nsanianSnail {</pre>&#13;
			<pre>    val directionFacing = Direction.LEFT</pre>&#13;
			<pre>    val sprites = List(8) { i -&gt;</pre>&#13;
			<pre>        File(when(i) {</pre>&#13;
			<pre>            0 -&gt; "snail-left.jpg"</pre>&#13;
			<pre>            1 -&gt; "snail-right.jpg"</pre>&#13;
			<pre>            in 2..4 -&gt; "snail-move-left-${i-1}.jpg"</pre>&#13;
			<pre>            else -&gt; "snail-move-right${(4-i)}.jpg"</pre>&#13;
			<pre>        })</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Here, we initialize a list of eight elements, passing a <code>block</code> function as a constructor. The benefit of this approach is that we can apply complex logic during the creation of a collection while still keeping it effectively immutable.</p>&#13;
			<p>For each element, we decide what image to get:</p>&#13;
			<ul>&#13;
				<li>Positions <code>0</code> and <code>1</code> are for still images, facing left and right.</li>&#13;
				<li>Positions <code>2</code> through <code>4</code> are for moving left.</li>&#13;
				<li>Positions <code>5</code> through <code>7</code> are for moving right.</li>&#13;
			</ul>&#13;
			<p>Let's do some math now. Each snail is represented by a 64 x 64 image. Assuming each color takes up exactly one byte, the single images will take up 4 KB of RAM in the memory. Since we have eight images for a snail, we need 32 KB of RAM for each one, which <a id="_idIndexMarker279"/>allows us to fit only 32 snails into 1 MB of memory.</p>&#13;
			<p>Since we want to have thousands of these dangerous and extremely fast creatures on screen and to be able to run our game on a 10-year-old phone, we clearly need a better solution.</p>&#13;
			<h2 id="_idParaDest-103"><a id="_idTextAnchor109"/>Saving memory</h2>&#13;
			<p><em class="italic">What's the problem we have with all of our snails?</em></p>&#13;
			<p>They're <a id="_idIndexMarker280"/>actually quite fat, heavyweight snails. We would like to put them on a diet. Each snail stores eight images within its <em class="italic">snaily</em> body. But these images are actually the same for each snail. This raises a question:</p>&#13;
			<p><em class="italic">What if we extract those sprites into a Singleton object or a Factory Method and then only reference them from each instance?</em></p>&#13;
			<p>For example, consider the following code:</p>&#13;
			<pre>object SnailSprites {</pre>&#13;
			<pre>    val sprites = List(8) { i -&gt;</pre>&#13;
			<pre>        java.io.File(when (i) {</pre>&#13;
			<pre>            0 -&gt; "snail-left.jpg"</pre>&#13;
			<pre>            1 -&gt; "snail-right.jpg"</pre>&#13;
			<pre>            in 2..4 -&gt; "snail-move-left-${i-1}.jpg"</pre>&#13;
			<pre>            else -&gt; "snail-move-right${(4-i)}.jpg"</pre>&#13;
			<pre>        })</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<pre>class TansanianSnail() {</pre>&#13;
			<pre>    val directionFacing = Direction.LEFT</pre>&#13;
			<pre>    val sprites = SnailSprites.sprites</pre>&#13;
			<pre>}</pre>&#13;
			<p>This way, our <code>getCurrentSprite</code> function could stay the same, and we'll only consume 256 KB of memory, no matter how many snails we generate. We could generate millions of them without affecting the footprint of our program.</p>&#13;
			<p>And this <a id="_idIndexMarker281"/>is exactly the idea behind the Flyweight design pattern. That is, limit the number of heavyweight objects (in our case, the image files) by sharing them between the lightweight objects (in our case, the snails).</p>&#13;
			<h2 id="_idParaDest-104"><a id="_idTextAnchor110"/>Caveats of the Flyweight design pattern</h2>&#13;
			<p>We should take extra care about the immutability of the data we pass. If, for example, we used <code>var</code> instead of <code>val</code> in our Singleton, it could be disastrous for our code. The same <a id="_idIndexMarker282"/>goes for mutable data structures. We wouldn't want someone removing an image, replacing it, or clearing the list of images altogether.</p>&#13;
			<p>Luckily, Kotlin makes handling these cases rather easy. Just make sure to always use values instead of variables in your extrinsic state, and remember to use immutable data structures, which cannot be altered after they have been created.</p>&#13;
			<p>You can debate the usefulness of this pattern in this era of plentiful memory. However, as we have already said, the tools in the toolbox don't take up much space, and having another design pattern under your belt may still prove useful.</p>&#13;
			<h1 id="_idParaDest-105"><a id="_idTextAnchor111"/>Proxy</h1>&#13;
			<p>Much like <a id="_idIndexMarker283"/>the Decorator design pattern, the <strong class="bold">Proxy</strong> design pattern extends an object's functionality. However, unlike a decorator, which always does what it's told, having a proxy may mean that when asked to do something, the object does something totally different.</p>&#13;
			<p>When we discussed <strong class="bold">Creational Patterns</strong> in <a href="B17816_02_ePub.xhtml#_idTextAnchor062"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Creational Patterns</em>, we already <a id="_idIndexMarker284"/>touched on the idea of <em class="italic">expensive</em> objects. For example, an object that accesses network resources or takes a lot of time to create.</p>&#13;
			<p>We at the <em class="italic">Funny Cat App</em> provide our users with funny cat images on a daily basis. On our homepage and mobile application, each user sees a lot of pictures of funny cats. When they click or touch any of those images, it expands to its full-screen glory. </p>&#13;
			<p>Fetching cat images over the network is very expensive, and it consumes a lot of memory, especially if those are images of cats that tend to indulge in a second dessert after dinner. What we want to do is fetch the full-sized image only once at the time it is requested. And if it is requested multiple times, we want to be able to show it to family or friends. In short, we don't want to have to fetch it every time.</p>&#13;
			<p>There's no <a id="_idIndexMarker285"/>way to avoid loading the image once. But when it's being accessed for the second time, we would like to avoid going over the network again and instead return the result that was cached in memory. That's the idea of the <strong class="bold">Proxy</strong> design pattern; instead of the expected behavior of going over the network each time, we're being a bit lazy and returning the result that we already prepared. </p>&#13;
			<p>It's a bit like going into a cheap diner, ordering a hamburger, and getting it after only two minutes, but cold. Well, that's because someone else hated onions and returned it to the kitchen a while ago. True story.</p>&#13;
			<p>This sounds like it would require a lot of logic. But as you've probably guessed (especially after meeting the Decorator design pattern), Kotlin can perform miracles by reducing the amount of boilerplate code you need to write to achieve your goals:</p>&#13;
			<pre>data class CatImage(val thumbnailUrl: String,</pre>&#13;
			<pre>        val url: String) {</pre>&#13;
			<pre>    val image: ByteArray <strong class="bold">by lazy</strong> {</pre>&#13;
			<pre>        // Read image as bytes</pre>&#13;
			<pre>        URL(url).readBytes()</pre>&#13;
			<pre>    }</pre>&#13;
			<pre>}</pre>&#13;
			<p>Previously, we've seen the <code>by</code> keyword in a different context – that is, when delegating the implementation of an interface to another class (as discussed in <em class="italic">The Decorator design pattern</em> section of this chapter).</p>&#13;
			<p>As you may have noticed, in this case, we use the <code>by</code> keyword to delegate the initialization of a <a id="_idIndexMarker286"/>field to happen later. We use a function called <code>lazy</code>, which is <a id="_idIndexMarker287"/>one of the <code>image</code> property, it will execute our code block and save its results into the <code>image</code> property. The following invocations of that property will simply return its value.</p>&#13;
			<p>Sometimes, the Proxy design pattern is divided into three sub-patterns:</p>&#13;
			<ul>&#13;
				<li><strong class="bold">Virtual proxy</strong>: Lazily <a id="_idIndexMarker288"/>caches the result</li>&#13;
				<li><strong class="bold">Remote proxy</strong>: Issues <a id="_idIndexMarker289"/>a call to the remote resource</li>&#13;
				<li><strong class="bold">Protection or access control proxy</strong>: Denies <a id="_idIndexMarker290"/>access to unauthorized parties</li>&#13;
			</ul>&#13;
			<p>You can regard our previous example as either a virtual proxy or a combination of the virtual and remote types of proxies.</p>&#13;
			<h2 id="_idParaDest-106"><a id="_idTextAnchor112"/>Lazy delegation</h2>&#13;
			<p>You may wonder what happens if two threads try to initialize the image at the same time. By default, the <code>lazy()</code> function is synchronized. Only one thread will win, and others will <a id="_idIndexMarker291"/>wait until the image is ready.</p>&#13;
			<p>If you don't <a id="_idIndexMarker292"/>mind two threads executing the lazy block (for example, if it's not that expensive), you can use <code>lazy(LazyThreadSafetyMode.PUBLICATION)</code> instead.</p>&#13;
			<p>If performance is absolutely critical for you and you're absolutely sure that two threads won't ever execute the same block simultaneously, you can use <code>LazyThreadSafetyMode.NONE</code>, which is not thread-safe.</p>&#13;
			<p>Proxying and delegation is a very useful approach for many complex problems, and we'll explore this in the following chapters.</p>&#13;
			<h1 id="_idParaDest-107"><a id="_idTextAnchor113"/>Summary</h1>&#13;
			<p>In this chapter, we have learned how structural design patterns can help us to create more flexible code that can adapt to changes with ease, sometimes even at runtime. We've covered how we can add functionality to an existing class with the Decorator design pattern, and we've explored how <em class="italic">operator overloading</em> can allow us to provide more intuitive syntax to common operations.</p>&#13;
			<p>We then learned how to adapt one interface to another interface using extension methods, and we also learned how to create anonymous objects to implement an interface only once. Next, we discussed how to simplify class hierarchies using the Bridge design pattern. You should now know how to create a shortcut for a type name with <code>typealias</code> and also how to define efficient constants with <code>const</code>.</p>&#13;
			<p>Moving on, we looked at the Composite design pattern, and we considered how it could help you to design a system that needs to treat groups of objects and regular objects in the same way. We also learned about secondary constructors and how a function can receive an <em class="italic">arbitrary number of arguments</em> when using the <code>vararg</code> keyword. We learned how the Facade design pattern helps us to simplify working with complex systems by exposing a simple interface, while the Flyweight design pattern allows us to reduce the memory footprint of our application.</p>&#13;
			<p>Finally, we've covered how delegating to another class works in Kotlin, implementing the same interface and using the <code>by</code> keyword in the Proxy design pattern and demonstrating its use with a <code>lazy</code> delegate. With these design patterns, you should be able to structure your system in a much more extensible and maintainable manner.</p>&#13;
			<p>In the next chapter, we'll discuss the third family of classic design patterns: behavioral patterns.</p>&#13;
			<h1 id="_idParaDest-108"><a id="_idTextAnchor114"/>Questions</h1>&#13;
			<ol>&#13;
				<li>What differences are there between the implementations of the Decorator and Proxy design patterns?</li>&#13;
				<li>What is the main goal of the Flyweight design pattern?</li>&#13;
				<li>What is the difference between the Facade and Adapter design patterns?</li>&#13;
			</ol>&#13;
		</div>&#13;
	</div></body></html>