- en: Getting Started with Arrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arrow** ([http://arrow-kt.io/](http://arrow-kt.io/)) is a Kotlin library
    that provides functional constructs, datatypes, and other abstractions. Kotlin
    syntax is powerful and flexible, and Arrow takes advantage of it to offer features
    that don''t come as standard.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow is the result of combining the two most successful and popular functional
    libraries, `funKTionale` and `Kategory`, into one. In late 2017, both developer
    groups, fearing a split that would damage the whole Kotlin community, decided
    to join forces and create a single, unified functional library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover how to use existing functions to build new and
    richer functions. Some of the topics that we''ll cover are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One big part of functional programming as a concept is to use functions in the
    same way that we use any other type—as values, parameters, returns, and so on.
    One thing that we can do with other types is to take them as construction blocks
    to build other types; the same concept can be applied to functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition is a technique to build functions using existing functions;
    similar to Unix pipes or channel pipelines, the result value of a function is
    used as a parameter for the next one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Arrow, function composition comes as a set of the `infix` extension functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `compose` | Takes the result of invoking the right-hand function as the parameter
    for the left-hand function. |'
  prefs: []
  type: TYPE_TB
- en: '| `forwardCompose` | Takes the result of invoking the left-hand function as
    the parameter for the right-hand function. |'
  prefs: []
  type: TYPE_TB
- en: '| `andThen` | Is an alias for `forwardCompose`. |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s compose some functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the `divStrong: (String) -> String` function, we compose `div:(String)
    -> String` and `strong:(String) -> String`. In other words, `divStrong` is equivalent
    to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For `spanP:(String) -> String`, we compose `span:(String) -> (String)` and
    `p:(String) -> String` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using the same type `(String) -> String`, but any function
    can be composed if it has the right return type that the other functions need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite our `Channel` pipeline example with function composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `salesSystem: (Quote) -> Unit` function is very complex in its behavior,
    but was built using other functions as building blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: Partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With function composition, we take two functions to create the third function;
    with partial application, we create a new function by passing a parameter to an
    existing function.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow comes with two flavours of partial application—explicit and implicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The explicit style uses a series of extension functions called `partially1`,
    `partially2`, all the way up to `partially22`. The implicit style takes a series
    of extensions, overloading the `invoke` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both styles can be chained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our original `splitter` function was not very flexible as it directly invoked
    warehouse and accounting functions. The `partialSplitter` function resolves this
    problem by taking `warehouse` and `accounting` as parameters; however a `(Pair<Bill,
    PickingOrder>?, (PickingOrder) -> Unit, (Bill) -> Unit)` function can't be used
    in composition. Then, we partially apply two functions—a lambda and a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A special case of partial application is **binding**. With binding, you pass
    a `T` parameter to the `(T) -> R` function but without executing it, effectively
    returning an `() -> R` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The function bind is just an alias for `partially1`, but it makes sense to have
    a separate name for it and make it more semantically correct.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reverse** takes any function and returns it with its parameter in the reverse
    order (in other languages, this function is known as **flip**). Let''s look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our `redStrong` function is awkward to use, as we'll expect to have `id` first
    and then `body`, but, is easily fixable with the `reverse` extension function.
    The `reverse` function can be applied to functions from parameters `1` to `22`.
  prefs: []
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `pipe` function takes a `T` value and invokes a `(T) -> R` function with
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A **pipe** is similar to function composition, but instead of generating new
    functions, we can chain function invocations to produce new values, reducing nesting
    calls. Pipes are known in other languages, such as **Elm** and **Ocaml**, as the
    operator `|>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Both lines are equivalent, but the first one must be understood backwards and
    the second one should read from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When `pipe` is applied to a multi-parameter function, using its variants `pipe2`
    to `pipe22`, it behaves as `partially1`.
  prefs: []
  type: TYPE_NORMAL
- en: Currying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying curried to a function of *n* parameters, for example, `(A, B) -> R`,
    transforms it into a chain of the `n` function calls, `(A) -> (B) -> R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Functions on curried forms can be transformed into a normal, multi-parameter
    form with `uncurried()`.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between the currying and partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is some confusion between currying and partial application. Some authors
    treat them as synonymous, but they are different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The differences are significant and they can help us to decide when to use
    one or the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Currying** | **Partial application** |'
  prefs: []
  type: TYPE_TB
- en: '| **Return value** | When a function of arity *N* gets curried, it returns
    a chain of functions of *N* size, (curried form). | When a function or arity *N*
    gets partially applied, it returns a function of arity *N - 1*. |'
  prefs: []
  type: TYPE_TB
- en: '| **Parameter application** | After curried, only the first parameter of the
    chain can be applied. | Any parameter can be applied in any order. |'
  prefs: []
  type: TYPE_TB
- en: '| **Reverting** | It is possible to take a function on the curried form and
    revert it to a multi-parameter function. | As partial application doesn''t change
    the function form, reverting is not applicable. |'
  prefs: []
  type: TYPE_TB
- en: Partial application can be more flexible, but some functional styles tend to
    favor currying. The important thing to grasp is that both styles are different
    and both are supported by Arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Logical complement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **logical complement** takes any predicate (a function with a return `Boolean` type)
    and negates it. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use a `Predicate<T>` type, but it is just an alias for `(T) ->
    Boolean`. There are complement extension functions for predicates from `0` to
    `22` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Memoization** is a technique to cache results of pure functions. A memoized
    function behaves as a normal function, but stores the result of previous computations
    associated with the parameters supplied to produce that result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic example of memoization is Fibonacci:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our memoized version is more than 700 times faster than a recursive function
    version (which is almost four times faster than the lambda version). The imperative
    version is unbeatable, as it is heavily optimized by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Memoized functions, internally, use a thread-safe structure to store their results,
    and are therefore safe to use on coroutines or any other concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: There are potential downsides of using memoized functions. The first is that
    the process of reading the internal cache is higher than the actual computation
    or memory consumption, as right now, memoized functions don't expose any behavior
    to control their internal storage.
  prefs: []
  type: TYPE_NORMAL
- en: Partial functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **partial function** (not to be confused with partial applied function) is
    a function that is not defined for every possible value of its parameter type.
    In contrast, a **total function** is a function that is defined for every possible
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `upper` function is a partial function; it can't process a null value despite
    the fact that `null` is a valid `String?` value. If you try to run this code,
    it will throw a `NullPointerException` (**NPE**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrow provides an explicit type `PartialFunction<T, R>` for partial functions
    of type `(T) -> R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`PartialFunction<T, R>` receives a predicate `(T) -> Boolean` as the first
    parameter which must return  `true` if the function is defined for that particular
    value. A `PartialFunction<T, R>` function extends from `(T) -> R`, therefore it
    can be used as a normal function.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the code still throws an exception but now of type `IllegalArgumentException`
    (**IAE**), with an informative message.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid getting exceptions, we must transform our partial function into a
    total one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One option is to use the `invokeOrElse` function that returns a default value
    in case the value `s` isn''t defined for this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option is to create a total function using several partial functions
    with the function `orElse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Through the `isDefinedAt(T)` function we can reuse the internal predicate, in
    this case, to build the condition for `fizzBuzz`. When used in a chain of `orElse`,
    the declaration order takes precedence, the first partial function that is defined
    for a value will be executed, and the other functions down the chain will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Identity and constant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identity and constant are straightforward functions. The `identity` function
    returns the same value provided as parameter; similar to additive and multiplicative
    identity property, adding 0 to any number is still the same number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `constant<T, R>(t: T)` function returns a new function that will always
    return the `t` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite our `fizzBuzz` value using `constant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Identity and constant functions are useful in functional programming or in implementations
    of math algorithms, for example, constant is K in SKI combinator calculus.
  prefs: []
  type: TYPE_NORMAL
- en: Optics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Optics** are abstractions to update immutable data structures elegantly.
    One form of optics is `Lens` (or lenses, depending on the library implementation).
    A `Lens` is a functional reference that can focus (hence the name) into a structure
    and read, write, or modify its target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To create a new `Laptop` value from an existing one, we need to use several
    nested copy methods and references. In this example, it isn't as bad but you can
    imagine that in a more complex data structure, things can overgrow into madness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write our very first `Lens` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `laptopPrice` value is a `Lens<Laptop, Double>` that we initialize using
    the function `Lens<S, T, A, B>` (actually `Lens.invoke`). `Lens` takes two functions
    as parameters, as `get: (S) -> A` and `set: (B) -> (S) -> T`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `set` is a curried function so that you can write your set
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Which, depending on your preferences, can be easier to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have your first lens, it can be used to set, read, and modify
    a laptop''s price. Not too impressive, but the magic of lenses is combining them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We created `laptopMemorySize` combining lenses from `Laptop` all the way to
    `memorySize`; then, we can set laptop's price and modify its memory.
  prefs: []
  type: TYPE_NORMAL
- en: Despite how cool lenses are, it looks like a lot of boilerplate code. Fear not,
    Arrow can generate those lenses for you.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Arrows code generation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a Gradle project, add a file called `generated-kotlin-sources.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `build.gradle` file, add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new dependency in the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once configured, you can generate Arrow code with a normal build command, `./gradlew
    build`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating lenses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once Arrow''s code generation is configured, you can add the `@lenses` annotation
    to the data classes that you want to have lenses generated for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Arrow generates as many lenses as constructor parameters our data classes have,
    with the name convention `classProperty` and in the same package, so no extra
    imports are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many features of Arrow that give us tools to create,
    generate, and enrich existing functions. We composed new functions using existing
    ones; we included partial application and currying. We also cached results of
    pure functions with memoization and modified data structures using lenses.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow's features open up the possibility of creating rich and maintainable applications,
    using basic functional principles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll cover more Arrow features, including datatypes such
    as `Option`, `Either`, and `Try`.
  prefs: []
  type: TYPE_NORMAL
