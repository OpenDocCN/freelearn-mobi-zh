- en: Getting Started with Arrow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Arrow
- en: '**Arrow** ([http://arrow-kt.io/](http://arrow-kt.io/)) is a Kotlin library
    that provides functional constructs, datatypes, and other abstractions. Kotlin
    syntax is powerful and flexible, and Arrow takes advantage of it to offer features
    that don''t come as standard.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arrow** ([http://arrow-kt.io/](http://arrow-kt.io/)) 是一个 Kotlin 库，它提供了函数式构造、数据类型和其他抽象。Kotlin
    语法强大且灵活，Arrow 利用这一点提供了一些标准中不包含的功能。'
- en: Arrow is the result of combining the two most successful and popular functional
    libraries, `funKTionale` and `Kategory`, into one. In late 2017, both developer
    groups, fearing a split that would damage the whole Kotlin community, decided
    to join forces and create a single, unified functional library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 是将两个最成功和最受欢迎的函数式库 `funKTionale` 和 `Kategory` 结合成一个的结果。在 2017 年晚些时候，两个开发者团队担心分裂会损害整个
    Kotlin 社区，因此决定联合起来创建一个单一、统一的函数式库。
- en: 'In this chapter, we''ll cover how to use existing functions to build new and
    richer functions. Some of the topics that we''ll cover are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用现有函数构建新的和更丰富的函数。我们将涵盖的一些主题包括以下内容：
- en: Function composition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Partial application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分应用
- en: Currying
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 柯里化
- en: Memoization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Pipes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Optics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光学
- en: Function composition
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: One big part of functional programming as a concept is to use functions in the
    same way that we use any other type—as values, parameters, returns, and so on.
    One thing that we can do with other types is to take them as construction blocks
    to build other types; the same concept can be applied to functions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程作为一个概念的一个重要部分是，以我们使用任何其他类型的方式使用函数——作为值、参数、返回值等。我们可以用其他类型做的一件事是将它们作为构建其他类型的构建块；同样的概念也可以应用于函数。
- en: Function composition is a technique to build functions using existing functions;
    similar to Unix pipes or channel pipelines, the result value of a function is
    used as a parameter for the next one.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是一种使用现有函数构建函数的技术；类似于 Unix 管道或通道管道，函数的结果值被用作下一个函数的参数。
- en: 'In Arrow, function composition comes as a set of the `infix` extension functions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arrow 中，函数组合以一系列的 `infix` 扩展函数的形式出现：
- en: '| **Function** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `compose` | Takes the result of invoking the right-hand function as the parameter
    for the left-hand function. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `compose` | 将右手函数调用的结果作为左手函数的参数。|'
- en: '| `forwardCompose` | Takes the result of invoking the left-hand function as
    the parameter for the right-hand function. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `forwardCompose` | 将左手函数调用的结果作为右手函数的参数。|'
- en: '| `andThen` | Is an alias for `forwardCompose`. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `andThen` | 是 `forwardCompose` 的别名。|'
- en: 'Let''s compose some functions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们组合一些函数：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To build the `divStrong: (String) -> String` function, we compose `div:(String)
    -> String` and `strong:(String) -> String`. In other words, `divStrong` is equivalent
    to the following code snippet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '要构建 `divStrong: (String) -> String` 函数，我们组合 `div:(String) -> String` 和 `strong:(String)
    -> String`。换句话说，`divStrong` 等同于以下代码片段：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For `spanP:(String) -> String`, we compose `span:(String) -> (String)` and
    `p:(String) -> String` as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `spanP:(String) -> String`，我们按照以下方式组合 `span:(String) -> (String)` 和 `p:(String)
    -> String`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that we are using the same type `(String) -> String`, but any function
    can be composed if it has the right return type that the other functions need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的是相同的类型 `(String) -> String`，但任何具有其他函数所需正确返回类型的函数都可以进行组合。
- en: 'Let''s rewrite our `Channel` pipeline example with function composition:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用函数组合重写我们的 `Channel` 管道示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `salesSystem: (Quote) -> Unit` function is very complex in its behavior,
    but was built using other functions as building blocks.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`salesSystem: (Quote) -> Unit` 函数的行为非常复杂，但它是由其他函数作为构建块构建的。'
- en: Partial application
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: With function composition, we take two functions to create the third function;
    with partial application, we create a new function by passing a parameter to an
    existing function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数组合，我们通过取两个函数来创建第三个函数；使用部分应用，我们通过向现有函数传递参数来创建一个新的函数。
- en: Arrow comes with two flavours of partial application—explicit and implicit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 提供了两种部分应用风格——显式和隐式。
- en: 'The explicit style uses a series of extension functions called `partially1`,
    `partially2`, all the way up to `partially22`. The implicit style takes a series
    of extensions, overloading the `invoke` operator:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显式风格使用一系列称为 `partially1`、`partially2`，一直到 `partially22` 的扩展函数。隐式风格通过一系列扩展，重载了
    `invoke` 操作符：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Both styles can be chained as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 两种风格都可以按以下方式链式使用：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our original `splitter` function was not very flexible as it directly invoked
    warehouse and accounting functions. The `partialSplitter` function resolves this
    problem by taking `warehouse` and `accounting` as parameters; however a `(Pair<Bill,
    PickingOrder>?, (PickingOrder) -> Unit, (Bill) -> Unit)` function can't be used
    in composition. Then, we partially apply two functions—a lambda and a reference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的 `splitter` 函数不够灵活，因为它直接调用了仓库和会计函数。`partialSplitter` 函数通过将 `warehouse`
    和 `accounting` 作为参数来解决这个问题；然而，一个 `(Pair<Bill, PickingOrder>?, (PickingOrder) ->
    Unit, (Bill) -> Unit)` 函数不能用于组合。然后，我们部分应用了两个函数——一个 lambda 和一个引用。
- en: Binding
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定
- en: 'A special case of partial application is **binding**. With binding, you pass
    a `T` parameter to the `(T) -> R` function but without executing it, effectively
    returning an `() -> R` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的一个特殊情况是 **绑定**。使用绑定时，你向 `(T) -> R` 函数传递一个 `T` 参数，但不执行它，实际上返回一个 `() -> R`
    函数：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The function bind is just an alias for `partially1`, but it makes sense to have
    a separate name for it and make it more semantically correct.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind` 函数只是 `partially1` 的别名，但给它一个单独的名字并使其语义更加正确是有意义的。'
- en: Reverse
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反转
- en: '**Reverse** takes any function and returns it with its parameter in the reverse
    order (in other languages, this function is known as **flip**). Let''s look at
    the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**反转**接受任何函数并返回其参数顺序相反的函数（在其他语言中，此函数被称为 **flip**）。让我们看看以下代码：'
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `redStrong` function is awkward to use, as we'll expect to have `id` first
    and then `body`, but, is easily fixable with the `reverse` extension function.
    The `reverse` function can be applied to functions from parameters `1` to `22`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `redStrong` 函数使用起来有些笨拙，因为我们期望首先有 `id` 然后有 `body`，但可以通过 `reverse` 扩展函数轻松修复。`reverse`
    函数可以应用于从参数 `1` 到 `22` 的函数。
- en: Pipes
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: 'A `pipe` function takes a `T` value and invokes a `(T) -> R` function with
    it:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe` 函数接受一个 `T` 值并使用它调用 `(T) -> R` 函数：'
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A **pipe** is similar to function composition, but instead of generating new
    functions, we can chain function invocations to produce new values, reducing nesting
    calls. Pipes are known in other languages, such as **Elm** and **Ocaml**, as the
    operator `|>`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道**类似于函数组合，但不同之处在于我们不是生成新函数，而是可以链式调用函数以产生新的值，从而减少嵌套调用。管道在其他语言中，如 **Elm**
    和 **Ocaml** 中，被称为操作符 `|>`：'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Both lines are equivalent, but the first one must be understood backwards and
    the second one should read from left to right:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 两行是等价的，但第一行必须从后往前理解，第二行应该从左到右阅读：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When `pipe` is applied to a multi-parameter function, using its variants `pipe2`
    to `pipe22`, it behaves as `partially1`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `pipe` 应用于多参数函数时，使用其变体 `pipe2` 到 `pipe22`，它表现得像 `partially1`。
- en: Currying
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Applying curried to a function of *n* parameters, for example, `(A, B) -> R`,
    transforms it into a chain of the `n` function calls, `(A) -> (B) -> R`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将柯里化应用于具有 *n* 个参数的函数，例如 `(A, B) -> R`，将其转换为 `n` 个函数调用的链，`(A) -> (B) -> R`：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Functions on curried forms can be transformed into a normal, multi-parameter
    form with `uncurried()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化形式的函数可以通过 `uncurried()` 转换为正常的多参数形式。
- en: Differences between the currying and partial application
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化和部分应用之间的区别
- en: 'There is some confusion between currying and partial application. Some authors
    treat them as synonymous, but they are different:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在柯里化和部分应用之间存在一些混淆。一些作者将它们视为同义词，但它们是不同的：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The differences are significant and they can help us to decide when to use
    one or the other:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区别是显著的，并且可以帮助我们决定何时使用其中一个：
- en: '|  | **Currying** | **Partial application** |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | **柯里化** | **部分应用** |'
- en: '| **Return value** | When a function of arity *N* gets curried, it returns
    a chain of functions of *N* size, (curried form). | When a function or arity *N*
    gets partially applied, it returns a function of arity *N - 1*. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **返回值** | 当一个 *N* 元函数被柯里化时，它返回一个大小为 *N* 的函数链，(柯里化形式)。 | 当一个函数或 *N* 元函数被部分应用时，它返回一个
    *N - 1* 元函数。 |'
- en: '| **Parameter application** | After curried, only the first parameter of the
    chain can be applied. | Any parameter can be applied in any order. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **参数应用** | 柯里化后，只有链的第一个参数可以被应用。 | 任何参数都可以以任何顺序应用。 |'
- en: '| **Reverting** | It is possible to take a function on the curried form and
    revert it to a multi-parameter function. | As partial application doesn''t change
    the function form, reverting is not applicable. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **还原** | 可以将柯里化形式的函数还原为多参数函数。 | 由于部分应用不会改变函数形式，因此还原不适用。 |'
- en: Partial application can be more flexible, but some functional styles tend to
    favor currying. The important thing to grasp is that both styles are different
    and both are supported by Arrow.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用可以更加灵活，但一些函数式风格倾向于偏好柯里化。重要的是要掌握的是，这两种风格都是不同的，并且都由 Arrow 支持。
- en: Logical complement
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑补码
- en: 'A **logical complement** takes any predicate (a function with a return `Boolean` type)
    and negates it. Let''s look at the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑补码**接受任何谓词（一个返回 `Boolean` 类型的函数）并将其否定。让我们看看以下代码：'
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that we use a `Predicate<T>` type, but it is just an alias for `(T) ->
    Boolean`. There are complement extension functions for predicates from `0` to
    `22` parameters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的是 `Predicate<T>` 类型，但它只是 `(T) -> Boolean` 的别名。从 `0` 到 `22` 参数的谓词都有补充扩展函数。
- en: Memoization
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: '**Memoization** is a technique to cache results of pure functions. A memoized
    function behaves as a normal function, but stores the result of previous computations
    associated with the parameters supplied to produce that result.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存**是一种缓存纯函数结果的技巧。缓存函数的行为像一个普通函数，但它存储了与产生该结果提供的参数相关联的先前计算的结果。'
- en: 'The classic example of memoization is Fibonacci:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存化的经典例子是斐波那契数列：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our memoized version is more than 700 times faster than a recursive function
    version (which is almost four times faster than the lambda version). The imperative
    version is unbeatable, as it is heavily optimized by the compiler:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们缓存版本的执行速度比递归函数版本快700多倍（后者几乎比 lambda 版本快四倍）。命令式版本是无敌的，因为它被编译器高度优化：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Memoized functions, internally, use a thread-safe structure to store their results,
    and are therefore safe to use on coroutines or any other concurrent code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存函数内部使用线程安全的结构来存储其结果，因此可以在协程或任何其他并发代码上安全使用。
- en: There are potential downsides of using memoized functions. The first is that
    the process of reading the internal cache is higher than the actual computation
    or memory consumption, as right now, memoized functions don't expose any behavior
    to control their internal storage.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓存函数存在潜在缺点。第一个缺点是读取内部缓存的进程比实际计算或内存消耗要高，因为目前，缓存函数不暴露任何行为来控制其内部存储。
- en: Partial functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分函数
- en: A **partial function** (not to be confused with partial applied function) is
    a function that is not defined for every possible value of its parameter type.
    In contrast, a **total function** is a function that is defined for every possible
    value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**部分函数**（不要与部分应用函数混淆）是一个对于其参数类型的每个可能值不一定有定义的函数。相比之下，**总函数**是对于其参数类型的每个可能值都有定义的函数。'
- en: 'Let''s have a look at the following example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `upper` function is a partial function; it can't process a null value despite
    the fact that `null` is a valid `String?` value. If you try to run this code,
    it will throw a `NullPointerException` (**NPE**).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper` 函数是一个部分函数；尽管 `null` 是一个有效的 `String?` 值，但它不能处理 `null` 值。如果你尝试运行此代码，它将抛出
    `NullPointerException`（**NPE**）。'
- en: 'Arrow provides an explicit type `PartialFunction<T, R>` for partial functions
    of type `(T) -> R`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 为类型 `(T) -> R` 的部分函数提供了一个显式类型 `PartialFunction<T, R>`：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`PartialFunction<T, R>` receives a predicate `(T) -> Boolean` as the first
    parameter which must return  `true` if the function is defined for that particular
    value. A `PartialFunction<T, R>` function extends from `(T) -> R`, therefore it
    can be used as a normal function.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`PartialFunction<T, R>` 接收一个谓词 `(T) -> Boolean` 作为第一个参数，该参数必须返回 `true`，如果函数对该特定值有定义。`PartialFunction<T,
    R>` 函数扩展自 `(T) -> R`，因此它可以作为一个普通函数使用。'
- en: In this example, the code still throws an exception but now of type `IllegalArgumentException`
    (**IAE**), with an informative message.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，代码仍然抛出异常，但现在类型为 `IllegalArgumentException`（**IAE**），并带有有用的消息。
- en: 'To avoid getting exceptions, we must transform our partial function into a
    total one:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免抛出异常，我们必须将我们的部分函数转换为总函数：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'One option is to use the `invokeOrElse` function that returns a default value
    in case the value `s` isn''t defined for this function:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用 `invokeOrElse` 函数，在值 `s` 对此函数未定义时返回默认值：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second option is to create a total function using several partial functions
    with the function `orElse`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择是使用 `orElse` 函数创建一个总函数，该函数由几个部分函数组成：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Through the `isDefinedAt(T)` function we can reuse the internal predicate, in
    this case, to build the condition for `fizzBuzz`. When used in a chain of `orElse`,
    the declaration order takes precedence, the first partial function that is defined
    for a value will be executed, and the other functions down the chain will be ignored.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`isDefinedAt(T)`函数，我们可以重用内部谓词，在这种情况下，用于构建`fizzBuzz`的条件。当在`orElse`链中使用时，声明顺序具有优先权，首先为某个值定义的部分函数将被执行，而链中的其他函数将被忽略。
- en: Identity and constant
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份和常量
- en: Identity and constant are straightforward functions. The `identity` function
    returns the same value provided as parameter; similar to additive and multiplicative
    identity property, adding 0 to any number is still the same number.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 身份和常量是简单的函数。`identity`函数返回提供的参数值；类似于加法和乘法恒等性质，将0加到任何数上仍然是同一个数。
- en: 'The `constant<T, R>(t: T)` function returns a new function that will always
    return the `t` value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`constant<T, R>(t: T)`函数返回一个新函数，该函数将始终返回`t`值：'
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can rewrite our `fizzBuzz` value using `constant`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`constant`重新编写我们的`fizzBuzz`值：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Identity and constant functions are useful in functional programming or in implementations
    of math algorithms, for example, constant is K in SKI combinator calculus.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 身份和常量函数在函数式编程或数学算法的实现中非常有用，例如，常量是 SKI 组合演算中的 K。
- en: Optics
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 透镜
- en: '**Optics** are abstractions to update immutable data structures elegantly.
    One form of optics is `Lens` (or lenses, depending on the library implementation).
    A `Lens` is a functional reference that can focus (hence the name) into a structure
    and read, write, or modify its target:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**透镜**是优雅地更新不可变数据结构的抽象。透镜的一种形式是`Lens`（或透镜，具体取决于库实现）。`Lens`是一个功能引用，可以聚焦（因此得名）到结构中，并读取、写入或修改其目标：'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To create a new `Laptop` value from an existing one, we need to use several
    nested copy methods and references. In this example, it isn't as bad but you can
    imagine that in a more complex data structure, things can overgrow into madness.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要从现有值创建一个新的`Laptop`值，我们需要使用多个嵌套的复制方法和引用。在这个例子中，这并不那么糟糕，但您可以想象在一个更复杂的数据结构中，事情可能会变得混乱。
- en: 'Let''s write our very first `Lens` values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写我们非常第一个`Lens`值：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `laptopPrice` value is a `Lens<Laptop, Double>` that we initialize using
    the function `Lens<S, T, A, B>` (actually `Lens.invoke`). `Lens` takes two functions
    as parameters, as `get: (S) -> A` and `set: (B) -> (S) -> T`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`laptopPrice`值是一个`Lens<Laptop, Double>`，我们使用函数`Lens<S, T, A, B>`（实际上是`Lens.invoke`）初始化它。`Lens`接受两个函数作为参数，作为`get:
    (S) -> A`和`set: (B) -> (S) -> T`。'
- en: 'As you can see, `set` is a curried function so that you can write your set
    like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`set`是一个柯里化函数，因此您可以像这样编写您的设置：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Which, depending on your preferences, can be easier to read and write.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的偏好，这可以使阅读和编写变得更加容易。
- en: 'Now that you have your first lens, it can be used to set, read, and modify
    a laptop''s price. Not too impressive, but the magic of lenses is combining them:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了第一个透镜，它可以用来设置、读取和修改笔记本电脑的价格。这并不太令人印象深刻，但透镜的魔力在于它们的组合：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We created `laptopMemorySize` combining lenses from `Laptop` all the way to
    `memorySize`; then, we can set laptop's price and modify its memory.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`Laptop`到`memorySize`的所有透镜组合创建了`laptopMemorySize`；然后，我们可以设置笔记本电脑的价格并修改其内存。
- en: Despite how cool lenses are, it looks like a lot of boilerplate code. Fear not,
    Arrow can generate those lenses for you.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管透镜很酷，但看起来有很多样板代码。不用担心，Arrow 可以为您生成这些透镜。
- en: Configuring Arrows code generation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Arrows 代码生成
- en: 'On a Gradle project, add a file called `generated-kotlin-sources.gradle`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Gradle 项目中，添加一个名为`generated-kotlin-sources.gradle`的文件：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, in the `build.gradle` file, add the following content:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`build.gradle`文件中，添加以下内容：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a new dependency in the `build.gradle` file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`文件中添加一个新的依赖项：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once configured, you can generate Arrow code with a normal build command, `./gradlew
    build`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置完成，您就可以使用常规的构建命令生成 Arrow 代码，`./gradlew build`。
- en: Generating lenses
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成透镜
- en: 'Once Arrow''s code generation is configured, you can add the `@lenses` annotation
    to the data classes that you want to have lenses generated for:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了 Arrow 的代码生成，您可以将`@lenses`注解添加到您希望生成透镜的数据类中：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Arrow generates as many lenses as constructor parameters our data classes have,
    with the name convention `classProperty` and in the same package, so no extra
    imports are needed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 为我们的数据类生成与构造函数参数数量一样多的透镜，名称约定为`classProperty`，并在同一包中，因此不需要额外的导入。
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered many features of Arrow that give us tools to create,
    generate, and enrich existing functions. We composed new functions using existing
    ones; we included partial application and currying. We also cached results of
    pure functions with memoization and modified data structures using lenses.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Arrow的许多特性，这些特性为我们提供了创建、生成和丰富现有函数的工具。我们使用现有的函数组合成新的函数；我们包括了部分应用和柯里化。我们还通过记忆化缓存了纯函数的结果，并使用透镜修改了数据结构。
- en: Arrow's features open up the possibility of creating rich and maintainable applications,
    using basic functional principles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow的特性为使用基本函数式原则创建丰富且可维护的应用程序打开了可能性。
- en: In the next chapter, we'll cover more Arrow features, including datatypes such
    as `Option`, `Either`, and `Try`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍更多的Arrow特性，包括`Option`、`Either`和`Try`等数据类型。
