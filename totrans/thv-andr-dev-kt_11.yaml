- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Adding Media Playback to Packtflix with ExoPlayer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ExoPlayer 将媒体播放添加到 Packtflix
- en: 'In the journey of Android development, the ability to create rich, engaging
    multimedia applications is a crucial skill that sets apart great apps from the
    good ones. As we venture further into the creation of our Netflix-like app, we’ll
    transition from the foundational structures and user interfaces for browsing movie
    lists and details to the core of multimedia experiences: video playback. This
    chapter is dedicated to unlocking the potential of video content within our application,
    a feature that will significantly enhance user engagement and satisfaction. Here,
    we will travel into the world of media playback on Android, focusing on the powerful
    and versatile library known as ExoPlayer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 开发的旅程中，能够创建丰富、引人入胜的多媒体应用是一项至关重要的技能，它将优秀的应用与良好的应用区分开来。随着我们进一步探索创建类似
    Netflix 的应用，我们将从浏览电影列表和详情的基础结构和用户界面过渡到多媒体体验的核心：视频播放。本章致力于挖掘我们应用中视频内容潜力，这一功能将显著提升用户参与度和满意度。在这里，我们将进入
    Android 媒体播放的世界，重点关注功能强大且多才多艺的库——ExoPlayer。
- en: ExoPlayer stands out in the Android ecosystem as a robust, open-source library
    that provides an alternative to the standard Android MediaPlayer API. It offers
    extensive customization options and supports a wide range of media formats, including
    those not natively supported by Android. Our exploration will begin with an overview
    of media options in Android, setting the stage for why ExoPlayer is the library
    of choice for modern Android applications seeking to offer a superior media playback
    experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: ExoPlayer 在 Android 生态系统中脱颖而出，作为一个健壮的开源库，它为标准的 Android MediaPlayer API 提供了替代方案。它提供了广泛的定制选项，并支持广泛的媒体格式，包括那些
    Android 本地不支持格式。我们的探索将从 Android 媒体选项概述开始，为为什么 ExoPlayer 是现代寻求提供卓越媒体播放体验的 Android
    应用首选库奠定基础。
- en: Following the introduction to media options, we will learn the basics of ExoPlayer,
    covering its architecture, key components, and how it integrates within an Android
    application. This foundational knowledge will prepare us to tackle the practical
    aspects of implementing video playback. This chapter will guide you through creating
    a responsive, intuitive video playback UI that meets the expectations of today’s
    users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍媒体选项之后，我们将学习 ExoPlayer 的基础知识，包括其架构、关键组件以及如何在 Android 应用程序中集成。这些基础知识将为我们应对视频播放的实际实现做好准备。本章将指导你创建一个响应式、直观的视频播放用户界面，以满足当今用户的期望。
- en: The journey will continue with hands-on examples and detailed guidance on playing
    videos using ExoPlayer. This includes managing playback controls, adjusting video
    quality, and handling various media sources. Additionally, while recognizing the
    importance of accessibility and global reach, you’ll learn how to add subtitles
    to your videos, ensuring your content is accessible to a wider audience.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 旅程将继续，通过实际示例和详细指导，使用 ExoPlayer 播放视频。这包括管理播放控制、调整视频质量和处理各种媒体源。此外，在认识到可访问性和全球覆盖的重要性时，你将学习如何为你的视频添加字幕，确保你的内容能够被更广泛的观众所访问。
- en: By the end of this chapter, you will have mastered the essentials of video playback
    in Android, equipped with the skills to enrich your applications with high-quality
    video content, creating immersive experiences for your users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握 Android 视频播放的基本知识，并具备用高质量视频内容丰富你应用的技能，为你的用户提供沉浸式体验。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Reviewing media options in Android
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Android 的媒体选项
- en: Reviewing Android’s media options
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 Android 的媒体选项
- en: Creating the video playback user interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建视频播放用户界面
- en: Playing video using ExoPlayer
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ExoPlayer 播放视频
- en: Adding subtitles to the video player
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视频播放器添加字幕
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, you will need to have Android Studio (or another
    editor of your preference) installed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，你需要安装 Android Studio（或你偏好的其他编辑器）。
- en: 'We will continue working on the same project we started in [*Chapter 7*](B19443_07.xhtml#_idTextAnchor142).
    You can find the complete code that we are going to build throughout this chapter
    in this book’s GitHub repository: [https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-8](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-8).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续在[*第 7 章*](B19443_07.xhtml#_idTextAnchor142)中开始的同一个项目中工作。您可以在本书的 GitHub
    仓库中找到我们将在本章构建的完整代码：[https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-8](https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-8)。
- en: Reviewing Android’s media options
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查 Android 的媒体选项
- en: Android, as a versatile mobile operating system, offers comprehensive support
    for various types of media, including but not limited to audio files (such as
    MP3, WAV, and OGG) and video content (such as MP4, WebM, and MKV). This broad
    support empowers developers to incorporate a wide range of media types into their
    applications that can be used for diverse user preferences and use cases. From
    educational apps that leverage video tutorials for learning to entertainment platforms
    streaming movies and music, media playback is at the heart of modern mobile applications,
    driving user engagement and satisfaction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android 作为一款多功能的移动操作系统，为各种类型的媒体提供了全面的支持，包括但不限于音频文件（如 MP3、WAV 和 OGG）和视频内容（如 MP4、WebM
    和 MKV）。这种广泛的支持使开发者能够将各种媒体类型集成到他们的应用程序中，以满足不同的用户偏好和使用场景。从利用视频教程进行学习的教育应用，到流式传输电影和音乐的娱乐平台，媒体播放是现代移动应用的核心，推动用户参与度和满意度。
- en: To start our journey, let’s look at which options we have in the Android ecosystem
    so that we can choose the most appropriate option to build the playback functionality
    of our app. We will start with MediaPlayer API and VideoView before considering
    ExoPlayer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的旅程，让我们看看在 Android 生态系统中我们有哪些选项，以便我们可以选择最合适的选项来构建我们应用的视频播放功能。我们将从 MediaPlayer
    API 和 VideoView 开始，然后再考虑 ExoPlayer。
- en: Learning about the MediaPlayer API
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 MediaPlayer API
- en: The **MediaPlayer** API is a powerful and flexible class that allows Android
    developers to handle audio and video playback with a high degree of control. The
    API is designed to be easy to use yet capable of catering to complex media playback
    requirements.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**MediaPlayer** API 是一个强大且灵活的类，它允许 Android 开发者以高度控制的方式处理音频和视频播放。该 API 设计得易于使用，同时能够满足复杂的媒体播放需求。'
- en: 'Its main features are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要功能如下：
- en: '**Versatile media source support**: MediaPlayer can play media from various
    sources, including local files (such as device storage or SD cards), raw resources
    (which are bundled within the app), and network streams (HTTP/HTTPS).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多功能的媒体源支持**：MediaPlayer 可以从各种来源播放媒体，包括本地文件（如设备存储或 SD 卡）、原始资源（包含在应用中）和网络流（HTTP/HTTPS）。'
- en: '**Playback control**: It offers comprehensive control over media playback,
    including play, pause, stop, rewind, and fast-forward options, as well as the
    ability to seek specific timestamps.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放控制**：它提供了对媒体播放的全面控制，包括播放、暂停、停止、倒退和快进选项，以及寻求特定时间戳的能力。'
- en: '**Volume control**: The MediaPlayer API in Android allows developers to programmatically
    adjust the volume of audio playback. This is achieved through methods such as
    **setVolume(float leftVolume, float rightVolume)**, which controls the volume
    level of the left and right speakers independently. This feature is essential
    for creating applications that can dynamically adjust the playback volume based
    on specific user settings, environmental conditions, or application scenarios.
    For instance, an app might automatically lower the volume during nighttime hours
    or increase it in a noisy environment to enhance user experience.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音量控制**：Android 中的 MediaPlayer API 允许开发者通过编程方式调整音频播放的音量。这是通过如 **setVolume(float
    leftVolume, float rightVolume)** 这样的方法实现的，它独立控制左右扬声器的音量级别。这一特性对于创建能够根据特定用户设置、环境条件或应用场景动态调整播放音量的应用程序至关重要。例如，一个应用可能会在夜间自动降低音量，或者在嘈杂的环境中提高音量以增强用户体验。'
- en: '**Event handling**: MediaPlayer provides listeners that can be used to respond
    to media life cycle events, such as completion, preparation, error handling, and
    buffering updates.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件处理**：MediaPlayer 提供了可以用于响应媒体生命周期事件的监听器，例如完成、准备、错误处理和缓冲更新。'
- en: '**Audio focus management**: Essential for apps that play audio, MediaPlayer
    can handle audio focus to ensure a smooth user experience when multiple apps potentially
    play sounds simultaneously.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频焦点管理**：对于播放音频的应用程序来说至关重要，MediaPlayer 可以处理音频焦点，以确保在多个应用程序可能同时播放声音时提供流畅的用户体验。'
- en: 'As we can see, MediaPlayer provides the basic functionality we need for simple
    audio and video handling, so it could be a good solution for the following cases:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，MediaPlayer 提供了我们需要的简单音频和视频处理的基本功能，因此它可能是以下情况的良好解决方案：
- en: '**Music players**: MediaPlayer is well-suited for apps that play music or podcast
    files, whether it’s stored locally or streamed over the internet'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐播放器**：MediaPlayer 非常适合播放音乐或播客文件的应用程序，无论是存储在本地还是通过互联网流式传输。'
- en: '**Video players**: Although MediaPlayer requires more setup for video playback
    compared to VideoView, it’s ideal for custom video player applications where developers
    need control over rendering and playback'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视频播放器**：虽然与 VideoView 相比，MediaPlayer 需要更多的设置来播放视频，但它非常适合需要控制渲染和播放的自定义视频播放器应用程序。'
- en: '**Game sound effects**: For games that need to play short sound effects, MediaPlayer
    can be used for its simplicity and ability to handle various audio formats'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏音效**：对于需要播放短音效的游戏，MediaPlayer 可以因其简单性和处理各种音频格式的能力而被使用。'
- en: 'Here’s an example of how to reproduce an audio file using MediaPlayer:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 MediaPlayer 重新生成音频文件的示例：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, `MediaPlayer.create()` is used within the `remember` block
    to ensure that the media player is only instantiated once, maintaining this instance
    across recompositions of the composable. Then, the `ObserveLifecycle` composable
    function is used to observe the life cycle of the entire application (using `ProcessLifecycleOwner`
    here for simplicity). This function ensures that `mediaPlayer.release()` is called
    to free up resources when the app is destroyed, although you might adapt this
    to more specific life cycle events as needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`MediaPlayer.create()` 在 `remember` 块中使用，以确保媒体播放器只实例化一次，并在组合的重组过程中保持此实例。然后，使用
    `ObserveLifecycle` 组合函数来观察整个应用程序的生命周期（这里为了简单起见使用 `ProcessLifecycleOwner`）。此函数确保在应用程序销毁时调用
    `mediaPlayer.release()` 以释放资源，尽管你可能需要根据需要将其适配到更具体的生命周期事件。
- en: The UI consists of two buttons for play and stop functionalities. The play button’s
    `onClick` logic checks if the media is not currently playing before starting playback.
    This is done to avoid restarting the audio and video if the button is pressed
    during playback. Similarly, the stop button pauses the playback.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: UI 由两个按钮组成，用于播放和停止功能。播放按钮的 `onClick` 逻辑在开始播放之前检查媒体是否当前未播放。这样做是为了避免在播放过程中按下按钮时重新启动音频和视频。同样，停止按钮暂停播放。
- en: 'This example demonstrates how to integrate MediaPlayer with Jetpack Compose
    while managing the media player life cycle and providing a simple UI for controlling
    playback. You can find more examples in the official documentation: [https://developer.android.com/media/platform/mediaplayer](https://developer.android.com/media/platform/mediaplayer).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本例演示了如何在管理媒体播放器生命周期的同时将 MediaPlayer 与 Jetpack Compose 集成，并提供一个简单的 UI 来控制播放。您可以在官方文档中找到更多示例：[https://developer.android.com/media/platform/mediaplayer](https://developer.android.com/media/platform/mediaplayer)。
- en: Although our example illustrates how to provide the playback control UI, we
    still need to show the video so that our users can watch it. This is where VideoView
    comes in.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的示例说明了如何提供播放控制 UI，但我们仍然需要显示视频，以便用户可以观看。这就是 VideoView 发挥作用的地方。
- en: Learning about VideoView
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 VideoView
- en: '**VideoView** is a higher-level UI component in Android that encapsulates the
    functionality of MediaPlayer and SurfaceView to provide a convenient way to play
    video files. It simplifies the process of video playback by managing the underlying
    media playback mechanics, making it ideal for use cases that require straightforward
    video playback without the need for fine-grained control over the media pipeline.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**VideoView** 是 Android 中的一个高级 UI 组件，它封装了 MediaPlayer 和 SurfaceView 的功能，以提供一种方便播放视频文件的方式。它通过管理底层的媒体播放机制简化了视频播放过程，使其非常适合需要直接视频播放而不需要精细控制媒体管道的场景。'
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: SurfaceView is a specialized component in the Android framework that provides
    a dedicated drawing surface within the app’s view hierarchy. Unlike standard views,
    which are drawn onto a single canvas managed by the UI thread, SurfaceView can
    be rendered independently in a separate thread. This allows for more efficient
    redrawing, especially for demanding content such as video playback or dynamic
    graphics. SurfaceView is particularly useful when you need to update your views
    frequently or when the rendering process is computationally intensive as it does
    not block user interaction while drawing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SurfaceView是Android框架中的一个专用组件，它为应用视图层次结构提供了一个专门的绘图表面。与绘制在由UI线程管理的单个画布上的标准视图不同，SurfaceView可以在单独的线程中独立渲染。这允许更高效的重新绘制，特别是对于视频播放或动态图形等要求较高的内容。SurfaceView在您需要频繁更新视图或渲染过程计算密集时特别有用，因为它在绘图时不会阻塞用户交互。
- en: 'Let’s explore some of VideoView’s features so that we can appreciate the practical
    benefits it offers:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些VideoView的功能，以便我们能够欣赏它提供的实际好处：
- en: '**Simplicity**: VideoView simplifies the implementation of video playback.
    You can start playing a video with just a few lines of code, handling preparation
    and playback of the video file automatically.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：VideoView简化了视频播放的实现。您只需几行代码就可以开始播放视频，自动处理视频文件的准备和播放。'
- en: '**Control integration**: It can be easily integrated with media controls (using
    MediaController), allowing users to play, pause, and seek through the video.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制集成**：它可以轻松集成媒体控件（使用MediaController），使用户能够播放、暂停和搜索视频。'
- en: '**Format support**: VideoView supports various video formats that Android’s
    MediaPlayer supports, including MP4, 3GP, and more, depending on the device and
    platform version.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式支持**：VideoView支持Android的MediaPlayer支持的多种视频格式，包括MP4、3GP等，具体取决于设备和平台版本。'
- en: '**Layout flexibility**: Being a view, VideoView can be placed anywhere in your
    application’s layout and can be resized and styled as needed, just like any other
    UI component.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局灵活性**：作为一个视图，VideoView可以放置在您应用布局的任何位置，可以根据需要调整大小和样式，就像任何其他UI组件一样。'
- en: 'Understanding VideoView’s features sets the stage for its practical applications.
    Now, let’s pinpoint exactly where VideoView shines. Here are the best scenarios
    for using VideoView in your app:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 理解VideoView的功能为其实际应用奠定了基础。现在，让我们精确地找出VideoView的亮点。以下是使用VideoView在您的应用中的最佳场景：
- en: '**Simple video playback**: When you need to play videos without requiring advanced
    playback features such as adaptive streaming, VideoView is a straightforward and
    effective choice. Adaptive streaming, such as **HTTP Live Streaming** (**HLS**)
    and **Dynamic Adaptive Streaming over HTTP** (**DASH**), allows videos to be delivered
    in varying qualities, depending on network conditions. HLS is widely used for
    live and on-demand streaming on the web, as well as dynamically adjusting video
    quality based on the viewer’s internet speed. Similarly, DASH is a flexible standard
    that enables high-quality streaming of media content over the internet.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单视频播放**：当您需要播放视频而不需要高级播放功能，如自适应流式传输时，VideoView是一个简单而有效的选择。自适应流式传输，如**HTTP实时流**（**HLS**）和**HTTP动态自适应流**（**DASH**），允许根据网络条件以不同的质量传输视频。HLS在网页上的直播和点播流以及根据观众的网络速度动态调整视频质量方面得到广泛应用。同样，DASH是一个灵活的标准，它允许在互联网上以高质量流式传输媒体内容。'
- en: '**Local and network videos**: It’s suitable for playing videos stored locally
    on the device or streamed over the network.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地和网络视频**：它适用于播放存储在设备上的本地视频或通过网络流式传输的视频。'
- en: '**Embedded video content**: VideoView is great for applications that need to
    embed video content directly within their UI, such as tutorial apps, video players,
    or social media apps with video feeds.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌入式视频内容**：VideoView非常适合需要在其UI中直接嵌入视频内容的应用程序，例如教程应用、视频播放器或带有视频流的社会媒体应用。'
- en: 'Now that we know its features and recommended use cases, let’s look at an example
    so that we understand how it works. In this example, we’re using the 1.7.0 version
    of the `androidx.media:media` library:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了其功能和推荐的使用案例，让我们通过一个示例来了解它是如何工作的。在这个例子中，我们使用的是`androidx.media:media`库的1.7.0版本：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we start by declaring a composable called `VideoPlayer`. This composable
    accepts a `videoUrl` string as a parameter. This specifies the location of the
    video to be played.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先声明一个名为`VideoPlayer`的可组合组件。这个可组合组件接受一个`videoUrl`字符串作为参数。这指定了要播放的视频的位置。
- en: Within the function, `LocalContext.current` is used to obtain the current context
    from the Compose environment. The `AndroidView` composable is then employed to
    bridge the gap between traditional Android UI components and the Compose world.
    It takes a factory Lambda expression where `VideoView` is instantiated by using
    the context.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，使用`LocalContext.current`从Compose环境中获取当前上下文。然后，使用`AndroidView`可组合项来弥合传统Android
    UI组件和Compose世界之间的差距。它接受一个工厂Lambda表达式，其中通过上下文实例化`VideoView`。
- en: Next, `MediaController` is created and associated with `VideoView` through `setMediaController()`,
    providing standard media controls such as play, pause, and seek to enhance user
    interaction with the video playback.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`MediaController`并将其通过`setMediaController()`与`VideoView`关联，提供标准媒体控件，如播放、暂停和搜索，以增强用户与视频播放的交互。
- en: The media controller is anchored to `VideoView` using `setAnchorView(this)`,
    ensuring that the control interface is displayed correctly concerning the video
    view. The video URL that’s passed to the function is parsed into a `Uri` component
    and set on `VideoView` with `setVideoURI()`, pointing the player to the video
    content.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setAnchorView(this)`将媒体控制器锚定到`VideoView`上，确保控制界面在视频视图方面正确显示。传递给函数的视频URL被解析为一个`Uri`组件，并通过`setVideoURI()`设置在`VideoView`上，指向播放器的内容。
- en: Finally, `start()` is called on `VideoView` to initiate video playback automatically
    as soon as the setup is complete and the video is ready to be shown.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在设置完成并且视频准备就绪后，通过在`VideoView`上调用`start()`方法来自动启动视频播放。
- en: 'In this section, we took a sneak peek at how the MediaPlayer API and VideoView
    work and their features. Now, it’s time for the crown jewel: ExoPlayer.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要了解了MediaPlayer API和VideoView的工作原理及其功能。现在，是时候关注皇冠上的宝石：ExoPlayer。
- en: Understanding the basics of ExoPlayer
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ExoPlayer的基础知识
- en: '**ExoPlayer** stands as a significant advancement over Android’s basic MediaPlayer,
    offering a level of flexibility, customization, and support for advanced streaming
    formats that MediaPlayer simply cannot match. This superiority makes ExoPlayer
    the go-to choice for developers needing robust, feature-rich media playback capabilities
    in their applications.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**ExoPlayer**在Android的基本MediaPlayer之上取得了重大进步，提供了MediaPlayer无法比拟的灵活性、定制性和对高级流媒体格式的支持。这种优越性使得ExoPlayer成为需要强大、功能丰富媒体播放能力的开发者的首选选择。'
- en: One of ExoPlayer’s most compelling advantages is its adaptability. Unlike the
    relatively static MediaPlayer, ExoPlayer can be easily adapted and extended to
    suit specific application needs. Its modular architecture allows developers to
    include only the components they need, reducing the app’s overall size. Furthermore,
    ExoPlayer’s customization options extend to its user interface, with the ability
    to create custom controls and layouts that seamlessly integrate with the rest
    of the application’s design. This adaptability ensures that developers can craft
    a unique media playback experience that aligns perfectly with their app’s branding
    and user interface guidelines.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ExoPlayer最吸引人的优势之一是其适应性。与相对静态的MediaPlayer不同，ExoPlayer可以轻松地适应和扩展以满足特定应用需求。其模块化架构允许开发者仅包含他们需要的组件，从而减少应用程序的整体大小。此外，ExoPlayer的定制选项还扩展到其用户界面，能够创建与应用程序设计无缝集成的自定义控件和布局。这种适应性确保了开发者可以打造与他们的应用程序品牌和用户界面指南完美对齐的独特媒体播放体验。
- en: In the realm of streaming, ExoPlayer’s strengths become even more apparent.
    It offers out-of-the-box support for modern streaming protocols such as HLS and
    DASH. These adaptive streaming protocols are essential for delivering content
    efficiently over the internet, adjusting the quality of the stream in real time
    based on the user’s current network conditions. This ensures an optimal viewing
    experience that minimizes buffering and playback interruptions even under fluctuating
    network speeds.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在流媒体领域，ExoPlayer的优势变得更加明显。它提供了对现代流媒体协议（如HLS和DASH）的即插即用支持。这些自适应流媒体协议对于在互联网上高效传输内容至关重要，可以根据用户的当前网络条件实时调整流的质量。这确保了即使在网络速度波动的情况下，也能提供最佳的观看体验，最小化缓冲和播放中断。
- en: MediaPlayer, by contrast, offers limited support for such streaming protocols,
    often requiring developers to implement additional solutions or workarounds to
    achieve similar functionality. With ExoPlayer, developers gain direct access to
    these advanced features, simplifying the development process and enhancing the
    end user experience.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，MediaPlayer 对此类流式传输协议的支持有限，通常需要开发者实现额外的解决方案或工作区来达到类似的功能。使用 ExoPlayer，开发者可以直接访问这些高级功能，简化开发过程并提升最终用户体验。
- en: As we can see, ExoPlayer’s functionality is widely superior due to its flexibility
    and wide format support and those are the reasons we will use it in this project.
    On the other hand, as it is more complex, we will have to learn more about it
    before we start to implement our video player using it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，由于其灵活性和广泛格式支持，ExoPlayer 的功能非常优越，这也是我们将在项目中使用它的原因。另一方面，由于它更复杂，我们将在开始使用它实现视频播放器之前需要更多地了解它。
- en: Well, let’s do exactly that and break down ExoPlayer’s architecture.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们就做这件事，并分解 ExoPlayer 的架构。
- en: Exploring ExoPlayer’s architecture
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 ExoPlayer 的架构
- en: ExoPlayer’s architecture is designed to be both flexible and extensible, making
    it capable of handling a wide range of media playback scenarios. ExoPlayer has
    several core components that work together to provide a robust and efficient media
    playback experience. Understanding these components is key to leveraging ExoPlayer’s
    full capabilities in our applications. Let’s take a look at them here.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ExoPlayer 的架构旨在既灵活又可扩展，使其能够处理广泛的媒体播放场景。ExoPlayer 有几个核心组件协同工作，以提供强大而高效的媒体播放体验。理解这些组件对于在应用中充分利用
    ExoPlayer 的全部功能至关重要。让我们在这里看看它们。
- en: The ExoPlayer instance – the central media playback engine
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ExoPlayer 实例 – 中心媒体播放引擎
- en: The ExoPlayer instance itself acts as the central hub for media playback, orchestrating
    the interaction between the various components involved in the playback process,
    managing the playback state, and coordinating the fetching, decoding, and rendering
    of media. Unlike Android’s MediaPlayer, which operates as a black box, ExoPlayer
    provides developers with detailed control over playback and access to the playback
    pipeline, enabling fine-tuned adjustments to fit the application’s specific needs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ExoPlayer 实例本身充当媒体播放的中心枢纽，协调播放过程中涉及的各个组件之间的交互，管理播放状态，并协调媒体内容的获取、解码和渲染。与作为黑盒操作的
    Android 的 MediaPlayer 不同，ExoPlayer 为开发者提供了对播放和播放管道的详细控制，使他们能够进行精细调整以满足应用程序的特定需求。
- en: 'Here’s a simple example of how to initialize ExoPlayer and prepare it to play
    a media item:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何初始化 ExoPlayer 并准备播放媒体项的简单示例：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The process begins with creating an `ExoPlayer` instance, utilizing a context-aware
    builder pattern that ensures the player is configured for the environment where
    it operates. Following its instantiation, a media item is specified through a
    URI, which could either point to a local resource or a remote media file. This
    media item is then associated with the `ExoPlayer` instance, indicating what content
    it should be prepared to play.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程从创建一个 `ExoPlayer` 实例开始，利用上下文感知的构建器模式确保播放器配置了其操作的环境。在其实例化之后，通过 URI 指定一个媒体项，该
    URI 可以指向本地资源或远程媒体文件。然后，将此媒体项与 `ExoPlayer` 实例关联起来，表明它应该准备播放的内容。
- en: Once the media item has been set, the player enters a preparation phase by invoking
    the `prepare()` method. During this phase, ExoPlayer analyzes the media, setting
    up necessary buffers and decoding resources to ensure smooth playback.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了媒体项，播放器将通过调用 `prepare()` 方法进入准备阶段。在此阶段，ExoPlayer 分析媒体内容，设置必要的缓冲区和解码资源，以确保流畅的播放。
- en: The final step in the process involves setting the player’s `playWhenReady`
    property to `true`, a command that triggers playback as soon as the player is
    fully prepared. This property provides flexibility, allowing developers to control
    when playback should start. This can be immediately after preparation or delayed
    based on additional conditions or user interactions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的最后一步是设置播放器的 `playWhenReady` 属性为 `true`，这是一个在播放器完全准备就绪后触发播放的命令。此属性提供了灵活性，允许开发者控制播放何时开始。这可以是准备完成后立即开始，也可以基于其他条件或用户交互进行延迟。
- en: MediaItem – sourcing the media resource
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MediaItem – 资源来源
- en: 'In ExoPlayer, **MediaItem** encapsulates details about a media source, such
    as its URI, metadata, and any configuration related to playback. It is a versatile
    and essential component that tells ExoPlayer what content to load and play. These
    are the key functions of MediaItem:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在ExoPlayer中，**MediaItem**封装了有关媒体源的信息，例如其URI、元数据和与播放相关的任何配置。它是一个多功能且至关重要的组件，告诉ExoPlayer要加载和播放什么内容。这些是MediaItem的关键功能：
- en: '**Media source specification**: The primary function of MediaItem is to specify
    the location of the media to be played. This can be a file path, a URL, or a content
    URI, among other formats.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体源指定**：MediaItem的主要功能是指定要播放的媒体的位置。这可以是文件路径、URL或内容URI等多种格式之一。'
- en: '**Media configuration**: Beyond just specifying a media source, MediaItem allows
    for detailed configuration of the playback. This includes setting DRM configurations,
    specifying subtitles, and defining custom attributes through metadata.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体配置**：MediaItem不仅允许指定媒体源，还允许详细配置播放。这包括设置DRM配置、指定字幕以及通过元数据定义自定义属性。'
- en: '**Adaptive streaming**: For adaptive streaming content (such as DASH and HLS),
    MediaItem can include the necessary information for ExoPlayer to adapt the stream’s
    quality dynamically based on network conditions. This information includes metadata
    such as the URLs of the various stream segments, available quality levels, and
    codecs.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自适应流**：对于自适应流内容（如DASH和HLS），MediaItem可以为ExoPlayer提供必要的信息，以便根据网络条件动态调整流的品质。这些信息包括各种流段的URL、可用的品质级别和编解码器等元数据。'
- en: '**Playback options**: Developers can use MediaItem to configure specific playback
    options, such as start and end positions, looping, and more. These options provide
    fine-grained control over how the media is played.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放选项**：开发者可以使用MediaItem配置特定的播放选项，例如起始和结束位置、循环等。这些选项提供了对媒体播放的精细控制。'
- en: 'In practice, once a MediaItem is created and configured, it is passed to the
    ExoPlayer instance so that it can be prepared for playback. You can load a single
    MediaItem for simple playback scenarios or manage a playlist by loading multiple
    MediaItems. Let’s see a brief example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，一旦创建并配置了MediaItem，它就会被传递给ExoPlayer实例，以便进行播放准备。您可以为简单的播放场景加载单个MediaItem，或者通过加载多个MediaItem来管理播放列表。让我们看一个简短的例子：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are creating `mediaItem` from a URL and preparing it to
    be reproduced by the ExoPlayer instance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从一个URL创建`mediaItem`并准备它由ExoPlayer实例播放。
- en: TrackSelector – managing media tracks
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轨道选择器 – 管理媒体轨道
- en: The `TrackSelector` instance is a critical component of ExoPlayer that’s responsible
    for selecting the specific tracks to be played. A video might contain multiple
    audio tracks in different languages, several video qualities, or various subtitle
    tracks, and `TrackSelector` decides which of these tracks are best suited for
    the current playback context based on the device’s capabilities, user preferences,
    and network conditions. This selection process is crucial for adaptive streaming
    scenarios as a single video is encoded at multiple quality levels and stored on
    the server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrackSelector`实例是ExoPlayer的一个关键组件，负责选择要播放的具体轨道。一个视频可能包含多种语言的多个音频轨道、多个视频品质或各种字幕轨道，而`TrackSelector`会根据设备的性能、用户偏好和网络条件，决定这些轨道中哪一个最适合当前的播放环境。这个选择过程对于自适应流场景至关重要，因为单个视频可能以多个品质级别编码并存储在服务器上。'
- en: 'Here’s an example of its use:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用示例：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The process starts with the creation of a `DefaultTrackSelector` instance. The
    `DefaultTrackSelector` instance is a component of `ExoPlayer` that decides which
    tracks (audio, video, or text) are played from the media based on various criteria,
    such as the user’s device capabilities and the tracks’ properties. In this example,
    the track selector is configured to prefer audio tracks in English. This preference
    is set by modifying the track selector’s parameters, indicating that if the media
    contains multiple audio tracks in different languages, the English one should
    be chosen, if available.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程从创建一个`DefaultTrackSelector`实例开始。`DefaultTrackSelector`实例是`ExoPlayer`的一个组件，它根据各种标准（如用户的设备性能和轨道属性）决定从媒体中播放哪些轨道（音频、视频或文本）。在这个例子中，轨道选择器被配置为优先选择英语音频轨道。这种偏好是通过修改轨道选择器的参数来设置的，表示如果媒体包含多种语言的多个音频轨道，则如果可用，应选择英语轨道。
- en: After configuring the track selector, it’s used in the construction of the `ExoPlayer`
    instance. Here, `ExoPlayer.Builder` is provided with the application context and
    the customized track selector when building the player. This ensures that when
    the `ExoPlayer` instance prepares and plays media, it uses the logic defined in
    `DefaultTrackSelector` for track selection. Essentially, this setup allows for
    more control over which audio track is selected during playback, based on the
    predefined criteria (in this case, the language preference).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完轨道选择器后，它被用于构建 `ExoPlayer` 实例。在这里，`ExoPlayer.Builder` 在构建播放器时提供了应用程序上下文和自定义的轨道选择器。这确保了当
    `ExoPlayer` 实例准备和播放媒体时，它使用 `DefaultTrackSelector` 中定义的逻辑进行轨道选择。本质上，这种设置允许在播放期间对选择哪个音频轨道有更多的控制，基于预定义的标准（在这种情况下，是语言偏好）。
- en: This approach to configuring ExoPlayer is particularly beneficial in applications
    that deal with media containing multiple tracks for different audience demographics
    or in scenarios where the application needs to adhere to user preferences or settings,
    such as a language selection option. By customizing the track selector, developers
    can ensure that the media playback experience is optimized for the specific needs
    and preferences of their users, enhancing overall usability and satisfaction.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置 ExoPlayer 的方法特别适用于处理包含针对不同受众群体的多个轨道的媒体的应用程序，或者在应用程序需要遵守用户偏好或设置（如语言选择选项）的场景中。通过自定义轨道选择器，开发者可以确保媒体播放体验针对用户的特定需求和偏好进行了优化，从而提高整体可用性和满意度。
- en: LoadControl – handling buffering and loading
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LoadControl – 处理缓冲和加载
- en: The `LoadControl` component oversees the strategy for buffering and loading
    media resources. Efficient buffering is essential for smooth playback, especially
    in streaming scenarios where network conditions can vary widely. The `LoadControl`
    component determines how much media data to buffer at any given time, striking
    a balance between reducing initial loading times and minimizing the likelihood
    of playback interruptions. We can customize the buffering policy to cater to specific
    requirements, such as prioritizing quick start times or ensuring uninterrupted
    playback.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadControl` 组件负责监控缓冲和加载媒体资源的策略。高效的缓冲对于流畅的播放至关重要，尤其是在网络条件可能大范围变化的流媒体场景中。`LoadControl`
    组件决定在任何给定时间需要缓冲多少媒体数据，在减少初始加载时间和最小化播放中断的可能性之间取得平衡。我们可以自定义缓冲策略以满足特定需求，例如优先考虑快速启动时间或确保无缝播放。'
- en: 'The following is an example of creating a custom `LoadControl` component to
    modify the buffer policy:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个创建自定义 `LoadControl` 组件以修改缓冲策略的示例：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The example begins by creating an instance of `DefaultLoadControl` using `Builder`.
    Here, `DefaultLoadControl` is an implementation of the `LoadControl` interface
    provided by ExoPlayer and is designed to manage media buffering based on various
    parameters that I will explain now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例开始于使用 `Builder` 创建 `DefaultLoadControl` 实例。在这里，`DefaultLoadControl` 是 ExoPlayer
    提供的 `LoadControl` 接口的一个实现，它旨在根据我将解释的各种参数来管理媒体缓冲。
- en: The `setBufferDurationsMs` method is called on the builder to specify custom
    buffer durations. Specifically, it sets the minimum buffer duration (`minBufferMs`)
    to 2 minutes (120,000 milliseconds). This means that ExoPlayer will attempt to
    buffer at least 2 minutes of media before starting playback, which can help ensure
    smooth playback under varying network conditions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建器上调用 `setBufferDurationsMs` 方法来指定自定义缓冲持续时间。具体来说，它将最小缓冲持续时间（`minBufferMs`）设置为2分钟（120,000毫秒）。这意味着
    ExoPlayer 将尝试在开始播放之前至少缓冲2分钟的媒体，这有助于确保在变化多端的网络条件下播放流畅。
- en: The other parameters (`maxBufferMs`, `bufferForPlaybackMs`, and `bufferForPlaybackAfterRebufferMs`)
    are set to their default values, which are predefined in `DefaultLoadControl`.
    These parameters control the maximum buffer size, the minimum amount of media
    that must be buffered for playback to start, and the minimum amount of media that
    must be buffered to resume playback after a rebuffer, respectively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数（`maxBufferMs`、`bufferForPlaybackMs` 和 `bufferForPlaybackAfterRebufferMs`）被设置为它们的默认值，这些默认值在
    `DefaultLoadControl` 中预定义。这些参数分别控制最大缓冲区大小、必须缓冲的最小媒体量以开始播放，以及重新缓冲后必须缓冲的最小媒体量。
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to learn more about the aforementioned options, you can find all
    the details in the documentation for **DefaultLoadControl.Builder**: [https://developer.android.com/reference/androidx/media3/exoplayer/DefaultLoadControl.Builder](https://developer.android.com/reference/androidx/media3/exoplayer/DefaultLoadControl.Builder).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于上述选项的信息，你可以在**DefaultLoadControl.Builder**的文档中找到所有详细信息：[https://developer.android.com/reference/androidx/media3/exoplayer/DefaultLoadControl.Builder](https://developer.android.com/reference/androidx/media3/exoplayer/DefaultLoadControl.Builder)。
- en: After configuring the buffer durations, the `build()` method is called to create
    the `DefaultLoadControl` instance with the specified settings.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 配置缓冲持续时间后，调用`build()`方法来创建具有指定设置的`DefaultLoadControl`实例。
- en: This custom `LoadControl` component is then set on a new `ExoPlayer` instance
    through the `setLoadControl` method of `ExoPlayer.Builder`. This step integrates
    the custom buffering strategy with the player, meaning that the player will use
    the specified buffer durations during playback.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过`ExoPlayer.Builder`的`setLoadControl`方法将此自定义`LoadControl`组件设置在新的`ExoPlayer`实例上。这一步将自定义缓冲策略与播放器集成，意味着播放器将在播放期间使用指定的缓冲持续时间。
- en: Finally, the `build` method is called on `ExoPlayer.Builder` to create the `ExoPlayer`
    instance that was configured with the custom `LoadControl` component.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`ExoPlayer.Builder`上调用`build`方法来创建配置了自定义`LoadControl`组件的`ExoPlayer`实例。
- en: Renderers – rendering media to outputs
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染器 – 将媒体渲染到输出
- en: Renderers are the components that output the media to the appropriate destination,
    such as rendering video frames to the screen or audio samples to speakers. ExoPlayer
    uses separate renderers for different types of tracks, allowing for parallel processing
    and rendering of audio, video, and text tracks. This separation enables ExoPlayer
    to support a wide range of media types and formats efficiently. Moreover, developers
    can implement custom renderers to handle non-standard media types or apply special
    processing to media before playback.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染器是输出媒体到适当目的地的组件，例如将视频帧渲染到屏幕或将音频样本渲染到扬声器。ExoPlayer使用不同的渲染器处理不同类型的轨道，允许并行处理和渲染音频、视频和文本轨道。这种分离使得ExoPlayer能够高效地支持广泛的媒体类型和格式。此外，开发者可以实现自定义渲染器来处理非标准媒体类型或在播放前对媒体应用特殊处理。
- en: 'To illustrate this, consider the following example, where a custom renderer
    is being used to apply a grayscale filter to video content:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，考虑以下示例，其中使用自定义渲染器将灰度过滤器应用于视频内容：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `GrayscaleVideoRenderer` class extends ExoPlayer’s `SimpleDecoderVideoRenderer`
    to apply a grayscale effect to video frames during playback. This customization
    allows it to not just decode and display the video but also transform each frame
    to grayscale in real time, enhancing the visual presentation for stylistic choices
    or accessibility.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`GrayscaleVideoRenderer`类扩展了ExoPlayer的`SimpleDecoderVideoRenderer`，在播放期间将灰度效果应用于视频帧。这种定制允许它不仅解码和显示视频，还能实时将每个帧转换为灰度，增强视觉呈现以适应风格选择或无障碍性。'
- en: When initializing, this renderer takes a `Handler` component for thread-safe
    event dispatching, a `VideoRendererEventListener` component for managing video
    events, and an integer that sets the threshold for notifying about dropped frames.
    This setup helps keep the playback smooth and responsive.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时，此渲染器接受一个`Handler`组件用于线程安全的事件分发，一个`VideoRendererEventListener`组件用于管理视频事件，以及一个整数，用于设置通知关于丢失帧的阈值。这种设置有助于保持播放的流畅和响应。
- en: It overrides the `onOutputFormatChanged` method, where it prepares for video
    format changes. This is where adjustments for grayscale processing would be set
    up. The `renderOutputBufferToSurface` method is where the grayscale effect is
    applied to each video frame before they are rendered to the screen.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它重写了`onOutputFormatChanged`方法，在这里它为视频格式变化做准备。这是设置灰度处理调整的地方。`renderOutputBufferToSurface`方法是将灰度效果应用于每个视频帧，在它们被渲染到屏幕之前。
- en: Now that we are familiar with the most important components of ExoPlayer, let’s
    integrate it into our project.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了ExoPlayer最重要的组件，让我们将其集成到我们的项目中。
- en: Integrating ExoPlayer into our project
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ExoPlayer集成到我们的项目中
- en: 'To integrate ExoPlayer, we have to include the necessary library dependencies
    in our version catalog:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成ExoPlayer，我们必须在我们的版本目录中包含必要的库依赖项：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As with every dependency that we have included, we must add them to the `build.gradle`
    file of the module where we are going to use them. In this case, we’ll add it
    them the `build.gradle` file for `:feature:playback`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们包含的每个依赖项一样，我们必须将它们添加到我们将要使用的模块的`build.gradle`文件中。在这种情况下，我们将将其添加到`build.gradle`文件中的`:feature:playback`：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With these two dependencies, we have all the components we need to use ExoPlayer:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个依赖项，我们拥有了使用ExoPlayer所需的所有组件：
- en: '**androidx.media3:media3-exoplayer**: This is the core module of ExoPlayer
    in the Media3 library. It includes the essential classes and interfaces needed
    for media playback functionality. This module provides the fundamental components
    for media playback, including the ExoPlayer interface, media source handling,
    and playback control logic. It is the backbone of media playback in Media3, offering
    high-performance, low-level media playback capabilities.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**androidx.media3:media3-exoplayer**：这是Media3库中ExoPlayer的核心模块。它包括媒体播放功能所需的必需类和接口。此模块为媒体播放提供基本组件，包括ExoPlayer接口、媒体源处理和播放控制逻辑。它是Media3中媒体播放的骨架，提供高性能、低级别的媒体播放功能。'
- en: '**androidx.media3:media3-ui**: This module provides user interface components
    for media playback in the Media3 library. It includes pre-built UI components
    such as **PlayerView** (a view that displays video content and playback controls)
    and other UI elements for controlling media playback. These components can be
    customized or replaced with custom implementations if needed. This module helps
    developers quickly integrate ExoPlayer with a functional UI for media playback.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**androidx.media3:media3-ui**：此模块为Media3库中的媒体播放提供用户界面组件。它包括预构建的UI组件，如**PlayerView**（一个显示视频内容和播放控制的视图）以及其他用于控制媒体播放的UI元素。如果需要，这些组件可以被自定义或替换为自定义实现。此模块帮助开发者快速将ExoPlayer与用于媒体播放的功能性UI集成。'
- en: Now, we’re all set. In the next section, we will build our playback UI and connect
    it with ExoPlayer.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了。在下一节中，我们将构建我们的播放UI并将其与ExoPlayer连接。
- en: Creating the video playback user interface
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视频播放用户界面
- en: 'In this section, we’re going to build the video playback UI and focus on the
    essentials: a title bar, close, play/pause, forward and rewind buttons, a progress
    bar, and a time indicator. We will start by creating the `PlaybackScreen` composable,
    the main composable for this new screen, after which we will add the additional
    components required to make it function.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建视频播放UI，并关注基本要素：标题栏、关闭按钮、播放/暂停、快进和快退按钮、进度条和时间指示器。我们将首先创建`PlaybackScreen`可组合组件，这是此新屏幕的主要可组合组件，之后我们将添加使它功能化的附加组件。
- en: Building PlaybackScreen and its composables
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建`PlaybackScreen`及其可组合组件
- en: 'Let’s start building the `PlaybackScreen` composable:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建`PlaybackScreen`可组合组件：
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We start by declaring a `Box` container that fills the entire screen and sets
    its background to black, mimicking the dark mode typically preferred in video
    playback interfaces. Within this `Box`, we place three key components that constitute
    our playback UI: a top media row, a play/pause button, and a progress bar with
    a time indicator.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明一个填充整个屏幕并设置其背景为黑色的`Box`容器，模仿视频播放界面通常首选的暗黑模式。在这个`Box`容器内，我们放置了构成我们播放UI的三个关键组件：顶部媒体行、播放/暂停按钮和带有时间指示器的进度条。
- en: Here, `TopMediaRow` is positioned at the top center of the screen, likely containing
    the title bar and close button. Then, `PlayPauseButton` is placed right in the
    center of the screen, making it easy for users to start or pause playback with
    a simple tap. Finally, `ProgressBarWithTime` is aligned at the bottom center,
    allowing users to see how much of the video has played and how much is left. Each
    of these components is aligned within the `Box` container using the `Modifier.align`
    method, ensuring they are positioned exactly where we want them in the UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`TopMediaRow`位于屏幕顶部中央，可能包含标题栏和关闭按钮。然后，`PlayPauseButton`放置在屏幕中央，使用户能够通过简单的点击开始或暂停播放。最后，`ProgressBarWithTime`对齐在底部中央，使用户能够看到视频播放了多少以及还剩下多少。每个这些组件都使用`Modifier.align`方法在`Box`容器内对齐，确保它们在UI中的位置正好是我们想要的。
- en: 'Now that we have built the base of the screen, including every composable needed,
    it’s time to build them. We will start with the `TopMediaRow` composable:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了屏幕的基础，包括每个需要的可组合组件，是时候构建它们了。我们将从`TopMediaRow`可组合组件开始：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this `TopMediaRow` composable function, we’re designing the top part of our
    video playback UI, which is specifically tailored for displaying the episode information
    and a close button. This function uses a `Row` layout to arrange its elements
    horizontally across the screen. The modifier that’s applied to this `Row` layout
    ensures it stretches to fill the maximum width of its parent container and applies
    a padding of 20 **density-independent pixels** (**dp**) around its edges for a
    neat, uncluttered look.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`TopMediaRow`可组合函数中，我们正在设计视频播放UI的顶部部分，该部分专门用于显示剧集信息和关闭按钮。此函数使用`Row`布局在其屏幕上水平排列其元素。应用于此`Row`布局的修饰符确保它扩展以填充其父容器的最大宽度，并在其边缘应用20
    **密度无关像素**（**dp**）的填充，以实现整洁、无杂乱的外观。
- en: 'Within the `Row` layout, we use two main components: `Text` and `Icon`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Row`布局中，我们使用两个主要组件：`Text`和`Icon`：
- en: The **Text** component displays the episode information, such as **S1:E1 ‘Pilot’**,
    in white color, making it easily visible against the dark background typical of
    video playback screens.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Text**组件显示剧集信息，例如**S1:E1 ‘Pilot’**，以白色显示，使其在视频播放屏幕典型的深色背景上易于可见。'
- en: The **Icon** component uses the default “close” symbol with its tint also set
    to white to maintain consistency and visibility. The **horizontalArrangement**
    property is set to **Arrangement.SpaceBetween** to ensure the text and icon are
    placed on opposite ends of the row, while **verticalAlignment** keeps them centered
    vertically within the row.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Icon**组件使用默认的“关闭”符号，其色调也设置为白色，以保持一致性和可见性。**horizontalArrangement**属性设置为**Arrangement.SpaceBetween**，以确保文本和图标位于行的两端，而**verticalAlignment**保持它们在行内垂直居中。'
- en: 'Now, let’s move to the next row, which contains the `PlayPauseButton` composable:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到下一行，其中包含`PlayPauseButton`可组合元素：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `PlayPauseButton` composable function will provide the central control mechanism
    for video playback and incorporate rewind, play/pause, and fast-forward actions
    within a single, intuitive interface. This function employs a `Row` layout to
    horizontally align its child elements – the buttons for each control action –
    so that they’re centered both horizontally and vertically.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayPauseButton`可组合函数将为视频播放提供中央控制机制，并在单个直观界面上集成倒退、播放/暂停和快进操作。此函数使用`Row`布局水平对齐其子元素——每个控制动作的按钮——使它们在水平和垂直方向上居中。'
- en: Each button is created using the `IconButton` component. These buttons are spaced
    out with a padding of 20 dp to ensure they’re comfortably tappable without the
    risk of accidental presses. The icons for rewind, play/pause, and fast-forward
    are sized uniformly at 80 dp by 80 dp, making them large enough to be easily tapped
    and visually recognized.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按钮都是使用`IconButton`组件创建的。这些按钮之间有20 dp的填充，以确保它们可以舒适地触摸，而不会意外按下。倒退、播放/暂停和快进图标的大小统一为80
    dp x 80 dp，足够大，易于触摸和视觉识别。
- en: 'The `Icon` components within each `IconButton` are specifically chosen to visually
    represent their respective actions: an arrow pointing backward for rewind, a play
    arrow for play/pause, and an arrow pointing forward for fast-forward, each accompanied
    by a content description for accessibility purposes. The placeholder comments
    within the `onClick` parameters indicate where the functionality for each button
    – rewinding the video by 10 seconds, toggling between playing and pausing, and
    fast-forwarding by 10 seconds – would be implemented.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`IconButton`中的`Icon`组件被特别选择以直观地表示它们各自的操作：一个指向后方的箭头表示倒退，一个播放/暂停的箭头，以及一个指向前方的箭头表示快进，每个操作都伴随着内容描述，以提高可访问性。`onClick`参数中的占位符注释表明每个按钮的功能——通过10秒倒退视频、在播放和暂停之间切换，以及通过10秒快进——将在何处实现。
- en: 'Finally, we have one last composable to build, the `ProgressBarWithTime` composable:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个需要构建的可组合元素，即`ProgressBarWithTime`可组合元素：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This composable is wrapped in a `Row` layout, which spans the maximum width
    available (to accommodate the length of the video) and adjusts its height to wrap
    the content closely, ensuring a tidy appearance with ample padding around its
    edges for a balanced layout.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可组合元素被包裹在一个`Row`布局中，它占据最大可用宽度（以适应视频长度）并调整其高度以紧密包裹内容，确保边缘有足够的填充，从而实现平衡的布局。
- en: 'The core functionality centers around two elements:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 核心功能围绕两个元素展开：
- en: The **Slider** component represents the video’s progress. It uses a mutable
    state initialized at **0.3** (30% progress) to simulate the current position of
    the video playback. This state is interactively adjustable, allowing users to
    seek through the video. The **onValueChange** event updates the progress state,
    reflecting the user’s input. To visually separate the progress bar from the time
    indicator and to ensure the layout remains intuitive, a spacer is inserted between
    these elements, maintaining a clear distinction.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滑动条**组件代表视频的进度。它使用一个初始化为**0.3**（30%进度）的可变状态来模拟视频播放的当前位置。这个状态是可交互调整的，允许用户在视频中搜索。`onValueChange`事件更新进度状态，反映用户的输入。为了在视觉上将进度条与时间指示器分开，并确保布局保持直观，我们在这些元素之间插入了一个空格，以保持清晰的区分。'
- en: Adjacent to the **Slider** component, the **Text** component displays the current
    playback time (set to **22:49** for now, until we integrate the playback functionality)
    in white color. The time is displayed to provide users with exact information
    about how much of the video has been played or how much is left, enhancing the
    user experience by offering precise control over video playback.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**滑动条**组件旁边，**文本**组件以白色显示当前播放时间（目前设置为**22:49**，直到我们集成播放功能）。显示时间是为了向用户提供关于视频播放进度或剩余时间的精确信息，通过提供对视频播放的精确控制来增强用户体验。
- en: Although it may seem that our playback UI is complete, there is still one thing
    that we should take care of before integrating the playback feature itself. When
    we are watching a video, we don’t want all those controls to be occupying the
    screen, making it difficult to watch the content. The controls usually disappear
    automatically after the user hasn’t been interacting with the screen. So, let’s
    implement this change.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的播放界面看起来已经完整，但在集成播放功能本身之前，我们仍有一件事需要关注。当我们观看视频时，我们不希望所有这些控件都占据屏幕，使得观看内容变得困难。通常情况下，当用户没有与屏幕交互时，控件会自动消失。因此，让我们实现这个更改。
- en: Making the controls disappear when playing the content
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在播放内容时使控件消失
- en: 'We know our playback controls should disappear if they haven’t been used for
    a while. The easiest way to do this is to have a value that will indicate if the
    controls should be visible or not, and we will modify its value to `false` when
    the screen has been idle for a time. Let’s make these modifications in the `PlaybackScreen`
    composable, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如果播放控件一段时间内没有被使用，它们应该消失。最简单的方法是有一个值来指示控件是否可见，并且当屏幕空闲一段时间后，我们将修改其值为`false`。让我们在`PlaybackScreen`可组合组件中进行以下修改：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The core idea of these modifications is to track user interaction and use a
    timer to determine when to hide the controls. Initially, as mentioned previously,
    we’ll introduce a state to manage the visibility of the controls. This state will
    likely be a Boolean that toggles between visible and invisible (`true` and `false`)
    based on user interaction and the passage of time without interaction.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修改的核心思想是跟踪用户交互并使用计时器来确定何时隐藏控件。最初，如前所述，我们将引入一个状态来管理控件的可视性。这个状态可能是一个布尔值，根据用户交互和没有交互的时间流逝在可见和不可见（`true`和`false`）之间切换。
- en: For detecting user interactions, we could wrap the `Box` layout that contains
    our playback UI components in a `Modifier.pointerInput` Lambda. Inside this Lambda,
    we can listen for touch input events, and each time a touch is detected, we can
    reset the timer – a coroutine launched with `LaunchedEffect` keyed to the visibility
    state might handle this. This coroutine will wait for 15 seconds of inactivity
    (no touch events detected) before setting the controls’ visibility state to `false`,
    effectively hiding them. To ensure the controls reappear when the user interacts
    with the screen again, the same touch input detection mechanism will set the visibility
    state back to `true`, and the coroutine will restart its countdown.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测用户交互，我们可以将包含我们的播放界面组件的`Box`布局包裹在`Modifier.pointerInput` Lambda中。在这个Lambda内部，我们可以监听触摸输入事件，每次检测到触摸时，我们可以重置计时器——一个使用`LaunchedEffect`启动的协程，其键是可见状态，可能负责处理这一点。这个协程将在检测到15秒的无操作（没有触摸事件）后，将控件的可视状态设置为`false`，从而有效地隐藏它们。为了确保当用户再次与屏幕交互时控件重新出现，相同的触摸输入检测机制将可视状态设置回`true`，并且协程将重新开始倒计时。
- en: Incorporating this functionality requires making modifications to the `PlaybackScreen`
    composable function so that it includes state handling for visibility and can
    modify the `TopMediaRow`, `PlayPauseButton`, and `ProgressBarWithTime` functions
    so that they accept and react to the visibility state. This means each of these
    components will only be rendered when the state indicates they should be visible.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 集成此功能需要修改`PlaybackScreen`组合函数，以便它包括对可见性的状态处理，并可以修改`TopMediaRow`、`PlayPauseButton`和`ProgressBarWithTime`函数，使它们能够接受并响应可见状态。这意味着这些组件只有在状态指示它们应该可见时才会被渲染。
- en: 'Once we’ve finished, our playback UI should look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，我们的播放UI应看起来像这样：
- en: '![Figure 8.1: Finished playback UI (with controls shown)](img/B19443_08_01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1：完成播放UI（显示控件）](img/B19443_08_01.jpg)'
- en: 'Figure 8.1: Finished playback UI (with controls shown)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：完成播放UI（显示控件）
- en: 'When the controls are hidden, it should just show the video content (this isn’t
    visible yet as it hasn’t been implemented):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当控件隐藏时，它应仅显示视频内容（目前尚未可见，因为它尚未实现）：
- en: '![Figure 8.2: Finished playback UI (with controls hidden)](img/B19443_08_02.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：完成播放UI（隐藏控件）](img/B19443_08_02.jpg)'
- en: 'Figure 8.2: Finished playback UI (with controls hidden)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：完成播放UI（隐藏控件）
- en: In this section, we created a UI to display the videos. In the next section,
    we will integrate ExoPlayer so that our app can start playing videos.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们创建了一个用于显示视频的UI。在下一节中，我们将集成ExoPlayer，以便我们的应用可以开始播放视频。
- en: Playing video using ExoPlayer
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ExoPlayer播放视频
- en: In this section, we’ll harness the full power of ExoPlayer so that we can integrate
    it into our newly created video playback UI. Let’s learn how we can do this.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将充分利用ExoPlayer的强大功能，以便将其集成到我们新创建的视频播放UI中。让我们学习如何实现这一点。
- en: Creating PlaybackActivity
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PlaybackActivity
- en: 'We’ll start by creating a new `Activity` for this functionality called `PlaybackActivity`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`PlaybackActivity`的新`Activity`来提供此功能：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This `PlaybackActivity` activity will show our already created `PlaybackScreen()`
    in its content.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`PlaybackActivity`活动将在其内容中显示我们已创建的`PlaybackScreen()`。
- en: 'We also want our playback UI to be always displayed in landscape mode. To do
    so, we’ll configure this activity in the `AndroidManifest.xml` file, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望我们的播放UI始终以横屏模式显示。为此，我们将在`AndroidManifest.xml`文件中配置此活动，如下所示：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are declaring `PlaybackActivity` so that it has landscape as a forced
    screen orientation. This will ensure it will only be rendered in landscape mode,
    despite what orientation the user is holding their phone.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明`PlaybackActivity`，使其具有强制横屏屏幕方向。这将确保它将以横屏模式渲染，无论用户手持手机的方向如何。
- en: Creating PlaybackViewModel
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建PlaybackViewModel
- en: Now, we need to create the player, which is the component that’s responsible
    for managing the media playback. We will create `PlaybackViewModel` to handle
    the ExoPlayer instance and all the logic needed for the view to interact with
    the video player and watch the media.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建播放器，这是负责管理媒体播放的组件。我们将创建`PlaybackViewModel`来处理`ExoPlayer`实例以及视图与视频播放器交互和观看媒体所需的所有逻辑。
- en: 'To start, we are going to build the basic setup logic for our player in `PlaybackViewModel`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将构建`PlaybackViewModel`中播放器的基本设置逻辑：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the start of our `PlaybackViewModel` composable, which is designed to
    manage the media playback functionality of an Android app.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`PlaybackViewModel`组合组件的开始，它被设计用来管理Android应用的媒体播放功能。
- en: The core component of this `ViewModel` is the ExoPlayer instance, which is stored
    in a property named `player`. This `player` property is responsible for all media
    playback operations. However, when `ViewModel` is first created, the player is
    not initialized; it’s declared with `lateinit`, meaning it will be initialized
    later but before any other component needs to access it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ViewModel`的核心组件是`ExoPlayer`实例，它存储在一个名为`player`的属性中。这个`player`属性负责所有媒体播放操作。然而，当`ViewModel`首次创建时，播放器尚未初始化；它使用`lateinit`声明，意味着它将在稍后初始化，但在任何其他组件需要访问它之前。
- en: The `setupPlayer` function is publicly exposed and intended to be called with
    a `Context` object, which provides access to application-specific resources and
    classes. Inside this function, `ExoPlayer.Builder` is used to create an instance
    of `ExoPlayer`. This setup process involves calling the `build()` method on the
    builder, which returns a fully configured `ExoPlayer` instance. Immediately after
    creating this instance, the `also` block executes, calling the `preparePlayerWithMediaSource`
    method with the newly created player.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupPlayer` 函数是公开的，并预期使用一个 `Context` 对象来调用，该对象提供了访问特定应用程序资源和类的权限。在这个函数内部，使用
    `ExoPlayer.Builder` 创建 `ExoPlayer` 的实例。这个设置过程包括在构建器上调用 `build()` 方法，该方法返回一个完全配置的
    `ExoPlayer` 实例。在创建这个实例后，立即执行 `also` 块，使用新创建的播放器调用 `preparePlayerWithMediaSource`
    方法。'
- en: The `preparePlayerWithMediaSource` method is where the actual media source is
    set up. It takes an `ExoPlayer` instance as an argument and configures it to play
    a specific media file. The URL of the media file is defined as [https://example.com/media.mp4](https://example.com/media.mp4).
    To play this media, `ProgressiveMediaSource` is created, which is suitable for
    playing regular media files such as MP4s over HTTP. This media source is then
    attached to the `ExoPlayer` instance using the `setMediaSource` method, and `prepare()`
    is called to prepare the player for playback. It’s worth noting that this method
    is marked as private, meaning it’s intended to be used only within the `PlaybackViewModel`
    class. The `@OptIn(UnstableApi::class)` annotation indicates that this method
    uses APIs that are not yet stable and may change in the future.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`preparePlayerWithMediaSource` 方法是设置实际媒体源的地方。它接受一个 `ExoPlayer` 实例作为参数，并将其配置为播放特定的媒体文件。媒体文件的
    URL 定义为 [https://example.com/media.mp4](https://example.com/media.mp4)。为了播放此媒体，创建了一个
    `ProgressiveMediaSource`，它适合通过 HTTP 播放常规媒体文件，如 MP4。然后使用 `setMediaSource` 方法将此媒体源附加到
    `ExoPlayer` 实例，并调用 `prepare()` 准备播放器。值得注意的是，此方法被标记为私有，意味着它仅打算在 `PlaybackViewModel`
    类中使用。`@OptIn(UnstableApi::class)` 注解表示此方法使用尚未稳定的 API，将来可能会更改。'
- en: Lastly, the `onCleared` method overrides a `ViewModel` life cycle callback that
    gets called when `ViewModel` is about to be destroyed. This method releases the
    `ExoPlayer` instance by calling `player.release()`, ensuring that resources are
    freed and preventing memory leaks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onCleared` 方法覆盖了 `ViewModel` 生命周期回调，当 `ViewModel` 即将销毁时被调用。此方法通过调用 `player.release()`
    释放 `ExoPlayer` 实例，确保释放资源并防止内存泄漏。
- en: 'Now, we’ll add the view that will render the media content in `PlaybackScreen`
    and connect it to the player:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在 `PlaybackScreen` 中添加渲染媒体内容的视图并将其连接到播放器：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the `PlaybackScreen` composable, we obtain an instance of `PlaybackViewModel`
    using `hiltViewModel()`. This `ViewModel` is central to managing the media playback
    life cycle and interactions within the app.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlaybackScreen` 组合组件中，我们使用 `hiltViewModel()` 获取 `PlaybackViewModel` 的实例。这个
    `ViewModel` 对于管理媒体播放的生命周期和应用程序内的交互至关重要。
- en: Once `ViewModel` is ready, we call `viewModel.setupPlayer(LocalContext.current)`
    to initialize `ExoPlayer`. This setup is crucial because it prepares the player
    with the appropriate Android context, allowing it to load and play media files
    effectively. Ensuring that ExoPlayer is initialized with the current context helps
    manage resources efficiently, which is essential for smooth playback.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `ViewModel` 准备就绪，我们调用 `viewModel.setupPlayer(LocalContext.current)` 来初始化
    `ExoPlayer`。这个设置至关重要，因为它使用适当的 Android 上下文准备播放器，使其能够有效地加载和播放媒体文件。确保 `ExoPlayer`
    使用当前上下文初始化有助于有效地管理资源，这对于流畅的播放至关重要。
- en: The UI component responsible for displaying the video is `VideoPlayerComposable`.
    We pass the initialized player from `ViewModel` to this composable, which is placed
    inside a `Box` layout. This layout is configured to fill the maximum size of its
    parent and sets a black background to emphasize the video content. The `Box` layout
    also handles user interactions, listening for tap gestures to toggle the visibility
    of playback controls. When a tap is detected, it makes the controls visible and
    starts a coroutine that hides these controls again after 15 seconds if no further
    interaction occurs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 负责显示视频的 UI 组件是 `VideoPlayerComposable`。我们将从 `ViewModel` 中初始化的播放器传递给这个组合组件，它被放置在一个
    `Box` 布局中。这个布局被配置为填充其父级的最大尺寸，并设置黑色背景以强调视频内容。`Box` 布局还处理用户交互，监听触摸手势以切换播放控制器的可见性。当检测到触摸时，它会使控制器可见，并启动一个协程，如果在
    15 秒内没有进一步的交互，则再次隐藏这些控制器。
- en: Inside the `Box` layout, conditional logic checks the value of `isControlsVisible`.
    If `true`, playback controls are rendered on top of the video. This allows users
    to interact with the video, such as pausing, skipping, or adjusting the volume,
    but only when they choose to display the controls.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Box` 布局内部，条件逻辑检查 `isControlsVisible` 的值。如果为 `true`，则播放控制器将渲染在视频上方。这允许用户与视频交互，例如暂停、跳过或调整音量，但仅在他们选择显示控件时。
- en: Finally, we will explore how to implement `VideoPlayerComposable` so that we
    can effectively utilize the player to render the video while responding dynamically
    to user interactions with playback controls.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何实现 `VideoPlayerComposable`，以便我们能够有效地利用播放器渲染视频，同时动态响应用户对播放控制器的交互。
- en: 'Let’s see how we can implement this new composable. Unfortunately, at the time
    of writing, the library doesn’t provide a Jetpack Compose option to show the player,
    so we need to create one inside an `AndroidView` composable, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这个新的可组合项。不幸的是，在撰写本文时，该库没有提供 Jetpack Compose 选项来显示播放器，因此我们需要在 `AndroidView`
    可组合项内部创建一个，如下所示：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `VideoPlayerComposable` function takes two parameters:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoPlayerComposable` 函数接受两个参数：'
- en: The **Modifier** instance allows you to customize the layout or appearance of
    this composable when it’s used elsewhere in your UI
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Modifier** 实例允许你在 UI 的其他地方使用此可组合项时自定义其布局或外观。'
- en: The **ExoPlayer** instance is the media player that will handle the actual playback
    of the video content
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExoPlayer** 实例是处理视频内容实际播放的媒体播放器。'
- en: Inside the `AndroidView` composable, the factory Lambda is where the traditional
    Android view is created – in this case, `PlayerView`. Here, `PlayerView` is a
    view provided by the `ExoPlayer` library to display video content and playback
    controls. Here, it’s initialized with the application context (`ctx`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AndroidView` 可组合项内部，工厂 Lambda 是创建传统 Android 视图的地方——在本例中是 `PlayerView`。在这里，`PlayerView`
    是由 `ExoPlayer` 库提供的用于显示视频内容和播放控制器的视图。在这里，它使用应用程序上下文 (`ctx`) 进行初始化。
- en: 'After creating `PlayerView`, some properties are set on it:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `PlayerView` 后，一些属性被设置在其上：
- en: Here, **layoutParams** is set to **MATCH_PARENT** for both width and height,
    making **PlayerView** fill the entire space allocated to it. This ensures that
    the video will take up as much space as possible, typically the entire screen
    or the parent container.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这里，`layoutParams` 被设置为 **MATCH_PARENT**，用于宽度和高度，使 **PlayerView** 填充分配给它的整个空间。这确保视频将占用尽可能多的空间，通常是整个屏幕或父容器。
- en: Then, **setPlayer(player)** attaches the passed **ExoPlayer** instance to **PlayerView**.
    This connection is what allows the video loaded in **ExoPlayer** to be displayed
    in this view.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，**setPlayer(player)** 将传递的 **ExoPlayer** 实例附加到 **PlayerView** 上。这种连接允许在 **ExoPlayer**
    中加载的视频显示在这个视图中。
- en: Finally, **useController** is set to **false**, indicating that the default
    playback controls provided by **PlayerView** (such as play, pause, and seek bar)
    will not be used. We will implement our own controls next.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**useController** 被设置为 **false**，表示不会使用 **PlayerView** 提供的默认播放控制器（如播放、暂停和进度条）。我们将在下一部分实现自己的控件。
- en: Finally, the update Lambda of `AndroidView` is where you can update the properties
    of `PlayerView` based on changes to the composable’s state or properties.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`AndroidView` 的更新 Lambda 是你可以根据可组合项的状态或属性的变化来更新 `PlayerView` 属性的地方。
- en: With these changes, our player is ready to start rendering the media via `ViewPlayer`.
    But we still have work to do. We need to bind the already developed controls to
    the player controls and keep the time and the progress bar of the video updated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们的播放器已经准备好通过 `ViewPlayer` 开始渲染媒体。但我们还有工作要做。我们需要将已经开发的控件绑定到播放器控件上，并保持视频的时间和进度条更新。
- en: Connecting the controls with ExoPlayer
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将控件与 ExoPlayer 连接
- en: 'Let’s start modifying the `PlayPauseButton` composable. In this case, we will
    need to bind the control functions with the ViewModel:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改 `PlayPauseButton` 可组合项开始。在这种情况下，我们需要将控制函数与 ViewModel 绑定：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, the `PlayPauseButton` composable takes several parameters, each serving
    a specific purpose within the UI component:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`PlayPauseButton` 可组合项接受几个参数，每个参数在 UI 组件中都有特定的用途：
- en: '**isPlaying** (Boolean): This parameter indicates the current playback state
    of the video. It is used to determine which icon to display on the play/pause
    button – either a play icon when the video is paused or a pause icon when the
    video is actively playing. This allows for intuitive control interactions from
    the user’s perspective.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**isPlaying**（布尔值）：此参数指示视频的当前播放状态。它用于确定在播放/暂停按钮上显示哪个图标——当视频暂停时显示播放图标，当视频正在播放时显示暂停图标。这使用户能够从用户的角度进行直观的控制交互。'
- en: '**onRewind** (Lambda function): This is a callback function that’s triggered
    when the user presses the rewind button. It should contain the logic for what
    happens when the video is rewound, such as moving the playback position backward
    by a fixed amount.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onRewind**（Lambda 函数）：这是一个在用户按下倒退按钮时触发的回调函数。它应该包含视频倒退时发生的逻辑，例如通过固定量向后移动播放位置。'
- en: '**onPlayPause** (Lambda function): This function is executed when the play/pause
    button is pressed. It handles toggling between playing and pausing the video based
    on the current state, facilitating seamless user control over video playback.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onPlayPause**（Lambda 函数）：当按下播放/暂停按钮时执行此函数。它根据当前状态处理在播放和暂停之间切换视频，使用户能够无缝控制视频播放。'
- en: '**onFastForward** (Lambda function): Similar to **onRewind**, this callback
    is activated when the fast-forward button is pressed. It controls the logic for
    fast-forwarding the video, advancing the playback position forward by a predetermined
    interval.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onFastForward**（Lambda 函数）：类似于 **onRewind**，当按下快进按钮时激活此回调。它控制快进视频的逻辑，通过预定的间隔向前移动播放位置。'
- en: '**modifier** (modifier): This parameter allows the appearance and layout of
    the button row within the composable to be customized. As we’ve seen previously,
    wt can be used to apply padding, define alignment, and set dimensions.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**modifier**（修饰符）：此参数允许自定义可组合组件内按钮行的外观和布局。正如我们之前所看到的，可以使用它来应用填充、定义对齐方式和设置尺寸。'
- en: 'Now that we’ve added these new parameters, we need to pass them from the parent
    composable. Here’s how you can include and invoke this composable with the required
    parameters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了这些新参数，我们需要从父可组合组件中传递它们。以下是包含并调用此可组合组件所需参数的方法：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, we have bound every Lambda parameter to `ViewModel` functions
    (that are yet to be implemented) and we are providing an `isPlaying` state to
    reflect the current playing status of the player.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经将每个 Lambda 参数绑定到（尚未实现的）`ViewModel` 函数上，并且我们提供了一个 `isPlaying` 状态来反映播放器的当前播放状态。
- en: 'Now, let’s implement those functions in `ViewModel`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `ViewModel` 中实现这些函数：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we have defined a private mutable state flow, `_isPlaying`, to track
    whether the video is currently playing. This same state flow is exposed as a public
    `MutableStateFlow` component named `isPlaying`. In this case, `isPlaying` acts
    as a single source of truth for the playback state, allowing our UI components
    to update reactively based on whether the video is playing or paused.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个私有可变状态流 `_isPlaying`，用于跟踪视频是否正在播放。这个相同的状态流被公开作为名为 `isPlaying` 的 `MutableStateFlow`
    组件。在这种情况下，`isPlaying` 作为播放状态的单一真相来源，允许我们的 UI 组件根据视频是否播放或暂停进行响应式更新。
- en: The `setupPlayer` function, which we’ve already implemented, initializes the
    `ExoPlayer` instance. Now, it also attaches a listener to respond to playback
    events. The listener added overrides several methods, but most importantly, `onIsPlayingChanged`
    is used to update `_isPlaying.value` based on the player’s state.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现的 `setupPlayer` 函数初始化了 `ExoPlayer` 实例。现在，它还附加了一个监听器来响应播放事件。添加的监听器覆盖了多个方法，但最重要的是，使用
    `onIsPlayingChanged` 来根据播放器的状态更新 `_isPlaying.value`。
- en: 'We’ve also included the functions to manipulate playback that we were already
    being called from the composable:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了从可组合组件中已经调用的操作播放功能：
- en: '**togglePlayPause**: This checks if the player is currently playing and toggles
    between play and pause. This method directly controls the player’s state, making
    it the primary way the user interacts with the playback.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**togglePlayPause**：此方法检查播放器是否正在播放，并在播放和暂停之间切换。此方法直接控制播放器的状态，成为用户与播放交互的主要方式。'
- en: '**rewind** and **fastForward**: These options calculate a new position based
    on the current playback position and seek to that position. The **rewind** function
    moves the playback position backward by 10 seconds, while **fastForward** moves
    it forward by 10 seconds. These methods enhance user control over the video, allowing
    for quick navigation within the content.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**倒退**和**快进**：这些选项基于当前播放位置计算新位置并跳转到该位置。**倒退**函数将播放位置向后移动10秒，而**快进**函数将播放位置向前移动10秒。这些方法增强了用户对视频的控制，允许在内容中快速导航。'
- en: 'Now, let’s connect the next (and last) composable, `ProgressBarWithTime`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们连接下一个（也是最后一个）可组合的组件，`ProgressBarWithTime`：
- en: '[PRE22]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The function now accepts three new parameters: `currentPosition` and `duration`
    to represent the current playback position and the total length of the video in
    milliseconds, respectively, and an `onSeek` Lambda function that defines what
    to do when the user seeks to a new position.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 函数现在接受三个新参数：`currentPosition` 和 `duration` 分别表示当前播放位置和视频总长度（以毫秒为单位），以及一个定义当用户搜索到新位置时要执行的操作的
    `onSeek` Lambda 函数。
- en: The `progress` variable calculates how far along the video is, represented as
    a float between 0 and 1\. This is achieved by dividing `currentPosition` by `duration`,
    which specifies a proportion of the video that has been played. If the duration
    is 0 (to avoid division by zero), progress is set to `0f`, indicating no progress.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`progress` 变量计算视频的进度，表示为介于0和1之间的浮点数。这是通过将 `currentPosition` 除以 `duration` 来实现的，`duration`
    指定了已播放视频的比例。如果持续时间是0（为了避免除以零），进度设置为 `0f`，表示没有进度。'
- en: The `formattedTime` string provides a user-friendly display of the current position
    and total duration of the video by using a custom formatting function, `formatTime()`
    (as we’ll see next), to convert milliseconds into a more readable format (HH:MM:SS).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`formattedTime` 字符串通过使用自定义格式化函数 `formatTime()`（我们将在下面看到）将毫秒转换为更易读的格式（HH:MM:SS）来提供用户友好的当前位置和视频总持续时间显示。'
- en: Finally, slider progress is now bound to the progress value, and its `onValueChange`
    event is wired to call `onSeek` with the new position when the user interacts
    with it. This allows the user to seek through the video by moving the slider,
    with the `onSeek` function updating the video playback position accordingly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，滑块进度现在绑定到进度值，并且其 `onValueChange` 事件连接到调用 `onSeek` 并传递新位置，当用户与其交互时。这允许用户通过移动滑块来搜索视频，`onSeek`
    函数相应地更新视频播放位置。
- en: 'Regarding the aforementioned `formatTime` function, it will work as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面提到的 `formatTime` 函数，它将按以下方式工作：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The input to the function is `millis`, which represents the time duration in
    milliseconds. This is a common way to represent time in programming because it’s
    precise. However, milliseconds aren’t very human-friendly, so the first step inside
    the function is to convert milliseconds into total seconds by dividing by `1000`.
    We’re doing this because there are 1,000 milliseconds in a second.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的输入是 `millis`，它表示以毫秒为单位的时间长度。这是在编程中表示时间的一种常见方式，因为它很精确。然而，毫秒对人类来说并不友好，所以函数中的第一步是将毫秒转换为总秒数，通过除以
    `1000` 来实现。我们这样做是因为一秒钟有1,000毫秒。
- en: Once you have the total seconds, the function calculates hours, minutes, and
    seconds. It divides the total seconds by `3600` (the number of seconds in an hour)
    to get hours. The remainder from that division (using the modulo operator, `%`)
    is then used to calculate minutes by dividing by `60` (since there are 60 seconds
    in a minute). Finally, the remainder from the minutes calculation gives you the
    seconds.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦得到总秒数，函数计算小时、分钟和秒。它将总秒数除以 `3600`（一小时中的秒数）来得到小时。然后，使用模运算符（`%`）从那个除法中得到的余数用于通过除以
    `60`（因为一分钟有60秒）来计算分钟。最后，分钟计算的余数给你秒数。
- en: 'The last part is where the function formats the time string. If the duration
    includes hours (that is, if the duration is longer than 60 minutes), it formats
    the time as HH:MM:SS using `String.format()`. This method is used to create a
    formatted string with placeholders (`%02d`) for hours, minutes, and seconds. Here’s
    a breakdown of the format:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的部分是函数格式化时间字符串的地方。如果持续时间包括小时（即，如果持续时间超过60分钟），它将使用 `String.format()` 将时间格式化为
    HH:MM:SS。这种方法用于创建带有占位符（`%02d`）的格式化字符串，用于小时、分钟和秒。以下是格式的分解：
- en: The **%** symbol indicates the start of a format specifier.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**%** 符号表示格式说明符的开始。'
- en: The **0** specifies that the number should be padded with leading zeros if it
    has fewer digits than specified.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0** 表示如果数字的位数少于指定位数，则应使用前导零进行填充。'
- en: The **2** indicates that the number should be at least two digits long.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 表示数字至少应有两个数字长。'
- en: The **d** stands for ‘decimal’ and specifies that the placeholder is for an
    integer number.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**d** 代表“十进制”，指定占位符用于整数。'
- en: So, `%02d` ensures that the number is at least two digits long and padded with
    zeros if necessary.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`%02d` 确保数字至少有两个数字长，并在必要时用零填充。
- en: 'Going back to the composable, we also need to modify where `ProgressBarWithTime`
    is called in `PlaybackScreen`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 回到可组合组件，我们还需要修改在 `PlaybackScreen` 中调用 `ProgressBarWithTime` 的位置：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see, we have bound the `seekTo` Lambda parameter to a `ViewModel`
    function (that is yet to be implemented) and we are also providing `duration`
    and `currentPosition` states.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们将 `seekTo` Lambda 参数绑定到一个（尚未实现）ViewModel 函数上，并且我们还在提供 `duration` 和 `currentPosition`
    状态。
- en: Now, let’s modify `PlaybackViewModel` so that we can implement the pending functions
    related to the progress bar.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `PlaybackViewModel` 以便我们可以实现与进度条相关的待定函数。
- en: Implementing the video controls in PlaybackViewModel
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 PlaybackViewModel 中实现视频控制
- en: 'The last step to make the progress bar work is to modify `PlaybackViewModel`.
    We can add the necessary functionality to control the progress bar like so:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使进度条正常工作的最后一步是修改 `PlaybackViewModel`。我们可以添加控制进度条所需的功能，如下所示：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With that, we’ve declared private mutable state flows called `_currentPosition`
    and `_duration` for tracking the current playback position and the total video
    duration, respectively. These are exposed as read-only StateFlows to the rest
    of the app, ensuring that the UI components can observe these values and react
    to changes, but cannot modify them directly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已声明名为 `_currentPosition` 和 `_duration` 的私有可变状态流，分别用于跟踪当前播放位置和视频的总时长。这些作为只读
    StateFlows 暴露给应用程序的其他部分，确保 UI 组件可以观察这些值并对变化做出反应，但不能直接修改它们。
- en: 'The listener in the `setupPlayer` function has also been modified to include
    functionality to keep the two states, `_currentPosition` and `_duration`. The
    following modifications have been made to the listener callbacks:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupPlayer` 函数中的监听器也已修改，包括保持两个状态（`_currentPosition` 和 `_duration`）的功能。对监听器回调进行了以下修改：'
- en: '**onIsPlayingChanged**: This updates the **_isPlaying** state and controls
    the start and stop of a job, which periodically updates the current playback position.
    This is essential for keeping the UI in sync with the actual playback.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onIsPlayingChanged**：此更新 **_isPlaying** 状态并控制作业的启动和停止，该作业定期更新当前播放位置。这对于使
    UI 与实际播放保持同步是必不可少的。'
- en: '**onPlaybackStateChanged**: This checks if the player is ready or buffering
    and updates the **_duration** state with the total duration of the video. This
    is necessary for setting up the progress bar.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onPlaybackStateChanged**：此检查播放器是否准备就绪或正在缓冲，并使用视频的总时长更新 **_duration** 状态。这对于设置进度条是必要的。'
- en: '**onPositionDiscontinuity** and **onTimelineChanged**: These ensure that changes
    in the video playback position or timeline (such as seeking or switching to another
    video) update **_currentPosition** and **_duration** correctly.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**onPositionDiscontinuity** 和 **onTimelineChanged**：这些确保视频播放位置或时间线（如快进或切换到另一视频）的变化能够正确更新
    **_currentPosition** 和 **_duration**。'
- en: Then, the new function, `startPeriodicProgressUpdate`, launches a coroutine
    that periodically updates the `_currentPosition` state with the player’s current
    position. This loop runs every second, providing a near-real-time update of the
    playback position to the UI. It’s crucial for making the progress bar move smoothly
    as the video plays.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，新的函数 `startPeriodicProgressUpdate` 启动一个协程，定期使用播放器的当前位置更新 `_currentPosition`
    状态。这个循环每秒运行一次，为 UI 提供近实时的播放位置更新。这对于使进度条在视频播放时平滑移动至关重要。
- en: Building on this functionality, the `seekTo` function allows the video to be
    seeked to a new position. It checks that the position is within the bounds of
    the video before calling `seekTo` on the ExoPlayer instance, effectively letting
    the user jump to different parts of the video through the progress bar.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此功能，`seekTo` 函数允许视频跳转到新的位置。它在调用 ExoPlayer 实例的 `seekTo` 之前检查位置是否在视频的范围内，从而让用户可以通过进度条跳转到视频的不同部分。
- en: Finally, the `onCleared` method has been modified to cancel the new `progressUpdateJob`
    composable in case we have to release the resources.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onCleared`方法已被修改，以便在需要释放资源的情况下取消新的`progressUpdateJob`可组合组件。
- en: With these changes, our video player is ready. We just have to modify the hardcoded
    media URL in `PlaybackViewModel` (`val mediaUrl = "https://example.com/media.mp4"`)
    so that we can provide a URL to an actual video and let the magic happen! At this
    point, we should see the playback of the provided video.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改后，我们的视频播放器已经准备好了。我们只需修改`PlaybackViewModel`中的硬编码媒体URL（`val mediaUrl = "https://example.com/media.mp4"`），以便我们可以提供一个实际视频的URL，并让魔法发生！在这个时候，我们应该看到提供的视频的播放。
- en: In the last section of this chapter, we are going to enhance the functionality
    of our video player a little bit further by learning how to add subtitles.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将通过学习如何添加字幕来进一步增强我们的视频播放器的功能。
- en: Adding subtitles to the video player
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向视频播放器添加字幕
- en: In this section, we’ll be adding subtitles to our video player. Subtitles are
    crucial for making videos accessible to everyone, but they can also be great for
    watching videos in noisy environments or when you need to keep the volume down.
    In this section, we’ll learn how to load and display subtitles alongside our video
    while handling various formats and ensuring they sync up perfectly with our content.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向我们的视频播放器添加字幕。字幕对于使视频对每个人可访问至关重要，但它们在嘈杂的环境中观看视频或需要降低音量时也非常有用。在本节中，我们将学习如何在视频的同时加载和显示字幕，并处理各种格式，确保它们与我们的内容完美同步。
- en: 'To add subtitles, follow these steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加字幕，请按照以下步骤操作：
- en: Create a MediaSource for your video file, just as you would for any video playback
    in ExoPlayer. We did this in the previous section.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的视频文件创建一个MediaSource，就像在ExoPlayer中播放任何视频一样。我们在上一节中做了这件事。
- en: Create a MediaSource for your subtitle file. This often involves using **SingleSampleMediaSource**
    for single subtitle files or similar approaches for different formats.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的字幕文件创建一个MediaSource。这通常涉及使用**SingleSampleMediaSource**来处理单个字幕文件或类似方法来处理不同格式。
- en: Use **MergingMediaSource** to combine the video and subtitle sources. This merged
    source is then passed to the ExoPlayer instance for playback.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**MergingMediaSource**来合并视频和字幕源。然后将此合并源传递给ExoPlayer实例进行播放。
- en: Initialize ExoPlayer with the merged source; it will handle the playback of
    both video and subtitles.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用合并的源初始化ExoPlayer；它将处理视频和字幕的播放。
- en: 'ExoPlayer supports a wide range of subtitle formats so that it can cater to
    various use cases and standards. Some of the most popular formats are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ExoPlayer支持广泛的字幕格式，以便满足各种用例和标准。以下是一些最受欢迎的格式：
- en: '**WebVTT** (**.vtt**): A widely used format for HTML5 video subtitles that’s
    supported by many web browsers and platforms:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WebVTT**（**.vtt**）：一个广泛使用的HTML5视频字幕格式，被许多网络浏览器和平台支持：'
- en: '**Advantages**: WebVTT is extensively supported across most modern web browsers,
    making it ideal for online streaming services. It offers options for styling,
    positioning, and cue settings, allowing for a customizable viewing experience.'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：WebVTT在大多数现代网络浏览器中得到广泛支持，使其成为在线流媒体服务的理想选择。它提供了样式、定位和提示设置选项，允许自定义观看体验。'
- en: '**Disadvantages**: Compared to simpler formats such as SRT, WebVTT’s additional
    features can make it more complex to create and edit. Also, different platforms
    and browsers may interpret styling and formatting cues differently, leading to
    inconsistent presentations.'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：与SRT等更简单的格式相比，WebVTT的附加功能可能会使其创建和编辑变得更加复杂。此外，不同的平台和浏览器可能对样式和格式提示的解释不同，导致展示不一致。'
- en: '**SubRip** (**.srt**): One of the most common subtitle formats that’s simple
    in structure and supported by a wide range of media players:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SubRip**（**.srt**）：一种结构简单且被广泛媒体播放器支持的常见字幕格式：'
- en: '**Advantages**: The structure of SRT files is straightforward, making them
    easy to create, edit, and debug. It is also supported by almost all media players,
    making it universally applicable for offline and online video playback.'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优点**：SRT文件的结构简单，使其易于创建、编辑和调试。它也几乎被所有媒体播放器支持，使其适用于离线和在线视频播放的通用格式。'
- en: '**Disadvantages**: It provides basic text formatting, which limits its ability
    to customize the appearance of subtitles.'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺点**：它提供基本的文本格式化，这限制了自定义字幕外观的能力。'
- en: 'To give you an idea of what one of these formats looks like, here’s an example
    of the content of a SubRip (`.``srt`) file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解这种格式的外观，以下是一个SubRip（`.srt`）文件内容的示例：
- en: '[PRE26]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each block starts with a sequence number (for example, 1, 2, 3, and so on),
    followed by the time range on the next line (start time --> end time), and then
    the text of the subtitle. This text can be one or more lines and is followed by
    a blank line to indicate the end of the subtitle entry. This format can be edited
    with any text editor and saved with the `.``srt` extension.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块都从序列号开始（例如，1、2、3等等），接着是下一行的时序范围（开始时间 --> 结束时间），然后是副标题的文本。这段文本可以是一行或多行，并且后面跟着一个空行来表示副标题条目的结束。这种格式可以用任何文本编辑器进行编辑，并保存为`.srt`扩展名。
- en: 'Now that we know a bit more about how to add subtitles to a video in ExoPlayer,
    let’s add them by default to our already-implemented playback functionality. We
    just need to change the logic for the player setup in `PlaybackViewModel`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何在ExoPlayer中添加字幕有了更多的了解，让我们将它们默认添加到我们已实现的播放功能中。我们只需要更改`PlaybackViewModel`中播放器设置的逻辑：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we modified the already existing `preparePlayerWithMediaSource`
    function. We started by adding a new media with the subtitles URL.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们修改了已经存在的`preparePlayerWithMediaSource`函数。我们首先添加了一个带有字幕URL的新媒体。
- en: Then we created `MediaSource` for the subtitles, and we created a `MediaItem.SubtitleConfiguration`
    object from the subtitle URL (`subtitleUrl`). This configuration specifies how
    the subtitle should be loaded and displayed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为字幕创建了`MediaSource`，并从字幕URL（`subtitleUrl`）创建了一个`MediaItem.SubtitleConfiguration`对象。此配置指定了字幕应该如何加载和显示。
- en: Then, `SingleSampleMediaSource` is created for the subtitle configuration. Here,
    `SingleSampleMediaSource` is used because subtitle files are typically a single
    piece of content rather than streamed content. The `createMediaSource` method
    here is slightly different from the video one; it takes the subtitle configuration
    and a duration parameter, which is set to `C.TIME_UNSET` to indicate that the
    duration is unknown or should be determined from the content itself.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为字幕配置创建了一个`SingleSampleMediaSource`。在这里，使用`SingleSampleMediaSource`是因为字幕文件通常是单一的内容，而不是流式内容。这里的`createMediaSource`方法与视频方法略有不同；它接受字幕配置和一个持续时间参数，该参数设置为`C.TIME_UNSET`，表示持续时间未知或应从内容本身确定。
- en: Once both the video and subtitle sources have been created, they’re combined
    into a single source using `MergingMediaSource`. This merged source tells `ExoPlayer`
    to play the video with the subtitles overlaying it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了视频和字幕源，它们就通过`MergingMediaSource`合并成一个单一的源。这个合并源告诉`ExoPlayer`以字幕叠加的方式播放视频。
- en: Finally, the merged source is set on the `ExoPlayer` instance with `setMediaSource`,
    and `prepare()` is called. This action causes `ExoPlayer` to load the media and
    get ready for playback. When the video plays, the subtitles from the specified
    SRT file will be displayed at the correct times, as defined in the file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过`setMediaSource`将合并的源设置在`ExoPlayer`实例上，并调用`prepare()`。这个动作导致`ExoPlayer`加载媒体并准备播放。当视频播放时，根据文件中定义的正确时间显示指定的SRT文件中的字幕。
- en: 'The following figure shows the subtitles added:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了添加的字幕：
- en: '![Figure 8.3: Playback with subtitles](img/B19443_08_03.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3：带字幕的播放](img/B19443_08_03.jpg)'
- en: 'Figure 8.3: Playback with subtitles'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：带字幕的播放
- en: With that, our player is ready to play back videos. By including subtitles,
    it offers a more accessible experience for our users.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的播放器就准备好播放视频了。通过包含字幕，它为我们的用户提供了更易于访问的体验。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we tackled the essentials of adding video playback in our Android
    app while focusing on the powerful ExoPlayer library. We started by comparing
    media options in Android before quickly realizing ExoPlayer’s superiority due
    to its flexibility and wide format support. This set the stage for us to learn
    how ExoPlayer fits into an app and how to use it for playing videos smoothly.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了在Android应用中添加视频播放的基本要素，同时关注功能强大的ExoPlayer库。我们首先比较了Android中的媒体选项，然后很快意识到由于它的灵活性和广泛格式支持，ExoPlayer的优越性。这为我们学习ExoPlayer如何适应应用以及如何使用它来流畅地播放视频奠定了基础。
- en: We then walked through building a user-friendly video playback interface, covering
    everything from setting up ExoPlayer to managing playback controls. Finally, we
    explored adding subtitles to make your videos accessible to a wider audience,
    highlighting ExoPlayer’s capability to enhance inclusivity.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讲解了如何构建一个用户友好的视频播放界面，涵盖了从设置ExoPlayer到管理播放控制的所有内容。最后，我们探讨了添加字幕以使您的视频对更广泛的观众可访问，并突出了ExoPlayer增强包容性的能力。
- en: Now that you have a solid grasp of video playback using ExoPlayer, you’re ready
    to elevate your app with picture-in-picture mode and media casting.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对使用ExoPlayer进行视频播放有了扎实的掌握，您就可以通过添加画中画模式和媒体投射功能来提升您的应用了。
