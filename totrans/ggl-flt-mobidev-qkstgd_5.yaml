- en: Widening our Flutter Horizons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will first discuss networking in Flutter by building a simple
    application that fetches data from the server using JSON. Every app is required
    to have accessibility features to cater to mass users, and we will cover this
    in the accessibility options. In the final section, we will talk about localization
    for having your app grow globally, supporting multiple languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Networking in Flutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessibility in Flutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internation­alizing Flutter apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking in Flutter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is the backbone of any app, and knowing how to make network calls
    is crucial. Working with networking calls in Flutter is simple and follows a streamline
    standard method. Flutter libraries and methods make it easier for developers to
    build apps with networking. This chapter will focus on making networking requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like many platforms, Flutter supports the use of shared packages that are contributed
    by the developers to the Flutter and Dart ecosystem. This facilitates development
    by making developers build apps quickly rather than worry about developing the
    code from scratch. Some of the most commonly used packages include, but are not
    limited to: making network requests (HTTP); using device APIs, such as device
    information (`device_info`); finding information and controlling the camera, including
    the support for previews of the camera feed and the captured image (camera); finding
    and using the location of the device using GPS coordinates (geolocator); and using
    third-party platform SDKs (such as Firebase). You can find the complete list of
    packages supported by Flutter at [https://pub.dartlang.org/packages](https://pub.dartlang.org/packages).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding existing package dependency to an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have decided on the set of packages that you want to include, follow
    these steps to include the dependency. For the purpose of this example, we have
    chosen HTTP package to an app. This package contains a set of high-level functions
    and classes, which can help developers consume HTTP resources while working on
    the app, and it is platform independent. It supports both the command line and
    the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the dependency: Open the `pubspec.yaml` file located inside your app
    folder, and add `http:` under dependencies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All packages have a version number, specified in their `pubspec.yaml` file.
    The current version of the package is displayed next to the package name. When
    you mention `Plugin_Name_1:`, it is interpreted as `Plugin_Name_1: any`. This
    indicates that any version of the package may be used. It is advisable to use
    a specific version to ensure that the app doesn''t break when it is updated.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install the package where the dependency has been added. You can install it
    by running the `flutter packages get` command. If you are using Android Studio/IntelliJ,
    you can also click the Package Get option in the action ribbon at the top of `pubspecs.yaml`.
    If you are using VS code, click Get Packages located on the right-hand side of
    the action ribbon at the top of `pubspec.yaml`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Include the corresponding `import` statement in your Dart code. In this case,
    it is `import package:http/http.dart`. In case you have missed anything, you can
    always cross-check using the Installation tab option on the package page on `Pub`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, it is better if you stop and restart the app to avoid errors
    such as `MissingPluginException` when using the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrading existing package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run `flutter packages get` (this will be `Packages Get` in IntelliJ)
    for the first time after adding a package in the `pubspec.yaml` file, Flutter
    will save the version found in the `pubspec.lock lockfile` file. To upgrade the
    package, you can run the Flutter packages upgrade (`Upgrade dependencies` in IntelliJ).
    Using this command, Flutter will retrieve the highest available version of the
    package. In case you have specified range constraint in `pubspec.yaml`, it will
    fetch the update as per the specification of the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Building a REST service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most prominent tasks for developers is to build REST services for
    the project that help you gather data in JSON format, which you can reflect on
    the front-end of the application. Imagine working on an application, and you want
    to mock up a REST web service to get the demo data for you. You could certainly
    build your backend server using Node.js, MongoDB, or other platforms, but one
    of the easiest ways is to use a JSON server. A JSON server is a simple project
    that stimulates REST API with CRUD operation. This project hardly consumes time
    for the setup, and you can swiftly process the data to ensure that everything
    works as expected. It is ideal for developers who are learning to build REST APIs
    to understand how the data is processed with a backend for prototyping and mocking.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up JSON Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The setup of this project can be found at [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
    Note that this project builds a full fake REST API for demo purposes only. Before
    we begin the setup, ensure that the following components are ready on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js**: JSON-Server is built on top of Node.js. If you already have it
    in place, please ensure to keep it updated. To find out the version of Node, run
    the `node -v` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NPM package**: NPM stands for Node Package Manager, and comes in handy to
    easily install, update, configure, and uninstall Node JS platform modules/packages.
    Ensure NPM is installed on the system. If not, refer to [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm).
    At this point, it would be ideal to quote that NPM is a separate project from
    the Node, and gets updated frequently. To update NPM, use the `sudo npm install
    npm@latest -g` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cURL`: This open source command line enables the transfer of data with URL
    syntax. If you have `cURL` installed, use the `curl -V`  command (Note that `V`
    is upper case). In case you need to install `cURL`, run the `brew install curl`
    command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The JSON server is available as an NPM package, so we could simply run the
    following command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-g` option enables the package to be installed globally on your system.
    Once you have installed it successfully, run the command to cross check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Building a resource file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A resource is anything that has data associated with it. For example, if you
    are working on a movie review website, movies, reviewers, users, and so on, would
    be resources. You could have API endpoints based on these resources. The API endpoints
    help you to retrieve or update the data on the server. In this case, we will use
    the resources as a JSON file. This JSON file will act as a config and database
    file for the mock server you set up using `json-server`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Json-server` works in a JSON file, and creating a JSON file is simple. Create
    a new file as `Books.json`, populate the following content, and save it. Note
    that the name of the array we specified is `Movie`, so `json-server` will create
    the REST APIs based on this name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the json-server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step is to run `json-server` to ensure we have the mock server running
    locally. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have now successfully set up `json-server`. Open the `http://localhost:3000/` URL
    to check whether you can see the following. Under the resources tag, you will
    be able to see the Movies JSON file we created.
  prefs: []
  type: TYPE_NORMAL
- en: Do not close the terminal, as that will kill `json-server`. In case your port
    `3000` is utilized, you can set options for the new port number in a `json-server.json`
    configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fetching data from the server is a commonly used feature. It is performed using
    the HTTP package that we covered earlier in this chapter. The steps to follow
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the HTTP package and make the network request
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the response into a custom Dart object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the data and display it using the Flutter
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we have already learned about adding HTTP packages in the *Using packages*
    section, we will now proceed with making a network request. In our next step,
    we will fetch the sample JSON content using JSON-Server and the `http.get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `Future` function, which is a core Dart class for working with async
    tasks and, together with `http`, it returns the data from a successful `http`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now create a `Post` class that will contain the data from our network requests.
    To ensure that we create a proper `Post` from JSON, we will include a `factory`
    constructor. In our example, we have four categories of data for each array to
    fetch, namely, `id`, `movieName`, `year`, and the `category`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to update the `fetchPost` function to return a `Future<Post>`,
    for which we will follow three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, convert the response body into a JSON Map using the `dart:convert` package.
    This package contains encoders and decoders for converting between different data
    representations. To use this, you will first have to add the dependency in your
    package''s `pubspec.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, use the `package:convert/convert.dart` import in your dart code.
  prefs: []
  type: TYPE_NORMAL
- en: If we get an `OK` response from the server with a status code of `200`, it means
    the data is fetched, and you can convert the JSON Map into a `Post` using the `fromJSON`
    factory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the response is unexpected, you can flag an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the piece of code that checks the previously-mentioned cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to fetch the data and display it, we use the `FutureBuilder` widget
    that is built into Flutter, and helps in working easily with async data sources.
    To make this happen, we will need two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the future we want to work with. In our example, we call it the `fetchPost()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A builder function that informs Flutter what to render, based on the state
    of the Flutter—loading, success, or error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Building the code by putting a call to an API in your `build()` method is convenient,
    but it's not recommended. It will make Flutter call the `build()` method every
    time when it wants to change anything in the view, making your app slow due to
    it making unnecessary flooded API calls. A better way is to bit the API when the
    page is initially loaded, and use `StatelessWidget` for the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this method, you will make the parent widget responsible for calling
    the fetch method, storing its result and then passing it to your widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the complete code that will fetch the JSON content using `json-server`
    by reading `Movies.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: At the start of the chapter, we discussed what packages are and how to use them.
    Once the packages were set up, we discussed how to build a JSON Server to fetch
    data for our tests. In the final section, we glanced through an example of how
    to fetch the JSON data to the app, displaying the content of the JSON file we
    created and ran using the JSON server.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility in Flutter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making your app accessible to many users could be a great initiative. That also
    includes people with disabilities, such as blindness, hearing, voice, or motor
    impairment. As per the reports on disability by the World Health Organization,
    there are over 100 million users across the globe who face physical challenges
    in their daily routine. Technology can be revolutionary in helping people, and
    that's when building apps catering to their specific needs can aid them well.
  prefs: []
  type: TYPE_NORMAL
- en: Not all the users use the app in a specifically defined manner, so, a focus
    on accessibility will not only help users to download and use the app, but will
    also propagate to a new level of users.
  prefs: []
  type: TYPE_NORMAL
- en: Google provides an app to check for accessibility support that is available
    as accessibility scanner on Google Play at [https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor](https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor) This
    app enables you to find the accessibility provide that a developer can do within
    the app. For iOS, XCode provides Accessibility Inspector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flutter supports three components for accessibility support:'
  prefs: []
  type: TYPE_NORMAL
- en: Large font
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With age, not many can see the content the way they used to in their youth.
    Some face issues in reading the text clearly, especially when developers consider
    using thedefault size without taking into considering factors such as screen size
    and orientation. One of the quickest ways to do this is to ensure that the text
    scales in their accessibility options consider the device specifications of the
    consumers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flutter has a feature that handles text size calculations automatically. For
    example, the `Text` widget has a `textScaleFactor` property that allows the scaling
    of the text. Font size is multiplied by the `textScaleFactor` value to determine
    the new font size that is rendered on the screen in logical pixels. For example,
    if the `textScaleFactor` is `1.5`, the text will be 50% larger than the specified
    font size, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One point that needs to be kept in mind is that, if you manually set the scale
    value, the user’s accessibility settings will be overridden. You have to ensure
    that the scale-up value doesn't show up the text to a large extent leading to
    uninstall of the app. If you do not specify the value, it will check `textScaleFactor`
    for the nearest `MediaQuery` ancestor (`MediaQueryData.textScaleFactor`) or `1.0`,
    if no such ancestor exists. Ensure that you test the text displays properly at
    all accessibility settings.
  prefs: []
  type: TYPE_NORMAL
- en: Screen readers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For those who are visually impaired, this accessiblity option can come in handy.
    It enables users to receive spoken feedback about the content of the screen. You
    could turn on VoiceOver in iOS, or TalkBack in an Android application on your
    device to navigate around your app. For example, when using TalkBack, users perform
    actions using gestures, and each action is complimented with an audible output
    that allows users to know that their gesture trigger was successful. There are
    three types of gestures in TalkBack: basic gestures, back-and-forth gestures,
    and angle gestures. Note that the users should use single gestures, even finger
    pressure, and a steady speed to have a seamless experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Screen contrast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Specifying background and foreground colors with sufficient color contrast enables
    better readability for the users. This ratio ranges from 1 to 21, where 21 means
    the highest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The W3C recommends the following:'
  prefs: []
  type: TYPE_NORMAL
- en: At least 4.5:1 for smaller text (below 18 point regular, or 14 point bold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 3.0:1 for larger text (18 point and above regular, or 14 point and
    above bold)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessibility is an important feature and should not be neglected. It ensures
    that the app is open to a larger audience, enabling the chances for better application
    usage. It is equally important to test the accessibility options before rolling
    out to the masses.
  prefs: []
  type: TYPE_NORMAL
- en: Internation­alizing Flutter apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, if your app will be by the international audience, you
    will have to think of providing **locale** support for the specific language of
    the target. That means you’ll need to write the app in a way that your app renders
    the values like text and layouts depending on each language or locale that the
    app supports. Flutter has made it simple by providing support by classes and widgets.
    Flutter supports the global localization classes for about 24 languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start the internationalization, dependencies must be added in** `pubspec.yaml`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to import the `flutter_localizations` library and specify
    `localizationsDelegates` and `supportedLocales` for `MaterialApp`. Also, import
    `package:flutter_localizations/flutter_localizations.dart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `localizationsDelegates` list contains the elements that are factories that
    produce collections of localized values. `GlobalMaterialLocalizations.delegate`
    provides strings that are localized and other values for the material components
    library. The default text direction for the widget library is defined by `GlobalWidgetsLocalizations.delegate`**. **
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three methods to keep an eye on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.load`: This method must return an object that contains a collection of related
    resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.isSupported`: If the support for the locale is found, it returns `True`.
    Otherwise it will return **`False`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldReload`: If this method returns `True`, then all the app widgets will
    be rebuilt after a load of resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete code for your reference is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After you run the code successfully, you will see the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b813aea-4d78-4467-b286-b5e550fb8737.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We first discussed how networking plays an important role in the apps, along
    with sample code for setting up and running a local server for fetching JSON code.
    This section was followed by understanding why accessibility is important, and
    what improvements developers can provide to support accessibility in the app.
    The next section showed how to make app support internationalization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to use platform powers to build apps.
  prefs: []
  type: TYPE_NORMAL
