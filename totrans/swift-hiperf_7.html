<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;The Importance of Being Lazy" id="1T1401-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. The Importance of Being Lazy</h1></div></div></div><p class="calibre8">Another way of improving an application's performance is by deferring the execution of code until the result is needed. This sounds very logical; the less the code we run, the less the time it will take. This design pattern is usually called <span class="strong"><strong class="calibre9">lazy</strong></span>. There are many things that can be lazy, and there are many different ways in which we can defer code execution. We are going to cover the following topics in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The lazy mindset</li><li class="listitem">Lazy loading</li><li class="listitem">Lazy collections and evaluation</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;The Importance of Being Lazy" id="1T1401-f05765b7b5914043830034430c83d0a0">
<div class="book" title="The lazy mindset"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec58" class="calibre1"/>The lazy mindset</h1></div></div></div><p class="calibre8">First, it is very important to understand the <a id="id414" class="calibre1"/>lazy pattern, how it works, how it could benefit an application's performance, and when to use it. It's also very important not to abuse it, because that would make code more complex and hard to read. Plus, it would be hard to follow the execution flow. Also, abusing it would decrease the overall application's performance.</p><p class="calibre8">The general idea of a lazy pattern is to defer the evaluation of an instruction until someone asks for the result of that instruction.</p><p class="calibre8">In general, code is executed instruction by instruction, starting at the top of a file or a function. Nowadays, our applications are more complex and consist of many files, windows, libraries, components, and layers, but they still execute code in the same way. Because our system gets bigger and bigger, it's important to make them lazy so that we don't have to perform all the work when we start the application. Let's learn a few techniques for making code lazy.</p></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;The Importance of Being Lazy" id="1T1401-f05765b7b5914043830034430c83d0a0">
<div class="book" title="The lazy mindset">
<div class="book" title="Separation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec69" class="calibre1"/>Separation</h2></div></div></div><p class="calibre8">It's very important to<a id="id415" class="calibre1"/> separate code into components with a<a id="id416" class="calibre1"/> <span class="strong"><strong class="calibre9">single responsibility</strong></span> pattern. A component should do only one thing and do it well. Let's take a look at this simple example to understand<a id="id417" class="calibre1"/> how this could improve performance:</p><div class="informalexample"><pre class="programlisting">struct Person {
  let name: String
  let age: Int
}

func analyze(people: [Person]) {
  let names = people.map { $0.name }
  let last = names.maxElement()
  
  let alphabetOrder = names.sort { $0 &gt; $1 }
  let lengthOrder = names.sort { $0.characters.count &lt; $1.characters.count }
  let longestName = lengthOrder.last
  
  print(last, alphabetOrder, lengthOrder, longestName)
  
  let age = people.map { $0.age }
  let youngest = age.minElement()
  let oldest = age.maxElement()
  let average = age.reduce(0, combine: +) / age.count
  
  print(youngest, oldest, average)
}

let people = [Person(name: "Sam", age: 3),
  Person(name: "Lisa", age: 68),
  Person(name: "Jesse", age: 35)
]

people + EnglandPopulation()
analyze(people)</pre></div><p class="calibre8">The problem with this code that the <code class="literal">analyze</code> function does two things. Because of that, the memory usage peak is twice as big. When we are done analyzing names, the memory used for it is not released immediately, but is kept until we return from the function. If we tried to analyze all of the population of England, it would require quite a lot of memory. By splitting them into separate functions, we can improve memory usage:</p><div class="informalexample"><pre class="programlisting">func analyze(people: [Person]) {

  let names = people.map { $0.name }
  analyzeNames(names)

  let age = people.map { $0.age }
  analyzeAge(age)
}

func analyzeNames(names: [String]) {
  ...
}

func analyzeAge(age: [Int]) {
  ...
}</pre></div><p class="calibre8">You should apply a code <a id="id418" class="calibre1"/>separation technique very often to different components as an example. Make simple models and use only the data that you need for the current view. Splitting code into smaller components is useful, but you shouldn't split it into too small components.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;The Importance of Being Lazy" id="1T1401-f05765b7b5914043830034430c83d0a0">
<div class="book" title="The lazy mindset">
<div class="book" title="Do work on demand"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec70" class="calibre1"/>Do work on demand</h2></div></div></div><p class="calibre8">The main idea of lazy code is to do<a id="id419" class="calibre1"/> work only on demand. In this way, you can delay a code execution or remove it completely if no one asks for the result. When you are planning an application's architecture, try to think about these questions: when would this resource or data be used in the application? Does it have to be instantiated now or can it wait? How often would this data be used? If often, then maybe you should cache it; if not, maybe you should load it lazily. Is the data heavy? Do you need to clean it afterward? Asking all of these questions helps you build a better application architecture with the <span class="strong"><em class="calibre10">do work on demand</em></span> approach.</p></div></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;The Importance of Being Lazy" id="1T1401-f05765b7b5914043830034430c83d0a0">
<div class="book" title="The lazy mindset">
<div class="book" title="Approximate results"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec71" class="calibre1"/>Approximate results</h2></div></div></div><p class="calibre8">Another idea is mixing<a id="id420" class="calibre1"/> lazy loading and asynchronous execution. If you want to perform an asynchronous task, because it takes a long time, but you would also like to get a result immediately, you can return an approximate result immediately and continue the execution. For example, the core data asynchronous fetching implements this pattern. It returns you an approximate number of items that will be fetched.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Lazy loading"><div class="book" id="1TVKI2-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec59" class="calibre1"/>Lazy loading</h1></div></div></div><p class="calibre8">The lazy loading pattern<a id="id421" class="calibre1"/> allows you to delay the creation of an object until you try to use it. This pattern can be implemented in any programming language. In Objective-C, we have used the property's getters and checked whether it was initialized. Swift adds support for lazy loading into the language, and this makes it even easier to apply this pattern. There are many things that can be lazy loaded, and we will cover them in this chapter.</p></div>

<div class="book" title="Lazy loading">
<div class="book" title="Global constants and variables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec72" class="calibre1"/>Global constants and variables</h2></div></div></div><p class="calibre8">Global variables and <a id="id422" class="calibre1"/>constants are always loaded lazily in Swift. This<a id="id423" class="calibre1"/> means that every global variable is initialized only when you access it for the first time. As a test, let's create a new <code class="literal">Person.swift</code> file and add this code to it:</p><div class="informalexample"><pre class="programlisting">struct Person {
  let name: String
  let age: Int
  
  init(name: String, age: Int) {
    self.name = name
    self.age = age
    print("\(name) Created")
  }
}

let Jon = Person(name: "Jon", age: 20)
let Sam = Person(name: "Sam", age: 28)</pre></div><p class="calibre8">This file contains two global constants: <code class="literal">Jon</code> and <code class="literal">Sam</code>. We have also added a log statement to the <code class="literal">Person</code> structure's <code class="literal">init</code> method so that we can see when the person is created. Now let's try to access one of the global constants and see the console output:</p><div class="informalexample"><pre class="programlisting">print("Start!")
print("Age: \(Jon.age)")
//print("Age: \(Sam.age)")

Console Output:

Start!
Jon Created
Age: 20</pre></div><p class="calibre8">As you can see, only the <code class="literal">Jon</code> global constant is created, and it's created when we try to access its age property. Yes, global constants and variables have powerful features in Swift, but you should almost never use global constants! There is a better way to do that.</p><p class="calibre8">Global variables are even more vulnerable because anyone can change them in the entire application.</p></div></div>

<div class="book" title="Lazy loading">
<div class="book" title="Type properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec73" class="calibre1"/>Type properties</h2></div></div></div><p class="calibre8">Both structures and classes<a id="id424" class="calibre1"/> can have a <code class="literal">type</code> property. The <code class="literal">type</code> property belongs to the type itself and not to an instance of that type. Only one copy of a type property will be created no matter how many instances of that type you create. They behave like global variables and constants, but they have a namespace scope of that type. Also, type properties can be declared as private and be hidden from rest of the application.</p><p class="calibre8">We can very easily improve our code by moving our global constants into the <code class="literal">Person</code> struct definition:</p><div class="informalexample"><pre class="programlisting">struct Person {
  let name: String
  let age: Int
  
  static let Jon = Person(name: "Jon", age: 20)
  static let Sam = Person(name: "Sam", age: 25)

  ...
}</pre></div><p class="calibre8">To access a <code class="literal">type</code> property, we need to prefix it with a type name that it is declared in; to access the <code class="literal">Jon</code> type constant, we would need to write <code class="literal">Person.Jon</code>. Classes have the same syntax and functionality for type properties as structures:</p><div class="informalexample"><pre class="programlisting">print("Age: \(Person.Jon.age)")
print("Age: \(Person.Sam.age)")</pre></div></div></div>

<div class="book" title="Lazy loading">
<div class="book" title="Lazy properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec74" class="calibre1"/>Lazy properties</h2></div></div></div><p class="calibre8">There is also a way to <a id="id425" class="calibre1"/>lazy load an instance property. Let's extend our <code class="literal">Person</code> type and add a <code class="literal">HealthData</code> structure to it:</p><div class="informalexample"><pre class="programlisting">struct HealthData {
  init() {
    print("HealthData Created") 
  }
}

struct Person {
  let name: String
  let age: Int

  var healthData = HealthData()
}</pre></div><p class="calibre8">Now, every time we create a new person, it creates a <code class="literal">healthData</code> instance. In our example, <code class="literal">HealthData</code> could be a heavy object that connects to a database, fetches health data, and does a lot of work. And we don't need a <code class="literal">HealthData</code> structure to be created at the same time as <code class="literal">Person</code>; instead, we would like to create a <code class="literal">HealthData</code> structure only when we use it.</p><p class="calibre8">To make a property behave lazy, all you need to do is add the <code class="literal">lazy</code> attribute to its declaration:</p><div class="informalexample"><pre class="programlisting">  lazy var healthData = HealthData()</pre></div><p class="calibre8">The <code class="literal">lazy</code> instance <a id="id426" class="calibre1"/>property must be declared as a variable and not a constant.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip37" class="calibre1"/>Tip</h3><p class="calibre8">It is very important not to abuse lazy instance properties. Accessing a lazy property adds a small performance overhead, for checking whether it was initialized or not.</p><p class="calibre8">That's why it is very important to analyze which parts of the system need to be created at the same time, because they are used at the same time, and which maybe not be used at all; so, we make them lazy to delay their creation.</p></div><p class="calibre8">When you access a lazy property, it actually mutates a value, so the instance has to be declared as a variable. If you use a class with a lazy stored property, it can be declared as a constant. This is because it's a constant reference and the changes are applied to the value:</p><div class="informalexample"><pre class="programlisting">let ola = Person(name: "Ola", age: 27)
let health = ola.healthData // Error! It's mutating a value

var bobby = Person(name: "Bobby ", age: 5)
let bobbyHealth = bobby.healthData // Works fine

let someClass = SomeClass()
someClass.healthData // Works fine because class is a reference type</pre></div><p class="calibre8">An important thing to note about lazy properties is that they get initialized only once. If you create a lazy optional property that you would like set to <code class="literal">nil</code> later and initialize again, you will need to do it manually. Let's say <code class="literal">healthData</code> is a very heavy instance and we want to clear it when it's not needed:</p><div class="informalexample"><pre class="programlisting">struct Person {
  ...
  lazy var healthData: HealthData? = HealthData()

  mutating func clearHealthData() {
    healthData = nil
  }
}

var ola = Person(name: "Ola", age: 27)
var health = ola.healthData //Get lazy loaded here
ola.clearHealthData() 
health = ola.healthData // nil, nothing happens here.</pre></div><p class="calibre8">As we said, the lazy stored property is initialized only once. So, the next time we access it, after we have cleared it, there is no extra initialization code running. If we really need this sort of lazy loading cache, then we will need to implement it ourselves. It's not hard. We would need a stored <a id="id427" class="calibre1"/>property and a computed property like this:</p><div class="informalexample"><pre class="programlisting">struct Person {
  ...
  private var _healthData: HealthData?
  
  mutating func clearHealthData() {
    _healthData = nil
  }
  
  var healthData: HealthData {
    mutating get {
      _healthData = _healthData ?? HealthData()
      return _healthData!
    }
  }
}</pre></div><p class="calibre8">We have to create a mutating getter here, because the <code class="literal">var</code> properties can't be declared as <code class="literal">mutating</code>. Now, if we run our previous example once more, we will see that <code class="literal">HealthData</code> is created every time after cleaning it:</p><div class="informalexample"><pre class="programlisting">var ola = Person(name: "Ola", age: 27)
var health = ola.healthData //Get lazy loaded here
ola.clearHealthData() 
health = ola.healthData // HealthData created again</pre></div></div></div>

<div class="book" title="Lazy loading">
<div class="book" title="Computed properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec75" class="calibre1"/>Computed properties</h2></div></div></div><p class="calibre8">The other way of<a id="id428" class="calibre1"/> delaying a property initialization is by using a computed property. As the name says, a computed property is computed every time you access it. It's important to remember that such a property will be computed every time, because this could have a negative impact on performance or if you perform any side effect on it.</p><p class="calibre8">The best use case of a computed property is when you want to provide a read-only property that uses internal data for its computation. A good example would be the full name of a person:</p><div class="informalexample"><pre class="programlisting">struct Person {
  let name: String
  let lastName: String
  let age: Int

  var fullName: String {
    print("calculating fullName")
    return "\(name) \(lastName)"
  }
}

var jack = Person(name: "Jack", lastName: "Samuel", age: 21)
print(jack.fullName)
print(jack.fullName)</pre></div><p class="calibre8">It's really important <a id="id429" class="calibre1"/>to pay attention while performing any side effect or mutation operation on the computed properties. The mutating operation would require specifying explicitly for structures, but it would also be legal to do this for a class.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Lazy collections and evaluation"><div class="book" id="1UU542-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec60" class="calibre1"/>Lazy collections and evaluation</h1></div></div></div><p class="calibre8">Another very interesting place<a id="id430" class="calibre1"/> where we <a id="id431" class="calibre1"/>could perform work lazily is collections and sequences. We store many elements in them, and sometimes, performing an operation such as <code class="literal">filter</code> or <code class="literal">map</code> would take a lot of time and may be unnecessary.</p><p class="calibre8">Before we dig into the details, let's first check out a small example to see why working lazily with a collection is so useful. We have a collection. We want to perform an operation such as mapping on it, and get one or a few elements from the result. Here is how we would implement it using an array:</p><div class="informalexample"><pre class="programlisting">let numbers = Array(1...1_000_000) 
let doubledNumbers = numbers.map { $0 * 2 }
doubledNumbers.last</pre></div><p class="calibre8">When we call the <code class="literal">map</code> method on the <code class="literal">numbers</code> array, it applies it to every element in the array and returns the new mapped array. As a result, we get a new <code class="literal">doubledNumbers</code> array. Our map <code class="literal">{ $0 * 2 }</code> closure is called as many times as there are elements in the array; in our case, it is 1,000,000 times. But we need only the last element from that array. Instead of mapping every element, we would like to map only the last one. For this situation, it is better to use a lazy collection:</p><div class="informalexample"><pre class="programlisting">let numbers = Array(1...1_000_000) 
let lazyNumbers = numbers.lazy
let doubledNumbers = lazyNumbers.map { $0 * 2 }
doubledNumbers.last</pre></div><p class="calibre8">The only difference here is that we added a <code class="literal">lazy</code> method call to create <code class="literal">LazyCollection</code> from an array:</p><div class="informalexample"><pre class="programlisting">public var lazy: LazyCollection&lt;Self&gt; { get }</pre></div><p class="calibre8">When we call a map method on the <a id="id432" class="calibre1"/>lazy collection, it does not perform a mapping of every element immediately, but delays it and returns another <code class="literal">LazyCollection</code>—<code class="literal">LazyMapCollection</code>. The next time when we ask <code class="literal">doubledNumbers</code> for the last number, it performs a mapping to the last number and returns it to us. As a result, we <a id="id433" class="calibre1"/>call our map only once, which is exactly what we needed.</p><p class="calibre8">All <code class="literal">LazyCollections</code> and <code class="literal">LazySequences</code> work by the same principle; they do work on demand when you pull an element from it. When you call any method that is supposed to perform an operation on a sequence, such as <code class="literal">map</code> or <code class="literal">filter</code>, it is not performed immediately. Instead, the <code class="literal">LazySequence</code> saves the operation that needs to be performed and returns a new <code class="literal">LazySequence</code>. The <code class="literal">LazySequence</code> performs that operation only when you pull data out of it, like when you ask for the last element.</p></div>

<div class="book" title="Lazy collections and evaluation">
<div class="book" title="Sequences and collections"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec76" class="calibre1"/>Sequences and collections</h2></div></div></div><p class="calibre8">For a better understanding of laziness, it's useful to <a id="id434" class="calibre1"/>learn the difference between sequences and collections. We can apply lazy operations to both of them, but collections allow us to do more, and we will see why.</p><div class="book" title="Sequences"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec42" class="calibre1"/>Sequences</h3></div></div></div><p class="calibre8">A sequence is <a id="id435" class="calibre1"/>represented as a traversable set of elements. The main operation we would do on a sequence is iterating over its elements by starting from the first element and moving forward. For us to do this, the sequence uses a <code class="literal">GeneratorType</code> protocol. The <code class="literal">GeneratorType</code> protocol has a <code class="literal">next</code> method, which returns the next element, or nil if there is no element. This is the only method that is available on <code class="literal">GeneratorType</code>:</p><div class="informalexample"><pre class="programlisting">mutating func next() -&gt; Self.Element?</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">SequenceType</code> and <code class="literal">GeneratorType</code> protocols are very simple. Each of them requires only one method to implement:</p><div class="informalexample"><pre class="programlisting">protocol SequenceType {
  func generate() -&gt; Self.Generator
}
protocol GeneratorType {
  mutating func next() -&gt; Self.Element?
}</pre></div></div><p class="calibre8">Here is the <a id="id436" class="calibre1"/>simplest and most fundamental operation that is available for a SequenceType instance, an iteration over its elements:</p><div class="informalexample"><pre class="programlisting">let seq = AnySequence(1...10)
for i in seq {
  i
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="tip38" class="calibre1"/>Tip</h3><p class="calibre8">If you want your own types to be used in a <code class="literal">for…in</code> loop, you need to implement a <code class="literal">SequenceType</code> protocol for your type.</p></div><p class="calibre8">The other way in which we can iterate over the sequence is by manually getting the next element from the generator:</p><div class="informalexample"><pre class="programlisting">let gen = seq.generate()
while let num = gen.next() {
  num
}</pre></div><p class="calibre8">The Swift standard library uses protocol extensions to provide extra functionality for the <code class="literal">SequenceType</code>. In Swift 2.0, <code class="literal">SequenceType</code> has become very powerful, with many methods, such as <code class="literal">map</code> and <code class="literal">filter</code>, <code class="literal">sort</code>, <code class="literal">equal</code>, and many others.</p></div><div class="book" title="Collections"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec43" class="calibre1"/>Collections</h3></div></div></div><p class="calibre8">A collection, on<a id="id437" class="calibre1"/> the other hand, represents a group of items in which every item can be accessed by its index. The simplest example of a collection is an array. A collection type also implements a <code class="literal">SequenceType</code> protocol, because of which you can use a collection in every place where a sequence is expected.</p><p class="calibre8">
<code class="literal">CollectionType</code> requires implementing three more methods in addition to the <code class="literal">SequenceType</code> protocol:</p><div class="informalexample"><pre class="programlisting">subscript (position: Self.Index) -&gt; Self._Element { get }
var startIndex: Self.Index { get }
var endIndex: Self.Index { get }</pre></div><p class="calibre8">
<code class="literal">CollectionType</code> gives us random access to elements with a subscript method. Because the collection knows the first and last indexes, it can also calculate the size and iterate over its elements in both directions, from the beginning and from the end. This gives us much more power.</p></div><div class="book" title="Implementing our own sequence and collection"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec44" class="calibre1"/>Implementing our own sequence and collection</h3></div></div></div><p class="calibre8">As the wrap-up of<a id="id438" class="calibre1"/> getting to know sequences and collections, let's <a id="id439" class="calibre1"/>implement our own sequence and collection types. We can also add a <code class="literal">print</code> statement to it so that we can see in the console when it's actually doing work. This is very useful for inspecting the behavior of lazy collections. Let's start with the sequence:</p><div class="informalexample"><pre class="programlisting">struct InfiniteNums: SequenceType {
  
  func generate() -&gt; AnyGenerator&lt;Int&gt; {
    var num = 0

    return anyGenerator {
      print("gen \(num)")
      return num++
    }
  }
}</pre></div><p class="calibre8">Here is our simple sequence of infinite numbers. Our generator just returns the next integer. Now let's create a custom collection. It will be a bit more complicated than a sequence:</p><div class="informalexample"><pre class="programlisting">struct Collection10: CollectionType {
  let data = Array(1...10)
  
  var startIndex: Int {
    return data.startIndex
  }
  
  var endIndex: Int {
    return data.endIndex
  }
  
  subscript (position: Int) -&gt; Int {
    print("Pos \(position)")
    return data[position]
  }
  
  func generate() -&gt; AnyGenerator&lt;Int&gt; {
    var index = 0
    
    return anyGenerator {
      print("Col index: \(index)")
      let next: Int? = index &lt; self.endIndex ? self.data[index++] : nil
      return next
    }
  }
}</pre></div><p class="calibre8">For this example, we<a id="id440" class="calibre1"/> made an immutable collection of 10 integer elements. Its<a id="id441" class="calibre1"/> implementation is still quite simple. Because our collection is closed and it has the <code class="literal">endIndex</code> property, the generator needs to check the bounds, and it returns <code class="literal">nil</code> when there are no more elements in the sequence.</p><p class="calibre8">You can play around with those new types and use them with functions from the Swift standard library, which takes sequence or collection types as an argument. Now let's move on to the most interesting part; let's use these types with a lazy function.</p></div><div class="book" title="Using lazy"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec45" class="calibre1"/>Using lazy</h3></div></div></div><p class="calibre8">Turning a <a id="id442" class="calibre1"/>collection or a sequence into a lazy version is very simple. Both sequences and collections have a <code class="literal">lazy</code> property, which returns a lazy version of that collection or sequence:</p><div class="informalexample"><pre class="programlisting">public var lazy: LazyCollection&lt;Self&gt; { get }
public var lazy: LazySequence&lt;Self&gt; { get }
[1, 2, 3].lazy
AnySequence(1...10).lazy</pre></div></div><div class="book" title="Using the lazy sequence"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec46" class="calibre1"/>Using the lazy sequence</h3></div></div></div><p class="calibre8">Let's now play with our <a id="id443" class="calibre1"/>infinite numbers sequence and the <code class="literal">LazySequence</code> map and filter methods:</p><div class="informalexample"><pre class="programlisting">let infNums = InfiniteNums()
let lazyNumbers = infNums.lazy

let oddNumbers = lazyNumbers.filter { $0 % 2 != 0 }
let doubled = lazyNumbers.map { $0 * 2 }
let mixed = lazyNumbers.filter { $0 % 4 != 0 }.map { $0  * 2 }

var gen = oddNumbers.generate()
var gen2 =  mixed.generate()

for _ in 0...10 {
  gen.next()
  gen2.next()
}</pre></div><p class="calibre8">The code here is pretty straightforward. We create a lazy sequence and apply a <code class="literal">map</code> and <code class="literal">filter</code> transformation to it. After that, we pull the first 10 results from it. Because the collection is lazy, it starts performing mapping and filtering only when we start pulling elements from it into the loop body, by calling the <code class="literal">next</code> method.</p><p class="calibre8">Because <code class="literal">LazySequence</code> is a <code class="literal">SequenceType</code> protocol, you can use it with any function that takes a <code class="literal">SequenceType</code> protocol or call any method that is available in that <code class="literal">SequenceType</code>. That operation won't be lazy and will return a result. If we try to use them with our infinity<a id="id444" class="calibre1"/> numbers, it could lead to an infinite loop. This is because our sequence is infinite:</p><div class="informalexample"><pre class="programlisting">lazyNumbers.contains(3) // returns true, stops when found
// lazyNumbers.minElement() // Infinite loop</pre></div></div><div class="book" title="Using a lazy collection"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec47" class="calibre1"/>Using a lazy collection</h3></div></div></div><p class="calibre8">Working with lazy <a id="id445" class="calibre1"/>collections is very similar to working with lazy sequences. A <code class="literal">LazyCollection</code> implements a <code class="literal">CollectionType</code>, which means that we can use all the methods from <code class="literal">CollectionType</code> with a <code class="literal">LazyCollection</code>.</p><p class="calibre8">First, let's create a lazy collection and some additional helper functions to map and filter a collection that we will use:</p><div class="informalexample"><pre class="programlisting">let isOdd = { $0 % 2 != 0 }
let doubleElements = { $0 * 2 }

let col = Collection10()
let lazyCol = col.lazy</pre></div><p class="calibre8">The <code class="literal">map</code>, <code class="literal">reverse</code>, and <code class="literal">filter</code> methods of a lazy collection have small differences. They return different lazy collection types: <code class="literal">LazyMapCollection</code>, <code class="literal">LazyFilterCollection</code>, and <code class="literal">ReverseRandomAccessCollection</code>:</p><div class="informalexample"><pre class="programlisting">lazyCol.map(doubleElements) //LazyMapCollection&lt;Self.Elements, U&gt;
lazyCol.reverse() //LazyCollection&lt;ReverseRandomAccessCollection&lt;Self.Elements&gt;&gt;
lazyCol.filter(isOdd)  //LazyFilterCollection&lt;Self.Elements&gt;</pre></div><p class="calibre8">Both the <code class="literal">LazyMapCollection</code> and <code class="literal">LazyFilterCollection</code> types implement a <code class="literal">LazyCollectionType</code>, and they have similar methods. Because of this, some lazy collections could have a different set of available methods.</p><p class="calibre8">One more interesting behavior of these lazy collections is the difference in the way some methods work. As an example, let's take a look at the <code class="literal">count</code> and <code class="literal">isEmpty</code> methods. First, let's try to use them with <code class="literal">LazyMapCollection</code>:</p><div class="informalexample"><pre class="programlisting">let lazyMap = lazyCol.map(doubleElements)
let count = lazyMap.count

lazyMap.isEmpty
lazyMap.reverse().isEmpty</pre></div><p class="calibre8">Calling <code class="literal">count</code> and <code class="literal">isEmpty</code> does not force a lazy collection to perform any mapping operation. Because<a id="id446" class="calibre1"/> mapping doesn't change the number of elements of a source collection, it can use the underlying collections data—<code class="literal">startIndex</code> and <code class="literal">endIndex</code>—to compute a result for those methods.</p><p class="calibre8">However, calling <code class="literal">count</code> and <code class="literal">isEmpty</code> on a <code class="literal">LazyFilterCollection</code> does require the lazy collection to perform a filtering operation. For the <code class="literal">isEmpty</code> method, it stops as soon as it finds an element; but for the <code class="literal">count</code> method, it needs to apply the filtering operation to every element. In such cases, calling a <code class="literal">count</code> method would behave the same way as calling it on a regular collection:</p><div class="informalexample"><pre class="programlisting">lazyCol.filter(isOdd).isEmpty
lazyCol.filter(isOdd).count</pre></div><p class="calibre8">One more difference between the <code class="literal">map</code> and <code class="literal">reverse</code> methods that is worth mentioning is in the subscript methods and indexes that they use:</p><div class="informalexample"><pre class="programlisting">//Query elements
lazyCol.map(doubleElements)[3]

let revCol = lazyCol.reverse()
let ind = revCol.startIndex.advancedBy(2)
revCol[ind]

let revMapCol = lazyCol.reverse().map(doubleElements)
let index = revMapCol.startIndex.advancedBy(2)
revMapCol[index]</pre></div><p class="calibre8">
<code class="literal">LazyMapCollection</code> allows us to use the original index that we used for the collection; in our case, this is an <code class="literal">Int</code> type. The <code class="literal">reverse</code> method returns a <code class="literal">ReverseRandomAccessCollection</code> with indexes of the <code class="literal">ReverseRandomAccessIndex</code> type. To use a subscript method on it, we need to use a <code class="literal">startIndex</code> or <code class="literal">endIndex</code> and an <code class="literal">advance</code> method to move the index to the needed position.</p><p class="calibre8">This was a general overview of lazy collections and sequences. However, there is one more very important characteristic of lazy types that we need to cover.</p><p class="calibre8">A lazy collection or sequence performs an operation, for example, a mapping of elements, when we start pulling elements from it. The difference here is that a regular array applies a mapping only once for every element and returns the result immediately. </p><p class="calibre8">A lazy collection applies a mapping every time we pull elements from it. If you are going to use a result of a mapping very often, then it may be better to use a regular array or add some kind of caching or memorization functionality. Let's see with the help of an example why it could be dangerous:</p><div class="informalexample"><pre class="programlisting">let col = Array(0...10)
let lazyCol = col.lazy

var x = 10
let mapped = lazyCol.map { $0 + x++ }

for i in mapped {
  print(" \(i)", terminator:"") //10 12 14 16 18 20 22 24 26 28 30
}

print("")
for i in mapped {
  print(" \(i)", terminator:"") //21 23 25 27 29 31 33 35 37 39 41
}</pre></div><p class="calibre8">This example shows two important issues with using a lazy collection and a state in the map function. When we use a mapped lazy collection, we expect that the result will be the same for all loop iterations because we haven't changed anything. In reality, however, it will be different because the <code class="literal">map</code> function is called twice and the state we used in the map function will have been changed.</p><p class="calibre8">We could partially<a id="id447" class="calibre1"/> solve this problem by removing the state from the map function. Now the lazy mapped collection produces the same result, but even this doesn't change the fact that a map function will be executed in both loops. If we put an expensive operation inside the map function, it will make our app twice as slow:</p><div class="informalexample"><pre class="programlisting">// No state
let mapped = lazyCol.map { $0 + $0 + 10 }</pre></div><p class="calibre8">Closing the topic of lazy collections, I would say that a lazy collection is very powerful, but you should used it as carefully as any other tool that helps improve performance. </p></div></div></div>
<div class="book" title="Summary" id="1VSLM1-f05765b7b5914043830034430c83d0a0"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec61" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we covered two more tools that can improve an application's performance: lazy loading and lazy execution techniques. First, we explained why it's important to make code behave lazily, when to do so, and in which way it can be implemented. Next, we showed you the lazy loading feature built into the Swift language and how to use it with global variables, type properties, and lazy stored properties.</p><p class="calibre8">In the rest of the chapter, we covered how to make a collection behave lazily. We used many functions with a lazy collection and showed the differences between a collection and a sequence. </p><p class="calibre8">In the next and final chapter, <span class="strong"><em class="calibre10">Discovering All of the Underlying Swift Power</em></span>, we will take a look at some more advanced tools that will help you analyze the power of Swift, and go through a quick recap of what you learned throughout the book.</p></div></body></html>