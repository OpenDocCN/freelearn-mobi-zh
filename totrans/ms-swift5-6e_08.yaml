- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes, Structures, and Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first programming language that I learned was BASIC. It was a good language
    to begin programming with, but once I traded in my Commodore Vic-20 for a PCjr
    (yes, I had a PCjr and I really enjoyed it), I realized that there were other,
    more advanced languages out there, and I spent a lot of time learning Pascal and
    C. It wasn''t until I started college that I heard the term **object-oriented
    programming language**. At that time, object-oriented programming languages were
    so new that there were no real courses on them, but I was able to experiment a
    little with C++. After I graduated, I left object-oriented programming behind,
    and it really wasn''t until several years later, when I started to experiment
    with C++ again, that I really discovered the power and flexibility of object-oriented
    programming. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What are classes and structures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add properties and property observers to classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add methods to classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add initializers to classes and structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and when to use access controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a class hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extend a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are classes and structures?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Swift, classes and structures are very similar. If we really want to master
    Swift, it is very important to not only understand what makes classes and structures
    so similar, but to also understand what sets them apart, because they are the
    building blocks of our applications. Apple describes them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and structures are general-purpose, flexible constructs that become
    the building blocks of your program's code. You define properties and methods
    to add functionality to your classes and structures by using the already familiar
    syntax of constants, variables, and functions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let's begin by taking a quick look at some of the similarities between classes
    and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Similarities between classes and structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Swift, classes and structures are more similar than they are in other languages,
    such as Objective-C. The following is a list of some of the features that classes
    and structures share:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties**: These are used to store information in our classes and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**: These provide functionality for our classes and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Initializers**: These are used when initializing instances of our classes
    and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscripts**: These provide access to values using the subscript syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extensions**: These help extend both classes and structures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's take a quick look at some of the differences between classes and
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between classes and structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While classes and structures are very similar, there are also several very
    important differences. The following is a list of some of the differences between
    classes and structures in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Type**: A structure is a value type, while a class is a reference type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: A structure cannot inherit from other types, while a class
    can'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deinitializers**: Structures cannot have custom deinitializers, while a class
    can'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will be emphasizing the differences between classes
    and structures to help us understand when to use each. Before we really dive into
    classes and structures, let's look at the difference between value types (structures)
    and reference types (classes). To fully understand when to use classes and structures
    and how to properly use them, it is important to understand the difference between
    value and reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Value versus reference types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Structures are value types. When we pass instances of a structure within our
    application, we pass a copy of the structure and not the original structure. Classes
    are reference types; therefore, when we pass an instance of a class within our
    application, a reference to the original instance is passed. It is very important
    to understand this difference. We will give a very high-level view here and will
    provide additional details in *Chapter 18*, *Memory Management*. When we pass
    structures within our application, we are passing copies of the structures and
    not the original structures. Since the function gets its own copy of the structure,
    it can change it as needed without affecting the original instance of the structure.
    When we pass an instance of a class within our application, we are passing a reference
    to the original instance of the class. Since we''re passing the instance of the
    class to the function, the function is getting a reference to the original instance;
    therefore, any changes made within the function will remain once the function
    exits. To illustrate the difference between value and reference types, let''s
    look at a real-world object: a book. If we have a friend who wants to read *Mastering
    Swift 5.3*, we could either buy them their own copy or share ours. If we bought
    our friend their own copy of the book, any notes they made within the book would
    remain in their copy of the book and would not be reflected in our copy. This
    is how passing by value works with structures and variables. Any changes that
    are made to the structure or variable within the function are not reflected in
    the original instance of the structure or variable. If we share our copy of the
    book, any notes they made within the book would stay in the book when they return
    it to us. This is how passing by reference works. Any changes that are made to
    the instance of the class remain when the function exits.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class or structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the same syntax to define classes and structures. The only difference
    is that we define a class using the `class` keyword and a structure using the
    `struct` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the syntax that''s used to create both classes and structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we define a new class named `MyClass` and a new structure
    named `MyStruct`. This effectively creates two new Swift types, named `MyClass`
    and `MyStruct`. When we name a new type, we want to use the standard naming convention
    set by Swift, where the name is in camel case, with the first letter being uppercase.
    This is also known as `PascalCase`. Any method or property defined within the
    class or structure should also be named using camel case, with the first letter
    being uppercase. Empty classes and structures are not that useful, so let's look
    at how we can add properties to our classes and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Properties associate values with a class or a structure. There are two types
    of properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stored properties**: These will store variable or constant values as part
    of an instance of a class or structure. Stored properties can also have property
    observers that can monitor the property for changes and respond with custom actions
    when the value of the property changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computed properties**: These do not store a value themselves but instead
    retrieve and possibly set other properties. The value returned by a computed property
    can also be calculated when it is requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stored properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stored property is a variable or constant that is stored as part of an instance
    of a class or structure. These are defined with the `var` and `let` keywords,
    just like normal variables and constants. In the following code, we will create
    a structure named `MyStruct` and a class named `MyClass`. The structure and the
    class both contain two stored properties, `c` and `v`. The stored property, `c`,
    is a constant because it is defined with the `let` keyword, and `v` is a variable
    because it is defined with the `var` keyword. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding example, the syntax to define a stored property
    is the same for both classes and structures. Let''s look at how we would create
    an instance of both the structure and class. The following code creates an instance
    of the `MyStruct` structure, named `myStruct`, and an instance of the `MyClass`
    class, named `myClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the differences between structures and classes is that, by default,
    a structure creates an initializer that lets us populate the stored properties
    when we create an instance of the structure. Therefore, we could also create an
    instance of `MyStruct` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the initializer is used to set the `v` variable,
    and the `c` constant will still contain the number `5`, which is defined in the
    structures. If we did not give the constant an initial value, as shown in the
    following example, the default initializer would be used to set the constant as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how the initializer for this new structure would
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to define a constant where we set the value when we initialize
    the class or structure at runtime, rather than hardcoding the value of the constant
    within the type. The order in which the parameters appear in the initializer is
    the order in which we defined them. In the previous example, we defined the `c`
    constant first, therefore, it is the first parameter in the initializer. We defined
    the `v` parameter next, therefore, it is the second parameter in the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting in Swift 5.1 with SE-0242, the initializer for structures has been
    enhanced so that default values can be added to any parameter, making the parameter
    optional in the initializer. Let''s create a new structure that illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we define three parameters, a, b, and c, where both the b and
    c parameters have default values. We are now able to initialize the `MyStruct`
    structure in any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are able to leave the c parameter or the b and c parameters undefined within
    the initializer because we set default values when we defined the parameters.
    One thing to note is the following code will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we defined the parameters within the structure, we defined parameter a
    first, followed by b, and then c, which means the order within the initializer
    is also a followed by b, and then c. When we make multiple parameters that are
    optional, we cannot leave off one of the parameters but still include others that
    come after it, therefore we cannot leave off parameter a and still include parameters
    `b` and c.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set or read a stored property, we use the standard dot syntax. Let''s look
    at how we would set and read stored properties in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line of code, we read the `c` property and store it into a variable
    named `x`. In the second line of code, we set the `v` property to the `Howdy`
    string. Before we move on to computed properties, let''s create both a structure
    and a class that will represent an employee. We will be using and expanding these
    throughout this chapter to show how classes and structures are similar, and how
    they differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The employee structure is named `EmployeeStruct`, and the employee class is
    named `EmployeeClass`. Both the class and structure have three stored properties:
    `firstName`, `lastName`, and `salaryYear`. Within the structure and class, we
    can access these properties by using the name of the property and the `self` keyword.
    Every instance of a structure or class has a property named `self`. This property
    refers to the instance itself; therefore, we can use it to access the properties
    within the instance. The following examples show how we can access the properties
    with the `self` keyword within the instance of the structure or class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Computed properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computed properties are properties that do not have backend variables, which
    are used to store the values associated with the property but are hidden from
    the external code. The values of a computed property are usually computed when
    code requests it. You can think of a computed property as a function disguised
    as a property. Let''s look at how we would define a read-only computed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To create a read-only computed property, we begin by defining it as if it were
    a normal variable with the `var` keyword, followed by the variable name, a colon,
    and the variable type. What comes next is different; we add a curly bracket at
    the end of the declaration and then define a getter method, which is called when
    the value of our computed property is requested. In this example, the getter method
    divides the current value of the `salaryYear` property by 52 to get the employee's
    weekly salary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simplify the definition of the read-only computed property by removing
    the `get` keyword, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Computed properties are not limited to being read-only; we can also write to
    them. To enable the `salaryWeek` property to be writeable, we will add a setter
    method. The following example shows how we add a setter method that will set the
    `salaryYear` property, based on the value being passed into the `salaryWeek` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the setter definition by not defining a name for the new value.
    In this case, the value will be assigned to a default variable named `newValue`,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `salaryWeek` computed property, as written in the preceding examples, could
    be added to either the `EmployeeClass` class or the `EmployeeStruct` structure
    without any modifications. Let''s see how we can do this by adding the `salaryWeek`
    property to our `EmployeeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how we can add the `salaryWeek` computed property to the
    `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the class and structure definitions are the same so far, except
    for the initial `class` or `struct` keywords that are used to define them. We
    read and write to a computed property exactly as we would to a stored property.
    Code that is external to the class or structure should not be aware that the property
    is a computed property. Let''s see this in action by creating an instance of the
    `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example starts off by creating an instance of the `EmployStruct`
    structure with the `salaryYear` value being set to 39,000\. Next, we print the
    value of the `salaryWeek` property to the console. This value is currently 750.00\.
    We then set the `salaryWeek` property to 1,000.00 and print out both the `salaryWeek`
    and `salaryYear` properties to the console. The values of the `salaryWeek` and
    `salaryYear` properties are now 1,000.00 and 52,000, respectively. As we can see,
    in this example, setting either the `salaryWeek` or `salaryYear` properties changes
    the values returned by both. Computed properties can be very useful for offering
    different views of the same data. For example, if we had a value that represented
    the length of something, we could store the length in centimeters and then use
    computed properties that calculate the values for meters, millimeters, and kilometers.
    Now, let's look at property observers.
  prefs: []
  type: TYPE_NORMAL
- en: Property observers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Property observers are called every time the value of the property is set.
    We can add property observers to any non-lazy stored property. We can also add
    property observers to any inherited stored or computed property by overriding
    the property in the subclass, which we will look at in the *Overriding properties*
    section. There are two property observers that we can set in Swift: `willSet`
    and `didSet`. The `willSet` observer is called right before the property is set,
    and the `didSet` observer is called right after the property is set. One thing
    to note about property observers is that they are not called when the value is
    set during initialization. Let''s look at how we can add a property observer to
    the salary property of our `EmployeeClass` class and `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we add a property observer to a stored property, we need to include the
    type of the value being stored within the definition of the property. In the preceding
    example, we did not need to define our `salaryYear` property as a `Double` type;
    however, when we add property observers, the definition is required. After the
    property definition, we define the `willSet` observer, which simply prints out
    the new value that the `salaryYear` property will be set to. We also define a
    `didSet` observer, which will check whether the new value is greater than the
    old value, and if so, it will print out that the employee got a raise; otherwise,
    it will print out that the employee did not get a raise. As with the getter method
    with computed properties, we do not need to define the name for the new value
    of the `willSet` observer. If we do not define a name, the new value is put in
    a constant named `newValue`. The following example shows how we can rewrite the
    previous `willSet` observer without defining a name for the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, properties are mainly used to store information associated
    with a class or structure. Methods are mainly used to add the business logic to
    a class or structure. Let's look at how we can add methods to a class or structure.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Methods are functions that are associated with an instance of a class or structure.
    A method, like a function, will encapsulate the code for a specific task or functionality
    that is associated with the class or structure. Let''s look at how we can define
    methods for classes and structures. The following code will return the full name
    of the employee by using the `firstName` and `lastName` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We define this method exactly as we would define any function. A method is simply
    a function that is associated with a specific class or structure, and everything
    that we learned about functions in the previous chapters applies to methods. The
    `fullName()` function can be added directly to the `EmployeeClass` class or `EmployeeStruct`
    structure without any modification. To access a method, we use the same dot syntax
    we used to access properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how we access the `fullName()` method of a class and
    a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we initialize an instance of both the `EmployeeClass`
    class and the `EmployeeStruct` structure. We populate the structure and class
    with the same information and then use the `fullName()` method to print the full
    name of the employee to the console. In both cases, `Jon Hoffman` is printed to
    the console. There is a difference in how we define methods for classes and structures
    that need to update property values. Let''s look at how we define a method that
    gives an employee a raise within the `EmployeeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add the preceding code to our `EmployeeClass`, it works as expected,
    and when we call the method with an amount, the employee gets a raise. However,
    if we try to add this method as it is written to the `EmployeeStruct` structure,
    we receive a `mark` method and a `mutating to make self mutable` error. By default,
    we are not allowed to update property values within a method of a structure. If
    we want to modify a property, we can mutate the behavior for that method by adding
    the `mutating` keyword before the `func` keyword of the method declaration. Therefore,
    the following code would be the correct way to define the `giveRaise(amount:)`
    method for the `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we use the `self` property to refer to the current
    instance of the type within the instance itself, so when we write `self.salaryYear`,
    we ask for the value of the `salaryYear` property for the current instance of
    the type.
  prefs: []
  type: TYPE_NORMAL
- en: The `self` property should only be used when necessary. We are using it in these
    examples to illustrate what it is and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `self` property is mainly used to distinguish between local and instance
    variables that have the same name. Let''s look at an example that illustrates
    this. We can add this function to either the `EmployeeClass` or `EmployeeStruct`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the method accepts an argument named `firstName`.
    There is also a property within the type that has the same name. We use the `self`
    property to specify that we want the instance property with the `firstName` name,
    and not the local variable with this name. Other than the `mutating` keyword being
    required for methods that change the value of the structure's properties, methods
    can be defined and used exactly as functions are defined and used. Therefore,
    everything we learned about functions in *Chapter 6*, *Functions*, can be applied
    to methods. There are times when we want to initialize properties or perform some
    business logic when a class or structure is first initialized. For this, we will
    use an initializer.
  prefs: []
  type: TYPE_NORMAL
- en: Custom initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initializers are called when we initialize a new instance of a type (class
    or structure). Initialization is the process of preparing an instance for use.
    The initialization process can include setting initial values for stored properties,
    verifying that external resources are available, or setting up the UI properly.
    Initializers are generally used to ensure that the instance of the class or structure
    is properly initialized prior to first use. Initializers are special methods that
    are used to create a new instance of a type. We define an initializer similarly
    to defining other methods, but we must use the `init` keyword as the name of the
    initializer to tell the compiler that this method is an initializer. In its simplest
    form, the initializer does not accept any arguments. Let''s look at the syntax
    that''s used to write a simple initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This format works for both classes and structures. By default, all classes
    and structures have an empty default initializer that can be overridden. We used
    these default initializers when we initialized the `EmployeeClass` class and `EmployeeStruct`
    structure in the previous section. Structures also have an additional default
    initializer, which we saw with the `EmployeeStruct` structure, which accepts a
    value for each stored property and initializes them with those values. Let''s
    look at how we add custom initializers to the `EmployeeClass` class and the `EmployeeStruct`
    structure. In the following code, we create three custom initializers that will
    work for both the `EmployeeClass` class and the `EmployeeStruct` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The first initializer, `init()`, will set all of the stored properties to their
    default values. The second initializer, `init(firstName: String, lastName: String)`,
    will populate the `firstName` and `lastName` properties with the values of the
    arguments. The third initializer, `init(firstName: String, lastName: String, salaryYear:
    Double)`, will populate all the properties with the values of the arguments. In
    the previous example, we can see that in Swift, an initializer does not have an
    explicit return value, but it does return an instance of the type. This means
    that we do not define a return type for the initializer or have a return statement
    within the initializer. Let''s look at how we could use these initializers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `g` instance of `EmployeeClass` uses the `init()` initializer to create
    an instance of the `EmployeeClass` class; therefore, all the properties of this
    instance contain their default values. The `h` instance of `EmployeeStruct` uses
    the `init(firstName: String, lastName: String)` initializer to create an instance
    of the `EmployeeStruct` structure; therefore, the `firstName` property is set
    to `Me` and the `lastName` property is set to `Moe`, which are the two arguments
    passed into the initializer. The `salaryYear` property is still set to the default
    value of `0.0`. The `i` instance of `EmployeeClass` uses the `init(firstName:
    String, lastName: String, salaryYear: Double0)` initializer to create an instance
    of the `EmployeeClass` class; therefore, the `firstName` property is set to `Me`,
    the `lastName` property is set to `Moe`, and the `salaryYear` property is set
    to `45_000`. Since all the initializers are identified with the `init` keyword,
    the parameters and parameter types are used to identify which initializer to use.
    A class, unlike a structure, can have a deinitializer. A deinitializer is called
    just before an instance of the class is destroyed and removed from memory. In
    *Chapter 18*, *Memory Management*, we will show examples of the deinitializer
    and see when it is called. Let''s look at internal and external parameter names
    with initializers.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal and external parameter names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like functions, the parameters associated with an initializer can have
    separate internal and external names. If we do not supply external parameter names
    for our parameters, Swift will automatically generate them for us. In the previous
    examples, we did not include external parameter names in the definition of the
    initializers, so Swift created them for us using the internal parameter name as
    the external parameter name. If we wanted to supply our own parameter names, we
    would do so by putting the external parameter name before the internal parameter
    name, exactly as we do with any normal function. Let''s look at how we can define
    our own external parameter names by redefining one of the initializers within
    our `EmployeeClass` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created the `init(employeeWithFirstName firstName:
    String, lastName lastName: String, andSalary salaryYear: Double)` initializer.
    This initializer will create an instance of the `EmployeeClass` class and populate
    the instance properties with the value of the arguments. In this example, each
    of the parameters has both external and internal property names. Let''s look at
    how we would use this initializer, with the external property names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are now using the external parameter names as defined in the
    initializer. Using external parameter names can help make our code more readable
    and help differentiate between different initializers. So, what will happen if
    our initializer fails? For example, what if our class relies on a specific resource,
    such as a web service that is not currently available? This is where failable
    initializers come in.
  prefs: []
  type: TYPE_NORMAL
- en: Failable initializers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A failable initializer is an initializer that may fail to initialize the resources
    needed for a class or a structure, thereby rendering the instance unusable. When
    using a failable initializer, the result of the initializer is an optional type,
    containing either a valid instance of the type or nil. An initializer can be made
    failable by adding a question mark (`?`) after the `init` keyword. Let''s look
    at how we can create a failable initializer that will not allow a new employee
    to be initialized with a salary of less than $20,000 a year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous examples, we did not include a `return` statement within the
    initializer because Swift does not need to return the initialized instance; however,
    in a failable initializer, if the initialization fails, it must return nil. If
    the initializer successfully initializes the instance, we do not need to return
    anything. Therefore, in our example, if the yearly salary that is passed in is
    less than $20,000 a year, we return `nil`, indicating that the initialization
    failed, otherwise nothing will be returned. Let''s look at how we would use a
    failable initializer to create an instance of a class or structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we initialize the instance of the `EmployeeClass`
    class with a yearly salary of greater than $20,000; therefore, the instance gets
    initialized correctly and the full name of `Jon Hoffman` is printed to the console.
    Now, let''s try to initialize an instance of the `EmployeeClass` class with a
    yearly salary of less than $20,000 to see how it fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the yearly salary that we are attempting to initialize
    for our employee is less than $20,000, therefore the initialization fails and
    a `Failed to initialize` messageis printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when we want to restrict access to certain parts of our code.
    For this, we use access controls.
  prefs: []
  type: TYPE_NORMAL
- en: Access controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Access controls enable us to hide implementation details and only expose the
    interfaces we want to expose. This feature is handled with access controls. We
    can assign specific access levels to both classes and structures. We can also
    assign specific access levels to properties, methods, and initializers that belong
    to our classes and structures. In Swift, there are five access levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open**: This is the most visible access control level. It allows us to use
    the property, method, class, and so on anywhere we want to import the module.
    Basically, anything can use an item that has an access-control level of open.
    Anything that is marked open can be subclassed or overridden by any item within
    the module they are defined in and any module that imports the module it is defined
    in. This level is primarily used by frameworks to expose the framework''s public
    API. The open-access control is only available to classes and members of a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: This access level allows us to use the property, method, class,
    and so on anywhere we want to import the module. Basically, anything can use an
    item that has an access-control level of public. Anything that is marked public
    can be subclassed or overridden only by any item within the module they are defined
    in. This level is primarily used by frameworks to expose the framework''s public
    API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: This is the default access level. This access level allows us
    to use the property, method, class, and so on in the module the item is defined
    in. If this level is used in a framework, it lets other parts of the framework
    use the item but code outside the framework will be unable to access it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fileprivate**: This access control allows access to the properties and methods
    from any code within the same source file that the item is defined in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This is the least visible access-control level. It only allows
    us to use the property, method, class, and so on, within extensions of the declaration
    defined in the source file that defines it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we are developing frameworks, the access controls really become useful.
    We will need to mark the public-facing interfaces as public or open so that other
    modules, such as applications that import the framework, can use them. We will
    then use the internal and private access-control levels to mark the interfaces
    that we want to use internally to the framework and the source file, respectively.
    To define access levels, we place the name of the level before the definition
    of the entity. The following code shows examples of how we can add access levels
    to several entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some limitations with access controls, but these limitations are
    there to ensure that access levels in Swift follow a simple guiding principle:
    no entity can be defined in terms of another entity that has a lower (more restrictive)
    access level. This means that we cannot assign a higher (less restrictive) access
    level to an entity when it relies on another entity that has a lower (more restrictive)
    access level. The following examples demonstrate this principle:'
  prefs: []
  type: TYPE_NORMAL
- en: We cannot mark a method as being public when one of the arguments or the return
    type has an access level of private, because external code would not have access
    to the private type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot set the access level of a method or property to public when the class
    or structure has an access level of private, because external code would not be
    able to access the constructor when the class is private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let's look at a new feature in Swift 5.2, key-path expressions as functions.
  prefs: []
  type: TYPE_NORMAL
- en: Key-path expressions as functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SE-0249 in Swift 5.2 introduced a great shortcut which enables us to easily
    access the properties of objects in a particular collection. What this means is
    if we iterate over a collection using the `map` algorithm, we are able to use
    key-path expressions `(\Root.value`) to access the properties of the items in
    the collection. Let''s look at an example using the employee structure we created
    earlier. We will start by creating three employees and adding them to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an array of employees, let''s retrieve all of the first names
    of our employees. We could loop through our array and pull out the names one by
    one, but if we combine the map algorithm that we saw in *Chapter 5*, *Using Swift
    Collections*, with this new feature, we could retrieve all first names like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With this code, the firstName array will contain the first name for each employee
    in our employeeCollection array.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another new feature with Swift 5.2, calling a type as a function.
  prefs: []
  type: TYPE_NORMAL
- en: Calling a type as a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With SE-0253 in Swift 5.2, we are able to call a type as a function. To explain
    it a little better, instances of types that have a method whose name is `callAsFunction`
    can be called as if they were a function. Let''s look at an example of this. We
    will start off by creating a `Dice` type that can be used to create an instance
    of any size dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the method within the function called callAsFunction(). This function
    generates a random number using the `lowValue` and `highValue` properties. Since
    we named this method `callAsFunction`, we are able to call it using the instance''s
    name as if it were a function. Let''s see how this works by creating a six-sided
    dice and generating a random value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `roll` variable will contain a random value generated from the `callAsFunction()`
    method. This enables us to simplify how we call certain functions. In the previous
    example, we are able to generate the roll of the dice by simply calling `d6()`
    rather than calling the instance with a function name like `d6.generateRoll()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at what inheritance is.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of inheritance is a basic object-oriented development concept. Inheritance
    allows a class to be defined as having a certain set of characteristics, and then
    other classes can be derived from that class. The derived class inherits all of
    the features of the class it is inheriting from (unless the derived class overrides
    those characteristics) and then usually adds additional characteristics of its
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is one of the fundamental differences that separates classes from
    structures. Classes can be derived from a parent or superclass, but a structure
    cannot.
  prefs: []
  type: TYPE_NORMAL
- en: With inheritance, we can create what is known as a class hierarchy. In a class
    hierarchy, the class at the top of the hierarchy is known as the base class, and
    the derived classes are known as subclasses. We are not limited to only creating
    subclasses from a base class, we can also create subclasses from other subclasses.
    The class that a subclass is derived from is known as the parent or superclass.
    In Swift, a class can have only one parent class. This is known as single inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses can call and access the properties, methods, and subscripts of their
    superclass. They can also override the properties, methods, and subscripts of
    their superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subclasses can add property observers to properties that they inherit from
    a superclass so that they can be notified when the values of the properties change.
    Let''s look at an example that illustrates how inheritance works in Swift. We
    will start off by defining a base class named `Plant`. The `Plant` class will
    have two properties: `height` and `age`. It will also have one method: `growHeight()`.
    The `height` property will represent the height of the plant, the `age` property
    will represent the age of the plant, and the `growHeight()` method will be used
    to increase the height of the plant. Here is how we would define the `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `Plant` base class, let''s see how we would define a subclass
    of it. We will name this subclass `Tree`. The `Tree` class will inherit the `age`
    and `height` properties of the `Plant` class and add one more property, named
    `limbs`. It will also inherit the `growHeight()` method of the `Plant` class and
    add two more methods: `limbGrow()`, where new limbs are grown, and `limbFall()`,
    where limbs fall off the tree. Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We indicate that a class has a superclass by adding a colon and the name of
    the superclass to the end of the class definition. In this example, we indicated
    that the `Tree` class has a superclass named `Plant`. Now, let''s look at how
    we could use the `Tree` class that inherited the `age` and `height` properties
    from the `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example begins by creating an instance of the `Tree` class. We
    then set the `Age` and `height` properties to `5` and `4`, respectively, and added
    two limbs to the tree by calling the `limbGrow()` method twice. We now have a
    base class named `Plant` that has a subclass named `Tree`. This means that the
    super (or parent) class of `Tree` is the `Plant` class. This also means that one
    of the subclasses (or child classes) of `Plant` is named `Tree`. There are, however,
    lots of different kinds of trees in the world. Let''s create two subclasses from
    the `Tree` class. These subclasses will be the `PineTree` class and the `OakTree`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The class hierarchy now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16683_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Inheritance class hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to keep in mind that, in Swift, a class can have multiple subclasses;
    however, a class can have only one superclass. There are times when a subclass
    needs to provide its own implementation of a method or property that it inherited
    from its superclass. This is known as **overriding**.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods and properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To override a method, property, or subscript, we need to prefix the definition
    with the `override` keyword. This tells the compiler that we intend to override
    something in the superclass, and that we did not make a duplicate definition by
    mistake. The `override` keyword prompts the Swift compiler to verify that the
    superclass (or one of its parents) has a matching declaration that can be overridden.
    If it cannot find a matching declaration in one of the superclasses, an error
    will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how we can override a method. We will start by adding a `getDetails()`
    method to the `Plant` class that we will then override in the child classes. The
    following code shows the code for the new `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how we can override the `getDetails()` method in the `Tree`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing to note here is that we do not use the `override` keyword in the
    `Plant` class because it is the first class to implement this method; however,
    we do include it in the `Tree` class since we are overriding the `getDetails()`
    method from the `Plant` class. Now, let''s see what happens if we call the `getDetails()`
    method from an instance of the `Plant` and `Tree` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous example will print the following two lines to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `getDetails()` method in the `Tree` subclass overrides the
    `getDetails()` of its parent `Plant` class. Inside the `Tree` class, we can still
    call the `getDetails()` method (or any overridden method, property, or subscript)
    of its superclass by using the `super` prefix. We will begin by replacing the
    `getDetails()` method in the `Plant` class with the following method, which will
    generate a string that contains the values of the `height` and `age` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will replace the `getDetails()` method for the `Tree` class with the
    following method, which will call the `getDetails()` method of the superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we begin by calling the `getDetails()` method of
    the superclass (the `Plant` class in this case) to get a string that contains
    the tree''s height and age. We then build a new string object that combines the
    results of the `getDetails()` method and a new string that contains the number
    of limbs from the `Tree` class. This new string is then returned. Let''s look
    at what happens if we call this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding code, the following line will be printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the string that is returned contains the `height` and `age` information
    from the `Plant` class and the `limbs` information from the `Tree` class.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can provide custom getters and setters to override any inherited property.
    When we override a property, we must provide the name and the type of property
    we are overriding so that the compiler can verify that one of the classes in the
    class hierarchy has a matching property to override. Let''s see how we can override
    a property by adding the following property to our `Plant` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `description` property is a basic read-only property. This property returns
    the `Base class is Plant` string. Now, let''s override this property by adding
    the following property to the `Tree` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The same `override` keyword is used when overriding both properties and methods.
    This keyword tells the compiler that we want to override a property so that the
    compiler can verify that another class in the class hierarchy contains a matching
    property to override. We then implement the property as we would any other property.
    Calling the `description` property for an instance of the `Tree` class will result
    in the `Base class is Plant. I am a Tree class` string being returned. There are
    times when we want to prevent a subclass from overriding the properties and methods.
    There are also times when we want to prevent an entire class from being subclassed.
    Let's see how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing overrides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prevent overrides or subclassing, we can use the `final` keyword. To use
    the `final` keyword, we add it before the item's definition. Examples are `final
    func`, `final var`, and `final class`. Any attempt to override an item marked
    with this keyword will result in a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we would like to describe the implementations (methods,
    properties, and other requirements) of a type without actually providing any implementation.
    For this, we can use protocols. Protocols define a blueprint of methods, properties,
    and other requirements for a class or a structure. A class or a structure can
    then provide an implementation that conforms to those requirements. The class
    or structure that provides the implementation is said to conform to the protocol.
    Protocols are very important to the Swift language. The entire Swift standard
    library is based on them, and we will be looking at protocols and how to use them
    in *Chapter 9*, *Protocols and Protocol Extensions*, and *Chapter 10*, *Protocol
    Oriented Design*.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax to define a protocol is very similar to how we define a class or
    a structure. The following example shows the syntax that''s used to define a protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We state that a class or structure conforms to a protocol by placing the name
    of the protocol after the type''s name, separated by a colon. Here is an example
    of how we would state that a structure conforms to the `MyProtocol` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A type can conform to multiple protocols. We list the protocols that the type
    conforms to by separating them with commas. The following example shows how we
    would state that our structure conforms to multiple protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need a class to both inherit from a superclass and implement a protocol,
    we would list the superclass first, followed by the protocols. The following example
    illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Property requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A protocol can require that the conforming type provides certain properties
    with a specified name and type. The protocol does not say whether the property
    should be a stored or computed property because the implementation details are
    left up to the conforming type. When defining a property within a protocol, we
    must specify whether the property is a read-only or read-write property by using
    the `get` and `set` keywords. Let''s look at how we would define properties within
    a protocol by creating a protocol named `FullName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FullName` protocol defines two properties, which any type that conforms
    to the protocol must implement. These are the `firstName` and `lastName` properties,
    and both are read-write properties. If we wanted to specify that the property
    is read-only, we would define it with only the `get` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how we can create a `Scientist` class that conforms to this protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If we had forgotten to include either of the required properties, we would have
    received an error message letting us know the property we forgot. We also need
    to make sure that the type of the property is the same. For example, if we change
    the definition of the `lastName` property in the `Scientist` class to `var lastName
    = 42`, we will also receive an error message because the protocol specifies that
    we must have a `lastName` property of the string type.
  prefs: []
  type: TYPE_NORMAL
- en: Method requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A protocol can require that the conforming class or structure provides certain
    methods. We define a method within a protocol exactly as we do within a class
    or structure, except without the method body. Let''s add a `fullName()` method
    to our `FullName` protocol and `Scientist` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add a `fullName()` method to our `Scientist` class so that
    it will conform to the protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Structures can conform to Swift protocols exactly as classes do. In fact, the
    majority of the Swift standard library are structures that implement the various
    protocols that make up the standard library. The following example shows how we
    can create a `FootballPlayer` structure that also conforms to the `FullName` protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When a class or structure conforms to a Swift protocol, we can be sure that
    it has implemented the required properties and methods. This can be very useful
    when we want to ensure that certain properties or methods are implemented over
    various classes, as our preceding examples show. Protocols are also very useful
    when we want to decouple our code from requiring specific types. The following
    code shows how we would decouple our code using the `FullName` protocol, the `Scientist`
    class, and the `FootballPlayer` structure that we have already built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by creating an instance of the `Scientist` class
    and the `FootballPlayer` structure. We then create a `person` variable that is
    of the `FullName (protocol)` type and set it to the `scientist` instance that
    we just created. We then call the `fullName()` method to retrieve our description.
    This will print out the `Kara Hoffman studies Physics` message to the console.
    We then set the `person` variable equal to the `player` instance and call the
    `fullName()` method again. This will print out the `Dan Marino has the number
    13` message to the console. As we can see, the `person` variable does not care
    what the actual implementation type is. Since we defined the `person` variable
    to be of the `FullName` type, we can set the variable to an instance of any type
    that conforms to the `FullName` protocol. This is called polymorphism. We will
    cover polymorphism and protocols more in *Chapter 9*, *Protocols and Protocol
    Extensions*, and *Chapter 10*, *Protocol Oriented Design*.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With extensions, we can add new properties, methods, initializers, and subscripts,
    or make an existing type conform to a protocol without modifying the source code
    for the type. One thing to note is that extensions cannot override the existing
    functionality. To define an extension, we use the `extension` keyword, followed
    by the type that we are extending.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we would create an extension that extends the
    `string` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how extensions work by adding a `reverse()` method and a `firstLetter`
    property to Swift''s standard `string` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When we extend an existing type, we define properties, methods, initializers,
    subscripts, and protocols in exactly the same way as we would normally define
    them in a standard class or structure. In the string extension example, we can
    see that we define the `reverse()` method and the `firstLetter` property exactly
    as we would define them in a normal type. We can then use these methods exactly
    as we would use any other method, as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Swift 4 did add the `reversed()` method to the string type, which should be
    preferred over the one we created here. This example just illustrates how to use
    extensions. Extensions are very useful for adding extra functionality to an existing
    type from external frameworks, even for Apple's frameworks, as demonstrated in
    this example. It is preferred to use extensions to add extra functionality to
    types from external frameworks rather than subclassing, because it allows us to
    continue to use the type throughout our code rather than changing the type to
    the subclass. Before we finish this chapter, let's take another look at optional
    chaining now that we have an understanding of classes and structures.
  prefs: []
  type: TYPE_NORMAL
- en: Property wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Property wrappers were introduced in Swift 5.1 with SE-0258 and they enable
    property values to be wrapped using a custom type. In order to perform this wrapping,
    we must create a custom attribute and a type that will handle the attribute. To
    see an example of this, let''s say that we want to trim all of the whitespace
    characters from the beginning and the ending of our string values. We could do
    this by using the getter and setter methods of our properties to trim the whitespace
    characters; however, we would have to put this logic in for each property that
    we wanted to trim. With property wrappers, we would do this much more easily.
    We will start off by creating our custom type that will be used as a wrapper;
    we will name it Trimmed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The previous code starts off by using the @propertyWrapper attribute to define
    that this type can be used as a property wrapper. Any type that is defined as
    a property wrapper must have a non-static property named wrappedValue, which we
    define as a `String` type within our Trimmed type. Finally, we create an initializer
    that is used to set the wrappedValue property.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look back at the `EmployeeStruct` structure that we created earlier in
    the chapter, we defined two `String` properties like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to trim all of the whitespaces from the beginning and ending of
    these properties, all we would need to do now is to add an @Trimmed attribute
    to them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we created new instances of the `EmployeeStruct` structure like this
    (notice the spaces in the initializer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `firstName` and `lastName` properties will contain the values with the whitespace
    characters automatically removed.
  prefs: []
  type: TYPE_NORMAL
- en: Optional chaining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Optional binding allows us to unwrap one optional at a time, but what would
    happen if we had optional types embedded within other optional types? This would
    force us to have optional binding statements embedded within other optional binding
    statements. There is a better way to handle this: by using optional chaining.
    Before we look at optional chaining, let''s see how this would work with optional
    binding. We will start off by defining three types that we will be using for our
    examples in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we begin by defining a `Collar` class, which has one property
    defined. This property is named `color`, which is of the string type. We can see
    that the `color` property is not an optional; therefore, we can safely assume
    that it will always have a valid value. Next, we define a `Pet` class that has
    two properties defined. These properties are named `name` and `collar`. The `name`
    property is of the string type and the `collar` property is an optional that may
    contain an instance of the `Collar` type or may contain no value. Finally, we
    define a `Person` class, which also has two properties. These properties are named
    `name` and `pet`. The `name` property is of the string type and the `pet` property
    is an optional that may contain an instance of the `Pet` type or may contain no
    value. For the examples that follow, let''s use the following code to initialize
    the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we want to get the color of the collar for a person''s
    pet; however, the person may not have a pet (the `pet` property may be `nil`)
    or the pet may not have a collar (the `collar` property may be `nil`). We could
    use optional binding to drill down through each layer, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'While this example is perfectly valid and would print out a `The color of the
    collar is red` message, the code is rather messy and hard to follow because we
    have multiple optional binding statements on the same line, where the second optional
    binding statement is dependent on the first one. Optional chaining allows us to
    drill down through multiple optional type layers of properties, methods, and subscripts
    in one line of code. These layers can be chained together and if any layer returns
    `nil`, the entire chain gracefully fails and returns `nil`. If none of the values
    returns `nil`, the last value of the chain is returned. Since the results of optional
    chaining may be a `nil` value, the results are always returned as an optional
    type, even if the final value we are retrieving is a non-optional type. To specify
    optional chaining, we place a question mark (`?`) after each of the optional values
    within the chain. The following example shows how to use optional chaining to
    make the preceding example much cleaner and easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we put a question mark after the `pet` and `collar` properties
    to signify that they are of the optional type and that, if either value is `nil`,
    the whole chain will return `nil`. This code would also print out the `The color
    of the collar is red` message; however, it is much easier to read than the preceding
    example because it clearly shows us what optionals we are dependent on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took an in-depth look at classes and structures. We saw
    what makes them so similar and also what makes them so different. In the upcoming
    chapters, it will be important to remember that classes are reference types while
    structures are value types. We also looked at protocols and extensions. As this
    chapter ends, we end the introduction to the Swift programming language. At this
    point, we have enough knowledge of the Swift language to begin writing our own
    applications; however, there is still much to learn. In the following chapters,
    we will look in more depth at some of the concepts that we've already discussed,
    such as protocols and subscripts. We will also see how we can use protocol-oriented
    programming techniques to write easy-to-manage code. Finally, we will have chapters
    that will help us write better code, such as a sample Swift style guide, and a
    chapter on design patterns.
  prefs: []
  type: TYPE_NORMAL
