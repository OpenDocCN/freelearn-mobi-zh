- en: '*Chapter 7*: Flexible Code with Protocols, Generics, and Extensions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用协议、泛型和扩展实现灵活的代码'
- en: Seasoned programmers will (or should) know the core concepts of **object-oriented
    programming** (**OOP**). It's been around for a while, and it has shaped the way
    many of us develop and think about software. But a relatively new paradigm on
    the scene comes in the form of protocols with **protocol-oriented programming**
    (**POP**). Not intended as a replacement for OOP, POP has gained a lot of traction
    over the years, especially with the Swift community.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的程序员（或应该知道）面向对象编程（**OOP**）的核心概念。它已经存在了一段时间，并且塑造了我们许多人开发软件的方式。但相对较新的范式以协议的形式出现，即**协议导向编程**（**POP**）。POP并不是作为OOP的替代品，但近年来它获得了很大的关注，尤其是在Swift社区中。
- en: In this chapter, we'll learn everything we need to know about POP, from standard
    implementation to associated types and then onto generics. By the end of this
    chapter, you'll be extremely confident with not only implementing POP in your
    app, but also understanding what it has to offer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于POP（Post Office Protocol）所需了解的一切，从标准实现到关联类型，再到泛型。到本章结束时，你将对自己在应用中实现POP以及理解它所能提供的内容充满信心。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding and implementing protocols
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和实现协议
- en: Getting the best out of extensions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充分利用扩展
- en: Adding flexibility with generics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用泛型增加灵活性
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need to download Xcode version 11.4 or above from Apple's
    App Store.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要从Apple的App Store下载Xcode版本11.4或更高版本。
- en: You'll also need to be running the latest version of macOS (Catalina or above).
    Simply search for `Xcode` in the App Store and select and download the latest
    version. Launch Xcode and follow any additional installation instructions that
    your system may prompt you with. Once Xcode has fully launched, you're ready to
    go.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要运行最新的macOS（Catalina或更高版本）。只需在App Store中搜索`Xcode`，选择并下载最新版本。启动Xcode，并遵循系统可能提示的任何附加安装说明。一旦Xcode完全启动，你就可以开始了。
- en: 'Download the sample code from the following GitHub link: [https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下GitHub链接下载示例代码：[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition/tree/master/Chapter%207%20-%20Playground/Protocols.playground)
- en: Understanding and implementing protocols
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和实现协议
- en: Swift and `UIKit` have protocols at the core of their design. You might have
    noticed this when you were implementing custom `UIViewController` transitions,
    or when you worked on a table view or collection view. When you implement these
    features, you create objects that function as delegates for the transitions, table
    views, and collection views and conform them to specific protocols. When you worked
    on view controller transitions in [*Chapter 5*](B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141),
    *Immersing Your Users with Animation*, we also implemented an `NSObject` subclass
    that conformed to `UIViewControllerAnimatedTransitioning`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Swift和`UIKit`的设计核心是协议。你可能注意到了这一点，当你实现自定义`UIViewController`过渡，或者当你处理表格视图或集合视图时。当你实现这些功能时，你创建的对象充当过渡、表格视图和集合视图的代理，并将它们符合特定的协议。当你在[*第5章*](B14717_05_Final_ASB_ePub.xhtml#_idTextAnchor141)“使用动画沉浸你的用户”中处理视图控制器过渡时，我们也实现了一个符合`UIViewControllerAnimatedTransitioning`的`NSObject`子类。
- en: With that said, let's take a deeper look at how we would handle creating and
    designing our own protocols to use in our Swift app.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们更深入地探讨一下我们如何创建和设计自己的协议，以便在Swift应用中使用。
- en: Defining your own protocols
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自己的协议
- en: Protocols are not confined to delegate behavior only. Defining a protocol is
    very similar to defining a class, struct, or enum. The main difference is that
    a protocol does not implement or store any values on its own. It acts as a contract
    between whoever calls an object that conforms to a protocol and the object that
    claims to conform to the protocol.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 协议不仅限于代理行为。定义一个协议与定义一个类、结构体或枚举非常相似。主要区别在于，协议本身不实现或存储任何值。它充当调用符合协议的对象与声称符合协议的对象之间的合同。
- en: Let's take a look at this by writing some code, we'll create a new playground
    in order to do this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些代码来看看这个例子，我们将创建一个新的游乐场来完成这个任务。
- en: 'Let''s implement a simple protocol that defines the expectations for any object
    that claims to be a pet. The protocol will be called the `PetType` protocol. Protocols
    defined in UIKit and the Swift standard library use either `Type`, `Ing`, or `Able`
    as a suffix to indicate that the protocol defines a behavior rather than a concrete
    type. You should try to follow this convention as much as possible because it
    makes your code easier to understand for other developers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个简单的协议，定义任何声称自己是宠物的对象应满足的期望。该协议将被称为 `PetType` 协议。在 UIKit 和 Swift 标准库中定义的协议使用
    `Type`、`Ing` 或 `Able` 作为后缀来表示协议定义的是行为而不是具体类型。你应该尽可能遵循这个约定，因为它使你的代码对其他开发者更容易理解：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The definition for `PetType` states that any object that claims to be `PetType`
    must have a get-only variable (a constant) called `name`, an `age` that can be
    changed because it specifies both `get` and `set`, a `sleep()` method that makes
    the pet rest, and finally, a static variable that describes the Latin name of
    `PetType`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetType` 的定义表明，任何声称自己是 `PetType` 的对象必须有一个只读变量（一个常量）称为 `name`，一个可以更改的 `age`（因为它指定了
    `get` 和 `set`），一个使宠物休息的 `sleep()` 方法，以及最后，一个静态变量，用于描述 `PetType` 的拉丁名。'
- en: Whenever you define that a protocol requires a certain variable to exist, you
    must also specify whether the variable should be gettable, settable, or both.
    If you specify that a certain method must be implemented, you write the method
    just as you usually would, but you stop at the first curly bracket. You only write
    down the method signature.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你定义一个协议要求存在某个变量时，你也必须指定该变量应该是可获取的、可设置的，还是两者都可以。如果你指定必须实现某个方法，你就像平常一样编写该方法，但你在第一个花括号处停止。你只写下方法签名。
- en: A protocol can also require that the implementer has a static variable or method.
    This is convenient in the case of `PetType` because the Latin name of a pet does
    not necessarily belong to a specific pet, but to the entire species that the pet
    belongs to, so implementing this as a property of the type rather than the instance
    makes a lot of sense.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 协议还可以要求实现者有一个静态变量或方法。对于 `PetType` 来说，这是方便的，因为宠物的拉丁名不一定属于某个特定的宠物，而是属于宠物所属的整个物种，因此将此作为类型的属性而不是实例的属性来实现是非常有意义的。
- en: 'To demonstrate how powerful a small protocol such as `PetType` can be, you
    will implement two pets: a cat and a dog. You''ll also write a function that takes
    any pet and then makes them take a nap by calling the `sleep()` method.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示一个像 `PetType` 这样的小协议有多强大，你将实现两个宠物：一只猫和一只狗。你还将编写一个函数，它接受任何宠物，然后通过调用 `sleep()`
    方法让它们打盹。
- en: 'An OOP approach to this protocol could be to create a class called `Pet`, and
    then create two subclasses, `Cat` and `Dog`. A `sleep()` method would take an
    instance of `Pet`, and it would look a bit like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个协议的面向对象方法，可以创建一个名为 `Pet` 的类，然后创建两个子类，`Cat` 和 `Dog`。`sleep()` 方法将接受一个 `Pet`
    的实例，它看起来可能像这样：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't get me wrong, the preceding object-oriented approach works and on such
    a small scale, no real problems will occur.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要误解，前面提到的面向对象的方法是有效的，在如此小的规模上，不会出现真正的问题。
- en: However, when the inheritance hierarchy grows, you typically end up with base
    classes that contain methods that are only relevant to a couple of subclasses.
    Alternatively, you will find yourself unable to add certain functionalities to
    a certain class because the inheritance hierarchy gets in the way after a while.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当继承层次结构增长时，你通常会得到一些基类，这些类中包含的方法只与少数几个子类相关。或者，你可能会发现自己无法向某个类添加某些功能，因为继承层次结构在一段时间后就会阻碍。
- en: 'Let''s see what it looks like when you use the `PetType` protocol to solve
    this challenge without using inheritance at all:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当你使用 `PetType` 协议解决这个挑战而不使用任何继承时，它看起来会是什么样子：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We just managed to implement a single method that can take both the `Cat` and
    `Dog` objects and makes them take a nap.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚成功实现了一个可以同时接受 `Cat` 和 `Dog` 对象并使它们打盹的单个方法。
- en: 'Instead of checking for a type, the code checks that the pet that is passed
    in conforms to the `PetType` protocol, and if it does, its `sleep()` method can
    be called because the protocol dictates that any `PetType` instance must implement
    a `sleep()` method. This brings us to the next topic of this chapter: checking
    for traits instead of types.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不是检查类型，而是检查传入的宠物是否符合`PetType`协议，如果符合，则可以调用其`sleep()`方法，因为协议规定任何`PetType`实例都必须实现`sleep()`方法。这引出了本章的下一个主题：检查特性而不是类型。
- en: Checking for traits instead of types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查特性而不是类型
- en: 'In classic OOP, you often create superclasses and subclasses to group together
    objects with similar capabilities. If you roughly model a group of felines in
    the animal kingdom with classes, you end up with a diagram that looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的面向对象编程中，你通常会创建超类和子类来将具有相似能力的对象分组在一起。如果你用类大致模拟动物王国的猫科动物群体，你最终得到的图示看起来像这样：
- en: '![Figure 7.1 – Object-orientated flow'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 面向对象流程'
- en: '](img/Figure_7.01_B14717.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B14717.jpg)'
- en: Figure 7.1 – Object-orientated flow
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 面向对象流程
- en: If you try to model more animals, you will find that it's a complex task because
    some animals share a whole bunch of traits, although they are quite far apart
    from each other in the class diagram.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试模拟更多的动物，你会发现这是一个复杂的工作，因为一些动物虽然彼此在类图中相距甚远，但它们共享许多特性。
- en: One example would be that both cats and dogs are typically kept as pets. This
    means that they should optionally have an owner and maybe a home. But cats and
    dogs aren't the only animals kept as pets because fish, guinea pigs, rabbits,
    and even snakes are kept as pets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是猫和狗通常被当作宠物。这意味着它们可以有一个所有者，也许还有一个家。但猫和狗并不是唯一被当作宠物的动物，因为鱼、豚鼠、兔子甚至蛇也被当作宠物。
- en: It would be tough to figure out a sensible way to restructure your class hierarchy
    in such a way that you don't have to redundantly add owners and homes to every
    pet in the hierarchy because it would be impossible to add these properties to
    the right classes selectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一种合理的方式重新结构化你的类层次结构，以便你不必在层次结构中的每个宠物上重复添加所有者和家，这将是困难的，因为不可能有选择性地将这些属性添加到正确的类中。
- en: This problem gets even worse when you write a function or method that prints
    a pet's home. You would either have to make that function accept any animal or
    write a separate implementation of the same function for each type that has the
    properties you're looking for. Neither of these approaches makes sense because
    you don't want to write the same function over and over again with just a different
    class for the parameter. Even if you choose to do this and you end up with a method
    that prints an animal's home address that accepts a `Fish` instance, passing an
    instance of `GreatWhiteShark` to a function called `printHomeAddress()` doesn't
    make a lot of sense either, because sharks typically don't have home addresses.
    Of course, the solution to this problem is to use protocols.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个打印宠物家的函数或方法时，这个问题变得更糟。你可能不得不让这个函数接受任何动物，或者为具有你所需属性的每种类型编写相同的函数的单独实现。这两种方法都不合理，因为你不想重复编写相同的函数，只是参数的类不同。即使你选择这样做，最终得到一个接受`Fish`实例的打印动物家的地址的方法，将`GreatWhiteShark`实例传递给名为`printHomeAddress()`的函数也没有太多意义，因为鲨鱼通常没有家地址。当然，这个问题的解决方案是使用协议。
- en: In the situation described in the previous section, objects were mostly defined
    by what they are, not by what they do. We care about the fact that an animal is
    part of a particular family or type, not about whether it lives on land. You can't
    differentiate between animals that can fly and animals that can't because not
    all birds can fly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节描述的情况中，对象主要是根据它们是什么来定义的，而不是根据它们做什么。我们关心的是动物是否属于特定的家族或类型，而不是它们是否生活在陆地上。你不能区分会飞的动物和不会飞的动物，因为并非所有鸟类都会飞。
- en: 'Inheritance isn''t compatible with this way of thinking. Imagine a definition
    for a `Pigeon` struct that looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 继承与这种思维方式不兼容。想象一下一个`Pigeon`结构的定义，看起来像这样：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since `Pigeon` is a struct, you know that `Bird` isn't a struct or class—it's
    a protocol that defines a couple of requirements about what it means to be a bird.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Pigeon`是一个结构体，你知道`Bird`不是一个结构体或类——它是一个协议，定义了成为鸟类的一些要求。
- en: The `Pigeon` struct also conforms to the `FlyingType`, `OmnivoreType`, and `Domesticatable`
    protocols. Each of these protocols tells you something about `Pigeon` regarding
    its capabilities or traits. The definition explains what a pigeon is and does
    instead of merely communicating that it inherits from a certain type of bird.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pigeon` 结构体也符合 `FlyingType`、`OmnivoreType` 和 `Domesticatable` 协议。每个协议都告诉你有关
    `Pigeon` 的能力或特性的信息。定义解释了鸽子是什么以及它能做什么，而不仅仅是传达它继承自某种类型的鸟类。'
- en: For example, almost all birds can fly, but there are some exceptions to the
    rule. You could model this with classes, but this approach is tedious and might
    be inflexible, depending on your needs and how your code evolves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，几乎所有的鸟类都能飞翔，但也有一些例外。你可以用类来模拟这种情况，但这种方法可能很繁琐，并且可能不够灵活，这取决于你的需求和代码如何演变。
- en: 'Setting the `Pigeon` struct up with protocols is powerful; you can now write
    a `printHomeAddress()` function and set it up so that it accepts any object that
    conforms to `Domesticatable`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议设置 `Pigeon` 结构体非常强大；你现在可以编写一个 `printHomeAddress()` 函数，并设置它以接受任何符合 `Domesticatable`
    协议的对象：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Domesticatable` protocol requires an optional `homeAddress` property. Not
    every animal that can be domesticated actually is.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Domesticatable` 协议需要一个可选的 `homeAddress` 属性。并不是所有可以驯化的动物实际上都被驯化了。'
- en: For example, think about the pigeon; some pigeons are kept as pets, but most
    aren't. This also applies to cats and dogs, because not every cat or dog has a
    home.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下鸽子；有些鸽子被当作宠物饲养，但大多数不是。这也适用于猫和狗，因为并不是每只猫或狗都有家。
- en: This approach is powerful, but shifting your mind from an object-oriented mindset,
    where you think of an inheritance hierarchy, to a protocol-oriented mindset, where
    you focus on traits instead of inheritance, isn't easy.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很强大，但将你的思维从面向对象的思维模式（其中你考虑继承层次结构）转变为以特性为中心的协议导向思维模式并不容易。
- en: 'Let''s expand the example code a bit more by defining `OmnivoreType`, `HerbivoreType`,
    and `CarnivoreType`. These types will represent the three main types of eaters
    in the animal kingdom. You can make use of inheritance inside of these protocols
    because `OmnivoreType` is both `HerbivoreType` and `CarnivoreType`, so you can
    make `OmnivoreType` inherit from both of these protocols:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义 `OmnivoreType`、`HerbivoreType` 和 `CarnivoreType` 来扩展示例代码。这些类型将代表动物王国中的三种主要食性类型。你可以在这些协议内部使用继承，因为
    `OmnivoreType` 既是 `HerbivoreType` 也是 `CarnivoreType`，所以你可以让 `OmnivoreType` 继承自这两个协议：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Composing two protocols into one like you did in the preceding example is powerful,
    but be careful when you do this.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个协议组合成一个，就像你在前面的例子中所做的那样，是非常强大的，但当你这样做时要小心。
- en: You don't want to create a crazy inheritance graph like you would when you do
    OOP; you just learned that inheritance could be wildly complex and inflexible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望创建一个像在面向对象编程中那样疯狂的继承图；你刚刚了解到继承可能非常复杂且不灵活。
- en: 'Imagine writing two new functions, one to print a carnivore''s favorite meat
    and one to print a herbivore''s favorite plant. Those functions would look like
    this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下编写两个新函数，一个用于打印食肉动物的 favorite meat，另一个用于打印草食动物的 favorite plant。这些函数看起来会是这样：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code might be exactly what you would write yourself. However,
    neither of these methods accepts `OmnivoreType`. This is perfectly fine because
    `OmnivoreType` inherits from `HerbivoreType` and `CarnivoreType`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码可能正是你自己会写的代码。然而，这两种方法都不接受 `OmnivoreType`。这是完全可以接受的，因为 `OmnivoreType` 继承自
    `HerbivoreType` 和 `CarnivoreType`。
- en: This works in the same way that you're used to in classical OOP, with the main
    exception being that `OmnivoreType` inherits from multiple protocols instead of
    just one.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这与你在经典面向对象编程中习惯的方式相同，主要区别在于 `OmnivoreType` 继承自多个协议而不是一个。
- en: This means that the `printFavoritePlant()` function accepts a `Pigeon` instance
    as its argument because `Pigeon` conforms to `OmnivoreType`, which inherits from
    `HerbivoreType`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `printFavoritePlant()` 函数接受一个 `Pigeon` 实例作为其参数，因为 `Pigeon` 符合 `OmnivoreType`，而
    `OmnivoreType` 继承自 `HerbivoreType`。
- en: Using protocols to compose your objects like this can drastically simplify your
    code. Instead of thinking about complex inheritance structures, you can compose
    your objects with protocols that define certain traits. The beauty of this is
    that it makes defining new objects relatively easy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协议以这种方式组合你的对象可以极大地简化你的代码。你不需要考虑复杂的继承结构，而是可以用定义了特定特性的协议来组合你的对象。这种方法的优点是它使得定义新对象相对容易。
- en: Imagine that a new type of animal is discovered, one that can fly, swim, and
    lives on land. This weird new species would be really hard to add to an inheritance-based
    architecture since it doesn't fit in with other animals.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下发现了一种新的动物，它既能飞、能游泳，又生活在陆地上。这种奇怪的新物种很难添加到基于继承的架构中，因为它与其他动物不兼容。
- en: When using protocols, you could add conformance to the `FlyingType`, `LandType`,
    and `SwimmingType` protocols and you'd be all set. Any methods or functions that
    take a `LandType` animal as an argument will happily accept your new animal since
    it conforms to the `LandType` protocol.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用协议时，你可以将 `FlyingType`、`LandType` 和 `SwimmingType` 协议添加到你的协议中，这样你就准备好了。任何接受
    `LandType` 动物作为参数的方法或函数都会愉快地接受你的新动物，因为它符合 `LandType` 协议。
- en: Getting the hang of this way of thinking isn't simple, and it will require some
    practice. But any time you're getting ready to create a superclass or subclass,
    ask yourself why. If you're trying to encapsulate a certain trait in that class,
    try using a protocol.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这种思维方式并不简单，它需要一些练习。但每次你准备创建一个超类或子类时，问问自己为什么。如果你试图在那个类中封装某种特性，尝试使用协议。
- en: This will train you to think differently about your objects, and before you
    know it, your code will be cleaner, more readable, and more flexible, using protocols
    and checking for traits instead of taking action based on what an object is.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将训练你以不同的方式思考你的对象，在你意识到这一点之前，你的代码将会更干净、更易读、更灵活，使用协议和检查特性而不是基于对象是什么来采取行动。
- en: As you've seen, a protocol doesn't need to have a lot of requirements; sometimes
    one or two are enough to convey the right meaning. Don't hesitate to create protocols
    with just a single property or method; as your projects grow over time and your
    requirements change, you will thank yourself for doing so.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，协议不需要有很多要求；有时一个或两个就足以传达正确的含义。不要犹豫，只创建具有单个属性或方法的协议；随着时间的推移，你的项目增长和需求变化，你会为自己这样做而感到庆幸。
- en: Extending your protocols with default behavior
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过默认行为扩展你的协议
- en: The previous examples have mainly used variables as the requirements for protocols.
    One slight downside of protocols is that they can result in a bit of code duplication.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子主要使用了变量作为协议的要求。协议的一个小缺点是它们可能导致一些代码重复。
- en: For example, every object that is `HerbivoreType` has a `favoriteMeat` variable.
    This means that you have to duplicate this variable in every object that conforms
    to `HerbivoreType`. Usually, you want as little code repetition as possible, and
    repeating a variable over and over again might seem like a step backward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每个 `HerbivoreType` 对象都有一个 `favoriteMeat` 变量。这意味着你必须在每个符合 `HerbivoreType`
    的对象中重复这个变量。通常，你希望代码重复尽可能少，反复重复变量可能看起来像是一种倒退。
- en: Even though it's nice if you don't have to declare the same property over and
    over again, there's a certain danger in not doing this. If your app grows to a
    large size, you won't remember every class, subclass, and superclass all of the
    time. This means that changing or removing a specific property can have undesired
    side-effects in other classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不需要反复声明相同的属性也很不错，但这样做也存在一定的风险。如果你的应用程序变得很大，你不可能总是记得每个类、子类和超类。这意味着更改或删除特定属性可能会在其他类中产生不希望的结果。
- en: Declaring the same properties on every object that conforms to a certain protocol
    isn't that big a deal; it usually takes just a few lines of code to do this. However,
    protocols can also require certain methods to be present on objects that conform
    to them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在符合特定协议的每个对象上声明相同的属性并不是什么大问题；通常只需要几行代码就能做到这一点。然而，协议也可以要求符合它们的对象必须存在某些方法。
- en: Declaring them over and over again can be cumbersome, especially if the implementation
    is the same for most objects. Luckily, you can make use of protocol extensions
    to implement a certain degree of default functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 反复声明它们可能会很麻烦，尤其是如果大多数对象的实现都是相同的话。幸运的是，你可以利用协议扩展来实现一定程度的默认功能。
- en: 'To explore protocol extensions, let''s move the `printHomeAddress()` function
    into the `Domesticatable` protocol so all `Domesticatable` objects can print their
    own home addresses. The first approach you can take is to immediately define the
    method on a protocol extension without adding it to the protocol''s requirements:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索协议扩展，让我们将 `printHomeAddress()` 函数移动到 `Domesticatable` 协议中，这样所有 `Domesticatable`
    对象都可以打印它们自己的家庭地址。你可以采取的第一种方法是立即在协议扩展中定义方法，而不将其添加到协议的要求中：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By defining the `printHomeAddress()` method in the protocol extension, every
    object that conforms to `Domesticatable` has the following method available without
    having to implement it with the object itself:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在协议扩展中定义 `printHomeAddress()` 方法，每个符合 `Domesticatable` 的对象都可以使用以下方法，而无需在对象本身中实现它：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This technique is very convenient if you want to implement default behavior
    that's associated with a protocol.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要实现与协议关联的默认行为，这种技术非常方便。
- en: 'You didn''t even have to add the `printHomeAddress()` method as a requirement
    to the protocol. However, this approach will give you some strange results if
    you''re not careful. The following snippet shows an example of such odd results
    by adding a custom implementation of `printHomeAddress()` to the `Pigeon` struct:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至不需要将 `printHomeAddress()` 方法作为要求添加到协议中。然而，如果你不小心，这种方法可能会给你一些奇怪的结果。以下代码片段通过向
    `Pigeon` 结构体添加 `printHomeAddress()` 的自定义实现，展示了这种奇怪结果的一个例子：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you call `myPigeon.printHomeAddress()`, the custom implementation is used
    to print the address. However, if you define a function, such as `printAddress(animal:)`,
    that takes a `Domesticatable` object as its parameter, the default implementation
    provided by the protocol is used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `myPigeon.printHomeAddress()` 时，将使用自定义实现来打印地址。然而，如果你定义了一个函数，例如 `printAddress(animal:)`，它接受一个
    `Domesticatable` 对象作为参数，将使用协议提供的默认实现。
- en: 'This happens because `printHomeAddress()` isn''t a requirement of the protocol.
    Therefore, if you call `printHomeAddress()` on a `Domesticatable` object, the
    implementation from the protocol extension is used. If you use the same snippet
    as in the preceding section, but change the `Domesticatable` protocol as shown
    in the following code, both calls to `printHomeAddress()` print the same thing,
    that is, the custom implementation in the `Pigeon` struct:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `printHomeAddress()` 不是协议的要求。因此，如果你在一个 `Domesticatable` 对象上调用 `printHomeAddress()`，将使用协议扩展中的实现。如果你使用与上一节相同的代码片段，但将
    `Domesticatable` 协议更改为以下代码所示，两次调用 `printHomeAddress()` 将打印相同的内容，即 `Pigeon` 结构体中的自定义实现：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This behavior is likely to be unexpected in most cases, so it's usually a good
    idea to define all methods you use in the protocol requirements unless you're
    absolutely sure you want the behavior you just saw.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这种行为可能是不预期的，所以通常一个好的做法是在协议要求中定义你使用的所有方法，除非你绝对确定你想要看到的行为。
- en: 'Protocol extensions can''t hold stored properties. This means that you can''t
    add your variables to the protocol to provide a default implementation for them.
    Even though extensions can''t hold stored properties, there are situations where
    you can still add a computed property to a protocol extension to avoid duplicating
    the same variable in multiple places. Let''s take a look at an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 协议扩展不能持有存储属性。这意味着你不能将变量添加到协议中，为它们提供默认实现。尽管扩展不能持有存储属性，但在某些情况下，你仍然可以向协议扩展添加一个计算属性，以避免在多个地方重复相同的变量。让我们来看一个例子：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you want to be able to check whether a `Domesticatable` has a home address,
    you can add a requirement for a Bool value, `hasHomeAddress`. If the `homeAddress`
    property is set, `hasHomeAddress` should be true. Otherwise, it should be false.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查一个 `Domesticatable` 是否有家庭地址，你可以添加一个布尔值的要求，`hasHomeAddress`。如果设置了 `homeAddress`
    属性，`hasHomeAddress` 应该为真。否则，它应该是假的。
- en: This property is computed in the protocol extension, so you don't have to add
    this property to all `Domesticatable` objects. In this case, it makes a lot of
    sense to use a computed property because the way its value is computed should
    most likely be the same across all `Domesticatable` objects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性是在协议扩展中计算的，所以你不需要将这个属性添加到所有 `Domesticatable` 对象中。在这种情况下，使用计算属性非常有意义，因为其值的计算方式很可能在所有
    `Domesticatable` 对象中都是相同的。
- en: Implementing default behaviors in protocol extensions makes the protocol-oriented
    approach we've seen before even more powerful; you can essentially mimic a feature
    called multiple inheritance without all the downsides of subclassing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议扩展中实现默认行为使得我们之前看到的协议导向方法更加强大；你实际上可以模仿一个称为多重继承的功能，而不需要所有子类化的缺点。
- en: Simply adding conformance to a protocol can add all kinds of functionality to
    your objects, and if the protocol extensions allow it, you won't need to add anything
    else to your code. Let's see how you can make protocols and extensions even more
    powerful with associated types.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地添加对协议的遵从可以为你的对象添加各种功能，如果协议扩展允许，你就不需要向你的代码中添加任何其他内容。让我们看看如何通过关联类型使协议和扩展更加强大。
- en: Improving your protocols with associated types
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关联类型改进你的协议
- en: One more awesome aspect of protocol-oriented programming is the use of associated
    types. An associated type is a generic, non-existing type that can be used in
    your protocol like any type that does exist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 协议导向编程的一个令人惊叹的方面是关联类型的用法。关联类型是一种泛型、不存在的类型，它可以像任何实际存在的类型一样在你的协议中使用。
- en: The real type of this generic is determined by the compiler based on the context
    it's used in. This description is abstract, and you might not immediately understand
    why or how an associated type can benefit your protocols. After all, aren't protocols
    themselves a very flexible way to make several unrelated objects fit certain criteria
    based on the protocols they conform to?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个泛型的实际类型是由编译器根据其使用的上下文确定的。这个描述是抽象的，你可能不会立即理解为什么或如何关联类型可以给你的协议带来好处。毕竟，协议本身不就是一种非常灵活的方式，可以让几个不相关的对象根据它们遵守的协议满足某些标准吗？
- en: 'To illustrate and discover the use of associated types, you will expand your
    animal kingdom a bit. What you should do is give the herbivores an `eat` method
    and an array to keep track of the plants they''ve eaten, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明和发现关联类型的使用，你将稍微扩展你的动物王国。你应该做的是给草食动物一个`eat`方法和一个数组来跟踪它们吃过的植物，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code looks fine at first sight. An herbivore eats plants, and this is
    established by this protocol. The `PlantType` protocol is defined as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码乍一看看起来不错。草食动物吃植物，这是通过这个协议确立的。`PlantType`协议定义如下：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s define two different plant types and an animal that will be used to
    demonstrate the problem with the preceding code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义两种不同的植物类型和一个将用于演示前面代码中问题的动物：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There shouldn''t be a big surprise here. Let''s continue with creating a `Cow`
    instance and feed it `Pine`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不应该有什么大的惊喜。让我们继续创建一个`Cow`实例并给它喂食`Pine`：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This doesn't really make sense. Cows don't eat pines; they eat grass! We need
    some way to limit this cow's food intake because this approach isn't going to
    work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并没有什么意义。牛不吃松树；它们吃草！我们需要某种方式来限制这只牛的食物摄入量，因为这种方法是不可行的。
- en: Currently, you can feed `HerbivoreType` animals anything that's considered a
    plant. You need some way to limit the types of food your cows are given. In this
    case, you should restrict `FoodType` to `Grass` only, without having to define
    the `eat(plant:)` method for every plant type you might want to feed a `HerbivoreType`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你可以给`HerbivoreType`动物喂食任何被认为是植物的东西。你需要某种方式来限制你给牛喂食的食物类型。在这种情况下，你应该将`FoodType`限制为只有`Grass`，而不必为可能想要喂食的每个`HerbivoreType`植物类型定义`eat(plant:)`方法。
- en: 'The problem you''re facing now is that all `HerbivoreType` animals mainly eat
    one plant type, and not all plant types are a good fit for all herbivores. This
    is where associated types are a great solution. An associated type for the `HerbivoreType`
    protocol can constrain the `PlantType` that a certain herbivore can eat to a single
    type that is defined by `HerbivoreType`. Let''s see what this looks like:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在面临的问题是所有`HerbivoreType`动物主要吃一种植物类型，并不是所有植物类型都适合所有草食动物。这正是关联类型成为绝佳解决方案的地方。`HerbivoreType`协议的关联类型可以限制某个草食动物可以吃的`PlantType`为`HerbivoreType`定义的单个类型。让我们看看这会是什么样子：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first highlighted line associates the generic `Plant` type, which doesn't
    exist as a real type, with the protocol. A constraint has been added to `Plant`
    to ensure that it's a `PlantType`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行高亮显示的行将泛型`Plant`类型（作为一个不存在的真实类型）与协议关联起来。为`Plant`添加了一个约束，以确保它是一个`PlantType`。
- en: 'The second highlighted line demonstrates how the `Plant` associated type is
    used as a `PlantType`. The plant type itself is merely an alias for any type that
    conforms to `PlantType` and is used as the type of object we use for `plantsEaten`
    and the `eat` methods. Let''s redefine the `Cow` struct to see this associated
    type in action:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个高亮行展示了如何将`Plant`关联类型用作`PlantType`。植物类型本身仅是符合`PlantType`的任何类型的别名，并用作我们用于`plantsEaten`和`eat`方法的类型。让我们重新定义`Cow`结构体，以查看这个关联类型的作用：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of making `plantsEaten` a `PlantType` array, it's now defined as an
    array of `Grass`. In the protocol and the definition, the type of plant is now
    `Grass`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将`plantsEaten`定义为`PlantType`数组，现在它被定义为`Grass`数组。在协议和定义中，植物的类型现在是`Grass`。
- en: 'The compiler understands this because the `plantsEaten` array is defined as
    `[Grass]`. Let''s define a second `HerbivoreType` that eats a different type of
    `PlantType`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器理解这一点，因为`plantsEaten`数组被定义为`[Grass]`。让我们定义第二个`HerbivoreType`，它吃不同类型的`PlantType`：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you try to feed a cow some carrots, or if you attempt to feed the rabbit
    a pine, the compiler will throw errors. The reason for this is that the associated
    type constraint allows you to define the type of `Plant` in each struct separately.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试给牛喂一些胡萝卜，或者如果你尝试给兔子喂松树，编译器将抛出错误。原因在于关联类型约束允许你在每个结构体中单独定义`Plant`的类型。
- en: One side note about associated types is that it's not always possible for the
    compiler to correctly infer the real type for an associated type. In our current
    example, this would happen if we didn't have the `plantsEaten` array in the protocol.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 关于关联类型的一个注意事项是，编译器并不总是能够正确推断关联类型的实际类型。在我们的当前示例中，如果没有`plantsEaten`数组在协议中，就会发生这种情况。
- en: 'The solution would be to define a `typealias` on types that conform to `HerbivoreType`
    so that the compiler understands which type `Plant` represents:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是为符合`HerbivoreType`的类型定义一个`typealias`，这样编译器就能理解`Plant`代表哪种类型：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Associated types can be really powerful when used correctly, but sometimes using
    them can also cause you a lot of headaches because of the amount of inferring
    the compiler has to do.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，关联类型可以非常强大，但有时使用它们也可能因为编译器必须做的推断量而给你带来很多麻烦。
- en: If you forget a few tiny steps, the compiler can quickly lose track of what
    you're trying to do, and the error messages aren't always the most unambiguous
    messages.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了一些微小的步骤，编译器可能会迅速失去对你的意图的跟踪，而且错误信息并不总是最明确的。
- en: Keep this in mind when you're using associated types, and try to make sure that
    you're as explicit as possible about the type you're looking to be associated
    with.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关联类型时，请记住这一点，并尽量确保你对你想要关联的类型尽可能明确。
- en: Sometimes, adding a type alias to give the compiler a helping hand is better
    than trying to get the compiler to infer everything on its own correctly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，添加一个类型别名来帮助编译器比试图让编译器自己正确推断一切要好。
- en: This type of flexibility is not limited to protocols. You can also add generic
    properties to functions, classes, structs, and enums. Let's see how this works
    and how it can make your code extremely flexible.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性不仅限于协议。你还可以向函数、类、结构体和枚举添加泛型属性。让我们看看这是如何工作的，以及它如何使你的代码非常灵活。
- en: Adding flexibility with generics
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用泛型增加灵活性
- en: Programming with generics is not always easy, but it does make your code extremely
    flexible. When you use something such as generics, you are always making a trade-off
    between the simplicity of your program and the flexibility of your code. Sometimes
    it's worth it to introduce a little bit of complexity to allow your code to be
    written in otherwise impossible ways.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型编程并不总是容易，但它确实使你的代码非常灵活。当你使用泛型时，你总是在你的程序简单性和代码灵活性之间做出权衡。有时引入一点复杂性以允许以其他方式不可能的方式编写代码是值得的。
- en: For instance, consider the `Cow` struct you saw before. To specify the generic
    associated type on the `HerbivoreType` protocol, a type alias was added to the
    `Cow` struct. Now imagine that not all cows like to eat grass. Maybe some cows
    prefer flowers, corn, or something else. You would not be able to express this
    using the type alias.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑你之前看到的`Cow`结构体。为了在`HerbivoreType`协议中指定泛型关联类型，我们在`Cow`结构体中添加了一个类型别名。现在想象一下，并不是所有的牛都喜欢吃草。也许有些牛更喜欢花朵、玉米或其他东西。你将无法使用类型别名来表达这一点。
- en: 'To represent a case where you might want to use a different `PlantType` for
    every cow instance, you can add a generic to the `Cow` itself. The following snippet
    shows how you can do this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示你可能希望为每个牛实例使用不同的 `PlantType` 的情况，你可以在 `Cow` 本身添加一个泛型。以下代码片段显示了你可以如何做到这一点：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Between `<` and `>`, the generic type name is specified as `Plant`. This generic
    is constrained to the `PlantType` type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<` 和 `>` 之间，泛型类型名称指定为 `Plant`。此泛型被限制为 `PlantType` 类型。
- en: 'This means that any type that will act as `Plant` has to conform to `PlantType`.
    The protocol will see that `Cow` has a generic `Plant` type now, so there is no
    need to add a type alias. When you create an instance of `Cow`, you can now pass
    every instance its own `PlantType`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何将作为 `Plant` 的类型都必须遵守 `PlantType` 协议。协议将看到 `Cow` 现在有一个泛型 `Plant` 类型，因此不需要添加类型别名。当你创建
    `Cow` 的实例时，你现在可以传递每个实例自己的 `PlantType`：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Applying generics to instances like this is more common than you might think.
    An `Array` instance uses generics to determine what kind of elements it contains.
    The following two lines of code are identical in functionality:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将泛型应用于此类实例比你想象的要常见。`Array` 实例使用泛型来确定它包含的元素类型。以下两行代码在功能上是相同的：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line uses a convenient syntax to create an array of strings. The second
    line uses the `Array` initializer and explicitly specifies the type of element
    it will contain.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用方便的语法创建了一个字符串数组。第二行使用 `Array` 初始化器，并明确指定了它将包含的元素类型。
- en: 'Sometimes, you might find yourself writing a function or method that can benefit
    from a generic argument or return type. An excellent example of a generic function
    is `map`. With `map`, you can transform an array of items into an array of different
    items. You can define your own simple version of `map` as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会发现自己正在编写一个可以从泛型参数或返回类型中受益的函数或方法。一个泛型函数的绝佳例子是 `map`。使用 `map`，你可以将项目数组转换成不同项目的数组。你可以定义自己的简单版本的
    `map` 如下所示：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `simpleMap(_:transform:)` has two generic types, `T` and `U`. These names
    are common placeholders for generics, so they make it clear to anybody reading
    this code that they are about to deal with generics.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`simpleMap(_:transform:)` 有两个泛型类型，`T` 和 `U`。这些名称是泛型的常见占位符，因此它们使任何阅读此代码的人都能清楚地知道他们即将处理泛型。
- en: In this sample, the function expects an input of `[T]`, which you can read as
    an array of something. It also expects a closure that takes an argument, `T`,
    and returns `U`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，该函数期望一个输入 `[T]`，你可以将其读作某种东西的数组。它还期望一个闭包，该闭包接受一个参数 `T` 并返回 `U`。
- en: You can interpret this as the closure taking an element out of that array of
    something, and it transforms it into something else.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这理解为闭包从那个某种东西的数组中取出一个元素，并将其转换成另一种东西。
- en: The function finally returns an array of `[U]`, or in other words, an array
    of something else.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数最终返回一个 `[U]` 的数组，换句话说，是另一种东西的数组。
- en: 'You would use `simpleMap(_:transform:)` as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `simpleMap(_:transform:)` 如下所示：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generics are not always easy to understand, and it's okay if they take you a
    little while to get used to it. They are a powerful and complex topic that we
    could write many more pages about.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型并不总是容易理解，如果你需要一些时间来适应它们，这是完全可以接受的。它们是一个强大而复杂的话题，我们可以写更多关于它们的内容。
- en: The best way to get into them is to use them, practice with them, and read as
    much as you can about them. For now, you should have more than enough to think
    about and play with.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是使用它们，练习它们，并尽可能多地阅读有关它们的内容。现在，你应该有足够的想法和内容去思考和玩耍。
- en: Note that generics are not limited to structs and functions. You can also add
    generics to your enums and classes in the same way you add them to a struct.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，泛型不仅限于结构体和函数。你还可以以相同的方式将泛型添加到你的枚举和类中。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how you can leverage the power of protocols to work
    with an object's traits or capabilities, rather than just using its class as the
    only way of measuring its capabilities. Then, you saw how protocols can be extended
    to implement a default functionality. This enables you to compose powerful types
    by merely adding protocol conformance, instead of creating a subclass.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了如何利用协议的强大功能来处理对象的特性和能力，而不仅仅是使用其类作为衡量其能力的唯一方式。然后，你看到了如何扩展协议以实现默认功能。这使你能够通过仅添加协议一致性来组合强大的类型，而不是创建子类。
- en: You also saw how protocol extensions behave depending on your protocol requirements,
    and that it's wise to have anything that's in the protocol extension defined as
    a protocol requirement. This makes the protocol behavior more predictable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了协议扩展如何根据你的协议要求表现，以及将协议扩展中的任何内容定义为协议要求是明智的。这使得协议行为更加可预测。
- en: Finally, you learned how associated types work and how they can take your protocols
    to the next level by adding generic types to your protocols that can be tweaked
    for every type that conforms to your protocol. You even saw how you can apply
    generics to other objects, such as functions and structs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了关联类型的工作原理以及它们如何通过向你的协议添加泛型类型来提升你的协议水平，这些泛型类型可以针对符合你协议的每个类型进行调整。你甚至看到了如何将泛型应用于其他对象，例如函数和结构体。
- en: The concepts shown in this chapter are pretty advanced, sophisticated, and powerful.
    To truly master their use, you'll need to train yourself to think regarding traits
    instead of an inheritance hierarchy.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的概念相当高级、复杂且强大。要真正掌握它们的使用，你需要训练自己用特性而不是继承层次来思考。
- en: Once you've mastered this, you can experiment with protocol extensions and generic
    types. It's okay if you don't fully understand these topics right off the bat;
    they're completely different and new ways of thinking for most programmers with
    OOP experience.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了这些，你就可以尝试协议扩展和泛型类型。如果你一开始并不完全理解这些主题，这是完全可以接受的；对于大多数有面向对象编程经验的程序员来说，这些都是全新的思维方式。
- en: Now that we've explored some of the theory behind protocols and value types,
    in the next chapter, you will learn how you can put this new knowledge to use
    by shortly revisiting the Contacts app from our previous chapters to improve the
    code you wrote there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了一些关于协议和值类型的理论，在下一章中，你将学习如何通过简要回顾我们之前章节中的联系人应用来应用这些新知识，以改进你那里写的代码。
