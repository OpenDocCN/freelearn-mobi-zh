- en: Designing Form Screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Form screens are an essential part of user interface design in many ways because
    their history is a lesson in how not to do things. Most applications need to capture
    input from their users at some point, and you need input widgets for that, but
    you should always consider the minimum amount of information you need to ask the
    user for, rather than try to get all the information you may need in the future.
    This approach will keep the user focused on the task they are trying to carry
    out. Presenting them with a wall of input fields is overwhelming to most users
    and breaks their focus, which in turn can lead to them abandoning what they were
    trying to do with your application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is focused on form screens, and will walk you through a bit of
    their history before diving into a method for actually designing form screens.
    This approach can and should be reused whenever you need to design a screen for
    an app. It's always important to take a step back from your code work and consider
    how things will look and fit together for the user; it's often the difference
    between a successful app and failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll develop a practical form screen using Android Studio
    and the layout editor. Starting from an empty template in a new project, you''ll
    learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to break up and then arrange a form layout to be most effective for your
    users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use resources to keep your user interface consistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to style widgets to help the user understand what the widget should be used
    for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build drawable resources that respond to state changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring form screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While not the most glamorous component of an application's user experience,
    form screens are a long-time staple of software. A form screen can be defined
    as any screen where the user is expected to explicitly enter or change data, as
    opposed to viewing or navigating it. Good examples of form screens are login screens,
    edit profile screens, or the add contact screen from a phonebook app. Over the
    years, the idea of what constitutes a good form screen has changed, with some
    people going as far as to shun them completely. However, you can't capture the
    user's data out of thin air.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android standard toolkit provides an excellent and diverse collection of
    widgets and layout structures to facilitate building excellent forms, and in Material
    Design applications, form screens can often double as a *view* screen (what will
    usually be a read-only version of the form screen) thanks to the placement of
    labels. A good way to understand this principle is to consider the evolution of
    textboxes. As soon as you have a blank space to be filled by your user, you need
    to tell the user what to put there, and when we started labeling textboxes, we
    simply copied how we did this on paper forms--by putting a label to the one side
    of the textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb41dffa-4a42-4750-9e74-d38408ce5176.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The issue with this is that the label always takes up quite a bit of space,
    and takes up even more if you need to include some validation rules for the user
    (such as date inputs--DD/MM/YYYY). This is where we started adding hints to the
    input boxes. The label will explain what to add in the Date of Birth textbox,
    and a hint within the textbox will tell the user how to input valid data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ecff562-332e-4c1f-96a7-d9d3f4ff9797.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From this pattern, many mobile applications began to drop the label completely
    and instead used the hint/placeholder to contain the data on the theory that from
    the context of the form, the user will be able to infer what data was in each
    of the textboxes. However, this means that the user has to do a bit of extra thinking
    in order to make sense of the screen when they see it for the first time. This
    extra delay can quickly turn to frustration, and reduces how usable your application
    is. For this reason, Material Design text inputs turn their hints into small labels
    that move above the textbox when the user focuses on the textbox, making it easier
    for them to keep track of what information they are entering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95a44133-8920-4198-9ac4-87937a650d97.png)'
  prefs: []
  type: TYPE_IMG
- en: This also reduces the amount of work that needs to be done on form screens as
    a developer, because you typically won't need to separate the *view* and *edit*
    screens of your application, since the form will always have all of its labeling
    available. However, it's important to avoid overcrowding your screens with input
    widgets. Nobody likes to have to fill in lots of data, even if most of it is optional.
    Instead, always consider the minimum amount of data you need from your user at
    each point in your application. It's also important to consider how you will ask
    the user for their data.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start our first form screen as an information capturing screen. We'll
    be building an imaginary app to track someone's travel expenses, allowing them
    to capture, tag, and store each of their expenses to be filtered and reviewed
    later. The first thing we need is a screen where the user can capture an expense
    and any additional information that goes with it.
  prefs: []
  type: TYPE_NORMAL
- en: As best as possible, you should make input fields optional, but you can always
    encourage people to give more data by telling them how complete something is.
    This is a common technique when dealing with a user profile--"Your profile is
    50% complete", helps encourage the user to provide more data to raise that number.
    This is a simple form of gamification, but it's also very effective.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Good user interface design is rooted in some simple rules, and there are processes
    you can follow to design a great user interface. For example, imagine that you're
    building an app to capture travel expenses so that they can be claimed easily
    at a later time. The foremost thing we'll build over here is the screen that captures
    the details of a single claim. This is a perfect example of a modern form screen
    design.
  prefs: []
  type: TYPE_NORMAL
- en: When designing a layout, it's a good idea to use a mockup tool such as Balsamiq
    ([https://balsamiq.com/](https://balsamiq.com/)), or even paper and pencil to
    think about the layout of the screen. Physical index cards make excellent thinking
    spaces as they have similar proportions to a phone or tablet. Using paper, especially,
    helps you think about the arrangement of the screen instead of being distracted
    by the exact colors, fonts, and spacing that should be dealt with in a common
    set of theming rules.
  prefs: []
  type: TYPE_NORMAL
- en: To start designing the screen, we need to consider what data we'll need from
    the user and how we might be able to fill some of it out for them. We also need
    to try and stick to the platform design language so that the application doesn't
    feel out of place to the user. It's also important when designing form screens
    to ensure that the entire input form will fit onto the device's display. Scrolling
    an input screen requires your user to remember what is not on the screen, and
    causes frustration and anxiety. Whenever you design a form screen, ensure that
    all the inputs will fit onto one display. If they don't all immediately fit onto
    the display together, first consider whether you can remove some of them. After
    removing any that aren't absolutely required, consider grouping some on a single
    line, ensuring that you put no more than two inputs per line. More than two input
    fields on a single line implies that you can probably turn them into a single
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get started, consider what information a user will want to capture for
    a travel expense:'
  prefs: []
  type: TYPE_NORMAL
- en: How much the expense was
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some photos of the invoice, or maybe of the item purchased
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The date that they captured the expense on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What sort of expense they're capturing such as food, transport, accommodation,
    and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short description to help them remember what the expense was
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great, that seems like a good starting point, but they''re not in a great order
    and they''re not grouped at all. We need to consider what is most important, and
    what groups logically fit together well on-screen. For starters, let''s focus
    on developing a portrait layout for a phone, since that will be our most common
    use case. So, the next thing to do is group the input components in a way that
    will feel logical and familiar to a user. When looking at an overview of claims,
    the things we''ll want to list are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The date of the expense:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The date that they captured the expense on
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The amount the claim is for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much the expense was
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some photos of the invoice, or maybe of the item purchased
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The description of the claim:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What sort of expense they're capturing such as food, transport, accommodation,
    and more
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A short description to help them remember what the expense was
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we''ll group these three fields together, and put them at the top of the
    screen. This particular grouping will feel common to anyone who has used any budget
    or expense tracking software:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4ed0cd5-76ce-46f6-b639-2972e08b2ccb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Date is a special field, because we can easily populate it with the current
    date. It''s most likely when the user enters this screen that they are capturing
    an expense for the same day. We still need to capture a category and attachments
    for the expense. Attachments will need a large amount of space so that the user
    can preview them without having to open each one to know what it is, so we''ll
    put them at the bottom of the screen and have them take any space left over. That
    just leaves the category. The expense categories are best represented using icons,
    but we need some space for text so that the user knows what each icon means. We
    can do this in one of several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Place a tiny label above or below each icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pros: All the labels are always on the screen'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: The labels can be hard to read on smaller screens, and the icons take
    up more screen space:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8d94c91b-2f0d-4ec2-b066-3dfeba6297e1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a vertical list of icons and put a nice large label to the right of
    each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pros: The labels are easy to read, and always associated with their icons'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: This will take up lots of the vertical space that is best used to display
    attachment previews:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e517b489-32be-4772-99ef-1ef8a78a5ebd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Show only the icons, and display the label when the user holds their finger
    over the icon (long presses):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pros: The text takes up no screen space'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: This sort of behavior is not intuitive to users, and requires that the
    user selects the category to know what its label is:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cf46ea5b-a70f-468b-843b-17b09980ffc6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Show the list of icons and the text of the selected category below them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pros: The text label can be large and easy to read, and takes up less screen
    space because only one label is shown at a time'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons: The user must select the category to know what its label is:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2c7ec26d-e032-4100-aeac-1081746871b6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to keep the label in a nice, easily readable size, while also drawing
    extra attention to which category is currently selected, this example will show
    you how to create option four, where the currently selected category name is shown
    below a horizontal list of the category icons. We'll also highlight the selected
    icon to help keep a connection between the two user interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The one remaining thing that the user needs to be able to do is attach files
    to the expense claim before saving it. There should be a nice, large area at the
    bottom of this layout that will make a perfect area to preview a single attachment,
    and if the user has more than one attachment, they can swipe left and right to
    switch between their previews. However, how can they attach them in the first
    place? This is where a floating action button is an ideal solution. You''ll see
    floating action buttons everywhere in Android applications. They are usually near
    the bottom-right of the screen, where a right-handed person will have their thumb
    if they hold the phone one-handed, and out of the way of most Western content,
    which will be to the left of the screen (normally):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3639b7e8-e1db-47ae-b77e-d3f8d6d9a22f.png)'
  prefs: []
  type: TYPE_IMG
- en: Floating action buttons are normally the most common *creative* (as opposed
    to navigation or destructive) actions on the screen; for example, creating a new
    email in the Gmail or Inbox app, attaching a file, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now, we have the screen broken down into three logical areas, outside of
    the normal decorations:'
  prefs: []
  type: TYPE_NORMAL
- en: Claim details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attachment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Putting them together into a single screen layout concept gives you a wireframe,
    looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ded7bee-080c-4948-8697-efde533a8904.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This exercise of wireframing your screens before you start developing them is
    an extremely valuable phase, because it gives you time and space to think about
    each of the choices you could be making, rather than just grabbing the first available
    widgets in the toolbox and putting them onto the screen. Now that you have a wireframe,
    you're ready to get started with building the user interface for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a form layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have a good wireframe to work from, you'll want to start developing
    the user interface screen. For this, we'll use Android Studio and its wonderful
    layout editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a brand new project, you''ll need to open Android Studio and
    use File | New | New Project to get it started. Then, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the project `Claim`, and leave any non-Java support turned off.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Target Android 4.1 on Phone & Tablet only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Activity Gallery, choose the Basic Activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0e29400-99c6-4672-af9b-07e1fa947b2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name the new Activity `CaptureClaimActivity`, and then change the title to
    `Capture Claim`. Leave the other parameters at their default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41766382-ac9d-4d3f-b977-6246b36c08eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Finish the New Project wizard, and wait for the project to be generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the project has been generated and synchronized, Android Studio will open
    the `content_capture_claim.xml` file in its layout editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, Android Studio assumes that you will be using a `ConstraintLayout`
    as the root of your layout. This is an incredibly powerful and flexible tool,
    but also not well suited as the root element of this user interface. You''ll need
    to switch over to the Text view at the bottom of the screen in order to change
    to something more suitable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2abfbd02-580d-491d-8a80-72cd70a30a66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The file will currently have something like the following XML in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `ConstraintLayout` to a simple `LinearLayout`. `LinearLayout` is
    one of the simplest layouts available on Android. It renders each of its children
    in a straight line, either horizontal or vertical, depending on its orientation
    attribute. Replace the whole of the `content_capture_claim.xml` file with the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Choosing the right layout to use is about more than just keeping your code simple;
    less flexible layouts are much faster at runtime and lead to a much smoother user
    experience. Try to stick to simpler layouts where possible, but also avoid nesting
    layouts too deep (one inside the other), as this also leads to performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: Change back to the Design view in the layout editor, and you'll notice that
    the Component Tree to the left of the design view now has a LinearLayout (vertical)
    as its only component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the description box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the base layout is set up, it''s time to start adding the widgets
    to the user interface and make it useful. In this next stage, you''ll be using
    several Material Design widgets that help produce great user interfaces, such
    as **CardView** and the **TextInputLayout** widget. Before Material Design, text
    input boxes were just plain `EditText` widgets, which while still available, are
    now generally discouraged in favor of a `TextInputLayout`. The `TextInputLayout`
    is a specialized layout that contains a single `EditText` widget for the user
    to enter text data. The `TextInputLayout` then also provides the floating hint/label
    effect and animations, transitioning the `EditText` widgets hint to a label space
    just above the input area. This means that even when the user has filled in the
    text, the hint for the `EditText` is still visible above their input:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fcc694c-5e37-49f1-a91f-3f3da355b179.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You''ll be wrapping this first group of widgets in a `CardView`, which will
    serve as a visual grouping for the user. Follow these steps to add the description
    input box:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the AppCompat section of the Widget Palette. This contains widgets that
    come from special APIs that are parts of the extended Android platform. They're
    not included on the platform by default, and instead, are included in each application
    they are used in, a bit like static linking a library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag and drop a `CardView` into your user interface design; you can drop it
    anywhere on the design canvas. This will serve as the grouping for the description,
    amount, and date input boxes. Ensure that in the Component Tree, the `CardView`
    appears as a child of the LinearLayout (vertical):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/52c6a273-04a3-481d-88f9-caa6497d07d8.png)'
  prefs: []
  type: TYPE_IMG
- en: A `CardView` stacks its widgets on top of each other in layers (back to front).
    This is not what's needed in this case, so you'll need to open the Layouts section
    of the `Palette` and drag a `ConstraintLayout` into the `CardView` on your design.
    Ensure that in the Component Tree, the `ConstraintLayout` appears as a child of
    the `CardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the new `ConstraintLayout` in the Component Tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Attributes panel, select the View all attributes button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bfface80-8164-44d4-b76c-01a96da322a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the section titled Layout_Margin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the resource editor button for the all line, as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cdca666b-c4b2-4e10-8272-08d482a05a38.png)'
  prefs: []
  type: TYPE_IMG
- en: In the resource editor, select the Add new resource button in the top-left,
    and choose New dimen value (dimen is short for dimension. A dimension resource
    can be used to specify sizes in non-pixel units, which are then converted according
    to the actual display system on the user's device).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the resource `grid_spacer1`, and give it a value of `8dp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/48dd69c2-c5fa-4abf-89b5-0f4c24b99967.png)'
  prefs: []
  type: TYPE_IMG
- en: Material Design interfaces on Android use a spacing grid in an increment of
    **8dp**, which is *8 density-independent pixels*. This is a special unit of measurement
    that varies the actual number of pixels used based on the density of the screen.
    These are also the most common unit of on-screen measurement in Android. A **1dp**
    measurement will be 1 physical pixel on a 160dpi screen, and scaled to 2 pixels
    on a 320dpi screen. This means that by measuring your layout in terms of density-independent
    pixels rather than physical pixels, your user interface will translate better
    over the range of screen densities it might encounter on various devices.
  prefs: []
  type: TYPE_NORMAL
- en: Click OK to create the dimension resource and go back to the layout editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, you''ll need to start building up the input boxes for the user to fill
    in. The first of these will be the description box. Open the Design section of
    the Palette, and drag a `TextInputLayout` into the Component Tree as a child of
    the ConstraintLayout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b697692b-30c6-43d2-bf30-173147dcb97e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Attributes panel, click on the View fewer attributes button (it's the
    same one as View all attributes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the Attributes panel, set the ID of the `TextInputLayout` to `description_layout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the Constraint editor (just below the ID attribute) to create connections
    to the left, and above the `TextInputLayout` by clicking on the blue circles with
    the + signs in them. Then, change the constrained margins to zero on both the
    new constraints, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b42003e1-9ca1-4c2d-9e13-e891710b0c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Your `TextInputLayout`, now named `description_layout`, should have snapped
    to the top-left corner of the layout editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5f7fcde9-2cba-4c1c-bca4-d08e938a1c01.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the `layout_width` attribute to `match_constraint`, and the `layout_height`
    parameter to `wrap_content`. The `TextInputLayout` will shrink to the minimum
    space it can occupy in the top-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, using the Component Tree, select the `TextInputEditText` inside the `description_layout`
    `TextInputLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the ID to `description`, since this is the field
    you actually want to capture the contents of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the inputType to textCapWords; this will instruct software keyboards
    to place a capital letter at the beginning of each word:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/06e8a6a1-ef8b-4b40-a6a1-ebbe4288c98e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The hint/label for the description box is currently hint, and it''s hardcoded
    into the layout. We want to change it to `Description`, and make it localizable
    (so that it''s easy to translate the app into new languages). Use the edit button
    to open the string resource editor, and choose Add new resource | New string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/765fcd4e-1d1b-472d-8544-6a6d60f16391.png)'
  prefs: []
  type: TYPE_IMG
- en: Fill in the Resource name as `label_description`. You'll notice that this follows
    another prefix rule, which helps when dealing with large numbers of string resources
    in your source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fill in the Resource value as `Description`, and leave the remaining fields
    unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5edd0859-c462-446b-a250-4bbc10ec4700.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on OK to create the new string resource and go back to the layout editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, you created a grouping component (the `CardView`) that will
    serve to visually group the description amount and date fields for the user, and
    you have populated it with its first component--the description box. You have
    also created a dimension resource that can be reused throughout your application
    to represent a single grid spacing unit, allowing you to adjust the size of the
    grid for the entire application. A consistent grid spacing in the application
    helps define a consistent look and feel for the application, and keeping this
    value as a resource provides you with a single place where you can change it if
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the amount and date inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this next section, we''ll finish building the description box by adding
    the `amount` and `date` fields. This will involve using some more complex constraints
    on the widgets you will be adding, as they will need to be positioned relative
    to each other. Follow these steps to finish the description box:'
  prefs: []
  type: TYPE_NORMAL
- en: Drag another `TextInputLayout` into your design and place it somewhere below
    the Description field. This new box has no constraints as of yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the ID to `amount_layout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, open the resource editor for `layout_width` as you
    did to create the `grid_spacer1` resource earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new resource named `input_size_amount`, and set its value as `100sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Much like dp, **sp** (**scale-independent pixels**) is a relative pixel size,
    but unlike density-independent pixels, scale-independent pixels are scaled according
    to the user's font preferences. Normally, these are used to specify font sizes,
    but they can also be useful when specifying fixed sizes for text input widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag the right constraint handle to the right of the layout, and then
    drag the top constraint handle to the top of the layout, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b522956-ecb0-4123-8174-77323826b485.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, zero the margins using the constraint editor in the Attributes panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a1d2c65f-8773-4ac8-a755-603688b52eaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, use the Component Tree to select the `description_layout` `TextInputLayout`
    widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When selecting widgets directly in the design view, the editor will pick the
    deepest child of the Component Tree that you clicked on. This means that if you
    click on the Description field directly, you will select the `TextInputEditText`
    box, instead of the `TextInputLayout`. So, when dealing with the `ConstraintLayout`
    in particular, it's often better to select widgets in the Component Tree to ensure
    that you pick the right one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the layout view, drag the right constraint handle of the description `TextInputLayout`
    to meet up with the left constraint handle of the new `amount_layout` and `TextInputLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fc7e0496-e9d3-41b1-98a3-73816950e775.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the new `TextInputEditText` widget in the Component Tree panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the ID to `amount`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the attribute editor to change the inputType to number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the hint attribute, open the resource editor to create a new string resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the resource as `label_amount`, and give it a value `Amount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/91d98fbc-f87e-4a66-b4d8-cd2f6645cb12.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we'll add a label for the `Date` input field; in the Palette panel, open
    the Text section and drag a new `TextView` into the layout editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the constraint editor in the Attributes panel, add a constraint to the
    left and right, and then zero their margins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `layout_width` to `match_constraint` so that the label takes up
    all the available width:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/29d933d6-422e-4d63-837b-c8b00d2958b2.png)'
  prefs: []
  type: TYPE_IMG
- en: The `match_contstraint` value available to the children of a `ConstraintLayout`
    is a special marker attribute that will cause the widget to fill the space made
    available by its constraints. This is similar to how the `match_parent` value
    will cause a widget to take up all the space made available by its parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, drag a new constraint from the top of the new `TextView` to the bottom
    of the Description `TextInputLayout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5fefec3a-0b4f-4d6c-b76e-119fbd898924.png)'
  prefs: []
  type: TYPE_IMG
- en: Use the resource editor to create a new string resource for the text attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the new resource `label_date`, and make its value `Date`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/47baea99-953b-4f38-9088-d945825a3ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: Still in the Attributes panel, change the textAppearance attribute to `AppCompat.Caption`.
    This is the same textAppearance style used by `TextInputLayout` for the hovering
    label when the cursor is focused on its `EditText`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use the resource selector on the textColor attribute to choose the colorAccent
    color resource. This is the highlight color that is generated by Android Studio
    for you, and is also used by `TextInputLayout`. Your `TextView` should now look
    like the focused label for a `TextInputLayout`, which is exactly what you want,
    because the next widget should look like an `EditText`, but isn't.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Palette panel, drag another `TextView` into the design layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Attributes panel to change its ID to `date`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create left and right constraints, and set them to zero.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `layout_width` to `match_constraint` so that the `date` `TextView`
    takes up all the horizontal space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/41f53141-e338-4ee3-80ae-7f9e6cccf0e7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the constraint handle from the top of the `date` `TextView` to the bottom
    of its `TextView` label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6bd09ad8-9b72-4aeb-8ad5-3d5a1c1f9190.png)'
  prefs: []
  type: TYPE_IMG
- en: At the top of the Attributes panel, use the View all attributes toggle button
    to view all the available attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the Attributes search box, find the style attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/495ef0a5-3527-4d67-81d2-e69da59b75d4.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the resource selector for the style attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using the search box, find the `AppCompat.EditText` style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b346e2f1-42eb-49b8-92e1-3d3267d1d4f1.png)'
  prefs: []
  type: TYPE_IMG
- en: Clear the search box, and toggle back to the View fewer attributes panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the text attribute by deleting its content (this `TextView` should be
    empty in the layout file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Component Tree, select the `CardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change its `layout_height` to `wrap_content`. The `CardView`
    will roll upward, taking up just enough space to contain the widgets that now
    make up the description, amount, and date inputs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike the description and amount input boxes, the date is actually made up
    of two labels that are styled so that together, they look like a focused `TextInputLayout`
    widget. This is important because the user will populate the date using a calendar
    dialog, rather than typing the date using a keyboard. A calendar dialog is more
    user-friendly, and less error-prone than manual date entry. Also, like this, the
    component looks familiar to the user, giving them a suggestion of how it should
    be used. This sort of styling capability is very important and useful in Android,
    and it's worth learning how standard components are composed together and styled
    so that you can build these sort of emulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your completed Description, Amount, and Date, so the capture box should look
    like this in the Android Studio layout editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85409db6-d79f-4935-9875-b89dc5cc2422.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the category chooser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The category chooser is where the user will select how to file their expense
    claims. There''ll be a fairly small number of these, and they will be represented
    by icons in the user interface. Fortunately for Android developers, Material specifies
    a huge range of standard icons, and Android Studio has features to import them
    as bitmap or vector graphics files. When deciding whether to use bitmap images
    or SVGs, it''s important to consider the trade-off between these two formats,
    specifically in relation to Android. Especially so since in Android, multiple
    copies of a bitmap are often provided for different screen sizes and densities,
    leading to much higher-quality scaling (as most will only ever be scaled down
    slightly). Here''s a quick table to compare them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bitmaps** | **Vector Graphics** |'
  prefs: []
  type: TYPE_TB
- en: '| Are supported on all platforms natively | May require a support library to
    work |'
  prefs: []
  type: TYPE_TB
- en: '| Can be handled by the GPU and rendered with full acceleration | Must be rendered
    into a bitmap before they can be rendered onto the screen, which takes time |'
  prefs: []
  type: TYPE_TB
- en: '| Take up more space in your app''s APK, especially as you may need to provide
    different copies for different screen sizes and densities | Are stored as binary
    XML files, and take up very little space in the APK |'
  prefs: []
  type: TYPE_TB
- en: '| Suffer massive loss of quality when scaled up, and loss of detail when scaled
    down | Can be rendered at virtually any size with no perceptible loss of quality
    or detail |'
  prefs: []
  type: TYPE_TB
- en: 'For the category chooser widget, you''ll be importing vector graphics icons
    and using them as radio buttons. Let''s get things started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the files view to the extreme left of Android Studio, right-click on the
    res directory and select New, Vector Asset to open the vector import tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/631d4086-a4f6-453f-9ad4-5e74811d1ffc.png)'
  prefs: []
  type: TYPE_IMG
- en: Where it says Icon, click on the button with the Android robot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the search box at the top-left of the dialog to find the "hotel" icon, and
    select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on OK to return to the import tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The import tool will have changed the proposed name to `ic_hotel_black_24dp`;
    change this to `ic_accommodation_black`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3f4c1482-edc2-4fe5-90c3-696e59780450.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Size boxes, select the Override checkbox and change the size to `32`
    dp X `32` dp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Next and then on Finish to complete the import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process, and find the room service icon. Name this one `ic_food_black`,
    and don't forget to change its size to `32` dp X `32` dp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for the airport shuttle icon. This is `ic_transport_black`, and
    again, change its size to `32` dp X `32` dp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat and find the local movies icon; name this `ic_entertainment_black` and
    remember to change its size to `32` dp X `32` dp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the "business center" icon and name it `ic_business_black`; again, change
    its size to `32` dp X `32` dp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, find the all inclusive icon, name it `ic_other_black`, and override
    its size to `32` dp X `32` dp.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have a collection of black icons that will serve as the basis for your
    category selector.
  prefs: []
  type: TYPE_NORMAL
- en: Making icons change with state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Android, images have state; they can change how they look according to the
    widget that is using them. In fact, this is how a button works; it has a background
    image that changes state depending on whether it''s pressed, released, enabled,
    disabled, focused, and so on. For us to show the user which of these categories
    they have actually selected, we need to provide them with a visual indication
    on the icon. This involves some editing:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by making a copy of the `ic_accommodation_black.xml` file that was generated,
    and name this one `ic_accommodation_white.xml`. Use copy, and then paste the file
    into the same directory to have Android Studio bring up a Copy dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Vector graphics in Android are XML files representing the various shapes and
    colors that make up the graphic. A vector graphic doesn't contain the pixel data
    like a bitmap image (such as a `.png` or `.jpeg`), but contains instructions for
    how to render the image. This means that by adjusting the coordinates contained
    within the instructions, the image can be made larger or smaller with little or
    no loss of quality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Beware**, because by default, Android Studio might have selected the drawable-xhdpi
    directory as the target for the paste operation. If it has, you''ll need to change
    this to `drawable`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f800a39c-18a1-4356-a9e3-4ffb49e6f7fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The editor will open with the new copy of the icon, which will still be black.
    The code for the file will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Change the `android:fillColor` attribute from `#FF000000` to `#FFFFFFFF` to
    change the icon from black to white.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Colors in Android resources are specified using the standard Hexadecimal color
    notation. This is the same notation used on the web in CSS and HTML files. Each
    pair of two characters represents one part of the color component with values
    from 0 to 255 (inclusive). The components are always Alpha, Red, Green, and Blue,
    in that order. Alpha represents how transparent or opaque the color is, zero (00)
    being completely invisible, while 255 (FF) is completely opaque.
  prefs: []
  type: TYPE_NORMAL
- en: Now, repeat this operation for all the other icons you imported, ensuring that
    each one is copied to the drawable directory, and change its name from `_black`
    to `_white`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now have a black and white version of each icon; black is perfect to place
    against the white background of a `CardView`, while white is perfect to place
    against the accent color of your application, and shows how the icon has been
    selected by the user. For this, we need even more drawable resources. Right-click
    on the drawable directory and choose New| Drawable resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new file `ic_category_accommodation` and click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Android Studio will now open the new file, which will be an empty selector
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A selector element corresponds to a `StateListDrawable` object from the `android.graphics.drawable`
    package. This class attempts to match its own state flags against a list of possible
    visual states (other `drawable` objects). The first item that matches is displayed,
    which means that it's important to consider the order you declare the states in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, tell the selector that it will always be the same size by setting its
    `constantSize` attribute, and then tell it that it should quickly animate between
    its state changes. This short animation gives the user an indication of these
    changes when choosing a category:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you''ll need to create a state for when the category is selected; you''ll
    use two layers: one will be a simple circle background filled with the accent
    color, and over that you''ll have the white version of the accommodation icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create another `item` that is the default state--the black-filled accommodation
    icon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this process for each icon you imported so that each one has a stateful,
    drawable icon that you can use in the layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process is often repeated, and there may even be more drawable resources
    involved for more varied state lists. Drawable elements are not always nested,
    as you did with the preceding `state_checked` item; they are often written into
    external drawable resources and then imported. This allows them to be reused without
    requiring the resource to be state-aware.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the category picker layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to go back to the layout editor and start creating the category
    selector box with these icons:'
  prefs: []
  type: TYPE_NORMAL
- en: Reopen the `content_capture_claim.xml` layout file from the `res/layout` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Palette panel, open the AppCompat section and drag another `CardView`
    into the layout editor. Drop it below the `CardView` for the description, amount,
    and date input fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, use the View all attributes toggle button and search
    box to find the layout margin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Layout_Margins attribute group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, open the resource selector for the top attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `grid_spacer1` dimension resource you created earlier, and click
    on OK to close the resource selector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb994880-a20d-4800-8d29-987d2f3e5ebf.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, in the Palette, open the Layouts section and drag a LinearLayout (vertical)
    into the new `CardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, use the resource selector to change the all margin
    attribute to `grid_spacer1` to create some padding from the edges of the `CardView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the Attributes panel search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Containers section of the Palette, and drag a `RadioGroup` into the
    new `LinearLayout` in the layout editor. A `RadioGroup` is a specialized `LinearLayout`
    that handles the toggling of its child `RadioButton` widgets, which you'll use
    to allow the user to select a category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the id attribute to `categories`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, use the search box to find the orientation attribute
    and change it to `horizontal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the Attributes panel search box, and toggle it back to View fewer attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Widgets section of the Palette and drag a `RadioButton` into the new
    `RadioGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the ID to `accommodation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the layout_weight attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the resource editor for the button attribute to select the `ic_category_accommodation`
    you created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/15e865bd-2b6f-40c0-8568-3bb3d6e2e4b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Clear the text attribute, since these radio buttons won't have any labels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You'll then use the contentDescription attribute to store the human readable
    name of the category. Open the resource editor, create a new string resource named
    `description_accommodation`, and give it a value of `Accommodation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `contentDescription` attribute is part of the accessibility system, and
    it's used by screen readers and similar aids to describe a component that might
    not have a text label. In this case, it's a perfect place for us to grab the human-readable
    description of a category. It's not an on-screen space, and it also serves users
    with accessibility enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Toggle the Attributes panel to view all the attributes, and then find the layout
    margins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the resource selector to change the end margin attribute to `grid_spacer1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process of adding and populating radio buttons for the categories,
    giving each of them a suitable name in their ID and contentDescription attributes.
    Leave the “other” category until last so that it appears to the right of all the
    others.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Component Tree panel, select the RadioGroup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change its layout_height to `wrap_content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Palette, open the Text section and drag a `TextView` into place below
    the `RadioGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the ID to `selected_category`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the text attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the drop-down on the textAppearance attribute to select `AppCompat.Medium`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Component Tree, select the `CardView` containing the category selection
    components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now in the Attributes panel, change the layout_height to `wrap_content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `CardView` will wrap upward, packing in the radio buttons and the label
    that you will use to display the currently selected category name. The `CardView`,
    again, serves to visually group the categories, and helps the user understand
    how they use this area of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f41b0d7-414d-429c-a551-8cae187805df.png)'
  prefs: []
  type: TYPE_IMG
- en: The use of standard styles and theming, again, helps the user to quickly grasp
    how things work; even though the categories are just a row of icons, they are
    underscored by the selected category name.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the attachment preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After completing the category selector box, roughly half the available layout
    space should be left empty underneath. This is where the user will be able to
    preview the attachments they have added to the claim. We want the user to be able
    to swipe through these attachments left and right, and the easiest way to allow
    this is a `ViewPager`. A `ViewPager` is a special type of Android widget that
    links to an `Adapter` (other examples are `ListView`, `Spinner`, and `RecylerView`).
    An `Adapter` object turns data (such as rows from a database cursor, or objects
    from a `java.util.List`) into widgets that can be displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add it to the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewPager` class is not available from the Palette panel, so at the bottom
    of the layout editor, change from Design mode to Text mode, so that you can edit
    the layout XML directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the bottom of the file and find the space between where the last `CardView`
    element is closed and where the `LinearLayout` is closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert a `ViewPager` element into that space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Change back to the Design view, and you'll note that a new box has been added
    to the layout and blueprints where the empty space was.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `clipChildren` and `clipToPadding` attributes in the preceding code change
    how the `ViewPager` and its children treat the space around them when rendering.
    The `CardView` class draws its shadows outside of its boundaries, and by default,
    these are clipped by the graphics system. Turning the clipping off allows the
    shadows and borders to be rendered completely.
  prefs: []
  type: TYPE_NORMAL
- en: A `ViewPager` doesn't look like anything on its own; its children are the only
    things that make it appear visually. So, until the user has added an attachment
    to a claim, nothing will appear in this space. This is not a problem, since the
    empty area provides a space for the software keyboard to appear when they enter
    the description and amount.
  prefs: []
  type: TYPE_NORMAL
- en: Try it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the knowledge you have gained in this chapter, import the attachment icon
    as a vector graphic, change its fill color to white, and set it as the icon of
    the floating action button that appears at the bottom-right of your layout. Once
    you have the icon right, try increasing the size of the floating action button
    to make it more thumb-friendly for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing a form screen, what is the first thing you should consider?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The colors and icons you want to use
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The data you need from your user
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard guidelines for Android
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the standard spacing increment in Material design?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 8 Pixels
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 Density Independent Pixels
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 8 Device Pixels
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConstraintLayout`, `ViewPager`, and `CardView` are part of the support
    APIs. What does this mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Their bytecode must be included with your application if you use them
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They are also used as part of the Android Studio code base
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: They can only contain other widgets from the support APIs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When building a new layout, your root widget should always be which of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `ConstraintLayout`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LinearLayout`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The simplest widget that makes sense for your layout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to design and then build a form screen in
    detail. These screens are an important part of applications, because they are
    where you users give you their details and as such they need to be especially
    intuitive and quick to use. Nobody likes to spend a lot of time filling in forms,
    and even less if they are using a mobile device. It's always good to remember
    that people normally use apps for relatively short periods of time; "what was
    that email?", is a more common action than "let me draft a letter to someone."
    This viewpoint helps when it comes to designing the user interfaces and overall
    experience you will build for your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s always a good idea to sketch out your screen somewhere visually, and
    if you do, use software for it: ensure that it''s something that lets you focus
    on layout and content rather than having to worry about colors, templates, or
    layout systems; always design first and then figure out how you''ll build it.
    Pay attention to apps you enjoy using and that you find useful, look at how they
    do things--imitation is the sincerest form of flattery. Don''t copy people too
    closely, but draw inspiration from good ideas; your users will thank you for it
    as well, because you''ll be presenting them with something familiar, and hopefully
    more innovative at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: Try to keep all text, colors, and dimensions as resources, and use generic names
    for these resources wherever possible. It's not uncommon to have an *ok* and *cancel*
    resource defined right under the application's name, because they are commonly
    used throughout applications. Keeping these values in the resource system allows
    for changes to be made far more easily, and keeps the application look and experience
    consistent for your users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at events, the Android event model, and how
    to best deal with events from your user interfaces in a way that provides the
    best user experience, while also being the more flexible to program with.
  prefs: []
  type: TYPE_NORMAL
