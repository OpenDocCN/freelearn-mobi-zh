- en: Chapter 1. Creational Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creational patterns are designed to deal with the object creation mechanism
    in software designing. A system using these patterns becomes independent of how
    objects are created, which means it is independent of how concrete classes are
    instantiated.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: These patterns encapsulate the use of concrete classes and favor the use of
    interfaces in the relationship between objects, allowing to have better abstraction
    of the global system conception.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if we analyze the **singleton** pattern, a pattern designed to instantiate
    only one instance of a class, we find that the mechanism that controls the unique
    access to this instance is fully encapsulated in the class, which means that this
    is completely transparent to the client consuming the instance of the class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce you to the five creational patterns and
    discuss how we can use them with Swift:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory method pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The objectives of these patterns are described in the following table:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Objective |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: '| The prototype pattern | This pattern allows you to create new objects by
    duplicating existing objects called prototypes. This pattern has the cloning capability.
    |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
- en: '| The factory method pattern | This pattern introduces you to an abstract method
    that allows you to create an object by telling its subclasses about the effective
    creation of the object. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
- en: '| The singleton pattern | This pattern ensures that a class has only one instance.
    This class provides a unique point of access that returns this instance. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| The abstract factory pattern | This pattern allows you to create an object
    that is grouped in families by hiding the concrete classes that are needed to
    create these objects. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| The builder pattern | This pattern allows you to separate the creation of
    complex objects from their implementation. This permits a client to create complex
    objects having different representations. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: The prototype pattern
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first pattern will be the prototype pattern; we will see how we can use
    it to accelerate the creation of an instance. We will see how we can use it to
    copy an existing instance, and eventually, we will see how to modify the new one
    to our needs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern is used to create a new object by duplicating existing
    objects called **prototypes**, and they have a cloning capability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used in the following use cases:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: When you need to create an instance without knowing the hierarchy of a class
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to create class instances that are dynamically loaded
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to have a simple object system and not include a parallel hierarchy
    of a factory class
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the generic class of the prototype pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Participant to this pattern are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`Client`: This class contains a list of objects called prototypes that are
    instances of the `AbstractPrototype` abstract class. The `Client` class needs
    to clone these prototypes without having to know their internal structure and
    subclass hierarchy.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractPrototype`: This is an abstract class that can duplicate itself. This
    class contains a cloning method called `clone()`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcretePrototype1` and `ConcretePrototype2`: These are concrete classes that
    inherit from the `AbstractPrototype` class. They define a prototype and have both
    a cloning method called `clone()`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborations
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client asks to one or more prototypes to clone themselves.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple and real example of where this pattern can be applied is the famous
    game *HeartStone* from *Blizzard* (the creator of *World of Warcraft*). In this
    strategy card game, when you spend "mana" to use spells, weapons, or put a minion
    on the board, there is a special minion that has the ability to clone a particular
    card. When a player uses this card, it selects the minion that he or she wants
    to clone and the card becomes an exact copy of the selected card. The following
    card represent the "HeartStone" card that have this behavior:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration](img/4852_01_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Implementation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code represent the implementation of the pattern using Swift:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AbstractPrototype` class is our `AbstractCard` class, where we implement
    a way to return a copy of itself using the `clone()` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code simulate how the client will interact with the `Card` object
    which implement the prototype pattern:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the code is written in a Playground file, you should consider it as the
    code that you'll put in the `Client` class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: First, we instantiate a new card named `Raid Leader`. This is a concrete prototype
    class. Let say that you have the "Faceless Manipulator" card and you want to use
    it to clone the "Raid Leader" card, then you simply need to use the `raidLeader.clone()`
    method that will return a new instance with the exact same properties as "Raid
    Leader".
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'By checking the details on the right-hand side of the Playground file, you''ll
    see that the `facelessManipulator` constant has exactly the same properties as
    `raidLeader` (line 39), as shown in the following screenshot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: The factory method pattern
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our second pattern is a very well-known pattern. It introduces you to the famous
    concept: "Program to an interface, not an implementation." The instantiation is
    done in the factory class that depends on the type that we need and the type that
    needs to be returned to the client.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern is one of the most used patterns in software designs.
    The purpose of this pattern is to abstract the creation of an object. The factory
    method lets a class defer instantiation to subclasses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: You'll see from that time to time that we have mentioned "program to an interface."
    This is exactly what this pattern does. With Swift, instead of an interface, you'll
    code with the "protocol" instead of the class itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used in the following use cases:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: A class only knows about abstract classes or interfaces of objects with whom
    it has some relationships
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class wants its subclasses to instantiate the object in order to benefit of
    polymorphism mechanism
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the generic class of the factory method pattern:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Participant to this pattern are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**Product interface**: This class contains the definition of our product. We
    will define what a card is here.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract product**: This abstract class implements the signature of our cards
    and some methods. You''ll see that we keep the prototype pattern that allows us
    to eventually clone a card. These classes define the properties of our products.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete product**: This class defines our product; in our example, the `Raid
    Leader` card is a concrete product, such as the `Faceless Manipulator` card.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete creator**: This class implements our factory method.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous pattern, you would have seen the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we directly program an implementation. We need a way to create some cards,
    but without having the knowledge to know exactly how to construct the card; we
    can only tell to create the `raidLeader` and `Faceless Manipulator` cards. At
    this point of time, the client doesn't want to know that the `Raid Leader` card
    needs three manas, so it provides two points of attack and two points of defense.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the factory method pattern is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Usage
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate the use of the factory method pattern by a client, we can write
    the card creation as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To simulate our client, we simply tell the `CardFactory` method that we want
    a `FacelessManipulator` card.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we use the `createCard` method (our factory method), and this method
    will delegate the instantiation of the card that was asked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The variable `c` has the type `Card` and not `FacelessManipulator`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is certainly the pattern that every developer learns first. It
    is often used with a factory or abstract factory class to ensure that there is
    only one instance of the class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The singleton pattern ensures that a class has only one instance and provides
    a global point of access to it, and at this point, it returns an instance of this
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it can be useful to have some classes that have only one instance;
    for example, in the case of the abstract factory, where it is not useful to have
    several instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Design
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following figure shows the generic UML class diagram of the singleton pattern.
    There are many way to write the singleton pattern using Swift.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the easiest way to do this. With Swift, you''ll see that we can
    change the way in which we apply it, thanks to the class constant:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is only one participant in this pattern: the `Singleton` class.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: This class provides a method that returns only one instance of the class. The
    mechanism locks the creation of other instances. It was introduced with Swift
    1.2\. We can now use class constants.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: With Swift 1.2, we will use the class constants to provide us with a way to
    ensure the unique creation of the instance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'A class constant is defined as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Collaborations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every client will have access to the unique instance of the `Singleton` class
    by calling the `Instance` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: With Swift, the approach we'll consider is the one that accesses our unique
    instance of the `Singleton` class using the class constant that we will call `sharedInstance`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are developing your card game and you need to manage all the data of the
    current game. In our game, we have two players; each player has a deck, mana reserve,
    name, and so on. We have a board (the table where we put our cards) and a game
    state (who is currently playing). To manage all of this information, you'll need
    a `BoardManager` class. This class will be a singleton class because we will not
    have several boards at the same time (we only allow one game at a time). The singleton
    pattern can be something interesting that can be used here in order to make sure
    that we access the good data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following approach supports lazy initialization, and it is thread safe
    by the definition of `let`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Usage
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use our singleton object, each client will access it using the following
    code :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `boardManager` variable contains all the members available in our singleton
    object and will be initialized only once.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used in the following cases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: We must have only one instance of a class
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This instance must be accessible to clients from a well-known access point
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already introduced you to a very popular concept in design patterns: **factories**.
    Factories are the classes that handle the instantiation of related objects without
    subclassing. The factory method pattern that we have already seen hides the class
    name from where an object is instantiated. The abstract factory pattern is more
    complete as it creates families of related or dependent objects.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory pattern is designed to build objects grouped in families
    without having to know the concrete class needed to create the object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is generally used in the following domains:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: A system that uses products needs to stay independent of how these products
    are grouped and instantiated
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system can have several product families that can evolve
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram represents the generic structure of the abstract factory
    pattern. You will see how products and families are decoupled:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The abstract factory pattern has a lot of participants:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '`Abstract` `Factory`: This abstract class defines the signature of the different
    methods that create our products.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteFactory1` and `ConcreteFactory2`: These are our concrete classes that
    implement our methods for each products'' families. By knowing the family and
    product, the factory is able to create an instance of the product for that family.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IProductA` and `IProductB`: These are our interfaces that define our products
    that are independent of their family. A family is introduced in their concrete
    subclasses.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductA` and `ProductB`: These are the concrete classes that implement `IProductA`
    and `IProductB`, respectively.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborations
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Client` class uses one instance of one of the concrete factories to create
    products throughout the interface of the abstract factory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our company specializes in manufacturing watches. Our watches are built in
    two parts: a band and dial. Our watches come in two sizes, so we must adapt the
    manufacturing of the band and dial according to the size of our watch.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In order to simplify how to manage the manufacturing of our watches, the direction
    team decided to use one manufacturer who specializes in products that are adapted
    to the 38 mm model of our watch, and another manufacturer whose products are adapted
    to the 42 mm model of our watch.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Each of these manufacturers will build a dial and band that are adapted to the
    dimension of the watch.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement our pattern, we first need to identify our actors. The two manufacturers
    represent the `ConcreteFactory1` and `ConcreteFactory2` classes. These two factories
    implement the `AbstractFactory` method, which tell us that we can create a band
    or dial. Of course, the concrete factories will create the dial adapted to the
    size of the watch produced in that manufacture.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ConcreteProductA` and `ConcreteProductB` classes are the band and the
    dial; each of these products implements their respective `IProductA` and `IProductB`
    interfaces, as shown in the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Usage
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate our client, we will use the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'The Playground file will display our product''s properties, depending on the
    factory used. The details of product *A* (the band) and product *B* (the dial)
    from the `manufacture1` object are shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'The details of product *C* (the band) and product *D* (the dial) from the `manufacture2`
    object are shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_08.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: The sizes of the band and the dial adapt to the manufacturer who delivers the
    product.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should use the singleton pattern to ensure that we have only one instance
    of our abstract factory. This instance can be shared between several clients.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the abstract factory pattern, which will produce parts of products of
    the same family, the builder pattern will help us build the finalized product
    that consists of several parts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of the builder pattern is to abstract the building of complex
    objects from its actual construction. Having the same construction process can
    create different representations of the product.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A client needs to construct complex objects without having to know its implementation
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client needs to construct complex objects that need to have several implementations
    or representations
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure shows the generic UML class diagram of the builder pattern:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_09.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is quite simple as it has only a few participants:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '`Director`: This class constructs the product using the interface of the `AbstractBuilder`
    class.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractBuilder`: This class defines the method signature that allows the
    construction of all the parts of the product, and it contains a signature of a
    method that returns the product once this is built.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteBuilder`: This is the `Concrete` class that implements the method
    of the `AbstractBuilder` class.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Product`: This is the finalized product. The product contains all the parts
    of the watch.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborations
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client creates the `ConcreteBuilder` and `Director` classes. The `Director`
    class will then build an object if the client asks him to do so by invoking the
    constructor and returns the finalized product to the client.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `AbstractFactory` method, we can use the builder pattern to build
    a watch. As we''ve seen that a watch has several parts: a dial and band. A watch
    can have two sizes too, and as we have already seen, the representation of the
    dial or band depends on the size of the watch too.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to build some watches that are represented with a dial and band,
    we will define a `Director` class that will define the construction order of all
    the parts of our watches and return the finalized watch to the client.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The `Director` class will call all the constructors who are in charge to construct
    one part of the watch. To implement this, we will reuse the existing code of the
    abstract factory pattern and add the following code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Builder.playground` file in Xcode to see the added code at the bottom
    of the file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usage
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate our client, we will tell our director to create two watches:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: A 42 mm aluminium dial with a sports band
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 38 mm gold dial with a milanese band
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for the example is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is shown in Playground like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_10.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift allows the use of closure that simplifies the creation of our complex
    objects. Regarding the example that we provided earlier, we can write the following
    code to build our two watches.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 允许使用闭包来简化我们复杂对象的创建。关于我们之前提供的示例，我们可以编写以下代码来构建我们的两个手表。
- en: Implementation using closures
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包的实现
- en: Here, we don't need to use the `Director` and `ConcreteBuilder` classes. Instead,
    we will tell our `Watch` class that the builder will be in the closure.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不需要使用`Director`和`ConcreteBuilder`类。相反，我们将告诉我们的`Watch`类，构建器将在闭包中。
- en: In the previous example, remove the `Director`, `AbstractBuilder`, and `ConcreteBuilder`
    classes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，移除`Director`、`AbstractBuilder`和`ConcreteBuilder`类。
- en: 'We just need to write the `Watch` class, as shown in the following code (you
    can find the following code in the `BuilderClosures.playground` file accompanying
    this chapter):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编写如下的`Watch`类，如下代码所示（你可以在伴随本章的`BuilderClosures.playground`文件中找到以下代码）：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, to simulate our client, we can write the following code which will call
    the appropriate constructor assigned to the band or dial property of the `Watch`
    object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了模拟我们的客户端，我们可以编写以下代码，该代码将调用分配给`Watch`对象带或表盘属性的适当构造函数：
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Implementation using closures](img/4852_01_11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![使用闭包的实现](img/4852_01_11.jpg)'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'Well, I hope that this chapter was a good introduction to the use of patterns
    using Swift. We learned the five creational patterns: the prototype pattern, the
    factory method pattern, the singleton pattern, the abstract factory pattern, and
    the builder pattern. We also learned when to use them and how to implement them.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我希望这一章对使用 Swift 的模式进行了良好的介绍。我们学习了五种创建型模式：原型模式、工厂方法模式、单例模式、抽象工厂模式和建造者模式。我们还学习了何时使用它们以及如何实现它们。
- en: In the next chapter, we will introduce you to three structural patterns that
    are designed to ease the relationship between entities.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您介绍三种旨在简化实体之间关系的结构模式。
