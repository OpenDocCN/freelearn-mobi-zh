- en: Chapter 1. Creational Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The creational patterns are designed to deal with the object creation mechanism
    in software designing. A system using these patterns becomes independent of how
    objects are created, which means it is independent of how concrete classes are
    instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: These patterns encapsulate the use of concrete classes and favor the use of
    interfaces in the relationship between objects, allowing to have better abstraction
    of the global system conception.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if we analyze the **singleton** pattern, a pattern designed to instantiate
    only one instance of a class, we find that the mechanism that controls the unique
    access to this instance is fully encapsulated in the class, which means that this
    is completely transparent to the client consuming the instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will introduce you to the five creational patterns and
    discuss how we can use them with Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: The prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The objectives of these patterns are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Objective |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| The prototype pattern | This pattern allows you to create new objects by
    duplicating existing objects called prototypes. This pattern has the cloning capability.
    |'
  prefs: []
  type: TYPE_TB
- en: '| The factory method pattern | This pattern introduces you to an abstract method
    that allows you to create an object by telling its subclasses about the effective
    creation of the object. |'
  prefs: []
  type: TYPE_TB
- en: '| The singleton pattern | This pattern ensures that a class has only one instance.
    This class provides a unique point of access that returns this instance. |'
  prefs: []
  type: TYPE_TB
- en: '| The abstract factory pattern | This pattern allows you to create an object
    that is grouped in families by hiding the concrete classes that are needed to
    create these objects. |'
  prefs: []
  type: TYPE_TB
- en: '| The builder pattern | This pattern allows you to separate the creation of
    complex objects from their implementation. This permits a client to create complex
    objects having different representations. |'
  prefs: []
  type: TYPE_TB
- en: The prototype pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first pattern will be the prototype pattern; we will see how we can use
    it to accelerate the creation of an instance. We will see how we can use it to
    copy an existing instance, and eventually, we will see how to modify the new one
    to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The prototype pattern is used to create a new object by duplicating existing
    objects called **prototypes**, and they have a cloning capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used in the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to create an instance without knowing the hierarchy of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to create class instances that are dynamically loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you need to have a simple object system and not include a parallel hierarchy
    of a factory class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the generic class of the prototype pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Participant to this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Client`: This class contains a list of objects called prototypes that are
    instances of the `AbstractPrototype` abstract class. The `Client` class needs
    to clone these prototypes without having to know their internal structure and
    subclass hierarchy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractPrototype`: This is an abstract class that can duplicate itself. This
    class contains a cloning method called `clone()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcretePrototype1` and `ConcretePrototype2`: These are concrete classes that
    inherit from the `AbstractPrototype` class. They define a prototype and have both
    a cloning method called `clone()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client asks to one or more prototypes to clone themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple and real example of where this pattern can be applied is the famous
    game *HeartStone* from *Blizzard* (the creator of *World of Warcraft*). In this
    strategy card game, when you spend "mana" to use spells, weapons, or put a minion
    on the board, there is a special minion that has the ability to clone a particular
    card. When a player uses this card, it selects the minion that he or she wants
    to clone and the card becomes an exact copy of the selected card. The following
    card represent the "HeartStone" card that have this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Illustration](img/4852_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code represent the implementation of the pattern using Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `AbstractPrototype` class is our `AbstractCard` class, where we implement
    a way to return a copy of itself using the `clone()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code simulate how the client will interact with the `Card` object
    which implement the prototype pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the code is written in a Playground file, you should consider it as the
    code that you'll put in the `Client` class.
  prefs: []
  type: TYPE_NORMAL
- en: First, we instantiate a new card named `Raid Leader`. This is a concrete prototype
    class. Let say that you have the "Faceless Manipulator" card and you want to use
    it to clone the "Raid Leader" card, then you simply need to use the `raidLeader.clone()`
    method that will return a new instance with the exact same properties as "Raid
    Leader".
  prefs: []
  type: TYPE_NORMAL
- en: 'By checking the details on the right-hand side of the Playground file, you''ll
    see that the `facelessManipulator` constant has exactly the same properties as
    `raidLeader` (line 39), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The factory method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our second pattern is a very well-known pattern. It introduces you to the famous
    concept: "Program to an interface, not an implementation." The instantiation is
    done in the factory class that depends on the type that we need and the type that
    needs to be returned to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The factory method pattern is one of the most used patterns in software designs.
    The purpose of this pattern is to abstract the creation of an object. The factory
    method lets a class defer instantiation to subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see from that time to time that we have mentioned "program to an interface."
    This is exactly what this pattern does. With Swift, instead of an interface, you'll
    code with the "protocol" instead of the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used in the following use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: A class only knows about abstract classes or interfaces of objects with whom
    it has some relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class wants its subclasses to instantiate the object in order to benefit of
    polymorphism mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram shows the generic class of the factory method pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Participant to this pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product interface**: This class contains the definition of our product. We
    will define what a card is here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract product**: This abstract class implements the signature of our cards
    and some methods. You''ll see that we keep the prototype pattern that allows us
    to eventually clone a card. These classes define the properties of our products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete product**: This class defines our product; in our example, the `Raid
    Leader` card is a concrete product, such as the `Faceless Manipulator` card.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete creator**: This class implements our factory method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our previous pattern, you would have seen the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we directly program an implementation. We need a way to create some cards,
    but without having the knowledge to know exactly how to construct the card; we
    can only tell to create the `raidLeader` and `Faceless Manipulator` cards. At
    this point of time, the client doesn't want to know that the `Raid Leader` card
    needs three manas, so it provides two points of attack and two points of defense.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The implementation of the factory method pattern is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate the use of the factory method pattern by a client, we can write
    the card creation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To simulate our client, we simply tell the `CardFactory` method that we want
    a `FacelessManipulator` card.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we use the `createCard` method (our factory method), and this method
    will delegate the instantiation of the card that was asked.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `c` has the type `Card` and not `FacelessManipulator`.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is certainly the pattern that every developer learns first. It
    is often used with a factory or abstract factory class to ensure that there is
    only one instance of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The singleton pattern ensures that a class has only one instance and provides
    a global point of access to it, and at this point, it returns an instance of this
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it can be useful to have some classes that have only one instance;
    for example, in the case of the abstract factory, where it is not useful to have
    several instances.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following figure shows the generic UML class diagram of the singleton pattern.
    There are many way to write the singleton pattern using Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the easiest way to do this. With Swift, you''ll see that we can
    change the way in which we apply it, thanks to the class constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is only one participant in this pattern: the `Singleton` class.'
  prefs: []
  type: TYPE_NORMAL
- en: This class provides a method that returns only one instance of the class. The
    mechanism locks the creation of other instances. It was introduced with Swift
    1.2\. We can now use class constants.
  prefs: []
  type: TYPE_NORMAL
- en: With Swift 1.2, we will use the class constants to provide us with a way to
    ensure the unique creation of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class constant is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Collaborations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every client will have access to the unique instance of the `Singleton` class
    by calling the `Instance` method.
  prefs: []
  type: TYPE_NORMAL
- en: With Swift, the approach we'll consider is the one that accesses our unique
    instance of the `Singleton` class using the class constant that we will call `sharedInstance`.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are developing your card game and you need to manage all the data of the
    current game. In our game, we have two players; each player has a deck, mana reserve,
    name, and so on. We have a board (the table where we put our cards) and a game
    state (who is currently playing). To manage all of this information, you'll need
    a `BoardManager` class. This class will be a singleton class because we will not
    have several boards at the same time (we only allow one game at a time). The singleton
    pattern can be something interesting that can be used here in order to make sure
    that we access the good data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following approach supports lazy initialization, and it is thread safe
    by the definition of `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use our singleton object, each client will access it using the following
    code :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `boardManager` variable contains all the members available in our singleton
    object and will be initialized only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is used in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: We must have only one instance of a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This instance must be accessible to clients from a well-known access point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstract factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already introduced you to a very popular concept in design patterns: **factories**.
    Factories are the classes that handle the instantiation of related objects without
    subclassing. The factory method pattern that we have already seen hides the class
    name from where an object is instantiated. The abstract factory pattern is more
    complete as it creates families of related or dependent objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract factory pattern is designed to build objects grouped in families
    without having to know the concrete class needed to create the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is generally used in the following domains:'
  prefs: []
  type: TYPE_NORMAL
- en: A system that uses products needs to stay independent of how these products
    are grouped and instantiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A system can have several product families that can evolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram represents the generic structure of the abstract factory
    pattern. You will see how products and families are decoupled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The abstract factory pattern has a lot of participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Abstract` `Factory`: This abstract class defines the signature of the different
    methods that create our products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteFactory1` and `ConcreteFactory2`: These are our concrete classes that
    implement our methods for each products'' families. By knowing the family and
    product, the factory is able to create an instance of the product for that family.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IProductA` and `IProductB`: These are our interfaces that define our products
    that are independent of their family. A family is introduced in their concrete
    subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProductA` and `ProductB`: These are the concrete classes that implement `IProductA`
    and `IProductB`, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Client` class uses one instance of one of the concrete factories to create
    products throughout the interface of the abstract factory.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our company specializes in manufacturing watches. Our watches are built in
    two parts: a band and dial. Our watches come in two sizes, so we must adapt the
    manufacturing of the band and dial according to the size of our watch.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to simplify how to manage the manufacturing of our watches, the direction
    team decided to use one manufacturer who specializes in products that are adapted
    to the 38 mm model of our watch, and another manufacturer whose products are adapted
    to the 42 mm model of our watch.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these manufacturers will build a dial and band that are adapted to the
    dimension of the watch.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement our pattern, we first need to identify our actors. The two manufacturers
    represent the `ConcreteFactory1` and `ConcreteFactory2` classes. These two factories
    implement the `AbstractFactory` method, which tell us that we can create a band
    or dial. Of course, the concrete factories will create the dial adapted to the
    size of the watch produced in that manufacture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `ConcreteProductA` and `ConcreteProductB` classes are the band and the
    dial; each of these products implements their respective `IProductA` and `IProductB`
    interfaces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate our client, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Playground file will display our product''s properties, depending on the
    factory used. The details of product *A* (the band) and product *B* (the dial)
    from the `manufacture1` object are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of product *C* (the band) and product *D* (the dial) from the `manufacture2`
    object are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The sizes of the band and the dial adapt to the manufacturer who delivers the
    product.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We should use the singleton pattern to ensure that we have only one instance
    of our abstract factory. This instance can be shared between several clients.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the abstract factory pattern, which will produce parts of products of
    the same family, the builder pattern will help us build the finalized product
    that consists of several parts.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main purpose of the builder pattern is to abstract the building of complex
    objects from its actual construction. Having the same construction process can
    create different representations of the product.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  prefs: []
  type: TYPE_NORMAL
- en: A client needs to construct complex objects without having to know its implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A client needs to construct complex objects that need to have several implementations
    or representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following figure shows the generic UML class diagram of the builder pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is quite simple as it has only a few participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Director`: This class constructs the product using the interface of the `AbstractBuilder`
    class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbstractBuilder`: This class defines the method signature that allows the
    construction of all the parts of the product, and it contains a signature of a
    method that returns the product once this is built.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteBuilder`: This is the `Concrete` class that implements the method
    of the `AbstractBuilder` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Product`: This is the finalized product. The product contains all the parts
    of the watch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client creates the `ConcreteBuilder` and `Director` classes. The `Director`
    class will then build an object if the client asks him to do so by invoking the
    constructor and returns the finalized product to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `AbstractFactory` method, we can use the builder pattern to build
    a watch. As we''ve seen that a watch has several parts: a dial and band. A watch
    can have two sizes too, and as we have already seen, the representation of the
    dial or band depends on the size of the watch too.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to build some watches that are represented with a dial and band,
    we will define a `Director` class that will define the construction order of all
    the parts of our watches and return the finalized watch to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The `Director` class will call all the constructors who are in charge to construct
    one part of the watch. To implement this, we will reuse the existing code of the
    abstract factory pattern and add the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Builder.playground` file in Xcode to see the added code at the bottom
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To simulate our client, we will tell our director to create two watches:'
  prefs: []
  type: TYPE_NORMAL
- en: A 42 mm aluminium dial with a sports band
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 38 mm gold dial with a milanese band
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for the example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in Playground like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Usage](img/4852_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Swift allows the use of closure that simplifies the creation of our complex
    objects. Regarding the example that we provided earlier, we can write the following
    code to build our two watches.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation using closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we don't need to use the `Director` and `ConcreteBuilder` classes. Instead,
    we will tell our `Watch` class that the builder will be in the closure.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, remove the `Director`, `AbstractBuilder`, and `ConcreteBuilder`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to write the `Watch` class, as shown in the following code (you
    can find the following code in the `BuilderClosures.playground` file accompanying
    this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to simulate our client, we can write the following code which will call
    the appropriate constructor assigned to the band or dial property of the `Watch`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation using closures](img/4852_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, I hope that this chapter was a good introduction to the use of patterns
    using Swift. We learned the five creational patterns: the prototype pattern, the
    factory method pattern, the singleton pattern, the abstract factory pattern, and
    the builder pattern. We also learned when to use them and how to implement them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce you to three structural patterns that
    are designed to ease the relationship between entities.
  prefs: []
  type: TYPE_NORMAL
