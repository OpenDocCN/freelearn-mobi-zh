<html><head></head><body><div><div><h1 id="_idParaDest-81"><a id="_idTextAnchor105"/>Chapter 6: Putting Pieces Together</h1>
			<p>The previous chapters explored various aspects of Jetpack Compose. For example, <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, compared the traditional View system to composable functions and explained the benefits of the declarative approach. <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>,<em class="italic">Laying Out UI Elements</em>, gave you a solid understanding of some built-in layout composables such as <code>Box()</code>, <code>Row()</code>, and <code>Column()</code>. In <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>, we looked at state and learned about the important role it plays in a Compose app.</p>
			<p>Now, it's time to see how these key elements work together in a real-world app. In this chapter, you will learn how Compose apps can be themed. We will also look at <code>Scaffold()</code>, an integrational UI element that picks up quite a few concepts that were originally related to activities, such as toolbars and menus, and we will learn how to add screen-based navigation.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Styling a Compose app</li>
				<li>Integrating toolbars and menus</li>
				<li>Adding navigation</li>
			</ul>
			<p>We will start by setting up a custom theme for a Compose app. You can define quite a few colors, shapes, and text styles that the built-in Material composables will use when drawing themselves. I will also show you what to keep in mind when you're adding additional Jetpack components that rely on app themes, such as <em class="italic">Jetpack Core Splashscreen</em>.</p>
			<p>The following section, <em class="italic">Integrating toolbars and menus</em>, will introduce you to app bars and the options menu. You will also learn how to create snack bars.</p>
			<p>In the final main section, <em class="italic">Adding navigation</em>, I will show you how to structure your app into screens. We will use the Compose version of <em class="italic">Jetpack Navigation</em> to navigate between them.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>This chapter includes one sample app, <code>ComposeUnitConverter</code>, as shown in the following screenshot: </p>
			<div><div><img src="img/B17505_06_1.jpg" alt="Figure 6.1 – The ComposeUnitConverter app&#13;&#10;" width="796" height="916"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The ComposeUnitConverter app</p>
			<p>Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, as well as how to get the repository that accompanies this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor107"/>Styling a Compose app</h1>
			<p>Most of your <a id="_idIndexMarker213"/>Compose UI will likely use the built-in composable functions from the <code>androidx.compose.material</code> package. They implement the design language known<a id="_idIndexMarker214"/> as <strong class="bold">Material Design</strong> and its successor, <strong class="bold">Material You</strong> (which was introduced with Android 12). Material You is the native design language <a id="_idIndexMarker215"/>on Android, though it will also be available on other platforms. It expands on the ideas of a pen, paper, and cards, and makes heavy use of grid-based layouts, responsive animations, and transitions, as well as padding and depth effects. Material You advocates larger buttons and rounded corners. Custom color themes can be generated from the user's wallpaper.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor108"/>Defining colors, shapes, and text styles</h2>
			<p>While <a id="_idIndexMarker216"/>apps should certainly honor both system and user preferences regarding visual appearance, you may want to add colors, shapes, or text styles<a id="_idIndexMarker217"/> that reflect your brand or corporate identity. So, how can you modify the look of the built-in Material composable functions?</p>
			<p>The main entry<a id="_idIndexMarker218"/> point to Material Theming is <code>MaterialTheme()</code>. This composable may receive custom colors, shapes, and text styles. If a value is not set, a corresponding default (<code>MaterialTheme.colors</code>, <code>MaterialTheme.typography</code>, or <code>MaterialTheme.shapes</code>) is used. The following theme sets custom colors but leaves the text styles and shapes as their defaults:</p>
			<pre>@Composable
fun ComposeUnitConverterTheme(
  darkTheme: Boolean = isSystemInDarkTheme(),
  content: @Composable () -&gt; Unit
) {
  val colors = if (darkTheme) {
    DarkColorPalette
  } else {
    LightColorPalette
  }
  MaterialTheme(
    colors = colors,
    content = content
  )
}</pre>
			<p>The <code>isSystemInDarkTheme()</code> composable detects if the device is currently using a dark theme. Your app should use colors that suit this configuration. My example has two palettes, <code>DarkColorPalette</code> and <code>LightColorPalette</code>. Here's how the latter one is defined:</p>
			<pre>private val LightColorPalette = lightColors(
  primary = AndroidGreen,
  primaryVariant = AndroidGreenDark,
  secondary = Orange,
  secondaryVariant = OrangeDark
)</pre>
			<p><code>lightColors()</code> is a top-level function inside the <code>androidx.compose.material</code> package. It provides a complete color definition for the Material color specification. You<a id="_idIndexMarker219"/> can find more<a id="_idIndexMarker220"/> information about this at <a href="https://material.io/design/color/the-color-system.html#color-theme-creation">https://material.io/design/color/the-color-system.html#color-theme-creation</a>. <code>LightColorPalette</code> overrides the default values for primary, <code>primaryVariant</code>, secondary, and <code>secondaryVariant</code>. All the others (there are, for example, <code>background</code>, <code>surface</code>, and <code>onPrimary</code>) remain unchanged.</p>
			<p><code>primary</code> will be <a id="_idIndexMarker221"/>displayed most frequently across your app's<a id="_idIndexMarker222"/> screens and components. With <code>secondary</code>, you can accent and distinguish your app. It is, for example, used for radio buttons. The checked thumb color of switches is <code>secondaryVariant</code>, whereas the unchecked thumb color is taken from <code>surface</code>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Material composables typically receive their default colors from composable functions called <code>colors()</code>, which belong to their accompanying <code>…Defaults</code> objects. For example, <code>Switch()</code> invokes <code>SwitchDefaults.colors()</code> if no color parameter is passed to <code>Switch()</code>. By looking at these <code>colors()</code> functions, you can find out which color attribute you should set in your theme.</p>
			<p>You may be wondering how I defined, for example, <code>AndroidGreen</code>. The simplest way to achieve this is like this:</p>
			<pre>val AndroidGreen = Color(0xFF3DDC84)</pre>
			<p>This works great if your app does not require other libraries or components that rely on the traditional Android theming system. We will turn to such scenarios in the <em class="italic">Using resource-based themes</em> section.</p>
			<p>Besides colors, <code>MaterialTheme()</code> allows you to provide alternative shapes. Shapes direct attention<a id="_idIndexMarker223"/> and communicate state. Material composables are <a id="_idIndexMarker224"/>grouped into shape categories <a id="_idIndexMarker225"/>based on their size:</p>
			<ul>
				<li>Small (buttons, snack bars, tooltips, and more)</li>
				<li>Medium (cards, dialog, menus, and more)</li>
				<li>Large (sheets and drawers, and more)</li>
			</ul>
			<p>To pass an alternative set of shapes to <code>MaterialTheme()</code>, you must instantiate <code>androidx.compose.material.Shapes</code> and provide implementations of the <code>androidx.compose.foundation.shape.CornerBasedShape</code> abstract class for the categories you want to modify (<code>small</code>, <code>medium</code>, and <code>large</code>). <code>AbsoluteCutCornerShape</code>, <code>CutCornerShape</code>, <code>AbsoluteRoundedCornerShape</code>, and <code>RoundedCornerShape</code> are direct subclasses of <code>CornerBasedShape</code>.</p>
			<p>The following screenshot shows a button with cut corners. While this makes the button look less familiar, it gives your app a distinctive look. You should, however, ensure that you want to add this:</p>
			<div><div><img src="img/B17505_06_2.jpg" alt="Figure 6.2 – A button with cut corners&#13;&#10;" width="437" height="183"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – A button with cut corners</p>
			<p>To achieve this, just add the following line when invoking <code>MaterialTheme()</code>:</p>
			<pre>shapes = Shapes(small = CutCornerShape(8.dp)),</pre>
			<p>You can find <a id="_idIndexMarker226"/>more information about <a id="_idIndexMarker227"/>applying shapes to UIs at <a href="https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme">https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme</a>.</p>
			<p>To alter <a id="_idIndexMarker228"/>the text styles that are used by Material composable functions, you <a id="_idIndexMarker229"/>need to pass an instance of <code>androidx.compose.material.Typography</code> to <code>MaterialTheme()</code>. <code>Typography</code> receives quite a few parameters, such as <code>h1</code>, <code>subtitle1</code>, <code>body1</code>, <code>button</code>, and <code>caption</code>. All of these are instances of <code>androidx.compose.ui.text.TextStyle</code>. If you do not pass a value for a parameter, a default is used.</p>
			<p>The following code block increases the text size of buttons:</p>
			<pre>typography = Typography(button = TextStyle(fontSize =
                                           24.sp)),</pre>
			<p>If you add this line to the invocation of <code>MaterialTheme()</code>, the text of all the buttons using your theme will be 24 scale-independent pixels tall. But how do you set the theme? To make sure that your complete Compose UI uses it, you should invoke your theme as early as possible:</p>
			<pre>class ComposeUnitConverterActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val factory = …
    setContent {
      ComposeUnitConverter(factory)
    }
  }
}</pre>
			<p>In my example, <code>ComposeUnitConverter()</code> is the root of the app's composable UI hierarchy since it is invoked inside <code>setContent {}</code>:</p>
			<pre>@Composable
fun ComposeUnitConverter(factory: ViewModelFactory) {
  …
  ComposeUnitConverterTheme {
    Scaffold( ...</pre>
			<p><code>ComposeUnitConverter()</code> immediately delegates to <code>ComposeUnitConverterTheme {}</code>, which receives the remaining UI as its content. <code>Scaffold()</code> is a skeleton for real-world Compose UIs. We will be taking a closer look at this in the <em class="italic">Integrating toolbars and menus</em> section.</p>
			<p>If you <a id="_idIndexMarker230"/>need to style parts of your app differently, you can <a id="_idIndexMarker231"/>nest themes <a id="_idIndexMarker232"/>by overriding your parent theme (<em class="italic">Figure 6.3</em>). Let's see how this works:</p>
			<pre>@Composable
@Preview
fun MaterialThemeDemo() {
  MaterialTheme(
    typography = Typography(
      h1 = TextStyle(color = Color.Red)
    )
  ) {
    Row {
<strong class="bold">      Text(</strong>
<strong class="bold">        text"= "He"lo",</strong>
<strong class="bold">        style = MaterialTheme.typography.h1</strong>
<strong class="bold">      )</strong>
      Spacer(modifier = Modifier.width(2.dp))
      MaterialTheme(
        typography = Typography(
          h1 = TextStyle(color = Color.Blue)
        )
      ) {
<strong class="bold">        Text(</strong>
<strong class="bold">          text"= "Comp"se",</strong>
<strong class="bold">          style = MaterialTheme.typography.h1</strong>
<strong class="bold">        )</strong>
      }
    }
  }
}</pre>
			<p>In the preceding code snippet, the base theme configures any text that is styled as <code>h1</code> so that it appears<a id="_idIndexMarker233"/> in red. The second <code>Text()</code> uses a nested <a id="_idIndexMarker234"/>theme<a id="_idIndexMarker235"/> that styles <code>h1</code> to appear in blue. So, it overrides the parent theme:</p>
			<div><div><img src="img/B17505_06_3.jpg" alt="Figure 6.3 – Nesting themes&#13;&#10;" width="279" height="90"/>
				</div>
			</div>
			<p class="figure-caption">Figure <a id="_idTextAnchor109"/>6.3 – Nesting themes</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">All the parts of your app must have a consistent look. Consequently, you should use nested themes carefully.</p>
			<p>In the next section, we will continue exploring styles and themes. We will look at how themes are set in the manifest file, as well as how libraries may influence the way you define your Compose theme.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor110"/>Using resource-based themes</h2>
			<p>App styling <a id="_idIndexMarker236"/>or theming has been present on Android since API level 1. It is based on resource files. Conceptually, there is a distinction between styles and themes. A <strong class="bold">style</strong> is a <a id="_idIndexMarker237"/>collection of attributes that specify the appearance (for example, font color, font size, or background color) of a single View. Consequently, styles do not matter for composable functions. A <strong class="bold">theme</strong> is also a <a id="_idIndexMarker238"/>collection of attributes, but'it's applied to an entire app, activity, or View hierarchy. Many elements of a Compose app are provided by Material composables; for them, a resource-based theme does not matter either. However, themes can apply styles to non-View elements, such as the status bar and window background. This may be relevant for a Compose app.</p>
			<p>Styles and themes are declared in XML files inside the <code>res/values</code> directory and are typically named <code>styles.xml</code> and <code>themes.xml</code>, depending on the content. A theme is applied to the application or activity inside the manifest file with the <code>android:theme</code> attribute of the <code>&lt;application /&gt;</code> or <code>&lt;activity /&gt;</code> tag. If none of them receives a theme, <code>ComposeUnitConverter</code> will look as follows:</p>
			<div><div><img src="img/B17505_06_4.jpg" alt="Figure 6.4 – Compose Unit Converter showing an additional title bar&#13;&#10;" width="1254" height="651"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Compose Unit Converter showing an additional title bar</p>
			<p>To avoid <a id="_idIndexMarker239"/>the unwanted additional title bar, Compose apps must configure a theme without action bars, such as <code>Theme.AppCompat.DayNight.NoActionBar</code>, using <code>android:the"e="@styl"/…"</code> for <code>&lt;application /&gt;</code> or <code>&lt;activity /&gt;</code>. This way, <code>ComposeUnitConverter</code> looks like <em class="italic">Figure 6.1</em>. Have you noticed that the status bar has a dark gray background?</p>
			<p>When <code>Theme.AppCompat.DayNight</code> is used, the status bar receives its background color from the <code>colorPrimaryDark</code> theme attribute (or <code>android:statusBarColor</code> since API level 21). If no value is specified, a default is used. Therefore, to make sure that the status bar is shown in a color that fits the remaining UI elements, you must add a file named <code>themes.xml</code> to <code>res/values</code>:</p>
			<pre>&lt;resources&gt;
  &lt;style name="Theme.ComposeUnitConverter"
         parent="Theme.AppCompat.DayNight.NoActionBar"&gt;
    &lt;item
     name="colorPrimaryDark"&gt;@color/android_green_dark
    &lt;/item&gt;
  &lt;/style&gt;
&lt;/resources&gt;</pre>
			<p>In the manifest file, the value of <code>android:theme</code> must then be changed to <code>@style/Theme.ComposeUnitConverter</code>. <code>@color/android_green_dark</code> represents<a id="_idIndexMarker240"/> the color. Instead of this expression, you could also pass the value directly; for example, <code>#FF20B261</code>. It is, however, best practice to store it in a file named <code>colors.xml</code> inside <code>res/values</code>:</p>
			<pre>&lt;resources&gt;
  &lt;color name="android_green_dark"&gt;#FF20B261&lt;/color&gt;
  &lt;color name="orange_dark"&gt;#FFCC8400&lt;/color&gt;
&lt;/resources&gt;</pre>
			<p>This way, you can assign a different value for the Dark theme. The following version of <code>themes.xml</code> should be put in <code>res/values-night</code>:</p>
			<pre>&lt;resources&gt;
  &lt;style name="Theme.ComposeUnitConverter"
         parent="Theme.AppCompat.DayNight.NoActionBar"&gt;
    &lt;item name="colorPrimaryDark"&gt;@color/orange_dark&lt;/item&gt;
  &lt;/style&gt;
&lt;/resources&gt;</pre>
			<p>The status bar now has a background color that fits the remaining UI elements. However, we need to define colors in two places: <code>colors.xml</code> and the Compose theme. Fortunately, this is rather easy to fix. Usually, we pass a literal, like this:</p>
			<pre>val AndroidGreenDark = Color(0xFF20B261)</pre>
			<p>Instead of doing this, we should obtain the value from the resources. The <code>colorResource()</code> composable function belongs to the <code>androidx.compose.ui.res</code> package. It returns the color associated with a resource that's identified by an ID.</p>
			<p>The<a id="_idIndexMarker241"/> following palette does not specify a <code>secondary</code> color:</p>
			<pre>private val LightColorPalette = lightColors(
  primary = AndroidGreen,
  primaryVariant = AndroidGreenDark,
  secondaryVariant = OrangeDark
)</pre>
			<p>Adding a color using <code>colorResource()</code> works as follows:</p>
			<pre>@Composable
fun ComposeUnitConverterTheme(
  darkTheme: Boolean = isSystemInDarkTheme(),
  content: @Composable () -&gt; Unit
) {
  val colors = if (darkTheme) {
    DarkColorPalette
  } else {
    LightColorPalette.copy(secondary = colorResource(
      id = R.color.orange_dark))
  }
  MaterialTheme(
    colors = colors,
    …</pre>
			<p>You saw most of this in the <em class="italic">Defining colors, shapes, and text styles</em> section. The important difference is that I created a modified version of <code>LightColorPalette</code> (with a secondary color) using <code>copy()</code>, which is then passed to <code>MaterialTheme()</code>. If you store all the colors inside <code>colors.xml</code>, you should create your palettes completely inside your theme composable.</p>
			<p>As you <a id="_idIndexMarker242"/>have seen, you may need to provide some values for resource-based themes, depending on how heavily you want to brand your app. Additionally, certain non-Compose Jetpack libraries use themes too, such as <em class="italic">Jetpack Core Splashscreen</em>. This component makes the advanced splash screen features of Android 12 available on older platforms. The images and colors of the splash screen are configured through theme attributes. The library requires that the theme of the starting activity has <code>Theme.SplashScreen</code> as its parent. Additionally, the theme must provide the <code>postSplashScreenTheme</code> attribute, which refers to the theme to use once the splash screen has been dismissed.You can find more information about <a id="_idIndexMarker243"/>splash screens on Android at <a href="https://developer.android.com/guide/topics/ui/splash-screen">https://developer.android.com/guide/topics/ui/splash-screen</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To ensure consistent use of colors, the <code>colors.xml</code> file should be the single point of truth in your app, if more than one component relies on resource-based themes.</p>
			<p>This concludes our look at Compose themes. In the next section, we will turn to an important integrational UI element called <code>Scaffold()</code> acts as a frame for your content, providing support for top and bottom bars, navigation, and actions.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor111"/>Integrating toolbars and menus</h1>
			<p>Early <a id="_idIndexMarker244"/>Android versions did not know about action or app bars. They were introduced with API level 11 (Honeycomb). The options menu, on the other hand, has been around since the beginning but was opened by pressing a dedicated hardware button and shown at the bottom of the screen. With Android 3, it moved to the top and became a vertical list. Some elements could be made available permanently as actions. In a way, the options menu and the action bar merged. While originally, all the aspects of the action bar were handled by the hosting activity, the <code>AppCompat</code> support library introduced an alternative implementation (<code>getSupportActionBar()</code>). It is still widely used today as part of Jetpack.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor112"/>Using Scaffold() to structure your screen</h2>
			<p>Jetpack Compose includes <a id="_idIndexMarker245"/>several app bar implementations that closely follow Material Design or Material You specifications. They <a id="_idIndexMarker246"/>can be added to a Compose UI through <code>Scaffold()</code>, a composable function that acts as an app frame or skeleton. The following code snippet is the root of the <code>ComposeUnitConverter</code> UI. It sets up the theme and then delegates it to <code>Scaffold()</code>:</p>
			<pre>@Composable
fun ComposeUnitConverter(factory: ViewModelFactory) {
  val navController = rememberNavController()
  val menuItems = listOf("Item #1", "Item #2")
  val scaffoldState = <strong class="bold">rememberScaffoldState()</strong>
  val snackbarCoroutineScope = <strong class="bold">rememberCoroutineScope()</strong>
  ComposeUnitConverterTheme {
    Scaffold(<strong class="bold">scaffoldState = scaffoldState</strong>,
      topBar = {
        ComposeUnitConverterTopBar(menuItems) { s -&gt;
          <strong class="bold">snackbarCoroutineScope.launch {</strong>
            scaffoldState.snackbarHostState.<strong class="bold">showSnackbar(</strong>s)
          }
        }
      },
      bottomBar = {
        ComposeUnitConverterBottomBar(navController)
      }
    ) {
      ComposeUnitConverterNavHost(
        navController = navController,
        factory = factory
      )
    }
  }
}</pre>
			<p><code>Scaffold()</code> implements the basic Material Design visual layout structure. You can add several other Material composables, such as <code>TopAppBar()</code> or <code>BottomNavigation()</code>. Google calls this <a id="_idIndexMarker247"/>a <code>Scaffold()</code> may need to remember different states. You can pass a <code>ScaffoldState</code>, which can be created with <code>rememberScaffoldState()</code>.</p>
			<p>My example uses <code>ScaffoldState</code> to show a snack bar, a brief temporary message that appears toward the bottom of the screen. As <code>showSnackbar()</code> is a suspending function, it must be called from a coroutine or another suspending function. Therefore, we must create and remember a <code>CoroutineScope</code> using <code>rememberCoroutineScope()</code> and invoke its <code>launch {}</code> function.</p>
			<p>In the next section, I will show you how to create a top app bar with an options menu.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor113"/>Creating a top app bar</h2>
			<p>App bars at<a id="_idIndexMarker250"/> the top of the screen are implemented using <code>TopAppBar()</code>. You can provide a navigation icon, a title, and a list of actions here:</p>
			<pre>@Composable
fun ComposeUnitConverterTopBar(menuItems: List&lt;String&gt;, 
                               onClick: (String) -&gt; Unit) {
  var menuOpened by remember { mutableStateOf(false) }
  TopAppBar(title = {
    Text(text = stringResource(id = R.string.app_name))
  },
    actions = {
      <strong class="bold">Box {</strong>
        <strong class="bold">IconButton(</strong>onClick = {
          menuOpened = true
        }) {
          Icon(Icons.Default.MoreVert, "")
        }
        <strong class="bold">DropdownMenu(</strong>expanded = menuOpened,
          onDismissRequest = {
            menuOpened = false
          }) {
          menuItems.forEachIndexed { index, s -&gt;
            if (index &gt; 0) Divider()
            <strong class="bold">DropdownMenuItem(</strong>onClick = {
              <strong class="bold">menuOpened = false</strong>
              onClick(s)
            }) {
              Text(s)
            }
          }
        }
      }
    }
  )
}</pre>
			<p><code>TopAppBar()</code> has no specific API for an options menu. Instead, the menu is treated as an ordinary action. Actions are typically <code>IconButton()</code> composables. They are displayed at the end of the app bar in a horizontal row. An <code>IconButton()</code> receives an <code>onClick</code> callback and an optional <code>enabled</code> parameter, which controls if the user can interact with the UI element.</p>
			<p>In my <a id="_idIndexMarker251"/>example, the callback only sets a <code>Boolean</code> mutable state (<code>menuOpened</code>) to <code>false</code>. As you will see shortly, this closes the menu. <code>content</code> (usually an icon) is drawn inside the button. The <code>Icon()</code> composable receives an instance of <code>ImageVector</code> and a content description. You can get icon data from the resources, but you should use predefined graphics if possible – in my example, <code>Icons.Default.MoreVert</code>. Next, let's learn how to display a menu.</p>
			<p>A Material Design drop-down menu (<code>DropdownMenu()</code>) allows you to display multiple choices compactly. It usually appears when you interact with another element, such as a button. My example places <code>DropdownMenu()</code> in a <code>Box()</code> with an <code>IconButton()</code>, which determines the location on-screen. The expanded parameter makes the menu visible (open) or invisible (closed). <code>onDismissRequest</code> is called when the user requests to dismiss the menu, such as by tapping outside the menu's bounds.</p>
			<p>The content should consist of <code>DropdownMenuItem()</code> composables. <code>onClick</code> is called when the corresponding menu item is clicked. Your code must make sure that the menu is closed. If possible, you should pass the domain logic to be executed as a parameter to make your code reusable and stateless. In my example, a snack bar is shown.</p>
			<p>This concludes our look at top app bars. In the next section, I will show you how to use <code>BottomNavigation()</code> to navigate to different screens using the Compose version of Jetpack Navigation.</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">To use the Compose version of Jetpack Navigation in your app, you must add an implementation dependency of <code>androidx.navigation:navigation-compose</code> to your module-level <code>build.gradle</code> file.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor114"/>Adding navigation</h1>
			<p><code>Scaffold()</code> allows you <a id="_idIndexMarker252"/>to put content in a slot at the bottom of the screen using its <code>bottomBar</code> parameter. This can, for example, be a <code>BottomAppBar()</code>. Material Design bottom app bars provide access to a bottom navigation drawer and up to four actions, including a floating action button. <code>ComposeUnitConverter</code> adds <code>BottomNavigation()</code> instead. Material Design bottom navigation bars allow movement between primary destinations in an app.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor115"/>Defining screens</h2>
			<p>Conceptually, primary <a id="_idIndexMarker253"/>destinations are <em class="italic">screens</em>, something that, before Jetpack Compose, may have been displayed in separate activities. Here's how screens are defined in <code>ComposeUnitConverter</code>:</p>
			<pre>sealed class ComposeUnitConverterScreen(
  val route: String,
  @StringRes val label: Int,
  @DrawableRes val icon: Int
) {
  companion object {
    val screens = listOf(
      Temperature,
      Distances
    )
    const val route_temperature = "temperature"
    const val route_distances = "distances"
  }
  private object Temperature : ComposeUnitConverterScreen(
    route_temperature,
    R.string.temperature,
    R.drawable.baseline_thermostat_24
  )
  private object Distances : ComposeUnitConverterScreen(
    route_distances,
    R.string.distances,
    R.drawable.baseline_square_foot_24
  )
}</pre>
			<p><code>ComposeUnitConverter</code> consists of two screens – <code>Temperature</code> and <code>Distances</code>. <code>route</code> uniquely identifies a screen. <code>label</code> and <code>icon</code> are shown to the user. Let's see <a id="_idIndexMarker254"/>how this is done:</p>
			<pre>@Composable
fun ComposeUnitConverterBottomBar(navController:
   NavHostController) {
  <strong class="bold">BottomNavigation {</strong>
    val navBackStackEntry by
          navController.currentBackStackEntryAsState()
    val currentDestination = navBackStackEntry?.destination
    ComposeUnitConverterScreen.screens.forEach { screen -&gt;
      <strong class="bold">BottomNavigationItem(</strong>
        <strong class="bold">selected</strong> = currentDestination?.hierarchy?.any {
          it.route == screen.route } == true,
        <strong class="bold">onClick</strong> = {
          navController.navigate(screen.route) {
            launchSingleTop = true
          }
        },
        <strong class="bold">label</strong> = {
          Text(text = stringResource(id = screen.label))
        },
        <strong class="bold">icon</strong> = {
          Icon(
            painter = painterResource(id = screen.icon),
            contentDescription = stringResource(id =
              screen.label)
          )
        },
        <strong class="bold">alwaysShowLabel</strong> = false
      )
    }
  }
}</pre>
			<p>The <a id="_idIndexMarker255"/>content of <code>BottomNavigation()</code> consists of <code>BottomNavigationItem()</code> items. Each item represents a <em class="italic">destination</em>. We can add them with a simple loop:</p>
			<pre>ComposeUnitConverterScreen.screens.forEach { screen -&gt;</pre>
			<p>As you can see, the <code>label</code> and <code>icon</code> properties of a <code>ComposeUnitConverterScreen</code> instance are used during the invocation of <code>BottomNavigationItem()</code>. <code>alwaysShowLabel</code> controls if the label is visible when an item is selected. An item will be selected if the corresponding screen is currently displayed. When a <code>BottomNavigationItem()</code> is clicked, its <code>onClick</code> callback is invoked. My implementation calls <code>navigate()</code> on the provided <code>NavHostController</code> instance, passing <code>route</code> from the corresponding <code>ComposeUnitConverterScreen</code> object.</p>
			<p>So far, we <a id="_idIndexMarker256"/>have defined screens and mapped them to <code>BottomNavigationItem()</code> items. When an item is clicked, the app navigates to a given route. But how do routes relate to composable functions? I will show you in the next section.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor116"/>Using NavHostController and NavHost()</h2>
			<p>An<a id="_idIndexMarker257"/> instance of <code>NavHostController</code> allows<a id="_idIndexMarker258"/> us to navigate to different screens by calling its <code>navigate()</code> function. We can obtain a reference to it inside <code>ComposeUnitConverter()</code> by invoking <code>rememberNavController()</code>, and then passing it to <code>ComposeUnitConverterBottomBar()</code>. The mapping between a route and a composable <a id="_idIndexMarker259"/>function is established through <code>NavHost()</code>. It <a id="_idIndexMarker260"/>belongs to the <code>androidx.navigation.compose</code> package. Here's how this composable is invoked:</p>
			<pre>@Composable
fun ComposeUnitConverterNavHost(
  navController: NavHostController,
  factory: ViewModelProvider.Factory?
) {
  NavHost(
    navController = navController,
    startDestination =
        ComposeUnitConverterScreen.route_temperature
  ) {
    composable(ComposeUnitConverterScreen.route_temperature) {
      Temperat<a id="_idTextAnchor117"/>ureConverter(
        viewModel = viewModel(factory = factory)
      )
    }
    composable(ComposeUnitConverterScreen.route_distances) {
      DistancesConverter(
        viewModel = viewModel(factory = factory)
      )
    }
  }
}</pre>
			<p><code>NavHost()</code> receives three parameters:</p>
			<ul>
				<li>A reference to our <code>NavHostController</code></li>
				<li>The route for the start destination</li>
				<li>The builder that was used to construct the navigation graph</li>
			</ul>
			<p>Before<a id="_idIndexMarker261"/> Jetpack Compose, the <a id="_idIndexMarker262"/>navigation graph was usually defined through an XML file. <code>NavGraphBuilder</code> provides access to a simple domain-specific language. <code>composable()</code> adds a composable function as a destination. Besides the route, you can pass a list of arguments and a list of deep links.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A detailed description <a id="_idIndexMarker263"/>of Jetpack Navigation is beyond the scope of this book. You can find more information at <a href="https://developer.android.com/guide/navigation">https://developer.android.com/guide/navigation</a>.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor118"/>Summary</h1>
			<p>This chapter showcased how key elements of Jetpack Compose work together in a real-world app. You learned how to theme Compose apps and how to keep your Compose theme in sync with resource-based themes.</p>
			<p>I also showed you how <code>Scaffold()</code> acts as an app frame or skeleton. We used its slot API to plug in a top app bar with a menu, as well as a bottom bar to navigate between screens using the Compose version of Jetpack Navigation.</p>
			<p>In the next chapter, <em class="italic">Tips, Tricks, and Best Practices</em>, we will discuss how to separate UI and business logic. We will revisit <code>ComposeUnitConverter</code>, this time focusing on its use of ViewModels.</p>
		</div>
	</div></body></html>