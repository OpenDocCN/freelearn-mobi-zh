<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer044">
			<h1 id="_idParaDest-81"><a id="_idTextAnchor105"/>Chapter 6: Putting Pieces Together</h1>
			<p>The previous chapters explored various aspects of Jetpack Compose. For example, <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, compared the traditional View system to composable functions and explained the benefits of the declarative approach. <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>,<em class="italic">Laying Out UI Elements</em>, gave you a solid understanding of some built-in layout composables such as <strong class="source-inline">Box()</strong>, <strong class="source-inline">Row()</strong>, and <strong class="source-inline">Column()</strong>. In <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>, we looked at state and learned about the important role it plays in a Compose app.</p>
			<p>Now, it's time to see how these key elements work together in a real-world app. In this chapter, you will learn how Compose apps can be themed. We will also look at <strong class="source-inline">Scaffold()</strong>, an integrational UI element that picks up quite a few concepts that were originally related to activities, such as toolbars and menus, and we will learn how to add screen-based navigation.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Styling a Compose app</li>
				<li>Integrating toolbars and menus</li>
				<li>Adding navigation</li>
			</ul>
			<p>We will start by setting up a custom theme for a Compose app. You can define quite a few colors, shapes, and text styles that the built-in Material composables will use when drawing themselves. I will also show you what to keep in mind when you're adding additional Jetpack components that rely on app themes, such as <em class="italic">Jetpack Core Splashscreen</em>.</p>
			<p>The following section, <em class="italic">Integrating toolbars and menus</em>, will introduce you to app bars and the options menu. You will also learn how to create snack bars.</p>
			<p>In the final main section, <em class="italic">Adding navigation</em>, I will show you how to structure your app into screens. We will use the Compose version of <em class="italic">Jetpack Navigation</em> to navigate between them.</p>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor106"/>Technical requirements</h1>
			<p>This chapter includes one sample app, <strong class="source-inline">ComposeUnitConverter</strong>, as shown in the following screenshot: </p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="Images/B17505_06_1.jpg" alt="Figure 6.1 – The ComposeUnitConverter app&#13;&#10;" width="796" height="916"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The ComposeUnitConverter app</p>
			<p>Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information about how to install and set up Android Studio, as well as how to get the repository that accompanies this book.</p>
			<p>All the code files for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_06</a>.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor107"/>Styling a Compose app</h1>
			<p>Most of your <a id="_idIndexMarker213"/>Compose UI will likely use the built-in composable functions from the <strong class="source-inline">androidx.compose.material</strong> package. They implement the design language known<a id="_idIndexMarker214"/> as <strong class="bold">Material Design</strong> and its successor, <strong class="bold">Material You</strong> (which was introduced with Android 12). Material You is the native design language <a id="_idIndexMarker215"/>on Android, though it will also be available on other platforms. It expands on the ideas of a pen, paper, and cards, and makes heavy use of grid-based layouts, responsive animations, and transitions, as well as padding and depth effects. Material You advocates larger buttons and rounded corners. Custom color themes can be generated from the user's wallpaper.</p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor108"/>Defining colors, shapes, and text styles</h2>
			<p>While <a id="_idIndexMarker216"/>apps should certainly honor both system and user preferences regarding visual appearance, you may want to add colors, shapes, or text styles<a id="_idIndexMarker217"/> that reflect your brand or corporate identity. So, how can you modify the look of the built-in Material composable functions?</p>
			<p>The main entry<a id="_idIndexMarker218"/> point to Material Theming is <strong class="source-inline">MaterialTheme()</strong>. This composable may receive custom colors, shapes, and text styles. If a value is not set, a corresponding default (<strong class="source-inline">MaterialTheme.colors</strong>, <strong class="source-inline">MaterialTheme.typography</strong>, or <strong class="source-inline">MaterialTheme.shapes</strong>) is used. The following theme sets custom colors but leaves the text styles and shapes as their defaults:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverterTheme(</p>
			<p class="source-code">  darkTheme: Boolean = isSystemInDarkTheme(),</p>
			<p class="source-code">  content: @Composable () -&gt; Unit</p>
			<p class="source-code">) {</p>
			<p class="source-code">  val colors = if (darkTheme) {</p>
			<p class="source-code">    DarkColorPalette</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    LightColorPalette</p>
			<p class="source-code">  }</p>
			<p class="source-code">  MaterialTheme(</p>
			<p class="source-code">    colors = colors,</p>
			<p class="source-code">    content = content</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">isSystemInDarkTheme()</strong> composable detects if the device is currently using a dark theme. Your app should use colors that suit this configuration. My example has two palettes, <strong class="source-inline">DarkColorPalette</strong> and <strong class="source-inline">LightColorPalette</strong>. Here's how the latter one is defined:</p>
			<p class="source-code">private val LightColorPalette = lightColors(</p>
			<p class="source-code">  primary = AndroidGreen,</p>
			<p class="source-code">  primaryVariant = AndroidGreenDark,</p>
			<p class="source-code">  secondary = Orange,</p>
			<p class="source-code">  secondaryVariant = OrangeDark</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">lightColors()</strong> is a top-level function inside the <strong class="source-inline">androidx.compose.material</strong> package. It provides a complete color definition for the Material color specification. You<a id="_idIndexMarker219"/> can find more<a id="_idIndexMarker220"/> information about this at <a href="https://material.io/design/color/the-color-system.html#color-theme-creation">https://material.io/design/color/the-color-system.html#color-theme-creation</a>. <strong class="source-inline">LightColorPalette</strong> overrides the default values for primary, <strong class="source-inline">primaryVariant</strong>, secondary, and <strong class="source-inline">secondaryVariant</strong>. All the others (there are, for example, <strong class="source-inline">background</strong>, <strong class="source-inline">surface</strong>, and <strong class="source-inline">onPrimary</strong>) remain unchanged.</p>
			<p><strong class="source-inline">primary</strong> will be <a id="_idIndexMarker221"/>displayed most frequently across your app's<a id="_idIndexMarker222"/> screens and components. With <strong class="source-inline">secondary</strong>, you can accent and distinguish your app. It is, for example, used for radio buttons. The checked thumb color of switches is <strong class="source-inline">secondaryVariant</strong>, whereas the unchecked thumb color is taken from <strong class="source-inline">surface</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Material composables typically receive their default colors from composable functions called <strong class="source-inline">colors()</strong>, which belong to their accompanying <strong class="source-inline">…Defaults</strong> objects. For example, <strong class="source-inline">Switch()</strong> invokes <strong class="source-inline">SwitchDefaults.colors()</strong> if no color parameter is passed to <strong class="source-inline">Switch()</strong>. By looking at these <strong class="source-inline">colors()</strong> functions, you can find out which color attribute you should set in your theme.</p>
			<p>You may be wondering how I defined, for example, <strong class="source-inline">AndroidGreen</strong>. The simplest way to achieve this is like this:</p>
			<p class="source-code">val AndroidGreen = Color(0xFF3DDC84)</p>
			<p>This works great if your app does not require other libraries or components that rely on the traditional Android theming system. We will turn to such scenarios in the <em class="italic">Using resource-based themes</em> section.</p>
			<p>Besides colors, <strong class="source-inline">MaterialTheme()</strong> allows you to provide alternative shapes. Shapes direct attention<a id="_idIndexMarker223"/> and communicate state. Material composables are <a id="_idIndexMarker224"/>grouped into shape categories <a id="_idIndexMarker225"/>based on their size:</p>
			<ul>
				<li>Small (buttons, snack bars, tooltips, and more)</li>
				<li>Medium (cards, dialog, menus, and more)</li>
				<li>Large (sheets and drawers, and more)</li>
			</ul>
			<p>To pass an alternative set of shapes to <strong class="source-inline">MaterialTheme()</strong>, you must instantiate <strong class="source-inline">androidx.compose.material.Shapes</strong> and provide implementations of the <strong class="source-inline">androidx.compose.foundation.shape.CornerBasedShape</strong> abstract class for the categories you want to modify (<strong class="source-inline">small</strong>, <strong class="source-inline">medium</strong>, and <strong class="source-inline">large</strong>). <strong class="source-inline">AbsoluteCutCornerShape</strong>, <strong class="source-inline">CutCornerShape</strong>, <strong class="source-inline">AbsoluteRoundedCornerShape</strong>, and <strong class="source-inline">RoundedCornerShape</strong> are direct subclasses of <strong class="source-inline">CornerBasedShape</strong>.</p>
			<p>The following screenshot shows a button with cut corners. While this makes the button look less familiar, it gives your app a distinctive look. You should, however, ensure that you want to add this:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="Images/B17505_06_2.jpg" alt="Figure 6.2 – A button with cut corners&#13;&#10;" width="437" height="183"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – A button with cut corners</p>
			<p>To achieve this, just add the following line when invoking <strong class="source-inline">MaterialTheme()</strong>:</p>
			<p class="source-code">shapes = Shapes(small = CutCornerShape(8.dp)),</p>
			<p>You can find <a id="_idIndexMarker226"/>more information about <a id="_idIndexMarker227"/>applying shapes to UIs at <a href="https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme">https://material.io/design/shape/applying-shape-to-ui.html#shape-scheme</a>.</p>
			<p>To alter <a id="_idIndexMarker228"/>the text styles that are used by Material composable functions, you <a id="_idIndexMarker229"/>need to pass an instance of <strong class="source-inline">androidx.compose.material.Typography</strong> to <strong class="source-inline">MaterialTheme()</strong>. <strong class="source-inline">Typography</strong> receives quite a few parameters, such as <strong class="source-inline">h1</strong>, <strong class="source-inline">subtitle1</strong>, <strong class="source-inline">body1</strong>, <strong class="source-inline">button</strong>, and <strong class="source-inline">caption</strong>. All of these are instances of <strong class="source-inline">androidx.compose.ui.text.TextStyle</strong>. If you do not pass a value for a parameter, a default is used.</p>
			<p>The following code block increases the text size of buttons:</p>
			<p class="source-code">typography = Typography(button = TextStyle(fontSize =</p>
			<p class="source-code">                                           24.sp)),</p>
			<p>If you add this line to the invocation of <strong class="source-inline">MaterialTheme()</strong>, the text of all the buttons using your theme will be 24 scale-independent pixels tall. But how do you set the theme? To make sure that your complete Compose UI uses it, you should invoke your theme as early as possible:</p>
			<p class="source-code">class ComposeUnitConverterActivity : ComponentActivity() {</p>
			<p class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">    super.onCreate(savedInstanceState)</p>
			<p class="source-code">    val factory = …</p>
			<p class="source-code">    setContent {</p>
			<p class="source-code">      ComposeUnitConverter(factory)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In my example, <strong class="source-inline">ComposeUnitConverter()</strong> is the root of the app's composable UI hierarchy since it is invoked inside <strong class="source-inline">setContent {}</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverter(factory: ViewModelFactory) {</p>
			<p class="source-code">  …</p>
			<p class="source-code">  ComposeUnitConverterTheme {</p>
			<p class="source-code">    Scaffold( ...</p>
			<p><strong class="source-inline">ComposeUnitConverter()</strong> immediately delegates to <strong class="source-inline">ComposeUnitConverterTheme {}</strong>, which receives the remaining UI as its content. <strong class="source-inline">Scaffold()</strong> is a skeleton for real-world Compose UIs. We will be taking a closer look at this in the <em class="italic">Integrating toolbars and menus</em> section.</p>
			<p>If you <a id="_idIndexMarker230"/>need to style parts of your app differently, you can <a id="_idIndexMarker231"/>nest themes <a id="_idIndexMarker232"/>by overriding your parent theme (<em class="italic">Figure 6.3</em>). Let's see how this works:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">@Preview</p>
			<p class="source-code">fun MaterialThemeDemo() {</p>
			<p class="source-code">  MaterialTheme(</p>
			<p class="source-code">    typography = Typography(</p>
			<p class="source-code">      h1 = TextStyle(color = Color.Red)</p>
			<p class="source-code">    )</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    Row {</p>
			<p class="source-code"><strong class="bold">      Text(</strong></p>
			<p class="source-code"><strong class="bold">        text"= "He"lo",</strong></p>
			<p class="source-code"><strong class="bold">        style = MaterialTheme.typography.h1</strong></p>
			<p class="source-code"><strong class="bold">      )</strong></p>
			<p class="source-code">      Spacer(modifier = Modifier.width(2.dp))</p>
			<p class="source-code">      MaterialTheme(</p>
			<p class="source-code">        typography = Typography(</p>
			<p class="source-code">          h1 = TextStyle(color = Color.Blue)</p>
			<p class="source-code">        )</p>
			<p class="source-code">      ) {</p>
			<p class="source-code"><strong class="bold">        Text(</strong></p>
			<p class="source-code"><strong class="bold">          text"= "Comp"se",</strong></p>
			<p class="source-code"><strong class="bold">          style = MaterialTheme.typography.h1</strong></p>
			<p class="source-code"><strong class="bold">        )</strong></p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding code snippet, the base theme configures any text that is styled as <strong class="source-inline">h1</strong> so that it appears<a id="_idIndexMarker233"/> in red. The second <strong class="source-inline">Text()</strong> uses a nested <a id="_idIndexMarker234"/>theme<a id="_idIndexMarker235"/> that styles <strong class="source-inline">h1</strong> to appear in blue. So, it overrides the parent theme:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="Images/B17505_06_3.jpg" alt="Figure 6.3 – Nesting themes&#13;&#10;" width="279" height="90"/>
				</div>
			</div>
			<p class="figure-caption">Figure <a id="_idTextAnchor109"/>6.3 – Nesting themes</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">All the parts of your app must have a consistent look. Consequently, you should use nested themes carefully.</p>
			<p>In the next section, we will continue exploring styles and themes. We will look at how themes are set in the manifest file, as well as how libraries may influence the way you define your Compose theme.</p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor110"/>Using resource-based themes</h2>
			<p>App styling <a id="_idIndexMarker236"/>or theming has been present on Android since API level 1. It is based on resource files. Conceptually, there is a distinction between styles and themes. A <strong class="bold">style</strong> is a <a id="_idIndexMarker237"/>collection of attributes that specify the appearance (for example, font color, font size, or background color) of a single View. Consequently, styles do not matter for composable functions. A <strong class="bold">theme</strong> is also a <a id="_idIndexMarker238"/>collection of attributes, but'it's applied to an entire app, activity, or View hierarchy. Many elements of a Compose app are provided by Material composables; for them, a resource-based theme does not matter either. However, themes can apply styles to non-View elements, such as the status bar and window background. This may be relevant for a Compose app.</p>
			<p>Styles and themes are declared in XML files inside the <strong class="source-inline">res/values</strong> directory and are typically named <strong class="source-inline">styles.xml</strong> and <strong class="source-inline">themes.xml</strong>, depending on the content. A theme is applied to the application or activity inside the manifest file with the <strong class="source-inline">android:theme</strong> attribute of the <strong class="source-inline">&lt;application /&gt;</strong> or <strong class="source-inline">&lt;activity /&gt;</strong> tag. If none of them receives a theme, <strong class="source-inline">ComposeUnitConverter</strong> will look as follows:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="Images/B17505_06_4.jpg" alt="Figure 6.4 – Compose Unit Converter showing an additional title bar&#13;&#10;" width="1254" height="651"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Compose Unit Converter showing an additional title bar</p>
			<p>To avoid <a id="_idIndexMarker239"/>the unwanted additional title bar, Compose apps must configure a theme without action bars, such as <strong class="source-inline">Theme.AppCompat.DayNight.NoActionBar</strong>, using <strong class="source-inline">android:the"e="@styl"/…"</strong> for <strong class="source-inline">&lt;application /&gt;</strong> or <strong class="source-inline">&lt;activity /&gt;</strong>. This way, <strong class="source-inline">ComposeUnitConverter</strong> looks like <em class="italic">Figure 6.1</em>. Have you noticed that the status bar has a dark gray background?</p>
			<p>When <strong class="source-inline">Theme.AppCompat.DayNight</strong> is used, the status bar receives its background color from the <strong class="source-inline">colorPrimaryDark</strong> theme attribute (or <strong class="source-inline">android:statusBarColor</strong> since API level 21). If no value is specified, a default is used. Therefore, to make sure that the status bar is shown in a color that fits the remaining UI elements, you must add a file named <strong class="source-inline">themes.xml</strong> to <strong class="source-inline">res/values</strong>:</p>
			<p class="source-code">&lt;resources&gt;</p>
			<p class="source-code">  &lt;style name="Theme.ComposeUnitConverter"</p>
			<p class="source-code">         parent="Theme.AppCompat.DayNight.NoActionBar"&gt;</p>
			<p class="source-code">    &lt;item</p>
			<p class="source-code">     name="colorPrimaryDark"&gt;@color/android_green_dark</p>
			<p class="source-code">    &lt;/item&gt;</p>
			<p class="source-code">  &lt;/style&gt;</p>
			<p class="source-code">&lt;/resources&gt;</p>
			<p>In the manifest file, the value of <strong class="source-inline">android:theme</strong> must then be changed to <strong class="source-inline">@style/Theme.ComposeUnitConverter</strong>. <strong class="source-inline">@color/android_green_dark</strong> represents<a id="_idIndexMarker240"/> the color. Instead of this expression, you could also pass the value directly; for example, <strong class="source-inline">#FF20B261</strong>. It is, however, best practice to store it in a file named <strong class="source-inline">colors.xml</strong> inside <strong class="source-inline">res/values</strong>:</p>
			<p class="source-code">&lt;resources&gt;</p>
			<p class="source-code">  &lt;color name="android_green_dark"&gt;#FF20B261&lt;/color&gt;</p>
			<p class="source-code">  &lt;color name="orange_dark"&gt;#FFCC8400&lt;/color&gt;</p>
			<p class="source-code">&lt;/resources&gt;</p>
			<p>This way, you can assign a different value for the Dark theme. The following version of <strong class="source-inline">themes.xml</strong> should be put in <strong class="source-inline">res/values-night</strong>:</p>
			<p class="source-code">&lt;resources&gt;</p>
			<p class="source-code">  &lt;style name="Theme.ComposeUnitConverter"</p>
			<p class="source-code">         parent="Theme.AppCompat.DayNight.NoActionBar"&gt;</p>
			<p class="source-code">    &lt;item name="colorPrimaryDark"&gt;@color/orange_dark&lt;/item&gt;</p>
			<p class="source-code">  &lt;/style&gt;</p>
			<p class="source-code">&lt;/resources&gt;</p>
			<p>The status bar now has a background color that fits the remaining UI elements. However, we need to define colors in two places: <strong class="source-inline">colors.xml</strong> and the Compose theme. Fortunately, this is rather easy to fix. Usually, we pass a literal, like this:</p>
			<p class="source-code">val AndroidGreenDark = Color(0xFF20B261)</p>
			<p>Instead of doing this, we should obtain the value from the resources. The <strong class="source-inline">colorResource()</strong> composable function belongs to the <strong class="source-inline">androidx.compose.ui.res</strong> package. It returns the color associated with a resource that's identified by an ID.</p>
			<p>The<a id="_idIndexMarker241"/> following palette does not specify a <strong class="source-inline">secondary</strong> color:</p>
			<p class="source-code">private val LightColorPalette = lightColors(</p>
			<p class="source-code">  primary = AndroidGreen,</p>
			<p class="source-code">  primaryVariant = AndroidGreenDark,</p>
			<p class="source-code">  secondaryVariant = OrangeDark</p>
			<p class="source-code">)</p>
			<p>Adding a color using <strong class="source-inline">colorResource()</strong> works as follows:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverterTheme(</p>
			<p class="source-code">  darkTheme: Boolean = isSystemInDarkTheme(),</p>
			<p class="source-code">  content: @Composable () -&gt; Unit</p>
			<p class="source-code">) {</p>
			<p class="source-code">  val colors = if (darkTheme) {</p>
			<p class="source-code">    DarkColorPalette</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    LightColorPalette.copy(secondary = colorResource(</p>
			<p class="source-code">      id = R.color.orange_dark))</p>
			<p class="source-code">  }</p>
			<p class="source-code">  MaterialTheme(</p>
			<p class="source-code">    colors = colors,</p>
			<p class="source-code">    …</p>
			<p>You saw most of this in the <em class="italic">Defining colors, shapes, and text styles</em> section. The important difference is that I created a modified version of <strong class="source-inline">LightColorPalette</strong> (with a secondary color) using <strong class="source-inline">copy()</strong>, which is then passed to <strong class="source-inline">MaterialTheme()</strong>. If you store all the colors inside <strong class="source-inline">colors.xml</strong>, you should create your palettes completely inside your theme composable.</p>
			<p>As you <a id="_idIndexMarker242"/>have seen, you may need to provide some values for resource-based themes, depending on how heavily you want to brand your app. Additionally, certain non-Compose Jetpack libraries use themes too, such as <em class="italic">Jetpack Core Splashscreen</em>. This component makes the advanced splash screen features of Android 12 available on older platforms. The images and colors of the splash screen are configured through theme attributes. The library requires that the theme of the starting activity has <strong class="source-inline">Theme.SplashScreen</strong> as its parent. Additionally, the theme must provide the <strong class="source-inline">postSplashScreenTheme</strong> attribute, which refers to the theme to use once the splash screen has been dismissed.You can find more information about <a id="_idIndexMarker243"/>splash screens on Android at <a href="https://developer.android.com/guide/topics/ui/splash-screen">https://developer.android.com/guide/topics/ui/splash-screen</a>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To ensure consistent use of colors, the <strong class="source-inline">colors.xml</strong> file should be the single point of truth in your app, if more than one component relies on resource-based themes.</p>
			<p>This concludes our look at Compose themes. In the next section, we will turn to an important integrational UI element called <strong class="bold">Scaffold</strong>. <strong class="source-inline">Scaffold()</strong> acts as a frame for your content, providing support for top and bottom bars, navigation, and actions.</p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor111"/>Integrating toolbars and menus</h1>
			<p>Early <a id="_idIndexMarker244"/>Android versions did not know about action or app bars. They were introduced with API level 11 (Honeycomb). The options menu, on the other hand, has been around since the beginning but was opened by pressing a dedicated hardware button and shown at the bottom of the screen. With Android 3, it moved to the top and became a vertical list. Some elements could be made available permanently as actions. In a way, the options menu and the action bar merged. While originally, all the aspects of the action bar were handled by the hosting activity, the <strong class="source-inline">AppCompat</strong> support library introduced an alternative implementation (<strong class="source-inline">getSupportActionBar()</strong>). It is still widely used today as part of Jetpack.</p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor112"/>Using Scaffold() to structure your screen</h2>
			<p>Jetpack Compose includes <a id="_idIndexMarker245"/>several app bar implementations that closely follow Material Design or Material You specifications. They <a id="_idIndexMarker246"/>can be added to a Compose UI through <strong class="source-inline">Scaffold()</strong>, a composable function that acts as an app frame or skeleton. The following code snippet is the root of the <strong class="source-inline">ComposeUnitConverter</strong> UI. It sets up the theme and then delegates it to <strong class="source-inline">Scaffold()</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverter(factory: ViewModelFactory) {</p>
			<p class="source-code">  val navController = rememberNavController()</p>
			<p class="source-code">  val menuItems = listOf("Item #1", "Item #2")</p>
			<p class="source-code">  val scaffoldState = <strong class="bold">rememberScaffoldState()</strong></p>
			<p class="source-code">  val snackbarCoroutineScope = <strong class="bold">rememberCoroutineScope()</strong></p>
			<p class="source-code">  ComposeUnitConverterTheme {</p>
			<p class="source-code">    Scaffold(<strong class="bold">scaffoldState = scaffoldState</strong>,</p>
			<p class="source-code">      topBar = {</p>
			<p class="source-code">        ComposeUnitConverterTopBar(menuItems) { s -&gt;</p>
			<p class="source-code">          <strong class="bold">snackbarCoroutineScope.launch {</strong></p>
			<p class="source-code">            scaffoldState.snackbarHostState.<strong class="bold">showSnackbar(</strong>s)</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      },</p>
			<p class="source-code">      bottomBar = {</p>
			<p class="source-code">        ComposeUnitConverterBottomBar(navController)</p>
			<p class="source-code">      }</p>
			<p class="source-code">    ) {</p>
			<p class="source-code">      ComposeUnitConverterNavHost(</p>
			<p class="source-code">        navController = navController,</p>
			<p class="source-code">        factory = factory</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Scaffold()</strong> implements the basic Material Design visual layout structure. You can add several other Material composables, such as <strong class="source-inline">TopAppBar()</strong> or <strong class="source-inline">BottomNavigation()</strong>. Google calls this <a id="_idIndexMarker247"/>a <strong class="bold">slot API</strong> because a composable function is customized by inserting another composable into an area or space (slot) of the parent. Passing an <a id="_idIndexMarker248"/>already configured child provides more flexibility than exposing (lots of) configuration<a id="_idIndexMarker249"/> parameters. Depending on which children you slot in, <strong class="source-inline">Scaffold()</strong> may need to remember different states. You can pass a <strong class="source-inline">ScaffoldState</strong>, which can be created with <strong class="source-inline">rememberScaffoldState()</strong>.</p>
			<p>My example uses <strong class="source-inline">ScaffoldState</strong> to show a snack bar, a brief temporary message that appears toward the bottom of the screen. As <strong class="source-inline">showSnackbar()</strong> is a suspending function, it must be called from a coroutine or another suspending function. Therefore, we must create and remember a <strong class="source-inline">CoroutineScope</strong> using <strong class="source-inline">rememberCoroutineScope()</strong> and invoke its <strong class="source-inline">launch {}</strong> function.</p>
			<p>In the next section, I will show you how to create a top app bar with an options menu.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor113"/>Creating a top app bar</h2>
			<p>App bars at<a id="_idIndexMarker250"/> the top of the screen are implemented using <strong class="source-inline">TopAppBar()</strong>. You can provide a navigation icon, a title, and a list of actions here:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverterTopBar(menuItems: List&lt;String&gt;, </p>
			<p class="source-code">                               onClick: (String) -&gt; Unit) {</p>
			<p class="source-code">  var menuOpened by remember { mutableStateOf(false) }</p>
			<p class="source-code">  TopAppBar(title = {</p>
			<p class="source-code">    Text(text = stringResource(id = R.string.app_name))</p>
			<p class="source-code">  },</p>
			<p class="source-code">    actions = {</p>
			<p class="source-code">      <strong class="bold">Box {</strong></p>
			<p class="source-code">        <strong class="bold">IconButton(</strong>onClick = {</p>
			<p class="source-code">          menuOpened = true</p>
			<p class="source-code">        }) {</p>
			<p class="source-code">          Icon(Icons.Default.MoreVert, "")</p>
			<p class="source-code">        }</p>
			<p class="source-code">        <strong class="bold">DropdownMenu(</strong>expanded = menuOpened,</p>
			<p class="source-code">          onDismissRequest = {</p>
			<p class="source-code">            menuOpened = false</p>
			<p class="source-code">          }) {</p>
			<p class="source-code">          menuItems.forEachIndexed { index, s -&gt;</p>
			<p class="source-code">            if (index &gt; 0) Divider()</p>
			<p class="source-code">            <strong class="bold">DropdownMenuItem(</strong>onClick = {</p>
			<p class="source-code">              <strong class="bold">menuOpened = false</strong></p>
			<p class="source-code">              onClick(s)</p>
			<p class="source-code">            }) {</p>
			<p class="source-code">              Text(s)</p>
			<p class="source-code">            }</p>
			<p class="source-code">          }</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">TopAppBar()</strong> has no specific API for an options menu. Instead, the menu is treated as an ordinary action. Actions are typically <strong class="source-inline">IconButton()</strong> composables. They are displayed at the end of the app bar in a horizontal row. An <strong class="source-inline">IconButton()</strong> receives an <strong class="source-inline">onClick</strong> callback and an optional <strong class="source-inline">enabled</strong> parameter, which controls if the user can interact with the UI element.</p>
			<p>In my <a id="_idIndexMarker251"/>example, the callback only sets a <strong class="source-inline">Boolean</strong> mutable state (<strong class="source-inline">menuOpened</strong>) to <strong class="source-inline">false</strong>. As you will see shortly, this closes the menu. <strong class="source-inline">content</strong> (usually an icon) is drawn inside the button. The <strong class="source-inline">Icon()</strong> composable receives an instance of <strong class="source-inline">ImageVector</strong> and a content description. You can get icon data from the resources, but you should use predefined graphics if possible – in my example, <strong class="source-inline">Icons.Default.MoreVert</strong>. Next, let's learn how to display a menu.</p>
			<p>A Material Design drop-down menu (<strong class="source-inline">DropdownMenu()</strong>) allows you to display multiple choices compactly. It usually appears when you interact with another element, such as a button. My example places <strong class="source-inline">DropdownMenu()</strong> in a <strong class="source-inline">Box()</strong> with an <strong class="source-inline">IconButton()</strong>, which determines the location on-screen. The expanded parameter makes the menu visible (open) or invisible (closed). <strong class="source-inline">onDismissRequest</strong> is called when the user requests to dismiss the menu, such as by tapping outside the menu's bounds.</p>
			<p>The content should consist of <strong class="source-inline">DropdownMenuItem()</strong> composables. <strong class="source-inline">onClick</strong> is called when the corresponding menu item is clicked. Your code must make sure that the menu is closed. If possible, you should pass the domain logic to be executed as a parameter to make your code reusable and stateless. In my example, a snack bar is shown.</p>
			<p>This concludes our look at top app bars. In the next section, I will show you how to use <strong class="source-inline">BottomNavigation()</strong> to navigate to different screens using the Compose version of Jetpack Navigation.</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">To use the Compose version of Jetpack Navigation in your app, you must add an implementation dependency of <strong class="source-inline">androidx.navigation:navigation-compose</strong> to your module-level <strong class="source-inline">build.gradle</strong> file.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor114"/>Adding navigation</h1>
			<p><strong class="source-inline">Scaffold()</strong> allows you <a id="_idIndexMarker252"/>to put content in a slot at the bottom of the screen using its <strong class="source-inline">bottomBar</strong> parameter. This can, for example, be a <strong class="source-inline">BottomAppBar()</strong>. Material Design bottom app bars provide access to a bottom navigation drawer and up to four actions, including a floating action button. <strong class="source-inline">ComposeUnitConverter</strong> adds <strong class="source-inline">BottomNavigation()</strong> instead. Material Design bottom navigation bars allow movement between primary destinations in an app.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor115"/>Defining screens</h2>
			<p>Conceptually, primary <a id="_idIndexMarker253"/>destinations are <em class="italic">screens</em>, something that, before Jetpack Compose, may have been displayed in separate activities. Here's how screens are defined in <strong class="source-inline">ComposeUnitConverter</strong>:</p>
			<p class="source-code">sealed class ComposeUnitConverterScreen(</p>
			<p class="source-code">  val route: String,</p>
			<p class="source-code">  @StringRes val label: Int,</p>
			<p class="source-code">  @DrawableRes val icon: Int</p>
			<p class="source-code">) {</p>
			<p class="source-code">  companion object {</p>
			<p class="source-code">    val screens = listOf(</p>
			<p class="source-code">      Temperature,</p>
			<p class="source-code">      Distances</p>
			<p class="source-code">    )</p>
			<p class="source-code">    const val route_temperature = "temperature"</p>
			<p class="source-code">    const val route_distances = "distances"</p>
			<p class="source-code">  }</p>
			<p class="source-code">  private object Temperature : ComposeUnitConverterScreen(</p>
			<p class="source-code">    route_temperature,</p>
			<p class="source-code">    R.string.temperature,</p>
			<p class="source-code">    R.drawable.baseline_thermostat_24</p>
			<p class="source-code">  )</p>
			<p class="source-code">  private object Distances : ComposeUnitConverterScreen(</p>
			<p class="source-code">    route_distances,</p>
			<p class="source-code">    R.string.distances,</p>
			<p class="source-code">    R.drawable.baseline_square_foot_24</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">ComposeUnitConverter</strong> consists of two screens – <strong class="source-inline">Temperature</strong> and <strong class="source-inline">Distances</strong>. <strong class="source-inline">route</strong> uniquely identifies a screen. <strong class="source-inline">label</strong> and <strong class="source-inline">icon</strong> are shown to the user. Let's see <a id="_idIndexMarker254"/>how this is done:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverterBottomBar(navController:</p>
			<p class="source-code">   NavHostController) {</p>
			<p class="source-code">  <strong class="bold">BottomNavigation {</strong></p>
			<p class="source-code">    val navBackStackEntry by</p>
			<p class="source-code">          navController.currentBackStackEntryAsState()</p>
			<p class="source-code">    val currentDestination = navBackStackEntry?.destination</p>
			<p class="source-code">    ComposeUnitConverterScreen.screens.forEach { screen -&gt;</p>
			<p class="source-code">      <strong class="bold">BottomNavigationItem(</strong></p>
			<p class="source-code">        <strong class="bold">selected</strong> = currentDestination?.hierarchy?.any {</p>
			<p class="source-code">          it.route == screen.route } == true,</p>
			<p class="source-code">        <strong class="bold">onClick</strong> = {</p>
			<p class="source-code">          navController.navigate(screen.route) {</p>
			<p class="source-code">            launchSingleTop = true</p>
			<p class="source-code">          }</p>
			<p class="source-code">        },</p>
			<p class="source-code">        <strong class="bold">label</strong> = {</p>
			<p class="source-code">          Text(text = stringResource(id = screen.label))</p>
			<p class="source-code">        },</p>
			<p class="source-code">        <strong class="bold">icon</strong> = {</p>
			<p class="source-code">          Icon(</p>
			<p class="source-code">            painter = painterResource(id = screen.icon),</p>
			<p class="source-code">            contentDescription = stringResource(id =</p>
			<p class="source-code">              screen.label)</p>
			<p class="source-code">          )</p>
			<p class="source-code">        },</p>
			<p class="source-code">        <strong class="bold">alwaysShowLabel</strong> = false</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <a id="_idIndexMarker255"/>content of <strong class="source-inline">BottomNavigation()</strong> consists of <strong class="source-inline">BottomNavigationItem()</strong> items. Each item represents a <em class="italic">destination</em>. We can add them with a simple loop:</p>
			<p class="source-code">ComposeUnitConverterScreen.screens.forEach { screen -&gt;</p>
			<p>As you can see, the <strong class="source-inline">label</strong> and <strong class="source-inline">icon</strong> properties of a <strong class="source-inline">ComposeUnitConverterScreen</strong> instance are used during the invocation of <strong class="source-inline">BottomNavigationItem()</strong>. <strong class="source-inline">alwaysShowLabel</strong> controls if the label is visible when an item is selected. An item will be selected if the corresponding screen is currently displayed. When a <strong class="source-inline">BottomNavigationItem()</strong> is clicked, its <strong class="source-inline">onClick</strong> callback is invoked. My implementation calls <strong class="source-inline">navigate()</strong> on the provided <strong class="source-inline">NavHostController</strong> instance, passing <strong class="source-inline">route</strong> from the corresponding <strong class="source-inline">ComposeUnitConverterScreen</strong> object.</p>
			<p>So far, we <a id="_idIndexMarker256"/>have defined screens and mapped them to <strong class="source-inline">BottomNavigationItem()</strong> items. When an item is clicked, the app navigates to a given route. But how do routes relate to composable functions? I will show you in the next section.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor116"/>Using NavHostController and NavHost()</h2>
			<p>An<a id="_idIndexMarker257"/> instance of <strong class="source-inline">NavHostController</strong> allows<a id="_idIndexMarker258"/> us to navigate to different screens by calling its <strong class="source-inline">navigate()</strong> function. We can obtain a reference to it inside <strong class="source-inline">ComposeUnitConverter()</strong> by invoking <strong class="source-inline">rememberNavController()</strong>, and then passing it to <strong class="source-inline">ComposeUnitConverterBottomBar()</strong>. The mapping between a route and a composable <a id="_idIndexMarker259"/>function is established through <strong class="source-inline">NavHost()</strong>. It <a id="_idIndexMarker260"/>belongs to the <strong class="source-inline">androidx.navigation.compose</strong> package. Here's how this composable is invoked:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ComposeUnitConverterNavHost(</p>
			<p class="source-code">  navController: NavHostController,</p>
			<p class="source-code">  factory: ViewModelProvider.Factory?</p>
			<p class="source-code">) {</p>
			<p class="source-code">  NavHost(</p>
			<p class="source-code">    navController = navController,</p>
			<p class="source-code">    startDestination =</p>
			<p class="source-code">        ComposeUnitConverterScreen.route_temperature</p>
			<p class="source-code">  ) {</p>
			<p class="source-code">    composable(ComposeUnitConverterScreen.route_temperature) {</p>
			<p class="source-code">      Temperat<a id="_idTextAnchor117"/>ureConverter(</p>
			<p class="source-code">        viewModel = viewModel(factory = factory)</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">    composable(ComposeUnitConverterScreen.route_distances) {</p>
			<p class="source-code">      DistancesConverter(</p>
			<p class="source-code">        viewModel = viewModel(factory = factory)</p>
			<p class="source-code">      )</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">NavHost()</strong> receives three parameters:</p>
			<ul>
				<li>A reference to our <strong class="source-inline">NavHostController</strong></li>
				<li>The route for the start destination</li>
				<li>The builder that was used to construct the navigation graph</li>
			</ul>
			<p>Before<a id="_idIndexMarker261"/> Jetpack Compose, the <a id="_idIndexMarker262"/>navigation graph was usually defined through an XML file. <strong class="source-inline">NavGraphBuilder</strong> provides access to a simple domain-specific language. <strong class="source-inline">composable()</strong> adds a composable function as a destination. Besides the route, you can pass a list of arguments and a list of deep links.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A detailed description <a id="_idIndexMarker263"/>of Jetpack Navigation is beyond the scope of this book. You can find more information at <a href="https://developer.android.com/guide/navigation">https://developer.android.com/guide/navigation</a>.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor118"/>Summary</h1>
			<p>This chapter showcased how key elements of Jetpack Compose work together in a real-world app. You learned how to theme Compose apps and how to keep your Compose theme in sync with resource-based themes.</p>
			<p>I also showed you how <strong class="source-inline">Scaffold()</strong> acts as an app frame or skeleton. We used its slot API to plug in a top app bar with a menu, as well as a bottom bar to navigate between screens using the Compose version of Jetpack Navigation.</p>
			<p>In the next chapter, <em class="italic">Tips, Tricks, and Best Practices</em>, we will discuss how to separate UI and business logic. We will revisit <strong class="source-inline">ComposeUnitConverter</strong>, this time focusing on its use of ViewModels.</p>
		</div>
	</div></body></html>