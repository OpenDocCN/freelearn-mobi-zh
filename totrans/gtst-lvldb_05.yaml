- en: Chapter 5. Using Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've seen, the native C++ interface of LevelDB is fairly simple. However,
    most OS X and iOS programmers want to be able to use their familiar `NSData` and
    `NSString` data types with a database. The use of **blocks** is steadily increasing
    in Cocoa APIs, as a way to apply small pieces of logic to collections of data.
    Some people also have a strong aversion to using C++ and will avoid anything that
    lacks an Objective-C interface.
  prefs: []
  type: TYPE_NORMAL
- en: Open source wrappers for LevelDB in Objective-C
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three significant Objective-C wrappers for LevelDB, all started in
    2011 when it was announced. They are the top hits and links if searching for Objective-C
    LevelDB.
  prefs: []
  type: TYPE_NORMAL
- en: Two come with their own projects to build a library or framework, but as of
    June 2013, these didn't work with Xcode 4.6 or higher. These two include a valuable
    suite of unit tests in each but not examples for iOS. Their relative popularity
    is hard to judge.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of trying to fix their builds, our downloadable `Sample05` has OS X
    and iOS projects with all three wrappers' source included and a common set of
    tests. It uses the LevelDB libraries we created earlier. This approach of copying
    the wrapper classes is more likely to survive changes in Xcode and lets you debug
    by stepping into source.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sample05` is a very important sample to explore the code in its entirety as
    it includes demo code in Objective-C of all the data updating and iteration concepts
    we have seen so far, rewritten from C++ for each of the three wrappers. This lets
    you see the stylistic differences side-by-side. The code samples in this chapter
    use all three, for contrast.'
  prefs: []
  type: TYPE_NORMAL
- en: '**LevelDB-ObjC**, from [https://github.com/hoisie/LevelDB-ObjC](https://github.com/hoisie/LevelDB-ObjC),
    was the earliest and simplest wrapper, providing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A way to call the basic `Put`, `Get`, and `Delete` operations with `NSString`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing objects and dictionaries or arrays of objects using `NSKeyedArchiver`
    to encode them into the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iteration through all keys with a block that can stop the iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**APLevelDB** from [https://github.com/preble/APLevelDB](https://github.com/preble/APLevelDB)
    is partly based on LevelDB-ObjC, trying to be a cleaner Objective-C wrapper, and:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adds separate iterators and direct array-like access with subscripting: `db[@"key"]
    = @"value"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds `WriteBatch` support as a separate protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleanly separates out different concepts into different protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rather than burying an encoding implementation, gets and sets `NSData` so you
    can do your own encoding and pass it via `NSData*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NuLevelDB**, from [https://github.com/nulayer/NULevelDB](https://github.com/nulayer/NULevelDB),
    is a very ambitious layer with many classes, featuring the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSData` is used for keys as well as values, making it easy to compose complex
    keys, as well as the `NSString` keys and values like the others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate optimized 64 bit integer keys and a lot of enumerate (iteration) methods
    for ranges and arbitrary sets of integer keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consistent use of the `NSError**` parameters to get errors back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy copying an entire database or a specific list of keys, to/from `NSDictionary`
    and `NSArray`, in the file `NULDBDB+BulkAccess.m`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its own `NULDBSerializable` protocol for exploding an object into a set of individual
    key/value pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the following listed issues may not be issues for everyone. Remember
    these wrappers are open source and easy to extend, if you lack a feature. The
    following are the most serious issues with the different wrappers, or points most
    likely to dissuade you from using a particular one. I found APLevelDB easier to
    extend with minor changes. The issues are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: LevelDB-ObjC and NuLevelDB are not ARC-compliant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LevelDB-ObjC exposes the `leveldb/db.h` header so you have to make any files
    using it into `.mm` Objective-C++ source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LevelDB-ObjC and APLevelDB's iteration methods lack any way to specify ranges
    so you lose most of the power of LevelDB. Their blocks can end the iteration but
    you can't start from a given key or part-key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NuLevelDB has a very rich iteration support but ignores any database's custom
    comparator and uses just the LevelDB's `BytewiseComparator` class method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of them expose the full read and write options of LevelDB. NuLevelDB is
    best with properties for write `sync` and read `fill_cache`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**ARC** (**Automatic Reference Counting**) was introduced in OS X Lion and
    iOS 5 and by now is used in most new Objective-C code. However, much older source
    has not been converted to ARC. To use non-ARC source files in an ARC project,
    use the **Build Phases** tab, **Compile Sources** section, and add the flag `–fno-objc-arc`
    on each file as needed. You will know this is necessary because of an **ARC Restrictions**
    compiler error.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Objective-C for simple data access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core data creation, finding and deleting we saw in [Chapter 3](ch03.html
    "Chapter 3. Basic Key-value Operations – Creating and Deleting Data"), *Basic
    Key-value Operations–Creating and Deleting Data*, looks like this with the LevelDB-ObjC
    wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a database object and open a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Check to be sure a key doesn''t exist, and then add a couple of records, checking
    that the `Packt` key works but lowercase `packt` still fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Write an existing key again, changing its value, and check to make sure that
    it has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compose a key with an embedded null, using a different way to create an `NSString`
    object from arbitrary characters, and prove we can read it back by that key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete a record and check to be sure it can no longer be read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can print out all the keys that were just added, like `Sample04`, but will
    use a block to stop after the first three records. A typical use of a block is
    to process data from a collection, either just the keys or both keys and values.
    Most of the iterators using blocks also allow the block to stop iteration by returning
    `NO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Extending APLevelDB to expose the C++ API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to add our own extensions to APLevelDB or the other wrappers, the
    internal `leveldb::DB*` has to be exposed. Just getting that pointer is enough
    to be able use all the C++ logic we saw in earlier chapters. This requires a minor
    change to `APLevelDB.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly declare a return type for `getDB` which can be safely included in pure
    Objective-C so we don''t force people to move to Objective-C++ with `.mm` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then inside `@interface APLevelDB : NSObject` add a public getter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simply implemented in `ApLevelDB.mm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add a **class category** to extend `APLevelDB` with other methods.
    Just one is shown here. We declare a method taking a prefix string and applying
    a block to the keys which match that prefix, passing a `BOOL` parameter so the
    block can stop enumerating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That's a simple example of how being able to get the database pointer allows
    writing some Objective-C++ code to add methods to APLevelDB. A similar technique
    can be used to extend the other frameworks. It also shows how Objective-C++ allows
    us to mix languages. The method `enumerateKeysWithPrefix:block` is an extension
    to APLevelDB with a pure Objective-C interface. It takes a block which can be
    pure Objective-C. The bits of C++ are the call to `NewIterator` and loop through
    the records calling the block. However, you could also just pass the `leveldb::DB*`
    to pure C++ .
  prefs: []
  type: TYPE_NORMAL
- en: Importing text data to load a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following function shows a complete loop for importing a tab-delimited
    text file and generating records using the APLevelDB database. The `Sample500.txt`
    file is bundled with both the OS X and iOS projects. We use a little helper function
    in `main06ios.m` or `main06osx.m`, to find the data file relative to the application.
    This finds a file bundled into an app package of Cocoa iOS or OS X app, a common
    way to include demos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Command-line OS X tools such as `Sample05` don''t automatically bundle files.
    To get the sample copied relative to the app, it was added to the **Build Phases**
    tab''s **Copy Files** setting the relative path `./SampleData` as used in the
    helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the function void `testAPLevelDBImportStrings` in its entirety. Open
    the text file, reading it into a single string then splitting into an array of
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a database, using another helper function `pathToSampleDB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In one `WriteBatch`, for speed and safety, loop through the array of lines,
    separating each at a tab and writing two records per line. The first key is a
    combination of last and first name and contains a JSON-encoded array. The second
    record is keyed by the phone number field and its value is the first key, so it''s
    like a secondary index. This is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses Apple''s standard `NSJSONSerialization` to pack a record, which does
    simple quoting to store an array as a string, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To unpack the record, we get the data back with `dataForKey` and then recreate
    an array with the method `JSONObjectWithData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This approach can serialize dictionaries and arrays of simple types such as
    `NSString`, including nested arrays and dictionaries. If your data is mostly text,
    it is reasonably compact and efficient. Using other variants of `NSCoder` lets
    you store and recreate your own objects, but you have to write overrides for encoding
    and decoding methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick look at the Objective-C wrappers for LevelDB showed us how they are
    used for the same tasks we mastered in C++. You also learned a general technique
    for loading text data bundled with your app. The text data loader showed a new
    way to encode the data values for a key and build a secondary index of phone numbers.
    We will now move on to putting a Cocoa user interface on top of this to see the
    data in something more exciting than a console output window.
  prefs: []
  type: TYPE_NORMAL
