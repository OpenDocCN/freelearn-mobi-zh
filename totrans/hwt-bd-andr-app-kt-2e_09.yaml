- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building User Interfaces Using Jetpack Compose
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jetpack Compose 构建用户界面
- en: In this section, you will learn how to use Jetpack Compose to create user interfaces
    using Kotlin code, how Compose revolutionized the way we built user interfaces,
    and how we can translate existing applications to Jetpack Compose. By the end
    of the chapter, you will be familiar with the most common UI elements in Compose
    and how to handle user actions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 Kotlin 代码通过 Jetpack Compose 创建用户界面，了解 Compose 如何革命性地改变我们构建用户界面的方式，以及如何将现有应用程序转换为
    Jetpack Compose。到本章结束时，你将熟悉 Compose 中最常见的 UI 元素以及如何处理用户操作。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is Jetpack Compose?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Jetpack Compose？
- en: Handling user actions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户操作
- en: Theming in Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose 中的主题
- en: Adding Compose to existing projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Compose 添加到现有项目中
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/kb5FW](https://packt.link/kb5FW)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在 GitHub 上找到，网址为 [https://packt.link/kb5FW](https://packt.link/kb5FW)
- en: What is Jetpack Compose?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Jetpack Compose？
- en: In past chapters, you learned how to set data into the Android View hierarchy
    and learned how to use different types of views for different purposes. That approach
    to user interface building is referred to as the **imperative approach**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何将数据设置到 Android 视图层次结构中，以及如何使用不同类型的视图来实现不同的目的。这种用户界面构建方法被称为 **命令式方法**。
- en: In the imperative approach, when we want to change the state of the user interface,
    we will need to manually change each user interface element until we reach the
    desired outcome.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式方法中，当我们想要改变用户界面的状态时，我们需要手动更改每个用户界面元素，直到达到我们期望的结果。
- en: Let’s assume that because of a user action, we want our `TextView` to change
    the text and text color. This means that we would need to invoke `setText` and
    `setTextColor` to achieve our desired effect.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设由于用户操作，我们希望我们的 `TextView` 改变文本和文本颜色。这意味着我们需要调用 `setText` 和 `setTextColor`
    来实现我们期望的效果。
- en: As an alternative to the imperative approach, we have the **declarative approach**,
    in which we would need to describe the final state that we want our user interface
    to reach, and internally, the required invocations would be performed.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 作为命令式方法的替代，我们有 **声明式方法**，其中我们需要描述我们希望用户界面达到的最终状态，然后内部执行所需的调用。
- en: 'This means that our `TextView` would instead have the text and text color as
    attributes, and we could define different objects holding the states we want.
    In Jetpack Compose, this would look like the following example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的 `TextView` 将具有文本和文本颜色作为属性，我们可以定义不同的对象来保存我们想要的状态。在 Jetpack Compose 中，这看起来就像以下示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, we define a `@Composable` function that will display
    a `Text` element. The values for `text` and `color` would be held in a separate
    data class that will represent the state of the text.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个将显示 `Text` 元素的 `@Composable` 函数。`text` 和 `color` 的值将保存在一个单独的数据类中，该数据类将代表文本的状态。
- en: This mechanism allows Jetpack Compose to redraw the user interface for any change
    that occurs in `MyState`. This process is called `@Composable` functions that
    had a change.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制允许 Jetpack Compose 在 `MyState` 发生任何变化时重新绘制用户界面。这个过程被称为 `@Composable` 函数发生了变化。
- en: 'If we want to create a new screen in Compose, we have the choice of `Row` or
    `Column` functions to arrange elements. For vertical arrangement, we can use `Column`,
    and for horizontal alignment, we use `Row`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 Compose 中创建一个新的屏幕，我们可以选择使用 `Row` 或 `Column` 函数来排列元素。对于垂直排列，我们可以使用 `Column`，而对于水平对齐，我们使用
    `Row`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding example, using `Column`, we show different user interface
    elements above each other:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用 `Column`，我们展示了不同的用户界面元素是上下排列的：
- en: '`Text` will show a simple label with the `My Static Text` label as `text`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text` 将显示一个简单的标签，其中 `My Static Text` 标签作为 `text`。'
- en: '`TextField` will show an input field that’s pre-filled with the `My Text Field`
    text through the `value` parameter. The `onValueChange` lambda will pick up any
    text that the user inserts.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField` 将显示一个输入字段，该字段通过 `value` 参数预先填充了 `My Text Field` 文本。`onValueChange`
    lambda 将捕获用户插入的任何文本。'
- en: '`Button` will show a button, and through the `onClick` lambda, we can pick
    up the click events on it.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button` 将显示一个按钮，通过 `onClick` lambda，我们可以捕获其上的点击事件。'
- en: '`Icon` will display a particular icon from the `drawable` or `mipmap` folders
    and will have a content description set from the string resources.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Icon` 将显示来自 `drawable` 或 `mipmap` 文件夹的特定图标，并将从字符串资源设置内容描述。'
- en: 'If we want to display lists of items, we can use the following approach when
    the number of items is known and small enough to fit on the screen of the device:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想显示项目列表，当项目数量已知且足够小，可以适应设备屏幕时，我们可以使用以下方法：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we iterate over each item in the list and show a
    `Text` for each item. If the number of items is unknown and large enough to require
    scrolling, then we would run into performance issues because the recomposition
    would go over both visible and not visible items. For this scenario, we could
    use the following approach:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们遍历列表中的每个项目，并为每个项目显示一个 `Text`。如果项目的数量未知且足够大，需要滚动，那么我们就会遇到性能问题，因为重组会覆盖可见和不可见的项目。对于这种情况，我们可以使用以下方法：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we are using a `LazyColumn` function and wrapping our collection with
    the `items` function. We are also able to add static items as a header and footer
    of the list through the `item` function. Like `Column`, we can use `LazyRow` to
    display a list of items with a horizontal scroll.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `LazyColumn` 函数，并用 `items` 函数包裹我们的集合。我们还可以通过 `item` 函数添加静态项作为列表的头部和尾部。像
    `Column` 一样，我们可以使用 `LazyRow` 来显示具有水平滚动的项目列表。
- en: 'If we want to add spacings between the UI elements, then `Modifiers` become
    useful:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在 UI 元素之间添加间距，那么 `Modifiers` 就变得很有用：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding example, we’ve added `16.dp` padding to the entire column
    of items in all directions. If we wanted different paddings in different directions,
    we would’ve had something like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在所有方向上为所有项目的整个列添加了 `16.dp` 的内边距。如果我们想在不同方向上使用不同的内边距，我们会得到以下类似的内容：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding example, we’ve set `5.dp` vertical padding and `10.dp` horizontal
    padding. Because the values are repeated, we can instead use the following approach:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们设置了 `5.dp` 的垂直内边距和 `10.dp` 的水平内边距。因为值是重复的，我们可以使用以下方法：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we’ve used the `vertical` and `horizontal` parameters to set the vertical
    and horizontal paddings. If we want to make the row clickable, then we can use
    the following modifier:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用了 `vertical` 和 `horizontal` 参数来设置垂直和水平内边距。如果我们想使行可点击，则可以使用以下修饰符：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we’ve used the `clickable` method from `Modifier`.
    This will register a click listener on the entire `Column`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `Modifier` 的 `clickable` 方法。这将在整个 `Column` 上注册一个点击监听器。
- en: 'When it comes to the relationship between Activities and Fragments and screens
    built in Compose, we have the following extensions for Compose:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 Activity 和 Fragment 以及在 Compose 中构建的屏幕之间的关系时，我们有以下 Compose 扩展：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding example, we have the `setContent` extension function defined
    for `ComponentActivity`, which will set a `@Composable` function as the content
    for an `Activity`. The same is true for Fragments; however, when starting a new
    project, the current recommendation is to have a single Activity and make all
    your additional screens separate `@``Composable` functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为 `ComponentActivity` 定义了 `setContent` 扩展函数，该函数将 `@Composable` 函数设置为
    `Activity` 的内容。对于片段也是如此；然而，在启动新项目时，当前的推荐是只有一个 `Activity`，并将所有额外的屏幕作为单独的 `@``Composable`
    函数。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Android Studio, we have the possibility of having previews of our `@Composable`
    functions with the `@``Preview` annotation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中，我们有使用 `@``Preview` 注解预览我们的 `@Composable` 函数的可能性。
- en: Exercise 9.01 – first Compose screen
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.01 – 第一个 Compose 屏幕
- en: 'Create an Android application that has one screen defined using `@Composable`
    functions. The screen should have the following elements:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个使用 `@Composable` 函数定义的单屏幕 Android 应用程序。屏幕应包含以下元素：
- en: '`Text`, which will say `"Enter` `a number"`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Text`，将显示 `"Enter` `a number"`'
- en: '`TextField`, which will only accept integers'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextField`，将只接受整数'
- en: '`Button`, which has the text `"``Click Me"`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`，其文本为 `"``Click Me"`'
- en: '`LazyColumn`, which will display a list of 100 items with the following format
    for each row: `"``Item c"`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LazyColumn`，将显示一个包含 100 个项目的列表，每个行的格式如下：`"``Item c"`'
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: Create a new Android Studio project and select **Empty** **Compose Activity**.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Android Studio 项目并选择 **Empty** **Compose Activity**。
- en: 'Add the following to `strings.xml` in the `res/values` folder:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `res/values` 文件夹中的 `strings.xml`：
- en: '[PRE9]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Define the user interface of the exercise:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义练习的用户界面：
- en: '[PRE10]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have chosen to place everything inside the `LazyColumn` block. This will
    make the entire content scrollable, including `Text`, `TextField`, and `Button`,
    and not just the list of items.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择将所有内容放置在`LazyColumn`块中。这将使整个内容可滚动，包括`Text`、`TextField`和`Button`，而不仅仅是项目列表。
- en: To make the keyboard only accept numeric input, we have used the `keyboardOptions`
    parameter of the `TextField` function. For `Button`, to add text to it, we needed
    to use the content parameter of the function and place a new `Text` inside the
    lambda.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使键盘只接受数字输入，我们使用了`TextField`函数的`keyboardOptions`参数。对于`Button`，为了向其添加文本，我们需要使用函数的内容参数，并在lambda中放置一个新的`Text`。
- en: 'Finally, modify the `MainActivity` code to use the function we’ve just defined:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改`MainActivity`代码以使用我们刚刚定义的函数：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we generate a new list of items that will say `"Item [count]"` and invoke
    the `@Composable` function, `MyScreen`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们生成一个新列表的项目，它们将显示为`"Item [count]"`，并调用`@Composable`函数`MyScreen`。
- en: 'If we run the preceding example, we will see the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的示例，我们将看到以下输出：
- en: '![Figure 9.1 – Output of Exercise 9.01](img/B19411_09_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 练习9.01的输出](img/B19411_09_01.jpg)'
- en: Figure 9.1 – Output of Exercise 9.01
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 练习9.01的输出
- en: We can see in the preceding figure that the screen was built according to the
    exercise specifications. One thing to note is the fact that we aren’t allowed
    to input any text in the input field. This is because we have set the value of
    `TextField` to an empty string. We will look at how we can properly handle this
    aspect in further sections of the book.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到，屏幕是根据练习规范构建的。需要注意的是，我们不允许在输入字段中输入任何文本。这是因为我们将`TextField`的值设置为空字符串。我们将在本书的后续章节中探讨如何正确处理这一方面。
- en: In this section, we have looked at how we can use Jetpack Compose to build user
    interfaces in a simple way without the involvement of other languages and syntaxes
    such as Kotlin. Next, we will continue the exploration of Compose and how we can
    handle user actions and manage states.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用Jetpack Compose以简单的方式构建用户界面，而不涉及其他语言和语法，如Kotlin。接下来，我们将继续探索Compose，以及我们如何处理用户操作和管理状态。
- en: Handling user actions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户操作
- en: In the previous section, we learned how to build user interfaces using Jetpack
    Compose. In the exercise, we were unable to collect the data that the user sets
    in `TextField`. In this section, we will learn how to handle the user input as
    well as the state of the user interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用Jetpack Compose构建用户界面。在练习中，我们无法收集用户在`TextField`中设置的数据。在本节中，我们将学习如何处理用户输入以及用户界面的状态。
- en: 'Let’s assume we have the following example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下示例：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, we define a `TextField` that is empty and has no handling for
    the change of the value. As we’ve seen, this won’t let us introduce any new input
    from the keyboard because it will always set the text to an empty string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个空白的`TextField`，没有处理值的变化。正如我们所看到的，这不会让我们从键盘引入任何新的输入，因为它总是会将文本设置为空字符串。
- en: 'For us to be able to introduce a new text, we will need to create a mutable
    variable to store the text inside and for it to survive recomposition. In Jetpack
    Compose, we can use the `@Composable` function called `remember` to define a `MutableState`
    that will hold our text:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入新的文本，我们需要创建一个可变变量来存储文本，并确保它在重新组合中存活。在Jetpack Compose中，我们可以使用名为`@Composable`的函数`remember`来定义一个`MutableState`，它将保存我们的文本：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, we define a mutable variable called `text`, which
    we then set in `TextField`. The `text` variable is initialized through the `remember`
    function, which will hold a `MutableState` that has the initial value set to an
    empty string. This still isn’t complete; we will now need to connect the state
    with the change in value for `TextField`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个名为`text`的可变变量，并将其设置在`TextField`中。`text`变量通过`remember`函数初始化，它将保存一个`MutableState`，其初始值设置为空字符串。这还不是完整的；我们现在需要将状态与`TextField`值的变化连接起来：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we modify the `onValueChange` lambda to change the `text` state with the
    latest text that the user inserted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了`onValueChange`的lambda表达式，以便使用用户插入的最新文本来改变`text`状态。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can use the `rememberSaveable` function to instead retain the value of objects
    across configuration changes such as Activity recreation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`rememberSaveable`函数来保留对象在配置更改（如Activity重建）之间的值。
- en: 'When dealing with states, we tend to turn `@Composable` functions from being
    stateless (doesn’t manage a state) to stateful (manages one or more states). As
    a guideline, we should try to keep our functions as stateless as possible through
    a pattern called `@Composable` function. This would turn the preceding example
    into the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理状态时，我们倾向于将 `@Composable` 函数从无状态（不管理状态）转换为有状态（管理一个或多个状态）。作为一个指导原则，我们应该尽量通过名为
    `@Composable` 函数的模式保持我们的函数尽可能无状态。这将使前面的例子变成以下形式：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we’ve split our functions in two. The `MyScreen` function
    will manage the state of the text and invoke the `MyScreenContent` function, which
    is now stateless. This approach introduces multiple benefits such as the *reusability*
    of our stateless functions, *decoupled* state management, and *a single source
    of truth* for our state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将我们的函数分成了两部分。`MyScreen` 函数将管理文本状态并调用 `MyScreenContent` 函数，该函数现在是无状态的。这种方法引入了多个好处，如我们无状态函数的
    *可重用性*、*解耦* 状态管理和 *单一事实来源*。
- en: Note
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When you use the Jetpack Compose State and `MutableState` objects, you might
    need to manually import the following two methods for getting and setting a state:
    `androidx.compose.runtime.getValue` and `androidx.compose.runtime.setValue`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Jetpack Compose 状态和 `MutableState` 对象时，你可能需要手动导入以下两个用于获取和设置状态的方法：`androidx.compose.runtime.getValue`
    和 `androidx.compose.runtime.setValue`。
- en: 'When dealing with states in Jetpack Compose, when a change occurs in a state,
    then the recomposition process is triggered. This might cause problems when we
    want to show one-off events such as `Snackbar` and `Toast`. To achieve this, we
    can use `LaunchedEffect`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 Jetpack Compose 中的状态时，当状态发生变化时，会触发重新组合过程。这可能会在我们想要显示一次性事件，如 `Snackbar` 和
    `Toast` 时引起问题。为了实现这一点，我们可以使用 `LaunchedEffect`：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding example will show a `Toast` message every time `anObjectToChange`
    takes on a different value. If we replace `anObjectToChange` with `Unit`, then
    the `LaunchedEffect` block will be executed only once.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子会在 `anObjectToChange` 每次取不同值时显示一个 `Toast` 消息。如果我们用 `Unit` 替换 `anObjectToChange`，那么
    `LaunchedEffect` 块将只执行一次。
- en: Exercise 9.02 – handling user inputs
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.02 – 处理用户输入
- en: Modify *Exercise 9.01 – first Compose screen* such that when the user introduces
    a number in `TextField` and clicks the button, then a list of items as big as
    the number introduced will be generated and the list below the button will be
    populated with them. The text will be the same for each item as before.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *练习 9.01 – 第一个 Compose 屏幕*，使得当用户在 `TextField` 中输入一个数字并点击按钮时，将生成一个与输入数字大小相同的项目列表，并将它们填充在按钮下面的列表中。每个项目的文本将与之前相同。
- en: To represent the state of the user interface, a data class will be created that
    will hold the number of items, with `0` as a default, and the list of items, which
    will be empty by default.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示用户界面的状态，将创建一个数据类来保存项目数量，默认为 `0`，以及项目列表，默认为空。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Create the `MyScreenState` data class, which will hold the state of the user
    interface:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `MyScreenState` 数据类，它将保存用户界面的状态：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the `@Composable` method called `MyScreenContent`, which will have `MyScreenState`
    as a parameter and render the state:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MyScreenContent` 的 `@Composable` 方法，它将 `MyScreenState` 作为参数并渲染状态：
- en: '[PRE18]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding example, we set `itemCount` from `myScreenState` in our `TextField`
    and `items` from `myScreenState` as items in the list. We’ve also added our text
    change listener and button listener as parameters to the function, making it stateless.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在 `TextField` 中设置了 `myScreenState` 的 `itemCount`，并将 `myScreenState`
    的 `items` 作为列表中的项目。我们还添加了文本更改监听器和按钮监听器作为函数的参数，使其变为无状态。
- en: 'Modify the `MyScreen` function such that it will call `MyScreenContent` and
    handle the listener for the text change and for the button click:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `MyScreen` 函数，使其调用 `MyScreenContent` 并处理文本更改和按钮点击的监听器：
- en: '[PRE19]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are creating a new `MutableState` that will hold `MyScreenState` with
    its defaults. We will then invoke `MyScreenContent` in which we pass the state.
    When the text changes, we set the state to be the copy of the existing state with
    the new text, and when the button is clicked, we generate a new list of items
    up until the current `itemCount` and update the state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的 `MutableState`，它将保存具有默认值的 `MyScreenState`。然后我们将调用 `MyScreenContent`
    并传递状态。当文本更改时，我们将状态设置为现有状态的副本，并带有新文本，当按钮被点击时，我们将生成一个新项目列表，直到当前的 `itemCount` 并更新状态。
- en: 'Update the `MainActivity` class to invoke the `MyScreen` function without any
    parameters:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`MainActivity`类以调用不带任何参数的`MyScreen`函数：
- en: '[PRE20]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we run the exercise and insert a number, then we should see the following
    screen:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行练习并插入一个数字，那么我们应该看到以下屏幕：
- en: '![Figure 9.2 – Output of Exercise 9.02](img/B19411_09_02.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 练习9.02的输出](img/B19411_09_02.jpg)'
- en: Figure 9.2 – Output of Exercise 9.02
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 练习9.02的输出
- en: When the app is first launched, we should see the `TextField` empty and no elements
    in the list below the button. When a number is set, then the state is changed
    to reflect the new text, and when the button is clicked, then the list of items
    is displayed with the size being that of the inserted number.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序首次启动时，我们应该看到`TextField`为空，并且按钮下没有元素。当设置一个数字时，状态将改变以反映新的文本，当点击按钮时，将显示包含插入数字大小的项目列表。
- en: In this section, we have looked at how we can handle user input, keep it in
    a state, and manage that state across recomposition. In the section that follows,
    we will look at how we can further decorate our user interface elements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何处理用户输入，保持其状态，并在重新组合中管理该状态。在接下来的章节中，我们将探讨如何进一步装饰我们的用户界面元素。
- en: Theming in Compose
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Compose中的主题化
- en: In the previous section, we learned how to handle user actions and how to manage
    the state of a particular screen. But how do we keep our application’s user interface
    elements consistent across the entire application? In this section, we will look
    at how we can create reusable elements that are linked to the application’s theme.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何处理用户操作以及如何管理特定屏幕的状态。但我们是如何保持应用程序的用户界面元素在整个应用程序中的一致性呢？在本节中，我们将探讨如何创建与应用程序主题相关联的可重用元素。
- en: 'You may have noticed, when you carried out the previous exercises, that Android
    Studio created some files in a `ui.theme` package. This is because Jetpack Compose
    is built upon the Material Design library and will assign a theme to your application
    that is built on Material Design. The approach taken is the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在执行前面的练习时，Android Studio在`ui.theme`包中创建了一些文件。这是因为Jetpack Compose建立在Material
    Design库之上，并将为您的应用程序分配一个基于Material Design的主题。所采用的方法如下：
- en: 'In the `Color.kt` file, all the colors of the application are declared:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Color.kt`文件中，声明了应用程序的所有颜色：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, we have the color hexadecimal names.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有颜色十六进制名称。
- en: 'In `Shape.kt`, the following code is generated:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Shape.kt`文件中，生成了以下代码：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will indicate what the size of the icons you use in the application should
    be.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示您在应用程序中使用的图标的大小。
- en: 'In `Type.kt`, the following code is generated:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Type.kt`文件中，生成了以下代码：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will represent how the text in your application is rendered. The `Typography`
    class holds configurations for how your headings, subtitles, paragraphs, buttons,
    and captions text should be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表示您的应用程序中文本是如何渲染的。`Typography`类包含有关标题、副标题、段落、按钮和标题文本应如何配置的设置。
- en: 'In the `Theme.kt` file, we have two color palettes defined:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Theme.kt`文件中，定义了两个颜色调色板：
- en: '[PRE24]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, there’s a light and dark color palette defined and the `primary`, `primaryVariant`,
    and `secondary` colors are set. The rest of the colors in the `lightColors` and
    `darkColors` functions will remain with their default values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义了浅色和深色颜色调色板，并设置了`primary`、`primaryVariant`和`secondary`颜色。`lightColors`和`darkColors`函数中的其余颜色将保留其默认值。
- en: 'In the same file, the application’s theme is generated:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，生成应用程序的主题：
- en: '[PRE25]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, a check will be made to see whether the device has light or dark mode
    enabled and use the appropriate set of colors for each mode. It will also set
    the typography you configured and how the shapes in your application should be.
    Just because it is set in the theme, that doesn’t mean that our user interface
    elements will automatically inherit it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将检查设备是否启用了浅色或深色模式，并为每种模式使用适当的颜色集。它还将设置您配置的字体样式以及应用程序中形状的样式。尽管它已在主题中设置，但这并不意味着我们的用户界面元素会自动继承它。
- en: 'When the `MainActivity` class is generated, it will have the following structure:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当生成`MainActivity`类时，它将具有以下结构：
- en: '[PRE26]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: When `setContent` is called, then your application’s theme will be called, and
    the `Surface` function will set your application’s background.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`setContent`时，您的应用程序主题将被调用，并且`Surface`函数将设置应用程序的背景。
- en: 'We can now use the preceding setup as a starting point to define a theme for
    our application and start to create reusable user interface components. Let’s
    assume we want all the paragraphs in the application to use the same typography
    and have the same color; in this case, we will use `MaterialTheme.typography.body1`
    and `MaterialTheme.colors.onBackground`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将前面的设置作为起点来定义应用程序的主题，并开始创建可重用的用户界面组件。假设我们希望应用程序中的所有段落都使用相同的排版和颜色；在这种情况下，我们将使用
    `MaterialTheme.typography.body1` 和 `MaterialTheme.colors.onBackground`：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, we’ve defined the `ParagraphText` function, which
    will set the style and color of the text from `MaterialTheme`. We might now have
    a problem if we want the same style and a different text color, where we need
    to duplicate the style attribute for each. Another solution is to create two functions
    – one for the style and the other on top of it for the color:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了 `ParagraphText` 函数，该函数将设置从 `MaterialTheme` 来的文本样式和颜色。如果我们想使用相同的样式和不同的文本颜色，可能需要为每个样式属性重复，这时我们可能遇到问题。另一个解决方案是创建两个函数——一个用于样式，另一个用于其上的颜色：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding example, we’ve moved the color to be a parameter in the `ParagraphText`
    function and then created a new function called `OnBackgroundParagraphText`, which
    allows us to set `MaterialTheme.colors.onBackground` to the `Text` defined in
    `ParagraphText`. If we want to use our new function, then we can do the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将颜色移动到 `ParagraphText` 函数的参数中，然后创建了一个名为 `OnBackgroundParagraphText`
    的新函数，这使得我们可以将 `MaterialTheme.colors.onBackground` 设置为在 `ParagraphText` 中定义的 `Text`。如果我们想使用我们的新函数，我们可以这样做：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is a simple function call, just like using the `Text` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数调用，就像使用 `Text` 函数一样。
- en: 'Now, let’s assume we are using this text across our entire application and
    the application goes through a redesign where instead of using `MaterialTheme.typography.body1`,
    we need to use `MaterialTheme.typography.body2`, and the text color needs to be
    red. In this case, we would then modify the `ParagraphText` function as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们正在将此文本应用于整个应用程序，并且应用程序经历了一次重新设计，其中不再使用 `MaterialTheme.typography.body1`，而是需要使用
    `MaterialTheme.typography.body2`，并且文本颜色需要是红色。在这种情况下，我们将修改 `ParagraphText` 函数如下：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we have changed the style of the `Text` function to use `MaterialTheme.typography.body2`.
    To change the color, we could modify `OnBackgroundParagraphText`, but the color
    currently used is recommended to be used on top of the current background, so
    we could also change the value of `MaterialTheme.colors.onBackground`. For this,
    we could go into `Theme.kt` and do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `Text` 函数的样式更改为使用 `MaterialTheme.typography.body2`。要更改颜色，我们可以修改 `OnBackgroundParagraphText`，但当前使用的颜色建议用于当前背景之上，因此我们也可以更改
    `MaterialTheme.colors.onBackground` 的值。为此，我们可以进入 `Theme.kt` 并执行以下操作：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we changed the value of `onBackground` to red, which will impact all the
    user interface elements that reference `onBackground`. We can now see how we can
    easily apply this across all the user interface elements in the application without
    touching the code where those elements are used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 `onBackground` 的值更改为红色，这将影响所有引用 `onBackground` 的用户界面元素。我们现在可以看到如何轻松地将此应用于应用程序中的所有用户界面元素，而无需触及使用这些元素的地方的代码。
- en: 'If we want to have multiple screens in our application, we can connect Compose
    with the `navigation` library, which is available here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在应用程序中拥有多个屏幕，我们可以将 Compose 与 `navigation` 库连接起来，该库在此处可用：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let’s now assume we have two screens defined in Jetpack Compose:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们在 Jetpack Compose 中定义了两个屏幕：
- en: '[PRE33]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Screen1` will display one button and `Screen2` has two inputs that will be
    displayed. We now want to connect the screens so that when the button is clicked
    on `Screen1`, `Screen2` opens with two hardcoded inputs passed. This would look
    like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`Screen1` 将显示一个按钮，而 `Screen2` 有两个输入将被显示。我们现在想连接这两个屏幕，以便当在 `Screen1` 上点击按钮时，`Screen2`
    会打开，并传递两个硬编码的输入。这看起来如下所示：'
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have defined a new `@Composable` function called `MyApp`, which uses `NavHost`
    to keep all the screens in the application. `NavHost` will open `Screen1` as a
    default through the `screen1` URL. In the `onButtonClick` lambda from `Screen1`,
    we navigate to `Screen2` and we pass the `input1` and `input2` strings.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新的 `@Composable` 函数 `MyApp`，它使用 `NavHost` 来保持应用程序中的所有屏幕。`NavHost` 将通过
    `screen1` URL 默认打开 `Screen1`。在 `Screen1` 的 `onButtonClick` lambda 中，我们导航到 `Screen2`
    并传递 `input1` 和 `input2` 字符串。
- en: This is done through the `screen2/{input1}?input2={input2}` URL. This is also
    how we will pass arguments between the two screens, through either the path parameter
    (`input1`) or the argument (`input2`). For each input, we will need to specify
    that we will be expecting a string as a type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过`screen2/{input1}?input2={input2}` URL完成的。这也是我们在两个屏幕之间传递参数的方式，无论是通过路径参数（`input1`）还是通过参数（`input2`）。对于每个输入，我们需要指定我们期望的是一个字符串类型。
- en: '`Screen2` will then be opened, and the input extracted through the `it` variable,
    which is a `NavBackStackEntry` type. We can call this function from the `setContent`
    method of the Activity:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将打开`Screen2`，并通过`it`变量提取输入，`it`是一个`NavBackStackEntry`类型。我们可以从Activity的`setContent`方法中调用此函数：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we hoist the state of `NavHostController` and then call the `MyApp` function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提升`NavHostController`的状态，然后调用`MyApp`函数。
- en: Exercise 9.03 – applying themes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9.03 – 应用主题
- en: Modify *Exercise 9.02 – handling user inputs* such that `MyScreen`, `MyScreenContent`,
    and `MyScreenState` are split into two screens, with `ItemCountScreen`, `ItemCountScreenContent`,
    and `ItemCountScreenState` on one side, which will hold `Text`, `TextField`, and
    `Button`, and `ItemScreen`, `ItemScreenContent`, and `ItemScreenState` on the
    other, which will hold the item list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*练习9.02 – 处理用户输入*，以便将`MyScreen`、`MyScreenContent`和`MyScreenState`拆分为两个屏幕，其中`ItemCountScreen`、`ItemCountScreenContent`和`ItemCountScreenState`在一侧，将包含`Text`、`TextField`和`Button`，而`ItemScreen`、`ItemScreenContent`和`ItemScreenState`在另一侧，将包含项目列表。
- en: The two screens will be saved in `ItemCountScreen.kt` and `ItemScreen.kt` files.
    `ItemCountScreen` will be shown first, and when the button is clicked, then `ItemScreen`
    is shown with the number of items set in the previous screen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 两个屏幕将被保存在`ItemCountScreen.kt`和`ItemScreen.kt`文件中。`ItemCountScreen`将首先显示，当按钮被点击时，然后显示`ItemScreen`，并在上一个屏幕中设置项目数量。
- en: 'New functions will also be created to represent `Text` used across the application:
    one for the `"Enter a number"` text, which will be `MaterialTheme.typography.h5`;
    the `"Click Me"` text will be `MaterialTheme.typography.button`; and `"Item [count]"`
    will be `MaterialTheme.typography.body1`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 还将创建新的函数来表示应用程序中使用的`Text`：一个用于`"Enter a number"`文本，它将是`MaterialTheme.typography.h5`；`"Click
    Me"`文本将是`MaterialTheme.typography.button`；而`"Item [count]"`将是`MaterialTheme.typography.body1`。
- en: The colors will be set to `MaterialTheme.colors.onBackground` for the text,
    and `Color.red` for the button text.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 文本的颜色将设置为`MaterialTheme.colors.onBackground`，按钮文本的颜色为`Color.red`。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'In the `app/build.gradle` file, add the `navigation` library dependency:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`文件中，添加`navigation`库依赖项：
- en: '[PRE36]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `ui.theme` package, create a Kotlin file called `Elements`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ui.theme`包中，创建一个名为`Elements`的Kotlin文件。
- en: 'In the `Elements.kt` file, add the functions for the title text on the first
    screen:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Elements.kt`文件中，添加第一屏幕上标题文本的函数：
- en: '[PRE37]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the same file, add the functions for the `"Item [``count]"` text:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加`"Item [``count]"`文本的函数：
- en: '[PRE38]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the same file, add the functions for the button text:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，添加按钮文本的函数：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this example, as the button sets the color for the content in a different
    way, we had to use `contentColor` from the `ButtonColors` class.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于按钮以不同的方式设置内容的颜色，我们不得不使用`ButtonColors`类中的`contentColor`。
- en: Create a new Kotlin file called `ItemCountScreen`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ItemCountScreen`的新Kotlin文件。
- en: 'In this file, create a new class called `ItemCountScreenState`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，创建一个名为`ItemCountScreenState`的新类：
- en: '[PRE40]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the same file, create a new function called `ItemCountScreenContent`, which
    will hold the newly created `OnBackgroundTitleText` and `PrimaryTextButton` functions:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，创建一个名为`ItemCountScreenContent`的新函数，该函数将包含新创建的`OnBackgroundTitleText`和`PrimaryTextButton`函数：
- en: '[PRE41]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the same file, create a new function called `ItemCountScreen`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，创建一个名为`ItemCountScreen`的新函数：
- en: '[PRE42]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Create a new Kotlin file called `ItemScreen`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ItemScreen`的新Kotlin文件。
- en: 'In that file, create a new class called `ItemScreenState`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中，创建一个名为`ItemScreenState`的新类：
- en: '[PRE43]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the same file, create a new function called `ItemScreenContent`, which will
    use `OnBackgroundItemText`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，创建一个名为`ItemScreenContent`的新函数，该函数将使用`OnBackgroundItemText`：
- en: '[PRE44]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the same file, create a new function called `ItemScreen`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，创建一个名为`ItemScreen`的新函数：
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `MainActivity` file, create the `MyApp` function, which will manage
    our two screens defined previously:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`文件中，创建`MyApp`函数，该函数将管理之前定义的两个屏幕：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, modify the `setContent` function so that `MyApp` will be called:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改`setContent`函数，以便调用`MyApp`：
- en: '[PRE47]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we run the application, we should see the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们应该看到以下输出：
- en: '![Figure 9.3 – Output of Exercise 9.03](img/B19411_09_03.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 练习 9.03 的输出](img/B19411_09_03.jpg)'
- en: Figure 9.3 – Output of Exercise 9.03
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 练习 9.03 的输出
- en: We should be able to see the screens split in two, and on entering a number
    in one screen, we should transition to the other screen with a generated list
    of items. We should also see the newly defined styles for the `Text` functions.
    We should be able to control these styles only from the `Elements` class and cause
    no modifications to the screens themselves.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够看到屏幕被分成两部分，并且在在一个屏幕中输入一个数字后，我们应该过渡到另一个屏幕，并显示一个生成的项目列表。我们还应该看到为 `Text`
    函数新定义的样式。我们只能从 `Elements` 类中控制这些样式，而不会对屏幕本身进行任何修改。
- en: In this section, we have learned how to apply theming to an application and
    how we can create multiple screens and navigate between them using Jetpack Compose.
    In the section that follows, we will look at how we can integrate Compose into
    an existing project and how well it can be integrated with other popular libraries.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何将主题应用到应用程序中，以及我们如何使用 Jetpack Compose 创建多个屏幕并在它们之间导航。在下一节中，我们将探讨如何将
    Compose 集成到现有项目中，以及它如何与其他流行的库集成。
- en: Adding Compose to existing projects
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Compose 添加到现有项目
- en: In this section, we will look at what options we have in terms of introducing
    Jetpack Compose into an existing Android application and how to get Compose to
    work with different libraries.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨将 Jetpack Compose 引入现有 Android 应用程序的各种选项，以及如何使 Compose 与不同的库一起工作。
- en: When using Jetpack Compose, you should ideally have a small number of activities,
    or one if possible, and have all your screens built using Compose. For an existing
    project to be able to achieve this, it would need to start at the bottom of the
    `View` hierarchy, meaning that your existing views should start being migrated
    to be built in Compose.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Jetpack Compose 时，理想情况下应该有少量活动，如果可能的话，只有一个，并且所有屏幕都使用 Compose 构建。为了使现有项目能够实现这一点，它需要从
    `View` 层级的底部开始，这意味着你的现有视图应该开始迁移到使用 Compose 构建。
- en: 'To facilitate this transition, Jetpack Compose offers the possibility of using
    `ComposeView` in your XML layout, as in the following example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便这种过渡，Jetpack Compose 提供了在 XML 布局中使用 `ComposeView` 的可能性，如下例所示：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we have an existing layout that will need to include a view that was
    defined using Jetpack Compose. In the layout XML file, we can put a `ComposeView`
    placeholder of where our view would live, and then in the Kotlin code, we can
    include the Compose user interface element:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个现有的布局，它需要包含一个使用 Jetpack Compose 定义的视图。在布局 XML 文件中，我们可以在我们的视图将存在的位置放置一个
    `ComposeView` 占位符，然后在 Kotlin 代码中，我们可以包含 Compose 用户界面元素：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this example, `Fragment` inflates the XML layout, looks up `ComposeView`,
    and marks the Compose content to be destroyed when the `View` of `Fragment` is
    also destroyed to prevent any leaks, and then sets the content of `ComposeView`
    to be `Text`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Fragment` 展示了 XML 布局，查找 `ComposeView`，并标记当 `Fragment` 的 `View` 被销毁时，Compose
    内容也应该被销毁，以防止任何泄漏，然后设置 `ComposeView` 的内容为 `Text`。
- en: 'When we want to go the opposite route and add Android views into the Compose
    code, then we have the option of using `AndroidView`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要走相反的路，将 Android 视图添加到 Compose 代码中时，我们有使用 `AndroidView` 的选项：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this example, we have defined a new `@Composable` function called `MyCustomisedElement`,
    which will invoke `AndroidView`, which in turn will create a `TextView` on which
    it will set the text we have defined as a parameter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个新的 `@Composable` 函数，名为 `MyCustomisedElement`，它将调用 `AndroidView`，然后创建一个
    `TextView`，并将我们定义的文本作为参数设置到该文本视图上。
- en: As we’ve seen in previous sections, we can use `LocalContext.current` to obtain
    a `Context` reference. This allows us to perform actions such as starting activities
    and services and showing `Toasts`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，我们可以使用 `LocalContext.current` 来获取 `Context` 引用。这允许我们执行启动活动、服务以及显示
    `Toasts` 等操作。
- en: 'Compose is also able to interact with other libraries that are useful when
    building Android applications. We will analyze these libraries in the chapters
    that follow, but now, we will look at how they work with Jetpack Compose:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 还能够与其他在构建 Android 应用程序时有用的库进行交互。我们将在接下来的章节中分析这些库，但现在，我们将看看它们是如何与 Jetpack
    Compose 一起工作的：
- en: 'The `ViewModel` library is useful for keeping data across configuration changes
    in our Activities and Fragments and helps to make our code more testable. Compose
    can obtain references to `ViewModel` objects through the `@Composable` function
    called `viewModel`:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`库对于在Activity和Fragment的配置更改中保持数据很有用，并有助于使我们的代码更容易测试。Compose可以通过名为`@Composable`的函数`viewModel`获取`ViewModel`对象的引用：'
- en: '[PRE51]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we call `viewModel` to obtain a reference to `MyViewModel` and set `Text`
    with the value that `viewModel` was holding.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`viewModel`来获取`MyViewModel`的引用，并使用`viewModel`持有的值设置`Text`。
- en: Data stream libraries are useful in combination with the `ViewModel` library,
    as when we want to load data asynchronously from the internet or the local filesystem,
    we will need to notify the user interface that the data was loaded.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流库与`ViewModel`库结合使用很有用，因为我们想要从互联网或本地文件系统异步加载数据时，需要通知用户界面数据已加载。
- en: 'Common data stream libraries are LiveData, RxJava, and Coroutines and Flows.
    We’ve seen that Compose uses a `State` object when we want to manage the state
    of the user interface. For each of the three libraries, Compose provides extension
    libraries in which a stream of data is converted into a `State` object:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的数据流库有LiveData、RxJava和Coroutines和Flows。我们已看到，当我们要管理用户界面的状态时，Compose使用`State`对象。对于这三个库，Compose提供了扩展库，将数据流转换为`State`对象：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, our `viewModel` object would have each of the data streams
    that would hold a string. For each of the streams, Compose calls the equivalent
    method to subscribe and monitor for changes in the value of the string. When a
    new value is emitted for each stream, then Compose sets it in the `Text`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的`viewModel`对象将包含每个数据流，这些数据流将保存一个字符串。对于每个流，Compose调用等效的方法来订阅并监控字符串值的更改。当每个流发出新的值时，Compose将其设置在`Text`中。
- en: 'Hilt is a dependency injection library designed for Android app development.
    If the `navigation` library is not present in the project, then using the `viewModel`
    function described previously should be enough to obtain a reference to your `ViewModel`;
    however, if the `navigation` library is present, then a library that makes `hilt`
    and `navigation` work together also needs to be included:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hilt是一个为Android应用开发设计的依赖注入库。如果项目中没有`navigation`库，那么使用前面描述的`viewModel`函数就足够获取到`ViewModel`的引用；然而，如果`navigation`库存在，那么还需要包含一个使`hilt`和`navigation`协同工作的库：
- en: '[PRE53]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To obtain references to `ViewModel` objects in the Compose code, we will need
    to replace the invocation to `viewModel` with an invocation to `hiltViewModel`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Compose代码中获取`ViewModel`对象的引用，我们需要将`viewModel`的调用替换为`hiltViewModel`的调用。
- en: 'You can find more information about integrating Jetpack Compose into your Android
    application at [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose),
    and about compatibility with other libraries here: [https://developer.android.com/jetpack/compose/libraries](https://developer.android.com/jetpack/compose/libraries).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose)找到有关将Jetpack
    Compose集成到你的Android应用程序中的更多信息，以及与其他库的兼容性信息：[https://developer.android.com/jetpack/compose/libraries](https://developer.android.com/jetpack/compose/libraries)。
- en: In this section, we have looked at how we can integrate the Jetpack Compose
    library and make it work with existing `View` objects and existing libraries in
    the project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何集成Jetpack Compose库，使其与项目中的现有`View`对象和现有库协同工作。
- en: Activity 9.01 – first Compose app
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第9.01节 – 第一个Compose应用
- en: 'Create a new app using Jetpack Compose, which will have three screens:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jetpack Compose创建一个新的应用，它将包含三个屏幕：
- en: The **insert rows** screen will have a title, a text field, and a button where
    a number can be inserted. When the button is clicked, then the user navigates
    to the next screen.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入行**屏幕将有一个标题、一个文本字段和一个按钮，可以在其中插入一个数字。当按钮被点击时，用户将导航到下一个屏幕。'
- en: The **insert columns** screen will have a title, a text field where a number
    can be inserted, and a button. When the button is clicked, then the user navigates
    to the next screen.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入列**屏幕将有一个标题、一个可以插入数字的文本字段和一个按钮。当按钮被点击时，用户将导航到下一个屏幕。'
- en: A grid screen will display a grid with the number of rows and the number of
    columns inserted above. Each row will independently scroll using `LazyRow`, and
    for the columns, `LazyColumn` will be used. Each grid item will display the text
    `"``Item [row][column]"`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格屏幕将显示一个网格，其行数和列数将插入在上方。每一行将独立使用 `LazyRow` 进行滚动，而对于列，将使用 `LazyColumn`。每个网格项将显示文本
    `"Item [row][column]"`。
- en: The first two screens will have their user interface elements using the same
    styling for the titles, text fields, and buttons, and the third screen will have
    a style for displaying the text in the grid.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个屏幕将使用相同的样式来显示标题、文本字段和按钮，而第三个屏幕将有一个用于显示网格中文本的样式。
- en: 'To complete this activity, you need to take the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此活动，您需要执行以下步骤：
- en: Create a new Android Studio project using an empty Compose Activity.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用空 Compose Activity 创建一个新的 Android Studio 项目。
- en: Add the `navigation` library dependency to the `app/build.gradle` file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `navigation` 库依赖项添加到 `app/build.gradle` 文件中。
- en: In the `ui.theme` package, create a new Kotlin file called `Elements`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ui.theme` 包中，创建一个名为 `Elements` 的新 Kotlin 文件。
- en: In that file, create `@Composable` functions for the titles used in the application.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中，为应用中使用的标题创建 `@Composable` 函数。
- en: In the same file, create `@Composable` functions for the text fields used in
    the application.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，为应用中使用的文本字段创建 `@Composable` 函数。
- en: In the same file, create `@Composable` functions for the grid items.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，为网格项创建 `@Composable` 函数。
- en: In the same file, create `@Composable` functions for the buttons.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，为按钮创建 `@Composable` 函数。
- en: Create a new Kotlin file called `InsertRowsScreen`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InsertRowsScreen` 的新 Kotlin 文件。
- en: Create `InsertRowsScreenState`, `InsertRowsScreenContent`, and `InsertRowsScreen`,
    which will be responsible for holding the screen state and the screen content
    and for managing the screen state.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `InsertRowsScreenState`、`InsertRowsScreenContent` 和 `InsertRowsScreen`，它们将负责保持屏幕状态和屏幕内容，并管理屏幕状态。
- en: Create a new Kotlin file called `InsertColumnsScreen`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `InsertColumnsScreen` 的新 Kotlin 文件。
- en: Create `InsertColumnsScreenState`, `InsertColumnsScreenContent`, and `InsertColumnsScreen`,
    which will be responsible for holding the screen state and the screen content
    and for managing the screen state.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `InsertColumnsScreenState`、`InsertColumnsScreenContent` 和 `InsertColumnsScreen`，它们将负责保持屏幕状态和屏幕内容，并管理屏幕状态。
- en: Create a new Kotlin file called `GridScreen`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GridScreen` 的新 Kotlin 文件。
- en: Create `GridScreenState`, `GridScreenContent`, and `GridScreen`, which will
    be responsible for holding the screen state and the screen content and for managing
    the screen state.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `GridScreenState`、`GridScreenContent` 和 `GridScreen`，它们将负责保持屏幕状态和屏幕内容，并管理屏幕状态。
- en: In `MainActivity`, create a new function that will set up the navigation between
    your screens.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，创建一个新的函数来设置屏幕之间的导航。
- en: In `MainActivity`, modify the `setContent` method block to invoke the function
    created previously.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 中，修改 `setContent` 方法块以调用之前创建的函数。
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/Le1jE](https://packt.link/Le1jE).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在 [https://packt.link/Le1jE](https://packt.link/Le1jE) 找到。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how we can build user interfaces using Jetpack
    Compose. We started by creating simple user interface elements, and we looked
    at how we can make an entire screen using `@Composable` functions without any
    XML code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用 Jetpack Compose 构建用户界面。我们首先创建简单的用户界面元素，并探讨了如何使用 `@Composable`
    函数构建整个屏幕，而不需要任何 XML 代码。
- en: Then, we analyzed state management and how we can handle user input, and looked
    at patterns such as state hoisting, in which we keep our functions as stateless
    as possible to increase reusability. We then looked at how we can define our own
    user interface elements and apply themes and styles to them, which allows us to
    change the entire look of an application without modifying the screens that use
    the changed elements.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们分析了状态管理以及如何处理用户输入，并探讨了诸如状态提升等模式，其中我们尽可能保持函数无状态以提高可重用性。然后，我们探讨了如何定义我们自己的用户界面元素并将主题和样式应用于它们，这使得我们可以在不修改使用更改元素的屏幕的情况下更改整个应用程序的外观。
- en: Finally, we looked at how we can add Compose to an existing project and how
    Compose interacts with popular libraries used for app development. In the chapter’s
    activity, we applied all these concepts and created an application with a consistent
    user interface definition with multiple screens defined in Compose.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们探讨了如何将Compose添加到现有项目中，以及Compose如何与用于应用开发的流行库交互。在章节活动中，我们应用了所有这些概念，并创建了一个具有一致的用户界面定义的应用程序，其中定义了多个由Compose定义的屏幕。
- en: In the next chapter, we will analyze how we can test our code on Android and
    look at some popular libraries we can use to achieve this.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将分析如何测试我们的Android代码，并查看一些我们可以用来实现这一目标的流行库。
- en: 'Part 3: Testing and Code Structure'
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：测试和代码结构
- en: In this part, we will look at how we can structure our code to make it testable
    and the types of testing we can do in the code base. The Android Architecture
    Components will be used to assist in code structuring by separating code that
    performs tasks that can be tested from code that interacts with the user interface,
    which is harder to test.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将探讨如何构建我们的代码以使其可测试，以及我们可以在代码库中执行的各种测试类型。Android架构组件将被用于通过将执行可测试任务的代码与与用户界面交互的代码分离来辅助代码结构化，后者更难测试。
- en: We will then look at the available options we have with regard to saving data
    on the device. Finally, we will explore how we can manage the dependencies inside
    the application with the help of dependency injection.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将探讨我们在设备上保存数据时拥有的可用选项。最后，我们将探讨在依赖注入的帮助下如何管理应用程序内部的依赖关系。
- en: 'We will cover the following chapters in this section:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下章节：
- en: '[*Chapter 10*](B19411_10.xhtml#_idTextAnchor512), *Unit Tests and Integration
    Tests with JUnit, Mockito, and Espresso*'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19411_10.xhtml#_idTextAnchor512), *使用JUnit、Mockito和Espresso进行单元测试和集成测试*'
- en: '[*Chapter 11*](B19411_11.xhtml#_idTextAnchor582), *Android Architecture Components*'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19411_11.xhtml#_idTextAnchor582), *Android架构组件*'
- en: '[*Chapter 12*](B19411_12.xhtml#_idTextAnchor638), *Persisting Data*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19411_12.xhtml#_idTextAnchor638), *持久化数据*'
- en: '[*Chapter 13*](B19411_13.xhtml#_idTextAnchor695), *Dependency Injection with
    Dagger, Hilt, and Koin*'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19411_13.xhtml#_idTextAnchor695), *使用Dagger、Hilt和Koin进行依赖注入*'
