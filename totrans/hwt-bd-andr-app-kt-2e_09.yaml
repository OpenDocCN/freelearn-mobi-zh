- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building User Interfaces Using Jetpack Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to use Jetpack Compose to create user interfaces
    using Kotlin code, how Compose revolutionized the way we built user interfaces,
    and how we can translate existing applications to Jetpack Compose. By the end
    of the chapter, you will be familiar with the most common UI elements in Compose
    and how to handle user actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Jetpack Compose?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Theming in Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Compose to existing projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/kb5FW](https://packt.link/kb5FW)
  prefs: []
  type: TYPE_NORMAL
- en: What is Jetpack Compose?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In past chapters, you learned how to set data into the Android View hierarchy
    and learned how to use different types of views for different purposes. That approach
    to user interface building is referred to as the **imperative approach**.
  prefs: []
  type: TYPE_NORMAL
- en: In the imperative approach, when we want to change the state of the user interface,
    we will need to manually change each user interface element until we reach the
    desired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that because of a user action, we want our `TextView` to change
    the text and text color. This means that we would need to invoke `setText` and
    `setTextColor` to achieve our desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to the imperative approach, we have the **declarative approach**,
    in which we would need to describe the final state that we want our user interface
    to reach, and internally, the required invocations would be performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that our `TextView` would instead have the text and text color as
    attributes, and we could define different objects holding the states we want.
    In Jetpack Compose, this would look like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we define a `@Composable` function that will display
    a `Text` element. The values for `text` and `color` would be held in a separate
    data class that will represent the state of the text.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism allows Jetpack Compose to redraw the user interface for any change
    that occurs in `MyState`. This process is called `@Composable` functions that
    had a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create a new screen in Compose, we have the choice of `Row` or
    `Column` functions to arrange elements. For vertical arrangement, we can use `Column`,
    and for horizontal alignment, we use `Row`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, using `Column`, we show different user interface
    elements above each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Text` will show a simple label with the `My Static Text` label as `text`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField` will show an input field that’s pre-filled with the `My Text Field`
    text through the `value` parameter. The `onValueChange` lambda will pick up any
    text that the user inserts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button` will show a button, and through the `onClick` lambda, we can pick
    up the click events on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Icon` will display a particular icon from the `drawable` or `mipmap` folders
    and will have a content description set from the string resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to display lists of items, we can use the following approach when
    the number of items is known and small enough to fit on the screen of the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we iterate over each item in the list and show a
    `Text` for each item. If the number of items is unknown and large enough to require
    scrolling, then we would run into performance issues because the recomposition
    would go over both visible and not visible items. For this scenario, we could
    use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using a `LazyColumn` function and wrapping our collection with
    the `items` function. We are also able to add static items as a header and footer
    of the list through the `item` function. Like `Column`, we can use `LazyRow` to
    display a list of items with a horizontal scroll.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add spacings between the UI elements, then `Modifiers` become
    useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we’ve added `16.dp` padding to the entire column
    of items in all directions. If we wanted different paddings in different directions,
    we would’ve had something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we’ve set `5.dp` vertical padding and `10.dp` horizontal
    padding. Because the values are repeated, we can instead use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve used the `vertical` and `horizontal` parameters to set the vertical
    and horizontal paddings. If we want to make the row clickable, then we can use
    the following modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we’ve used the `clickable` method from `Modifier`.
    This will register a click listener on the entire `Column`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the relationship between Activities and Fragments and screens
    built in Compose, we have the following extensions for Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have the `setContent` extension function defined
    for `ComponentActivity`, which will set a `@Composable` function as the content
    for an `Activity`. The same is true for Fragments; however, when starting a new
    project, the current recommendation is to have a single Activity and make all
    your additional screens separate `@``Composable` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Android Studio, we have the possibility of having previews of our `@Composable`
    functions with the `@``Preview` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.01 – first Compose screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an Android application that has one screen defined using `@Composable`
    functions. The screen should have the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Text`, which will say `"Enter` `a number"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TextField`, which will only accept integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Button`, which has the text `"``Click Me"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LazyColumn`, which will display a list of 100 items with the following format
    for each row: `"``Item c"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project and select **Empty** **Compose Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following to `strings.xml` in the `res/values` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the user interface of the exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have chosen to place everything inside the `LazyColumn` block. This will
    make the entire content scrollable, including `Text`, `TextField`, and `Button`,
    and not just the list of items.
  prefs: []
  type: TYPE_NORMAL
- en: To make the keyboard only accept numeric input, we have used the `keyboardOptions`
    parameter of the `TextField` function. For `Button`, to add text to it, we needed
    to use the content parameter of the function and place a new `Text` inside the
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, modify the `MainActivity` code to use the function we’ve just defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we generate a new list of items that will say `"Item [count]"` and invoke
    the `@Composable` function, `MyScreen`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding example, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Output of Exercise 9.01](img/B19411_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Output of Exercise 9.01
  prefs: []
  type: TYPE_NORMAL
- en: We can see in the preceding figure that the screen was built according to the
    exercise specifications. One thing to note is the fact that we aren’t allowed
    to input any text in the input field. This is because we have set the value of
    `TextField` to an empty string. We will look at how we can properly handle this
    aspect in further sections of the book.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can use Jetpack Compose to build user
    interfaces in a simple way without the involvement of other languages and syntaxes
    such as Kotlin. Next, we will continue the exploration of Compose and how we can
    handle user actions and manage states.
  prefs: []
  type: TYPE_NORMAL
- en: Handling user actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to build user interfaces using Jetpack
    Compose. In the exercise, we were unable to collect the data that the user sets
    in `TextField`. In this section, we will learn how to handle the user input as
    well as the state of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume we have the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we define a `TextField` that is empty and has no handling for
    the change of the value. As we’ve seen, this won’t let us introduce any new input
    from the keyboard because it will always set the text to an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to be able to introduce a new text, we will need to create a mutable
    variable to store the text inside and for it to survive recomposition. In Jetpack
    Compose, we can use the `@Composable` function called `remember` to define a `MutableState`
    that will hold our text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we define a mutable variable called `text`, which
    we then set in `TextField`. The `text` variable is initialized through the `remember`
    function, which will hold a `MutableState` that has the initial value set to an
    empty string. This still isn’t complete; we will now need to connect the state
    with the change in value for `TextField`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we modify the `onValueChange` lambda to change the `text` state with the
    latest text that the user inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `rememberSaveable` function to instead retain the value of objects
    across configuration changes such as Activity recreation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with states, we tend to turn `@Composable` functions from being
    stateless (doesn’t manage a state) to stateful (manages one or more states). As
    a guideline, we should try to keep our functions as stateless as possible through
    a pattern called `@Composable` function. This would turn the preceding example
    into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we’ve split our functions in two. The `MyScreen` function
    will manage the state of the text and invoke the `MyScreenContent` function, which
    is now stateless. This approach introduces multiple benefits such as the *reusability*
    of our stateless functions, *decoupled* state management, and *a single source
    of truth* for our state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use the Jetpack Compose State and `MutableState` objects, you might
    need to manually import the following two methods for getting and setting a state:
    `androidx.compose.runtime.getValue` and `androidx.compose.runtime.setValue`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with states in Jetpack Compose, when a change occurs in a state,
    then the recomposition process is triggered. This might cause problems when we
    want to show one-off events such as `Snackbar` and `Toast`. To achieve this, we
    can use `LaunchedEffect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will show a `Toast` message every time `anObjectToChange`
    takes on a different value. If we replace `anObjectToChange` with `Unit`, then
    the `LaunchedEffect` block will be executed only once.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.02 – handling user inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *Exercise 9.01 – first Compose screen* such that when the user introduces
    a number in `TextField` and clicks the button, then a list of items as big as
    the number introduced will be generated and the list below the button will be
    populated with them. The text will be the same for each item as before.
  prefs: []
  type: TYPE_NORMAL
- en: To represent the state of the user interface, a data class will be created that
    will hold the number of items, with `0` as a default, and the list of items, which
    will be empty by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `MyScreenState` data class, which will hold the state of the user
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `@Composable` method called `MyScreenContent`, which will have `MyScreenState`
    as a parameter and render the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we set `itemCount` from `myScreenState` in our `TextField`
    and `items` from `myScreenState` as items in the list. We’ve also added our text
    change listener and button listener as parameters to the function, making it stateless.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `MyScreen` function such that it will call `MyScreenContent` and
    handle the listener for the text change and for the button click:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are creating a new `MutableState` that will hold `MyScreenState` with
    its defaults. We will then invoke `MyScreenContent` in which we pass the state.
    When the text changes, we set the state to be the copy of the existing state with
    the new text, and when the button is clicked, we generate a new list of items
    up until the current `itemCount` and update the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `MainActivity` class to invoke the `MyScreen` function without any
    parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the exercise and insert a number, then we should see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Output of Exercise 9.02](img/B19411_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Output of Exercise 9.02
  prefs: []
  type: TYPE_NORMAL
- en: When the app is first launched, we should see the `TextField` empty and no elements
    in the list below the button. When a number is set, then the state is changed
    to reflect the new text, and when the button is clicked, then the list of items
    is displayed with the size being that of the inserted number.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can handle user input, keep it in
    a state, and manage that state across recomposition. In the section that follows,
    we will look at how we can further decorate our user interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: Theming in Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned how to handle user actions and how to manage
    the state of a particular screen. But how do we keep our application’s user interface
    elements consistent across the entire application? In this section, we will look
    at how we can create reusable elements that are linked to the application’s theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed, when you carried out the previous exercises, that Android
    Studio created some files in a `ui.theme` package. This is because Jetpack Compose
    is built upon the Material Design library and will assign a theme to your application
    that is built on Material Design. The approach taken is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Color.kt` file, all the colors of the application are declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we have the color hexadecimal names.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Shape.kt`, the following code is generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will indicate what the size of the icons you use in the application should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Type.kt`, the following code is generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will represent how the text in your application is rendered. The `Typography`
    class holds configurations for how your headings, subtitles, paragraphs, buttons,
    and captions text should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Theme.kt` file, we have two color palettes defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, there’s a light and dark color palette defined and the `primary`, `primaryVariant`,
    and `secondary` colors are set. The rest of the colors in the `lightColors` and
    `darkColors` functions will remain with their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file, the application’s theme is generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a check will be made to see whether the device has light or dark mode
    enabled and use the appropriate set of colors for each mode. It will also set
    the typography you configured and how the shapes in your application should be.
    Just because it is set in the theme, that doesn’t mean that our user interface
    elements will automatically inherit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `MainActivity` class is generated, it will have the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When `setContent` is called, then your application’s theme will be called, and
    the `Surface` function will set your application’s background.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the preceding setup as a starting point to define a theme for
    our application and start to create reusable user interface components. Let’s
    assume we want all the paragraphs in the application to use the same typography
    and have the same color; in this case, we will use `MaterialTheme.typography.body1`
    and `MaterialTheme.colors.onBackground`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we’ve defined the `ParagraphText` function, which
    will set the style and color of the text from `MaterialTheme`. We might now have
    a problem if we want the same style and a different text color, where we need
    to duplicate the style attribute for each. Another solution is to create two functions
    – one for the style and the other on top of it for the color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we’ve moved the color to be a parameter in the `ParagraphText`
    function and then created a new function called `OnBackgroundParagraphText`, which
    allows us to set `MaterialTheme.colors.onBackground` to the `Text` defined in
    `ParagraphText`. If we want to use our new function, then we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple function call, just like using the `Text` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s assume we are using this text across our entire application and
    the application goes through a redesign where instead of using `MaterialTheme.typography.body1`,
    we need to use `MaterialTheme.typography.body2`, and the text color needs to be
    red. In this case, we would then modify the `ParagraphText` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have changed the style of the `Text` function to use `MaterialTheme.typography.body2`.
    To change the color, we could modify `OnBackgroundParagraphText`, but the color
    currently used is recommended to be used on top of the current background, so
    we could also change the value of `MaterialTheme.colors.onBackground`. For this,
    we could go into `Theme.kt` and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, we changed the value of `onBackground` to red, which will impact all the
    user interface elements that reference `onBackground`. We can now see how we can
    easily apply this across all the user interface elements in the application without
    touching the code where those elements are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to have multiple screens in our application, we can connect Compose
    with the `navigation` library, which is available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now assume we have two screens defined in Jetpack Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`Screen1` will display one button and `Screen2` has two inputs that will be
    displayed. We now want to connect the screens so that when the button is clicked
    on `Screen1`, `Screen2` opens with two hardcoded inputs passed. This would look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a new `@Composable` function called `MyApp`, which uses `NavHost`
    to keep all the screens in the application. `NavHost` will open `Screen1` as a
    default through the `screen1` URL. In the `onButtonClick` lambda from `Screen1`,
    we navigate to `Screen2` and we pass the `input1` and `input2` strings.
  prefs: []
  type: TYPE_NORMAL
- en: This is done through the `screen2/{input1}?input2={input2}` URL. This is also
    how we will pass arguments between the two screens, through either the path parameter
    (`input1`) or the argument (`input2`). For each input, we will need to specify
    that we will be expecting a string as a type.
  prefs: []
  type: TYPE_NORMAL
- en: '`Screen2` will then be opened, and the input extracted through the `it` variable,
    which is a `NavBackStackEntry` type. We can call this function from the `setContent`
    method of the Activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we hoist the state of `NavHostController` and then call the `MyApp` function.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.03 – applying themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *Exercise 9.02 – handling user inputs* such that `MyScreen`, `MyScreenContent`,
    and `MyScreenState` are split into two screens, with `ItemCountScreen`, `ItemCountScreenContent`,
    and `ItemCountScreenState` on one side, which will hold `Text`, `TextField`, and
    `Button`, and `ItemScreen`, `ItemScreenContent`, and `ItemScreenState` on the
    other, which will hold the item list.
  prefs: []
  type: TYPE_NORMAL
- en: The two screens will be saved in `ItemCountScreen.kt` and `ItemScreen.kt` files.
    `ItemCountScreen` will be shown first, and when the button is clicked, then `ItemScreen`
    is shown with the number of items set in the previous screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'New functions will also be created to represent `Text` used across the application:
    one for the `"Enter a number"` text, which will be `MaterialTheme.typography.h5`;
    the `"Click Me"` text will be `MaterialTheme.typography.button`; and `"Item [count]"`
    will be `MaterialTheme.typography.body1`.'
  prefs: []
  type: TYPE_NORMAL
- en: The colors will be set to `MaterialTheme.colors.onBackground` for the text,
    and `Color.red` for the button text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `app/build.gradle` file, add the `navigation` library dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `ui.theme` package, create a Kotlin file called `Elements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Elements.kt` file, add the functions for the title text on the first
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, add the functions for the `"Item [``count]"` text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, add the functions for the button text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, as the button sets the color for the content in a different
    way, we had to use `contentColor` from the `ButtonColors` class.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Kotlin file called `ItemCountScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this file, create a new class called `ItemCountScreenState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, create a new function called `ItemCountScreenContent`, which
    will hold the newly created `OnBackgroundTitleText` and `PrimaryTextButton` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, create a new function called `ItemCountScreen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a new Kotlin file called `ItemScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that file, create a new class called `ItemScreenState`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, create a new function called `ItemScreenContent`, which will
    use `OnBackgroundItemText`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the same file, create a new function called `ItemScreen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `MainActivity` file, create the `MyApp` function, which will manage
    our two screens defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, modify the `setContent` function so that `MyApp` will be called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we run the application, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Output of Exercise 9.03](img/B19411_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Output of Exercise 9.03
  prefs: []
  type: TYPE_NORMAL
- en: We should be able to see the screens split in two, and on entering a number
    in one screen, we should transition to the other screen with a generated list
    of items. We should also see the newly defined styles for the `Text` functions.
    We should be able to control these styles only from the `Elements` class and cause
    no modifications to the screens themselves.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned how to apply theming to an application and
    how we can create multiple screens and navigate between them using Jetpack Compose.
    In the section that follows, we will look at how we can integrate Compose into
    an existing project and how well it can be integrated with other popular libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Compose to existing projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at what options we have in terms of introducing
    Jetpack Compose into an existing Android application and how to get Compose to
    work with different libraries.
  prefs: []
  type: TYPE_NORMAL
- en: When using Jetpack Compose, you should ideally have a small number of activities,
    or one if possible, and have all your screens built using Compose. For an existing
    project to be able to achieve this, it would need to start at the bottom of the
    `View` hierarchy, meaning that your existing views should start being migrated
    to be built in Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate this transition, Jetpack Compose offers the possibility of using
    `ComposeView` in your XML layout, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have an existing layout that will need to include a view that was
    defined using Jetpack Compose. In the layout XML file, we can put a `ComposeView`
    placeholder of where our view would live, and then in the Kotlin code, we can
    include the Compose user interface element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Fragment` inflates the XML layout, looks up `ComposeView`,
    and marks the Compose content to be destroyed when the `View` of `Fragment` is
    also destroyed to prevent any leaks, and then sets the content of `ComposeView`
    to be `Text`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to go the opposite route and add Android views into the Compose
    code, then we have the option of using `AndroidView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have defined a new `@Composable` function called `MyCustomisedElement`,
    which will invoke `AndroidView`, which in turn will create a `TextView` on which
    it will set the text we have defined as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve seen in previous sections, we can use `LocalContext.current` to obtain
    a `Context` reference. This allows us to perform actions such as starting activities
    and services and showing `Toasts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compose is also able to interact with other libraries that are useful when
    building Android applications. We will analyze these libraries in the chapters
    that follow, but now, we will look at how they work with Jetpack Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewModel` library is useful for keeping data across configuration changes
    in our Activities and Fragments and helps to make our code more testable. Compose
    can obtain references to `ViewModel` objects through the `@Composable` function
    called `viewModel`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we call `viewModel` to obtain a reference to `MyViewModel` and set `Text`
    with the value that `viewModel` was holding.
  prefs: []
  type: TYPE_NORMAL
- en: Data stream libraries are useful in combination with the `ViewModel` library,
    as when we want to load data asynchronously from the internet or the local filesystem,
    we will need to notify the user interface that the data was loaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Common data stream libraries are LiveData, RxJava, and Coroutines and Flows.
    We’ve seen that Compose uses a `State` object when we want to manage the state
    of the user interface. For each of the three libraries, Compose provides extension
    libraries in which a stream of data is converted into a `State` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our `viewModel` object would have each of the data streams
    that would hold a string. For each of the streams, Compose calls the equivalent
    method to subscribe and monitor for changes in the value of the string. When a
    new value is emitted for each stream, then Compose sets it in the `Text`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hilt is a dependency injection library designed for Android app development.
    If the `navigation` library is not present in the project, then using the `viewModel`
    function described previously should be enough to obtain a reference to your `ViewModel`;
    however, if the `navigation` library is present, then a library that makes `hilt`
    and `navigation` work together also needs to be included:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To obtain references to `ViewModel` objects in the Compose code, we will need
    to replace the invocation to `viewModel` with an invocation to `hiltViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about integrating Jetpack Compose into your Android
    application at [https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose),
    and about compatibility with other libraries here: [https://developer.android.com/jetpack/compose/libraries](https://developer.android.com/jetpack/compose/libraries).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how we can integrate the Jetpack Compose
    library and make it work with existing `View` objects and existing libraries in
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 9.01 – first Compose app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new app using Jetpack Compose, which will have three screens:'
  prefs: []
  type: TYPE_NORMAL
- en: The **insert rows** screen will have a title, a text field, and a button where
    a number can be inserted. When the button is clicked, then the user navigates
    to the next screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **insert columns** screen will have a title, a text field where a number
    can be inserted, and a button. When the button is clicked, then the user navigates
    to the next screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A grid screen will display a grid with the number of rows and the number of
    columns inserted above. Each row will independently scroll using `LazyRow`, and
    for the columns, `LazyColumn` will be used. Each grid item will display the text
    `"``Item [row][column]"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two screens will have their user interface elements using the same
    styling for the titles, text fields, and buttons, and the third screen will have
    a style for displaying the text in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity, you need to take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Android Studio project using an empty Compose Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `navigation` library dependency to the `app/build.gradle` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ui.theme` package, create a new Kotlin file called `Elements`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that file, create `@Composable` functions for the titles used in the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same file, create `@Composable` functions for the text fields used in
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same file, create `@Composable` functions for the grid items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same file, create `@Composable` functions for the buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Kotlin file called `InsertRowsScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `InsertRowsScreenState`, `InsertRowsScreenContent`, and `InsertRowsScreen`,
    which will be responsible for holding the screen state and the screen content
    and for managing the screen state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Kotlin file called `InsertColumnsScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `InsertColumnsScreenState`, `InsertColumnsScreenContent`, and `InsertColumnsScreen`,
    which will be responsible for holding the screen state and the screen content
    and for managing the screen state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Kotlin file called `GridScreen`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create `GridScreenState`, `GridScreenContent`, and `GridScreen`, which will
    be responsible for holding the screen state and the screen content and for managing
    the screen state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity`, create a new function that will set up the navigation between
    your screens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `MainActivity`, modify the `setContent` method block to invoke the function
    created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/Le1jE](https://packt.link/Le1jE).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can build user interfaces using Jetpack
    Compose. We started by creating simple user interface elements, and we looked
    at how we can make an entire screen using `@Composable` functions without any
    XML code.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we analyzed state management and how we can handle user input, and looked
    at patterns such as state hoisting, in which we keep our functions as stateless
    as possible to increase reusability. We then looked at how we can define our own
    user interface elements and apply themes and styles to them, which allows us to
    change the entire look of an application without modifying the screens that use
    the changed elements.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at how we can add Compose to an existing project and how
    Compose interacts with popular libraries used for app development. In the chapter’s
    activity, we applied all these concepts and created an application with a consistent
    user interface definition with multiple screens defined in Compose.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will analyze how we can test our code on Android and
    look at some popular libraries we can use to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Testing and Code Structure'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will look at how we can structure our code to make it testable
    and the types of testing we can do in the code base. The Android Architecture
    Components will be used to assist in code structuring by separating code that
    performs tasks that can be tested from code that interacts with the user interface,
    which is harder to test.
  prefs: []
  type: TYPE_NORMAL
- en: We will then look at the available options we have with regard to saving data
    on the device. Finally, we will explore how we can manage the dependencies inside
    the application with the help of dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following chapters in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19411_10.xhtml#_idTextAnchor512), *Unit Tests and Integration
    Tests with JUnit, Mockito, and Espresso*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19411_11.xhtml#_idTextAnchor582), *Android Architecture Components*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19411_12.xhtml#_idTextAnchor638), *Persisting Data*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19411_13.xhtml#_idTextAnchor695), *Dependency Injection with
    Dagger, Hilt, and Koin*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
