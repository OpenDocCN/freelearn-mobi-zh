<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing Applications with Spring Security</h1>
                
            
            
                
<p>Security is one of the first priorities for the enterprise, e-commerce, and banking projects. These projects need to create a security system since they exchange millions of dollars and store the protected resources of an organization.</p>
<p>Spring Security is a sub-task of the immense Spring Framework portfolio. It has been upgraded to be utilized with a Spring MVC web application framework, yet can similarly be utilized with Java servlets. This supports authentication incorporation with a long list of other technologies, such as <strong>Lightweight Directory Access Protocol</strong> (<strong>LDAP</strong>), <strong>Java Authentication and Authorization Service</strong> (<strong>JAAS</strong>), and OpenID. It was developed as a complete security solution for Java-based enterprise environments.</p>
<p>In this chapter, we'll learn about Spring Security and its modules and learn how to implement security in a Spring-based project. The following topics will be covered in this chapter:</p>
<ul>
<li>Spring Security architecture</li>
<li>The advantages of Spring Security</li>
<li>Spring Security features</li>
<li>Spring Security modules</li>
<li>Implementing Spring Security</li>
<li>Securing REST with Spring Security basic authentication</li>
<li>Securing REST with Spring Security OAuth2</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>You need to add these dependencies to enable and use the features of Spring Security. Here are the dependencies that need to be added to the <kbd>pom.xml</kbd> file of the Spring project:</p>
<pre>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;Spring_Security_SUB_Module_Name&lt;/artifactId&gt;<br/>   &lt;version&gt;CURRENT_RELEASE_VERSION&lt;/version&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;dependency&gt;<br/>   &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>   &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;<br/>   &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>You can find all the examples from this chapter on GitHub at <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter05">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter05</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Spring Security architecture</h1>
                
            
            
                
<p>Spring Security is the security service solution for a J2EE-based enterprise production. This helps to develop a secured application in a faster and easier way with the use of its particular dependency-injection principles. To develop a secure J2EE-based enterprise application, Spring Security is an incredible and flexible authentication and authorization framework. Authentication is the process of checking the identity of a procedure or a client. On the other hand, authorization implies a procedure of checking the authority of a client to perform activities in the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authentication</h1>
                
            
            
                
<p class="mce-root">Authentication is the process that identifies a user or client based on their username and password. It helps a user to get the access protected system objects based on their identity. For the authentication procedure, spring security gives us the <kbd>AuthenticationManager</kbd> interface. This interface has just a single capacity, named <kbd>validate()</kbd>.</p>
<p class="mce-root">The accompanying snippet of code is an example of the <kbd>AuthenticationManager</kbd> interface:</p>
<pre><strong>interface AuthenticationManager {</strong><br/><strong>    @Throws(AuthenticationException::class)</strong><br/><strong>    fun authenticate(authentication: Authentication): Authentication</strong><br/><strong>}<br/></strong></pre>
<p>Three tasks are completed by the <kbd>authenticate()</kbd> in this <kbd>AuthenticationManager</kbd> interface:</p>
<ul>
<li class="mce-root"><kbd>authenticate()</kbd> returns<kbd>Authentication</kbd> on the off-chance that its capacity can check that the input represents a valid principle. The previously-mentioned code generally returns <kbd>authenticated=true</kbd>.</li>
<li class="mce-root">In the event that the capacity finds that the input doesn't speak to a substantial rule, it tosses <kbd>AuthenticationException</kbd>.</li>
<li class="mce-root">In the event that the capacity can't choose anything, it will return <kbd>null</kbd>.</li>
</ul>
<p><kbd>AuthenticationException</kbd> is a runtime exception. An application handles this exception in a conventional way. </p>
<p><kbd>ProviderManager</kbd> is often used to implement <kbd>AuthenticationManager</kbd>, and represents a chain of <kbd>AuthenticationProvider</kbd> objects. If there's no parent accessible, it throws <kbd>AuthenticationException</kbd>.</p>
<p class="CDPAlignLeft CDPAlign"><kbd>AuthenticationProvider</kbd> resembles <kbd>AuthenticationManager</kbd>, but has an additional function. This additional function enables the client to query on the off-chance that it supports a given <kbd>Authentication</kbd> type.</p>
<p class="CDPAlignLeft CDPAlign">Here's some code of the <kbd>AuthenticationProvider</kbd> interface:</p>
<pre>interface AuthenticationProvider {<br/><strong>   @Throws(AuthenticationException::class)</strong><br/>    fun authenticate(authentication:Authentication):Authentication<br/>    fun supports(authentication: Class&lt;*&gt;): Boolean<br/>}</pre>
<p>This interface has two functions—<kbd>authenticate()</kbd> returns the user's authentication details and <kbd>supports()</kbd> returns a <kbd>Boolean</kbd> if the authentication and given username-password pair matches, or doesn't.</p>
<p class="mce-root"/>
<p>Here is a diagram of the <kbd>AuthenticationManager</kbd> hierarchy utilizing <kbd>ProviderManager</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5fd0389-0cd9-48a8-a03f-6954119392f0.png"/></p>
<p>According to this diagram, in an application, <kbd>ProviderManager</kbd> may have a group of other <kbd>ProviderManager</kbd> instances but the first one will behave as a parent. Every <kbd>ProviderManager</kbd> may have multiple <kbd>AuthenticationManager</kbd>. For example, if all web resources are under the same path, every group will have its own dedicated <kbd>AuthenticationManager</kbd>. However, there will be only one common parent, which will act as a global resource and will be shared by these dedicated <kbd>AuthenticationManager</kbd> instances. Now, let's see how to modify the authentication manager.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying authentication managers</h1>
                
            
            
                
<p>Spring Security provides some configuration helpers to set up authentication manager features in your application. This will help to get the features quickly. <kbd>AuthenticationManagerBuilder</kbd> helps to modify the authentication managers.</p>
<p>Here is an example of how to implement <kbd>AuthenticationManagerBuilder</kbd> in the <kbd>ApplicationSecurity.kt</kbd> class:</p>
<pre>class ApplicationSecurity: WebSecurityConfigurerAdapter() {<br/>    @Autowired<br/><strong>    fun initialize(builder: AuthenticationManagerBuilder, dataSource: DataSource){</strong><br/><strong>builder.jdbcAuthentication().dataSource(dataSource).withUser("Sunnat629").password("packtPub").roles("USER")</strong><br/><strong> }</strong><br/>}</pre>
<p>Here, we have given a username, <kbd>sunnat629</kbd>, and a password, <kbd>packtPub</kbd>, as a <kbd>USER</kbd> role in this application.</p>
<p>Spring Boot accompanies a default global <kbd>AuthenticationManager</kbd>, which is sufficiently secure. You can supplant it by giving your own <kbd>AuthenticationManager</kbd> bean.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authorization</h1>
                
            
            
                
<p>Authorization is the process of accepting or rejecting access to network resources. It will grant access to utilize the data from the resources. After the <kbd>Authentication</kbd> process, the <kbd>Authorization</kbd> process begins. <kbd>Authorization</kbd> is used to deal with controlling access. <kbd>AccessDecisionManager</kbd> is one of the core entities of this. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Web security</h1>
                
            
            
                
<p>The servlet channels of spring security provide web security. The <kbd>@WebSecurityConfigurer</kbd> annotation is used to enable the web security and override <kbd>WebSecurityConfigurerAdapter</kbd> in the web security class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Method Security</h1>
                
            
            
                
<p>This is a module of a security method that's provided by Spring Security. We can provide a role in a particular function so that role-based users can access the function. </p>
<p>The following annotation is used to enable this feature:</p>
<pre> @EnableGlobalMethodSecurity(securedEnabled = true)</pre>
<p>Here's an example of how to enable method security in the <kbd>SpringSecurityApplication.kt</kbd> class, which is the main application class of our demo project:</p>
<pre>@SpringBootApplication<br/><strong>@EnableGlobalMethodSecurity(securedEnabled = true)</strong><br/>class <strong>SpringSecurityApplication</strong>{<br/><br/>    fun main(args: Array&lt;String&gt;) {<br/>        runApplication&lt;SpringSecurityApplication&gt;(*args)<br/>    }<br/>}<br/><br/></pre>
<p>Now you can create the method resources, such as the following code:</p>
<pre><strong>@Secured<br/></strong>class CustomService{<br/>   <strong> @Secured<br/>    fun secure(): String{</strong><br/><strong>        return "The is Secured..."<br/>    }</strong><br/>}</pre>
<p>Here, we created a secured class named <kbd>CustomService</kbd> using the <kbd>@Secured</kbd> annotation, and then created a secured function that will return a spring. The <kbd>@Secured</kbd> annotation is used to specify a list of roles on a function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The advantages of Spring Security</h1>
                
            
            
                
<p>The Spring Security framework provides the following advantages:</p>
<ul>
<li>Spring Security is an open source security framework</li>
<li>It supports authentication and authorization</li>
<li>It protects against common tasks</li>
<li>It can be integrated with Spring MVC and the Servlet API</li>
<li>It supports Java and Kotlin configuration support</li>
<li class="mce-root">It's easy to develop and unit-test the applications</li>
<li class="mce-root">Spring dependency injection and AOP can be used with ease</li>
<li class="mce-root">It develops loosely-coupled applications</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Spring Security features</h1>
                
            
            
                
<p>There are a lot of features that are implemented in Spring Security.</p>
<p>Here, we have explained some common and major features:</p>
<ul>
<li><strong>LDAP</strong>:<strong> </strong>LDAP is an open application protocol. This maintains and accesses distributed directory data services over the internet.</li>
<li><strong>OAuth 2.0 login</strong>:<strong> </strong>This component makes it possible for the client to log into the application by utilizing their existing accounts on Google, Facebook, Twitter, or GitHub.</li>
<li><strong>Basic access authentication</strong>:<strong> </strong>This gives a username and password when a client requests them over the network.</li>
<li class="mce-root"><strong>Digest access authentication</strong>:<strong> </strong>This asks the program to affirm the identity of the client before sending personal information over the system.</li>
<li class="mce-root"><strong>Web form authentication</strong>: In this authentication system, a web form collects and authenticates user credentials from the web browser.</li>
<li class="mce-root"><strong>Authorization</strong>: Spring Security offers this feature to approve of the client before getting the assets. </li>
<li><strong>HTTP authorization</strong>: This refers to the<strong> </strong>HTTP authorization of web request URLs. It uses Apache Ant paths or regular expressions.</li>
<li class="mce-root"><strong>Reactive support</strong>: This provides reactive programming and web runtime support.</li>
<li class="mce-root"><strong>Modernized password encoding</strong>: A new password encoder, named <kbd>DelegatingPasswordEncoder</kbd>, is introduced from Spring Security 5.0.</li>
<li class="mce-root"><strong>Single sign-on</strong>: This feature allows a client to access multiple applications with a single account.</li>
<li class="mce-root"><strong>JAAS</strong>: JAAS is a Pluggable Authentication Module that's implemented in Java.</li>
<li><strong>Remember-me</strong>:<strong> </strong>Spring Security utilizes HTTP cookies, which remember a client's login ID and password in order to maintain a strategic distance from login again until the client logs out.</li>
<li class="mce-root"><strong>Software localization</strong>: You can create the user interface of an application in any human language.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Spring Security modules</h1>
                
            
            
                
<p>The Spring Security module has been isolated into a few sub-modules in Spring Security 3.0. However, in the present version, there are 12 submodules. To support these modules, the code is sub-partitioned into isolated containers. These containers are currently disengaged, where every submodule has a diverse useful area and third-party dependencies.</p>
<p>Here is a list of sub-module jars:</p>
<ul>
<li><kbd>spring-security-core.jar</kbd></li>
<li><kbd>spring-security-remoting.jar</kbd></li>
<li><kbd>spring-security-web.jar</kbd></li>
<li><kbd>spring-security-config.jar</kbd></li>
<li><kbd>spring-security-ldap.jar</kbd></li>
<li class="mce-root"><kbd>spring-security-oauth2-core.jar</kbd></li>
<li><kbd>spring-security-oauth2-client.jar</kbd></li>
<li><kbd>spring-security-oauth2-jose.jar </kbd></li>
<li><kbd>spring-security-acl.jar</kbd></li>
<li><kbd>spring-security-cas.jar</kbd></li>
<li><kbd>spring-security-openid.jar</kbd></li>
<li><kbd>spring-security-test.jar</kbd></li>
</ul>
<p>The Spring Security Core sub-module is the base module for the rest of the Security sub-modules, such as <kbd>web</kbd>, <kbd>config</kbd>, and <kbd>oauth2</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing Spring Security</h1>
                
            
            
                
<p>If you want to use Spring Security in your project, you need to implement the Spring Security dependencies that you want to use in both Maven and Gradle.</p>
<p>Let's take a look at how to implement the Spring Security dependencies in both Maven and Gradle.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Maven</h1>
                
            
            
                
<p>To implement the security dependencies, you need to implement <kbd>spring-security-core</kbd> in <kbd>pom.xml</kbd>:</p>
<pre>&lt;dependency&gt;<br/> &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/> &lt;artifactId&gt;Spring_Security_SUB_Module_Name&lt;/artifactId&gt;<br/> &lt;version&gt;CURRENT_RELEASE_VERSION&lt;/version&gt;<br/>&lt;/dependency&gt;<br/><br/><strong>&lt;!--here is an example of a security core sub-modules--&gt;</strong><br/><strong>&lt;dependency&gt;</strong><br/><strong> &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;</strong><br/><strong> &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt;</strong><br/><strong> &lt;version&gt;5.1.1.RELEASE&lt;/version&gt;</strong><br/><strong>&lt;/dependency&gt;</strong><br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle</h1>
                
            
            
                
<p>To implement the dependencies, you need to put the following code in <kbd>build.gradle</kbd>:</p>
<pre>dependencies {<br/>    implementation 'org.springframework.security:[Spring_Security_SUB_Module_Name]:CURRENT_RELEASE_VERSION'<br/>}<br/><br/>// here is an example of a security core sub-modules<br/><strong>dependencies {</strong><br/><strong>    implementation 'org.springframework.security:[spring-security-core]:5.1.1.RELEASE'</strong><br/><strong>}</strong><br/></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing REST with basic authentication</h1>
                
            
            
                
<p>Within this topic, we'll learn basic authentication with a simple project. Here, we'll create an example where you'll build a secure REST API. We'll make a project and implement the basic authentication. This will help us to avoid the basic configuration and complete Kotlin config duration. For this project, you must enter your username and password to access the content. This project has no UI and therefore you need to use an HTTP client to test the project. Here, we're using Insomnia (<a href="https://insomnia.rest/download/">https://insomnia.rest/download/</a>). You can test your project and access the content from here.</p>
<p>Before starting with our project, we'll learn about basic authentication and its use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is basic authentication?</h1>
                
            
            
                
<p><strong>Basic authentication</strong> is the simplest authentication scheme, which is built into the HTTP protocol. To use it, the client needs to send HTTP requests with the authentication header, which contains the word <em>Basic</em> followed by a space. Then, the given string of username and password will be considered as <kbd>username/password</kbd> and encoded into Base64. For example, if the username and password are <kbd>Sunnat629</kbd> and <kbd>pa$$worD</kbd>, these will be converted into Base64 encoding, which will be <kbd>U3VubmF0NjI5L3BhcyQkd29yRA==</kbd> as authorized. Finally, the client will send  <kbd>Authorization: Basic  U3VubmF0NjI5L3BhcyQkd29yRA==</kbd> to the server.</p>
<p>Base64 can easily be decoded. This is neither encrypted nor hashed. If you want to use the basic authentication, we highly recommend using this together with other security tools, such as HTTPS/SSL.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a project</h1>
                
            
            
                
<p>We'll create a small project where we'll implement the basic authentication security to protect the data. A user needs to be accepted by our security system to access the data. Let's create the project with the given steps:</p>
<ol>
<li>To create the project, go to the <a href="https://start.spring.io/">https://start.spring.io/</a> and modify the given field with your requirement. You can check our project information in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/4047a3e3-1931-49b8-82b8-4674ba208e7a.png"/></p>
<p style="padding-left: 60px">Here, we're using <kbd>Maven Project</kbd> and selecting the language as <kbd>Kotlin</kbd> and the Spring Boot version as <kbd>2.1.1 (SNAPSHOT)</kbd>.</p>
<p style="padding-left: 60px">We've added the <kbd>Security</kbd>, <kbd>Web</kbd>, and <kbd>DevTools</kbd> dependencies. You can check the list in <kbd>pom.xml</kbd>.</p>
<ol start="3">
<li>When you select <kbd>Generate Project</kbd>, you'll get the project as a ZIP file. Unzip and open this project with your IDE. </li>
</ol>
<ol start="4">
<li>It will take a moment to download and update the Maven dependencies. Here's a screenshot of your project's content:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0901227f-9f7f-40af-930f-25108808826a.png"/> </p>
<p>If you need to add new dependencies or update the versions, modify <kbd>pom.xml</kbd>. If you want to create <kbd>kotlin</kbd> files, you need to create files under the <kbd>src-&gt;main-&gt;kotlin-&gt;{Package_NAME}</kbd> folder. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring pom.xml</h1>
                
            
            
                
<p>In this <kbd>pom.xml</kbd>, you'll have all the information regarding the project. Here, you can insert new dependencies, update versions, and so on. Here is the sample <kbd>pom.xml</kbd> (the full code is on the GitHub, at <a href="https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter05">https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter05</a>:</p>
<pre><strong>&lt;groupId&gt;com.packtpub.sunnat629&lt;/groupId&gt;<br/></strong>&lt;artifactId&gt;ssbasicauth&lt;/artifactId&gt;<br/>&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br/>&lt;packaging&gt;jar&lt;/packaging&gt;<br/><br/>&lt;name&gt;Spring Security Basic Authentication&lt;/name&gt;<br/>&lt;description&gt;A sample project of Spring Security Basic Authentication&lt;/description&gt;<br/><br/>----<br/>----<br/><br/>&lt;properties&gt;<br/>   &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;<br/>   &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;<br/><strong>   &lt;java.version&gt;1.8&lt;/java.version&gt;<br/>   &lt;kotlin.version&gt;1.3.0&lt;/kotlin.version&gt;</strong><br/>&lt;/properties&gt;<br/><br/>&lt;dependencies&gt;<br/>   &lt;dependency&gt;<br/>      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>      &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>      &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;<br/>      &lt;artifactId&gt;jackson-module-kotlin&lt;/artifactId&gt;<br/>   &lt;/dependency&gt;<br/><strong>   &lt;dependency&gt;<br/>      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br/>      &lt;artifactId&gt;kotlin-stdlib-jdk8&lt;/artifactId&gt;<br/></strong><strong>   &lt;/dependency&gt;</strong><br/>   &lt;dependency&gt;<br/>      &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;<br/>      &lt;artifactId&gt;kotlin-reflect&lt;/artifactId&gt;<br/>   &lt;/dependency&gt;<br/><br/>   &lt;dependency&gt;<br/>      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;<br/>      &lt;scope&gt;test&lt;/scope&gt;<br/>   &lt;/dependency&gt;<br/>   &lt;dependency&gt;<br/>      &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>      &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt;<br/>      &lt;scope&gt;test&lt;/scope&gt;<br/>   &lt;/dependency&gt;<br/>&lt;/dependencies&gt;<br/><br/>---<br/>---<br/>---</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring a Spring bean</h1>
                
            
            
                
<p>To configure a Spring bean, we'll create an application file named <kbd>SSBasicAuthApplication.kt</kbd> and use Java configuration, which configures Spring Security without writing any XML code.</p>
<p>Here's a simple code for the application file (<kbd>SSBasicAuthApplication.kt</kbd>):</p>
<pre>@ComponentScan(basePackages = ["com.packtpub.sunnat629.ssbasicauth"])<br/>@SpringBootApplication<br/>class SSBasicAuthApplication: SpringBootServletInitializer()<br/><br/>fun main(args: Array&lt;String&gt;) {<br/> runApplication&lt;SSBasicAuthApplication&gt;(*args)<br/>}</pre>
<p>Here, we've extended <kbd>SpringBootServletInitializer</kbd>. This runs <kbd>SpringApplication</kbd> from a traditional <kbd>WAR</kbd> archive. This class is responsible for binding the <kbd>Servlet</kbd>, <kbd>Filter</kbd>, and <kbd>ServletContextInitializer</kbd> beans from the application context to the server.</p>
<p><kbd>@SpringBootApplication</kbd> is a convenience annotation that's equivalent to declaring <kbd>@Configuration</kbd> and <kbd>@EnableAutoConfiguration</kbd> for this <kbd>SSBasicAuthApplication</kbd> class.</p>
<p>Mention a package name or a collection of package names in the <kbd>@ComponentScan</kbd> annotation to specify the base packages. This is used with the <kbd>@Configuration</kbd> annotation to tell Spring packages to scan for annotated components.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration for Spring Security</h1>
                
            
            
                
<p>To add the configuration for Spring Security of our project, create a file named <strong><kbd>SSConfig.kt</kbd> </strong>in the application package using the following code: </p>
<pre><strong>@Configuration<br/></strong><strong>@EnableWebSecurity</strong><br/>class SSConfig: <strong>WebSecurityConfigurerAdapter()</strong> {<br/><br/>    @Autowired<br/>    private val authEntryPoint: AuthenticationEntryPoint? = null<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(http: HttpSecurity) {<br/>        http.csrf().disable().authorizeRequests()<br/>                .anyRequest().authenticated()<br/>                .and().httpBasic()<br/>                .authenticationEntryPoint(authEntryPoint)<br/>    }<br/><br/>    @Autowired<br/>    @Throws(Exception::class)<br/>    fun configureGlobal(auth: AuthenticationManagerBuilder) {<br/>        auth.inMemoryAuthentication()<br/>                .withUser("sunnat629")<br/>                .password(PasswordEncoderFactories.createDelegatingPasswordEncoder()<br/>                        .encode("password"))<br/>                .roles("USER")<br/>    }<br/>}</pre>
<p>We've annotated this class with <kbd>@Configuration</kbd>, which helps in the Spring annotation-based configuration. <kbd>@EnableWebSecurity</kbd> will enable the web security support of Spring Security.</p>
<p>We've extended <kbd>WebSecurityConfigurerAdapter</kbd> and this will give us access to overriding and customizing the Spring features. We're using HTTP Basic Authentication and all of our requests will be authenticated using this.</p>
<p>If the authentication fails, we need to handle this. To do so, create an authentication entry point class named <kbd>AuthenticationEntryPoint.kt</kbd> and <kbd>autowire</kbd> it. It will help to retry this process again in case of the failure.</p>
<p>Here we are using the <kbd>sunnat629</kbd> username, the <kbd>password</kbd> password, and the <kbd>USER</kbd> role.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring an authentication entry point</h1>
                
            
            
                
<p>Configure the authentication entry point to handle the failed authentication. When the credentials aren't authorized, this class is mainly responsible for sending the response.</p>
<p>Here's the code of an authentication entry point class named <strong><kbd>AuthenticationEntryPoint.kt</kbd>:</strong></p>
<pre>@Component<br/>class AuthenticationEntryPoint : BasicAuthenticationEntryPoint() {<br/><br/>    @Throws(IOException::class, ServletException::class)<br/>    override fun commence(request: HttpServletRequest,<br/>                          response: HttpServletResponse,<br/>                          authEx: AuthenticationException) {<br/>        response.addHeader("WWW-Authenticate", "Basic realm=$realmName")<br/>        response.status = HttpServletResponse.SC_UNAUTHORIZED<br/>        val writer = response.writer<br/>        writer.println("HTTP Status 401 - " + authEx.message)<br/>    }<br/><br/>    @Throws(Exception::class)<br/>    override fun afterPropertiesSet() {<br/>        realmName = "packtpub ssbasicauth"<br/>        super.afterPropertiesSet()<br/>    }<br/>}</pre>
<p>Here, we've extended <kbd>BasicAuthenticationEntryPoint()</kbd>. This will return a full description of a <kbd>401 Unauthorized</kbd> response to the client. </p>
<p><kbd>401 Unauthorized Error</kbd> is an HTTP response status code. This indicates that the request sent by the client couldn't be authenticated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Spring WebApplicationInitializer</h1>
                
            
            
                
<p>A Spring <kbd>WebApplicationInitializer</kbd> uses a Servlet 3.0+ implementation to configure <kbd>ServletContext</kbd> programmatically.</p>
<p>Here's the sample code of the <kbd>WebApplicationInitializer</kbd> class, called<strong> <kbd>MyApplicationInitializer.kt</kbd>:</strong></p>
<pre>class MyApplicationInitializer: WebApplicationInitializer {<br/><br/>    @Throws(ServletException::class)<br/>    override fun onStartup(container: ServletContext) {<br/><br/>        val ctx = AnnotationConfigWebApplicationContext()<br/>        ctx.servletContext = container<br/>        <br/>        val servlet = container.addServlet("dispatcher", DispatcherServlet(ctx))<br/>        servlet.setLoadOnStartup(1)<br/>        servlet.addMapping("/")<br/>    }<br/>}</pre>
<p>This class will help to map the project URL path, <kbd>"\"</kbd>, using start. As we are using a code-based annotation in place of an XML configuration, we are using <kbd>AnnotationConfigWebApplicationContext</kbd>. </p>
<p> Then we have created and registered the dispatcher servlet.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a user model</h1>
                
            
            
                
<p>By accessing a simple REST API, we're creating a user model class. When the client inputs a correct username and password, this will return a simple JSON output of some user details.</p>
<p>Here is the code of <kbd>Users.kt</kbd>:</p>
<pre>class Users(<strong>val id: String,<br/>            val name: String,<br/>            val email: String,<br/>            val contactNumber: String</strong>)</pre>
<p> In this user model, we have an <kbd>id</kbd>, a <kbd>name</kbd>, an <kbd>email</kbd>, and a <kbd>contactNumber</kbd>. We'll create a JSON-type REST API that will be protected by our security system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a controller</h1>
                
            
            
                
<p>The controller class will map the URL path of the project. Here, we will use the <kbd>GET</kbd> or <kbd>POST</kbd> <kbd>HTTP</kbd> request functions to create the REST API. Here's a sample code of the controller of the project, named <strong><kbd>UserController.kt</kbd>:</strong></p>
<pre>@RestController<br/>class UserController {<br/><br/>    @GetMapping(path = ["/users"])<br/>    fun userList(): ResponseEntity&lt;List&lt;Users&gt;&gt;{<br/>        return ResponseEntity(getUsers(), HttpStatus.OK)<br/>    }<br/><br/>    private fun getUsers(): List&lt;Users&gt; {<br/>        val user = Users("1","Sunnat", "sunnat123@gmail.com", "0123456789")<br/>        val user1 = Users("2","Chaity", "chaity123@gmail.com", "1234567890")<br/>        val user2 = Users("3","Jisan", "jisan123@gmail.com", "9876543210")<br/>        val user3 = Users("4","Mirza", "mirza123@gmail.com", "5412309876")<br/>        val user4 = Users("5","Hasib", "hasib123@gmail.com", "5678901234")<br/><br/>        return Arrays.asList&lt;Users&gt;(user, user1, user2, user3, user4)<br/>    }<br/>}</pre>
<p>Here, we've created a user list of five people with the user model. In a controller, the <kbd>@RequestMapping</kbd> annotation is applied to the class level and/or the method level. This maps a particular request path onto a controller. With the <kbd>@GetMapping(path = ["/users"])</kbd> annotation, the client will send a <kbd>GET</kbd> request to get the list of the users if the Http status is <kbd>OK</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the HTTP client</h1>
                
            
            
                
<p>To see the output, open your third-party HTTP client tools. Here, we're using Insomnia. </p>
<p>After you run the project, open Insomnia.</p>
<p>Please follow these steps to test the project:</p>
<ol>
<li>Create a New Request with a name.</li>
<li>In the GET input box, put the <kbd>http://localhost:8080/user</kbd> URL. Here, <kbd>localhost:8080</kbd> is the root URL and as we use <kbd>@RequestMapping(path = ["/user"], method = [RequestMethod.GET])</kbd> in the controller class, the project will work under the <kbd>http://localhost:8080/user</kbd> path.</li>
<li>If you hit the Send button, you'll see an <kbd>HTTP Status 401 - Bad credentials</kbd> error, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d117a43c-a6bc-4e69-ab94-3b5758114780.png"/></p>
<p>Although you're using the basic authentication, you have to input a <strong>Username</strong> and <strong>Password</strong> to complete this request. You need to click on the Auth (second tab) and select <kbd>Basic</kbd> auth; you can enter the <strong>Username</strong> and <strong>Password</strong> there. If you input a random username and password, you'll also get the same error. </p>
<p>After entering the correct <strong>Username</strong> and <strong>Password</strong>, you'll get the list of the users in JSON format as output, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7f32d0f3-0f92-4f2a-82af-f4b5e82cc79e.png"/></p>
<p>You can also test in the browser. There, you'll be asked to input the <strong>Username</strong> and <strong>Password</strong>. </p>
<p>You can also use the browser to see the REST API:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/4baeb0f8-550c-40e2-ba42-9dd827b76de6.png"/> </p>
<p class="CDPAlignLeft CDPAlign">After inserting the username and password, we can see the user list:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/944f295e-d503-4c56-a601-0776e8922b25.png" style="width:31.42em;height:45.42em;"/></p>
<p>You've created a very simple project using Spring Security basic authentication. We hope that from now on you can write your own auth-based project with the help of Spring Security. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Android app</h1>
                
            
            
                
<p>It's time to create a simple Android app as a client that will retrieve the REST API from our base authentication server. First of all, we need to create an app from Android Studio and fill in your project name and the company domain. Don't forget to check <kbd>Include Kotlin support</kbd>. Here's a screenshot of the create application project window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/aabf30ec-8bc8-41b7-ae73-8591beadad9f.png"/></p>
<p>Select the minimum API version from the Phone and Tablet option. There's no need to add other options for this project. After clicking Next, you can select Empty Activity in the <strong>Add an Activity to Mobile</strong> window. After renaming the <strong>Activity Name</strong> and <strong>layout</strong>, click Finish. After building the gradle, you'll be ready to start creating an Android app.</p>
<p>Now, let's see how to implement the project's dependencies in Gradle.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle information</h1>
                
            
            
                
<p>In the Gradle file, mention the Kotlin dependency and the application Gradle version. Here are the details of my Android Studio's Gradle file:</p>
<pre>buildscript {<br/><strong>    ext.kotlin_version = '1.3.10'<br/></strong>    repositories {<br/>        google()<br/>        jcenter()<br/>    }<br/>    dependencies {<br/>        <strong>classpath 'com.android.tools.build:gradle:3.2.1'<br/>        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version</strong><strong>"</strong><br/><br/>        // NOTE: Do not place your application dependencies here; they belong<br/>        // in the individual module build.gradle files<br/>    }<br/>}<br/><br/>allprojects {<br/>    repositories {<br/>        google()<br/>        jcenter()<br/>    }<br/>}<br/><br/>task clean(type: Delete) {<br/>    delete rootProject.buildDir<br/>}</pre>
<p>Here, our Gradle version is <kbd>3.2.1</kbd> and the Kotlin version is <kbd>1.3.10</kbd></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gradle dependencies</h1>
                
            
            
                
<p>In this Gradle file, we'll implement the dependencies of Retrofit, which will help us to fetch the JSON-type REST API from our previous project. Here are all the dependencies:</p>
<pre>implementation 'com.android.support:appcompat-v7:27.1.1'<br/>implementation 'com.android.support.constraint:constraint-layout:1.1.3'<br/><br/>implementation 'com.google.code.gson:gson:2.8.5'<br/><br/>implementation 'com.squareup.retrofit2:retrofit:2.4.0'<br/>implementation 'com.squareup.retrofit2:converter-gson:2.4.0'<br/>implementation 'com.squareup.retrofit2:retrofit-converters:2.5.0'<br/>implementation 'com.squareup.retrofit2:retrofit-adapters:2.5.0'<br/>implementation 'com.squareup.okhttp3:logging-interceptor:3.12.0'</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a user model</h1>
                
            
            
                
<p>We'll fetch the REST API of our basic authentication-based Spring project, which was created using basic authentication. Although the REST API has four entities (<kbd>id</kbd>, <kbd>name</kbd>, <kbd>email</kbd>, and <kbd>contactNumber</kbd>), we'll create a model based on this REST API.</p>
<p>Here's the output of the REST API where we can see five users' details:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/26a0fb10-ac11-46cd-b71f-a3f08f20d12e.png" style="width:21.25em;height:35.00em;"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>According to the API, we'll create a user model for the client side. Here's the model class, named <strong><kbd>UserModel</kbd></strong><strong>:</strong></p>
<pre>class UserModel (<strong>val id: String<br/>                 val name: String,<br/>                 val contactNumber: String,<br/>                 val id: String,<br/>                 val email: String</strong>)</pre>
<p>Now, we need to create an interface that will have the HTTP request functions. In this project, we'll only use a <kbd>GET</kbd> function that retrieves all the details of users. Here, we're using the <kbd>GET</kbd> retrofit annotation to encode details about the parameters and request function.</p>
<p>Here's the code of the <kbd>UserService</kbd> interface:</p>
<pre>interface UserService {<br/><strong>    @GET("/user")</strong><br/>    fun getUserList(): Call&lt;List&lt;UserModel&gt;&gt;<br/>}</pre>
<p>We'll search the <kbd>/user</kbd> endpoint and this will provide a list of user models.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the user service</h1>
                
            
            
                
<p>Retrofit client calls the Gerrit API and handles the result by printing the result of the call to the console.</p>
<p>Create a class where we'll build a Retrofit client, and this will call the API and handle the result. This will be responsible for controlling all the tasks using the <kbd>Retrofit.builder</kbd> class and configuring it with the base of the given URL.   </p>
<p>Here's the code of <kbd>UserServiceImpl.kt</kbd>:</p>
<pre>class UserServiceImpl{<br/>   fun getGithubServiceImpl(username:String, password:String): UserService {<br/>        val retrofit = Retrofit.Builder()<br/>                .client(getOkhttpClient(username, password))<br/>                .baseUrl(<strong>YOUR_SERVER_DOMAIN</strong>)<br/>                .addConverterFactory(GsonConverterFactory.create())<br/>                .build()<br/>        return retrofit.create(UserService::class.java)<br/>    }<br/><br/>    private fun getOkhttpClient(username:String, password:String): OkHttpClient{<br/>        return OkHttpClient.Builder()<br/>                .addInterceptor(BasicAuthInterceptor(username, password))<br/>                .build()<br/>    }<br/>}</pre>
<p>According to this code, we set <kbd>.client()</kbd> with <kbd>username</kbd> and <kbd>password</kbd>. Then we implemented the <kbd>YOUR_SERVER_DOMAIN</kbd> (assume the URL of the Rest API server is <strong><kbd>http://localhost:8080</kbd></strong>), <kbd>baseUrl() </kbd>, and we've used  <kbd>OkHttpClient</kbd> as the client. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authenticating with OkHttp interceptors</h1>
                
            
            
                
<p>Although we're using a base authentication security, we need a <kbd>username</kbd> and <kbd>password</kbd> to grant access to this REST API. Here, we're using <kbd>OkHttp</kbd> interceptors for authentication. This will help you to send a request and get the auth permission to access the resources.</p>
<p>Here, we've called the <kbd>BasicAuthInterceptor</kbd> class in <kbd>OkHttpClient.Builder()</kbd>:</p>
<pre> private fun getOkhttpClient(username:String, password:String): OkHttpClient{<br/>        return OkHttpClient.Builder()<br/>                .addInterceptor(<strong>BasicAuthInterceptor</strong>(<strong>username, password</strong>))<br/>                .build()<br/>    }</pre>
<p>Here's the class of <kbd>BasicAuthInterceptor.kt</kbd>:</p>
<pre>class BasicAuthInterceptor(user: String, password: String) : Interceptor {<br/><br/>    private val credentials: String = Credentials.basic(user, password)<br/><br/>    @Throws(IOException::class)<br/>    override fun intercept(chain: Interceptor.Chain): Response {<br/>        val request = chain.request()<br/>        val authenticatedRequest = request.newBuilder()<br/>                .header("Authorization", credentials).build()<br/>        return chain.proceed(authenticatedRequest)<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>In this class, only the credentials are added as your user details. Here, a client will make a request using the <kbd>username</kbd> and <kbd>password</kbd> credentials. During every request, this interceptor acts before it's performed and alters the request header. Consequently, you don't need to add <kbd>@HEADER("Authorization")</kbd> to the API function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calling callbacks</h1>
                
            
            
                
<p>Here, we're calling <kbd>CallBack&lt;&gt;</kbd> from <kbd>MainActivity</kbd>. This callback response comes from a server or offline requests. This means returning the result of a long-running function at a later moment in time.</p>
<p>Check the <kbd>MainActivity.kt</kbd> code to use the <kbd>CallBack</kbd> function and handle the result:</p>
<pre>class MainActivity : AppCompatActivity() {<br/><br/>    var username: String = "sunnat629"<br/>    var password: String = "password"<br/><br/>    override fun onCreate(savedInstanceState: Bundle?) {<br/>        super.onCreate(savedInstanceState)<br/>        setContentView(R.layout.activity_main)<br/><br/>        val githubService: UserService = UserServiceImpl().getGithubServiceImpl(username,password)<br/><br/>        val call: Call&lt;List&lt;UserModel&gt;&gt; = githubService.getUserList()<br/>        call.enqueue(object: Callback&lt;List&lt;UserModel&gt;&gt; {<br/>            override fun onFailure(call: Call&lt;List&lt;UserModel&gt;&gt;, t: Throwable) {<br/>                Log.wtf("PACKTPUB", t.message)<br/>            }<br/><br/>            override fun onResponse(call: Call&lt;List&lt;UserModel&gt;&gt;, response: Response&lt;List&lt;UserModel&gt;&gt;) {<br/>                val adapter = UserListAdapter(this@MainActivity, response.body())<br/>                displayList.adapter = adapter<br/>            }<br/>        })<br/>    }<br/>}</pre>
<p>Let's discuss the preceding code as follows:</p>
<ol>
<li>First, we need to initialize <kbd>UserServiceImpl().getGithubServiceImpl(username,password)</kbd> so that we can call <kbd>getUserList()</kbd> from <kbd>UserService</kbd>.</li>
<li>Then we'll call <kbd>enqueue(retrofit2.Callback&lt;T&gt;)</kbd>, which will be executed asynchronously, send the request, and get the response.</li>
<li><kbd>enqueue()</kbd> has two functions: <kbd>onResponse()</kbd> and <kbd>onFailure()</kbd>. If there are any server-related errors, it will call <kbd>onFailure()</kbd>, and if it gets the response and the resources, it will call <kbd>onResponse()</kbd>. We can also use the resource of the <kbd>onResponse()</kbd> function.</li>
</ol>
<p>Here, we'll get a response of the <kbd>UserModel</kbd> list. We can show the list in our application UI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the UI</h1>
                
            
            
                
<p>In the created <kbd>main_activity</kbd> layout, we'll show a list of the user details where we show the name, email ID, and contact number of a user—we'll use <kbd>ListView</kbd>.</p>
<p>Here's the code of the <kbd>mainActivity</kbd> layout of the <kbd>MainActivity</kbd> class:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/textView"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:text="@string/user_title"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        android:textStyle="bold"<br/>        android:padding="5dp"<br/>        android:gravity="center_horizontal"<br/>        android:textAppearance="?android:textAppearanceLarge"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent" /&gt;<br/><br/>    &lt;ListView<br/>        android:id="@+id/displayList"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_marginStart="8dp"<br/>        android:layout_marginLeft="8dp"<br/>        android:layout_marginTop="8dp"<br/>        android:layout_marginEnd="8dp"<br/>        android:layout_marginRight="8dp"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toBottomOf="@+id/textView" /&gt;<br/><br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>In this layout, we have one <kbd>TextView</kbd> and one <kbd>ListView</kbd>.</p>
<p>We'll use this <kbd>ListView</kbd> in the <kbd>onResponse()</kbd> function of <kbd>MainActivity</kbd>. </p>
<p>We'll get the list and create a custom adapter to show the user list, as follows:</p>
<pre>val adapter = UserListAdapter(this@MainActivity, <br/>response.body()//this is a arraylist <br/>)</pre>
<p>Here, we have a custom adapter where we'll send the context and the <kbd>Array</kbd> list of the users. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a custom list adapter</h1>
                
            
            
                
<p>To show the output of the REST API, we need to create a custom list adapter and so we need to design an XML file of the custom list adapter. Here's the XML code for each row in the list:</p>
<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    android:padding="10dp"&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/name"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:gravity="center_horizontal"<br/>        android:padding="5dp"<br/>        android:textAppearance="?android:textAppearanceMedium"<br/>        android:textStyle="bold"<br/>        app:layout_constraintBottom_toTopOf="@+id/contactNumber"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toTopOf="parent"<br/>        tools:text="@tools:sample/full_names" /&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/contactNumber"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:gravity="center_horizontal"<br/>        android:padding="5dp"<br/>        android:textAppearance="?android:textAppearanceSmall"<br/>        app:layout_constraintBottom_toTopOf="@+id/email"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toBottomOf="@+id/name"<br/>        tools:text="@tools:sample/cities" /&gt;<br/><br/>    &lt;TextView<br/>        android:id="@+id/email"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:gravity="center_horizontal"<br/>        android:padding="5dp"<br/>        android:textAppearance="?android:textAppearanceSmall"<br/>        app:layout_constraintEnd_toEndOf="parent"<br/>        app:layout_constraintStart_toStartOf="parent"<br/>        app:layout_constraintTop_toBottomOf="@+id/contactNumber"<br/>        tools:text="@tools:sample/cities" /&gt;<br/><br/><br/>&lt;/android.support.constraint.ConstraintLayout&gt;</pre>
<p>Here, we have a <kbd>TextView</kbd> of <kbd>name</kbd>, <kbd>contactNumber</kbd>, and <kbd>email</kbd>.</p>
<p>After that, we'll create the adapter, named <kbd>UserListAdapter.kt</kbd>,<strong> </strong>as follows:</p>
<pre>class UserListAdapter(context: Context,<br/>                      private val userList: List&lt;UserModel&gt;?) : BaseAdapter() {<br/>    private val inflater: LayoutInflater = context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)<br/>            as LayoutInflater<br/>    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {<br/>        val rowView = inflater.inflate(R.layout.user_list_item, parent, false)<br/>        val name = rowView.findViewById(R.id.name) as TextView<br/>        val email = rowView.findViewById(R.id.email) as TextView<br/>        val contactNumber = rowView.findViewById(R.id.contactNumber) as TextView<br/>        val userDetails = getItem(position) as UserModel<br/>        name.text = userDetails.name<br/>        email.text = userDetails.email<br/>        contactNumber.text = userDetails.contactNumber<br/>        return rowView<br/>    }<br/>    override fun getItem(position: Int): Any {<br/>        return userList!![position]<br/>    }<br/>    override fun getItemId(position: Int): Long {<br/>        return position.toLong()<br/>    }<br/>    override fun getCount(): Int {<br/>        return userList!!.size<br/>    }<br/>}</pre>
<p>This class extends <kbd>BaseAdapter()</kbd>, which will add several inherited functions. </p>
<p>Then you need to add <kbd>LayoutInflater</kbd>, which converts the XML layout into corresponding <kbd>ViewGroups</kbd> and Widgets:<strong> </strong></p>
<ul>
<li><kbd>getView()</kbd> creates a view for a row of the list. Here, you'll define all the UI-based information.</li>
<li><kbd>getItem()</kbd> returns the position of the list that's obtained from the server.</li>
<li><kbd>getItemId()</kbd> defines a unique ID for each row in the list.</li>
<li><kbd>getCount()</kbd> returns the size of the list.</li>
</ul>
<p>Now, in <kbd>getView()</kbd>, you'll add the element of the layout, as follows:</p>
<pre> val name = rowView.findViewById(R.id.name) as TextView<br/>        val email = rowView.findViewById(R.id.email) as TextView<br/>        val contactNumber = rowView.findViewById(R.id.contactNumber) as TextView</pre>
<p>You should never perform long-running tasks on the main thread. This will result in an Application Not Responding (ANR).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mobile applications</h1>
                
            
            
                
<p>Once we've completed our code, it's time to see the output. Run your basic authentication Spring project and then run your app. Here's the output of your app, where we can see the user details:</p>
<div><img src="img/bb1d3a80-1f6b-4d39-9de8-b3a746152d48.png" style="width:18.83em;height:34.33em;"/></div>
<p>In the following screenshot, the left side is the server API, where we have the user details, and on the right we have the client output of the Android application:</p>
<div><img src="img/2deb9410-34b7-440c-9604-1e9e61a024d0.png"/></div>
<p>We've created a client application that will fetch the data of a basic authentication Spring-Security-based REST API.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing REST with Spring Security OAuth2</h1>
                
            
            
                
<p>In the last section, we learned how to make a basic authorization project. This provides solid security for a project, but it doesn't have the dimension of security required for a complex or enterprise-level project. Since this security can be broken or hacked, we require a more grounded security framework to handle these sorts of hacking. OAuth is one of the best security frameworks – it's exceedingly utilized by Google, Facebook, Twitter, and many other popular platforms. Now we'll learn about OAuth2 and its use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is OAuth2?</h1>
                
            
            
                
<p><strong>OAuth</strong> is a safe authorization convention, and <strong>OAuth2</strong> is the second form of the OAuth protocol. This protocol is called a <strong>framework</strong>. OAuth2 enables a third-party application to provide limited access to an HTTP service, such as Google, GitHub, or Twitter. This access is either intended for the benefit of the proprietor or to enable the third-party application to get access to the user account. This creates an authorization stream between web and desktop or mobile devices. It has some important roles that control the users' access limitation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">OAuth2 Roles</h1>
                
            
            
                
<p>There are four roles in OAuth2:</p>
<ul>
<li><strong>Resource Owner</strong>: Normally, this is you.</li>
<li><strong>Resource Server</strong>: The server host's protected data. For example, Google, Github, or Twitter hosts your personal and professional information. </li>
<li><strong>Client</strong>: An application that requests a resource server to access data. The client can be a website, a desktop application, or even a mobile application.</li>
<li><strong>Authorization Server</strong>: This server will issue an access token to the client. This token will be the key to accessing the information and it's mainly used to request the resource server for the client.</li>
</ul>
<p>Here's a diagram of the general workflow of the OAuth protocol (the flow isn't fixed for every protocol; it's based on the type of authorization granted):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3a2aa391-2ab8-4090-bee9-6ed59fd69490.png" style="width:29.33em;height:27.08em;"/></p>
<p>Here are the steps of the workflow:</p>
<ol>
<li>To access the service resources, the <strong>Application</strong> sends the <strong>Authorization Request</strong> to the <strong>User</strong>.</li>
<li> The <strong>Application</strong> receives an <strong>Authorization Grant</strong> if the <strong>User</strong> authorizes the request.</li>
<li>The <strong>Application</strong> sends the grant to the <strong>Authorization Server</strong> for an <strong>Access Token</strong>.</li>
<li>If the <strong>Authorization Grant</strong> is valid and the <strong>Application</strong> is authenticated, the <strong>Authorization Server</strong> creates an <strong>Access Token</strong>.</li>
<li>The <strong>Application</strong> gets the <strong>Access Token</strong> from the <strong>Authorization Server</strong>.</li>
<li>The application sends a request to the <strong>Resource Server</strong> for resources from the server as well as authentication.</li>
<li>Using the token, the <strong>Resource Server</strong> provides the requested recourses to the <strong>Application</strong>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">OAuth2 grant types</h1>
                
            
            
                
<p class="mce-root">There are four kinds of OAuth2 Grants:</p>
<ul>
<li><strong>Authorization Code:</strong> This is used in a server-side application and allows the client to get a long-lasting access token. However, this token will be invalidated if the client asks the server for a new token.</li>
<li class="mce-root"><strong>Implicit:</strong> For the most part, this is utilized with mobile or web applications. </li>
<li class="mce-root"><strong>Resource Owner Password Credentials:</strong> In this grant, the credentials are first sent to the customer. Then they're sent to the authorization server. </li>
<li class="mce-root"><strong>Client Credentials:</strong> This is used when the client itself is the resource owner. There's no authorization to get from the client's end.</li>
</ul>
<p>So, that's a brief summary of the OAuth protocol. Now let's create a project using the Spring Security OAuth2 modules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a project</h1>
                
            
            
                
<p class="mce-root">We'll create a simple Spring Security OAuth2-based project. To do so, go to <a href="https://start.spring.io/">https://start.spring.io/</a> and modify the given field with your requirement. </p>
<p class="mce-root">Here, we're using the Maven Project and selecting the language as Kotlin. The Spring Boot version is 2.1.1 (SNAPSHOT).</p>
<p>After you select Generate Project, you'll get the project as a ZIP file. Unzip and open this project with your IDE.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maven dependencies</h1>
                
            
            
                
<p>Our main dependencies are <kbd>Web</kbd>, <kbd>Security</kbd>, <kbd>Cloud Security</kbd>, <kbd>Cloud OAuth2</kbd>, <kbd>JPA</kbd>, <kbd>H2</kbd>, <kbd>Lombok</kbd>, and <kbd>Thymeleaf</kbd>.</p>
<p class="mce-root">Here are the mentioned Maven dependencies in <kbd>pom.xml</kbd>:</p>
<pre>----<br/>----<br/>  &lt;dependencies&gt;<br/>---<br/>---<br/>&lt;!--spring security--&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;<br/>    &lt;version&gt;5.2.0.BUILD-SNAPSHOT&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><br/>&lt;!--spring cloud security--&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-cloud-starter-security&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/><br/>----<br/>----<br/><br/>&lt;!--database--&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br/>    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>    &lt;scope&gt;runtime&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>----<br/>----</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring the resource server</h1>
                
            
            
                
<p>A resource server will have all the protected resources, and these are protected by the OAuth2 token. It's time to learn about this resource server with the help of the code. Create a resource server named  <strong><kbd>ResourceServerConfig.kt</kbd></strong>. </p>
<p>Here is the code of our <strong><kbd>ResourceServerConfig.kt</kbd></strong>:</p>
<pre>@Configuration<br/>@EnableResourceServer<br/>class ResourceServerConfig: ResourceServerConfigurerAdapter(){<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(http: HttpSecurity?) {<br/>        http!!<br/>                .authorizeRequests()<br/>                .antMatchers("/open_for_all").permitAll() // anyone can enter<br/>                .antMatchers("/private").authenticated() // only authorized user can enter<br/>    }<br/>}</pre>
<p>To enable the features of the OAuth 2.0 resource-server mechanism, you need to add an annotation named <kbd>@EnableResourceServer</kbd>, and although it's a configuration class, you need to add the <kbd>@Configuration</kbd> annotation.</p>
<p>This class extends <kbd>ResourceServerConfigurerAdapter</kbd>, this then extends <kbd>ResourceServerConfigurer</kbd>, which will make it possible to override and configure <kbd>ResourceServerConfigurer</kbd>.</p>
<p>We override <kbd>configure(http: HttpSecurity?)</kbd>, where we mention which URL paths are protected and which are not protected.</p>
<p><kbd>authorizeRequests()</kbd> permits confining access dependent on the utilization of <kbd>HttpServletRequest</kbd>.</p>
<p><kbd>antMatchers()</kbd> refers to the implementation of the Ant-style path patterns in mappings.</p>
<p>We use <kbd>.antMatchers("/").permitAll()</kbd>, which allows all users to access this URL path, <kbd>"/"</kbd>. In addition, we use <kbd>.antMatchers("/private").authenticated()</kbd>, which means a user needs a token to access this <kbd>/private</kbd> path.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring the authorization server</h1>
                
            
            
                
<p>An authorization server is a configuration class. In this class, we'll create a grant-type environment. A grant type helps a client get an access token from the end user. This server's configuration is designed to implement the client details' service and token service. It's also responsible for enabling or disabling certain components of the mechanism globally. Now, create an authorization server class named <kbd>AuthorizationServerConfig.kt</kbd>. </p>
<p>Here's the code for <kbd>AuthorizationServerConfig.kt</kbd>:</p>
<pre><strong>@Configuration<br/></strong><strong>@EnableAuthorizationServer</strong><br/>class AuthorizationServerConfig: AuthorizationServerConfigurerAdapter() {<br/><br/>   @Autowired<br/>   lateinit var authenticationManager: AuthenticationManager<br/><br/>    @Autowired<br/>    lateinit var passwordEncoder: BCryptPasswordEncoder<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(security: AuthorizationServerSecurityConfigurer?) {<br/>        security!!.checkTokenAccess("isAuthenticated()")<br/>    }<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(clients: ClientDetailsServiceConfigurer?) {<br/>       clients!!<br/>               .inMemory()<br/>               .withClient("client")<br/>               .secret(passwordEncoder.encode("secret"))<br/>               .authorizedGrantTypes("password")<br/>               .authorities("ROLE_CLIENT", "ROLE_TRUSTED_CLIENT")<br/>               .scopes("read", "write", "trust")<br/>               .resourceIds("oauth2-resource")<br/>               .accessTokenValiditySeconds(5000) // token validity time duration 5 minuets<br/><br/>    }<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(endpoints: AuthorizationServerEndpointsConfigurer?) {<br/>        endpoints!!.authenticationManager(authenticationManager)<br/>    }<br/>}</pre>
<p>The <kbd>@EnableAuthorizationServer</kbd> annotation enables the features of the OAuth 2.0 authorization server mechanism. You need to add the <kbd>@Configuration</kbd> annotation to make it the configuration class.</p>
<p>This class extends <kbd>AuthorizationServerConfigurerAdapter</kbd>, which then extends <kbd>ResourceServerConfigurer</kbd>. It will make it possible to override and configure <kbd>AuthorizationServerConfigurer</kbd>. There are three types of <kbd>configure()</kbd> functions:</p>
<ul>
<li><kbd>ClientDetailsServiceConfigurer</kbd>: This defines the details service of a client.</li>
<li><kbd>AuthorizationServerSecurityConfigurer</kbd>: This defines the security constraints on the token endpoint.</li>
<li><kbd>AuthorizationServerEndpointsConfigurer</kbd>: This defines the authorization and token endpoints and the token services.</li>
</ul>
<p>According to our code, in <kbd>configure(security: AuthorizationServerSecurityConfigurer?)</kbd>, we define whether or not to check the token endpoint which is authenticated.</p>
<p>In <kbd>configure(clients: ClientDetailsServiceConfigurer?)</kbd>, we define the <kbd>ClientDetails</kbd> service. In this project, we didn't use a database, so we use an in-memory implementation of the <kbd>ClientDetails</kbd> service. Here are the important attributes of the client:</p>
<ul>
<li><kbd>withClient()</kbd>: This is required and this is where we define the client ID, <kbd>"client"</kbd>.</li>
<li><kbd>secret()</kbd>: This is required for trusted clients and is where we define the secret, <kbd>"secret"</kbd>, but we have to encode the password. Here, we inject <kbd>BCryptPasswordEncoder</kbd> to encode the password or secret key.</li>
<li><kbd>authorizedGrantTypes()</kbd>: We have used the <kbd>"password"</kbd> grant type that's authorized for the client to use. </li>
<li><kbd>scope()</kbd>: The scope is used to limit the access for the resources of a client. If the scope is undefined or empty, that means the client isn't limited by scope. Here, we use <kbd>"read"</kbd>, <kbd>"write"</kbd>, and <kbd>"trust"</kbd>.</li>
<li><kbd>authorities()</kbd>: This is used to grant the client.</li>
<li><kbd>resourceId()</kbd>: This optional ID is used for the resource. </li>
<li><kbd>accessTokenValiditySeconds()</kbd>: This refers to the token validity time duration.</li>
</ul>
<p>In <kbd>configure(endpoints: AuthorizationServerEndpointsConfigurer?)</kbd>, we've configured <kbd>AuthorizationEndpoint</kbd>, which supports the grant type. We inject <kbd>AuthenticationManager</kbd> and configure it via <kbd>AuthorizationServerEndpointsConfigurer</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the security config</h1>
                
            
            
                
<p>This is a Java configuration class for Spring Security that enables users to configure Spring Security easily without the use of XML. Create a secure config file named <kbd>SecurityConfiguration.kt</kbd>. Here's the code for the class:</p>
<pre>@Configuration<br/>@EnableWebSecurity<br/>class SecurityConfiguration: WebSecurityConfigurerAdapter() {<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(auth: AuthenticationManagerBuilder?) {<br/>        auth!!<br/>                .inMemoryAuthentication()<br/>                .passwordEncoder(passwordEncoder())<br/>             // user1 as USER<br/>                .withUser("sunnat")<br/>                .password(passwordEncoder().encode("password"))<br/>                .roles("USER")<br/>                .and()<br/><br/>                // user2 as ADMIN<br/>               .withUser("admin")        <br/>               .password(passwordEncoder().encode("password"))<br/>                .roles("ADMIN")<br/>    }<br/><br/>    @Throws(Exception::class)<br/>    override fun configure(http: HttpSecurity?) {<br/>        http!!<br/>                .antMatcher("/**").authorizeRequests()<br/>                .anyRequest().authenticated()<br/>                .and()<br/>                .formLogin()<br/>                .and()<br/>                .httpBasic()<br/>    }<br/><br/>    @Bean(name = [BeanIds.AUTHENTICATION_MANAGER])<br/>    @Throws(Exception::class)<br/>    override fun authenticationManagerBean(): AuthenticationManager {<br/>        return super.authenticationManagerBean()<br/>    }<br/><br/><br/>    @Bean<br/>    fun passwordEncoder(): BCryptPasswordEncoder {<br/>        return BCryptPasswordEncoder(16)<br/>    }<br/>}</pre>
<p>This is a configuration class, so you need to add the <kbd>@Configuration</kbd> annotation. </p>
<p>This class extends <kbd>WebSecurityConfigurerAdapter</kbd>, and the <kbd>@EnableWebSecurity</kbd> annotation provides the web-based security mechanism.  </p>
<p>According to this code, we use two <kbd>@Bean</kbd> annotations in the required functions. We inject <kbd>AuthenticationManager</kbd> and configure it via <kbd>AuthorizationServerEndpointsConfigurer</kbd>. The <kbd>BCryptPasswordEncoder</kbd> instance is used to encode the passwords.</p>
<p>In <kbd>configure(http: HttpSecurity?)</kbd>, note the following:</p>
<ul>
<li><kbd>antMatcher("/**").authorizeRequests()</kbd> means that this <kbd>HttpSecurity</kbd> will only be applicable to URLs that start with <kbd>/**</kbd>.</li>
<li><kbd>anyRequest().authenticated()</kbd> utilization guarantees that any request to our application requires the client to be confirmed.</li>
<li><kbd>formLogin()</kbd> allows users to authenticate with form-based logins.</li>
<li><kbd>httpBasic()</kbd> means the user is validated with HTTP Basic authentication.</li>
</ul>
<p class="mce-root">In <kbd>configure(auth: AuthenticationManagerBuilder?)</kbd>, note the following:</p>
<ul>
<li><kbd>inMemoryAuthentication()</kbd> includes memory confirmation to <kbd>AuthenticationManagerBuilder</kbd> and restores <kbd>InMemoryUserDetailsManagerConfigurer</kbd> to permit customization of the in-memory validation.</li>
<li><kbd>passwordEncoder(passwordEncoder())</kbd> means that the password will be an encoded password.</li>
<li><kbd>withUser("user")</kbd> and <kbd>withUser("admin")</kbd> is the name of the user.</li>
<li><kbd>password(passwordEncoder().encode("password"))</kbd> is the encoded password.</li>
<li><kbd>roles("USER")</kbd> and <kbd>roles("ADMIN")</kbd> is the role of a user.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the controller class</h1>
                
            
            
                
<p>Create a controller class named <kbd>UserController.kt</kbd>, as follows:</p>
<pre>@RestController<br/>@RequestMapping("/")<br/>class UserController{<br/><br/>//    This is for all means there is no security issue for this URL path<br/>    @GetMapping(value = ["/open_for_all", ""])<br/>    fun home(): String{<br/>        return "This area can be accessed by all."<br/>    }<br/><br/>    //    Yu have to use token to get this URL path<br/>    @GetMapping("/private")<br/>    fun securedArea(): String{<br/>        return "You used an access token to enter this area."<br/>    }<br/>}</pre>
<p>Here, we've annotated this class as <kbd>@RestController</kbd>, which handles all the web requests. <kbd>@RequestMapping("/")</kbd> means that the default URL path is <kbd>"/"</kbd>.</p>
<p>The <kbd>@GetMapping</kbd> implemented functions are <kbd>home()</kbd>, which can be accessed by everyone, and <kbd>securedArea()</kbd>, which can be accessed only by those who have the <em>access token</em>. We configured these in the <kbd>ResourceServerConfig</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the application class</h1>
                
            
            
                
<p>Lastly, create the application class, named <kbd>SpringSecurityOAuth2Application.kt</kbd>, which will convert your application into a SpringBoot application:</p>
<pre>@SpringBootApplication<br/>class SpringSecurityOAuth2Application<br/><br/>fun main(args: Array&lt;String&gt;) {<br/>    runApplication&lt;SpringSecurityOAuth2Application&gt;(*args)<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Application properties</h1>
                
            
            
                
<p>This step is optional, particularly in this project. Here, we just change the port number for this project. To change it, modify <kbd>application.properties</kbd> under the <kbd>resources</kbd><strong> </strong>folder:</p>
<pre>#this project server port<br/>server.port=8081</pre>
<p>Here, we change the port number to <kbd>8081</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking the output</h1>
                
            
            
                
<p>If you're reading this section, that means you've configured everything correctly. After finishing the project, you'll have these files:</p>
<p>After completing the setup, run the project. If there are no errors, you can find the run<strong> </strong>window. The following screenshot shows that there are no errors and the application is ready to use:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6e2f5ec2-e29c-4641-8b42-0288911faa18.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking unprotected URLs</h1>
                
            
            
                
<p>Now, open the <em>Insomnia</em> application.</p>
<p>Create a <kbd>GET</kbd> request from the top inbox and use the <kbd>http://localhost:8081/open_for_all</kbd> URL.</p>
<p>Your result will look like the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/956bc690-72ea-4a2e-b902-eec4e709ee8a.png"/></p>
<p>In the <kbd>ResourceServerConfig</kbd> class, we configured that <kbd>"/open_for_all"</kbd> can be accessed by everyone.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting access tokens</h1>
                
            
            
                
<p>Create a <kbd>POST</kbd> request from the top inbox and put down the <kbd>http://localhost:8081/oauth/token</kbd> URL. This is the default <kbd>POST</kbd> <em>URL</em> to get the token.</p>
<p>Add three parameters—<kbd>username=sunnat</kbd>, <kbd>password=password</kbd>, and <kbd>grant_type=password—</kbd>in the Multipart window:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b79568f5-19bf-4d32-b9c1-7f582311a7f4.png" style="width:38.67em;height:18.67em;"/></p>
<p>You can find the information of <kbd>username</kbd> and <kbd>password</kbd> in the <kbd>SecurityConfiguration</kbd> class, and <kbd>grant_type</kbd> will be found in <kbd>AuthorizationServerConfig</kbd>. Here, we're using the <strong>password</strong> grant type.</p>
<p>Go to the <strong>Basic</strong> window and input the <strong>username</strong> and <strong>password</strong>. You can find this information in the <kbd>AuthorizationServerConfig</kbd> class, where the username is mentioned in <kbd>withClient()</kbd> and the password is <kbd>secret()</kbd>.</p>
<p>We added an image of the Insomnia tool where we wrote down the <strong>username</strong> and <strong>pass</strong><strong>word. </strong>Now click the send button. If there are no errors, you'll get the following <kbd>access_token</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/2fb2b231-90a0-4d9e-af22-e2249b6e8482.png" style="width:74.00em;height:25.25em;"/></p>
<p>You can see the <kbd>access_token</kbd> that will be used to access the protected resources. <kbd>expires_in</kbd> means that after <kbd>4469</kbd> seconds the token will expire. <kbd>"scope": "read write trust"</kbd> means you can read, write, and modify the resources.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing the protected URL</h1>
                
            
            
                
<p>We found the <kbd>access_token</kbd> and now we'll use it. To do this, create another <kbd>GET</kbd> request and insert <kbd>http://localhost:8081/private</kbd>.</p>
<p>As a parameter, use <kbd>access_token</kbd> with the value of the given token key, and click Send:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/a4b3e161-225e-4b04-bef5-76bdb512aa5f.png"/></p>
<p>Once that's done, you can access the <kbd>/private</kbd> URL, which is protected and configured in the <kbd>ResourceServerConfig</kbd> class.</p>
<p>We're now ready to use the OAuth2 Spring Security in our project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Common mistakes and errors</h1>
                
            
            
                
<p>During this project, you may encounter some common errors. </p>
<p>For example, you might get some errors during building and running the project. To solve this, check that all versions of the dependencies are the latest. In addition, check whether every dependency is present. If you use the database, make sure you have the correct database and scheme name in <kbd>application.properties</kbd>.</p>
<p>In the <kbd>POST</kbd> request, sometimes you can find the following error message:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/d1d5e9c8-90b9-4bae-b247-5bf90ca2d651.png" style="width:24.67em;height:5.25em;"/></p>
<p>The previous screenshot indicates that you entered an incorrect <kbd>grant_type</kbd>. Please check the parameter, as well as the <kbd>AuthorizationServerConfig</kbd> class where you mention the <kbd>grant_type</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e36835a3-80c0-47dc-a8dc-c52f7499284b.png" style="width:22.83em;height:10.33em;"/></p>
<p>Please check the <kbd>SecurityConfiguration</kbd> class and match the system <kbd>username-password</kbd> with the given <kbd>username</kbd> and <kbd>password</kbd> parameters. The following screenshot means you entered an incorrect client or secret value in the <kbd>Basic Auth</kbd> tab:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6ed25197-c442-4fb8-ae9b-3cdc26f076d0.png" style="width:22.92em;height:12.58em;"/></p>
<p>The preceding screenshot means you entered an incorrect <kbd>client</kbd> or <kbd>secret</kbd> value in the Basic Auth tab.<strong> </strong>Please match the <kbd>client</kbd> and <kbd>secret</kbd> value from <kbd>AuthorizationServerConfig</kbd> and the <kbd>Basic Auth</kbd> tab's value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ac63e400-14b3-44c0-92ab-5334b51000df.png" style="width:37.58em;height:10.00em;"/></p>
<p>The preceding screenshot means your token key has expired. You need to refresh a new access token to solve this error.</p>
<p>You may face some other errors. To see the solutions, you can always search StackOverflow (<a href="https://stackoverflow.com/">https://stackoverflow.com/</a>). </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you learned how to use Spring Security with confidence. First, we covered what Spring Security is as well as its architecture. We also learned about the advantage of using Spring Security, looking at its features and modules. Now, we're able to implement Spring Security in any project. We learned what the basic authentication is and, using an example, we saw how to implement the basic authentication in a project as well as how to secure the resources in a server. We also learned how to create a secured REST API. Then we learned how to create a client application in Android to fetch and use the protected resources from the REST API. We also learned how to implement a username and password to get access to the basic authentication-based secured server. In addition, we familiarized ourselves with how to use a custom adapter in a listview in the client application. In the last section, we explored a better-secured protocol: OAuth2. We learned the role and workflow of this protocol. With a simple project, we learned how to configure the OAuth2 authorization and resource servers. Finally, we saw how to retrieve the REST API using a third-party HTTP client.</p>
<p>In the next chapter, we'll learn about the database, which is very important, as it's the main place to store and handle your data.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What does Spring Security target?</li>
<li>What are the fundamental classes of Spring Security?</li>
<li>Which filter class is required for Spring Security?</li>
<li>Is password hashing supported in Spring Security?</li>
<li>What are the OAuth 2.0 Grant Types?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Here is a list of information you can refer to:</p>
<ul>
<li><em>Spring Security - Third Edition</em> (<a href="https://www.packtpub.com/application-development/spring-security-third-edition">https://www.packtpub.com/application-development/spring-security-third-edition</a>) by Mick Knutson, Robert Winch, Peter Mularien</li>
<li><em>Hands-On Spring Security 5 for Reactive Applications</em> (<a href="https://www.packtpub.com/application-development/hands-spring-security-5-reactive-applications">https://www.packtpub.com/application-development/hands-spring-security-5-reactive-applications</a>) by Tomcy John</li>
<li><em>OAuth 2.0 Cookbook</em> (<a href="https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook">https://www.packtpub.com/virtualization-and-cloud/oauth-20-cookbook</a>) by Adolfo Eloy Nascimento</li>
</ul>


            

            
        
    </body></html>