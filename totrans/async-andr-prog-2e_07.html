<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Exploring the JobScheduler API</h1></div></div></div><p>So far, we have been scheduling background work using a time condition in the Handler facilities for the short-term future, and the Android Alarm Manager for the long-term future.</p><p>Those APIs that are able to execute future tasks at an exact and inexact time in the future are used to trigger events, refresh data in the background, or execute tasks without user intervention. AlarmManager, which we covered in detail in the previous chapter, is able to wake up the device from deep idle states and execute work even without considering the device's battery state.</p><p>In this chapter, we will learn how to work with JobScheduler to execute jobs in the background when several prerequisites are fulfilled and taking into account the energy consumption context of the device.</p><p>In this chapter, we will cover the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to JobScheduler</li><li class="listitem" style="list-style-type: disc">Setting the JobScheduler running criteria</li><li class="listitem" style="list-style-type: disc">Controlling the execution of your job with criteria</li><li class="listitem" style="list-style-type: disc">How to schedule work with JobService</li><li class="listitem" style="list-style-type: disc">Executing repeating tasks with JobScheduler</li><li class="listitem" style="list-style-type: disc">Retrieving the list of pending JobScheduler schedules</li><li class="listitem" style="list-style-type: disc">How to cancel a task in JobScheduler</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Introduction to JobScheduler</h1></div></div></div><p>The Android <a id="id399" class="indexterm"/>development team, under the project Volta umbrella, introduced in the API Level 21 Lollipop release some enhancements and features in order to improve the power usage on the Android platform. Apart from the tools introduced to monitor and follow the battery usage in the Android platform, a new API for scheduling background was officially released to help the developer. It saves extra power cycles when the jobs used to support the developer's application do not need a time of execution, and can be deferred until the device has better battery and network context.</p><p>The API was not created to completely replace <code class="literal">AlarmManager</code>; however, the <code class="literal">JobScheduler</code> API is able to perform a better battery management and supply extra behaviors.</p><p>The main features introduced with Scheduler API are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Less power consumption</strong>: The job task could be delayed until the device is powered to the <a id="id400" class="indexterm"/>charger or they are grouped to run in batches on a regular basis</li><li class="listitem" style="list-style-type: disc"><strong>Persistent jobs across reboots</strong>: We are able to install job schedules that persistent task across device reboots</li><li class="listitem" style="list-style-type: disc"><strong>Better network bandwidth management</strong>: The job could be delayed until a higher bandwidth network is available, such as when a Wi-Fi network connection is available</li><li class="listitem" style="list-style-type: disc"><strong>Less intrusive execution</strong>: The job could be delayed until the user is not interacting with the device</li></ul></div><p>
<code class="literal">JobScheduler</code> is a singleton system service that we can retrieve via a <code class="literal">Context</code> object instance, using a code similar to the following:</p><div><pre class="programlisting">JobScheduler js = (JobScheduler)
     getSystemService(Context.JOB_SCHEDULER_SERVICE);</pre></div><p>The <code class="literal">JobScheduler</code> singleton service instance object helps us to manage our running jobs and provides us with member functions to schedule, cancel, and retrieve a list of deferred jobs.</p><p>Once we have a reference to the <code class="literal">JobScheduler</code> service, we can schedule a job by passing <code class="literal">JobInfo</code> to the <code class="literal">JobScheduler.schedule</code> function:</p><div><pre class="programlisting">int schedule(JobInfo job);</pre></div><p>
<code class="literal">JobInfo</code> is the object used in this framework where we specify all the information about the job itself, all the conditions that should be fulfilled to initiate the job execution, and the unit of work called <code class="literal">JobService</code> that will be started to execute the work required.</p><p>To build a <code class="literal">JobInfo</code> object, a common factory pattern, known Software Engineering as <code class="literal">Builder</code> and materialized in the static inner-class <code class="literal">JobInfo.Builder</code>, is available to construct the <code class="literal">JobInfo</code> object passed to <code class="literal">JobScheduler</code>. The pattern provides us with a way to construct a multi-parameter <code class="literal">JobInfo</code> on a clean, step-by-step basis and by using the <code class="literal">Builder</code> setter functions to define the <code class="literal">JobInfo</code> parameters.</p><p>First, we will have to build a <code class="literal">JobInfo.Builder</code> object using the following constructor:</p><div><pre class="programlisting">Builder(int jobId, ComponentName jobService)</pre></div><p>
<code class="literal">jobId</code> is an internal number <a id="id401" class="indexterm"/>used to identify your job in the <code class="literal">JobScheduler</code> service and the second argument is used to set the <code class="literal">JobService</code> derived class that will be invoked when the system verifies that all the pre-requisites are met to execute the job.</p><p>Let's write some code to show this:</p><div><pre class="programlisting">ComponentName jobSrvc= new ComponentName(ctx, MyJobService.class);
JobInfo.Builder jobIBuilder = new JobInfo.Builder(MY_JOB_ID,
                                                  jobSrvc);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Setting running criteria</h1></div></div></div><p>With the <code class="literal">Builder</code> <a id="id402" class="indexterm"/>object reference, we can start setting up the job parameters and the pre-requisites using the member function available in the <code class="literal">Builder</code> object.</p><p>Let's consider a couple of examples. In our first example, the job should only start when there is a Wi-Fi network available, so to achieve that, we have to use the following code to set the network availability pre-requisite:</p><div><pre class="programlisting">jobIBuilder.setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED);</pre></div><p>An unmetered network connection means that you have a connection where you don't have a limited amount of data usage per month and you are not charged when you go over the usage limit. When a network type is not specified, as a condition, the default value is <code class="literal">NETWORK_TYPE_NONE</code>, meaning that the job will run in any network context and even without any network connection. Apart from the previous network type criteria, there is <code class="literal">NETWORK_TYPE_ANY</code>, which determines that the job could run when there is network connectivity available.</p><p>To specify a job to run only when the device is plugged in and charging:</p><div><pre class="programlisting">jobIBuilder.setRequiresCharging(true);</pre></div><p>When a job should only run when the device is in idle mode:</p><div><pre class="programlisting">jobIBuilder.setRequiresDeviceIdle(true);</pre></div><p>Idle mode means that the job should only run when the device is not in use and has not been used for some time. This could be the best time to execute heavier computations because the user will not notice that the device resources have been allocated to your job, thereby the computation does not interfere with the user interactions. By default, any job will not require idle <a id="id403" class="indexterm"/>mode to run.</p><p>Persist your job execution across device reboots as follows:</p><div><pre class="programlisting">jobIBuilder.setPersisted(true);</pre></div><p>Such as an <code class="literal">AlarmManager</code> job, the job schedule will only survive a reboot if your application holds the permissions to receive the completed boot. To achieve that, add the following line to the <code class="literal">Android Manifest</code> file:</p><div><pre class="programlisting">&lt;uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" /&gt;</pre></div><p>In those cases where you want to schedule a periodic task, you can set the interval in milliseconds between subsequent executions:</p><div><pre class="programlisting">long interval = TimeUnit.HOURS.toMillis(5L);
jobIBuilder.setPeriodic(interval);</pre></div><p>This is an inexact interval since the Android system will try to group the jobs in batches in order to save some battery cycles.</p><p>When you want to define a maximum defer time to run your job, we can specify a time deadline where the job has to run, then it will run regardless of whether or not the other criteria are met:</p><div><pre class="programlisting">long maxExecutionTime = TimeUnit.MINUTES.toMillis(5L);
jobIBuilder.setOverrideDeadline(maxExecutionTime);</pre></div><p>In the following code, we set one hour as the maximum time to defer this job, so, if the other pre-requisites are not fulfilled, after one hour the job is going to run by the system independently of the other criteria:</p><div><pre class="programlisting">jobIBuilder.setOverrideDeadline(TimeUnit.HOURS.toMillis(1L));</pre></div><p>On the other hand, we can also specify a minimum defer time to this job as a criterion:</p><div><pre class="programlisting">jobIBuilder.setMinimumLatency(TimeUnit.SECONDS.toMillis(120));</pre></div><p>With the values used above, our job will never run on the next <code class="literal">120</code> seconds since we set a maximum latency time <a id="id404" class="indexterm"/>as a prerequisite to our job.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>
<code class="literal">setMinimumLatency</code> and <code class="literal">setOverrideDeadline</code> are not applicable for periodic jobs criteria shall be avoided  that it is in your recurrent jobs schedules. If any one of these criteria are used on recurrent jobs, an <code class="literal">IllegalArgumentException</code> exception will be thrown when the build is called.</p></div></div><p>When the job fails, in order to specify a retry policy, we have to specify the <code class="literal">backoff</code> initial value that determines the interval between retries and the retry increase policy. The <code class="literal">JobScheduler</code> API provides two policies that define the way in which the retry time increases between subsequent tries:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">BACKOFF_POLICY_LINEAR</code>: The interval time between retries increases linearly—<code class="literal">initial_backoff_millis * num_retries</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">BACKOFF_POLICY_EXPONENTIAL</code>: The interval time between retries increases exponentially—<code class="literal">initial_backoff_millis * 2 ^ (num_retries)</code><div><img src="img/Image_B05062_07_01.jpg" alt="Setting running criteria"/></div></li></ul></div><p>The <code class="literal">backoff</code> interval will increase until we reach a backoff of five hours (<code class="literal">JobInfo. MAX_BACKOFF_DELAY_MILLIS</code>) and the initial default value is <code class="literal">30</code> seconds (<code class="literal">JobInfo .DEFAULT_INITIAL_BACKOFF_MILLIS</code>).</p><p>Now, in the following examples we are going to show you how to create a linear and an exponential backoff policy for our <code class="literal">jobInfo</code> object:</p><div><pre class="programlisting">// Initial Backoff of 10 minutes that grows linearly
jobIBuilder.setBackoffCriteria(TimeUnit.MINUTES.toMillis(10L),
JobInfo.BACKOFF_POLICY_LINEAR);

// Initial Backoff of 3 minutes that grows exponentially
jobIBuilder.setBackoffCriteria(TimeUnit.MINUTES.toMillis(3),
JobInfo.BACKOFF_POLICY_EXPONENTIAL);</pre></div><p>The <code class="literal">builder</code> class also <a id="id405" class="indexterm"/>provides us a method to set some parameters to forward the job over a <code class="literal">PersistableBundle</code> object:</p><div><pre class="programlisting">PersistableBundle bundle = new PersistableBundle();
bundle.putInt(MY_JOB_ARG1,2);
jobIBuilder.setExtras(bundle);</pre></div><div><div><h3 class="title"><a id="note44"/>Note</h3><p>A <code class="literal">PersistableBundle</code> is a special kind of bundle that can be saved and restored later. Its main purpose is to pass arguments to the deferred job execution.</p></div></div><p>As soon as we have all the criteria to schedule our defined job, we are able to construct our <code class="literal">JobInfo</code> and use it to incorporate the job execution in our application:</p><div><pre class="programlisting">JobInfo.Builder jobIBuilder = ...
// Set Criterias
JobInfo jobInfo = jobIBuilder.setRequiresCharging(true)

setRequiresDeviceIdle(true).
                                             ...
                                             build();</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Scheduling a job</h1></div></div></div><p>With the criteria already <a id="id406" class="indexterm"/>defined and the <code class="literal">JobInfo</code> object, we have all the entities required to set up the job for our application. So now let's show you how to create a job with a real example.</p><p>Our example will <a id="id407" class="indexterm"/>synchronize the user account information stored in a device file with an HTTP web service over a job scheduled using the Scheduler API. The user interface will provide us a UI where we can update the user information, a button to save the information on an internal file, and a button to set up the synchronization job that will upload the account information to the web service.</p><p>First, let's start by defining our job pre-requisites and parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Our job should only run when the device is charging to save the battery</li><li class="listitem" style="list-style-type: disc">Our job should only run when an unmetered network is available to save mobile network bandwidth</li><li class="listitem" style="list-style-type: disc">Our job should only run when the device is idle because we don't want to slow down the UI responsiveness</li><li class="listitem" style="list-style-type: disc">Our job must run at least once within eight hours of being scheduled</li><li class="listitem" style="list-style-type: disc">Our job should run even after device reboot</li></ul></div><p>The <code class="literal">JobInfo</code> object requires an <code class="literal">ID</code> to identify the job in all the <code class="literal">JobSchedule</code> methods, so it is a good idea, in order to ensure consistency, to use a <code class="literal">public static int</code> to identify it:</p><div><pre class="programlisting">  static final int ACC_BACKUP_JOB_ID ="AccountBackJobService"
  hashCode();</pre></div><p>Subsequent calls to cancel or list jobs created must use the same <code class="literal">jobId</code> defined here.</p><p>Since we use a file to store the account information internally on the device, the filename used to retrieve account information needs to be passed to the job as an argument. The same principle applies to the remote web service endpoint.</p><p>To forward the required parameters, we have to build <code class="literal">PersistableBundle</code>, passing the filename and endpoint path as bundle parameters:</p><div><pre class="programlisting">private static final String SYNC_FILE = "account.json";
private static final String SYNC_PATH = "account_sync";
private static final String SYNC_PATH_KEY = "path";
...
PersistableBundle bundle = new PersistableBundle();
// Forward filename where the account information is stored
bundle.putString(SyncTask.SYNC_FILE_KEY,SYNC_FILE);
// Forward the HTTP Path used to upload the account information
bundle.putString(SyncTask.SYNC_PATH_KEY,SYNC_PATH);</pre></div><p>Once the criteria are stated and we have the identifier and the class name of our service, we are able to create our <a id="id408" class="indexterm"/><code class="literal">JobInfo</code> using the <code class="literal">Builder</code> inner class, as <a id="id409" class="indexterm"/>shown in the following code:</p><div><pre class="programlisting">ComponentName serviceName = new ComponentName(this,
  AccountBackupJobService.class);

// Setup the Job Information and criterias over a builder
JobInfo jobInfo = new JobInfo.
   Builder(ACC_BACKUP_JOB_ID, serviceName)
    .setRequiresCharging(true)
    .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)
    .setRequiresDeviceIdle(true)
    .setPersisted(true)
    .setOverrideDeadline(TimeUnit.HOURS.toMillis(8L))
    .setExtras(bundle)
    .build();</pre></div><p>Now we are ready to schedule the job with the <code class="literal">JobScheduler</code> service: </p><div><pre class="programlisting">// Get a Reference to the Service
JobScheduler jobScheduler = (JobScheduler) 
   getSystemService(JOB_SCHEDULER_SERVICE);

int result = jobScheduler.schedule(jobInfo);

if ( result == JobScheduler.RESULT_FAILURE ) {
  // Failed to setup the job 
  Toast.makeText(AccountInfoActivity.this, 
                 "Failed to setup a sharedpref backup job", 
                 Toast.LENGTH_SHORT).show();
} else {
  // Schedule Success 
  Toast.makeText(SharedPrefActivity.this,
                 "SharedPrefBack job successfully scheduled",
                 Toast.LENGTH_SHORT).show();
}</pre></div><p>The JobScheduler's <code class="literal">schedule</code> method will return <code class="literal">RESULT_FAILURE</code> in the case of failure and in the case of success will return the job identifier that we defined in the <code class="literal">JobInfo.Builder</code> constructor.</p><p>Now, since we have just scheduled our job, it's time to write the backup behavior in the <code class="literal">JobService</code> subclass. In the next section, we will detail how to implement a <code class="literal">JobService</code> that <a id="id410" class="indexterm"/>plays well with the <code class="literal">JobScheduler</code> <a id="id411" class="indexterm"/>framework.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Implementing the JobService</h1></div></div></div><p>Our <code class="literal">JobService</code> <a id="id412" class="indexterm"/>subclass is the entity that is going to do the hard work and receive the callbacks as soon as all the criteria specified in the <code class="literal">JobInfo</code> are met. To implement our own service, we have to extend from <code class="literal">JobService</code> and override the start and stop callbacks, as shown in the following code:</p><div><pre class="programlisting">public class AccountBackupJobService extends JobService {
    @Override
    public boolean onStartJob(JobParameters params) {
      // Start your job here
        return false;
    } 
    @Override
    public boolean onStopJob(JobParameters params) {
        // Stop your job here
        return false;
    }
}</pre></div><p>The <code class="literal">onStartJob</code> callback function runs on the main thread, and if the job needs to do asynchronous processing then it should return <code class="literal">true</code> to indicate it's still doing work on a background thread. The <code class="literal">callback</code> function also receives the extra parameters specified in the <code class="literal">JobInfo</code> bundle.</p><p>
<code class="literal">onStopJob</code> is automatically invoked by the system when it requires to cancel the job execution because the criteria specified in the <code class="literal">jobInfo</code> are no longer fulfilled.</p><p>For example, our job requires to run the work while the device is in an idle state, so, if the device leaves the idle mode because the user started to interact with the device, <code class="literal">onStopJob</code> will get called to abandon the execution for the meantime.</p><p>In this function, we should release any resources allocated to our job and stop any background processing in place. This function returning <code class="literal">boolean</code> would indicate whether you'd like to retry this job following the same criteria specified in the job creation or abandon the job execution. You should use <code class="literal">true</code> to reschedule this job based on the retry criteria specified during the job creation.</p><p>Before we add our Service business logic, we must add our <code class="literal">Service</code> class to <code class="literal">AndroidManifest.xml</code> and we must protect our service with the <code class="literal">android.permission.BIND_JOB_SERVICE</code> permission:</p><div><pre class="programlisting">&lt;service 
   android:name=".chapter7.AccountBackupJobService"
   android:exported="true"
   android:permission="android.permission.BIND_JOB_SERVICE" /&gt;</pre></div><p>There are two important <a id="id413" class="indexterm"/>things to recall about your <code class="literal">JobService</code> implementation:</p><div><ol class="orderedlist arabic"><li class="listitem">One, the <code class="literal">onStartJob</code> and <code class="literal">onStopJob</code> callbacks will run on the main thread, and it is your responsibility to hand over your service's long running executions to separate threads to prevent the appearance of any ANR dialog in your application due to a blocking operation in the main thread.</li><li class="listitem">Second, the Android system will acquire and hold a <code class="literal">WakeLock</code> for you while your <code class="literal">JobService</code> callbacks are running or until you explicitly call the <code class="literal">jobFinished</code> method in the case that you return <code class="literal">true</code> in the <code class="literal">onStartJob</code> function. If you don't, tell the system that your job execution is finished. The <code class="literal">WakeLock</code> will keep your device awake and burn your device's battery in vain. This could make your user angry and create a reason to uninstall your application, because your application will waste resources and battery and affect the user experience.</li></ol></div><p>Now that we have learned the theory about the <code class="literal">JobService</code>, let's write the code to execute the account synchronization with the remote server away from the main thread on a background processing line.</p><p>Considering the Android constructs learned until now, we will use the <code class="literal">AsyncTask</code> construct learned in <a class="link" href="ch03.html" title="Chapter 3. Exploring the AsyncTask">Chapter 3</a>, <em>Exploring the AsyncTask</em>, for its simplicity, and create an <code class="literal">AsyncTask</code> subclass to upload the account information using the created for this purpose:</p><div><pre class="programlisting">public class Result&lt;T&gt; {
    public T result;
    public Exception exc;
}

public class SyncTask extends 
  AsyncTask&lt;JobParameters, Void, Result&lt;JobParameters&gt;&gt; {
  
  // Parameter Keys for parameter arguments
  public static final String SYNC_FILE_KEY = "file";
  public static final String SYNC_ENDPOINT_KEY = "http_endpoint";
  
   // Variable used to store a reference to the service
  private final JobService jobService;
	
  // Constructor
  public SyncTask(JobService jobService) {
        this.jobService = jobService;
  } 
  ...
}</pre></div><p>As a starting point, we specified the generic <code class="literal">AsyncTask</code> class parameter types, setting <code class="literal">JobParameters</code> as the parameter for <code class="literal">doInBackground</code> and <code class="literal">Result</code> as the type returned from <code class="literal">doInBackground</code> and passed to the <code class="literal">onPostExecute</code> function.</p><p>Later, we create the final constant keys used to pass information in the bundle.</p><p>The <code class="literal">Result</code> type is also <a id="id414" class="indexterm"/>recovered from previous sessions to return an error when something wrong happens during the background execution.</p><p>Without going into too much detail, we will implement the <code class="literal">doInBackground</code> code responsible for uploading the data to the remote web service:</p><div><pre class="programlisting">@Override
protected Result&lt;JobParameters&gt; doInBackground(
  JobParameters... params) {

  Result&lt;JobParameters&gt; result = new Result&lt;JobParameters&gt;();
  HttpURLConnection urlConn = null;
  try {
    URL url;
    ...
         // Retrieve the file to upload from the parameters
         // passed in 
    String file = params[0].getExtras().
                                  getString(SYNC_FILE_KEY);
         // Remote WebService Path
    String endpoint = params[0].getExtras().
                             getString(SYNC_ENDPOINT_KEY);
    url = new URL ("http://&lt;webs_host&gt;:&lt;webs_port&gt;/" 
                        + endpoint);
    ...
    // Load the account information stored internally
    String body = Util.loadJSONFromFile(jobService, file);
    // Write the information to the remote service
            uploadJsonToServer(urlConn, body);
    // Process Server Response
         ...
  } catch (Exception e) {
    result.exc = e;
  } finally {
     if ( urlConn != null) {
      urlConn.disconnect();
     }
  }
  return result;
}</pre></div><p>Some implementation details are elided here for brevity, but we have implemented the <code class="literal">doInBackground</code> function to read the JSON data stored internally on a device file and we uploaded it over an <code class="literal">HttpURLConnection</code>. The Android <code class="literal">Activity</code> that displays the form saves and syncs the button to the final user. The <strong>save</strong> button, once pressed, stores the account information in the <code class="literal">account.json</code> local file when the <strong>save</strong> button is clicked.</p><p>The <strong>sync</strong> button, once <a id="id415" class="indexterm"/>clicked, will schedule the job for synchronizing the data with our remote HTTP server. When the job criteria defined by us are fulfilled, <code class="literal">doInBackground</code> is called to execute the sync procedure in the background.</p><p>Now that we have the code to upload the data to our server, let's finish it by processing the response and server errors:</p><div><pre class="programlisting">try {
  ...
  int resultCode = urlConn.getResponseCode();
  if ( resultCode != HttpURLConnection.HTTP_OK ) {
    throw new Exception("Failed to sync with server :" + 
        resultCode);
  }
  result.result = params[0];
...</pre></div><p>When an exception occurs, such as the server being down or a server internal error happening, the exception is propagated over our <code class="literal">Result</code> object to <code class="literal">onPostExecute</code> for further processing.</p><p>Note that we are being careful to handle the error situations, so, to notify the result of the background work to the <a id="id416" class="indexterm"/>user, we will write an <code class="literal">onPostExecute</code> function that runs on the main thread that is going to publish a system notification that informs the user whether the task was completed successfully or failed miserably:</p><div><pre class="programlisting">@Override
protected void onPostExecute(Result&lt;JobParameters&gt; result) {

  NotificationCompat.Builder builder =
    new NotificationCompat.Builder(jobService);
  ...
  if ( result.exc != null ) {
    // Error handling 
    jobService.jobFinished(result.result, true);
    builder.setContentTitle("Failed to sync account")
    .setContentText("Failed to sync account " + result.exc);
  } else {
    // Success handling
    builder.setContentTitle("Account Updated")
      .setContentText("Updated Account Sucessfully at " + 
             new Date().toString());
    jobService.jobFinished(result.result, false);
  }
  nm.notify(NOTIFICACTION_ID, builder.build());
}</pre></div><p>When the task is done, we invoke <code class="literal">jobFinished(JobParameters params, boolean needsRescheduled)</code> to let the system know that we are finished with that task; however, when an exception happens, we inform the system that we were unable to finish the task with success passing <code class="literal">true</code> on the second <code class="literal">jobFinished</code> argument.</p><p>When a finished job failed and needs to be rescheduled, we pass <code class="literal">false</code> as the second <code class="literal">jobService.jobFinished</code> argument, and the Scheduler API will reschedule our job using the back-off time specified in the <code class="literal">JobInfo</code> object. However, since our job only executes on idle mode, the failed job will be added to the scheduler queue and re-executed within a future idle maintenance window without using the back-off times specified in the <code class="literal">JobInfo</code>.</p><p>It is important to always call <code class="literal">jobFinished</code> to release the <code class="literal">WakeLock</code> assigned to the job and to inform the system that it can process additional jobs.</p><p>If everything goes well, a notification should appear in the notification drawer presenting the success message and the <a id="id417" class="indexterm"/>time when the last synchronization happened successfully.</p><p>Finally, we can update the <code class="literal">SyncJobService</code> code to start and stop the <code class="literal">SyncTask</code> execution:</p><div><pre class="programlisting">public class SyncJobService extends JobService {

    private static final String TAG = "SyncJobService";
    SyncTask mJob = null;
    @Override
    public boolean onStartJob(JobParameters params) {
        Log.i(TAG, "on start job: " + params.getJobId());
        if ( mJob != null ){
            mJob = new SyncTask(this);
            mJob.execute(params);
            return true;
        }
        return false;
    }

    @Override
    public boolean onStopJob(JobParameters params) {
        Log.i(TAG, "on stop job: " + params.getJobId());
        if ( mJob != null ){
            mJob.cancel(true);
            mJob = null;
        }
        return true;
    }    
}</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Listing pending jobs</h1></div></div></div><p>Unlike the <code class="literal">AlarmManager</code> <a id="id418" class="indexterm"/>API, the Scheduler API provides the ability to list all the pending <a id="id419" class="indexterm"/>schedules for your application. This handy feature could help us to recognize the jobs that are going to be executed in the future and react accordingly with that list. The list retrieved could help us to pinpoint a pending job that we would like to cancel.</p><p>The <code class="literal">JobScheduler</code> service class has an <code class="literal">instance</code> method with the following signature:</p><div><pre class="programlisting">public List&lt;JobInfo&gt; getAllPendingJobs();</pre></div><p>The method will return a list of <code class="literal">JobInfo</code> objects that we can use to observe job parameter sets during the job build:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Job criteria for each job:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getNetworkType()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isRequireDeviceIdle()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isRequireCharging()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getMinLatencyMillis()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isPeriodic()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getIntervalMillis()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">isPersisted()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">getMaxExecutionDelayMillis()</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">JobService</code> subclass that will be called back by the <code class="literal">JobScheduler</code> to execute the job—<code class="literal">getService()</code></li><li class="listitem" style="list-style-type: disc">Job arguments: <code class="literal">getExtras()</code></li><li class="listitem" style="list-style-type: disc">Retry policy: <code class="literal">getInitialBackoffMillis()</code> and <code class="literal">getBackoffPolicy()</code></li></ul></div><p>Okay, now we are ready to create an Activity that prints a list of pending jobs for our application:</p><div><pre class="programlisting">public class JobListActivity extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
   ...
JobScheduler jobScheduler = (JobScheduler)
       getSystemService(JOB_SCHEDULER_SERVICE);

    // Get the list of scheduled jobs
    List&lt;JobInfo&gt; jobList = jobScheduler.getAllPendingJobs();
    // Initialize the adapter job list
    JobListRecyclerAdapter adapter = 
      new JobListRecyclerAdapter(this, jobList);

    rv.setAdapter(adapter);
    // Set the Job Counter
    TextView jobCountTv = (TextView)findViewById(R.id.jobCount);
    jobCountTv.setText(Integer.toString(jobList.size()));
  }
}</pre></div><p>To list the pending jobs in the UI, we have used the support library <code class="literal">RecyclerView</code> class, a more advanced version of <code class="literal">ListView</code>, which simplifies the creation of a large set of <code class="literal">Views</code>.</p><p>First, we will build up our <a id="id420" class="indexterm"/><code class="literal">ViewHolder</code> to hold the references to the row <a id="id421" class="indexterm"/>views that will display the <code class="literal">jobId</code> and the <code class="literal">Service</code> endpoint:</p><div><pre class="programlisting">public class JobListRecyclerAdapter extends
  RecyclerView.Adapter&lt;JobListRecyclerAdapter.JobViewHolder&gt; {
       …
  public static class JobViewHolder extends
    RecyclerView.ViewHolder {
    // References to the Views
    CardView cv;
    TextView jobId;
    TextView serviceName;
    
    JobViewHolder(View itemView) {
      super(itemView);
      cv = (CardView)itemView.findViewById(R.id.cv);
      jobId = (TextView)itemView.findViewById(R.id.jobIdTv);
      serviceName = (TextView) 
        itemView.findViewById(R.id.className);
   }
 }
}</pre></div><p>To bind the <code class="literal">jobInfo</code> parameters to the current <code class="literal">ViewHolder</code>, we will write the <code class="literal">RecyclerView.onBindViewHolder</code> to set the information based on the current <code class="literal">JobInfo</code>:</p><div><pre class="programlisting">@Override
public void onBindViewHolder(
  JobListRecyclerAdapter.JobViewHolder holder, int position) {
  // Retrieve the job for the current list row
  final JobInfo ji = mJobList.get(position);
  // Update the UI Views with the Job Info
  holder.jobId.setText(Integer.toString(ji.getId()));
  holder.serviceName.setText(ji.getService().getClassName());
}</pre></div><p>Yes, thanks to <code class="literal">getAllPendingJobs</code>, we have a list of our jobs, and moreover, we can analyze that programmatically <a id="id422" class="indexterm"/>to create behavior around the current application situation.</p><p>Some code is omitted on purpose; however, the full source code is available on Packt Publishing website. Take a <a id="id423" class="indexterm"/>look at the complete source code to appreciate how the recycler view and the card view was used to build up the job list UI.</p><p>To fully manipulate the jobs at will, there is only one CRUD (create, read, update, delete) operation that we need to cover in this chapter - the delete operation. The delete job operation is delivered by the <code class="literal">cancel</code> functions and is going to be covered in detail in the next section.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Canceling a job</h1></div></div></div><p>There are some situations <a id="id424" class="indexterm"/>where we want to provide for the users an ability to cancel the job because the environment situation has changed or it does not make sense to execute the job anymore—for example, the user changed a piece of information that the job depends on and the job is no longer applicable. The <code class="literal">JobScheduler</code> service offers us the support for job cancellation with the following <code class="literal">cancel</code> and <code class="literal">cancelAll</code> methods:</p><div><pre class="programlisting">void cancel(int jobId);

void cancelAll();</pre></div><p>The first method, <code class="literal">cancel(jobId)</code>, allows us to cancel a specific job using the job identifier returned from the <code class="literal">schedule(JobInfo job)</code> function or the <code class="literal">jobId</code> available on <code class="literal">JobInfo</code> objects returned by the <code class="literal">getAllPendingJobs</code> function.</p><p>The <code class="literal">cancelAll()</code> method allows us to cancel the scheduled jobs that have been registered with the <code class="literal">JobScheduler</code> by the current application.</p><p>With <code class="literal">JobInfo</code> from the <a id="id425" class="indexterm"/>previous example we are able to cancel a specific job passing the job identifier:</p><div><pre class="programlisting">  final JobInfo ji = ...;
  JobScheduler jobScheduler = (JobScheduler)
        mContext.getSystemService(mContext.JOB_SCHEDULER_SERVICE);
  // Cancel a Specific Job based on the JobInfo-&gt;jobId
  jobScheduler.cancel(ji.getId());</pre></div><p>Whenever we cancel a schedule, the job will be removed from the <code class="literal">JobScheduler</code> future execution queue and will no longer be executed by the <code class="literal">SyncJobService</code> or any other <code class="literal">JobService</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec58"/>Scheduling a periodic job</h1></div></div></div><p>So far, we have <a id="id426" class="indexterm"/>scheduled one-shot jobs, but do you know there is an option to <a id="id427" class="indexterm"/>schedule the execution of a job at periodic internals. These kinds of jobs might be the perfect construct to performing repeating backups or repeating network operations such as application user data backup.</p><p>Let's update our <code class="literal">AccountInfoActivity</code> to schedule the periodic execution of the account synchronization job.</p><p>We'll start by defining a new job identifier for our periodic job:</p><div><pre class="programlisting">static final int SYNC_PER_JOB_ID = "SyncJobPerService".hashCode();</pre></div><p>We can schedule a periodic job to be executed approximately every 12 hours like this:</p><div><pre class="programlisting">JobInfo.Builder builder = new JobInfo.Builder(SYNC_PER_JOB_ID,
   serviceName);
builder.setRequiresDeviceIdle(true)  
  // Persist the schedule across the device reboots
<strong>  .setPersisted(true)</strong>
<strong>  .setPeriodic(TimeUnit.HOURS.toMillis(12L))</strong>
  .setRequiredNetworkType(JobInfo.NETWORK_TYPE_UNMETERED)
  .setRequiresDeviceIdle(true)
  .setExtras(bundle);
  
// Schedule the repeating job
JobScheduler jobScheduler = (JobScheduler) getSystemService(JOB_SCHEDULER_SERVICE);
jobScheduler.schedule(builder.build());</pre></div><p>Now we are able to schedule the synchronization job to run periodically in the background while the device is idle and the Wi-Fi network is available. The job schedule will be persisted by the <a id="id428" class="indexterm"/>system and re-enabled after the device boots up until <a id="id429" class="indexterm"/>we explicitly cancel the job or all the jobs are cancelled through <code class="literal">cancelAll()</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec59"/>Applications of the JobScheduler</h1></div></div></div><p>The <code class="literal">JobScheduler</code> <a id="id430" class="indexterm"/>API allows us to schedule work that runs asynchronously without user intervention in the future under certain conditions. This API is also able to reduce the energy consumption by deferring the job execution until the device is charging or connected to an unmetered network, such as the Wi-Fi network.</p><p>Ideal cases include things such as application database backup that could be deferred and do not require exact time execution, a periodic upload of user data to the network, and download of configuration parameters. So, typically jobs that don't have to run immediately and which data doesn't have to be ready for user consumption. Reducing your application energy consumption without compromising the user experience will increase the device battery lifetime and therefore improve the user experience.</p><p>The <code class="literal">JobScheduler</code> could cover most of the <code class="literal">AlarmManager</code> use cases, notwithstanding it provides advanced features to optimize device resources acquisition. As an additional feature, this API provides a way to create schedule that survive the device shutdown and restart.</p><p>The only big drawback is that <code class="literal">JobScheduler</code> was only introduced with Android 5.0 (Lollipop). Therefore, you need to target your application to an API Version 21 or higher to interact with this API.</p><p>At the time of writing in July 2016, 45 percent of Android devices run a version of Android that supports <code class="literal">JobScheduler</code>. To get up-to-date information about the Android market share by version, please check the Android Developer Dashboard.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec60"/>Summary</h1></div></div></div><p>In this chapter, we explored the <code class="literal">JobSheduler</code> API, putting it to use to schedule background work that starts when a group of conditions defined by us are met.</p><p>We learned in detail how to set the different criteria supported by the API and how to schedule based on the <code class="literal">JobInfo</code> object that starts a job when the device is charging and not in use.</p><p>In the meantime, we learned how to implement an asynchronous <code class="literal">JobService</code> that is able to run in a background execution line and finish the job execution properly by releasing all the acquired resources (<code class="literal">WakeLock</code>, <code class="literal">...</code>).</p><p>Later, we used the <code class="literal">getAllPendingJobs</code> to create a sample code to list all the pending Scheduler API jobs within our application. From the example, we learned how to cancel a specific job or all the pending jobs in our applications.</p><p>To finish, we built a persistent and recurrent schedule using the <code class="literal">JobSheduler</code> API, which wakes up the device and executes our job every 12 hours.</p><p>In the next chapter, we will learn how to transfer data from and to the network using effective asynchronous libraries and protocols, without even draining the battery.</p></div></body></html>