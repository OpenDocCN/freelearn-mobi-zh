- en: Chapter 3. Basic Key-value Operations – Creating and Deleting Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 基本键值操作 – 创建和删除数据
- en: The core of LevelDB and any key-value store is the ability to `Put`, `Get`,
    and `Delete` values by keys. These three operations are all we need to store and
    retrieve specific pieces of data, treating our database as a persistent dictionary.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 和任何键值存储的核心是能够通过键来 `Put`、`Get` 和 `Delete` 值。这三个操作就是我们存储和检索特定数据片段所需的所有操作，将我们的数据库视为持久字典。
- en: This chapter is about how to use the `Put`, `Get`, and `Delete` operations at
    their simplest to store and retrieve data. We'll also cover when and how to combine
    operations into batches.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何以最简单的方式使用 `Put`、`Get` 和 `Delete` 操作来存储和检索数据。我们还将讨论何时以及如何将操作组合成批处理。
- en: The code in this chapter is going to start being a little more idiomatic C++
    than the trivial examples so far. The basic LevelDB interface is C++, not just
    C, and that introduces a couple of issues you need to understand for safe coding.
    The many other language bindings for LevelDB sit on top of this C++ API, although
    it is invisible in most of them. For the benefit of people who are pure Objective-C
    programmers, some C++ idioms will be explained in detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码将开始比迄今为止的简单示例更具 C++ 习惯用法。LevelDB 的基本接口是 C++，而不仅仅是 C，这引入了一些您需要了解以进行安全编码的问题。许多其他
    LevelDB 的语言绑定都建立在 C++ API 之上，尽管在大多数情况下它是不可见的。为了纯 Objective-C 程序员的好处，一些 C++ 习惯用法将详细解释。
- en: The sample code used for this and the next chapter is written as OS X console
    programs to have the simplest environment for testing. It's about the database
    concepts rather than the platforms. Duplicating projects in Xcode is awkward so
    we will just create new projects each time (which of course you can download in
    the accompanying code). The sample code uses a lot of `assert` statements around
    different actions. Normally, you would write more robust error-handling code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 用于本章和下一章的示例代码被编写为 OS X 控制台程序，以拥有最简单的测试环境。它关于数据库概念，而不是平台。在 Xcode 中复制项目是尴尬的，所以我们每次都会创建新的项目（当然，您可以在配套代码中下载）。示例代码在许多不同操作周围使用了大量的
    `assert` 语句。通常，您会编写更健壮的错误处理代码。
- en: The following screenshot shows the entire console output from running the `Sample03`
    code, including the strange characters drawn because of embedded nulls in one
    key.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了运行 `Sample03` 代码的整个控制台输出，包括由于一个键中嵌入的空字符而绘制的奇怪字符。
- en: 'Like most of our samples, the code creates a database from scratch, using the
    same logic to put it in a temporary directory as we did in [Chapter 01](ch01.html
    "Chapter 1. Downloading LevelDB and Building with OS X"), *Downloading LevelDB
    and Building with OS X*. Download the complete sample code to compile and try
    it for yourself or just refer back to this console output to see the results of
    the following code snippets:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的大多数示例一样，代码从零开始创建数据库，使用与我们在 [第 01 章](ch01.html "第 1 章. 下载 LevelDB 并在 OS X
    上构建") 中相同的逻辑将其放入临时目录，即 *下载 LevelDB 并在 OS X 上构建*。下载完整的示例代码以编译并亲自尝试，或者只需参考此控制台输出以查看以下代码片段的结果：
- en: '![Basic Key-value Operations – Creating and Deleting Data](img/1015OS_03_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![基本键值操作 – 创建和删除数据](img/1015OS_03_01.jpg)'
- en: Console output for Sample03 showing messages as data put and retrieved
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Sample03 的控制台输出，显示数据插入和检索的消息
- en: Understanding C++ idioms in LevelDbHelper.h
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 LevelDbHelper.h 中理解 C++ 习惯用法
- en: A couple of C++ idioms for LevelDbHelper.h are about being able to write to
    standard I/O.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDbHelper.h 的几个 C++ 习惯用法是关于能够写入标准 I/O。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Never put an unscoped `using` statement into a header file because that propagates
    to any source that `#includes` the header, causing obscure errors. However, it's
    perfectly acceptable to simplify a function as seen in `testRead` (in the following
    code snippet) by putting the `using` statements inside.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将未限定的 `using` 语句放入头文件中，因为这会传播到任何 `#includes` 该头文件的源代码，导致难以理解的错误。然而，将 `using`
    语句放在其中是完全可以接受的，就像在 `testRead`（以下代码片段中）中看到的那样简化函数。
- en: 'A function such as `operator<<` starting with `template` and using the template
    type in its declaration will automatically create code for different data types.
    This shows how to add an `operator<<` function so your own data types can be written
    to streams for output:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `template` 开头并使用模板类型在其声明中使用的函数，如 `operator<<`，将自动为不同数据类型创建代码。以下是如何添加一个 `operator<<`
    函数，以便您的自定义数据类型可以写入流以进行输出：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The LevelDB `Get` function fills in `std::string` as its only way of returning
    values. Unlike a classical `const char*` C string, C++ `std::string` can contain
    binary data. It''s basically a size and a pointer to bytes, which normally behaves
    like a string of characters but can also be used as an arbitrary container. You
    can see the `leveldb::Status` object returned by calling `Get` and how we check
    its `ok()` function and human-readable error message via `ToString()`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LevelDB 的 `Get` 函数将 `std::string` 作为其返回值的唯一方式。与经典的 `const char*` C 字符串不同，C++
    `std::string` 可以包含二进制数据。它基本上是一个大小和一个指向字节的指针，它通常像字符字符串一样行为，但也可以用作任意容器。你可以看到通过调用
    `Get` 返回的 `leveldb::Status` 对象，以及我们如何通过 `ToString()` 检查其 `ok()` 函数和可读的错误消息：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most of the LevelDB functions take an `options` object as their first parameter.
    Just for this test, you saw how to create a default just using `leveldb::ReadOptions()`.
    The variables `ropt` and `wopt` in `main03.cpp` are used for a single set of consistent
    options.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 LevelDB 函数将 `options` 对象作为它们的第一个参数。仅为此测试，你看到了如何使用 `leveldb::ReadOptions()`
    创建默认值。`main03.cpp` 中的 `ropt` 和 `wopt` 变量用于一组单一的连续选项。
- en: Using Get and Put for strings
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字符串进行 Get 和 Put 操作
- en: The `testString` function from `main03.cpp` stores and retrieves string values.
    We start by trying to read a non-existent key. Note that either a literal quoted
    string or a `std::string` object can be passed as a key. The `Get` call in `testRead`
    fails with the message **NotFound**, and you could test for that with `if (s.IsNotFound())`.
    See the `leveldb::Status` class declaration in `leveldb/status.h` for all these
    helpers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `main03.cpp` 的 `testString` 函数存储和检索字符串值。我们首先尝试读取一个不存在的键。请注意，可以传递一个字面量引号字符串或
    `std::string` 对象作为键。`testRead` 中的 `Get` 调用会失败，并显示消息 **NotFound**，你可以通过 `if (s.IsNotFound())`
    来测试这一点。参见 `leveldb/status.h` 中的 `leveldb::Status` 类声明，以获取所有这些辅助函数。
- en: 'After using the `Put` call to add a value for a given key, it can be read only
    by using the exact key again—see the following code—how a different case fails.
    Updating a value is simply done by using `Put` again with a different value but
    the same key:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `Put` 调用来为给定键添加值之后，只能通过再次使用确切的键来读取它——参见以下代码——不同的案例是如何失败的。更新值只需再次使用 `Put`
    并提供不同的值但相同的键即可：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Understanding Slice – the efficient LevelDB parameter object
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解切片 - 高效的 LevelDB 参数对象
- en: The `testRead` function was templated to allow it to take any data type for
    a key. In practice, that's any data type from which you can create a `leveldb::Slice`
    object. These objects are used as parameters in most of the LevelDB interfaces.
    A `Slice` object contains a length and a data pointer. It does not own its data
    so is very efficient to copy around but also dangerous to hang onto. If you keep
    a `Slice` object then make sure the data it was initialized with is also retained
    and the context is thread-safe. This is one reason why you should never share
    LevelDB objects across threads—they have internal storage referred to by `Slices`,
    and those buffers can be corrupted by operations on other threads.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`testRead` 函数被模板化，允许它接受任何数据类型作为键。在实践中，这可以是任何可以创建 `leveldb::Slice` 对象的数据类型。这些对象在
    LevelDB 接口中用作参数。`Slice` 对象包含一个长度和一个数据指针。它不拥有其数据，因此复制起来非常高效，但也存在风险。如果你保留了一个 `Slice`
    对象，那么请确保初始化它的数据也被保留，并且上下文是线程安全的。这也是你永远不应该在线程之间共享 LevelDB 对象的一个原因——它们有通过 `Slices`
    引用的内部存储，而这些缓冲区可能会被其他线程的操作损坏。'
- en: See `slice.h` for the full class declaration. A `Slice` constructor can take
    a `const char*` parameter by itself as a C string, or take a `std::string` or
    `const char*` with `size_t` length to define a sized value. The `Slice` methods
    `data()` and `size()` return that data pointer and size. The input keys and values
    for `Get` and `Put` are `const` references to `Slice` objects. This implies the
    unique C++ idiom of conversion by construction can create a temporary `Slice`
    object from any single value which can be used as a Slice constructor parameter,
    such as a `const char*` or `std:string&`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `slice.h` 以获取完整的类声明。`Slice` 构造函数可以单独接受一个 `const char*` 参数作为 C 字符串，或者接受一个
    `std::string` 或 `const char*` 与 `size_t` 长度来定义一个有大小值。`Slice` 方法 `data()` 和 `size()`
    返回该数据指针和大小。`Get` 和 `Put` 的输入键和值是 `Slice` 对象的 `const` 引用。这意味着独特的 C++ 构造转换习语可以从任何单个值创建一个临时的
    `Slice` 对象，该对象可以用作 Slice 构造函数参数，例如 `const char*` 或 `std::string&`。
- en: Using Get and Put with binary values
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二进制值进行 Get 和 Put 操作
- en: 'Now that you understand how `Slice` objects are used, let''s go back to the
    simple `Put` and `Get` operations. Binary values can be stored just the same as
    string values, remembering a `std::string` value can be regarded, such as `Slice`
    as containing just data bytes and a length. The difference is that a `std::string`
    retains ownership of its bytes and so is a safe container for binary data. In
    the following `testBin()` sample we create a `Slice` object with a pointer and
    length of an arbitrary binary `struct`, and do the opposite to get the binary
    `struct` back out of the `std::string` value returned from `Get`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用`Slice`对象，让我们回到简单的`Put`和`Get`操作。二进制值可以像字符串值一样存储，记住一个`std::string`值可以被视为，例如`Slice`，只包含数据字节和长度。区别在于`std::string`保留了其字节的拥有权，因此是二进制数据的安全容器。在下面的`testBin()`示例中，我们使用一个指针和长度创建一个`Slice`对象，任意二进制`struct`，并执行相反操作从`Get`返回的`std::string`值中获取二进制`struct`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using Delete – the final third of key-value operations
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Delete – 键值操作的最后一部分
- en: 'Earlier in this chapter, we saw how you can change the value for a given key
    just by using `Put` again with that same key. If you want to effectively rename
    a key, or get rid of it altogether, you use `Delete`. It will cope if the key
    doesn''t exist, as seen in the second `Delete` of `Packt`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面，我们看到了如何仅通过再次使用相同键的`Put`操作来更改给定键的值。如果你想有效地重命名一个键，或者完全删除它，你将使用`Delete`。如果键不存在，它将处理这种情况，就像在`Packt`的第二个`Delete`中看到的那样：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Delete` operation removes a key-value pair from storage. As mentioned
    previously, we must also use it as part of renaming to ensure an original key
    is no longer there. Unlike other database architectures, the log-based storage
    of LevelDB doesn''t have an index table which can be updated. Thus, a `rename`
    implies both a new key being created and the entire associated value is rewritten:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete`操作从存储中删除一个键值对。如前所述，我们还需要将其作为重命名的一部分使用，以确保原始键不再存在。与其它数据库架构不同，LevelDB基于日志的存储没有可以更新的索引表。因此，`rename`操作意味着创建一个新的键，并且整个相关值被重写：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This rename-by-copy starts by retrieving the value we're going to add back in,
    so we start with a `Get` with the old key.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通过复制重命名的操作首先检索我们要添加回的值，所以我们从使用旧键的`Get`操作开始。
- en: Wrapping operations in WriteBatch for increased safety
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WriteBatch包装操作以增加安全性
- en: 'The previous example of renaming a key, like any other sequence of LevelDB
    operations, runs the risk of leaving the database in an inconsistent state if
    the program was terminated partway through. We can wrap any sequence of `Put`
    and `Delete` operations in a `WriteBatch` object. Using sync will guarantee we
    wait for the disk I/O to complete and allow the batch to optimize its sequence
    of writes. A safer version of the rename is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前重命名键的例子，就像LevelDB的任何其他操作序列一样，如果程序在中间终止，则存在使数据库处于不一致状态的风险。我们可以将任何`Put`和`Delete`操作序列包装在`WriteBatch`对象中。使用同步将保证我们等待磁盘I/O完成，并允许批次优化其写入序列。重命名的更安全版本是：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are familiar with other database concepts, `WriteBatch` is similar to
    performing a transaction and a commit. That implies the ability to abandon operations
    which is also a part of `WriteBatch`, using its `Clear` operation. Alternatively,
    you can just free a `WriteBatch` object and never apply it with `db->Write()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他数据库概念，`WriteBatch`类似于执行事务和提交。这意味着可以放弃操作，这也是`WriteBatch`的一部分，使用其`Clear`操作可以实现。或者，你也可以简单地释放一个`WriteBatch`对象，并且永远不使用`db->Write()`来应用它。
- en: Summary
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was very much a chapter focused on C++, showing templated functions for
    different kinds of content and writing data to the console. The vital `Slice`
    class was discussed in detail, with its efficient but dangerous reference-only
    behavior and how it enables storing binary data. We covered the `Put`, `Get`,
    and `Delete` operations and the safe way to wrap a combination of data changes
    with `WriteBatch`. Next, we will learn to search keys.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这章非常专注于C++，展示了用于不同类型内容的模板函数以及将数据写入控制台。详细讨论了至关重要的`Slice`类，其高效但危险的仅引用行为以及它如何使存储二进制数据成为可能。我们涵盖了`Put`、`Get`和`Delete`操作，以及使用`WriteBatch`安全地包装数据更改组合的方法。接下来，我们将学习如何搜索键。
