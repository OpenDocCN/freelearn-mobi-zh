- en: Customizing Widgets and Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In everyday development on Android, you'll find that the core platform and support
    libraries offer a wide range of widgets and layouts for you to build your application.
    There are also a wealth of open source and third-party widgets available on the
    internet. The *Android Arsenal* website ([https://android-arsenal.com/](https://android-arsenal.com/))
    is a well-cataloged list of APIs available for Android, and it is an excellent
    starting point when you need some functionality that is not available in the platform
    or support libraries. Even with this massive wealth of available widgets and libraries,
    you'll sometimes find yourself wanting a widget that hasn't already been built.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own widgets on any platform is a sizable undertaking. Widgets
    need to be able to render themselves to look as native as possible using graphics
    primitives such as lines, arcs, circles, and polygons. Many Android widgets (such
    as `Button`) avoid having to do this using the excellent `Drawable` class and
    resources. This enables you to customize the look of widgets simply by changing
    the drawable resources they use to a stateful drawable (as you did with the `RadioButton`
    widgets in [Chapter 2](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml), *Designing
    Form Screens*).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll take a look at how to build custom widgets and layout
    components. We''ll take a look at the best practices to use when building your
    own `View` implementations, and how to render 2D graphics using the Android graphics
    APIs. Specifically, we''ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a completely custom `View` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering 2D graphics using graphics primitives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a custom `ViewGroup` to produce custom layout effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering animations using `Drawable` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating `View` classes that self-animate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom view implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the existing widgets just aren''t enough, no matter how much you
    customize them. Sometimes, you need to display something that simply isn''t supported
    by the platform. In these cases, you might find yourself needing to implement
    your own custom widget. The `View` class can be easily extended to produce many
    different effects, but there are a few things that are worth knowing before you
    tackle it:'
  prefs: []
  type: TYPE_NORMAL
- en: The rendering for a `View` is expected to happen in the `onDraw` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When rendering the graphics for the `View`, you'll use a `Canvas` to send the
    drawing instructions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `View` is responsible for calculating the offsets for its padding, and
    by default, the graphics will be clipped to these dimensions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should avoid any object allocation (including arrays, if possible) in the
    `onDraw` method. The `onDraw` methods are probably the most time-sensitive method
    calls in any application, and need to produce as little garbage as possible. Any
    object allocations should be done in other methods and just used in the `onDraw`
    implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the travel claims example, it will be really nice if the user can see a
    simple overview graph of their spending for the last few days. To do this, we''ll
    need to write a class that can draw this graph for them. It''s useful to be able
    to change some of the `View` attributes (specifically, the size and color of the
    line graph) using the layout XML file. For this, you''ll need to specify the attribute
    names and their type information for the layout resource compiler. Follow these
    instructions to write a simple line-graph `View` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `res/values` resource directory in the travel claim app and
    select New| Values resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `attrs_spending_graph_view`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll use this file to declare some new XML attributes for the resource compiler
    that can be used in your layout XML files when dealing with your new graph `View`
    class. These XML attributes are given type information (in the form of a `format`
    attribute), which affects how the resource compiler handles them in the layout
    XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, right-click on the widget package and select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `SpendingGraphView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Superclass` to `android.view.View`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `SpendingGraphView`, declare variables to hold the values that can be
    specified in the layout XML files. These should typically reflect the names used
    in the XML file, and should be initialized with sensible default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare an array for the data points to be rendered into the graph. In
    this implementation, we''ll assume that each data point is the amount spent on
    an unspecified day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, the `onDraw` implementation should have to do as little
    work as possible. In this graph implementation, it means that the entire graph
    is actually calculated ahead of time, and cached in local variables to be drawn
    in the `onDraw` method. The Android graphics APIs provide a `Path` class to define
    any abstract group of connected lines, and the `Paint` class that defines the
    colors, stroke size (pen), fill-style, and so on. You''ll need to declare one
    of each of these to be calculated and rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Storing the widget's rendering state on a field in the class might seem to go
    against everything you know about where you should store and pass state, but a
    widget is a form of state container. Its job is to present its state to the user
    and to capture events to trigger state changes. Keeping the construction of the
    graphics primitives out of the `onDraw` implementation means that the graphics
    pipeline isn't slowed by recalculating the graphics state from the graph data
    for every frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, implement the standard constructors for a `View` class. You''ll want all
    of these constructors to invoke a single `init()` method to handle the actual
    initialization of the widget, which in this case, will also need to fetch and
    read the attributes given in the layout XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the `init` method and use the `Context` to convert the `AttributeSet`
    object and its data into a `TypedArray` object. This is where all the style information
    is merged in from the current `Theme` of the application. When you are finished
    with a `TypedArray`, you need to recycle them, handing them back to the platform
    to be reused. This helps the performance of the `obtainStyledAttributes` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to paint the graph correctly, you''ll need a utility method to help
    find the scale of the vertical axis. This involves finding the maximum value that
    the graph will have, and unfortunately, the Android platform doesn''t expose a
    method to do this directly, so you''ll need to implement it yourself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to implement the actual rendering method for the graph data.
    This method will be invoked on the main thread, but won''t be invoked as part
    of the rendering loop. Instead, you''ll calculate all the values and plot the
    graph using a `Path` object (a vector graphics primitive). Then, this method will
    store the plotted line and the `Paint` to use in the path and paint fields you
    declared, and signal that the `View` is *invalid* and needs to have its `onDraw`
    method called as soon as possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It would actually be quite possible to encapsulate this code in an `ActionCommand`
    or `AsyncTask`, so that these calculations don't block the main thread. You will
    need to invoke the `invalidate()` method in `onForeground()`, or use the `postInvalidate()`
    method instead (which posts the `invalidate()` signal to the main thread). Moving
    such complexity to a background thread is good practice if the amount of data
    the graph is expected to present became very large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you''re ready to override the `onDraw` method and actually paint the graph
    onto the `Canvas` provided by the platform. This `onDraw` implementation simply
    verifies that the graph has been rendered, and then paints the fields onto the
    screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It's useful to know that you can construct a `Canvas` yourself by having it
    paint to an offscreen `Bitmap` object, allowing you to capture *screenshots* of
    widgets by invoking their `onDraw` method yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you just need a few getter and setter methods to allow your application
    to specify the data to be rendered, and a programmatic way to change and fetch
    the XML attribute values. The setter methods also need to invoke the `invalidateGraph()`
    method to cause the data to be recalculated and rendered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `SpendingGraphView` requires that its actual data is delivered programmatically
    using the `setSpendingPerDay` method. This can, fortunately, be done easily using
    the data-binding system, which will also keep the data up to date when the data
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the SpendingGraphView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integrating the `SpendingGraphView` into an application is as simple as declaring
    it in your layout XML file, and providing it with some data points to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also programmatically find the `SpendingGraphView` using `findViewById`,
    and invoke the `setSpendingPerDay` method from your Java code. Integrating the
    `SpendingGraphView` into the travel claim example is a little more complex. The
    graph belongs on the overview screen, since it gives the user a quick visual indication
    of what their last few days of spending have looked like. If the user starts scrolling,
    the graph needs to scroll off the screen so that there is more screen space for
    the claim items. A nice way to do this is to leverage the `DisplayItem` class
    you wrote to handle the spacers, and simply add one at the beginning of the overview.
    Let''s integrate the new `SpendingGraphView` with the overview screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the res/layout directory and select New| Layout resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new resource file `card_spending_graph`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Root element to be `layout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This layout resource will be used with the `DataBoundViewHolder`, and we''ll
    be passing the spending-per-day indirectly as the `item` variable. It''s also
    worth noting that the XML namespace for your custom attributes on the `SpendingGraphView`
    (`strokeColor` and `strokeWidth`) is the `app` namespace. This is what the layout
    resource should look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the Code Assistant on the `layout_height` attribute to create a new dimension
    value named `spending_graph_height` (as was just highlighted) in your `dimens.xml`
    values resource file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Open the `ClaimItemAdapter` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Most of the changes will be in the `CreateDisplayListCommand` inner class.
    You''ll need to calculate the user''s spending for a selection of recent days.
    To do this, you''ll need to know how many days ago each claim was, so that you
    can add its amount to the correct day. This method simply counts backward one
    day at a time, until it reaches the given timestamp:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Time APIs such as JODA time ([http://www.joda.org/joda-time/](http://www.joda.org/joda-time/))
    and the Java 8 time APIs offer methods specifically for calculating the difference
    between two instants in time (in various different time units). However, the use
    of these APIs is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you''ll need another method in the `CreateDisplayListCommand` to create
    the array of amounts representing the user''s spending over the last few days.
    To keep the implementation simple and quick, we limit this to ten days by default.
    The `getSpendingPerDay` method creates a double for each of these days, and adds
    the amounts to each double for the `ClaimItem` objects filed on each day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The final thing to do in the `CreateDisplayListCommand`, is to create a `DisplayItem`
    as the first item in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need to add some new code to the `UpdateDisplayListCommand` inner
    class, because it doesn''t know how to compare the spending graph for the `DiffUtil`.
    In the implementation of the `areItemsTheSame` method in the `DiffUtil.Callback`,
    you can treat the `card_spending_graph` layout resources exactly the same as the
    separators, because there is only one of them in the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you also need the `DiffUtil` to detect that the graph data may have
    changed. In this case, we simply assume that the data has changed, and force the
    `RecyclerView` to bind the new data points to the existing `SpendingGraphView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The one last thing to ensure is that the user can't swipe the `SpendingGraphView`
    to delete it from the `RecyclerView`, as this will be a huge surprise for the
    user. Open the `OverviewActivity` source file and locate the `SwipeToDeleteCallback`
    inner class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to tell the `ItemTouchHelper` that the first item in the list cannot
    be swiped or moved. We do this by overriding the default `getMovementFlags` method.
    This method usually just returns the flags that you passed into the constructor,
    but you now want these flags to change for just one item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Creating a layout implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most applications, you'll find that a combination of the `ConstraintLayout`,
    `CoordinatorLayout`, and some of the more primitive layout classes (such as `LinearLayout`
    and `FrameLayout)`) are more than enough to achieve any layout requirements you
    can dream up for your user interface. Every now and again though, you'll find
    yourself needing a custom layout manager to achieve an effect required for the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layout classes extend from the `ViewGroup` class, and their job is to tell
    their child widgets where to position themselves, and how large they should be.
    They do this in two phases: the measurement phase and the layout phase.'
  prefs: []
  type: TYPE_NORMAL
- en: All `View` implementations are expected to provide measurements for their actual
    size according to specifications. These measurements are then used by the `View`
    widget's parent `ViewGroup` to allocate the amount of space the widget will consume
    on the screen. For example, a `View` might be told to consume, at most, the screen
    width. The `View` must then determine how much of that space it actually requires,
    and records that size in its **measured dimensions**. The measured dimensions
    are then used by the parent `ViewGroup` during the layout process.
  prefs: []
  type: TYPE_NORMAL
- en: The second phase is the layout phase, and it is conducted by the `ViewGroup`
    parent of each `View` widget. This phase positions the `View` on the screen, relative
    to its parent `ViewGroup` location, and specifies the actual size that the widget
    will consume on the screen (typically based on the measured size calculated in
    the measurement phase).
  prefs: []
  type: TYPE_NORMAL
- en: When you implement your own `ViewGroup`, you'll need to ensure that all of your
    child `View` widgets are given a chance to measure themselves before you perform
    the actual layout operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build a layout class to arrange its children in a circle. To keep the
    implementation simple, we''ll assume that all the child widgets are the same size
    (for example, if they were all icons):'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `widget` package in the travel claim example app, and select
    New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new class `CircleLayout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Superclass to `android.view.ViewGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the standard `ViewGroup` constructors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onMeasure` method to calculate the size of the `CircleLayout`
    and all of its child `View` widgets. The measurement specifications are passed
    in as `int` values, which are interpreted using the `static` methods in the `MeaureSpec`
    class. Measurement specifications come in two flavors: *at most* and *exactly*,
    and each has a *size* value attached. In this particular layout, we always measure
    the `CircleLayout` as the size given in the specification. This means that the
    `CircleLayout` will always consume the maximum amount of space available. It also
    expects all of its children to be able to specify sizes without the `match_parent`
    attribute (as this will cause each child to take up all the available space):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next method to implement is the `onLayout` method. This performs the actual
    arrangement of the child `View` widget within the `CircleLayout`, by invoking
    their `layout` method. The `layout` method should never be overridden, because
    it''s closely tied to the platform and performs several other important actions
    (such as notifying layout listeners). Instead, you should override `onLayout`,
    but invoking `layout.CircleLayout` assumes that all the child `View` widgets are
    of the same size (and forces this as part of the `onLayout` implementation). This
    `onLayout` method simply calculates the available space, and then positions the
    child `View` widgets in a circle around the outside edge:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Although the implementation of the `onLayout` method is quite long, it's also
    relatively simple. Most of the code is concerned with determining the desired
    position of the child `View` widgets. Layout code needs to execute as quickly
    as possible, and should avoid allocating any objects during the `onMeasure` and
    `onLayout` methods (similar to the rules of `onDraw`). Layout is a critical part
    of building the screen from a performance standpoint, because no rendering can
    actually occur without the layout being completed. The layout will also be rerun
    every time the layout changes its structure. For example, if you add or remove
    any child `View` widgets, or change the size or position of the `ViewGroup`. Changing
    the size of a `ViewGroup` might happen on every frame if you use a `CoordinatorLayout`,
    where the `ViewGroup` is being collapsed (or if you change its size as part of
    a property-animation).
  prefs: []
  type: TYPE_NORMAL
- en: Creating animated views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most widget animation can be taken care of using the animation APIs in Android.
    The standard animation APIs are designed to take care of animations with a defined
    start and end, or animations that form a simple loop. Some animations, however,
    don't fit into this mold; a good example would be a game. A game has many animations
    running continuously, and you can even think about the entire game screen as a
    single, continuous animation.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of widgets that need to be continuously animated, and your
    standard Android animation API won't work. In these cases, you'll need a `View`
    that can continuously animate and update itself as long as it's visible to the
    user. In these cases, a slightly different design is called for, as the widget
    will always be changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how to write a widget that has a continuous animation, let''s
    write a `View` class that animates some number of bouncing `Drawable` objects.
    Each `Drawable` will be tracked separately, and when it reaches a side, it will
    "bounce off", and head in the other direction. This class is unrelated to the
    travel claim example code, so you can add it to a new project if you like. Follow
    these steps to write a `BouncingDrawablesView`:'
  prefs: []
  type: TYPE_NORMAL
- en: On your default package, select New| Java Class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the class `widget.BouncingDrawablesView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the Superclass `android.view.View`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on OK to create the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll have some number of bouncing objects in the scene, and you''ll need
    to track both their position and speed vector. For this, you''ll want to encapsulate
    each bouncing `Drawable` in a `Bouncer` object; we''ll write this as an inner
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to do in the `Bouncer` inner class is to create a single `step`
    method, which will set up the `Bouncer` for the next animation frame to be rendered.
    This method will take a parameter that represents the boundaries of the *field*
    it''s being rendered on. If the next position collides with any of the edges of
    the field, the `Bouncer` will avoid crossing the edge and will reverse direction
    on the axis it would have collided with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Bouncer` class also needs a convenient draw method that will update the
    boundaries of the `Drawable`, before rendering it to a given `Canvas` object.
    The `Bouncer` keeps track of its own boundaries, so that all the `Bouncer` instances
    can actually share the same `Drawable` instance, and simply paint it at different
    locations on the field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `BouncingDrawablesView`, declare an array of `Bouncer` objects
    that will be contained and animated by the `View` implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BouncingDrawableView` also needs a status field to track whether it should
    be animating or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the standard `View` implementation constructors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `onDraw` method by simply telling each of the `Bouncer` objects
    to paint themselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''ll need to implement that actual logic to animate each frame. Do
    this by creating an `onNextFrame` method that first checks whether the animation
    should still be running (if it''s not running, we stop the animation), and then
    tells each `Bouncer` to move one step in the animation. After you''ve set up the
    next animation frame, you''ll need to tell the platform to repaint the `BouncingDrawablesView`,
    by calling the `invalidate()` method. Once the `onNextFrame()` method is complete,
    we schedule it to be invoked again in 16 milliseconds time (scheduling just under
    60 frames per second):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to automatically start the animation when the `BouncingDrawablesView`
    becomes visible and make it stop when it''s invisible, you need to know when the
    `BouncingDrawablesView` is attached to the `Window` (when it''s attached to the
    screen components). To do this, you''ll need to override `onAttachedToWindow`
    and invoke `onNextFrame()`. However, `onAttachedToWindow` is invoked before the
    layout is executed, so you''ll schedule `onNextFrame()` to be run at the end of
    the current event queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write a setter and getter for the `Bouncer` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up the `BouncingDrawablesView` is a very simple process. An `Activity`
    will need to create an array of `Bouncer` objects with some random positions and
    speeds, and then hand them over to the `BouncingDrawablesView` instance to take
    care of them. As soon as the `BouncingDrawablesView` becomes visible on the screen,
    it will start animating the `Drawable` objects around the screen. A simple example
    setup of the `BouncingDrawableView` might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When rendering specialized graphics for a custom widget, you need to do which
    of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Buffer all the rendering in an offscreen `Bitmap`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a custom background `Drawable`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Override the `onDraw` method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should you create instances of graphics primitives such as `Drawable`,
    `Paint` and `Path` for rendering in `onDraw`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the main thread
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `onDraw` method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Anywhere that doesn't affect `onDraw` directly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the two phases involved in the layout process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Layout and then measurement
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Measurement and then layout
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Measurement and then rendering
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When painting a `Drawable` object, you need to do which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass it a valid `Canvas` object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Canvas.paintDrawable`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke its `onDraw` method
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To tell the platform that a widget needs to repaint itself (from the main thread),
    you use which of these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`View.redraw()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View.invalidate()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`View.repaint()`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of what has been covered in this book is a mix of theory (how to go about
    designing a screen) and hard practical knowledge (writing the code to produce
    that screen). When you combine a good theoretical base with practical knowledge
    of the platform you're working on, you have a powerful combination. Being about
    to write great applications isn't just about being able to write code (very little
    in programming is about being able to *just* write code). It's about having an
    eye for detail in the user interface, and always thinking about your users.
  prefs: []
  type: TYPE_NORMAL
- en: Android is an amazingly powerful platform when used correctly. In this book,
    you've learned to use APIs such as data binding, the Room data storage system,
    and `LiveData`. This mix of APIs on the Android Platform doesn't just allow you
    to rapidly develop excellent applications, but it also provides an excellent separation
    between different areas of your code base. They also don't, in any way, reduce
    the power you can leverage from the underlying platforms and systems (such as
    SQLite).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android community is massive, and there is plenty to find and work with
    outside of the core platform that can make development even easier. Here are a
    few links to resources, documentation, and APIs, that are especially useful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Android platform reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.android.com/reference/packages.html](https://developer.android.com/reference/packages.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Firebase (handles hosting, push-notifications, database synchronization, authentication,
    and much more):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://firebase.google.com/](https://firebase.google.com/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The Android Arsenal, an unofficial list of third-party APIs and widgets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://android-arsenal.com/](https://android-arsenal.com/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Joda-Time API, the de-facto standard time API before Java 8 on the core Java
    platform, still useful on Android, though:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.joda.org/joda-time/](http://www.joda.org/joda-time/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The official SQLite website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://sqlite.org/](https://sqlite.org/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, here are some fun ideas for projects that you might want to try implementing
    once you''ve finished this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Try expanding the travel claim example to allow for multiple trips.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple expense tracker to allow your user to enter and track their spending.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A packing/moving organizer app, allowing the user to photograph the contents
    of boxes and record their contents for when they are moving their house.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A to-do list application, allowing the user to create various lists of things
    they need to do and check them off when done. To make this more interesting, you
    can add reminders and deadlines (items that must be completed by a certain date
    and time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A real-time chat application, which is a bit more complex; use the Firebase
    Real-time database to store and synchronize the chat messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building your own custom components can be a lot of work, but can also be extremely
    rewarding. Having complete control over the measurement, layout, and rendering
    cycle provides you with an amazing amount of power to virtually build any widget
    that you can imagine. Android also has some excellent defaults defined, allowing
    you to focus on how your widget should look and work, rather than getting stuck
    on the intricacies of the rendering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The `Drawable` class is one of the most powerful graphics primitives Android
    has. It's difficult to call it a primitive due to how powerful they actually are.
    Wherever possible, use them instead of a `Bitmap` or `Path`, as they make future
    improvements much simpler, and easily integrate with the resources system.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Handler` class to animate a widget is also a very powerful and low-level
    mechanism. It's often a good idea to introduce a sense of real time into these
    sorts of animations so that frames that take slightly longer, or shorter, to render
    don't affect the overall feel of the application. This can be done simply by using
    the timestamp in each frame and moving values according to that, instead of having
    fixed values. In this case, the speed of the `Bouncer` will become the number
    of `pixels/time` instead of a fixed number of pixels per frame.
  prefs: []
  type: TYPE_NORMAL
- en: Before building your own widgets or layouts, you should always look around on
    the internet to see whether there is an existing project that does what you are
    looking for. Knowing how widgets are actually built and fit together is useful
    knowledge, and should give you the confidence to not just create your own, but
    also help others build theirs.
  prefs: []
  type: TYPE_NORMAL
