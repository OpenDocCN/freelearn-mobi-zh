<html><head></head><body><div><div><div><h1 id="_idParaDest-41" class="chapter-number"><a id="_idTextAnchor045"/>2</h1>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor046"/>Principles of Software Architecture</h1>
			<p>In this chapter, we are going to cover the fundamental principles of software architecture. They are vitally important to every part of software architecture. We should constantly remind ourselves of these, just like professional pianists practice scales every day.</p>
			<p>We’ll go through different ways to describe and view software architecture first. Then we’ll cover a few important principles that will be referenced in later chapters. It is intended that you might go back to this chapter anytime and contemplate again some of these key concepts.</p>
			<ul>
				<li>Perspectives, dimensions, and qualities</li>
				<li>Separation of concerns, cohesiveness, and coupling</li>
				<li>SOLID principles</li>
				<li>YAGNI and future-proof architecture</li>
				<li>The Law of Demeter</li>
			</ul>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor047"/>Technical requirements</h1>
			<p>You can find all the code files used in this chapter on GitHub: <a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-2%0D">https://github.com/Packt
Publishing/Software-Architecture-with-Kotlin/tree/main/chapter-2</a></p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor048"/>Perspectives, dimensions, and qualities</h1>
			<p>Software systems are not physical objects that we can easily see or touch. At their roots, they are instructions that are interpreted by a machine. So, we will need to visualize software systems in other ways.</p>
			<p>The major purpose of visualizing software systems is to demonstrate how stakeholder concerns are addressed. There is usually a lengthy list of concerns. Each stakeholder usually has multiple concerns at various levels of abstraction. It is not possible to address all concerns from all angles in one visual representation.</p>
			<p>The concept of <strong class="bold">View</strong> was<a id="_idIndexMarker115"/> introduced in the 1970s to describe software architecture. Since then, there have been numerous efforts to codify and standardize methods in describing software architecture. <strong class="bold">ISO/IEC/IEEE 42010:2022</strong> is the current standard in specifying software architecture, by <a id="_idIndexMarker116"/>which the architectural concepts, structure, and language are defined.</p>
			<p>In a View, only selected perspectives of software architecture are portrayed. The selection aims at addressing certain stakeholder concerns. Moreover, there are multiple Views so each View can target specific concerns and specific stakeholders.</p>
			<p>A <strong class="bold">View Model</strong> is a <a id="_idIndexMarker117"/>collection of Views wherein each View has a dedicated focus, purpose, and language for visualization.</p>
			<p>The <strong class="bold">4+1 architecture view model</strong> was<a id="_idIndexMarker118"/> created by Philippe Kruchten in 1995. It includes four views of a software system, plus selected scenarios that help different stakeholders understand the software system from the perspectives of other stakeholders.</p>
			<div><div><img src="img/B21737_02_1.jpg" alt="Figure 2.1 – A 4+1 architecture view model" width="726" height="454"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – A 4+1 architecture view model</p>
			<p>Let’s look at each view from the 4+1 architecture view model in the upcoming sections.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor049"/>Logical view</h2>
			<p>The <strong class="bold">logical view</strong> focuses <a id="_idIndexMarker119"/>on the business functionality of the system and how it is implemented. It is agnostic to the technical concerns. It is an abstract view of how a business feature works without involving technical terms, using the language that both technical and non-technical stakeholders understand. It is suitable for communication with non-technical stakeholders.</p>
			<p>In the example of the state transition of a service exchange contract between households, the logical view is expressed in the UML state diagram that follows:</p>
			<div><div><img src="img/B21737_02_2.jpg" alt="Figure 2.2 – A 4+1 architecture view model – logical view" width="885" height="970"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – A 4+1 architecture view model – logical view</p>
			<p>A <a id="_idIndexMarker120"/>service contract between two households is first drafted by one household. The contract is of the <strong class="bold">Drafted</strong> state. Once the draft is complete, the household submits the contract to be reviewed by the other household.</p>
			<p>The contract could be amended by both households before they reach an agreement. Both households must agree to the terms before going further. However, in some cases, the contract may be rejected by a household and thus enter the <strong class="bold">Rejected</strong> terminal state.</p>
			<p>Assuming<a id="_idIndexMarker121"/> that both households agreed to the terms, there is still a chance that the contract could be withdrawn due to other circumstances. Assuming that the contract goes ahead, both households then exercise and fulfill the terms of the contract. This concludes the contract and reaches the end of its life cycle.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor050"/>Physical view</h2>
			<p>The <strong class="bold">physical view</strong> focuses <a id="_idIndexMarker122"/>on the deployable software components and the interconnections between them. It is also called the <strong class="bold">deployment view</strong>. It is <a id="_idIndexMarker123"/>suitable for communication with system engineers, platform engineers, and infrastructure engineers.</p>
			<p>Imagine that the ADR example we demonstrated in the previous chapter was approved. There is a central service to keep the master records of service exchange contracts. The physical view may look something like the following:</p>
			<div><div><img src="img/B21737_02_3.jpg" alt="Figure 2.3 – A 4+1 architecture view model – physical view" width="1494" height="612"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – A 4+1 architecture view model – physical view</p>
			<p>The software has been moved to a browser-based web application. Users access the system via a web browser as a client and submit requests for service. The load balancer is the first component to receive these requests and distribute them to the appropriate instance of the <strong class="bold">Exchange service</strong> based on the load of each instance. Any static content such as images is fetched from a web server. The <strong class="bold">Exchange service</strong> processes the request and persists the result in the <strong class="bold">Relational database</strong>.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor051"/>Process View</h2>
			<p>The <strong class="bold">process view</strong> focuses<a id="_idIndexMarker124"/> on the real-time behaviors of the system. It is usually close to the system’s operation, where internal employees or other systems are involved. It is useful in showcasing issues involving concurrency, performance, and scalability. This view facilitates communication among technical stakeholders.</p>
			<p>UML diagrams such as sequence diagrams, interaction diagrams, activity diagrams, communication diagrams, and timing <a id="_idIndexMarker125"/>diagrams are useful to represent a process view. <strong class="bold">Business Process Modeling and Notation</strong> (<strong class="bold">BPMN</strong>) diagrams are also useful in describing how the system behaves in the context of business processes.</p>
			<p>If the service contract exchange system has an email notification function, it may look like the figure that follows:</p>
			<div><div><img src="img/B21737_02_4.jpg" alt="Figure 2.4 – A 4+1 architecture view model – process view" width="1422" height="1075"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – A 4+1 architecture view model – process view</p>
			<p>When <strong class="bold">Household A</strong> submits a draft contract, the <strong class="bold">Exchange service</strong> validates the request and updates the corresponding records in the <strong class="bold">Relational database</strong>. Afterward, the <strong class="bold">Exchange service</strong> makes a call to the <strong class="bold">Email service</strong> to send an email notification to <strong class="bold">Household B</strong> for the service contract submitted by <strong class="bold">Household A</strong>.</p>
			<p><strong class="bold">Household B</strong>, in this<a id="_idIndexMarker126"/> case, is notified of the service contract in the email. Then <strong class="bold">Household B</strong> submits a request to agree to the contract terms to the <strong class="bold">Exchange service</strong>. The <strong class="bold">Exchange service</strong> then updates the records in the <strong class="bold">Relational database</strong>.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor052"/>Development view</h2>
			<p>The <strong class="bold">development view</strong> concentrates on <a id="_idIndexMarker127"/>software management. The target audience is programmers who are coding hands-on in the system.</p>
			<p>The view focuses on the static organization of the software in the development environment. This includes how multiple components collaborate to form a software system at various levels, such as packages of source code, call hierarchies from higher-order business functions to lower-level utility functions, inheritance hierarchies of classes, and dependency trees of software artifacts. The details of this view can be found in the source code repository.</p>
			<p>UML package and component diagrams can be used to represent this view. An organized source code repository may find these diagrams redundant. However, these diagrams are good at highlighting any dependency issues between packages and modules.</p>
			<p>The <strong class="bold">Exchange service</strong> in the service contract exchange system may be expressed in a UML package diagram, as in the figure that follows:</p>
			<div><div><img src="img/B21737_02_5.jpg" alt="Figure 2.5 – A 4+1 architecture view model – development view" width="1177" height="1096"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – A 4+1 architecture view model – development view</p>
			<p>The <strong class="bold">Exchange service</strong> has a <a id="_idIndexMarker128"/>business package that includes the following:</p>
			<ol>
				<li>A module that controls the workflow of a service contract</li>
				<li>A module that master’s the records of households</li>
				<li>A module that searches the history of service contracts</li>
			</ol>
			<p>The <strong class="bold">Business</strong> package uses the <strong class="bold">Persistence</strong> package to perform the actual relational database operations for service contracts and households.</p>
			<p>The <strong class="bold">Business</strong> package<a id="_idIndexMarker129"/> has a dependency on the <strong class="bold">Validation</strong> package, which contains a few standalone validators for addresses, emails, dates, and service contracts.</p>
			<p>The <strong class="bold">Integration</strong> module is responsible for communicating with other services such as the <strong class="bold">Email service</strong>. This module is used by the <strong class="bold">Business</strong> module to notify households.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor053"/>Scenarios</h2>
			<p>In the 4+1 architecture view model, scenarios<a id="_idIndexMarker130"/> are represented by the <em class="italic">+1</em> because only important scenarios would be chosen to be documented. It focuses on user-system interactions and on how the system facilitates users in their workflow. It is often used in communication with users, both internal and external.</p>
			<p>UML use case diagrams are used for scenarios. In the example of the service contract exchange system, the drafting and exercising of the service contract are selected use cases.</p>
			<div><div><img src="img/B21737_02_6.jpg" alt="Figure 2.6 – A 4+1 architecture view model – scenario" width="1326" height="630"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – A 4+1 architecture view model – scenario</p>
			<p><strong class="bold">Household A</strong> submits a drafted contract to be reviewed by <strong class="bold">Household B</strong>. The contract can be amended before it is agreed to. Once the households agree to the contract terms, they <a id="_idIndexMarker131"/>exercise the service contract to completion.</p>
			<p>We have discussed the 4+1 architecture view model, which visualizes the architecture of a system from at least five perspectives. Each perspective visualizes the system using different dimensions to highlight certain aspects at a time. Each view is useful in communicating with its own audience.</p>
			<p>Next, we are going to explore system quality attributes, which can be used to describe, measure, and predict how well a system can perform.</p>
			<h3>System quality attributes</h3>
			<p>If there are two functionally identical systems, how might we compare and evaluate which system performs better? We can use system quality attributes to measure and compare the two systems.</p>
			<p>System quality attributes<a id="_idIndexMarker132"/> exist independently of the business functions that the system provides. They are purely technical attributes that determine whether a system runs smoothly or not. The requirements to <a id="_idIndexMarker133"/>have certain system <a id="_idIndexMarker134"/>quality attributes are called <strong class="bold">Non-Functional Requirements</strong> (<strong class="bold">NFRs</strong>) or <strong class="bold">Cross-Functional </strong><strong class="bold">Requirements</strong> (<strong class="bold">CFRs</strong>).</p>
			<p>It is important to differentiate between functional requirements and NFRs. Functional requirements define what the system does, while NFRs define how the requirements are fulfilled. Functional requirements specify the features of a system, while NFRs define its qualities, behaviors, and performance characteristics.</p>
			<p>There are many dimensions<a id="_idIndexMarker135"/> for system quality attributes. Here we will highlight several system quality attributes that we will cover in later chapters:</p>
			<ul>
				<li><strong class="bold">Correctness</strong>: This measures whether the system behaves as described in the specifications. This could be <a id="_idIndexMarker136"/>referred to as <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) documentation, operation manuals, or simply function contracts.</li>
				<li><strong class="bold">Availability</strong>: This measures the uptime of the system or the time when it can operate and serve its purpose.</li>
				<li><strong class="bold">Robustness</strong>: This refers to the level of service the system can provide when the system has faulty parts and/or is under heavy traffic.</li>
				<li><strong class="bold">Resilience</strong>: This refers to how quickly the system can recover from faults, continue to operate, and bounce back from unexpected disruption to a fully functional state.</li>
				<li><strong class="bold">Performance</strong>: This measures how quickly the system can respond to requests and how many requests the system can process at a time.</li>
				<li><strong class="bold">Scalability</strong>: This measures how flexibly the system can scale to cope with changing the volume and latency requirements. It is the ability of the system to expand or shrink.</li>
				<li><strong class="bold">Observability</strong>: This refers to how well the external view of the system helps us determine its internal state. The external view can be represented by log messages, charts, alerts, files, or the payload of a system remote call.</li>
				<li><strong class="bold">Manageability</strong>: This measures how easy it is to manage and control a system in terms of operations, monitoring, configuration, and administration.</li>
				<li><strong class="bold">Maintainability</strong>: This measures how easy it is to maintain a working system. This can include source code, updating infrastructure, modifying build pipelines, and tweaking environments.</li>
				<li><strong class="bold">Extensibility</strong>: This <a id="_idIndexMarker137"/>measures the ease of extending the current capability of the system to include new functions as the business grows. It includes the time, complexity, and effort required to modify and enhance the current system.</li>
				<li><strong class="bold">Testability</strong>: This measures the extent to which tests can cover the functionality of the system. It is not limited to the business functions to be tested but also includes the assessment of other system quality attributes.</li>
				<li><strong class="bold">Reusability</strong>: This refers to the extent to which the individual components of the system can be reused for other purposes. This includes not only the software modules and source code but also the business functions and processes.</li>
				<li><strong class="bold">Usability</strong>: This<a id="_idIndexMarker138"/> translates to how good the user experience is while working with the system. It is not limited to end users who treat the system as a black box but also includes other stakeholders such as internal users, system operators, administrators, and programmers.</li>
			</ul>
			<p>We have covered a few important system quality attributes that we will mention in later chapters. We are going to discuss the fundamental architecture principles that drive modern software architecture and help us improve current systems.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor054"/>Separation of concerns, cohesiveness, and coupling</h1>
			<p>A system is composed of many components and the interconnections among them. The ability to group and separate elements in the system has become a crucial factor in ensuring it is maintainable, reusable, and extendable. We are going to cover three fundamental concepts that will help us group and separate elements appropriately, namely <strong class="bold">separation of concerns</strong>, <strong class="bold">cohesiveness</strong>, and <strong class="bold">coupling</strong>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor055"/>Separation of concerns</h2>
			<p>Separation of concerns<a id="_idIndexMarker139"/> is a fundamental principle that we should apply in every corner of the system. It is a principle that advocates segregating the system into independent components and having each component address a specific concern. Separation of concerns aims at creating a system that is easier to maintain, reason, and update, and which can adapt to changes in requirements over time.</p>
			<p>Let us take the following scenario as an example: the submission of a draft service exchange contract from a household’s <a id="_idIndexMarker140"/>browser to <strong class="bold">Exchange service</strong> via <strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) with payload in<a id="_idIndexMarker141"/> the <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) format.</p>
			<p>The first concern will likely be to ensure that <strong class="bold">Exchange service</strong> only takes the correct information to create a draft service in the <strong class="bold">Relational database</strong>.</p>
			<p>Within the<a id="_idIndexMarker142"/> correctness category, there are multiple levels:</p>
			<ol>
				<li>The request payload needs to conform to the agreed structure; otherwise, an HTTP <code>400</code> (Bad request) status should be returned.</li>
				<li>The services to be exchanged must not be empty; otherwise, an HTTP <code>400</code> (Bad request) status should be returned.</li>
				<li>The households in the contract must already exist in the system records; otherwise, an HTTP <code>404</code> (Not found) status should be returned.</li>
				<li>The household that submitted the draft contract must already have logged on; otherwise, an HTTP <code>401</code> (Unauthorized) status should be returned.</li>
				<li>The household that submitted the draft contract must already have been verified; otherwise, an HTTP <code>403</code> (Forbidden) status should be returned.</li>
				<li>If the request passes all validation checks and the contract persists, an HTTP <code>200</code> (OK) status should be returned with the payload of the persisted record.</li>
				<li>If the request passes all validation and the contract persists, the contract should be in the <strong class="bold">Drafted</strong> state.</li>
			</ol>
			<p>The list goes on. However, we could see that, for example, the payload is at the syntactical level. Returned HTTP statuses, on the other hand, are at the contractual communication level, while being in the correct state is at a semantic level.</p>
			<p>If a change addressing one concern for a part of the system is made without affecting the other concerns, then this change is aligned with the separation of concerns principle.</p>
			<p>To be able to separate concerns when modifying a system, some parts of the system will need to be grouped together and other parts need to be separated.</p>
			<p>The degree to which the software elements within a component are closely related can be measured by cohesiveness. The degree of independence of each component can be measured by coupling.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor056"/>Cohesiveness</h2>
			<p>Software components that are strongly<a id="_idIndexMarker143"/> related to each other have a few properties. Firstly, they share similar responsibilities and most likely have a common objective. Secondly, if you change one component, it is likely that the rest of the components will require changes as well. Finally, they coordinate and cooperate in at least one manner. Chained function calls are examples of cohesive components.</p>
			<p>Software components can be cohesive in the following ways.</p>
			<h3>Horizontal cohesiveness</h3>
			<p>Horizontally cohesive <a id="_idIndexMarker144"/>components <a id="_idIndexMarker145"/>are grouped together to provide features related to a certain implementation. For example, components related to integration with a particular external system are grouped together to separate the concerns of vendor-specific implementation from the functional behaviors that the system provides. In the case of reviewing vendor choices, engineers can replace this group of components with another group that targets a different vendor system. This cohesive approach supports a plug-and-play structure that is easy to maintain and understand.</p>
			<h3>Vertical cohesiveness</h3>
			<p>Vertically cohesive <a id="_idIndexMarker146"/>components are <a id="_idIndexMarker147"/>grouped together based on the functional behaviors that they collectively provide. Vertical cohesiveness usually involves <strong class="bold">encapsulation</strong> of <a id="_idIndexMarker148"/>data and behaviors shared among components in the group. For example, components responsible for providing <strong class="bold">Create, Read, Update, Delete</strong> (<strong class="bold">CRUD</strong>) operations for<a id="_idIndexMarker149"/> managing households can be grouped together. This grouping provides clarity on how the system behaves. When the behaviors must be modified, engineers can focus on a small area and lower the risk of change.</p>
			<h3>Linear cohesiveness</h3>
			<p>Linearly cohesive <a id="_idIndexMarker150"/>components are <a id="_idIndexMarker151"/>grouped together due to the sequence of their execution or the flow of control. This could be manifested by chains of function calls or by a chained reaction of event communication. This grouping provides clarity and visibility for how smaller tasks or processes emerge into a larger workflow.</p>
			<h3>Interactive cohesiveness</h3>
			<p>Interactively cohesive components<a id="_idIndexMarker152"/> are grouped based on the frequency of <a id="_idIndexMarker153"/>communication and interaction patterns among them. For example, the HTTP service and the client library of a certain function are grouped under a project of different modules. When there is a change in communication protocol, engineers can find most of the necessary changes in one project. This reduces the cost and effort of making a change. It also keeps the change contained in one area.</p>
			<p>Look at the example of household validation that follows:</p>
			<pre class="source-code">
data class Household(
    val name: String,
    val members: List&lt;Person&gt;,
)
data class Person(
    val firstName: String,
    val lastName: String,
    val age: Int,
    val skills: List&lt;String&gt;,
)
fun Household.validate(): List&lt;String&gt; =
    listOfNotNull(
        if (name.isBlank()) "name must not be empty" else null,
    ) + members.flatMap { it.validate() }
fun Person.validate(): List&lt;String&gt; = listOfNotNull(
    if (firstName.isBlank()) "first name must be non-empty" else null,
    if (lastName.isBlank()) "last name must be non-empty" else null,
    if (age &lt; 0) "age must be non-negative" else null,
)</pre>			<p>A household <a id="_idIndexMarker154"/>has a name and a list of members. Each member has a few basic<a id="_idIndexMarker155"/> fields such as first and last names. A basic household validation would involve ensuring that the household name is not empty; moreover, it also requires that each person in the household passes the validation. For example, age cannot be a negative number.</p>
			<p>In this example, the validation of a household depends on the validation of a person in that household. The functions to validate both the household and the person are vertically cohesive because they behave as a validation feature in the form of a higher-order function. They are also linearly cohesive because the validation function of a household invokes the validation function of a person.</p>
			<p>High cohesiveness concentrates related components in one place. This illustrates the overall behavior of the components and makes the behavior easier to understand. It also promotes better testability as engineers can test the components’ overall behavior in one place. Keeping related components in one place also means fewer moving parts when making a change, which lowers risk. The overall behavior can be treated as one unit that other parts of the system can reuse.</p>
			<p>On the other hand, low cohesiveness results in related components being scattered around, making them difficult to understand, modify, and maintain. It creates inappropriate coupling between components, making it riskier to make changes without affecting unrelated parts of the system. Attempting to modify one system quality attribute can result in the unintended effect of changing the others. You are also more likely to create bugs when making a change. It then becomes difficult to reuse the component as it brings dependencies that are unlikely to be suitable for the use case.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor057"/>Coupling</h2>
			<p>Coupling is a bad idea in the context of <a id="_idIndexMarker156"/>cohesiveness, but the measurement of coupling is not bad at all. It provides a view of how interdependent the software components in the system are.</p>
			<p>Coupling is inevitable, but it can be minimized in a way that promotes better maintainability, reusability, and understanding. It is preferable to limit the interactions among components as much as possible.</p>
			<h3>Functional coupling</h3>
			<p>To limit the interactions among <a id="_idIndexMarker157"/>components, we must separate what needs to be done from how to do it. In the previous example, the “what” is the validation of households including <a id="_idIndexMarker158"/>their members; the “how” is that the validation functions run through each field and add violated conditions to a list to be returned. The household is valid if the returned list is empty.</p>
			<p>The definition of the work performed by a software component is a contract between the provider and the invoker. It typically consists of an input, an optional state, and an output. The invoker is concerned with the input to supply and the output to receive, but not with what happens internally within the software component. On the other hand, the provider is concerned with how to compute the output and optionally update the state based on the given input.</p>
			<p>This contract is often referred to as an interface between the provider and the invoker. It gives a good foundation for loosely coupled software components. With the interaction of both parties centered around the interfaces, the invoker now has the flexibility to switch to a different provider who can fulfill the contract. The provider need not do anything extra for another invoker who wants to reuse this functionality.</p>
			<p>This type of coupling is called <strong class="bold">functional coupling</strong>. It is based on the contracts or interfaces among software components.</p>
			<h3>Data coupling</h3>
			<p>A software component<a id="_idIndexMarker159"/> may require <a id="_idIndexMarker160"/>the data that it shares with another to function properly. The ownership of data is a topic in itself. However, in a simple sense, if there is only one component that creates, updates, or deletes a category of data, then that component owns the data.</p>
			<p>It is almost guaranteed that if more than one component owns the same piece of data, there will be a big problem in keeping the data reliable and consistent. In this situation, it is better for the two components to truly own their data.</p>
			<p>There are several options to consider:</p>
			<ol>
				<li>Should the components that share the same data be merged into one component?</li>
				<li>Can the ownership of the data be split among the components so they no longer share the same data?</li>
				<li>Can a new component be extracted to own the data, while other components become the listeners of the data change?</li>
				<li>Should one of the components take all the responsibility of creating, updating, and deleting the data, effectively becoming the owner of the data? This would mean that the other components become the listeners of the data change.</li>
				<li>Should each component own a copy of the data and let each copy be diverse in each component?</li>
				<li>Can<a id="_idIndexMarker161"/> each component keep a separate copy of the data owned by another<a id="_idIndexMarker162"/> component while there are reconciliation processes in place to process the difference?</li>
			</ol>
			<p>Given that a software component can own the data, it is important for the component to decide how much of the data should be exposed externally. The component should encapsulate the data to hide any internal data and only expose the fields that are related to the interface to other components.</p>
			<p>Moreover, it is often useful to separate the internal and external representations of the data. For instance, a list of internal error enumeration values may contain information that exposes the internal state of the component unintentionally.</p>
			<p>For example, given that there are several internal error enumeration values for a log-on operation, then the Kotlin enum class would look like the following code:</p>
			<pre class="source-code">
enum class InternalError {
    WRONG_PASSWORD,
    USERNAME_NOT_FOUND,
    FAILED_CAPTCHA,
    TIMED_OUT,
    INVALID_REQUEST
}</pre>			<p>If we expose<a id="_idIndexMarker163"/> all these values externally, the invoker of the component will be <a id="_idIndexMarker164"/>able to understand whether a username exists even if the log-on operation failed, or if both were valid but failed the captcha challenge. These are unnecessary details to the outside of the component and should be hidden. This is without mentioning the obvious security concern that is also at play. So, we could create a list of external error enumeration values to only show what is of interest to the invoker:</p>
			<pre class="source-code">
enum class ExternalError {
    FAILED_AUTHENTICATION,
    TIMED_OUT,
    INVALID_REQUEST
}</pre>			<h3>Temporal coupling</h3>
			<p>Two software components <a id="_idIndexMarker165"/>can be temporally coupled if they both need to be available for the <a id="_idIndexMarker166"/>whole operation to run through. Component A might need to invoke a synchronous remote call to component B to continue to handle its incoming requests, for example. An even worse situation would be a chain of multiple remote cascading calls to multiple components. An example of temporally coupled components is described in the UML sequence diagram that follows:</p>
			<div><div><img src="img/B21737_02_7.jpg" alt="Figure 2.7 – A Synchronous pull interaction" width="748" height="739"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – A Synchronous pull interaction</p>
			<p>Each time a synchronous<a id="_idIndexMarker167"/> call is made, it blocks the thread until there is an answer <a id="_idIndexMarker168"/>returned or until it times out. This is also called<a id="_idIndexMarker169"/> the <strong class="bold">pull-based</strong> approach. If we had multiple of these calls, it would be quite easy to cause a timed-out error to the original request.</p>
			<p>Synchronous remote calls have the nature of blocking the thread, pulling data, and depending on the component’s availability. There are cases where synchronous remote calls may be necessary due to time sensitivity, such as when the service must authenticate a user within a given number of seconds or time out.</p>
			<p>If all the synchronous remote calls are only there to provide data, then we can consider an asynchronous<a id="_idIndexMarker170"/> and <strong class="bold">push-based</strong> approach. Using this approach, component A subscribes to a topic whereby component B publishes an event when the data changes. Component A then keeps a copy of the <a id="_idIndexMarker171"/>data locally. Then component A no longer requires component B to be available to handle requests; component A uses the last known value instead. An example of asynchronous push interactions among <a id="_idIndexMarker172"/>components is illustrated as a UML sequence diagram in <em class="italic">Figure 2</em><em class="italic">.8</em>:</p>
			<div><div><img src="img/B21737_02_8.jpg" alt="Figure 2.8 – An asynchronous push interaction" width="763" height="754"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – An asynchronous push interaction</p>
			<p>If the interaction between components A and B is more procedural and sequential, then the components can still be loosely coupled by being reactive and asynchronous using events. In this scenario, component A has processed up to the point where it needs component B, so component A sends an event, and component B receives it. Then component B performs the work. When component B finishes its part, it sends an event that component A receives. Component A then continues the rest of the work. An example of the asynchronous reactive event-driven interaction among components can be expressed by a UML sequence diagram as follows:</p>
			<div><div><img src="img/B21737_02_9.jpg" alt="Figure 2.9 – An asynchronous reactive event-driven interaction" width="882" height="868"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – An asynchronous reactive event-driven interaction</p>
			<p>We have discussed the principles of separation of concerns, cohesiveness, and coupling. We went through why they are important and how the application of these concepts affects system quality attributes. We also covered the sub-categories of cohesiveness and coupling with real-time world examples. They are three different concepts but relate to each other often.</p>
			<p>Next, we are going to cover the <strong class="bold">SOLID principles</strong>. These principles encourage software architecture with separate concerns, highly cohesive components, and low coupling between components.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor058"/>SOLID principles</h1>
			<p>The SOLID principles<a id="_idIndexMarker173"/> are a set of five software architecture principles that advocate for creating maintainable, understandable, flexible, and modular software. Though they were originally targeted at object-oriented software, the concepts behind them are useful and can be applied to systems other than object orientation.</p>
			<p>These concepts were first introduced by Robert J. Martin in his <em class="italic">Design Principles and Design Patterns</em> paper in 2000. However, the SOLID acronym was introduced later by Michael Feathers.</p>
			<p>The acronym SOLID stands for the following:</p>
			<ul>
				<li><strong class="bold">Single Responsibility </strong><strong class="bold">Principle</strong> (<strong class="bold">SRP</strong>)</li>
				<li><strong class="bold">Open-Closed </strong><strong class="bold">Principle</strong> (<strong class="bold">OCP</strong>)</li>
				<li><strong class="bold">Liskov Substitution </strong><strong class="bold">Principle</strong> (<strong class="bold">LSP</strong>)</li>
				<li><strong class="bold">Interface Segregation </strong><strong class="bold">Principle</strong> (<strong class="bold">ISP</strong>)</li>
				<li><strong class="bold">Dependency Inversion </strong><strong class="bold">Principle</strong> (<strong class="bold">DIP</strong>)</li>
			</ul>
			<p>We will walk through each of them and use the concepts that we have covered for discussion.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor059"/>SRP</h2>
			<p>The SRP <a id="_idIndexMarker174"/>states that a class should have one responsibility or <a id="_idIndexMarker175"/>concern, and only one. There is only one reason to change. If a class conforming to this principle has a clear and well-defined purpose and it is then easier to understand, test, and maintain, it can be counted as an exception.</p>
			<p>Let us have a look at a class that violates the SRP:</p>
			<pre class="source-code">
interface HouseholdService {
    fun create(household: Household): Household
    fun draftContract(contract: Contract)
    fun notifyHouseholds(contract: Contract)
}</pre>			<p>The <code>HouseholdService</code> interface is responsible for creating a household, drafting a contract, and<a id="_idIndexMarker176"/> notifying the households involved in a <a id="_idIndexMarker177"/>contract. This class can change due to a change in any one of these operations.</p>
			<p>We can refactor the example to conform to SRP:</p>
			<pre class="source-code">
interface HouseholdService {
    fun create(household: Household): Household
}
interface ContractService {
    fun draftContract(contract: Contract)
}
interface NotificationService {
    fun notifyHouseholds(contract: Contract)
}</pre>			<p>Now <code>HouseholdService</code> is only responsible for managing households. The <code>ContractService</code> interface is solely responsible for drafting a contract. <code>NotificationService</code> only aims to notify the households involved in a contract. Now each class only has one responsibility and one reason to change.</p>
			<p>There are a few more benefits that come with this change. Each class is now more testable, easier to understand, and easier to maintain. Each class can evolve and extend its functions independently. A concern in a single class can be addressed without impacting the others. Other <a id="_idIndexMarker178"/>classes can also reuse one of these classes easily <a id="_idIndexMarker179"/>without pulling in some never-to-be-used functions.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor060"/>OCP</h2>
			<p>The OCP<a id="_idIndexMarker180"/> states that<a id="_idIndexMarker181"/> software components such as classes, modules, and functions should be open for extension but closed for modification.</p>
			<p>A component is <em class="italic">open</em> if its behaviors can be extended without modifying the existing code. A highly cohesive component already contains all strongly related elements, so an extension of the behavior only needs to use what is already provided and does not need to modify the code inside.</p>
			<p>A component is <em class="italic">closed</em> if it can be used by other components. We should be able to modify the implementation without changing the behaviors. A loosely coupled component offers a simple and straightforward way for it to be used by other components without pulling in dependencies that others may not wish to include.</p>
			<p>In the following example, there is a <code>NotificationService</code> that notifies households of the status of the contract in which they are involved:</p>
			<pre class="source-code">
interface NotificationService {
    fun notifyHouseholds(contract: Contract)
}
class SmsNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
        // send SMS messages to household's phone numbers
    }
}
class EmailNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
        // send messages to household's email addresses
    }
}</pre>			<p>We have an interface that defines a <code>notifyHouseholds(contract: Contract)</code> function. <code>SmsNotificationService</code> and <code>EmailNotificationService</code> are concrete implementations of the interface.</p>
			<p>If we want to<a id="_idIndexMarker182"/> extend the behavior by adding a new medium of<a id="_idIndexMarker183"/> communication, such as phone app notifications, we can create a new concrete implementation without modifying any existing code. This interface is <em class="italic">open</em> for extension.</p>
			<p>We can reuse this interface in other situations where we need to notify households about their contract. We can update the way in which <code>EmailNotificationService</code> is authenticated with the <strong class="bold">Simple Mail Transfer Protocol</strong> (<strong class="bold">SMTP</strong>) server<a id="_idIndexMarker184"/> without changing the interface. This interface is <em class="italic">closed</em> for modification.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor061"/>LSP</h2>
			<p>The LSP states<a id="_idIndexMarker185"/> that the objects of a superclass can be replaced by<a id="_idIndexMarker186"/> objects of its subclasses with no change in the correction of the system.</p>
			<p>In other words, all subclasses should behave functionally identically to their superclasses.</p>
			<p>From the previous example, <code>NotificationService</code> specifies that the <code>notifyHouseholds</code> function would notify the households involved in the given contract. From a behavioral function point of view, it can do this via emails, text messages, or any other ways of communication. However, all these subclasses should notify the households that are involved in the given contract.</p>
			<p>On the contrary, if there is a <code>PhoneNotificationService</code> that not only notifies households involved in a contract but also updates the contract status to <code>UNDER_REVIEW</code>, it would violate the LSP. This is because if <code>EmailNotificationService</code> is replaced by <code>PhoneNotificationService</code>, the contract status will be updated, which would not happen before the replacement:</p>
			<pre class="source-code">
class PhoneNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
         // ring an automated message to household's phone
   // also update contract status to UNDER_REVIEW
    }
}</pre>			<p>If we adhere to the <a id="_idIndexMarker187"/>LSP, then we will have classes that are highly<a id="_idIndexMarker188"/> cohesive, as it only focuses on classes being behaviorally equivalent to their superclasses and nothing else.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor062"/>ISP</h2>
			<p>The ISP states <a id="_idIndexMarker189"/>that clients should not be forced to depend upon<a id="_idIndexMarker190"/> interfaces that they do not use.</p>
			<p>This principle promotes that interfaces should be designed to be specific to the needs of the clients that use them. This could result in a few outcomes:</p>
			<ul>
				<li><strong class="bold">Small and numerous interfaces</strong>: The interface is small, so the clients do not need to depend on functions from an interface that they do not use. Since each interface is smaller, there are likely to be more interfaces to cover the same scope of functionalities.</li>
				<li><strong class="bold">Relevance</strong>: The interface is relevant and specific to the needs of the clients. Different clients may have unique needs. Therefore, there may be a few specific interfaces for different clients. There may be an overlap of functionalities and some clients may want unique behaviors that are only relevant to them for different clients.</li>
				<li><strong class="bold">Higher cohesiveness</strong>: Each interface shall contain only related functions and ideally focus on one responsibility.</li>
				<li><strong class="bold">Looser coupling</strong>: Since the interfaces are smaller, the coupling with other components is also looser.</li>
			</ul>
			<p>This is an example of a violation of the ISP:</p>
			<pre class="source-code">
interface Human {
    fun logOn()
    fun exerciseContract()
}
data class User(val username: String) : Human {
    override fun logOn() {
        // user log on
    }
    override fun exerciseContract() {
        throw UnsupportedOperationException("user cannot exercise contract")
    }
}
data class HouseholdMember(val name: String) : Human {
    override fun logOn() {
        throw UnsupportedOperationException("household members do not log on")
    }
    override fun exerciseContract() {
        // exercise contract
    }
}</pre>			<p>The <code>Human</code> interface<a id="_idIndexMarker191"/> has two functions: <code>logOn</code> and <code>exerciseContract</code>. There are two concrete implementations: <code>User</code> and <code>HouseholdMember</code>. While <a id="_idIndexMarker192"/>both users and household members are human, they have nothing in common functionally. Both subclasses were forced to implement functions that they had no use for. The interface should be segregated so that they are specifically targeted toward the functions for users and household members.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor063"/>DIP</h2>
			<p>The <a id="_idIndexMarker193"/>DIP consists <a id="_idIndexMarker194"/>of two parts:</p>
			<ol>
				<li>High-level components should not depend on low-level components directly. Both should depend on abstractions.</li>
				<li>Abstractions should not depend on details; details should depend on abstractions.</li>
			</ol>
			<p>Abstractions can be referred to as interfaces and details can be referred to as concrete implementations. The rationale behind the principle is that the user of a component should only care about the behaviors of the component, not its implementation.</p>
			<p>For example, if we want to reuse the component that notifies the households involved in a contract in a workflow, then the principle suggests that we reference the component as the <code>NotificationService</code> type, even if we know that <code>EmailNotificationService</code> is the concrete implementation.</p>
			<p>This approach brings a few benefits:</p>
			<ul>
				<li>The <code>NotificationService</code> interface can be mocked or replaced by a <code>EmailNotificationService</code>. Our unit tests focus on how to interact with <code>NotificationService</code>, handling several types of outcomes from the <code>notifyHouseholds</code> function.</li>
				<li>The dependency on <code>NotificationService</code> can be injected or looked up at runtime. This gives us the flexibility to swap it with a different concrete implementation and have the function still run correctly. An <strong class="bold">Inversion of Control</strong> (<strong class="bold">IoC</strong>) container <a id="_idIndexMarker196"/>framework can support the implementation of the injection.</li>
				<li>Coupling with <code>NotificationService</code> is loosened to only care about the behaviors.</li>
				<li>The code is easier to maintain as swapping the concrete implementation of <code>NotificationService</code> requires no code changes.</li>
				<li>It is easier to extend <code>NotificationService</code> by providing a different concrete implementation.</li>
			</ul>
			<p>Let us look at<a id="_idIndexMarker197"/> the ensuing example <a id="_idIndexMarker198"/>and see whether it adheres to the DIP:</p>
			<pre class="source-code">
class ContractWorkflowService(
    val emailNotificationService: EmailNotificationService,
) {
    fun agree(contract: Contract): Contract {
        return contract.copy(agreedAt = Instant.now()).also {
 emailNotificationService.notifyHouseholds(contract)
        }
    }
}
interface NotificationService {
    fun notifyHouseholds(contract: Contract)
}
class EmailNotificationService : NotificationService {
    override fun notifyHouseholds(contract: Contract) {
        // send messages to household's email addresses
    }
}</pre>			<p><code>ContractWorkflowService</code> has a function to mark a contract as <code>agreed</code>. After the contract is agreed to, it invokes <code>EmailNotificationService</code> to notify households about the agreement. However, <code>ContractWorkflowService</code> uses the function from the interface <code>NotificationService</code> and not the subclass.</p>
			<p>There is no need for <code>ContractWorkflowService</code> to reference the concrete implementation as the service does not concern itself with whether the notification is sent via email or another channel. This is a violation of the DIP.</p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor064"/>The Law of Demeter</h1>
			<p>The <strong class="bold">Law of Demeter</strong>, or the principle <a id="_idIndexMarker199"/>of least knowledge, states that a software component should have limited knowledge about the inner details of other components. More specifically, a component should not know about the internal details of another component.</p>
			<p>Let us say there is a function that returns the city in the address of a person:</p>
			<pre class="source-code">
class Person(val name: String, val address: Address) {
    fun getAddressCity(): String {
        return address.city
    }
}
class Address(val city: String)</pre>			<p>The <code>Person</code> class directly accesses the <code>city</code> property inside the <code>Address</code> class. The <code>Person</code> class should not have this knowledge, as this is a violation of the <strong class="bold">Law </strong><strong class="bold">of Demeter</strong>.</p>
			<p>This creates a coupling between <code>Person</code> and <code>Address</code>. The coupling dictates that if the <code>city</code> property changes its data type, then both classes will need to change. It also means that the code change is bigger than it needs to be, hence making it less maintainable and testable.</p>
			<p>To conform to the Law of Demeter, the <code>getAddressCity</code> function should be provided by the <code>Address</code> class. This reduces the responsibility of the <code>Person</code> class for getting the city of an address and thereby reduces the complexity of the code base.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor065"/>YAGNI and future-proof architecture</h1>
			<p><strong class="bold">You Ain’t Gonna Need It</strong> <strong class="bold">(YAGNI</strong>) is a<a id="_idIndexMarker200"/> principle that states that functionalities should not be implemented until they are needed. This principle came from <strong class="bold">Extreme Programming</strong> (<strong class="bold">XP</strong>) as an approach to improve software quality and respond to<a id="_idIndexMarker201"/> changing business requirements.</p>
			<p>This principle is also related to the idea of minimalism in software development, which states that we should avoid unnecessary code and complexity in exchange for clean, easy-to-understand, and extensible software.</p>
			<p>Another way to describe YAGNI is as the imperative to do the simplest thing that works. This is by no means an incomplete design or unfulfilled user requirement. It still promotes complete and functional software that satisfies user requirements with the simplest design available.</p>
			<p>YAGNI aims at a few practices:</p>
			<ul>
				<li><strong class="bold">Simple and lean code base</strong>: By <a id="_idIndexMarker202"/>implementing only what is necessary now, a lot of complexity can be avoided. As a result, the code base is simple, clean, and maintainable.</li>
				<li><strong class="bold">Prevention of over-engineering</strong>: Over-engineering happens when an engineer anticipates future requirements and includes unused features in the system. It not only results in wasted time on unnecessary work but also becomes a dead weight in the code base, which is then made harder to maintain. Over-engineered code also implies a design choice made before there is sufficient information to make that choice, locking in the approach prematurely.</li>
				<li><strong class="bold">Adaptive and flexible implementation</strong>: By delaying the implementation of a feature until it is needed, engineers have more options to adapt to changes when the feature is finally needed. It also encourages a more organic evolution of the system whereby engineers respond more effectively to changing requirements.</li>
				<li><strong class="bold">Productivity</strong>: By focusing on the absolute must-have requirements, engineers can deliver changes more quickly and efficiently. Any unnecessary features can be postponed, saving <a id="_idIndexMarker203"/>time and resources.</li>
			</ul>
			<p>There<a id="_idIndexMarker204"/> is also an opposite idea though: <strong class="bold">future-proof architecture</strong>. It aims at creating systems that are unlikely to be obsolete or to fail in the future. This sounds very appealing. If we can build a system that can fulfill future requirements, we will have saved time and effort that would otherwise be spent continuously evolving it.</p>
			<p>However, there is an assumption behind this. You need to predict the new requirements and you need to be right. That is equivalent to knowing the future. It rarely happens.</p>
			<p>If you are certain about requiring a feature in the future, then it is neither a prediction nor a future requirement. It is simply a requirement now.</p>
			<p>This does not mean that we should build systems based on short-term objectives or take shortcuts. Instead, we should build systems that are ready to adapt to new requirements but not have these implemented.</p>
			<p><strong class="bold">Capacity planning</strong> should <a id="_idIndexMarker205"/>not be mistaken for future-proof architecture. Capacity planning is an operational concern related to deployment and physical resources. For instance, building a road to handle twice the current traffic is different from building a branch of the road that goes nowhere. Leaving headroom for expansion, extra volume, and extra traffic is part of the readiness for evolution. Capacity planning is an NFR, not a future requirement. We would not want the system to run on edges that may collapse in response to a fluctuation in the volume of requests.</p>
			<p>This mindset leads to a few outcomes. The software architecture aims for modular, extensible, and flexible components that are ready to make changes when they become necessary.</p>
			<p>It implies that each component is highly cohesive but loosely coupled. It means that interfaces are small and specific. It also means that interactions among components are based on abstract interfaces and not concrete implementations. It further means that subclasses conform to the behaviors of their superclasses and are ready to be extended. Furthermore, it means that each component has only one reason to change. It also means that modifying a component does not require recompiling the entire system. It also means that concerns are separated so that when we want to adjust system quality attributes, we can address the particular concern in isolation.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor066"/>Summary</h1>
			<p>We have covered the 4+1 architecture view model, as well as system quality attributes, separation of concerns, cohesiveness, coupling, the SOLID principles, and the Law of Demeter. We have demonstrated them with code examples. These demonstrated that adhering to these principles lets the code become modular, flexible, maintainable, extensible, and easy to understand.</p>
			<p>We have also discussed the conflicting concepts of the YAGNI principle and future-proof architecture. We clarified what future-proofing is and how it is different from capacity planning.</p>
			<p>In the next chapter, we will explore polymorphism and its alternative approaches.</p>
		</div>
	</div></div></body></html>