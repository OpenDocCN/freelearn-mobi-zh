- en: Chapter 3. Mix in the Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit includes a fully functional physics engine. It is easy to implement
    and very useful; most mobile game designs require some level of physical interaction
    between game objects. In our game, we want to know when the player runs into the
    ground, an enemy, or a power-up. The physics system can track these collisions
    and execute our specific game code when any of these events occur. SpriteKit's
    physics engine can also apply gravity to the world, bounce and spin colliding
    sprites against each other, and create realistic movement through impulses – and
    it does all of this before every single frame is drawn to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Adopting a protocol for consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing game objects into classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the player's character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renovating the `GameScene` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physics bodies and gravity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring physics simulation mechanics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movement with impulses and forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bumping bees into bees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laying the foundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned through small bits of code, individually added to the
    `GameScene` class. The intricacy of our application is about to increase. To build
    a complex game world, we will need to construct re-usable classes and actively
    organize our new code.
  prefs: []
  type: TYPE_NORMAL
- en: Following protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, we want individual classes for each of our game objects (a bee class,
    a player penguin class, a power-up class, and so on). Furthermore, we want all
    of our game object classes to share a consistent set of properties and methods.
    We can enforce this commonality by creating a **protocol**, or a blueprint for
    our game classes. The protocol does not provide any functionality on its own,
    but each class that adopts the protocol must follow its specifications exactly
    before Xcode can compile the project. Protocols are very similar to interfaces,
    if you are from a Java or C# background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new file to your project (right-click in the project navigator and choose
    **New File**, then **Swift File**) and name it `GameSprite.swift`. Then add the
    following code to your new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, any class that adopts the `GameSprite` protocol must implement a `textureAtlas`
    property, a `spawn` function, and an `onTap` function. We can safely assume that
    the game objects provide these implementations when we work with them in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Reinventing the bee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our old bee is working wonderfully, but we want to spawn many bees throughout
    the world. We will create a `Bee` class, inheriting from `SKSpriteNode`, so we
    can cleanly stamp as many bees to the world as we please.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is a common convention to separate each class into its own file. Add a new
    `Swift` file to your project and name it `Bee.swift`. Then, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now easy to spawn as many bees as we like. Switch back to `GameScene.swift`,
    and add this code in `didMoveToView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project. Bees, bees everywhere! Our original bee is flying back and
    forth through a swarm. Your simulator should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reinventing the bee](img/Image_B04532_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Depending on how you look at it, you may perceive that the new bees are moving
    and the original bee is still. We need to add a point of reference. Next, we will
    add the ground.
  prefs: []
  type: TYPE_NORMAL
- en: The icy tundra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will add some ground at the bottom of the screen to serve as a constraint
    for player positioning and as a reference point for movement. We will create a
    new class named `Ground`. First, let us add the texture atlas for the ground art
    to our project.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to add assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use a different method of adding files to Xcode. Follow these steps
    to add the new artwork:'
  prefs: []
  type: TYPE_NORMAL
- en: In Finder, navigate to the asset pack you downloaded in [Chapter 2](ch02.html
    "Chapter 2. Sprites, Camera, Actions!"), *Sprites, Camera, Actions!*, and then
    to the `Environment` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You learned to create a texture atlas earlier, for our bee. I have already created
    texture atlases for the rest of the art we use in this game. Locate the `ground.atlas`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag and drop this folder into the project manager in Xcode, under the project
    folder, as seen in this screenshot:![Another way to add assets](img/Image_B04532_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box, make sure your settings match the following screenshot, and
    then click **Finish**:![Another way to add assets](img/Image_B04532_03_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perfect – you should see the ground texture atlas in the project navigator.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Ground class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will add the code for the ground. Add a new Swift file to your project
    and name it `Ground.swift`. Use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tiling a texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why do we need the `createChildren` function? SpriteKit does not support a built-in
    method to repeat a texture over the size of a node. Instead, we create children
    nodes for each texture tile and append them across the width of the parent. Performance
    is not an issue; as long as we attach the children to one parent, and the textures
    all come from the same texture atlas, SpriteKit handles them with one draw call.
  prefs: []
  type: TYPE_NORMAL
- en: Running wire to the ground
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have added the ground art to the project and created the `Ground` class.
    The final step is to create an instance of `Ground` in our scene. Follow these
    steps to wire-up the ground:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `GameScene.swift` and add a new property to the `GameScene` class to create
    an instance of the `Ground` class. You can place this underneath the line that
    instantiates the world node (the new code is in bold):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Locate the `didMoveToView` function. Add the following code at the bottom,
    underneath our bee spawning lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the project. You will see the icy tundra appear underneath our bees. This
    small change goes a long way towards creating the feeling that our central bee
    is moving through space. Your simulator should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running wire to the ground](img/Image_B04532_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A wild penguin appears!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more class to build before we start our physics lesson: the `Player`
    class! It is time to replace our moving bee with a node designated as the player.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will add the texture atlas for our penguin art. By now, you are familiar
    with adding files through the project navigator. Add the Pierre art as you did
    previously with the ground assets. I named Pierre's texture atlas `pierre.atlas`.
    You can find it in the asset pack, inside the `Pierre` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you add Pierre''s texture atlas to the project, you can create the `Player`
    class. Add a new Swift file to your project and name it `Player.swift`. Then add
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Before we continue, we need to replace our original bee with an instance
    of the new `Player` class we just created. Follow these steps to replace the bee:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameScene.swift`, near the top, remove the line that creates a `bee` constant
    in the `GameScene` class. Instead, we want to instantiate an instance of `Player`.
    Add the new line: `let player = Player()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Completely delete the `addTheFlyingBee` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `didMoveToView`, remove the line that calls `addTheFlyingBee`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `didMoveToView`, at the bottom, add a new line to spawn the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further down, in `didSimulatePhysics`, replace the references to the bee with
    references to `player`. Recall that we created the `didSimulatePhysics` function
    in [Chapter 2](ch02.html "Chapter 2. Sprites, Camera, Actions!"), *Sprites, Camera,
    Actions!*, when we centered the camera on one node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have successfully transformed the original bee into a penguin. Before we
    move on, we will make sure your `GameScene` class includes all of the changes
    we have made so far in this chapter. After that, we will begin to explore the
    physics system.
  prefs: []
  type: TYPE_NORMAL
- en: Renovating the GameScene class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have made quite a few changes to our project. Luckily, this is the last
    major overhaul of the previous animation code. Moving forward, we will use the
    terrific structure we built in this chapter. At this point, your `GameScene.swift`
    file should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project. You will see our new penguin hovering near the bees. Great
    work; we are now ready to explore the physics system with all of our new nodes.
    Your simulator should look something like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Renovating the GameScene class](img/Image_B04532_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exploring the physics system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SpriteKit simulates physics with **physics bodies**. We attach physics bodies
    to all the nodes that need physics computations. We will set up a quick example
    before exploring all of the details.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping like flies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our bees need to be part of the physics simulation, so we will add physics
    bodies to their nodes. Open your `Bee.swift` file and locate the `spawn` function.
    Add the following code at the bottom of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is that easy to add a node to the physics simulation. Run the project. You
    will see our three `Bee` instances drop off the screen. They are now subject to
    gravity, which is on by default.
  prefs: []
  type: TYPE_NORMAL
- en: Solidifying the ground
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want the ground to catch falling game objects. We can give the ground its
    own physics body so the physics simulation can stop the bees from falling through
    it. Open your `Ground.swift` file, locate the `spawn` function, and then add this
    code at the bottom of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project. The bees will now quickly drop and then stop once they collide
    with the ground. Notice how bees that fall farther bounce more energetically.
    After the bees land, your simulator will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Solidifying the ground](img/Image_B04532_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checkpoint 3-A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great work so far. We have added a lot of structure to our game and started
    to explore the physics system. If you would like to download my project to this
    point, do so here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-3](http://www.thinkingswiftly.com/game-development-with-swift/chapter-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring physics simulation mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the specifics of SpriteKit''s physics system.
    For instance, why are the bees subject to gravity, but the ground stays where
    it is? Though we attached physics bodies to both nodes, we actually used two different
    styles of physics bodies. There are three types of physics bodies, and each behaves
    slightly differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic** physics bodies have volume and are fully subject to forces and
    collisions in the system. We will use dynamic physics bodies for most parts of
    the game world: the player, enemies, power-ups, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static** physics bodies have volume but no velocity. The physics simulation
    does not move nodes with static bodies but they can still collide with other game
    objects. We can use static bodies for walls or obstacles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge** physics bodies have no volume and the physics simulation will never
    move them. They mark off the boundaries of movement; other physics bodies will
    never cross them. Edges can cross each other to create small containment areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Voluminous (dynamic and static) bodies have a variety of properties that modify
    how they react to collisions and movement through space. This allows us to create
    a wide range of realistic physics effects. Each property controls one aspect of
    a body''s physical characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Restitution** determines how much energy is lost when one body bounces into
    another. This changes the body''s bounciness. SpriteKit measures restitution on
    a scale from 0.0 to 1.0\. The default value is 0.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction** describes the amount of force necessary to slide one body against
    another body. This property also uses a scale of 0.0 to 1.0, with a default value
    of 0.2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Damping** determines how quickly a body slows as it moves through space.
    You can think of damping as air friction. Linear damping determines how quickly
    a body loses speed, while angular damping affects rotation. Both measure from
    0.0 to 1.0, with a default value of 0.1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mass** is measured in kilograms. It describes how far colliding objects push
    the body and factors in momentum during movement. Bodies with more mass will move
    less when hit by another body and will push other bodies further when they collide
    with them. The physics engine automatically uses the mass and the area of the
    body to determine **density**. Alternatively, you can set the density and let
    the physics engine calculate mass. It is usually more intuitive to set the mass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All right – enough with the textbook! Let us solidify our learning with some
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we want gravity to skip our bees. We will set their flight paths manually.
    We need the bees to be dynamic physics bodies in order to interact properly with
    other nodes, but we need these bodies to ignore gravity. For such instances, SpriteKit
    provides a property named `affectedByGravity`. Open `Bee.swift` and, at the bottom
    of the `spawn` function, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The question mark after `physicsBody` is optional chaining. We need to unwrap
    `physicsBody`, since it is optional. If `physicsBody` is nil, the entire statement
    will return nil (instead of triggering an error). You can think of it as gracefully
    unwrapping an optional property with an inline statement.
  prefs: []
  type: TYPE_NORMAL
- en: Run the project. The bees should now hover in place as they did before we added
    their bodies. However, SpriteKit's physics simulation now affects them; they will
    react to impulses and collisions. Great, let us purposefully collide the bees.
  prefs: []
  type: TYPE_NORMAL
- en: Bee meets bee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that we positioned `bee2` and `bee3` at the same height
    in the game world. We only need to push one of them horizontally to create a collision
    – perfect crash test dummies! We can use an **impulse** to create velocity for
    the outside bee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the `didMoveToView` function in `GameScene.swift`. At the bottom, below
    all of our spawn code, add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the project. You will see the outermost bee fly towards the middle and crash
    into the inner bee. This pushes the inner bee to the left and slows the first
    bee from the contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attempt the same experiment with a variable: increased mass. Before the impulse
    line, add this code to adjust the mass of `bee2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project. Hmm, our heavier bee does not move very far with the same
    impulse (it is a 200-gram bee, after all.) It eventually bumps into the inner
    bee, but it is not a very exciting collision. We will need to crank up the impulse
    to propel our beefier bee. Change the impulse line to use a `dx` value of `-15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project again. This time, our impulse provides enough energy to move
    the heavy bee in an interesting way. Notice how much energy the heavy bee transfers
    to the normal bee when they collide; the lighter bee shoots away after contact.
    Both bees possess enough momentum to eventually slide completely off the screen.
    Your simulator should look something like this screenshot, just before the bees
    slide off the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bee meets bee](img/Image_B04532_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before you move on, you may wish to experiment with the various physics properties
    that I outlined earlier in the chapter. You can create many collision variations;
    the physics simulation offers a lot of depth with out much effort.
  prefs: []
  type: TYPE_NORMAL
- en: Impulse or force?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have several options for moving nodes with physics bodies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An impulse is an immediate, one-time change to a physics body''s velocity.
    In our test, an impulse gave the bee its velocity, and it slowly bled speed to
    damping and its collision. Impulses are perfect for projectiles: missiles, bullets,
    disgruntled birds, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A force applies velocity for only one physics calculation cycle. When we use
    a force, we typically apply it before every frame. Forces are useful for rocket
    ships, cars, or anything else that is continually self-propelled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also edit the `velocity` and `angularVelocity` properties of a body
    directly. This is useful for setting a manual velocity limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkpoint 3-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have made a number of structural changes to our project in this chapter.
    Feel free to download my project to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-3](http://www.thinkingswiftly.com/game-development-with-swift/chapter-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made great strides in this chapter. Our new class organization will
    serve us well over the course of this book. We learned how to use protocols to
    enforce commonality across classes, encapsulated our game objects into distinct
    classes, and explored tiling textures over the width of the ground node. Finally,
    we cleaned out some of our previous learning code from `GameScene` and used the
    new class system to spawn all of our game objects.
  prefs: []
  type: TYPE_NORMAL
- en: We also applied the physics simulation to our game. We have only scratched the
    surface of the powerful physics system in SpriteKit – we will dive deeper into
    custom collision events in [Chapter 7](ch07.html "Chapter 7. Implementing Collision
    Events"), *Implementing Collision Events* – but we have already gained quite a
    bit of functionality. We explored the three types of physics bodies and studied
    the various physics properties you can use to fine-tune the physical behavior
    of your game objects. Then, we put all of our hard work into practice by bumping
    our bees together and watching the results.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will try several control schemes and move our player around the game
    world. This is an exciting addition; our project will begin to feel like a true
    game in [Chapter 4](ch04.html "Chapter 4. Adding Controls"), *Adding Controls*.
  prefs: []
  type: TYPE_NORMAL
