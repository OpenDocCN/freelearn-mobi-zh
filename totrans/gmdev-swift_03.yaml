- en: Chapter 3. Mix in the Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：混合物理
- en: SpriteKit includes a fully functional physics engine. It is easy to implement
    and very useful; most mobile game designs require some level of physical interaction
    between game objects. In our game, we want to know when the player runs into the
    ground, an enemy, or a power-up. The physics system can track these collisions
    and execute our specific game code when any of these events occur. SpriteKit's
    physics engine can also apply gravity to the world, bounce and spin colliding
    sprites against each other, and create realistic movement through impulses – and
    it does all of this before every single frame is drawn to the screen.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 包含一个功能齐全的物理引擎。它易于实现且非常有用；大多数移动游戏设计都需要游戏对象之间一定程度的物理交互。在我们的游戏中，我们想知道玩家何时撞到地面、敌人或道具。物理系统可以跟踪这些碰撞，并在这些事件发生时执行我们的特定游戏代码。SpriteKit
    的物理引擎还可以将重力应用于世界，使碰撞的精灵相互弹跳和旋转，并通过冲量创建逼真的运动——而且它会在屏幕上绘制每一帧之前完成所有这些。
- en: 'The topics in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Adopting a protocol for consistency
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保持一致性，采用协议
- en: Organizing game objects into classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将游戏对象组织到类中
- en: Adding the player's character
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加玩家的角色
- en: Renovating the `GameScene` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建 `GameScene` 类
- en: Physics bodies and gravity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理体和重力
- en: Exploring physics simulation mechanics
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索物理模拟机制
- en: Movement with impulses and forces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用冲量和力进行移动
- en: Bumping bees into bees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将蜜蜂撞进蜜蜂中
- en: Laying the foundation
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打好基础
- en: So far, we have learned through small bits of code, individually added to the
    `GameScene` class. The intricacy of our application is about to increase. To build
    a complex game world, we will need to construct re-usable classes and actively
    organize our new code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过向 `GameScene` 类逐个添加小块代码来学习。我们应用程序的复杂性即将增加。为了构建一个复杂的游戏世界，我们需要构建可重用的类并积极组织我们的新代码。
- en: Following protocol
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循协议
- en: To start, we want individual classes for each of our game objects (a bee class,
    a player penguin class, a power-up class, and so on). Furthermore, we want all
    of our game object classes to share a consistent set of properties and methods.
    We can enforce this commonality by creating a **protocol**, or a blueprint for
    our game classes. The protocol does not provide any functionality on its own,
    but each class that adopts the protocol must follow its specifications exactly
    before Xcode can compile the project. Protocols are very similar to interfaces,
    if you are from a Java or C# background.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要为每个游戏对象创建单独的类（蜜蜂类、玩家企鹅类、道具类等）。此外，我们希望所有游戏对象类都共享一组一致的属性和方法。我们可以通过创建一个
    **协议**，即我们游戏类的蓝图来强制这种一致性。协议本身不提供任何功能，但采用该协议的每个类都必须完全遵循其规范，Xcode 才能编译项目。如果您来自 Java
    或 C# 背景，协议与接口非常相似。
- en: 'Add a new file to your project (right-click in the project navigator and choose
    **New File**, then **Swift File**) and name it `GameSprite.swift`. Then add the
    following code to your new file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将新文件添加到您的项目中（在项目导航器中右键单击并选择**新建文件**，然后选择**Swift 文件**），并将其命名为 `GameSprite.swift`。然后，将以下代码添加到您的新文件中：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, any class that adopts the `GameSprite` protocol must implement a `textureAtlas`
    property, a `spawn` function, and an `onTap` function. We can safely assume that
    the game objects provide these implementations when we work with them in our code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何采用 `GameSprite` 协议的类都必须实现一个 `textureAtlas` 属性、一个 `spawn` 函数和一个 `onTap`
    函数。当我们用代码处理游戏对象时，我们可以安全地假设游戏对象提供了这些实现。
- en: Reinventing the bee
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新发明蜜蜂
- en: Our old bee is working wonderfully, but we want to spawn many bees throughout
    the world. We will create a `Bee` class, inheriting from `SKSpriteNode`, so we
    can cleanly stamp as many bees to the world as we please.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老蜜蜂工作得非常好，但我们想在世界的各个地方生成许多蜜蜂。我们将创建一个继承自 `SKSpriteNode` 的 `Bee` 类，这样我们就可以干净利落地将任意数量的蜜蜂印在世界上了。
- en: 'It is a common convention to separate each class into its own file. Add a new
    `Swift` file to your project and name it `Bee.swift`. Then, add this code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个类单独分离到其自己的文件中是一种常见的约定。向您的项目中添加一个新的 `Swift` 文件，并将其命名为 `Bee.swift`。然后，添加以下代码：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It is now easy to spawn as many bees as we like. Switch back to `GameScene.swift`,
    and add this code in `didMoveToView`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以轻松地生成我们想要的任意数量的蜜蜂。切换回 `GameScene.swift`，并在 `didMoveToView` 中添加以下代码：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the project. Bees, bees everywhere! Our original bee is flying back and
    forth through a swarm. Your simulator should look like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。蜜蜂，到处都是！我们的原始蜜蜂正在一群蜜蜂中来回飞行。您的模拟器应该看起来像这样：
- en: '![Reinventing the bee](img/Image_B04532_03_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![重新发明蜜蜂](img/Image_B04532_03_01.jpg)'
- en: Depending on how you look at it, you may perceive that the new bees are moving
    and the original bee is still. We need to add a point of reference. Next, we will
    add the ground.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的看法，你可能觉得新蜜蜂在移动，而原始蜜蜂是静止的。我们需要添加一个参考点。接下来，我们将添加地面。
- en: The icy tundra
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冰原
- en: We will add some ground at the bottom of the screen to serve as a constraint
    for player positioning and as a reference point for movement. We will create a
    new class named `Ground`. First, let us add the texture atlas for the ground art
    to our project.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在屏幕底部添加一些地面，作为玩家定位的约束和移动的参考点。我们将创建一个名为`Ground`的新类。首先，让我们将地面艺术纹理图集添加到我们的项目中。
- en: Another way to add assets
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种添加资源的方式
- en: 'We will use a different method of adding files to Xcode. Follow these steps
    to add the new artwork:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用不同的方法将文件添加到Xcode中。按照以下步骤添加新的艺术作品：
- en: In Finder, navigate to the asset pack you downloaded in [Chapter 2](ch02.html
    "Chapter 2. Sprites, Camera, Actions!"), *Sprites, Camera, Actions!*, and then
    to the `Environment` folder.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Finder中，导航到你在[第2章](ch02.html "第2章。精灵、相机、动作！")下载的资产包，*精灵、相机、动作！*，然后到`Environment`文件夹。
- en: You learned to create a texture atlas earlier, for our bee. I have already created
    texture atlases for the rest of the art we use in this game. Locate the `ground.atlas`
    folder.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你之前已经学会了如何为我们的蜜蜂创建纹理图集。我已经为我们在游戏中使用的其余艺术作品创建了纹理图集。定位`ground.atlas`文件夹。
- en: Drag and drop this folder into the project manager in Xcode, under the project
    folder, as seen in this screenshot:![Another way to add assets](img/Image_B04532_03_02.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件夹拖放到Xcode的项目管理器中，在项目文件夹下，如图所示：![另一种添加资源的方式](img/Image_B04532_03_02.jpg)
- en: In the dialog box, make sure your settings match the following screenshot, and
    then click **Finish**:![Another way to add assets](img/Image_B04532_03_03.jpg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，确保你的设置与以下截图匹配，然后点击**完成**：![另一种添加资源的方式](img/Image_B04532_03_03.jpg)
- en: Perfect – you should see the ground texture atlas in the project navigator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 完美——你应该在项目导航器中看到地面纹理图集。
- en: Adding the Ground class
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加地面类
- en: 'Next, we will add the code for the ground. Add a new Swift file to your project
    and name it `Ground.swift`. Use the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加地面代码。在你的项目中添加一个新的Swift文件，并将其命名为`Ground.swift`。使用以下代码：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tiling a texture
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理平铺
- en: Why do we need the `createChildren` function? SpriteKit does not support a built-in
    method to repeat a texture over the size of a node. Instead, we create children
    nodes for each texture tile and append them across the width of the parent. Performance
    is not an issue; as long as we attach the children to one parent, and the textures
    all come from the same texture atlas, SpriteKit handles them with one draw call.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要`createChildren`函数？SpriteKit不支持内置方法来重复节点大小的纹理。相反，我们为每个纹理瓦片创建子节点，并将它们附加到父节点的宽度上。性能不是问题；只要我们将子节点附加到一个父节点上，并且所有纹理都来自同一个纹理图集，SpriteKit就会通过一个绘制调用来处理它们。
- en: Running wire to the ground
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将电线接到地面上
- en: 'We have added the ground art to the project and created the `Ground` class.
    The final step is to create an instance of `Ground` in our scene. Follow these
    steps to wire-up the ground:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将地面艺术添加到项目中并创建了`Ground`类。最后一步是在场景中创建`Ground`的实例。按照以下步骤连接地面：
- en: 'Open `GameScene.swift` and add a new property to the `GameScene` class to create
    an instance of the `Ground` class. You can place this underneath the line that
    instantiates the world node (the new code is in bold):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameScene.swift`，并在`GameScene`类中添加一个新的属性以创建`Ground`类的实例。你可以将此放在实例化世界节点（新代码用粗体表示）的下面：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Locate the `didMoveToView` function. Add the following code at the bottom,
    underneath our bee spawning lines:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位`didMoveToView`函数。在蜜蜂孵化线下面添加以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the project. You will see the icy tundra appear underneath our bees. This
    small change goes a long way towards creating the feeling that our central bee
    is moving through space. Your simulator should look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你将看到冰原出现在我们的蜜蜂下方。这个小小的改动在很大程度上有助于营造我们的中心蜜蜂正在穿越空间的感受。你的模拟器应该看起来像这样：
- en: '![Running wire to the ground](img/Image_B04532_03_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![将电线接到地面上](img/Image_B04532_03_04.jpg)'
- en: A wild penguin appears!
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一只野企鹅出现了！
- en: 'There is one more class to build before we start our physics lesson: the `Player`
    class! It is time to replace our moving bee with a node designated as the player.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始物理课程之前，还需要构建一个类：`Player`类！是时候用指定的玩家节点替换移动的蜜蜂了。
- en: First, we will add the texture atlas for our penguin art. By now, you are familiar
    with adding files through the project navigator. Add the Pierre art as you did
    previously with the ground assets. I named Pierre's texture atlas `pierre.atlas`.
    You can find it in the asset pack, inside the `Pierre` folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加我们的企鹅艺术纹理图集。到现在为止，你应该熟悉通过项目导航器添加文件。像之前添加地面资产一样添加皮埃尔的美术。我将皮埃尔的纹理图集命名为
    `pierre.atlas`。你可以在资产包中找到它，在 `Pierre` 文件夹内。
- en: 'Once you add Pierre''s texture atlas to the project, you can create the `Player`
    class. Add a new Swift file to your project and name it `Player.swift`. Then add
    this code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将皮埃尔的纹理图集添加到项目中，你就可以创建 `Player` 类。在你的项目中添加一个新的 Swift 文件，并将其命名为 `Player.swift`。然后添加以下代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Great! Before we continue, we need to replace our original bee with an instance
    of the new `Player` class we just created. Follow these steps to replace the bee:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！在我们继续之前，我们需要用我们刚刚创建的新 `Player` 类的实例替换原始蜜蜂。按照以下步骤替换蜜蜂：
- en: 'In `GameScene.swift`, near the top, remove the line that creates a `bee` constant
    in the `GameScene` class. Instead, we want to instantiate an instance of `Player`.
    Add the new line: `let player = Player()`.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 文件中，靠近顶部，删除创建 `bee` 常量的行。相反，我们想要实例化一个 `Player` 实例。添加新行：`let
    player = Player()`.
- en: Completely delete the `addTheFlyingBee` function.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全删除 `addTheFlyingBee` 函数。
- en: In `didMoveToView`, remove the line that calls `addTheFlyingBee`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `didMoveToView` 方法中，删除调用 `addTheFlyingBee` 的行。
- en: 'In `didMoveToView`, at the bottom, add a new line to spawn the player:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `didMoveToView` 方法中，在底部添加一行以生成玩家：
- en: '[PRE7]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Further down, in `didSimulatePhysics`, replace the references to the bee with
    references to `player`. Recall that we created the `didSimulatePhysics` function
    in [Chapter 2](ch02.html "Chapter 2. Sprites, Camera, Actions!"), *Sprites, Camera,
    Actions!*, when we centered the camera on one node.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下方，在 `didSimulatePhysics` 方法中，将蜜蜂的引用替换为 `player` 的引用。回想一下，我们在 [第 2 章](ch02.html
    "第 2 章。精灵、相机、动作！") 中创建了 `didSimulatePhysics` 函数，当时我们在一个节点上居中相机。
- en: We have successfully transformed the original bee into a penguin. Before we
    move on, we will make sure your `GameScene` class includes all of the changes
    we have made so far in this chapter. After that, we will begin to explore the
    physics system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地将原始蜜蜂转换成了企鹅。在我们继续之前，请确保你的 `GameScene` 类包含了本章中我们迄今为止所做的所有更改。之后，我们将开始探索物理系统。
- en: Renovating the GameScene class
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复 GameScene 类
- en: 'We have made quite a few changes to our project. Luckily, this is the last
    major overhaul of the previous animation code. Moving forward, we will use the
    terrific structure we built in this chapter. At this point, your `GameScene.swift`
    file should look something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的项目做了一些更改。幸运的是，这是之前动画代码的最后一次重大修改。向前看，我们将使用本章中构建的出色结构。到现在为止，你的 `GameScene.swift`
    文件应该看起来像这样：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the project. You will see our new penguin hovering near the bees. Great
    work; we are now ready to explore the physics system with all of our new nodes.
    Your simulator should look something like this screenshot:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到我们的新企鹅在蜜蜂附近悬浮。干得好；我们现在准备好使用所有新节点来探索物理系统。你的模拟器应该看起来像这样的截图：
- en: '![Renovating the GameScene class](img/Image_B04532_03_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![修复 GameScene 类](img/Image_B04532_03_05.jpg)'
- en: Exploring the physics system
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索物理系统
- en: SpriteKit simulates physics with **physics bodies**. We attach physics bodies
    to all the nodes that need physics computations. We will set up a quick example
    before exploring all of the details.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 使用 **物理体** 来模拟物理。我们将物理体附加到所有需要物理计算的节点上。在探索所有细节之前，我们将设置一个快速示例。
- en: Dropping like flies
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如飞般坠落
- en: 'Our bees need to be part of the physics simulation, so we will add physics
    bodies to their nodes. Open your `Bee.swift` file and locate the `spawn` function.
    Add the following code at the bottom of the function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的蜜蜂需要成为物理模拟的一部分，因此我们将为它们的节点添加物理体。打开你的 `Bee.swift` 文件并定位到 `spawn` 函数。在函数底部添加以下代码：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is that easy to add a node to the physics simulation. Run the project. You
    will see our three `Bee` instances drop off the screen. They are now subject to
    gravity, which is on by default.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 向物理模拟中添加节点就这么简单。运行项目。你会看到我们的三个 `Bee` 实例从屏幕上掉落。它们现在受到重力的作用，默认情况下重力是开启的。
- en: Solidifying the ground
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 巩固地面
- en: 'We want the ground to catch falling game objects. We can give the ground its
    own physics body so the physics simulation can stop the bees from falling through
    it. Open your `Ground.swift` file, locate the `spawn` function, and then add this
    code at the bottom of the function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望地面能够捕捉下落的游戏对象。我们可以给地面自己的物理体，这样物理模拟就可以阻止蜜蜂穿过它。打开您的`Ground.swift`文件，找到`spawn`函数，然后在函数底部添加以下代码：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the project. The bees will now quickly drop and then stop once they collide
    with the ground. Notice how bees that fall farther bounce more energetically.
    After the bees land, your simulator will look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。现在蜜蜂会迅速下落，然后一旦与地面碰撞就会停止。注意下落得更远的蜜蜂弹跳得更有力。蜜蜂着陆后，您的模拟器将看起来像这样：
- en: '![Solidifying the ground](img/Image_B04532_03_06.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![加固地面](img/Image_B04532_03_06.jpg)'
- en: Checkpoint 3-A
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点3-A
- en: 'Great work so far. We have added a lot of structure to our game and started
    to explore the physics system. If you would like to download my project to this
    point, do so here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，工作做得很好。我们已经为我们的游戏添加了很多结构，并开始探索物理系统。如果您想下载到这一点的我的项目，请在此处操作：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-3](http://www.thinkingswiftly.com/game-development-with-swift/chapter-3)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-3](http://www.thinkingswiftly.com/game-development-with-swift/chapter-3)'
- en: Exploring physics simulation mechanics
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索物理模拟机制
- en: 'Let''s take a closer look at the specifics of SpriteKit''s physics system.
    For instance, why are the bees subject to gravity, but the ground stays where
    it is? Though we attached physics bodies to both nodes, we actually used two different
    styles of physics bodies. There are three types of physics bodies, and each behaves
    slightly differently:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看SpriteKit物理系统的具体细节。例如，为什么蜜蜂受到重力的作用，而地面却保持在原地？尽管我们为两个节点都附加了物理体，但实际上我们使用了两种不同的物理体样式。有三种类型的物理体，它们的行为略有不同：
- en: '**Dynamic** physics bodies have volume and are fully subject to forces and
    collisions in the system. We will use dynamic physics bodies for most parts of
    the game world: the player, enemies, power-ups, and others.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**物理体有体积，并且完全受系统中的力和碰撞的影响。我们将为游戏世界的绝大部分使用动态物理体：玩家、敌人、道具等。'
- en: '**Static** physics bodies have volume but no velocity. The physics simulation
    does not move nodes with static bodies but they can still collide with other game
    objects. We can use static bodies for walls or obstacles.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**物理体有体积但没有速度。物理模拟不会移动具有静态体的节点，但它们仍然可以与其他游戏对象发生碰撞。我们可以使用静态体来制作墙壁或障碍物。'
- en: '**Edge** physics bodies have no volume and the physics simulation will never
    move them. They mark off the boundaries of movement; other physics bodies will
    never cross them. Edges can cross each other to create small containment areas.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边缘**物理体没有体积，物理模拟永远不会移动它们。它们标记了运动边界；其他物理体永远不会越过它们。边缘可以交叉以创建小的封闭区域。'
- en: 'Voluminous (dynamic and static) bodies have a variety of properties that modify
    how they react to collisions and movement through space. This allows us to create
    a wide range of realistic physics effects. Each property controls one aspect of
    a body''s physical characteristics:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 体积（动态和静态）体具有各种属性，这些属性可以修改它们对碰撞和空间移动的反应。这使我们能够创建各种逼真的物理效果。每个属性控制一个物体的物理特性的一个方面：
- en: '**Restitution** determines how much energy is lost when one body bounces into
    another. This changes the body''s bounciness. SpriteKit measures restitution on
    a scale from 0.0 to 1.0\. The default value is 0.2.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复系数**决定了当一个物体弹入另一个物体时损失多少能量。这改变了物体的弹性。SpriteKit在0.0到1.0的范围内测量恢复系数。默认值是0.2。'
- en: '**Friction** describes the amount of force necessary to slide one body against
    another body. This property also uses a scale of 0.0 to 1.0, with a default value
    of 0.2.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**摩擦**描述了滑动一个物体相对于另一个物体所需的力。这个属性也使用0.0到1.0的刻度，默认值为0.2。'
- en: '**Damping** determines how quickly a body slows as it moves through space.
    You can think of damping as air friction. Linear damping determines how quickly
    a body loses speed, while angular damping affects rotation. Both measure from
    0.0 to 1.0, with a default value of 0.1.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼**决定了物体在空间中移动时减速的速度。你可以把阻尼想象成空气摩擦。线性阻尼决定了物体失去速度的速度，而角阻尼影响旋转。两者都从0.0到1.0测量，默认值为0.1。'
- en: '**Mass** is measured in kilograms. It describes how far colliding objects push
    the body and factors in momentum during movement. Bodies with more mass will move
    less when hit by another body and will push other bodies further when they collide
    with them. The physics engine automatically uses the mass and the area of the
    body to determine **density**. Alternatively, you can set the density and let
    the physics engine calculate mass. It is usually more intuitive to set the mass.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**是以千克为单位的。它描述了碰撞物体推动物体的距离，并在运动中考虑动量。质量更大的物体在受到另一个物体的撞击时移动较少，并且在它们相互碰撞时会将其他物体推得更远。物理引擎会自动使用物体的质量和面积来确定
    **密度**。或者，你可以设置密度，让物理引擎计算质量。通常设置质量更直观。'
- en: All right – enough with the textbook! Let us solidify our learning with some
    examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——教科书就到这里吧！让我们通过一些例子来巩固我们的学习。
- en: 'First, we want gravity to skip our bees. We will set their flight paths manually.
    We need the bees to be dynamic physics bodies in order to interact properly with
    other nodes, but we need these bodies to ignore gravity. For such instances, SpriteKit
    provides a property named `affectedByGravity`. Open `Bee.swift` and, at the bottom
    of the `spawn` function, add this code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望重力跳过我们的蜂。我们将手动设置它们的飞行路径。我们需要蜂成为动态物理体，以便与其他节点正确交互，但我们需要这些体忽略重力。对于这种情况，SpriteKit
    提供了一个名为 `affectedByGravity` 的属性。打开 `Bee.swift`，在 `spawn` 函数的底部添加以下代码：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The question mark after `physicsBody` is optional chaining. We need to unwrap
    `physicsBody`, since it is optional. If `physicsBody` is nil, the entire statement
    will return nil (instead of triggering an error). You can think of it as gracefully
    unwrapping an optional property with an inline statement.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`physicsBody` 后面的问号是可选链。我们需要解包 `physicsBody`，因为它是一个可选值。如果 `physicsBody` 为 nil，整个语句将返回
    nil（而不是触发错误）。你可以把它想象成用内联语句优雅地解包一个可选属性。'
- en: Run the project. The bees should now hover in place as they did before we added
    their bodies. However, SpriteKit's physics simulation now affects them; they will
    react to impulses and collisions. Great, let us purposefully collide the bees.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。蜂群现在应该像我们添加它们身体之前一样停留在原地。然而，SpriteKit 的物理模拟现在会影响它们；它们会对冲量和碰撞做出反应。太好了，让我们故意让蜂群相撞。
- en: Bee meets bee
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蜂遇蜂
- en: You may have noticed that we positioned `bee2` and `bee3` at the same height
    in the game world. We only need to push one of them horizontally to create a collision
    – perfect crash test dummies! We can use an **impulse** to create velocity for
    the outside bee.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在游戏世界中将 `bee2` 和 `bee3` 放在了相同的高度。我们只需要推动其中一个水平方向，以创建碰撞——完美的碰撞测试假人！我们可以使用
    **冲量** 为外部蜂创建速度。
- en: 'Locate the `didMoveToView` function in `GameScene.swift`. At the bottom, below
    all of our spawn code, add this line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GameScene.swift` 中找到 `didMoveToView` 函数。在所有生成代码的下方，添加这一行：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the project. You will see the outermost bee fly towards the middle and crash
    into the inner bee. This pushes the inner bee to the left and slows the first
    bee from the contact.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。你会看到最外层的蜂飞向中间并撞到内蜂。这会把内蜂推向左边，并减缓第一只蜂的接触速度。
- en: 'Attempt the same experiment with a variable: increased mass. Before the impulse
    line, add this code to adjust the mass of `bee2`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个变量：增加质量，尝试相同的实验。在冲量行之前，添加以下代码来调整 `bee2` 的质量：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the project. Hmm, our heavier bee does not move very far with the same
    impulse (it is a 200-gram bee, after all.) It eventually bumps into the inner
    bee, but it is not a very exciting collision. We will need to crank up the impulse
    to propel our beefier bee. Change the impulse line to use a `dx` value of `-15`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行项目。嗯，我们的重蜂在相同的冲量下移动不远（毕竟它是一只200克的蜂。）它最终撞到了内蜂，但碰撞并不令人兴奋。我们需要增加冲量来推动我们更重的蜂。将冲量行更改为使用
    `-15` 的 `dx` 值：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the project again. This time, our impulse provides enough energy to move
    the heavy bee in an interesting way. Notice how much energy the heavy bee transfers
    to the normal bee when they collide; the lighter bee shoots away after contact.
    Both bees possess enough momentum to eventually slide completely off the screen.
    Your simulator should look something like this screenshot, just before the bees
    slide off the screen:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行项目。这次，我们的冲量提供了足够的能量，使重蜂以有趣的方式移动。注意重蜂在碰撞时传递给普通蜂的能量；轻蜂在接触后飞走。两只蜂都有足够的动量，最终完全滑出屏幕。你的模拟器应该看起来像这张截图，就在蜂群滑出屏幕之前：
- en: '![Bee meets bee](img/Image_B04532_03_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![蜂遇蜂](img/Image_B04532_03_07.jpg)'
- en: Before you move on, you may wish to experiment with the various physics properties
    that I outlined earlier in the chapter. You can create many collision variations;
    the physics simulation offers a lot of depth with out much effort.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在您继续之前，您可能希望尝试我在本章前面概述的各种物理属性。您可以创建许多碰撞变体；物理模拟只需付出很少的努力就能提供很多深度。
- en: Impulse or force?
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冲量还是力？
- en: 'You have several options for moving nodes with physics bodies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您有几种选项可以使用物理体移动节点：
- en: 'An impulse is an immediate, one-time change to a physics body''s velocity.
    In our test, an impulse gave the bee its velocity, and it slowly bled speed to
    damping and its collision. Impulses are perfect for projectiles: missiles, bullets,
    disgruntled birds, and so on.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冲量是对物理体速度的即时、一次性改变。在我们的测试中，冲量给了蜜蜂速度，并且它慢慢因为阻尼和碰撞而减速。冲量非常适合投射物：导弹、子弹、不高兴的鸟等等。
- en: A force applies velocity for only one physics calculation cycle. When we use
    a force, we typically apply it before every frame. Forces are useful for rocket
    ships, cars, or anything else that is continually self-propelled.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力只在一个物理计算周期内作用于速度。当我们使用力时，我们通常在每一帧之前应用它。力对于火箭船、汽车或其他持续自我推进的任何东西都很有用。
- en: You can also edit the `velocity` and `angularVelocity` properties of a body
    directly. This is useful for setting a manual velocity limit.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以直接编辑物体的`velocity`和`angularVelocity`属性。这对于设置手动速度限制很有用。
- en: Checkpoint 3-B
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点 3-B
- en: 'We have made a number of structural changes to our project in this chapter.
    Feel free to download my project to this point:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对我们的项目进行了多项结构性的更改。您可以随意下载我到目前为止的项目：
- en: '[http://www.thinkingswiftly.com/game-development-with-swift/chapter-3](http://www.thinkingswiftly.com/game-development-with-swift/chapter-3)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[Swift 游戏开发](http://www.thinkingswiftly.com/game-development-with-swift/chapter-3)'
- en: Summary
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have made great strides in this chapter. Our new class organization will
    serve us well over the course of this book. We learned how to use protocols to
    enforce commonality across classes, encapsulated our game objects into distinct
    classes, and explored tiling textures over the width of the ground node. Finally,
    we cleaned out some of our previous learning code from `GameScene` and used the
    new class system to spawn all of our game objects.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们取得了巨大的进步。我们新的类组织将在整本书的进程中为我们提供良好的服务。我们学习了如何使用协议在类之间强制一致性，将游戏对象封装到不同的类中，并探讨了在地面节点宽度上的平铺纹理。最后，我们从`GameScene`中清理了一些之前的学习代码，并使用新的类系统生成所有游戏对象。
- en: We also applied the physics simulation to our game. We have only scratched the
    surface of the powerful physics system in SpriteKit – we will dive deeper into
    custom collision events in [Chapter 7](ch07.html "Chapter 7. Implementing Collision
    Events"), *Implementing Collision Events* – but we have already gained quite a
    bit of functionality. We explored the three types of physics bodies and studied
    the various physics properties you can use to fine-tune the physical behavior
    of your game objects. Then, we put all of our hard work into practice by bumping
    our bees together and watching the results.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将物理模拟应用于我们的游戏。我们在 SpriteKit 中强大的物理系统中只是触及了表面——我们将在第 7 章[实现碰撞事件](ch07.html
    "第 7 章。实现碰撞事件")中深入探讨自定义碰撞事件——但我们已经获得了相当多的功能。我们探索了三种类型的物理体，并研究了您可以使用来微调游戏对象物理行为的各种物理属性。然后，我们通过让蜜蜂相互碰撞并观察结果来将所有辛勤工作付诸实践。
- en: Next, we will try several control schemes and move our player around the game
    world. This is an exciting addition; our project will begin to feel like a true
    game in [Chapter 4](ch04.html "Chapter 4. Adding Controls"), *Adding Controls*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试几种控制方案，并将玩家移动到游戏世界中。这是一个令人兴奋的补充；我们的项目将开始感觉像一款真正的游戏。[添加控制](ch04.html
    "第 4 章。添加控制")。
