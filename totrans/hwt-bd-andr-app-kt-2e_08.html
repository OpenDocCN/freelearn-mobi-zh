<html><head></head><body>
		<div id="_idContainer160">
			<h1 id="_idParaDest-132" class="chapter number"><a id="_idTextAnchor467"/><a id="_idTextAnchor468"/><a id="_idTextAnchor469"/><a id="_idTextAnchor470"/><a id="_idTextAnchor471"/>8</h1>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor472"/>Services, WorkManager, and Notifications</h1>
			<p><a id="_idTextAnchor473"/>This chapter will introduce you to the concepts of managing long-running tasks in the background of an app. By the end of this chapter, you will be able to trigger a background task, create a notification for the user when a background task is complete, and launch an application from a notification. This chapter will give you a solid understanding of how to manage background tasks and keep the user informed about the progress of <span class="No-Break">these tasks.</span></p>
			<p><a id="_idTextAnchor474"/>In the previous chapter, we learned how to request permissions from the user and use Google’s Maps API. With that knowledge, we obtained the user’s location and allowed them to deploy an agent on a local map. In this chapter, we will learn how to track a long-running process and report its progress to <span class="No-Break">the user.</span></p>
			<p>We will build an example app where we will assume that <strong class="bold">Secret Cat Agents</strong> (<strong class="bold">SCAs</strong>) get deployed in a record time of 15 seconds. When a <a id="_idIndexMarker675"/>cat successfully deploys, we will notify the user and let them launch the app, presenting them with a successful <span class="No-Break">deployment message.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">We will go with 15 seconds because that way, we will avoid having to wait for very long before our background <span class="No-Break">task completes.</span></p>
			<p>Ongoing background tasks are quite common in the mobile world. Background tasks run even when an application is not active. Examples of long-running background tasks include the downloading of files, resource clean-up jobs, playing music, and tracking the <span class="No-Break">user’s location.</span></p>
			<p>Historically, Google offered Android developers multiple ways of executing such tasks: <strong class="source inline">Services</strong>, <strong class="source inline">JobScheduler</strong>, and Firebase’s <strong class="source inline">JobDispatcher</strong> and <strong class="source inline">AlarmManager</strong>. With the fragmentation that existed in the Android world, it was quite a mess to cope with. Luckily for us, since March 2019, we have had a better (more <span class="No-Break">stable) option.</span></p>
			<p>With the introduction of <strong class="source inline">WorkManager</strong>, Google has abstracted the logic of choosing a background executing mechanism based on the API version away for us. We still use a foreground service, which is a special kind of service, for certain tasks that should be known to the user while running, such as playing music or tracking the user’s location in a <span class="No-Break">running app.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout"><strong class="bold">Services</strong> are<a id="_idIndexMarker676"/> application components designed to run in the background, even when an app is not running. Except for foreground services, which are tied to a notification, services have no <span class="No-Break">user interface.</span></p>
			<p>Before we proceed, take a quick step back. We have mentioned services, and we will be focusing on foreground services, but we haven’t quite explained what services are. Services are application components designed to run in the background, even when an app is <span class="No-Break">not running.</span></p>
			<p>Services have no user interface, with foreground services being the exception. It is important to note that services run on the main thread of their hosting process. This means that their operations can block the app. It is up to us to start a separate thread from within a service to <span class="No-Break">avoid that.</span></p>
			<p>Let’s get started and look at the implementation of the multiple approaches available in Android for managing a <span class="No-Break">background task.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Starting a background task <span class="No-Break">using </span><span class="No-Break"><strong class="source inline">WorkManager</strong></span></li>
				<li>Background operations noticeable to the user – using a <span class="No-Break">Foreground Servic<a id="_idTextAnchor475"/><a id="_idTextAnchor476"/>e</span></li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor477"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub <span class="No-Break">at </span><a href="https://packt.link/i8IRQ"><span class="No-Break">https://packt.link/i8IRQ</span></a></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor478"/>Starting a background task using WorkManager</h1>
			<p>The first<a id="_idIndexMarker677"/> question we will address here is should<a id="_idIndexMarker678"/> we opt for <strong class="source inline">WorkManager</strong> or a foreground service? To answer that, a good rule of thumb is to ask whether you need the action to be tracked by the user in <span class="No-Break">real time.</span></p>
			<p>If <a id="_idIndexMarker679"/>the answer is yes (for example, if you have a task such<a id="_idIndexMarker680"/> as responding to the user’s location or playing music in the background), then you should use a foreground service with its attached notification to give the user a real-time indication of state. When the background task can be delayed or does not require user interaction (for example, downloading a large file), <span class="No-Break">use </span><span class="No-Break"><strong class="source inline">WorkManager</strong></span><span class="No-Break">.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">Starting with version <strong class="source inline">2.3.0-alpha02</strong> of <strong class="source inline">WorkManager</strong>, you can launch a foreground service via the <strong class="source inline">WorkManager</strong> singleton by calling <strong class="source inline">setForegroundAsync(ForegroundInfo)</strong>. Our control over that foreground service is quite limited. It does allow you to attach a (predefined) notification to the work, which is why it is <span class="No-Break">worth mentioning.</span></p>
			<p>In our example app, we will track the SCAs’ preparation for deployment. Before an agent can head out, they need to stretch, groom their fur, visit the litter box, and suit up. Each one of these tasks takes some time. Because you can’t rush a cat, the agent will finish each step in its own time. All we can do is wait (and let the user know when the task is done). <strong class="source inline">WorkManager</strong> is perfect for such <span class="No-Break">a scenario.</span></p>
			<p>To use <strong class="source inline">WorkManager</strong>, we need to familiarize ourselves with its four <span class="No-Break">main classes:</span></p>
			<ul>
				<li><strong class="source inline">WorkManager</strong>: This receives work and enqueues it based on provided arguments and constraints (such as internet connectivity and the <span class="No-Break">device charging).</span></li>
				<li><strong class="source inline">Worker</strong>: This is a wrapper around the work that needs doing. It has one function, <strong class="source inline">doWork()</strong>, which we override to implement the background work code. The <strong class="source inline">doWork()</strong> function will be executed in a <span class="No-Break">background thread.</span></li>
				<li><strong class="source inline">WorkRequest</strong>: This class binds a <strong class="source inline">Worker</strong> class to arguments and constraints. There are two types of <strong class="source inline">WorkRequest</strong>: <strong class="source inline">OneTimeWorkRequest</strong>, which runs the work once, and <strong class="source inline">PeriodicWorkRequest</strong>, which can be used to schedule work to run at a <span class="No-Break">fixed interval.</span></li>
				<li><strong class="source inline">ListenableWorker.Result</strong>: You probably guessed it, but this is the class holding the result of the executed work. The result can be one of <strong class="source inline">Success</strong>, <strong class="source inline">Failure</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source inline">Retry</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Other than these four classes, we also have the <strong class="source inline">Data</strong> class, which holds data passed to and from <span class="No-Break">the worker.</span></p>
			<p>Let’s get back to our example. We want to define four tasks that need to occur in sequential order: the cat needs to stretch, then it needs to groom its fur, then visit the litter box, and, finally, it needs to <span class="No-Break">suit up.</span></p>
			<p>Before we can start using <strong class="source inline">WorkManager</strong>, we have to first include its dependency in our app <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
implementation "androidx.work:work-runtime:2.8.0"</pre>
			<p>With <strong class="source inline">WorkManager</strong> included in our project, we’ll go ahead and create our workers. The <a id="_idIndexMarker681"/>first worker <a id="_idIndexMarker682"/>will look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
class CatStretchingWorker(
  context: Context, workerParameters: WorkerParameters
) : Worker(context, workerParameters) {
  override fun doWork(): Result {
    val catAgentId =
      inputData.getString(INPUT_DATA_CAT_AGENT_ID)
    Thread.sleep(3000L)
    val outputData = Data.Builder()
      .putString(OUTPUT_DATA_CAT_AGENT_ID, catAgentId)
      .build()
      return Result.success(outputData)
  }
  companion object {
    const val INPUT_DATA_CAT_AGENT_ID = "id"
    const val OUTPUT_DATA_CAT_AGENT_ID = "id"
  }
}</pre>
			<p>We<a id="_idIndexMarker683"/> start by extending <strong class="source inline">Worker</strong> and overriding<a id="_idIndexMarker684"/> its <strong class="source inline">doWork()</strong> function. We then read the SCA ID from the input data. Then, because we have no real sensors to track the progress of the cat stretching, we fake our wait by introducing a 3-second (3,000 milliseconds) <strong class="source inline">Thread.sleep(Long)</strong> call. Finally, we construct an output <strong class="source inline">data</strong> class with the ID we received in our input and return it with the <span class="No-Break">successful result.</span></p>
			<p>Once we’ve created workers for all our tasks (<strong class="source inline">CatStretchingWorker</strong>, <strong class="source inline">CatFurGroomingWorker</strong>, <strong class="source inline">CatLitterBoxSittingWorker</strong>, and <strong class="source inline">CatSuitUpWorker</strong>), similarly to how we created the first one, we can call <strong class="source inline">WorkManager</strong> to chain them. Let’s also assume we can’t tell the progress of the agent unless we’re connected to the internet. Our call would look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
val catStretchingInputData = Data.Builder()
  .putString(CatStretchingWorker.INPUT_DATA_CAT_AGENT_ID,
  "catAgentId").build()
val catStretchingRequest = OneTimeWorkRequest
  .Builder(CatStretchingWorker::class.java)
val catStretchingRequest = OneTimeWorkRequest.Builder(
  CatStretchingWorker::class.java)
    .setConstraints(networkConstraints)
    .setInputData(catStretchingInputData)
    .build()
...
WorkManager.getInstance(this)
  .beginWith(catStretchingRequest)
  .then(catFurGroomingRequest)
  .then(catLitterBoxSittingRequest)
  .then(catSuitUpRequest)
  .enqueue()</pre>
			<p>In the<a id="_idIndexMarker685"/> preceding code, we first construct <a id="_idIndexMarker686"/>a <strong class="source inline">Constraints</strong> instance declaring we need to be connected to the internet for the work to execute. We then define our input data, setting it to the SCA ID. Next, we bind the constraints and input data to our <strong class="source inline">Worker</strong> class by <span class="No-Break">constructing </span><span class="No-Break"><strong class="source inline">OneTimeWorkRequest</strong></span><span class="No-Break">.</span></p>
			<p>The construction of the other <strong class="source inline">WorkRequest</strong> instances has been left out, but they are almost identical to the one shown here. We can now chain all the requests and enqueue them in the <strong class="source inline">WorkManager</strong> class. You can enqueue a single <strong class="source inline">WorkRequest</strong> instance by passing it directly to the <strong class="source inline">WorkManager</strong> <strong class="source inline">enqueue()</strong> function, or you can have multiple <strong class="source inline">WorkRequest</strong> instances run in parallel by passing them all to the <strong class="source inline">WorkManager</strong> <strong class="source inline">enqueue()</strong> function as <span class="No-Break">a list.</span></p>
			<p>Our tasks will be executed by <strong class="source inline">WorkManager</strong> when the constraints <span class="No-Break">are met.</span></p>
			<p>Each <strong class="source inline">Request</strong> instance has a unique identifier. <strong class="source inline">WorkManager</strong> exposes a <strong class="source inline">LiveData</strong> property for each request, allowing us to track the progress of its work by passing its unique identifier, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
workManager.getWorkInfoByIdLiveData(
  catStretchingRequest.id
).observe(this) { info -&gt;
  if (info.state.isFinished) { doSomething() }
}</pre>
			<p>The state of work can be <strong class="source inline">BLOCKED</strong> (there is a chain of requests, and this one is not next in the chain), <strong class="source inline">ENQUEUED</strong> (there is a chain of requests, and this work is next), <strong class="source inline">RUNNING</strong> (the work in <strong class="source inline">doWork()</strong> is executing), and <strong class="source inline">SUCCEEDED</strong>. Work can also be canceled, leading to a <strong class="source inline">CANCELLED</strong> state, or it can fail, leading to a <span class="No-Break"><strong class="source inline">FAILED</strong></span><span class="No-Break"> state.</span></p>
			<p>Finally, there’s <strong class="source inline">Result.retry</strong>. Returning this result tells the <strong class="source inline">WorkManager</strong> class to enqueue the work again. The policy governing when to run the work again is defined by a <strong class="source inline">backoff</strong> criteria set on <strong class="source inline">WorkRequest</strong> <strong class="source inline">Builder</strong>. The default <strong class="source inline">backoff</strong> policy is exponential, but we can set it to be linear instead. We can also define the initial <span class="No-Break"><strong class="source inline">backoff</strong></span><span class="No-Break"> time.</span></p>
			<p>Let’s put<a id="_idIndexMarker687"/> the knowledge gained so far into practice<a id="_idIndexMarker688"/> in the following exercise. In this section, we will track our SCA from the moment we fire off the command to deploy it to the field to the moment it arrives at <span class="No-Break">its<a id="_idTextAnchor479"/><a id="_idTextAnchor480"/> destination.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor481"/>Exercise 8.01 – executing background work with the WorkManager class</h2>
			<p>In this first exercise, we <a id="_idIndexMarker689"/>will track the SCA as it<a id="_idIndexMarker690"/> prepares to head out by enqueuing the chained <span class="No-Break"><strong class="source inline">WorkRequest</strong></span><span class="No-Break"> classes:</span></p>
			<ol>
				<li>Start by creating a new <strong class="source inline">Empty Activity</strong> project (<strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Project</strong> | <strong class="bold">Empty Activity</strong>). <span class="No-Break">Click </span><span class="No-Break"><strong class="bold">Next</strong></span><span class="No-Break">.</span></li>
				<li>Name your application <strong class="source inline">Cat </strong><span class="No-Break"><strong class="source inline">Agent Tracker</strong></span><span class="No-Break">.</span></li>
				<li>Make sure your package name <span class="No-Break">is </span><span class="No-Break"><strong class="source inline">com.example.catagenttracker</strong></span><span class="No-Break">.</span></li>
				<li>Set the save location to where you want to save <span class="No-Break">your project.</span></li>
				<li>Leave everything else at its default values and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></li>
				<li>Make sure you are on the Android view in your <span class="No-Break"><strong class="bold">Project</strong></span><span class="No-Break"> pane.</span></li>
				<li>Open your app’s <strong class="source inline">build.gradle</strong> file. In the <strong class="source inline">dependencies</strong> block, add the <span class="No-Break"><strong class="source inline">WorkManager</strong></span><span class="No-Break"> dependency:</span><pre class="source code">
dependencies {
    ...
    <strong class="bold">implementation "androidx.work:work-runtime:2.8.0"</strong>
    ...
}</pre></li>
			</ol>
			<p>This will allow you to use <strong class="source inline">WorkManager</strong> and its dependencies in <span class="No-Break">your code.</span></p>
			<ol>
				<li value="8">Create a new package under your app package (right-click on <strong class="source inline">com.example.catagenttracker</strong>, then <strong class="bold">New</strong> | <strong class="bold">Package</strong>). Name the new <span class="No-Break">package </span><span class="No-Break"><strong class="source inline">com.example.catagenttracker.worker</strong></span><span class="No-Break">.</span></li>
				<li>Create a new class under <strong class="source inline">com.example.catagenttracker.worker</strong> named <strong class="source inline">CatStretchingWorker</strong> (right-click on <strong class="source inline">worker</strong>, then <strong class="bold">New</strong> | <strong class="bold">New</strong> <strong class="bold">Kotlin File/Class</strong>). Under <strong class="bold">Kind</strong>, <span class="No-Break">choose </span><span class="No-Break"><strong class="bold">Class</strong></span><span class="No-Break">.</span></li>
				<li>To <a id="_idIndexMarker691"/>define a <strong class="source inline">Worker</strong> instance<a id="_idIndexMarker692"/> that will sleep for <strong class="source inline">3</strong> seconds, update the new class <span class="No-Break">like so:</span><pre class="source code">
package com.example.catagenttracker.worker
[imports]
class CatStretchingWorker(
  context: Context, workerParameters: WorkerParameters
) : Worker(context, workerParameters) {
  override fun doWork(): Result {
    val catAgentId =
      inputData.getString(INPUT_DATA_CAT_AGENT_ID)
    Thread.sleep(3000L)
    val outputData = Data.Builder()
      .putString(OUTPUT_DATA_CAT_AGENT_ID, catAgentId)
      .build()
    return Result.success(outputData)
  }
  companion object {
    const val INPUT_DATA_CAT_AGENT_ID = "inId"
    const val OUTPUT_DATA_CAT_AGENT_ID = "outId"
  }
}</pre></li>
			</ol>
			<p>This will add the required dependencies for a <strong class="source inline">Worker</strong> implementation and then extend the <strong class="source inline">Worker</strong> class. To implement the actual work, you will override <strong class="source inline">doWork(): Result</strong>, making it read the Cat Agent ID from the input, sleep for <strong class="source inline">3</strong> seconds (<strong class="source inline">3,000</strong> milliseconds), construct an output data instance with the Cat Agent ID, and pass it via a <span class="No-Break"><strong class="source inline">Result.success</strong></span><span class="No-Break"> value.</span></p>
			<ol>
				<li value="11">Repeat <em class="italic">steps 9</em> and <em class="italic">10</em> to create three more identical workers named <strong class="source inline">CatFurGroomingWorker</strong>, <strong class="source inline">CatLitterBoxSittingWorker</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source inline">CatSuitUpWorker</strong></span><span class="No-Break">.</span></li>
				<li>Open <strong class="source inline">MainActivity</strong>. Right<a id="_idIndexMarker693"/> before<a id="_idIndexMarker694"/> the end of the class, add <span class="No-Break">the following:</span><pre class="source code">
private fun getCatAgentIdInputData(
  catAgentIdKey: String, catAgentIdValue: String) =
  Data.Builder()
    .putString(catAgentIdKey, catAgentIdValue).build()</pre></li>
			</ol>
			<p>This helper function constructs an input <strong class="source inline">Data</strong> instance for you with the Cat <span class="No-Break">Agent ID.</span></p>
			<ol>
				<li value="13">Add the following to the <span class="No-Break"><strong class="source inline">onCreate(Bundle?)</strong></span><span class="No-Break"> function:</span><pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
  super.onCreate(savedInstanceState)
  setContentView(R.layout.activity_main)
  <strong class="bold">val networkConstraints = Constraints.Builder()</strong>
<strong class="bold">    .setRequiredNetworkType(NetworkType.CONNECTED)</strong>
<strong class="bold">    .build()</strong>
  <strong class="bold">val catAgentId = "CatAgent1"</strong>
  <strong class="bold">val catStretchingRequest = OneTimeWorkRequest.</strong>
    <strong class="bold">Builder(CatLitterBoxSittingWorker::class.java)</strong>
    <strong class="bold">.setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(</strong>
      <strong class="bold">getCatAgentIdInputData(CatStretchingWorker</strong>
<strong class="bold">        .INPUT_DATA_CAT_AGENT_ID, catAgentId)</strong>
      <strong class="bold">).build()</strong>
  <strong class="bold">val catFurGroomingRequest = OneTimeWorkRequest.</strong>
    <strong class="bold">Builder(CatFurGroomingWorker::class.java)</strong>
    <strong class="bold">.setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(getCatAgentIdInputData(</strong>
<strong class="bold">      CatFurGroomingWorker.INPUT_DATA_CAT_AGENT_ID,</strong>
<strong class="bold">        catAgentId)</strong>
    <strong class="bold">).build()</strong>
  <strong class="bold">val catLitter<a id="_idTextAnchor482"/>BoxSittingRequest = OneTimeWorkRequest.</strong>
    <strong class="bold">Builder(CatLitterBoxSittingWorker::class.java)</strong>
    <strong class="bold">.setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(getCatAgentIdInputData(</strong>
<strong class="bold">CatLitterBoxSittingWorker.INPUT_DATA_CAT_AGENT_ID,</strong>
      <strong class="bold">catAgentId)</strong>
    <strong class="bold">).build()</strong>
  <strong class="bold">val catSuitUpRequest = OneTimeWorkRequest.Builder(</strong>
<strong class="bold">    CatSuitUpWorker::class.java</strong>
<strong class="bold">  ).setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(getCatAgentIdInputData(CatSuitUpWorker.</strong>
      <strong class="bold">INPUT_DATA_CAT_AGENT_ID, catAgentId)</strong>
    <strong class="bold">).build()</strong>
}</pre></li>
			</ol>
			<p>The first<a id="_idIndexMarker695"/> line added defines<a id="_idIndexMarker696"/> a network constraint. It tells the <strong class="source inline">WorkManager</strong> class to wait for an internet connection before executing work. Then, you define your Cat Agent ID. Finally, you define four requests, passing in your <strong class="source inline">Worker</strong> classes, the network constraints, and the Cat Agent ID in the form of <span class="No-Break">input data.</span></p>
			<ol>
				<li value="14">At the top of the class, define <span class="No-Break">your </span><span class="No-Break"><strong class="source inline">WorkManager</strong></span><span class="No-Break">:</span><pre class="source code">
private val workManager = WorkManager.getInstance(this)</pre></li>
				<li>Add a chained <strong class="source inline">enqueue</strong> request right below the code you just added, still within the <span class="No-Break"><strong class="source inline">onCreate</strong></span><span class="No-Break"> function:</span><pre class="source code">
val catSuitUpRequest = ...
<strong class="bold">workManager.beginWith(catStretchingRequest)</strong>
    <strong class="bold">.then(catFurGroomingRequest)</strong>
    <strong class="bold">.then(catLitterBoxSittingRequest)</strong>
    <strong class="bold">.then(catSuitUpRequest)</strong>
    <strong class="bold">.enqueue()</strong></pre></li>
			</ol>
			<p>Your <strong class="source inline">WorkRequests</strong> are now enqueued to be executed in sequence when their constraints are met and the <strong class="source inline">WorkManager</strong> class is ready to <span class="No-Break">execute them.</span></p>
			<ol>
				<li value="16">Define a function to show a toast with a provided message. It should look <span class="No-Break">like this:</span><pre class="source code">
private fun showResult(message: String) {
    Toast.makeText(this, message, LENGTH_SHORT).show()
}</pre></li>
				<li>To track<a id="_idIndexMarker697"/> the progress of <a id="_idIndexMarker698"/>the enqueued <strong class="source inline">WorkRequest</strong> instances, add the following after the <span class="No-Break"><strong class="source inline">enqueue</strong></span><span class="No-Break"> call:</span><pre class="source code">
workManager.beginWith(catStretchingRequest)
    ...
    .enqueue()
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    catStretchingRequest.id).observe(this) { info -&gt;</strong>
<strong class="bold">        if (info.state.isFinished) {</strong>
    <strong class="bold">        showResult("Agent done stretching")</strong>
  <strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    catFurGroomingRequest.id).observe(this) { info -&gt;</strong>
  <strong class="bold">      if (info.state.isFinished) {</strong>
    <strong class="bold">        showResult("Agent done grooming its fur")</strong>
  <strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    </strong><strong class="bold">catLitterBoxSittingRequest.id).observe(this) { info -&gt;</strong>
        <strong class="bold">if (info.state.isFinished) {</strong>
            <strong class="bold">showResult("Agent done sitting in litter box")</strong>
        <strong class="bold">}</strong>
    <strong class="bold">}</strong>
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    catSuitUpRequest.id).observe(this) { info -&gt;</strong>
<strong class="bold">         if (info.state.isFinished) {</strong>
<strong class="bold">    </strong>  <strong class="bold">    </strong>  <strong class="bold"> </strong><strong class="bold">showResult("Agent done suiting up. Ready to go!")</strong>
<strong class="bold">         }</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>The preceding<a id="_idIndexMarker699"/> code observes<a id="_idIndexMarker700"/> a <strong class="source inline">WorkInfo</strong> observable provided by the <strong class="source inline">WorkManager</strong> class for each <strong class="source inline">WorkRequest</strong>. When each request is finished, a toast is shown with a <span class="No-Break">relevan<a id="_idTextAnchor483"/>t message.</span></p>
			<ol>
				<li value="18">Run <span class="No-Break">your app:</span></li>
			</ol>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B19411_08_01.jpg" alt="Figure 8.1 – Toasts showing in order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Toasts showing in order</p>
			<p>You should <a id="_idIndexMarker701"/>now see a simple <strong class="source inline">Hello World!</strong> screen. However, if you wait a few seconds, you will start seeing toasts<a id="_idIndexMarker702"/> informing you of the progress of your SCA preparing to deploy to the field. You will notice that the toasts follow the order in which you enqueued the requests and execute <a id="_idTextAnchor484"/><a id="_idTextAnchor485"/>their <span class="No-Break">delays sequentially.</span></p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor486"/>Background operations noticeable to the user – using a Foreground Service</h1>
			<p>With our SCA all suited up, they<a id="_idIndexMarker703"/> are now ready to get to the assigned destination. To track the SCA, we will periodically poll the location of the SCA using a Foreground Service and update the sticky notification (a notification that cannot be dismissed by the user) attached to that service with the <span class="No-Break">new location.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">For the sake of simplicity, we will fake the location. Following what you learned in <a href="B19411_07.xhtml#_idTextAnchor421"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Android Permissions and Google Maps</em>, you could later replace this implementation with a real one that uses <span class="No-Break">a map.</span></p>
			<p>Foreground services are another way of performing background operations. The name may be a bit counterintuitive. It is meant to differentiate these services from the base Android (background) services. The former are tied to a notification, while the latter run in the background with no user-facing representation <span class="No-Break">built in.</span></p>
			<p>Another important difference between foreground services and background services is that the latter are candidates for termination when the system is low on memory, while the former <span class="No-Break">are not.</span></p>
			<p>As of Android 9 (Pie, or API level 28), we have to request the <strong class="source inline">FOREGROUND_SERVICE</strong> permission to use foreground services. Since it is a normal permission, it will be granted to our <span class="No-Break">app automatically.</span></p>
			<p>Before we can launch a foreground service, we must first create one. A foreground service is a subclass of the Android abstract <strong class="source inline">Service</strong> class. If we do not intend to bind to the service, and in our example, we do not, we can simply override <strong class="source inline">onBind(Intent)</strong> so that it <span class="No-Break">returns </span><span class="No-Break"><strong class="source inline">null</strong></span><span class="No-Break">.</span></p>
			<p>As a side note, binding is one of the ways for interested clients to communicate with a service. We will not focus on this approach in this book, as there are other, easier approaches, as you <span class="No-Break">will discover.</span></p>
			<p>A Foreground Service must be tied to a notification. On Android 8 (Oreo, or API level 26) and above, if a Foreground Service is not tied to one within the <strong class="bold">Application Not Responding</strong> (<strong class="bold">ANR</strong>) time <a id="_idIndexMarker704"/>window (around five seconds), the service is stopped, and the app is declared as <span class="No-Break">not responding.</span></p>
			<p>Because of<a id="_idIndexMarker705"/> this requirement, it is best if we tie the service to a notification as soon as we can. The best place to do that would be in the <strong class="source inline">onCreate()</strong> function of the service. A quick implementation would look something <span class="No-Break">like this:</span></p>
			<pre class="source code">
private fun onCreate() {
  val channelId = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    val newChannelId = "ChannelId"
    val channelName = "My Background Service"
    val channel = NotificationChannel(newChannelId,
      channelName, NotificationManager.IMPORTANCE_DEFAULT)
    val service = getSystemService(
      Context.NOTIFICATION_SERVICE) as NotificationManager
    service.createNotificationChannel(channel)
    newChannelId
  } else { "" }
    val flag = if (Build.VERSION.SDK_INT &gt;=
      Build.VERSION_CODES.S) FLAG_IMMUTABLE else 0
  val pendingIntent = Intent(this,
    MainActivity::class.java).let { notificationIntent -&gt;
      PendingIntent.getActivity(this, 0,
        notificationIntent, flag)
    }
  val notification =
    NotificationCompat.Builder(this, channelId)
      .setContentTitle("Content title")
      .setContentText("Content text")
      .setSmallIcon(R.drawable.notification_icon)
      .setContentIntent(pendingIntent)
      .setTicker("Ticker message").build()
  startForeground(NOTIFICATION_ID, notificationBuilder.build())
}</pre>
			<p>Let’s break <span class="No-Break">this down.</span></p>
			<p>We start by <a id="_idIndexMarker706"/>defining the channel ID. This is only required for Android Oreo or above and is ignored in earlier versions of Android. In Android Oreo, Google introduced the concept of channels. Channels are used to group notifications and allow users to filter out <span class="No-Break">unwanted notifications.</span></p>
			<p>Next, we define <strong class="source inline">pendingIntent</strong>. This will be the <strong class="source inline">Intent</strong> launched if the user taps on the notification. In this example, the main activity would be launched. It is constructed by wrapping an <strong class="source inline">Intent</strong> activity launching in a <strong class="source inline">PendingIntent</strong>. The request code is set to <strong class="source inline">0</strong> because this example doesn’t expect a result, so the code will not <span class="No-Break">be used.</span></p>
			<p>The flag is set to <strong class="source inline">0</strong> for APIs older than S (31). Otherwise, it is set to the recommended <strong class="source inline">PendingIntent.FLAG_IMMUTABLE</strong>, which means that additional arguments passed to the <strong class="source inline">Intent</strong> on send will <span class="No-Break">be ignored.</span></p>
			<p>With the channel ID and <strong class="source inline">pendingIntent</strong>, we can construct our notification. We use <strong class="source inline">NotificationCompat</strong>, which takes away some of the boilerplate around supporting older API levels. We pass in the context and the channel ID. We define the title, text, small icon, <strong class="source inline">Intent</strong>, and ticker message and build the notification to complete <span class="No-Break">the builder:</span></p>
			<pre class="source code">
val notification =
  NotificationCompat.Builder(this, channelId)
    .setContentTitle("Content title")
    .setContentText("Content text")
    .setSmallIcon(R.drawable.notification_icon)
    .setContentIntent(pendingIntent)
    .setTicker("Ticker message")
    .build()</pre>
			<p>To start a<a id="_idIndexMarker707"/> service in the foreground, attaching the notification to it, we call it the <strong class="source inline">startForeground(Int, Notification)</strong> function, passing in a notification ID (any unique <strong class="source inline">int</strong> value to identify this service, which must not be 0) and a notification, which must have its priority set to <strong class="source inline">PRIORITY_LOW</strong> or higher. In our case, we have not specified the priority, which sets it <span class="No-Break">to </span><span class="No-Break"><strong class="source inline">PRIORITY_DEFAULT</strong></span><span class="No-Break">:</span></p>
			<p>If launched, our service will now show a sticky notification. Clicking on the notification would launch our <span class="No-Break">main activity.</span></p>
			<p>Currently, our service doesn’t perform any operations aside from showing a notification. To add some functionality to it, we need to override <strong class="source inline">onStartCommand(Intent?, Int, Int)</strong>. This function gets called when the service is launched via <span class="No-Break">an Intent.</span></p>
			<p>This also gives us the opportunity to read any extra data passed via that Intent. It also provides us with flags (which may be set to <strong class="source inline">START_FLAG_REDELIVERY</strong> or <strong class="source inline">START_FLAG_RETRY</strong>) and a unique request ID. We will get to reading the extra data later in this chapter. You don’t need to worry about the flags or the request ID in a <span class="No-Break">simple implementation.</span></p>
			<p>It is important to note that <strong class="source inline">onStartCommand(Intent?, Int, Int)</strong> gets called on the UI thread, so don’t perform any long-running operations here, or your app will freeze, giving the user a poor experience. Instead, we could create a new handler using a new <strong class="source inline">HandlerThread</strong> (a thread with a looper, a class used to run a message loop for a thread) and post our work <span class="No-Break">to it.</span></p>
			<p>This means we’ll have an infinite loop running, waiting for us to post to it via a <strong class="source inline">Handler</strong>. When we receive a <strong class="source inline">start</strong> command, we can post the work we want to be done to it. That work will then be executed on <span class="No-Break">that thread.</span></p>
			<p>When our long-running work is done, there are a few things we may want to happen. First, we may want to inform whoever is interested (our main activity, if it is running, for example) that we are done. Then, we probably want to stop running in the foreground. Lastly, if we do not expect to require the service again, we could <span class="No-Break">stop it.</span></p>
			<p>An app has several ways to communicate with a service: binding, using broadcast receivers, using a bus architecture, or using a result receiver, to name just a few. For our example, we will use <span class="No-Break">Google’s </span><span class="No-Break"><strong class="source inline">LiveData</strong></span><span class="No-Break">.</span></p>
			<p>Before we proceed, it is worth touching on broadcast receivers. Broadcast receivers allow our app to send and receive messages using a pattern much like the <em class="italic">publish-subscribe </em><span class="No-Break"><em class="italic">design pattern</em></span><span class="No-Break">.</span></p>
			<p>The system broadcasts events such as the device booting up or charging having started. Our services can broadcast status updates as well. For example, they can broadcast a long calculation result on completion. If our app registers to receive a certain message, the system will inform it when that message <span class="No-Break">is broadcast.</span></p>
			<p>This used to be <a id="_idIndexMarker708"/>a common way to communicate with services, but the <strong class="source inline">LocalBroadcastManager</strong> class is now deprecated as it was an application-wide event bus that <span class="No-Break">encouraged anti-patterns.</span></p>
			<p>Having said that, broadcast receivers are still useful for system-wide events. We first define a class overriding the <strong class="source inline">BroadcastReceiver</strong> <span class="No-Break">abstract class:</span></p>
			<pre class="source code">
class ToastBroadcastReceiver : BroadcastReceiver() {
  override fun onReceive(context: Context, intent: Intent) {
    StringBuilder().apply {
      append("Action: ${intent.action}\n")
      append(
        "URI:${intent.toUri(Intent.URI_INTENT_SCHEME)}\n")
      toString().let { eventText -&gt;
        Toast.makeText(context, eventText,
        Toast.LENGTH_LONG).show()
      }
    }
  }
}</pre>
			<p>When an event is received by <strong class="source inline">ToastBroadcastReceiver</strong>, it will show a toast showing the action and URI of <span class="No-Break">the event.</span></p>
			<p>We can register our receiver via the <span class="No-Break"><strong class="source inline">Manifest.xml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source code">
&lt;receiver android:name=".ToastBroadcastReceiver"
android:exported="true"&gt;
  &lt;intent-filter&gt;
    &lt;action android:name=
      "android.intent.action.ACTION_POWER_CONNECTED" /&gt;
  &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre>
			<p>Specifying <strong class="source inline">android:exported="true"</strong> tells the system that this receiver can receive <a id="_idIndexMarker709"/>messages from outside of the application. The action defines the message we are interested in. We can specify multiple actions. In this example, we listen for when the device starts charging. Keep in mind that setting this value to <strong class="source inline">true</strong> allows other apps, including malicious ones, to activate <span class="No-Break">this receiver.</span></p>
			<p>We can al<a id="_idTextAnchor487"/>so register for messages <span class="No-Break">in code:</span></p>
			<pre class="source code">
val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply { addAction(Intent.ACTION_POWER_CONNECTED) }
registerReceiver(ToastBroadcastReceiver(), filter)</pre>
			<p>Adding this code to an activity or in our custom application class would register a new instance of our receiver as well. This receiver will live so long as the context (activity or application) is valid. So, correspondingly, if the activity or application is destroyed, our receiver will be freed to be <span class="No-Break">garbage collected.</span></p>
			<p>Now back to our implementation. <strong class="source inline">LiveData</strong> already comes bundled with <strong class="source inline">androidx.appcompat</strong>, saving us the trouble of having to manually include it in our project. We can define a <strong class="source inline">LiveData</strong> instance in the companion object of the service, <span class="No-Break">like so:</span></p>
			<pre class="source code">
companion object {
  <strong class="bold">private val mutableWorkCompletion = MutableLiveData&lt;String&gt;()</strong>
<strong class="bold">  val workCompletion: LiveData&lt;String&gt; = mutableWorkCompletion</strong>
}</pre>
			<p>Note that we hide the <strong class="source inline">MutableLiveData</strong> instance behind a <strong class="source inline">LiveData</strong> interface. This is so that consumers can only read the data. We can now use the <strong class="source inline">mutableWorkCompletion</strong> instance to report completion by assigning it a value. However, we must remember that values can only be assigned to the <strong class="source inline">LiveData</strong> instances on the <span class="No-Break">main thread.</span></p>
			<p>This means once our work is done, we must switch back to the main thread. We can easily achieve that—all we need is a new handler with the main <strong class="source inline">Looper</strong> (obtained by calling <strong class="source inline">Looper.getMainLooper()</strong>), to which we can post <span class="No-Break">our update.</span></p>
			<p>Now that our service is ready to do some work, we can finally launch it. Before we do, we must make sure we added the service to our <strong class="source inline">AndroidManifest.xml</strong> file within the <strong class="source inline">&lt;application&gt;&lt;/application&gt;</strong> block, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
&lt;application ...&gt;
    <strong class="bold">&lt;service android:name="ForegroundService" /&gt;</strong>
&lt;/application&gt;</pre>
			<p>To launch the service we just added to our manifest, we create <strong class="source inline">Intent</strong>, passing in any extra data required, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source code">
val serviceIntent = Intent(this, ForegroundService::class.java).apply {
    putExtra("ExtraData", "Extra value")
}</pre>
			<p>Then, we<a id="_idIndexMarker710"/> call <strong class="source inline">ContextCompat.startForegroundService(Context, Intent)</strong> to fire <a id="_idTextAnchor488"/><a id="_idTextAnchor489"/>off <strong class="source inline">Intent</strong> and launch <span class="No-Break">the service.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor490"/>Exercise 8.02 – tracking your SCA’s work with a Foreground Service</h2>
			<p>In the first exercise, you <a id="_idIndexMarker711"/>tracked the SCA as it<a id="_idIndexMarker712"/> was preparing to head out using the <strong class="source inline">WorkManager</strong> class and multiple Worker instances showing toasts. In this exercise, you will track the SCA as it deploys to the field and moves toward the assigned target by showing a sticky notification counting down the time to arrival at <span class="No-Break">the destination.</span></p>
			<p>This notification will be driven by a Foreground Service, which will present and continuously update it. Clicking the notification at any time will launch your main activity if it’s not already running and will always bring it to <span class="No-Break">the foreground:</span></p>
			<ol>
				<li>Start by adding the <strong class="source inline">WorkManager</strong> dependency to your app’s <span class="No-Break"><strong class="source inline">build.gradle</strong></span><span class="No-Break"> file:</span><pre class="source code">
implementation "androidx.work:work-runtime:2.8.0"</pre></li>
				<li>Create a new class called <strong class="source inline">RouteTrackingService</strong>, extending the abstract <span class="No-Break"><strong class="source inline">Service</strong></span><span class="No-Break"> class:</span><pre class="source code">
class RouteTrackingService : Service() {
  override fun onBind(intent: Intent): IBinder? = null
}</pre></li>
			</ol>
			<p>You will not rely on binding in this exercise, so it is safe to simply return <strong class="source inline">null</strong> in the <span class="No-Break"><strong class="source inline">onBind(Intent)</strong></span><span class="No-Break"> implementation.</span></p>
			<ol>
				<li value="3">In the newly created service, define some constants that you will later need, as well as the <strong class="source inline">LiveData</strong> instance used to <span class="No-Break">observe progress:</span><pre class="source code">
companion object {
    const val NOTIFICATION_ID = 0xCA7
    const val EXTRA_SECRET_CAT_AGENT_ID = "scaId"
    private val mutableTrackingCompletion =
        MutableLiveData&lt;String&gt;()
    val trackingCompletion: LiveData&lt;String&gt; =
        mutableTrackingCompletion
}</pre></li>
			</ol>
			<p><strong class="source inline">NOTIFICATION_ID</strong> has to be a unique identifier for the notification owned by this service and must not be <strong class="source inline">0</strong>. Now, <strong class="source inline">EXTRA_SECRET_CAT_AGENT_ID</strong> is the constant you will use to pass data to the service. <strong class="source inline">mutableTrackingCompletion</strong> is private and is used to allow you to post completion updates internally via <strong class="source inline">LiveData</strong> without exposing the mutability outside of the service. <strong class="source inline">trackingCompletion</strong> is then used to expose the <strong class="source inline">LiveData</strong> instance for observation in an <span class="No-Break">immutable fashion.</span></p>
			<ol>
				<li value="4">Add a function to <a id="_idIndexMarker713"/>your <strong class="source inline">RouteTrackingService</strong> class to<a id="_idIndexMarker714"/> provide <strong class="source inline">PendingIntent</strong> to your <span class="No-Break">sticky notification:</span><pre class="source code">
private fun getPendingIntent(): PendingIntent {
  val flag = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_
    CODES.S) FLAG_IMMUTABLE else 0
  return PendingIntent.getActivity(this, 0, Intent(this, 
    MainActivity::class.java), flag)</pre></li>
			</ol>
			<p>This will launch <strong class="source inline">MainActivity</strong> whenever the user clicks on <strong class="source inline">Notification</strong>. You call <strong class="source inline">PendingIntent.getActivity()</strong>, passing a context, no request code (<strong class="source inline">0</strong>), <strong class="source inline">Intent</strong> that will launch <strong class="source inline">MainActivity</strong>, and the <strong class="source inline">FLAG_IMMUTABLE</strong> flag if available, otherwise no flags (<strong class="source inline">0</strong>) to it. You get back a <strong class="source inline">PendingIntent</strong>, which will launch <span class="No-Break">that activity.</span></p>
			<ol>
				<li value="5">Add another function to create <strong class="source inline">NotificationChannel</strong> on devices running Android Oreo or newer, and return a <span class="No-Break">channel ID:</span><pre class="source code">
private fun createNotificationChannel(): String =
  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    val newChannelId = "CatDispatch"
    val channelName = "Cat Dispatch Tracking"
    val channel = NotificationChannel(
      newChannelId, channelName,
      NotificationManager.IMPORTANCE_DEFAULT
    )
    val service = requireNotNull(
      ContextCompat.getSystemService(this,
        NotificationManager::class.java)
    )
    service.createNotificationChannel(channel)
    newChannelId
  } else { "" }</pre></li>
			</ol>
			<p>You start by checking the Android version. You only need to create a channel if it’s Android O or later. Otherwise, you can return an empty string. For Android O, you define the channel ID. This needs to be unique for a package. Next, you define a channel name that will be visible to <span class="No-Break">the user.</span></p>
			<p>This <a id="_idIndexMarker715"/>can (and should) be localized. We skipped that<a id="_idIndexMarker716"/> part for the sake of simplicity. A <strong class="source inline">NotificationChannel</strong> instance is then created with the importance set to <strong class="source inline">IMPORTANCE_DEFAULT</strong>. The importance dictates how disruptive the notifications posted to this <span class="No-Break">channel are.</span></p>
			<p>Lastly, a channel is created using <strong class="source inline">Notification Service</strong> with the data provided in the <strong class="source inline">NotificationChannel</strong> instance. The function returns the channel ID so that it can be used to construct <span class="No-Break">the </span><span class="No-Break"><strong class="source inline">Notification</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="6">Create a function to provide you <span class="No-Break">with </span><span class="No-Break"><strong class="source inline">Notification.Builder</strong></span><span class="No-Break">:</span><pre class="source code">
private fun getNotificationBuilder(pendingIntent:
PendingIntent, channelId: String) =
    NotificationCompat.Builder(this, channelId)
    .setContentTitle("Agent approaching destination")
    .setContentText("Agent dispatched")
    .setSmallIcon(R.drawable.ic_launcher_foreground)
    .setContentIntent(pendingIntent)
    .setTicker("Agent dispatched, tracking movement")
    .setOngoing(true)</pre></li>
			</ol>
			<p>This function takes the <strong class="source inline">pendingIntent</strong> and <strong class="source inline">channelId</strong> instances generated from the functions you created earlier and constructs a <span class="No-Break"><strong class="source inline">NotificationCompat.Builder</strong></span><span class="No-Break"> class.</span></p>
			<p>The builder<a id="_idIndexMarker717"/> lets you define a title (the first row), text (the second row), a small icon (size differs based on the device) to use, the <strong class="source inline">Intent</strong> to be triggered when the user clicks on <strong class="bold">Notification</strong>, and a <a id="_idIndexMarker718"/>ticker (used for accessibility; before Android Lollipop, this showed before the notification <span class="No-Break">was presented).</span></p>
			<p>Setting the notification to ongoing prevents users from dismissing them. This also prevents Android from muting the notification due to <span class="No-Break">frequent updates.</span></p>
			<p>You can set other properties, too. Explore the <strong class="source inline">NotificationCompat.Builder</strong> class. In a real project, remember to use string resources from <strong class="source inline">strings.xml</strong> rather than <span class="No-Break">hardcoded strings.</span></p>
			<ol>
				<li value="7">Implement the following code to introduce a function to start the <span class="No-Break">foreground service:</span><pre class="source code">
private fun startForegroundService():
NotificationCompat.Builder {
  val pendingIntent = getPendingIntent()
  val channelId = if (Build.VERSION.SDK_INT &gt;=
    Build.VERSION_CODES.O) {
      createNotificationChannel()
  } else { "" }
  val notificationBuilder = getNotificationBuilder(
    pendingIntent, channelId)
  startForeground(NOTIFICATION_ID, notificationBuilder.build())
  return notificationBuilder
}</pre></li>
			</ol>
			<p>You <a id="_idIndexMarker719"/>first get <strong class="source inline">PendingIntent</strong> using <a id="_idIndexMarker720"/>the <strong class="source inline">getPendingIntent</strong> function you introduced earlier. Then, depending on the API level of the device, you create a notification channel and get its ID or set an <span class="No-Break">empty ID.</span></p>
			<p>You pass <strong class="source inline">pendingIntent</strong> and <strong class="source inline">channelId</strong> to the function that constructs a <strong class="source inline">NotificationCompat.Builder</strong> and start the service as a Foreground Service, providing it with <strong class="source inline">NOTIFICATION_ID</strong> and a notification built using the builder. The function returns <strong class="source inline">NotificationCompat.Builder</strong>, to be used later to update <span class="No-Break">the notification.</span></p>
			<ol>
				<li value="8">Define two fields in your service—one to hold a reusable <strong class="source inline">NotificationCompat.Builder</strong> class, and another to hold a reference to <strong class="source inline">Handler</strong>, which you will later use to post work in <span class="No-Break">the background:</span><pre class="source code">
private lateinit var notificationBuilder:
NotificationCompat.Builder
private lateinit var serviceHandler: Handler</pre></li>
				<li>Next, override <strong class="source inline">onCreate()</strong> to start the service as a foreground service and keep a reference of the <strong class="source inline">Notification.Builder</strong>, and <span class="No-Break">create </span><span class="No-Break"><strong class="source inline">serviceHandler</strong></span><span class="No-Break">:</span><pre class="source code">
override fun onCreate() {
  super.onCreate()
  notificationBuilder = startForegroundService()
  val handlerThread =
    HandlerThread("RouteTracking").apply { start() }
  serviceHandler = Handler(handlerThread.looper)
}</pre></li>
			</ol>
			<p>Note<a id="_idIndexMarker721"/> that to create the <strong class="source inline">Handler</strong> instance, you<a id="_idIndexMarker722"/> must first initialize and <span class="No-Break">start </span><span class="No-Break"><strong class="source inline">HandlerThread</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="10">Define a call that tracks your deployed SCA as it approaches its <span class="No-Break">designated destination:</span><pre class="source code">
private fun trackToDestination(notificationBuilder: NotificationCompat.Builder) {
  val notificationManager = getSystemService(NOTIFICATION_
    SERVICE) as NotificationManager
  for (i in 10 downTo 0) {
    Thread.sleep(1000L)
    notificationBuilder.setContentText(
      "$i seconds to destination").setSilent(true)
    notificationManager.notify(NOTIFICATION_ID,
      notificationBuilder.build())
  }
}</pre></li>
			</ol>
			<p>This will first obtain a reference to the <strong class="source inline">NotificationManager</strong>. Then, it will count down from <strong class="source inline">10</strong> to <strong class="source inline">0</strong>, sleeping for 1 second between updates and then updating the notification with the remaining time. Note we set the notification to be silent. This avoids the notification playing a sound <span class="No-Break">every second.</span></p>
			<ol>
				<li value="11">Add a function to notify observers of completion on the <span class="No-Break">main thread:</span><pre class="source code">
private fun notifyCompletion(agentId: String) {
    Handler(Looper.getMainLooper()).post {
        mutableTrackingCompletion.value = agentId
    }
}</pre></li>
			</ol>
			<p>By <a id="_idIndexMarker723"/>posting on a handler using the main <strong class="source inline">Looper</strong>, you<a id="_idIndexMarker724"/> make sure that updates occur on the main (UI) app thread. When setting the value to the agent ID, you are notifying all observers that that agent ID has reached <span class="No-Break">its destination.</span></p>
			<ol>
				<li value="12">Override <strong class="source inline">onStartCommand(Intent?, Int, Int)</strong> <span class="No-Break">like so:</span><pre class="source code">
override fun onStartCommand(intent: Intent?, flags:
Int, startId: Int): Int {
  val returnValue = super.onStartCommand(intent,
    flags, startId)
  val agentId = intent?.getStringExtra(EXTRA_SECRET_CAT_
    AGENT_ID)
    ?: throw IllegalStateException("Agent ID must be 
    provided")
  serviceHandler.post {
    trackToDestination(notificationBuilder)
    notifyCompletion(agentId)
    stopForeground(true)
    stopSelf()
  }
  return returnValue
}</pre></li>
			</ol>
			<p>You first <a id="_idIndexMarker725"/>delegate the call to <strong class="source inline">super</strong>, which internally<a id="_idIndexMarker726"/> calls <strong class="source inline">onStart()</strong> and returns a backward-compatible state you could return. You store this returned value. Next, you obtain the SCA ID from the extras passed via the <strong class="source inline">Intent</strong>. This service will not work without an agent ID, so you throw an exception if one is <span class="No-Break">not provided.</span></p>
			<p>Next, you switch to the background thread defined in <strong class="source inline">onCreate</strong> to track the agent to its destination in a blocking way. When tracking is done, you notify observers that the task is complete, stop the foreground service (removing the notification by passing <strong class="source inline">true</strong>), and stop the service itself, as you don’t expect to require it again soon. You then return the earlier stored return value <span class="No-Break">from </span><span class="No-Break"><strong class="source inline">super</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="13">Update your <strong class="source inline">AndroidManifest.xml</strong> file to request the necessary permissions and introduce <span class="No-Break">the service:</span><pre class="source code">
&lt;manifest ...&gt;
  <strong class="bold">&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt;</strong>
<strong class="bold">  &lt;uses-permission android:name="android.permission.POST_NOTIFICATIONS" /&gt;</strong>
  &lt;application ...&gt;
    <strong class="bold">&lt;service</strong>
      <strong class="bold">android:name=".RouteTrackingService"</strong>
      <strong class="bold">android:enabled="true"</strong>
      <strong class="bold">android:exported="true" /&gt;</strong>
    &lt;activity ...&gt;</pre></li>
			</ol>
			<p>First, we <a id="_idIndexMarker727"/>declare that our app requires<a id="_idIndexMarker728"/> the <strong class="source inline">FOREGROUND_SERVICE</strong> permission. Unless we do so, the system will block our app from using foreground services. We also request the <strong class="source inline">POST_NOTIFICATIONS</strong> permission, without which we cannot present notifications on SDK 33+. Next, we declare the service. Setting <strong class="source inline">android:enabled="true"</strong> tells the system it can instantiate <span class="No-Break">the service.</span></p>
			<p>The default is <strong class="source inline">"true"</strong>, so this is optional. Defining the service with <strong class="source inline">android:exported="true"</strong> tells the system that other applications can start the service. In our case, we don’t need this extra functionality, but we have added it just so that you are aware of <span class="No-Break">this capability.</span></p>
			<ol>
				<li value="14">Back to your <strong class="source inline">MainActivity</strong>. Introduce a function to <span class="No-Break">launch </span><span class="No-Break"><strong class="source inline">RouteTrackingService</strong></span><span class="No-Break">:</span><pre class="source code">
private fun launchTrackingService() {
  RouteTrackingService.trackingCompletion.observe(
    this) { agentId -&gt;
        showResult("Agent $agentId arrived!")
    }
  val serviceIntent = Intent(this,
    RouteTrackingService::class.java).apply {
      putExtra(EXTRA_SECRET_CAT_AGENT_ID, "007")
    }
  ContextCompat.startForegroundService(this, 
  serviceIntent)
}</pre></li>
			</ol>
			<p>This function first observes the <strong class="source inline">trackingCompletion</strong> <strong class="source inline">LiveData</strong> for completion updates, showing a result on completion. Then, it defines an <strong class="source inline">Intent</strong> for launching the service, setting the SCA ID as an extra parameter for that <strong class="source inline">Intent</strong>. It then launches the service as a foreground service using <strong class="source inline">ContextCompat</strong>, which hides away compatibility-related logic <span class="No-Break">for you.</span></p>
			<ol>
				<li value="15">Now, extract the logic from <strong class="source inline">onCreate()</strong> (everything that comes after the <strong class="source inline">setContentView</strong> call) to a private function <span class="No-Break">named </span><span class="No-Break"><strong class="source inline">dispatchCat</strong></span><span class="No-Break">.</span></li>
				<li>Update <strong class="source inline">dispatchCat</strong> to start tracking the <a id="_idIndexMarker729"/>SCA as soon as it is suited up and ready <span class="No-Break">to</span><span class="No-Break"><a id="_idIndexMarker730"/></span><span class="No-Break"> go:</span><pre class="source code">
workManager.getWorkInfoByIdLiveData(
  catSuitUpRequest.id).observe(this) { info -&gt;
  if (info.state.isFinished) {
    showResult("Agent done suiting up. Ready to go!")
    <strong class="bold">launchTrackingService()</strong>
  }
}</pre></li>
				<li>Create a new private function called <strong class="source inline">ensurePermissionGrantedAndDispatchCat</strong>. In this function, make sure you have the <strong class="source inline">POST_NOTIFICATIONS</strong> permission. Request it if you don’t. Refer to <a href="B19411_07.xhtml#_idTextAnchor421"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Android Permissions and Google Maps</em>, for the implementation details. If or when you h<a id="_idTextAnchor491"/>ave the permission, <span class="No-Break">call </span><span class="No-Break"><strong class="source inline">dispatchCat</strong></span><span class="No-Break">.</span></li>
				<li>Launch <span class="No-Break">the app:</span></li>
			</ol>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B19411_08_02.jpg" alt="Figure 8.2 – The notification counting down"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The notification counting down</p>
			<p>After the <a id="_idIndexMarker731"/>notifications informing you of the SCA’s preparation<a id="_idIndexMarker732"/> steps, you should see a notification in your status bar. That notification should then count down from 10 to 0, disappear, and be replaced by a toast informing you that the agent arrived at its destination. Seeing that last toast tells you that you managed to communicate the SCA ID to the service as well as get it back on completion of the <span class="No-Break">background task.</span></p>
			<p>With all the knowledge gained fr<a id="_idTextAnchor492"/><a id="_idTextAnchor493"/>om this chapter, let’s complete the <span class="No-Break">following activity.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor494"/>Activity 8.01 – reminder to drink water</h2>
			<p>The average human <a id="_idIndexMarker733"/>loses about 2,500 <strong class="bold">milliliters</strong> (<strong class="bold">ml</strong>) of water per day. To stay healthy, we need to consume as much water as we lose. However, due to the busy nature of modern life, a lot of us forget to stay <span class="No-Break">hydrated regularly.</span></p>
			<p class="callout heading">Note</p>
			<p class="callout">See <a href="https://packt.link/90nbQ">https://packt.link/90nbQ</a> for more information <span class="No-Break">on this.</span></p>
			<p>Suppose you wanted to develop an app that keeps track of your water loss (statistically) and gives you a constant update on your fluid balance. Starting from a balanced state, the app would gradually decrease the user’s tracked water level. The user could tell the app when they drank a glass of water, and it would update the water <span class="No-Break">level accordingly.</span></p>
			<p>The continuous updating of the water level will leverage your knowledge of running a background task, and you will also utilize your knowledge of communicating with a service to update a balance in response to <span class="No-Break">user interaction.</span></p>
			<p>The following steps will <a id="_idIndexMarker734"/>help you complete <span class="No-Break">the activity:</span></p>
			<ol>
				<li>Create an empty activity project and name your app <strong class="source inline">My </strong><span class="No-Break"><strong class="source inline">Water Tracker</strong></span><span class="No-Break">.</span></li>
				<li>Add the foreground service and post notifications permissions to your <span class="No-Break"><strong class="source inline">AndriodManifest.xml</strong></span><span class="No-Break"> file.</span></li>
				<li>Create a <span class="No-Break">new service.</span></li>
				<li>Define a variable in your service to track the <span class="No-Break">water level.</span></li>
				<li>Define constants for a notification ID and for an extra <strong class="source inline">Intent</strong> <span class="No-Break">data key.</span></li>
				<li>Set up the creation of the notification from <span class="No-Break">the service.</span></li>
				<li>Add functions to request the notification permissions (if required), start the Foreground Service and update the <span class="No-Break">water level.</span></li>
				<li>Set the water level to decrease by 0.144 ml every <span class="No-Break">5 seconds.</span></li>
				<li>Handle the addition of fluids from outside <span class="No-Break">the service.</span></li>
				<li>Make sure the service cleans up callbacks and messages <span class="No-Break">when destroyed.</span></li>
				<li>Register the service in the <span class="No-Break"><strong class="source inline">Manifest.xml</strong></span><span class="No-Break"> file.</span></li>
				<li>Start the service from <strong class="source inline">MainActivity</strong> when the activity is created, after the notification permission is granted, <span class="No-Break">if needed.</span></li>
				<li>Add a button to the main activity layout with a <strong class="bold">Drank a Glass of </strong><span class="No-Break"><strong class="bold">Water</strong></span><span class="No-Break"> label.</span></li>
				<li>When the user clicks the button, notify the service that it needs to increment the water level <a id="_idIndexMarker735"/>by <span class="No-Break">250 ml.</span></li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution t<a id="_idTextAnchor495"/><a id="_idTextAnchor496"/>o this activity can be found <span class="No-Break">at </span><a href="https://packt.link/By7eE"><span class="No-Break">https://packt.link/By7eE</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor497"/>Summary</h1>
			<p>In this chapter, we learned how to execute long-running background tasks using <strong class="source inline">WorkManager</strong> and foreground services. We discussed how to communicate progress to the user, and how to get the user back into an app once a task is finished executing. All the topics covered in this chapter are quite broad, and you could explore communicating with services, building notifications, and using the <strong class="source inline">WorkManager</strong> <span class="No-Break">class further.</span></p>
			<p>For most common scenarios, you now have the tools you need. Common use cases include background downloads, the background cleaning up of cached assets, playing media while the app is not running in the foreground, and, combined with the knowledge we gained from <a href="B19411_07.xhtml#_idTextAnchor421"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Android Permissions and Google Maps</em>, tracking the user’s location <span class="No-Break">over time.</span></p>
			<p>In the next chapter, we will look into making our apps more robust and maintainable by writing unit and integration tests. This is particularly helpful when the code you write runs in the background, a<a id="_idTextAnchor498"/>nd it is not immediately evident when something <span class="No-Break">goes wrong.</span></p>
		</div>
		<div>
			<div id="_idContainer161" class="IMG---Figure">
			</div>
		</div>
	</body></html>