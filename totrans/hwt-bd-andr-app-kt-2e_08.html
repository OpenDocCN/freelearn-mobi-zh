<html><head></head><body>
		<div><h1 id="_idParaDest-132" class="chapter number"><a id="_idTextAnchor467"/><a id="_idTextAnchor468"/><a id="_idTextAnchor469"/><a id="_idTextAnchor470"/><a id="_idTextAnchor471"/>8</h1>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor472"/>Services, WorkManager, and Notifications</h1>
			<p><a id="_idTextAnchor473"/>This chapter will introduce you to the concepts of managing long-running tasks in the background of an app. By the end of this chapter, you will be able to trigger a background task, create a notification for the user when a background task is complete, and launch an application from a notification. This chapter will give you a solid understanding of how to manage background tasks and keep the user informed about the progress of these tasks.</p>
			<p><a id="_idTextAnchor474"/>In the previous chapter, we learned how to request permissions from the user and use Google’s Maps API. With that knowledge, we obtained the user’s location and allowed them to deploy an agent on a local map. In this chapter, we will learn how to track a long-running process and report its progress to the user.</p>
			<p>We will build an example app where we will assume that <strong class="bold">Secret Cat Agents</strong> (<strong class="bold">SCAs</strong>) get deployed in a record time of 15 seconds. When a <a id="_idIndexMarker675"/>cat successfully deploys, we will notify the user and let them launch the app, presenting them with a successful deployment message.</p>
			<p class="callout heading">Note</p>
			<p class="callout">We will go with 15 seconds because that way, we will avoid having to wait for very long before our background task completes.</p>
			<p>Ongoing background tasks are quite common in the mobile world. Background tasks run even when an application is not active. Examples of long-running background tasks include the downloading of files, resource clean-up jobs, playing music, and tracking the user’s location.</p>
			<p>Historically, Google offered Android developers multiple ways of executing such tasks: <code>Services</code>, <code>JobScheduler</code>, and Firebase’s <code>JobDispatcher</code> and <code>AlarmManager</code>. With the fragmentation that existed in the Android world, it was quite a mess to cope with. Luckily for us, since March 2019, we have had a better (more stable) option.</p>
			<p>With the introduction of <code>WorkManager</code>, Google has abstracted the logic of choosing a background executing mechanism based on the API version away for us. We still use a foreground service, which is a special kind of service, for certain tasks that should be known to the user while running, such as playing music or tracking the user’s location in a running app.</p>
			<p class="callout heading">Note</p>
			<p class="callout"><strong class="bold">Services</strong> are<a id="_idIndexMarker676"/> application components designed to run in the background, even when an app is not running. Except for foreground services, which are tied to a notification, services have no user interface.</p>
			<p>Before we proceed, take a quick step back. We have mentioned services, and we will be focusing on foreground services, but we haven’t quite explained what services are. Services are application components designed to run in the background, even when an app is not running.</p>
			<p>Services have no user interface, with foreground services being the exception. It is important to note that services run on the main thread of their hosting process. This means that their operations can block the app. It is up to us to start a separate thread from within a service to avoid that.</p>
			<p>Let’s get started and look at the implementation of the multiple approaches available in Android for managing a background task.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Starting a background task using <code>WorkManager</code></li>
				<li>Background operations noticeable to the user – using a Foreground Servic<a id="_idTextAnchor475"/><a id="_idTextAnchor476"/>e</li>
			</ul>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor477"/>Technical requirements</h1>
			<p>The complete code for all the exercises and the activity in this chapter is available on GitHub at <a href="https://packt.link/i8IRQ">https://packt.link/i8IRQ</a></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor478"/>Starting a background task using WorkManager</h1>
			<p>The first<a id="_idIndexMarker677"/> question we will address here is should<a id="_idIndexMarker678"/> we opt for <code>WorkManager</code> or a foreground service? To answer that, a good rule of thumb is to ask whether you need the action to be tracked by the user in real time.</p>
			<p>If <a id="_idIndexMarker679"/>the answer is yes (for example, if you have a task such<a id="_idIndexMarker680"/> as responding to the user’s location or playing music in the background), then you should use a foreground service with its attached notification to give the user a real-time indication of state. When the background task can be delayed or does not require user interaction (for example, downloading a large file), use <code>WorkManager</code>.</p>
			<p class="callout heading">Note</p>
			<p class="callout">Starting with version <code>2.3.0-alpha02</code> of <code>WorkManager</code>, you can launch a foreground service via the <code>WorkManager</code> singleton by calling <code>setForegroundAsync(ForegroundInfo)</code>. Our control over that foreground service is quite limited. It does allow you to attach a (predefined) notification to the work, which is why it is worth mentioning.</p>
			<p>In our example app, we will track the SCAs’ preparation for deployment. Before an agent can head out, they need to stretch, groom their fur, visit the litter box, and suit up. Each one of these tasks takes some time. Because you can’t rush a cat, the agent will finish each step in its own time. All we can do is wait (and let the user know when the task is done). <code>WorkManager</code> is perfect for such a scenario.</p>
			<p>To use <code>WorkManager</code>, we need to familiarize ourselves with its four main classes:</p>
			<ul>
				<li><code>WorkManager</code>: This receives work and enqueues it based on provided arguments and constraints (such as internet connectivity and the device charging).</li>
				<li><code>Worker</code>: This is a wrapper around the work that needs doing. It has one function, <code>doWork()</code>, which we override to implement the background work code. The <code>doWork()</code> function will be executed in a background thread.</li>
				<li><code>WorkRequest</code>: This class binds a <code>Worker</code> class to arguments and constraints. There are two types of <code>WorkRequest</code>: <code>OneTimeWorkRequest</code>, which runs the work once, and <code>PeriodicWorkRequest</code>, which can be used to schedule work to run at a fixed interval.</li>
				<li><code>ListenableWorker.Result</code>: You probably guessed it, but this is the class holding the result of the executed work. The result can be one of <code>Success</code>, <code>Failure</code>, or <code>Retry</code>.</li>
			</ul>
			<p>Other than these four classes, we also have the <code>Data</code> class, which holds data passed to and from the worker.</p>
			<p>Let’s get back to our example. We want to define four tasks that need to occur in sequential order: the cat needs to stretch, then it needs to groom its fur, then visit the litter box, and, finally, it needs to suit up.</p>
			<p>Before we can start using <code>WorkManager</code>, we have to first include its dependency in our app <code>build.gradle</code> file:</p>
			<pre class="source code">
implementation "androidx.work:work-runtime:2.8.0"</pre>
			<p>With <code>WorkManager</code> included in our project, we’ll go ahead and create our workers. The <a id="_idIndexMarker681"/>first worker <a id="_idIndexMarker682"/>will look something like this:</p>
			<pre class="source code">
class CatStretchingWorker(
  context: Context, workerParameters: WorkerParameters
) : Worker(context, workerParameters) {
  override fun doWork(): Result {
    val catAgentId =
      inputData.getString(INPUT_DATA_CAT_AGENT_ID)
    Thread.sleep(3000L)
    val outputData = Data.Builder()
      .putString(OUTPUT_DATA_CAT_AGENT_ID, catAgentId)
      .build()
      return Result.success(outputData)
  }
  companion object {
    const val INPUT_DATA_CAT_AGENT_ID = "id"
    const val OUTPUT_DATA_CAT_AGENT_ID = "id"
  }
}</pre>
			<p>We<a id="_idIndexMarker683"/> start by extending <code>Worker</code> and overriding<a id="_idIndexMarker684"/> its <code>doWork()</code> function. We then read the SCA ID from the input data. Then, because we have no real sensors to track the progress of the cat stretching, we fake our wait by introducing a 3-second (3,000 milliseconds) <code>Thread.sleep(Long)</code> call. Finally, we construct an output <code>data</code> class with the ID we received in our input and return it with the successful result.</p>
			<p>Once we’ve created workers for all our tasks (<code>CatStretchingWorker</code>, <code>CatFurGroomingWorker</code>, <code>CatLitterBoxSittingWorker</code>, and <code>CatSuitUpWorker</code>), similarly to how we created the first one, we can call <code>WorkManager</code> to chain them. Let’s also assume we can’t tell the progress of the agent unless we’re connected to the internet. Our call would look something like this:</p>
			<pre class="source code">
val catStretchingInputData = Data.Builder()
  .putString(CatStretchingWorker.INPUT_DATA_CAT_AGENT_ID,
  "catAgentId").build()
val catStretchingRequest = OneTimeWorkRequest
  .Builder(CatStretchingWorker::class.java)
val catStretchingRequest = OneTimeWorkRequest.Builder(
  CatStretchingWorker::class.java)
    .setConstraints(networkConstraints)
    .setInputData(catStretchingInputData)
    .build()
...
WorkManager.getInstance(this)
  .beginWith(catStretchingRequest)
  .then(catFurGroomingRequest)
  .then(catLitterBoxSittingRequest)
  .then(catSuitUpRequest)
  .enqueue()</pre>
			<p>In the<a id="_idIndexMarker685"/> preceding code, we first construct <a id="_idIndexMarker686"/>a <code>Constraints</code> instance declaring we need to be connected to the internet for the work to execute. We then define our input data, setting it to the SCA ID. Next, we bind the constraints and input data to our <code>Worker</code> class by constructing <code>OneTimeWorkRequest</code>.</p>
			<p>The construction of the other <code>WorkRequest</code> instances has been left out, but they are almost identical to the one shown here. We can now chain all the requests and enqueue them in the <code>WorkManager</code> class. You can enqueue a single <code>WorkRequest</code> instance by passing it directly to the <code>WorkManager</code> <code>enqueue()</code> function, or you can have multiple <code>WorkRequest</code> instances run in parallel by passing them all to the <code>WorkManager</code> <code>enqueue()</code> function as a list.</p>
			<p>Our tasks will be executed by <code>WorkManager</code> when the constraints are met.</p>
			<p>Each <code>Request</code> instance has a unique identifier. <code>WorkManager</code> exposes a <code>LiveData</code> property for each request, allowing us to track the progress of its work by passing its unique identifier, as shown in the following code:</p>
			<pre class="source code">
workManager.getWorkInfoByIdLiveData(
  catStretchingRequest.id
).observe(this) { info -&gt;
  if (info.state.isFinished) { doSomething() }
}</pre>
			<p>The state of work can be <code>BLOCKED</code> (there is a chain of requests, and this one is not next in the chain), <code>ENQUEUED</code> (there is a chain of requests, and this work is next), <code>RUNNING</code> (the work in <code>doWork()</code> is executing), and <code>SUCCEEDED</code>. Work can also be canceled, leading to a <code>CANCELLED</code> state, or it can fail, leading to a <code>FAILED</code> state.</p>
			<p>Finally, there’s <code>Result.retry</code>. Returning this result tells the <code>WorkManager</code> class to enqueue the work again. The policy governing when to run the work again is defined by a <code>backoff</code> criteria set on <code>WorkRequest</code> <code>Builder</code>. The default <code>backoff</code> policy is exponential, but we can set it to be linear instead. We can also define the initial <code>backoff</code> time.</p>
			<p>Let’s put<a id="_idIndexMarker687"/> the knowledge gained so far into practice<a id="_idIndexMarker688"/> in the following exercise. In this section, we will track our SCA from the moment we fire off the command to deploy it to the field to the moment it arrives at its<a id="_idTextAnchor479"/><a id="_idTextAnchor480"/> destination.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor481"/>Exercise 8.01 – executing background work with the WorkManager class</h2>
			<p>In this first exercise, we <a id="_idIndexMarker689"/>will track the SCA as it<a id="_idIndexMarker690"/> prepares to head out by enqueuing the chained <code>WorkRequest</code> classes:</p>
			<ol>
				<li>Start by creating a new <code>Empty Activity</code> project (<strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">New Project</strong> | <strong class="bold">Empty Activity</strong>). Click <strong class="bold">Next</strong>.</li>
				<li>Name your application <code>Cat </code><code>Agent Tracker</code>.</li>
				<li>Make sure your package name is <code>com.example.catagenttracker</code>.</li>
				<li>Set the save location to where you want to save your project.</li>
				<li>Leave everything else at its default values and click <strong class="bold">Finish</strong>.</li>
				<li>Make sure you are on the Android view in your <strong class="bold">Project</strong> pane.</li>
				<li>Open your app’s <code>build.gradle</code> file. In the <code>dependencies</code> block, add the <code>WorkManager</code> dependency:<pre class="source code">
dependencies {
    ...
    <strong class="bold">implementation "androidx.work:work-runtime:2.8.0"</strong>
    ...
}</pre></li>
			</ol>
			<p>This will allow you to use <code>WorkManager</code> and its dependencies in your code.</p>
			<ol>
				<li value="8">Create a new package under your app package (right-click on <code>com.example.catagenttracker</code>, then <code>com.example.catagenttracker.worker</code>.</li>
				<li>Create a new class under <code>com.example.catagenttracker.worker</code> named <code>CatStretchingWorker</code> (right-click on <code>worker</code>, then <strong class="bold">New</strong> | <strong class="bold">New</strong> <strong class="bold">Kotlin File/Class</strong>). Under <strong class="bold">Kind</strong>, choose <strong class="bold">Class</strong>.</li>
				<li>To <a id="_idIndexMarker691"/>define a <code>Worker</code> instance<a id="_idIndexMarker692"/> that will sleep for <code>3</code> seconds, update the new class like so:<pre class="source code">
package com.example.catagenttracker.worker
[imports]
class CatStretchingWorker(
  context: Context, workerParameters: WorkerParameters
) : Worker(context, workerParameters) {
  override fun doWork(): Result {
    val catAgentId =
      inputData.getString(INPUT_DATA_CAT_AGENT_ID)
    Thread.sleep(3000L)
    val outputData = Data.Builder()
      .putString(OUTPUT_DATA_CAT_AGENT_ID, catAgentId)
      .build()
    return Result.success(outputData)
  }
  companion object {
    const val INPUT_DATA_CAT_AGENT_ID = "inId"
    const val OUTPUT_DATA_CAT_AGENT_ID = "outId"
  }
}</pre></li>
			</ol>
			<p>This will add the required dependencies for a <code>Worker</code> implementation and then extend the <code>Worker</code> class. To implement the actual work, you will override <code>doWork(): Result</code>, making it read the Cat Agent ID from the input, sleep for <code>3</code> seconds (<code>3,000</code> milliseconds), construct an output data instance with the Cat Agent ID, and pass it via a <code>Result.success</code> value.</p>
			<ol>
				<li value="11">Repeat <em class="italic">steps 9</em> and <em class="italic">10</em> to create three more identical workers named <code>CatFurGroomingWorker</code>, <code>CatLitterBoxSittingWorker</code>, and <code>CatSuitUpWorker</code>.</li>
				<li>Open <code>MainActivity</code>. Right<a id="_idIndexMarker693"/> before<a id="_idIndexMarker694"/> the end of the class, add the following:<pre class="source code">
private fun getCatAgentIdInputData(
  catAgentIdKey: String, catAgentIdValue: String) =
  Data.Builder()
    .putString(catAgentIdKey, catAgentIdValue).build()</pre></li>
			</ol>
			<p>This helper function constructs an input <code>Data</code> instance for you with the Cat Agent ID.</p>
			<ol>
				<li value="13">Add the following to the <code>onCreate(Bundle?)</code> function:<pre class="source code">
override fun onCreate(savedInstanceState: Bundle?) {
  super.onCreate(savedInstanceState)
  setContentView(R.layout.activity_main)
  <strong class="bold">val networkConstraints = Constraints.Builder()</strong>
<strong class="bold">    .setRequiredNetworkType(NetworkType.CONNECTED)</strong>
<strong class="bold">    .build()</strong>
  <strong class="bold">val catAgentId = "CatAgent1"</strong>
  <strong class="bold">val catStretchingRequest = OneTimeWorkRequest.</strong>
    <strong class="bold">Builder(CatLitterBoxSittingWorker::class.java)</strong>
    <strong class="bold">.setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(</strong>
      <strong class="bold">getCatAgentIdInputData(CatStretchingWorker</strong>
<strong class="bold">        .INPUT_DATA_CAT_AGENT_ID, catAgentId)</strong>
      <strong class="bold">).build()</strong>
  <strong class="bold">val catFurGroomingRequest = OneTimeWorkRequest.</strong>
    <strong class="bold">Builder(CatFurGroomingWorker::class.java)</strong>
    <strong class="bold">.setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(getCatAgentIdInputData(</strong>
<strong class="bold">      CatFurGroomingWorker.INPUT_DATA_CAT_AGENT_ID,</strong>
<strong class="bold">        catAgentId)</strong>
    <strong class="bold">).build()</strong>
  <strong class="bold">val catLitter<a id="_idTextAnchor482"/>BoxSittingRequest = OneTimeWorkRequest.</strong>
    <strong class="bold">Builder(CatLitterBoxSittingWorker::class.java)</strong>
    <strong class="bold">.setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(getCatAgentIdInputData(</strong>
<strong class="bold">CatLitterBoxSittingWorker.INPUT_DATA_CAT_AGENT_ID,</strong>
      <strong class="bold">catAgentId)</strong>
    <strong class="bold">).build()</strong>
  <strong class="bold">val catSuitUpRequest = OneTimeWorkRequest.Builder(</strong>
<strong class="bold">    CatSuitUpWorker::class.java</strong>
<strong class="bold">  ).setConstraints(networkConstraints)</strong>
    <strong class="bold">.setInputData(getCatAgentIdInputData(CatSuitUpWorker.</strong>
      <strong class="bold">INPUT_DATA_CAT_AGENT_ID, catAgentId)</strong>
    <strong class="bold">).build()</strong>
}</pre></li>
			</ol>
			<p>The first<a id="_idIndexMarker695"/> line added defines<a id="_idIndexMarker696"/> a network constraint. It tells the <code>WorkManager</code> class to wait for an internet connection before executing work. Then, you define your Cat Agent ID. Finally, you define four requests, passing in your <code>Worker</code> classes, the network constraints, and the Cat Agent ID in the form of input data.</p>
			<ol>
				<li value="14">At the top of the class, define your <code>WorkManager</code>:<pre class="source code">
private val workManager = WorkManager.getInstance(this)</pre></li>
				<li>Add a chained <code>enqueue</code> request right below the code you just added, still within the <code>onCreate</code> function:<pre class="source code">
val catSuitUpRequest = ...
<strong class="bold">workManager.beginWith(catStretchingRequest)</strong>
    <strong class="bold">.then(catFurGroomingRequest)</strong>
    <strong class="bold">.then(catLitterBoxSittingRequest)</strong>
    <strong class="bold">.then(catSuitUpRequest)</strong>
    <strong class="bold">.enqueue()</strong></pre></li>
			</ol>
			<p>Your <code>WorkRequests</code> are now enqueued to be executed in sequence when their constraints are met and the <code>WorkManager</code> class is ready to execute them.</p>
			<ol>
				<li value="16">Define a function to show a toast with a provided message. It should look like this:<pre class="source code">
private fun showResult(message: String) {
    Toast.makeText(this, message, LENGTH_SHORT).show()
}</pre></li>
				<li>To track<a id="_idIndexMarker697"/> the progress of <a id="_idIndexMarker698"/>the enqueued <code>WorkRequest</code> instances, add the following after the <code>enqueue</code> call:<pre class="source code">
workManager.beginWith(catStretchingRequest)
    ...
    .enqueue()
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    catStretchingRequest.id).observe(this) { info -&gt;</strong>
<strong class="bold">        if (info.state.isFinished) {</strong>
    <strong class="bold">        showResult("Agent done stretching")</strong>
  <strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    catFurGroomingRequest.id).observe(this) { info -&gt;</strong>
  <strong class="bold">      if (info.state.isFinished) {</strong>
    <strong class="bold">        showResult("Agent done grooming its fur")</strong>
  <strong class="bold">      }</strong>
<strong class="bold">    }</strong>
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    </strong><strong class="bold">catLitterBoxSittingRequest.id).observe(this) { info -&gt;</strong>
        <strong class="bold">if (info.state.isFinished) {</strong>
            <strong class="bold">showResult("Agent done sitting in litter box")</strong>
        <strong class="bold">}</strong>
    <strong class="bold">}</strong>
<strong class="bold">workManager.getWorkInfoByIdLiveData(</strong>
<strong class="bold">    catSuitUpRequest.id).observe(this) { info -&gt;</strong>
<strong class="bold">         if (info.state.isFinished) {</strong>
<strong class="bold">    </strong>  <strong class="bold">    </strong>  <strong class="bold"> </strong><strong class="bold">showResult("Agent done suiting up. Ready to go!")</strong>
<strong class="bold">         }</strong>
<strong class="bold">}</strong></pre></li>
			</ol>
			<p>The preceding<a id="_idIndexMarker699"/> code observes<a id="_idIndexMarker700"/> a <code>WorkInfo</code> observable provided by the <code>WorkManager</code> class for each <code>WorkRequest</code>. When each request is finished, a toast is shown with a relevan<a id="_idTextAnchor483"/>t message.</p>
			<ol>
				<li value="18">Run your app:</li>
			</ol>
			<div><div><img src="img/B19411_08_01.jpg" alt="Figure 8.1 – Toasts showing in order"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Toasts showing in order</p>
			<p>You should <a id="_idIndexMarker701"/>now see a simple <code>Hello World!</code> screen. However, if you wait a few seconds, you will start seeing toasts<a id="_idIndexMarker702"/> informing you of the progress of your SCA preparing to deploy to the field. You will notice that the toasts follow the order in which you enqueued the requests and execute <a id="_idTextAnchor484"/><a id="_idTextAnchor485"/>their delays sequentially.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor486"/>Background operations noticeable to the user – using a Foreground Service</h1>
			<p>With our SCA all suited up, they<a id="_idIndexMarker703"/> are now ready to get to the assigned destination. To track the SCA, we will periodically poll the location of the SCA using a Foreground Service and update the sticky notification (a notification that cannot be dismissed by the user) attached to that service with the new location.</p>
			<p class="callout heading">Note</p>
			<p class="callout">For the sake of simplicity, we will fake the location. Following what you learned in <a href="B19411_07.xhtml#_idTextAnchor421"><em class="italic">Chapter 7</em></a>, <em class="italic">Android Permissions and Google Maps</em>, you could later replace this implementation with a real one that uses a map.</p>
			<p>Foreground services are another way of performing background operations. The name may be a bit counterintuitive. It is meant to differentiate these services from the base Android (background) services. The former are tied to a notification, while the latter run in the background with no user-facing representation built in.</p>
			<p>Another important difference between foreground services and background services is that the latter are candidates for termination when the system is low on memory, while the former are not.</p>
			<p>As of Android 9 (Pie, or API level 28), we have to request the <code>FOREGROUND_SERVICE</code> permission to use foreground services. Since it is a normal permission, it will be granted to our app automatically.</p>
			<p>Before we can launch a foreground service, we must first create one. A foreground service is a subclass of the Android abstract <code>Service</code> class. If we do not intend to bind to the service, and in our example, we do not, we can simply override <code>onBind(Intent)</code> so that it returns <code>null</code>.</p>
			<p>As a side note, binding is one of the ways for interested clients to communicate with a service. We will not focus on this approach in this book, as there are other, easier approaches, as you will discover.</p>
			<p>A Foreground Service must be tied to a notification. On Android 8 (Oreo, or API level 26) and above, if a Foreground Service is not tied to one within the <strong class="bold">Application Not Responding</strong> (<strong class="bold">ANR</strong>) time <a id="_idIndexMarker704"/>window (around five seconds), the service is stopped, and the app is declared as not responding.</p>
			<p>Because of<a id="_idIndexMarker705"/> this requirement, it is best if we tie the service to a notification as soon as we can. The best place to do that would be in the <code>onCreate()</code> function of the service. A quick implementation would look something like this:</p>
			<pre class="source code">
private fun onCreate() {
  val channelId = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    val newChannelId = "ChannelId"
    val channelName = "My Background Service"
    val channel = NotificationChannel(newChannelId,
      channelName, NotificationManager.IMPORTANCE_DEFAULT)
    val service = getSystemService(
      Context.NOTIFICATION_SERVICE) as NotificationManager
    service.createNotificationChannel(channel)
    newChannelId
  } else { "" }
    val flag = if (Build.VERSION.SDK_INT &gt;=
      Build.VERSION_CODES.S) FLAG_IMMUTABLE else 0
  val pendingIntent = Intent(this,
    MainActivity::class.java).let { notificationIntent -&gt;
      PendingIntent.getActivity(this, 0,
        notificationIntent, flag)
    }
  val notification =
    NotificationCompat.Builder(this, channelId)
      .setContentTitle("Content title")
      .setContentText("Content text")
      .setSmallIcon(R.drawable.notification_icon)
      .setContentIntent(pendingIntent)
      .setTicker("Ticker message").build()
  startForeground(NOTIFICATION_ID, notificationBuilder.build())
}</pre>
			<p>Let’s break this down.</p>
			<p>We start by <a id="_idIndexMarker706"/>defining the channel ID. This is only required for Android Oreo or above and is ignored in earlier versions of Android. In Android Oreo, Google introduced the concept of channels. Channels are used to group notifications and allow users to filter out unwanted notifications.</p>
			<p>Next, we define <code>pendingIntent</code>. This will be the <code>Intent</code> launched if the user taps on the notification. In this example, the main activity would be launched. It is constructed by wrapping an <code>Intent</code> activity launching in a <code>PendingIntent</code>. The request code is set to <code>0</code> because this example doesn’t expect a result, so the code will not be used.</p>
			<p>The flag is set to <code>0</code> for APIs older than S (31). Otherwise, it is set to the recommended <code>PendingIntent.FLAG_IMMUTABLE</code>, which means that additional arguments passed to the <code>Intent</code> on send will be ignored.</p>
			<p>With the channel ID and <code>pendingIntent</code>, we can construct our notification. We use <code>NotificationCompat</code>, which takes away some of the boilerplate around supporting older API levels. We pass in the context and the channel ID. We define the title, text, small icon, <code>Intent</code>, and ticker message and build the notification to complete the builder:</p>
			<pre class="source code">
val notification =
  NotificationCompat.Builder(this, channelId)
    .setContentTitle("Content title")
    .setContentText("Content text")
    .setSmallIcon(R.drawable.notification_icon)
    .setContentIntent(pendingIntent)
    .setTicker("Ticker message")
    .build()</pre>
			<p>To start a<a id="_idIndexMarker707"/> service in the foreground, attaching the notification to it, we call it the <code>startForeground(Int, Notification)</code> function, passing in a notification ID (any unique <code>int</code> value to identify this service, which must not be 0) and a notification, which must have its priority set to <code>PRIORITY_LOW</code> or higher. In our case, we have not specified the priority, which sets it to <code>PRIORITY_DEFAULT</code>:</p>
			<p>If launched, our service will now show a sticky notification. Clicking on the notification would launch our main activity.</p>
			<p>Currently, our service doesn’t perform any operations aside from showing a notification. To add some functionality to it, we need to override <code>onStartCommand(Intent?, Int, Int)</code>. This function gets called when the service is launched via an Intent.</p>
			<p>This also gives us the opportunity to read any extra data passed via that Intent. It also provides us with flags (which may be set to <code>START_FLAG_REDELIVERY</code> or <code>START_FLAG_RETRY</code>) and a unique request ID. We will get to reading the extra data later in this chapter. You don’t need to worry about the flags or the request ID in a simple implementation.</p>
			<p>It is important to note that <code>onStartCommand(Intent?, Int, Int)</code> gets called on the UI thread, so don’t perform any long-running operations here, or your app will freeze, giving the user a poor experience. Instead, we could create a new handler using a new <code>HandlerThread</code> (a thread with a looper, a class used to run a message loop for a thread) and post our work to it.</p>
			<p>This means we’ll have an infinite loop running, waiting for us to post to it via a <code>Handler</code>. When we receive a <code>start</code> command, we can post the work we want to be done to it. That work will then be executed on that thread.</p>
			<p>When our long-running work is done, there are a few things we may want to happen. First, we may want to inform whoever is interested (our main activity, if it is running, for example) that we are done. Then, we probably want to stop running in the foreground. Lastly, if we do not expect to require the service again, we could stop it.</p>
			<p>An app has several ways to communicate with a service: binding, using broadcast receivers, using a bus architecture, or using a result receiver, to name just a few. For our example, we will use Google’s <code>LiveData</code>.</p>
			<p>Before we proceed, it is worth touching on broadcast receivers. Broadcast receivers allow our app to send and receive messages using a pattern much like the <em class="italic">publish-subscribe </em><em class="italic">design pattern</em>.</p>
			<p>The system broadcasts events such as the device booting up or charging having started. Our services can broadcast status updates as well. For example, they can broadcast a long calculation result on completion. If our app registers to receive a certain message, the system will inform it when that message is broadcast.</p>
			<p>This used to be <a id="_idIndexMarker708"/>a common way to communicate with services, but the <code>LocalBroadcastManager</code> class is now deprecated as it was an application-wide event bus that encouraged anti-patterns.</p>
			<p>Having said that, broadcast receivers are still useful for system-wide events. We first define a class overriding the <code>BroadcastReceiver</code> abstract class:</p>
			<pre class="source code">
class ToastBroadcastReceiver : BroadcastReceiver() {
  override fun onReceive(context: Context, intent: Intent) {
    StringBuilder().apply {
      append("Action: ${intent.action}\n")
      append(
        "URI:${intent.toUri(Intent.URI_INTENT_SCHEME)}\n")
      toString().let { eventText -&gt;
        Toast.makeText(context, eventText,
        Toast.LENGTH_LONG).show()
      }
    }
  }
}</pre>
			<p>When an event is received by <code>ToastBroadcastReceiver</code>, it will show a toast showing the action and URI of the event.</p>
			<p>We can register our receiver via the <code>Manifest.xml</code> file:</p>
			<pre class="source code">
&lt;receiver android:name=".ToastBroadcastReceiver"
android:exported="true"&gt;
  &lt;intent-filter&gt;
    &lt;action android:name=
      "android.intent.action.ACTION_POWER_CONNECTED" /&gt;
  &lt;/intent-filter&gt;
&lt;/receiver&gt;</pre>
			<p>Specifying <code>android:exported="true"</code> tells the system that this receiver can receive <a id="_idIndexMarker709"/>messages from outside of the application. The action defines the message we are interested in. We can specify multiple actions. In this example, we listen for when the device starts charging. Keep in mind that setting this value to <code>true</code> allows other apps, including malicious ones, to activate this receiver.</p>
			<p>We can al<a id="_idTextAnchor487"/>so register for messages in code:</p>
			<pre class="source code">
val filter = IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION).apply { addAction(Intent.ACTION_POWER_CONNECTED) }
registerReceiver(ToastBroadcastReceiver(), filter)</pre>
			<p>Adding this code to an activity or in our custom application class would register a new instance of our receiver as well. This receiver will live so long as the context (activity or application) is valid. So, correspondingly, if the activity or application is destroyed, our receiver will be freed to be garbage collected.</p>
			<p>Now back to our implementation. <code>LiveData</code> already comes bundled with <code>androidx.appcompat</code>, saving us the trouble of having to manually include it in our project. We can define a <code>LiveData</code> instance in the companion object of the service, like so:</p>
			<pre class="source code">
companion object {
  <strong class="bold">private val mutableWorkCompletion = MutableLiveData&lt;String&gt;()</strong>
<strong class="bold">  val workCompletion: LiveData&lt;String&gt; = mutableWorkCompletion</strong>
}</pre>
			<p>Note that we hide the <code>MutableLiveData</code> instance behind a <code>LiveData</code> interface. This is so that consumers can only read the data. We can now use the <code>mutableWorkCompletion</code> instance to report completion by assigning it a value. However, we must remember that values can only be assigned to the <code>LiveData</code> instances on the main thread.</p>
			<p>This means once our work is done, we must switch back to the main thread. We can easily achieve that—all we need is a new handler with the main <code>Looper</code> (obtained by calling <code>Looper.getMainLooper()</code>), to which we can post our update.</p>
			<p>Now that our service is ready to do some work, we can finally launch it. Before we do, we must make sure we added the service to our <code>AndroidManifest.xml</code> file within the <code>&lt;application&gt;&lt;/application&gt;</code> block, as shown in the following code:</p>
			<pre class="source code">
&lt;application ...&gt;
    <strong class="bold">&lt;service android:name="ForegroundService" /&gt;</strong>
&lt;/application&gt;</pre>
			<p>To launch the service we just added to our manifest, we create <code>Intent</code>, passing in any extra data required, as shown in the following code:</p>
			<pre class="source code">
val serviceIntent = Intent(this, ForegroundService::class.java).apply {
    putExtra("ExtraData", "Extra value")
}</pre>
			<p>Then, we<a id="_idIndexMarker710"/> call <code>ContextCompat.startForegroundService(Context, Intent)</code> to fire <a id="_idTextAnchor488"/><a id="_idTextAnchor489"/>off <code>Intent</code> and launch the service.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor490"/>Exercise 8.02 – tracking your SCA’s work with a Foreground Service</h2>
			<p>In the first exercise, you <a id="_idIndexMarker711"/>tracked the SCA as it<a id="_idIndexMarker712"/> was preparing to head out using the <code>WorkManager</code> class and multiple Worker instances showing toasts. In this exercise, you will track the SCA as it deploys to the field and moves toward the assigned target by showing a sticky notification counting down the time to arrival at the destination.</p>
			<p>This notification will be driven by a Foreground Service, which will present and continuously update it. Clicking the notification at any time will launch your main activity if it’s not already running and will always bring it to the foreground:</p>
			<ol>
				<li>Start by adding the <code>WorkManager</code> dependency to your app’s <code>build.gradle</code> file:<pre class="source code">
implementation "androidx.work:work-runtime:2.8.0"</pre></li>
				<li>Create a new class called <code>RouteTrackingService</code>, extending the abstract <code>Service</code> class:<pre class="source code">
class RouteTrackingService : Service() {
  override fun onBind(intent: Intent): IBinder? = null
}</pre></li>
			</ol>
			<p>You will not rely on binding in this exercise, so it is safe to simply return <code>null</code> in the <code>onBind(Intent)</code> implementation.</p>
			<ol>
				<li value="3">In the newly created service, define some constants that you will later need, as well as the <code>LiveData</code> instance used to observe progress:<pre class="source code">
companion object {
    const val NOTIFICATION_ID = 0xCA7
    const val EXTRA_SECRET_CAT_AGENT_ID = "scaId"
    private val mutableTrackingCompletion =
        MutableLiveData&lt;String&gt;()
    val trackingCompletion: LiveData&lt;String&gt; =
        mutableTrackingCompletion
}</pre></li>
			</ol>
			<p><code>NOTIFICATION_ID</code> has to be a unique identifier for the notification owned by this service and must not be <code>0</code>. Now, <code>EXTRA_SECRET_CAT_AGENT_ID</code> is the constant you will use to pass data to the service. <code>mutableTrackingCompletion</code> is private and is used to allow you to post completion updates internally via <code>LiveData</code> without exposing the mutability outside of the service. <code>trackingCompletion</code> is then used to expose the <code>LiveData</code> instance for observation in an immutable fashion.</p>
			<ol>
				<li value="4">Add a function to <a id="_idIndexMarker713"/>your <code>RouteTrackingService</code> class to<a id="_idIndexMarker714"/> provide <code>PendingIntent</code> to your sticky notification:<pre class="source code">
private fun getPendingIntent(): PendingIntent {
  val flag = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_
    CODES.S) FLAG_IMMUTABLE else 0
  return PendingIntent.getActivity(this, 0, Intent(this, 
    MainActivity::class.java), flag)</pre></li>
			</ol>
			<p>This will launch <code>MainActivity</code> whenever the user clicks on <code>Notification</code>. You call <code>PendingIntent.getActivity()</code>, passing a context, no request code (<code>0</code>), <code>Intent</code> that will launch <code>MainActivity</code>, and the <code>FLAG_IMMUTABLE</code> flag if available, otherwise no flags (<code>0</code>) to it. You get back a <code>PendingIntent</code>, which will launch that activity.</p>
			<ol>
				<li value="5">Add another function to create <code>NotificationChannel</code> on devices running Android Oreo or newer, and return a channel ID:<pre class="source code">
private fun createNotificationChannel(): String =
  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {
    val newChannelId = "CatDispatch"
    val channelName = "Cat Dispatch Tracking"
    val channel = NotificationChannel(
      newChannelId, channelName,
      NotificationManager.IMPORTANCE_DEFAULT
    )
    val service = requireNotNull(
      ContextCompat.getSystemService(this,
        NotificationManager::class.java)
    )
    service.createNotificationChannel(channel)
    newChannelId
  } else { "" }</pre></li>
			</ol>
			<p>You start by checking the Android version. You only need to create a channel if it’s Android O or later. Otherwise, you can return an empty string. For Android O, you define the channel ID. This needs to be unique for a package. Next, you define a channel name that will be visible to the user.</p>
			<p>This <a id="_idIndexMarker715"/>can (and should) be localized. We skipped that<a id="_idIndexMarker716"/> part for the sake of simplicity. A <code>NotificationChannel</code> instance is then created with the importance set to <code>IMPORTANCE_DEFAULT</code>. The importance dictates how disruptive the notifications posted to this channel are.</p>
			<p>Lastly, a channel is created using <code>Notification Service</code> with the data provided in the <code>NotificationChannel</code> instance. The function returns the channel ID so that it can be used to construct the <code>Notification</code>.</p>
			<ol>
				<li value="6">Create a function to provide you with <code>Notification.Builder</code>:<pre class="source code">
private fun getNotificationBuilder(pendingIntent:
PendingIntent, channelId: String) =
    NotificationCompat.Builder(this, channelId)
    .setContentTitle("Agent approaching destination")
    .setContentText("Agent dispatched")
    .setSmallIcon(R.drawable.ic_launcher_foreground)
    .setContentIntent(pendingIntent)
    .setTicker("Agent dispatched, tracking movement")
    .setOngoing(true)</pre></li>
			</ol>
			<p>This function takes the <code>pendingIntent</code> and <code>channelId</code> instances generated from the functions you created earlier and constructs a <code>NotificationCompat.Builder</code> class.</p>
			<p>The builder<a id="_idIndexMarker717"/> lets you define a title (the first row), text (the second row), a small icon (size differs based on the device) to use, the <code>Intent</code> to be triggered when the user clicks on <strong class="bold">Notification</strong>, and a <a id="_idIndexMarker718"/>ticker (used for accessibility; before Android Lollipop, this showed before the notification was presented).</p>
			<p>Setting the notification to ongoing prevents users from dismissing them. This also prevents Android from muting the notification due to frequent updates.</p>
			<p>You can set other properties, too. Explore the <code>NotificationCompat.Builder</code> class. In a real project, remember to use string resources from <code>strings.xml</code> rather than hardcoded strings.</p>
			<ol>
				<li value="7">Implement the following code to introduce a function to start the foreground service:<pre class="source code">
private fun startForegroundService():
NotificationCompat.Builder {
  val pendingIntent = getPendingIntent()
  val channelId = if (Build.VERSION.SDK_INT &gt;=
    Build.VERSION_CODES.O) {
      createNotificationChannel()
  } else { "" }
  val notificationBuilder = getNotificationBuilder(
    pendingIntent, channelId)
  startForeground(NOTIFICATION_ID, notificationBuilder.build())
  return notificationBuilder
}</pre></li>
			</ol>
			<p>You <a id="_idIndexMarker719"/>first get <code>PendingIntent</code> using <a id="_idIndexMarker720"/>the <code>getPendingIntent</code> function you introduced earlier. Then, depending on the API level of the device, you create a notification channel and get its ID or set an empty ID.</p>
			<p>You pass <code>pendingIntent</code> and <code>channelId</code> to the function that constructs a <code>NotificationCompat.Builder</code> and start the service as a Foreground Service, providing it with <code>NOTIFICATION_ID</code> and a notification built using the builder. The function returns <code>NotificationCompat.Builder</code>, to be used later to update the notification.</p>
			<ol>
				<li value="8">Define two fields in your service—one to hold a reusable <code>NotificationCompat.Builder</code> class, and another to hold a reference to <code>Handler</code>, which you will later use to post work in the background:<pre class="source code">
private lateinit var notificationBuilder:
NotificationCompat.Builder
private lateinit var serviceHandler: Handler</pre></li>
				<li>Next, override <code>onCreate()</code> to start the service as a foreground service and keep a reference of the <code>Notification.Builder</code>, and create <code>serviceHandler</code>:<pre class="source code">
override fun onCreate() {
  super.onCreate()
  notificationBuilder = startForegroundService()
  val handlerThread =
    HandlerThread("RouteTracking").apply { start() }
  serviceHandler = Handler(handlerThread.looper)
}</pre></li>
			</ol>
			<p>Note<a id="_idIndexMarker721"/> that to create the <code>Handler</code> instance, you<a id="_idIndexMarker722"/> must first initialize and start <code>HandlerThread</code>.</p>
			<ol>
				<li value="10">Define a call that tracks your deployed SCA as it approaches its designated destination:<pre class="source code">
private fun trackToDestination(notificationBuilder: NotificationCompat.Builder) {
  val notificationManager = getSystemService(NOTIFICATION_
    SERVICE) as NotificationManager
  for (i in 10 downTo 0) {
    Thread.sleep(1000L)
    notificationBuilder.setContentText(
      "$i seconds to destination").setSilent(true)
    notificationManager.notify(NOTIFICATION_ID,
      notificationBuilder.build())
  }
}</pre></li>
			</ol>
			<p>This will first obtain a reference to the <code>NotificationManager</code>. Then, it will count down from <code>10</code> to <code>0</code>, sleeping for 1 second between updates and then updating the notification with the remaining time. Note we set the notification to be silent. This avoids the notification playing a sound every second.</p>
			<ol>
				<li value="11">Add a function to notify observers of completion on the main thread:<pre class="source code">
private fun notifyCompletion(agentId: String) {
    Handler(Looper.getMainLooper()).post {
        mutableTrackingCompletion.value = agentId
    }
}</pre></li>
			</ol>
			<p>By <a id="_idIndexMarker723"/>posting on a handler using the main <code>Looper</code>, you<a id="_idIndexMarker724"/> make sure that updates occur on the main (UI) app thread. When setting the value to the agent ID, you are notifying all observers that that agent ID has reached its destination.</p>
			<ol>
				<li value="12">Override <code>onStartCommand(Intent?, Int, Int)</code> like so:<pre class="source code">
override fun onStartCommand(intent: Intent?, flags:
Int, startId: Int): Int {
  val returnValue = super.onStartCommand(intent,
    flags, startId)
  val agentId = intent?.getStringExtra(EXTRA_SECRET_CAT_
    AGENT_ID)
    ?: throw IllegalStateException("Agent ID must be 
    provided")
  serviceHandler.post {
    trackToDestination(notificationBuilder)
    notifyCompletion(agentId)
    stopForeground(true)
    stopSelf()
  }
  return returnValue
}</pre></li>
			</ol>
			<p>You first <a id="_idIndexMarker725"/>delegate the call to <code>super</code>, which internally<a id="_idIndexMarker726"/> calls <code>onStart()</code> and returns a backward-compatible state you could return. You store this returned value. Next, you obtain the SCA ID from the extras passed via the <code>Intent</code>. This service will not work without an agent ID, so you throw an exception if one is not provided.</p>
			<p>Next, you switch to the background thread defined in <code>onCreate</code> to track the agent to its destination in a blocking way. When tracking is done, you notify observers that the task is complete, stop the foreground service (removing the notification by passing <code>true</code>), and stop the service itself, as you don’t expect to require it again soon. You then return the earlier stored return value from <code>super</code>.</p>
			<ol>
				<li value="13">Update your <code>AndroidManifest.xml</code> file to request the necessary permissions and introduce the service:<pre class="source code">
&lt;manifest ...&gt;
  <strong class="bold">&lt;uses-permission android:name="android.permission.FOREGROUND_SERVICE" /&gt;</strong>
<strong class="bold">  &lt;uses-permission android:name="android.permission.POST_NOTIFICATIONS" /&gt;</strong>
  &lt;application ...&gt;
    <strong class="bold">&lt;service</strong>
      <strong class="bold">android:name=".RouteTrackingService"</strong>
      <strong class="bold">android:enabled="true"</strong>
      <strong class="bold">android:exported="true" /&gt;</strong>
    &lt;activity ...&gt;</pre></li>
			</ol>
			<p>First, we <a id="_idIndexMarker727"/>declare that our app requires<a id="_idIndexMarker728"/> the <code>FOREGROUND_SERVICE</code> permission. Unless we do so, the system will block our app from using foreground services. We also request the <code>POST_NOTIFICATIONS</code> permission, without which we cannot present notifications on SDK 33+. Next, we declare the service. Setting <code>android:enabled="true"</code> tells the system it can instantiate the service.</p>
			<p>The default is <code>"true"</code>, so this is optional. Defining the service with <code>android:exported="true"</code> tells the system that other applications can start the service. In our case, we don’t need this extra functionality, but we have added it just so that you are aware of this capability.</p>
			<ol>
				<li value="14">Back to your <code>MainActivity</code>. Introduce a function to launch <code>RouteTrackingService</code>:<pre class="source code">
private fun launchTrackingService() {
  RouteTrackingService.trackingCompletion.observe(
    this) { agentId -&gt;
        showResult("Agent $agentId arrived!")
    }
  val serviceIntent = Intent(this,
    RouteTrackingService::class.java).apply {
      putExtra(EXTRA_SECRET_CAT_AGENT_ID, "007")
    }
  ContextCompat.startForegroundService(this, 
  serviceIntent)
}</pre></li>
			</ol>
			<p>This function first observes the <code>trackingCompletion</code> <code>LiveData</code> for completion updates, showing a result on completion. Then, it defines an <code>Intent</code> for launching the service, setting the SCA ID as an extra parameter for that <code>Intent</code>. It then launches the service as a foreground service using <code>ContextCompat</code>, which hides away compatibility-related logic for you.</p>
			<ol>
				<li value="15">Now, extract the logic from <code>onCreate()</code> (everything that comes after the <code>setContentView</code> call) to a private function named <code>dispatchCat</code>.</li>
				<li>Update <code>dispatchCat</code> to start tracking the <a id="_idIndexMarker729"/>SCA as soon as it is suited up and ready to<a id="_idIndexMarker730"/> go:<pre class="source code">
workManager.getWorkInfoByIdLiveData(
  catSuitUpRequest.id).observe(this) { info -&gt;
  if (info.state.isFinished) {
    showResult("Agent done suiting up. Ready to go!")
    <strong class="bold">launchTrackingService()</strong>
  }
}</pre></li>
				<li>Create a new private function called <code>ensurePermissionGrantedAndDispatchCat</code>. In this function, make sure you have the <code>POST_NOTIFICATIONS</code> permission. Request it if you don’t. Refer to <a href="B19411_07.xhtml#_idTextAnchor421"><em class="italic">Chapter 7</em></a>, <em class="italic">Android Permissions and Google Maps</em>, for the implementation details. If or when you h<a id="_idTextAnchor491"/>ave the permission, call <code>dispatchCat</code>.</li>
				<li>Launch the app:</li>
			</ol>
			<div><div><img src="img/B19411_08_02.jpg" alt="Figure 8.2 – The notification counting down"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The notification counting down</p>
			<p>After the <a id="_idIndexMarker731"/>notifications informing you of the SCA’s preparation<a id="_idIndexMarker732"/> steps, you should see a notification in your status bar. That notification should then count down from 10 to 0, disappear, and be replaced by a toast informing you that the agent arrived at its destination. Seeing that last toast tells you that you managed to communicate the SCA ID to the service as well as get it back on completion of the background task.</p>
			<p>With all the knowledge gained fr<a id="_idTextAnchor492"/><a id="_idTextAnchor493"/>om this chapter, let’s complete the following activity.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor494"/>Activity 8.01 – reminder to drink water</h2>
			<p>The average human <a id="_idIndexMarker733"/>loses about 2,500 <strong class="bold">milliliters</strong> (<strong class="bold">ml</strong>) of water per day. To stay healthy, we need to consume as much water as we lose. However, due to the busy nature of modern life, a lot of us forget to stay hydrated regularly.</p>
			<p class="callout heading">Note</p>
			<p class="callout">See <a href="https://packt.link/90nbQ">https://packt.link/90nbQ</a> for more information on this.</p>
			<p>Suppose you wanted to develop an app that keeps track of your water loss (statistically) and gives you a constant update on your fluid balance. Starting from a balanced state, the app would gradually decrease the user’s tracked water level. The user could tell the app when they drank a glass of water, and it would update the water level accordingly.</p>
			<p>The continuous updating of the water level will leverage your knowledge of running a background task, and you will also utilize your knowledge of communicating with a service to update a balance in response to user interaction.</p>
			<p>The following steps will <a id="_idIndexMarker734"/>help you complete the activity:</p>
			<ol>
				<li>Create an empty activity project and name your app <code>My </code><code>Water Tracker</code>.</li>
				<li>Add the foreground service and post notifications permissions to your <code>AndriodManifest.xml</code> file.</li>
				<li>Create a new service.</li>
				<li>Define a variable in your service to track the water level.</li>
				<li>Define constants for a notification ID and for an extra <code>Intent</code> data key.</li>
				<li>Set up the creation of the notification from the service.</li>
				<li>Add functions to request the notification permissions (if required), start the Foreground Service and update the water level.</li>
				<li>Set the water level to decrease by 0.144 ml every 5 seconds.</li>
				<li>Handle the addition of fluids from outside the service.</li>
				<li>Make sure the service cleans up callbacks and messages when destroyed.</li>
				<li>Register the service in the <code>Manifest.xml</code> file.</li>
				<li>Start the service from <code>MainActivity</code> when the activity is created, after the notification permission is granted, if needed.</li>
				<li>Add a button to the main activity layout with a <strong class="bold">Drank a Glass of </strong><strong class="bold">Water</strong> label.</li>
				<li>When the user clicks the button, notify the service that it needs to increment the water level <a id="_idIndexMarker735"/>by 250 ml.</li>
			</ol>
			<p class="callout heading">Note</p>
			<p class="callout">The solution t<a id="_idTextAnchor495"/><a id="_idTextAnchor496"/>o this activity can be found at <a href="https://packt.link/By7eE">https://packt.link/By7eE</a>.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor497"/>Summary</h1>
			<p>In this chapter, we learned how to execute long-running background tasks using <code>WorkManager</code> and foreground services. We discussed how to communicate progress to the user, and how to get the user back into an app once a task is finished executing. All the topics covered in this chapter are quite broad, and you could explore communicating with services, building notifications, and using the <code>WorkManager</code> class further.</p>
			<p>For most common scenarios, you now have the tools you need. Common use cases include background downloads, the background cleaning up of cached assets, playing media while the app is not running in the foreground, and, combined with the knowledge we gained from <a href="B19411_07.xhtml#_idTextAnchor421"><em class="italic">Chapter 7</em></a>, <em class="italic">Android Permissions and Google Maps</em>, tracking the user’s location over time.</p>
			<p>In the next chapter, we will look into making our apps more robust and maintainable by writing unit and integration tests. This is particularly helpful when the code you write runs in the background, a<a id="_idTextAnchor498"/>nd it is not immediately evident when something goes wrong.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>