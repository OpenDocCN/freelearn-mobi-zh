["```swift\nclass ClassName {\n   property1\n   property2 \n   property3 \n   method1() { \n      code\n   }\n   method2() {\n      code\n   }\n} \n```", "```swift\nclass Animal {\n   var name: String = \"\" \n   var sound: String = \"\"\n   var numberOfLegs: Int = 0\n   var breathesOxygen: Bool = true\n   func makeSound() {\n      print(self.sound)\n   }\n}\n```", "```swift\n    let cat = Animal()\n    print(cat.name)\n    print(cat.sound) \n    print(cat.numberOfLegs) \n    print(cat.breathesOxygen)\n    cat.makeSound()\n    ```", "```swift\n    let cat = Animal()\n    makeSound() method are printed to the Debug area. Note that here you create the instance first, and then assign values to that instance. It is also possible to assign the values when the instance is being created, and you do this by implementing an initializer in your class declaration. \n    ```", "```swift\n    class Animal {\n       var name: String \n       var sound: String\n       var numberOfLegs: Int\n       var breathesOxygen: Bool\n    init keyword and has a list of parameters that will be used to set the property values. Note that the self keyword distinguishes the property names from the parameters. For example, self.name refers to the property and name refers to the parameter. At the end of the initialization process, every property in the class should have a valid value.\n    ```", "```swift\n       func makeSound() {\n          print(self.sound)\n       }\n    }\n    let cat = Animal(name: \"Cat\", sound: \"Mew\", \n    numberOfLegs: 4, breathesOxygen: true)\n    print(cat.name)\n    ```", "```swift\n    class Mammal: Animal {\n       let hasFurOrHair: Bool = true\n    }\n    ```", "```swift\n    let cat = cat is now an instance of the Mammal class instead of the Animal class. As you can see, the results displayed in the Debug area are the same as before, and there are no errors. The value for hasFurOrHair has not been displayed though. Let's fix that.\n    ```", "```swift\n    print(cat.hasFurOrHair)\n    ```", "```swift\n    class Animal {\n       var name: String \n       var sound: String\n       var numberOfLegs: Int\n       var breathesOxygen: Bool = true\n       init(name: String, sound: String, numberOfLegs:\n       Int, breathesOxygen: Bool) {\n          self.name = name \n          self.sound = sound\n          self.numberOfLegs = numberOfLegs \n          self.breathesOxygen = breathesOxygen\n       }\n       func makeSound() {\n          print(self.sound)\n       }\n       func description() -> String {\n    return \"name: \\(self.name) \n          sound: \\(self.sound)\n          numberOfLegs: \\(self.numberOfLegs)\n          breathesOxygen: \\(self.breathesOxygen)\"\n       }\n    }\n    ```", "```swift\n    let cat = Mammal(name: \"Cat\", sound: \"Mew\", \n    numberOfLegs: 4, breathesOxygen: true)\n    description() method is not implemented in the Mammal class, it is implemented in the Animal class. This means it will be inherited by the Mammal class, and the instance properties will be printed to the Debug area. Note that the value for the hasFurOrHair property is missing, and you can't put it in the description() method because the hasFurOrHair property does not exist for the Animal class.\n    ```", "```swift\n    Mammal: Animal {\n       let hasFurOrHair: Bool = true\n    override keyword is used here to specify that the description() method implemented here is to be used in place of the superclass implementation. The super keyword is used to call the superclass implementation of description(). The value in hasFurOrHair is then added to the string returned by super.description(). You will see the following in the Debug area:\n\n    ```", "```swift\n\n    ```", "```swift\nstruct StructName { \n   property1 \n   property2 \n   property3\n   method1() {\n      code\n   }\n   method2(){\n      code\n   }\n}\n```", "```swift\nstruct Reptile {\n   var name: String \n   var sound: String\n   var numberOfLegs: Int\n   var breathesOxygen: Bool\n   let hasFurOrHair: Bool = false \n   func makeSound() {\n      print(sound)\n   }\n   func description() -> String {\n      return \"Structure: Reptile name: \\(self.name) \n      sound: \\(self.sound) \n      numberOfLegs: \\(self.numberOfLegs)\n      breathesOxygen: \\(self.breathesOxygen) \n      hasFurOrHair: \\(self.hasFurOrHair)\"\n   }\n}\n```", "```swift\nvar snake = Reptile(name: \"Snake\", sound: \"Hiss\", \nnumberOfLegs: 0, breathesOxygen: true)\nprint(snake.description())\nsnake.makeSound()\n```", "```swift\nStructure: Reptile name: Snake sound: Hiss numberOfLegs: 0 breathesOxygen: true hasFurOrHair: false\nHiss\n```", "```swift\n    struct SampleValueType {\n       var sampleProperty = 10\n    }\n    var a = SampleValueType()\n    var b = a \n    b.sampleProperty = 20 \n    print(a.sampleProperty) \n    print(b.sampleProperty)\n    ```", "```swift\n    class SampleReferenceType {\n       var sampleProperty = 10\n    }\n    var c = SampleReferenceType()\n    var d = c \n    c.sampleProperty = 20 \n    print(c.sampleProperty) \n    print(d.sampleProperty)\n    ```", "```swift\nvar trafficLightColor = 2\n```", "```swift\nenum EnumName {\n   case value1 \n   case value2 \n   case value3\n}\n```", "```swift\n    enum TrafficLightColor {\n       case red \n       case yellow \n       case green\n    }\n    var trafficLightColor = TrafficLightColor.red\n    ```", "```swift\n    enum TrafficLightColor {\n       case red \n       case yellow \n       case green\n       func description() -> String {\n          switch self {\n          case .red:\n    return \"red\" \n          case .yellow:\n    return \"yellow\" \n          default:\n             return \"green\"\n          }\n       }\n    }\n    var trafficLightColor = TrafficLightColor.red\n    print(trafficLightColor.description())\n    ```"]