["```kt\n@Composable\nfun CameraPreview(cameraController:\nLifecycleCameraController, modifier: Modifier = Modifier) {\n    AndroidView(\n        factory = { context ->\n            PreviewView(context).apply {\n                implementationMode =\n                  PreviewView.ImplementationMode.COMPATIBLE\n            }\n        },\n        modifier = modifier,\n        update = { previewView ->\n            previewView.controller = cameraController\n        }\n    )\n}\n```", "```kt\n@Composable\nfun CaptureVideoButton(\n    cameraController: LifecycleCameraController,\n    onRecordingFinished: (String) -> Unit,\n) {\n    val context = LocalContext.current\n    val recording = remember {\n        mutableStateOf<Recording?>(null) }\n    IconButton(\n        onClick = {\n            cameraController.setEnabledUseCases(\n                LifecycleCameraController.VIDEO_CAPTURE)\n            if (recording.value == null) {\n                recording.value =\n                    startRecording(cameraController,\n                        context, onRecordingFinished)\n            } else {\n                stopRecording(recording.value)\n                recording.value = null\n            }\n        },\n        modifier = Modifier\n            .size(60.dp)\n            .padding(8.dp),\n    ) {\n        Icon(\n            painter = if (recording.value == null)\n                painterResource(id =\n                    R.drawable.ic_videocam) else\n                        painterResource(id =\n                            R.drawable.ic_stop),\n            contentDescription = \"Capture video\",\n            tint = MaterialTheme.colorScheme.onPrimary\n        )\n    }\n}\n```", "```kt\n@SuppressLint(\"MissingPermission\")\nprivate fun startRecording(\n    cameraController: LifecycleCameraController,\n    context: Context,\n    onRecordingFinished: (String) -> Unit\n): Recording {\n    val videoFile = File(context.filesDir,\n        \"video_${System.currentTimeMillis()}.mp4\")\n    val outputOptions =\n        FileOutputOptions.Builder(videoFile).build()\n    val audioConfig = AudioConfig.create(true)\n    val executor = Executors.newSingleThreadExecutor()\n    return cameraController.startRecording(\n        outputOptions,\n        audioConfig,\n        executor\n    ) { recordEvent ->\n        when (recordEvent) {\n            is VideoRecordEvent.Finalize -> {\n                if (recordEvent.hasError()) {\n                    Log.e(\"CaptureVideoButton\",\n                        \"Video recording error:\n                            ${recordEvent.error}\")\n                } else {\n                    onRecordingFinished(\n                        videoFile.absolutePath)\n                }\n            }\n        }\n    }\n}\n```", "```kt\nfun stopRecording(recording: Recording?) {\n    recording?.stop()\n}\n```", "```kt\n@Composable\nprivate fun CaptureModeContent(\n    cameraController: LifecycleCameraController,\n    onImageCaptured: (Bitmap) -> Any,\n    onVideoCaptured: (String) -> Any\n) {\n    Box(modifier = Modifier.fillMaxSize()) {\n        CameraPermissionRequester {\n            Box(\n                contentAlignment = Alignment.BottomCenter,\n                modifier = Modifier.fillMaxSize()\n            ) {\n                CameraPreview(...)\n                Row {\n                    CaptureButton(...)\n                    CaptureVideoButton(\n                       cameraController =\n                           cameraController,\n                       onRecordingFinished = { videoPath ->\n                           onVideoCaptured(videoPath)\n                       }\n                    )\n                }\n            }\n        }\n    }\n}\n```", "```kt\n[versions]\n...\nmobileffmpeg = \"4.4\"\n[libraries]\n...\nmobileffmpeg = { group = \"com.arthenica\", name = \"mobile-ffmpeg-full\", version.ref = \"mobileffmpeg\" }\n```", "```kt\ndependencies {\n    ....\n    implementation(libs.mobileffmpeg)\n}\n```", "```kt\nFFmpeg.execute(\"[global_options] {[input_file_options] [flags] input_url} ... {[output_file_options] output_url} ...\")\n```", "```kt\nFFmpeg.execute(\"-i input.mp4 output.avi\")\n```", "```kt\nffmpeg -i input.file -c:v [video_codec] -c:a [audio_codec] output.file\n```", "```kt\nffmpeg -i input.mp4 -c:v libx264 -c:a aac output.mp4\n```", "```kt\nffmpeg -i input.file -b:v [video_bitrate] -b:a [audio_bitrate] output.file\n```", "```kt\nffmpeg -i input.mp4 -b:v 1500k -b:a 128k output.mp4\n```", "```kt\nffmpeg -i input.file -s [width]x[height] output.file\n```", "```kt\nffmpeg -i input.mp4 -s 1920x1080 output.mp4\n```", "```kt\nffmpeg -i input.file -vf \"[filter1],[filter2]\" output.file\n```", "```kt\nffmpeg -i input.mp4 -vf \"crop=640:480:0:0, hue=h=60:s=1\" -c:a copy output.mp4\n```", "```kt\nffmpeg -i main_video.mp4 -i overlay.mp4 -filter_complex \"overlay=x:y\" output.mp4\n```", "```kt\nffmpeg -i video.mp4 -i logo.png -filter_complex \"overlay=1900:1060\" -codec:a copy output.mp4\n```", "```kt\nffmpeg -i main_video.mp4 -i logo.png -filter_complex \"overlay=x='t*100':y=50\" output.mp4\n```", "```kt\nffmpeg -i main_video.mp4 -i logo.png -filter_complex \"[1:v]fade=t=in:st=0:d=1,fade=t=out:st=3:d=1[logo];[0:v][logo]overlay=10:10\" output.mp4\n```", "```kt\nval command = \"-i input.mp4 -c:v libx264 output.mp4\"\nval returnCode = FFmpeg.execute(command)\n```", "```kt\nFFmpeg.executeAsync(command) { executionId, returnCode ->\n    when (returnCode) {\n        Config.RETURN_CODE_SUCCESS -> {\n            // Processing was successful\n        }\n        Config.RETURN_CODE_CANCEL -> {\n            // Command execution was cancelled\n        }\n        else -> {\n            // Command execution failed\n        }\n    }\n}\n```", "```kt\nFFmpeg.executeAsync(command, ExecuteCallback { executionId,\nreturnCode ->\n    // Handle execution result\n}, LogCallback { logMessage ->\n    // Handle log message\n}, StatisticsCallback { statistics ->\n    // Handle progress updates\n})\n```", "```kt\nclass AddCaptionToVideoUseCase() {\n    suspend fun addCaption(videoFile: File, captionText:\n    String): Result<File> = withContext(Dispatchers.IO) {\n        val outputFile = File(\n            videoFile.parent,\n                \"${videoFile.nameWithoutExtension}\n                    _captioned.mp4\")\n        val fontFilePath =\n            \"/system/fonts/Roboto-Regular.ttf\"\n        val ffmpegCommand = arrayOf(\n            \"-i\", videoFile.absolutePath,\n            \"-vf\", \"drawtext=fontfile=$fontFilePath:\n                text='$captionText':\n                    fontcolor=white:\n                        fontsize=24:x=(w-text_w)/2:\n                            y=(h-text_h)-10\",\n            \"-c:a\", \"aac\",\n            \"-b:a\", \"192k\",\n            outputFile.absolutePath\n        )\n        try {\n            val executionId =\n            FFmpeg.executeAsync(ffmpegCommand)\n            { _, returnCode ->\n                if (returnCode !=\n                Config.RETURN_CODE_SUCCESS) {\n                    Result.failure<AddCaptionToVideoError>(\n                        AddCaptionToVideoError)\n                }\n            }\n            // Optionally handle the executionId, e.g., for\n               cancellation\n            Result.success(outputFile)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\nobject AddCaptionToVideoError: Throwable(\"There was an\nerror adding the caption to the video\") {\n    private fun readResolve(): Any = AddCaptionToVideoError\n}\n```", "```kt\nval command = \"-i ${videoFile.absolutePath} -vf drawtext=text='$captionText':fontcolor=white:fontsize=24:x=(w-text_w)/2:y=(h-text_h)/2 -codec:a copy ${outputFile.absolutePath}\"\n```", "```kt\nclass StoryEditorViewModel(\n    private val saveCaptureUseCase: SaveCaptureUseCase,\n    private val addCaptionToVideoUseCase:\n    AddCaptionToVideoUseCase\n): ViewModel() {\n  // Other variables we defined for the photo feature\n    var videoFile: File? = null\n  // Other code we already added for the photo feature\n    fun addCaptionToVideo(captionText: String) {\n        videoFile?.let { file ->\n            viewModelScope.launch {\n                val result =\n                    addCaptionToVideoUseCase.addCaption(\n                        file, captionText)\n                // Handle the result of the captioning\n                   process\n            }\n        }\n    }\n}\n```", "```kt\nclass AddVignetteEffectUseCase() {\n    suspend fun addVignetteEffect(videoFile: File):\n    Result<File> = withContext(Dispatchers.IO) {\n        val outputFile = File(videoFile.parent,\n            \"${videoFile.nameWithoutExtension}\n                _vignetted.mp4\")\n        val command = \"-i ${videoFile.absolutePath} -vf\n            vignette=angle=PI/4 ${outputFile.absolutePath}\"\n        try {\n            val executionId = FFmpeg.executeAsync(command)\n            { _, returnCode ->\n                if (returnCode !=\n                Config.RETURN_CODE_SUCCESS) {\n                    Result.failure<AddVignetteEffectError>(\n                        AddVignetteEffectError)\n                }\n            }\n            // Optionally handle the executionId, e.g., for\n               cancellation\n            Result.success(outputFile)\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\nobject AddVignetteEffectError : Throwable(\"There was an\nerror adding the vignette effect to the video\") {\n    private fun readResolve(): Any = AddVignetteEffectError\n}\n```", "```kt\nval command = \"-i ${videoFile.absolutePath} -vf vignette=angle=PI/4 ${outputFile.absolutePath}\"\n```", "```kt\nclass StoryEditorViewModel(\n    private val saveCaptureUseCase: SaveCaptureUseCase,\n    private val addCaptionToVideoUseCase:\n        AddCaptionToVideoUseCase,\n    private val addVignetteEffectUseCase:\n        AddVignetteEffectUseCase\n): ViewModel() {\n...\n    var videoFile: File? = null\n...\n    fun addVignetteFilterToVideo() {\n        videoFile?.let { file ->\n            viewModelScope.launch {\n                val result =\n                    addVignetteEffectUseCase\n                        .addVignetteEffect(file)\n                // Handle the result of the filter process\n            }\n        }\n    }\n}\n```", "```kt\nclass VideoStorageDataSource {\n    fun uploadVideo(videoFile: File, onSuccess: (String) ->\n    Unit, onError: (Exception) -> Unit) {\n        val storageReference =\n            FirebaseStorage.getInstance().reference\n        val videoRef = storageReference.child(\n            \"videos/${videoFile.name}\")\n        val uploadTask =\n            videoRef.putFile(Uri.fromFile(videoFile))\n        uploadTask.addOnSuccessListener {\n        videoRef.downloadUrl.addOnSuccessListener { uri ->\n            onSuccess(uri.toString())\n        }\n        }.addOnFailureListener { exception ->\n            onError(exception)\n        }\n    }\n}\n```", "```kt\ninterface VideoRepository {\n    suspend fun uploadVideo(videoFile: File):\n        Result<String>\n}\nclass VideoRepositoryImpl(private val\nvideoStorageDataSource: VideoStorageDataSource) :\nVideoRepository {\n    override suspend fun uploadVideo(videoFile: File):\n    Result<String> {\n        return try {\n            var uploadResult: Result<String> =\n                Result.failure(RuntimeException(\"Upload\n                    failed\"))\n            firebaseStorageDataSource.uploadVideo(\n            videoFile, { url ->\n                uploadResult = Result.success(url)\n            }, { exception ->\n                uploadResult = Result.failure(exception)\n            })\n            uploadResult\n        } catch (e: Exception) {\n            Result.failure(e)\n        }\n    }\n}\n```", "```kt\nclass UploadVideoUseCase(private val videoRepository:\nVideoRepository) {\n    suspend fun uploadVideo(videoFile: File):\n    Result<String> {\n        return videoRepository.uploadVideo(videoFile)\n    }\n}\n```", "```kt\nclass StoryEditorViewModel(\nprivate val saveCaptureUseCase: SaveCaptureUseCase,\nprivate val addCaptionToVideoUseCase:\n    AddCaptionToVideoUseCase,\nprivate val addVignetteEffectUseCase:\n    AddVignetteEffectUseCase,\nprivate val uploadVideoUseCase: UploadVideoUseCase\n) : ViewModel() {\n...\n    fun uploadVideo(videoFile: File) {\n        viewModelScope.launch {\n            val result =\n                uploadVideoUseCase.uploadVideo(videoFile)\n            // Handle the result of the upload process\n        }\n    }\n}\n```"]