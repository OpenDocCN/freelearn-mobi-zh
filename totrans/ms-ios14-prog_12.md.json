["```swift\nlocationHelper.askPermission { [weak self] status in if status == .authorizedAlways {\n  self?.showCurrentLocation()\n  } else {\n    // handle the case where you don't always have access\n  }\n}\n```", "```swift\nlocationManager.delegate = self\n```", "```swift\nfunc askPermission(_ completion: @escaping (CLAuthorizationStatus) -> Void) {\n  let authorizationStatus = \n    CLLocationManager.authorizationStatus()\n  if authorizationStatus != .notDetermined {\n    completion(authorizationStatus)\n  } else {\n    askPermissionCallback = completion\n    locationManager.requestAlwaysAuthorization()\n  }\n}\n```", "```swift\nfunc locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {\n  askPermissionCallback?(status)\n  askPermissionCallback = nil\n}\n```", "```swift\nfunc getLatestLocation(_ completion: @escaping (CLLocation) -> Void) {\n  if let location = trackedLocations.last {\n    completion(location)\n  } else if CLLocationManager.locationServicesEnabled() {\n    latestLocationObtainedCallback = completion\n    locationManager.startUpdatingLocation()\n  }\n}\n```", "```swift\nfunc locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n  latestLocationObtainedCallback?(locations.last!)\n  latestLocationObtainedCallback = nil\n  locationManager.stopUpdatingLocation()\n  trackedLocations += locations\n}\n```", "```swift\nfunc getLocationName(for location: CLLocation, _ completion: @escaping (String) -> Void) {\n  let geocoder = CLGeocoder()\n  geocoder.reverseGeocodeLocation(location) { placemarks,\n    error in\n  guard error == nil else {\n    completion(\"An error ocurred: \n    \\(error?.localizedDescription ?? \"Unknown error\")\")\n    return\n  }\n  completion(placemarks?.first?.name ?? \"Unkown location\")\n  }\n}\n```", "```swift\nif launchOptions?[UIApplication.LaunchOptionsKey.location] != nil\n  { locationHelper.monitorSignificantChanges { _ in\n    // continue monitoring\n  }\n}\n```", "```swift\nfunc monitorSignificantChanges(_ locationHandler: @escaping (CLLocation) -> Void) {\n  guard CLLocationManager. \n    significantLocationChangeMonitoringAvailable() else { return }\n  significantChangeReceivedCallback = locationHandler\n  locationManager.startMonitoringSignificantLocationChanges()\n  isTrackingSignificantLocationChanges = true\n}\n```", "```swift\nfunc locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {\n  latestLocationObtainedCallback?(locations.last!)\n  latestLocationObtainedCallback = nil\n  if isTrackingSignificantLocationChanges == false {\n    locationManager.stopUpdatingLocation()\n  }\n  significantChangeReceivedCallback?(locations.last!)\n  trackedLocations += locations\n}\n```", "```swift\nlocationManager.allowsBackgroundLocationUpdates = true\n```", "```swift\nlet region = CLCircularRegion(center: location.coordinate, radius: 30, identifier: \"current-location-geofence\") locationHelper.setGeofence(at: region, exitHandler, enterHandler)\n```", "```swift\nfunc setGeofence(at region: CLRegion, _ exitHandler: @escaping () -> Void, _ enterHandler: @escaping () -> Void) {\n  guard CLLocationManager.isMonitoringAvailable(for: \n  CLCircularRegion.self) else { return }\n  geofenceExitCallback = exitHandler\n  geofenceEnterCallback = enterHandler\n  locationManager.startMonitoring(for: region)\n}\n```", "```swift\nfunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) {\n  geofenceEnterCallback?()\n}\nfunc locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) {\n  geofenceExitCallback?()\n}\n```"]