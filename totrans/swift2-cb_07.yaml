- en: Chapter 7. Swift Debugging with Xcode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating the values – developing a tax income simulator app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with Xcode and Swift – the best checker movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging with LLDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling in Swift 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error handling in Swift 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability checking in Swift 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's face it, nobody writes a full program without any issues. Even the best
    programmer will see some situations that haven't been contemplated. Sometimes
    it's easy to find the bug, sometimes it is very hard, mainly you have a multithread
    app.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to debug an app step by step, it
    will make it easier for you to find out where the issue is.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the values – developing a tax income simulator app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing code and developing apps, we know that some variables of a function
    shouldn't contain certain values, but are you sure of that? How can we develop
    and check that everything has the right value?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to learn how to check that the values are right
    during the development stage. To simulate this, let's create an app where we are
    sure that there will be people trying to cheat the values; in this case let's
    create an app to calculate tax income.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a project called `Chapter 7 Tax Income` and make sure that you are in
    debug mode; to do it click on the project schema and select **Edit Scheme…**,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Run** option located on the left-hand side, then make sure that
    the **Info** tab is selected, and finally, make sure that the **Build** option
    is on **Debug**. We will have some explanations afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once these steps have been checked we need to open the project settings and
    create a macro called `DEBUG_MODE`, only on the debug configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create a new file called `Assertions.swift`. Here we are going
    to add some functions, all of them starting with `assert_`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can create another file, which will contain a class that should be able
    to calculate the income tax. Create a new file called `IncomeTaxCalculator.swift`;
    start with the following class header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is adding its attributes; as you can imagine, we have to store
    a few values for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, all of them are initialized or are options; you don''t need
    to create an initializer in this case, except if you are using one of the first
    versions of Swift:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you paid attention, this class must implement the `Printable` protocol.
    So we need to add the description to this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To finish this class, we need a method that calculates the income tax based
    on the previous attributes. Of course, this is a fictional case; don''t use this
    app to calculate your income tax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once it is done, we have to create the graphical part of our app, so go to the
    storyboard and create a layout with six text fields, one button, and six labels;
    something similar to the following one:![How to do it…](img/00077.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you may imagine, we need to create some attributes to link with the text
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete our graphical part, we need to add an event for the button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last step to do is testing our application and watching the assertions work.
    Press play and when the application appears, press calculate, without adding any
    information into the text fields. You should see your application stop running,
    and the Xcode should show you where:![How to do it…](img/00078.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you pay attention, the log console will open and show you what happened,
    printing the message that you have written:![How to do it…](img/00079.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's complete this recipe, changing from **Debug** to **Release** configuration;
    press play again, and see that the first assert was ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assertions are like functions that interrupt the application when they find
    an unexpected value. Of course, when a program is released, it needs to accept
    these values, which means that the developer shouldn't trust on the assertions'
    power forever, he must fix the value, or at least interrupt the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift comes with only two assertions functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert`: This function has two arguments. The first one is a Boolean element
    which, in case of being false, is going to stop your program and show the next
    argument (the message) for the developer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertionFailure`: This function stops the program execution without checking
    any condition. This function is used when there is a way where the app shouldn''t
    go through it. Imagine that you have a `switch` statement, and theoretically your
    program shouldn''t go to the default case because it isn''t considered, in this
    case you need to add an assertion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another nagging question is: What does `autoclosure` mean? The reason is the
    following—`assert`, `assertionFailure`, and our assertions functions actually
    don''t receive a value as an argument, the reason is laziness. It means that Swift
    isn''t going to evaluate the values before entering into the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Swift converts your argument into a function and the argument will be evaluated
    inside when the assert function calls it. Why? The reason is that assertions shouldn't
    work if you are compiling with Release configuration instead of Debug. Bear in
    mind that assertions stop your program, which is something good when you are developing,
    but for a user it won't be a good sensation. That's the reason that sometimes
    we call the autoclosure function between `#ifdef NDEBUG` and `#endif`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Xcode 6 beta 5, `@autoclosure` used to be written as `@auto_closure`.
    If you are going to search for something about this modifier on the Internet,
    try writing it both ways.
  prefs: []
  type: TYPE_NORMAL
- en: If assertions don't work on Release mode, why are they useful? The reason is
    that assertions are used for detecting development errors, you should track the
    source of the error and modify it to ensure that the source won't give you a wrong
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we created a different file for our own assertion functions is that
    you may have this file shared between projects; of course you can use the function
    `assert` for everything, but I would recommend creating assertions functions that
    can save us from work, like the one we have to check if an element is inside of
    an array.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe we learned about using the Swift assertions, which is the equivalent
    of the `NSAssert` in Objective-C. If you prefer using the other assertion features
    from the Objective-C foundation, such as `NSParameterAssert` and `NSAssertionHandler`,
    you are still able to use them in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Assertions are very useful for finding paths that are receiving wrong values,
    however there are times when it is necessary to go step by step in the code. We
    will see how to do it with Xcode and Swift in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with Xcode and Swift – the best checker movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have some experience with programming, you know that sometimes we need
    to go step by step into the code, mainly when we have those kinds of issues where
    nobody knows how it happened.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we are going to learn how to debug with Xcode and Swift. To do
    it, we are going to recycle our checkers board. In this case we are going to make
    the best move using the white pieces. We are also going to leave it prepared for
    a second version of this app where we could use kings.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to create the right algorithm in the beginning, the idea is
    to debug and find where the issue is, and then we are going to correct it afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open your playground from the previous chapter where you have the checkers board.
    Leave it open because we are going to reuse this code. Once it is opened, create
    a new project called `Chapter 7 checkerboard`, and let's start coding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file called `CheckersBoard.swift`, start by importing the `UIKit`
    library if it is not imported yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that you can paste the class code from playground. Then, copy the last
    part from playground (variable instantiation and setup) and paste it in the `viewDidLoad`
    method on the view controller file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a breakpoint on the third time we assign a piece, by clicking
    on the gray area to the left of the code:![How to do it…](img/00080.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press play, wait until the Xcode stops on your breakpoint and move your mouse
    pointer over the board variable. It can be any of them, like the first one, where
    the variable is being declared, or the other ones where we assign a piece.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a short interval you will see a small dialog with two icons on the right.
    The first icon, which is an **i** with a circle around it, displays the content
    of the object with a text format similar to a JSON format:![How to do it…](img/00081.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The other icon is very familiar to us, because it''s the same icon we''ve seen
    on the playground, it''s the quick look icon and we can also use it here. That
    way we retrieve a more visual way of watching the checkers board:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00082.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't create the method `debugQuickLookObject` for every single class you have,
    only for those classes that are hard to visualize and need to be debugged frequently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we know how to visualize our object, we need to differentiate traditional
    pieces from kings. Our next goal is adding a Boolean to the `BoardSpace` enumeration.
    Replace the previous enumeration with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to display something different, in this case we are going to add
    the letter `K` over the piece. Replace the `switch` statement inside the `debugQuickLookObject`
    with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right, now after filling the pieces we need to add a code in case the current
    piece is a king:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to change the way we assign the pieces with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's repeat the operation by pressing play and watching the board with quick
    look; now you can press the step over button, just press the *F6* key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: New Apple keyboards have an assigned function for the *F6* key, so you will
    probably have to press this key together with the *fn* key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now check the quick look and see that you have the letter `K` over one of your
    pieces:![How to do it…](img/00083.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ok, now that we know how to visualize the board, we are going to see whether
    we can win a game with only one turn. To do it we will need to choose a piece
    and see every possibility we have. It means that we will need to clone our object
    frequently. Usually we would create a struct for it but in this case we are going
    to create a method for cloning our object. We will give explanations later; just
    add this code inside your `CheckersBoard` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step to worry about is how to capture the opponent''s piece, to do
    it we will need to test which directions are possible. Let''s create an enumeration
    inside our `CheckersBoard` class to help us:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create a method that is going to find us the best move; remember
    that we are using only the white pieces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, we have two private methods, one for the best movement of a
    normal piece, and another one for a king. Here we are going to develop the single
    piece function, the other method I''ll leave as homework for you; otherwise it
    will be an extremely huge recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this class, we need to add more methods, one that will count the
    number of black pieces, and another that is going to capture the opponent''s piece:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok, now imagine that it's Monday. We had to type this whole amount of code and
    someone (probably your boss) tells us that there is a setup that doesn't find
    the best solution. Reviewing every single line of this code can be very boring,
    and it can be hard to find where the problem is.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s debug starting with the setup that is not working, so replace the setup
    code with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing you might have noticed is the `debugDescription`. This is something
    similar to `debugQuickLookObject` but instead of returning different kinds of
    objects it only returns a text, we are going to complete this property later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As you know, we have to debug the fourth white piece movement. To do it, go
    to the method called `bestMovementWhite` and add a breakpoint on the line where
    we call the method `bestMovementSinglePieceWhite`. Right-click on this breakpoint
    and you will see a menu like the following one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/00084.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Choose **Edit breakpoint...**, as you know we don't want to check what happened
    with the first three pieces, so say that you want to ignore **3** times before
    stopping:![How to do it…](img/00085.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sometimes we know that we have to stop after a certain number of times, try
    to use it instead of clicking play lots of times. Add another breakpoint in this
    same method at the end (`return boardCandidate`) and edit it. Now we are going
    to add a condition to make it work and change the action to sound. Unfortunately
    most of the available sounds are too soft, I usually choose the glass one, but
    if you prefer you can choose another one. To finish this breakpoint, select the
    option **Automatically continue after evaluating actions**:![How to do it…](img/00086.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now press play and wait until Xcode stops, press the step into button (the
    one with an arrow pointing down) or press *F7*, you will get into the `bestMovementSinglePieceWhite`.
    Now click on step over (or press *F6*) three times, check the board with quick
    look, and have a look that we will return this board. Once this issue has been
    detected, we can replace our algorithm with this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now press play again but instead of pressing step into use step over, check
    the board with the quick look inspector, and see that you now have the right solution.
    So, problem solved, but don't celebrate too much, other issues are coming.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xcode allows us to debug step by step. Using the method that we used to debug
    on our playground (`debugQuickLookObject`) can help us to visualize the current
    object state. In this case we could improve our method using the method `drawAtPoint`
    of the NSString, right now there is no equivalent method on Swift strings.
  prefs: []
  type: TYPE_NORMAL
- en: Another detail that you could see is that we created our own method to clone
    the board instead of using a struct. The reason is that structs can't inherit
    and in this case we need to do it due to our quick look method.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints have some special features when using Xcode. You can ignore them
    a few times, which is very useful when you know that the issue happens after some
    repetitions. Imagine if you have to press continue 50 times, and then you have
    to repeat it again and again until you find the solution. You and your mouse would
    end the day exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can also add an action to the breakpoint, such as adding
    a debugger command, playing a sound (that is very useful for knowing that something
    was done in the background, but you don't want to stop), or logging a message
    that helps us to analyze the program trajectory.
  prefs: []
  type: TYPE_NORMAL
- en: There are some commands for debugging that a developer must know, such as step
    over, which executes the whole line of code and stops on the next one, step into,
    which goes inside the current function, step out (*F8*), which exits from the
    current function and stops on the same place where it was called, and continue
    (*control* + *command* + *Y*), which continues executing the program until the
    next breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately there is no right or wrong procedure to find an issue, and sometimes
    you have to use your sixth sense to solve it. The only way is to collect as much
    information as you can and go step by step.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actually Xcode isn't debugging by itself, the reality is that it uses another
    debugger to do this task; on the next recipe we are going to use the debugger
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with LLDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging with Xcode is fine, but sometimes we are limited and we have to use
    the debugger with a lower level. To do it, we have to know that actually, Xcode
    is not debugging anything, it uses another program called LLDB.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old versions of Xcode used to debug with GDB instead of LLDB, don't try to use
    them with Swift because there is no support for Swift on GDB.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended knowing the LLDB commands if you want to debug big
    programs, there are also some cases where you have to connect with another machine
    (a continuous integration, for example), where you have to do everything through
    an SSH shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open the checkers board program and check whether you have any breakpoints and
    remove all of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Press play and when the program starts, press the pause button using the combination
    *control* + *command* + *U*. After that you will see the LLDB console:![How to
    do it…](img/00087.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now click on the LLDB console and write `break s -r bestMovement*`. You will
    see that the answer is `Breakpoint 1: 4 locations`. Then let''s list these breakpoints
    with a breakpoint list. Here you can see an ugly answer, but don''t be scared,
    this is simpler than you think.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also write `thread info` to get some information about the current thread.
    Check that it specifies the language of each frame, with this information you
    can get a better idea about what happened with your code in case of crashing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List your threads with `thread list,` switch to thread 2 with `thread select
    2`, and write `thread info` again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now write `repl` and see that the prompt changes to `1>`. In this case, we
    are going to write a new function to test our REPL, so type the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this function is done, let''s test it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, `repl` can help you write functions in runtime, like we did
    with the playground.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLDB is the current Xcode debugger; you can set multiple breakpoints with regular
    expressions. Remember that what you do on LLDB isn't necessarily reflected on
    Xcode, the breakpoints we set are a good example.
  prefs: []
  type: TYPE_NORMAL
- en: Have a look that three of our breakpoints have the filename and a line number,
    like `... at CheckersBoard.swift:158, …` it means your breakpoint is on the file
    `CheckersBoard.swift` at line 158.
  prefs: []
  type: TYPE_NORMAL
- en: We also used REPL, which is a Swift command line, here you can create functions
    and test some code. Of course you can also use playground, but sometimes it is
    faster using the current debugger.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apple has some documentation about LLDB worth looking at. Check this URL: [https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What about features that users complain about but are hard to debug, such as
    memory, performance, or energy? For these kinds of problems you have to use another
    tool, we are going to learn about it in the next recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very common to hear about issues, but if an app doesn't have any important
    issue it doesn't mean that it is working fine. Imagine that you have a program
    that has a memory leak. Presumably you won't find any problem using it for 10
    minutes, however, a user may find it after using it for a few days. Don't think
    that this case is impossible, remember that iOS apps don't terminate, so if you
    have a memory leak it will be kept until your app blows up.
  prefs: []
  type: TYPE_NORMAL
- en: Performance is another frequent topic, what if your app looks ok but it gets
    slower with the passage of time? We have to be aware of this problem. This kind
    of test is called **profiling** and Xcode comes with a very good tool for realizing
    this operation, which is called **Instruments**.
  prefs: []
  type: TYPE_NORMAL
- en: In this case we are going to profile our app to visualize the amount of energy
    wasted by our app and of course let's try to reduce it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe you will need a physical device, and to install your app on
    the device you will need to be enrolled on the Apple Developer Program. If you
    have both requirements the next thing you have to do is create a new project called
    `Chapter 7 Energy`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start coding, we will need to add a framework to the project. Click
    on the tab **Build Phases** of your project and go to the section **Link Binaries
    with Libraries** and press the plus sign:![How to do it…](img/00088.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Xcode opens a dialog window asking for the framework to add, choose **CoreLocation**
    and **MapKit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go to the storyboard, place a label and a MapKit view, you might have a
    layout similar to this one:![How to do it…](img/00089.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Link the MapKit view and call it just map, and the `UILabel` and call it just
    label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Continuing with the view controller, let''s click at the beginning of the file
    to add the `CoreLocation` and `MapKit` imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that you have to initialize the location manager object on the `viewDidLoad`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this moment you may get an error because your view controller doesn''t conform
    with the `CLLocationManagerDelegate`, so let''s go to the header of the view controller
    class and let''s specify that it implements this protocol. Another error we have
    is the `locationManager` variable, because it is not declared, therefore we have
    to create it as an attribute. And as we are declaring attributes, we are going
    to add the geocoder, which is going to be used later:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we implement the method that receives the positioning, let''s create
    another method to detect whether there was any authorization error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we can implement the method that will update our location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before you test the app there is still another step to do. On your project,
    navigate to or click expand on the supporting files and then click on **info.plist**.
    Add a row by right-clicking on the list and selecting **add row**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On this new row, type `NSLocationWhenInUseUsageDescription` as key, and on value
    Permission required, like the following screenshot:![How to do it…](img/00090.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a device and install this app onto it, and test the application walking
    around your street (or walking around planet Earth if you want). Check that the
    label will change and also that the map will display your current position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now go back to your computer and plug the device in again, now instead of pressing
    play you have to hold the play button until you see more options and then you
    have to select the profile option:![How to do it…](img/00091.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing that will happen is that instruments is going to open, probably
    a dialog will pop up asking for an administrator account. That's due to instruments
    needing to use some special permissions to access some low-level information:![How
    to do it…](img/00092.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next dialog you will see different kinds of instruments, some of them
    are OS X specific, some are iOS specific, and others are for both. If you choose
    the wrong platform instrument the record button will be disabled. For this recipe
    choose energy diagnostics:![How to do it…](img/00093.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the **Energy Diagnostics** window is open you can press the record button,
    which is on the upper-left corner, and try to move around—yes, you need to keep
    the device connected to your computer so you have to move around with both elements
    together—and do some actions with your device, such as pressing the home button
    and turning off the screen. Now you may have a screen similar to this one:![How
    to do it…](img/00094.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can analyze who is spending more energy on your app. To get a better
    idea about it, go to your code and replace the constant `kCLLocationAccuracyBest`
    with `kCLLocationAccuracyThreeKilometers` and check whether you have saved some
    energy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instruments is a tool used for profiling your application. It gives you information
    about your app, which can't be retrieved by code, or at least can't be retrieved
    easily. You can check whether your app has memory leaks, whether it is losing
    performance, and as you can see, whether it is wasting much energy or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we used the GPS because it is a sensor that requires some energy,
    and also you can check on the table on the bottom of your instrument that Internet
    requests were done, which is something that if you do very frequently, will also
    empty your battery fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something you might be asking is: why did we have to change the `info.plist`?
    Since iOS 8, some sensors require user permissions; the GPS is one of them, so
    you need to report the message that is going to be shown to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is recommended that you read about the way that instruments work, mainly
    those that you are going to use. Check the Apple documentation about instruments
    to get more details about it: [https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html](https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have experience with Objective-C you might be asking how could you recycle
    your code using Swift, in the next chapter we are going to see some recipes for
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling in Swift 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the introduction of Swift 2.0, Apple has provided an entirely new way to
    perform error handling, similar to other programming languages. Not only can you
    take advantage of this in your own classes, Apple has also updated all of its
    classes to use the new error handling methods.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new single view project and name it `Error Handling Chapter 7`. We
    will be using the boiler plate project setup for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open `ViewController.swift` and add the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Upon running this code, you should receive an error `Extra argument 'Error'
    in call`. With Swift 2.0, you are no longer required to pass the memory address
    of an error object, therefore the error argument is no longer needed and has been
    removed from the Apple standard library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the code in the method call to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to C++, Swift 2.0 now uses a do-try-catch method of error handling.
    Inside the do block we attempt to perform some task that can result in an error
    and prefix it with the try keyword. This lets Xcode know that this method can
    fail and to look for a catch block if a failure occurs.
  prefs: []
  type: TYPE_NORMAL
- en: You can tell what methods require this error handling by looking at the method
    declaration. All methods with error handling will include a throws keyword at
    the tail end of the declaration. We will learn in the next recipe how to define
    your own methods that incorporate error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the try keyword can be used with both ? and ! for additional functionality.
    Using try? for instance will result in the returned value wrapped in an optional.
    Rather than performing a do-while loop and catching the error to set a value to
    nil, you can simply substitute try? and the value will now function as an optional
    with standard nil handling. When using try!, you explicitly ignore the error handling.
    This is only used when you already know a value will not produce an error; for
    example, loading an image that was shipped with the application.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will often require some code to run regardless of errors. Swift 2.0 adds
    a new feature that works great for just this scenario: the defer keyword. Any
    code provided inside of the defer block will automatically execute once it reaches
    the end of the containing scope. This feature works anywhere in code.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom error handling in Swift 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new error handling in Swift 2.0 is not limited to the Apple standard library.
    You can include this new syntax in your own classes and methods. Doing so allows
    you to build applications that handle all errors appropriately, often resulting
    in a better user experience and with fewer crashes. Additionally, this new error
    handling can be leveraged for more complex debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new single view project and name it `Custom Error Handling Chapter
    7`. We will be using the boilerplate project setup for this recipe. If you followed
    the previous recipe in this chapter, you may continue using that project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Navigate to the `ViewController.swift` file and add the following code to the
    bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s implement a custom method that uses the `CustomError` enum we just created.
    Add the following code below our enum declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We initially create a custom enum to store any required custom error types.
    These types can be explicit to your application or generic enough for a framework.
    Swift 2.0 uses the throws keyword placed before the return value of a method in
    order to identify methods with error handling.
  prefs: []
  type: TYPE_NORMAL
- en: In our custom method, we want to perform any task that can possibly fail, such
    as a URL request. Next, we validate the possible errors and call `throw` with
    the error type. Everything after our checks will run as normal if no errors are
    thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Availability checking in Swift 2.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swift 2.0 introduces a new method for checking OS availability in your code.
    This is done in the form of `@available` and allows us to check for OS support
    for both calling methods and creating our own. Using this new availability checking
    allows you to write backwards-compatible code without the worry of runtime errors.
    Xcode 7 has great integration with `@available` for a better programmer experience
    without many warnings. Additionally, you can more clearly define tasks based on
    the OS version without the hassle of macros.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new single view project and name it `Availability Chapter 7`. We will
    be using the boiler plate project setup for this recipe. If you followed the previous
    recipe in this chapter, you may continue using that project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test this functionality, we will be using an Apple standard library call
    for registering notifications. iOS 8 introduced a new method for this, so we want
    to target iOS 8 and up only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the project settings and change the minimum deployment target to
    iOS 7.1 or below. Because the notification method is supported in 8.0 and above,
    we want to test with 7.1 as our target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the projects `AppDelegate.swift` file and add the following code
    to the `didFinishLaunchingWithOptions` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We use the new syntax `#available`(version number) to specify the version we
    require to run this block of code. The `*` simply indicates all versions above
    the stated version. Additionally, this syntax supports adding multiple platforms,
    such as OS X and watchOS.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the `@available`(version number) syntax, you can specify individual functions
    and classes as only available in a specific version. Simply include this line
    directly above the function or class declaration.
  prefs: []
  type: TYPE_NORMAL
- en: See also…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apple has supplied numerous attributes that can be used in conjunction with
    `@available`. Visit this link to the Apple documentation to learn more about attributes:
    [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Attributes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
