- en: Chapter 3. Using Collections and Cocoa Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once I got past the basic Hello World beginner applications, I quickly began
    to realize the shortcomings of variables, especially with the Mad Libs style applications
    that I was starting to write. These applications requested that the user enter
    in numerous strings, and I was creating a separate variable for each input field
    that the user entered. Having all of these separate variables quickly became very
    cumbersome. I remember talking to a friend about this and he asked me why I was
    not using arrays. At that time, I was not familiar with arrays, so I asked him
    to show me what they were. Even though he had a TI-99/4A and I had a Commodore
    Vic-20, the concept of arrays was the same. Even today, the arrays found in modern
    development languages have the same basic concepts as the arrays I used on my
    Commodore Vic-20\. While it is definitely possible to create a useful application
    without using collections, when used right, collections do make application development
    significantly easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What an array is in Swift and how to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a dictionary is in Swift and how we can use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a Set is in Swift and how we can use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What a tuple is in Swift and how we can use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Cocoa data types in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Foundation data types in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swift collection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection is a group or store of data that has a shared significance. Swift
    provides three native collection types for storing data. These collection types
    are arrays, sets, and dictionaries. An array stores the data in an ordered list,
    sets are an unordered collection of unique data, and dictionaries are an unordered
    collection of key/value pairs. In an array, we access the data by the location
    (index) in the array; in a set, we tend to iterate over the set; and dictionaries
    are usually accessed using a unique key.
  prefs: []
  type: TYPE_NORMAL
- en: The data stored in a Swift collection is required to be of the same type. This
    means, as an example, that we are unable to store a string value and an array
    of integers. Since Swift does not allow us to mismatch data types in a collection,
    we can be certain of the data type when we retrieve data from a collection. This
    is another feature, which on the surface might seem like a shortcoming, but is
    actually a design feature that helps eliminate common programming mistakes. We
    will see how to work around this feature by using the `AnyObject` and `Any` aliases
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who are familiar with Objective-C, you will know that there are different
    classes for mutable and immutable collections. For example, to define a mutable
    array, we use the `NSMutableArray` class, and to define an immutable array, we
    use the `NSArray` class. Swift is a little different because it does not contain
    separate classes for mutable and immutable collections. Instead, we define whether
    a collection is constant (immutable) or a variable (mutable) by using the `let`
    and `var` keywords. This should seem familiar since, in Swift, we define constants
    with the `let` keyword and variables with the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good practice to create immutable collections unless there is a specific
    need to change the objects within the collection. This allows the compiler to
    optimize the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin our tour of collections by looking at the most common collection
    type—the array type.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are a very common component of modern programming languages and can be
    found virtually in all the modern programming languages. In Swift, arrays are
    an ordered list of objects of the same type. This is different from the `NSArray`
    class in Objective-C, which can contain objects of different types.
  prefs: []
  type: TYPE_NORMAL
- en: When an array is created, we must declare the type of data to be stored in it
    by explicit type declaration or through type inference. Typically, we only explicitly
    declare the data type of an array when we are creating an empty array. If we initialize
    an array with data, we should let the compiler use type inference to infer the
    most appropriate data type for the array.
  prefs: []
  type: TYPE_NORMAL
- en: Each object in an array is called an element. Each of these elements is stored
    in a set order and can be accessed by its location (index) in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and initializing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can initialize an array with an array literal. An array literal is a set
    of values that we prepopulate the array with. The following example shows how
    to define an immutable array of integers using the `let` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned, if we need to create a mutable array, we will use the `var`
    keyword to define the array. The following example shows how to define a mutable
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding two examples, the compiler inferred the type of values stored
    in the array by looking at the type of values stored in the array literal. If
    we needed to create an empty array, we will need to explicitly declare the type
    of values to store in the array. The following example shows how to declare an
    empty array that can be used to store integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding examples, we created arrays with integer values, and the majority
    of the array examples in this chapter will also use integer values; however, we
    can create arrays in Swift with any type. The only rule is that once an array
    is defined as containing a particular type, all the elements in the array must
    be of that type. The following example shows how we would create arrays of various
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift does provide special type aliases for working with nonspecific types.
    These aliases are `AnyObject` and `Any`. We can use these aliases to define arrays
    whose elements are of different types, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We should use the `Any` and `AnyObject` aliases only when there is an explicit
    need for this behavior. It is always better to be specific about the types of
    data our collections contain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also initialize an array to a certain size with all the elements of
    the array set to a predefined value. This can be very useful if we want to create
    an array and prepopulate it with the default values. The following example defines
    an array with seven elements, and each element contains the number `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'While the most common array is a one-dimensional array, we can also create
    multidimensional arrays. A multidimensional array is really nothing more than
    an array of arrays. For example, a two-dimensional array is an array of arrays,
    while a three-dimensional array is an array of arrays of arrays. The following
    examples show the two ways to create a two-dimensional array in Swift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the array elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the subscript syntax to retrieve values from an array. The subscript
    syntax for an array is where a number appears between two square brackets and
    that number specifies the location (index), within the array, of the element we
    wish to retrieve. The following example shows how to retrieve elements from an
    array using the subscript syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by creating an array of integers that contains
    six numbers. We then print out the value at index `0` and `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to retrieve an individual value within a multidimensional array,
    we will need to provide a subscript for each dimension. If we did not provide
    a subscript for each dimension, we will return an array rather than an individual
    value within the array. The following example shows how we can define a two-dimensional
    array and retrieve an individual value within the two dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we begin by defining a two-dimensional array. When we
    retrieve the value at index `0` of the first dimension (`multiArray[0]`), we retrieve
    the array, `[1,2]`. When we retrieve the value at index `0` of the first dimension
    and index `1` of the second dimension (`multiArray[0][1]`), we retrieve the integer,
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the first and last elements of an array using the `first` and
    `last` properties. The `first` and `last` properties return an optional value
    since the values may be nil if the array is empty. The following example shows
    how to use the `first` and `last` properties to retrieve the first and last elements
    of both single-dimensional and multidimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Counting the elements of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At times, it is essential to know the number of elements in an array. To retrieve
    the number of elements, we would use the read-only `count` property. The following
    example shows how to use this property to retrieve the number of elements in both
    single-dimensional and multidimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value that is returned by the `count` property is the number of elements
    in the array and not the largest valid index of the array. For nonempty arrays,
    the largest valid index is the number of elements in the array minus one. This
    is because the first element of the array has an index number of zero. As an example,
    if an array has two elements, the valid indexes are `0` and `1`, while the count
    property would return `2`. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we attempt to retrieve an element from an array, using the subscript syntax,
    where the index is outside the range of the array, the application will throw
    an `Array index out of range` error. Therefore, if we are unsure of the size of
    an array, it is good practice to verify that the index is not outside the range
    of the array. The following examples illustrate this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the first block of code would throw an `array index out
    of range` error exception because we are attempting to access the value from the
    array `arrayTwo` at index `6`; however, there are only four elements in the array.
    The second example would not throw the `array index out of range` error exception
    because we are checking whether the `arrayOne` array contains more than six elements,
    and if it does not, we do not attempt to access the value at index `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Is the array empty?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check whether an array is empty (does not contain any elements), we use
    the `isEmpty` property. This property will return `true` if the array is empty,
    or `false` if it has elements. The following example shows how to check whether
    an array is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Appending to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A static array is somewhat useful, but having the ability to add elements dynamically
    is what makes arrays really useful. To add an item to the end of an array, we
    can use the `append` method. The following example shows how to append an item
    to the end of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift also allows us to use the addition assignment operator (`+=`) to append
    an array to another array. The following example shows how to use the addition
    assignment operator to append an array to the end of another array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The way you append an element to the end of an array is really up to you. Personally,
    I prefer the assignment operator because, to me, it is a bit easier to read, but
    we will be using both in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a value into an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can insert a value into an array by using the `insert` method. The `insert`
    method will move all the items, starting at the specified index up one spot, to
    make room for the new element and then inserts the value into the specified index.
    The following example shows how to use the insert method to insert a new value
    into an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot insert a value that is outside the current range of the array. Attempting
    to do so will throw an `Index out of range exception`. For example, in the preceding
    code, if we attempt to insert a new integer at index 10, we will receive an `Index
    out of range exception error` because `arrayOne` only contains five elements.
    The exception to this is that we are able to insert an item directly after the
    last element; therefore, we can insert an item at index `6`. However, it is recommended
    that we use the `append` function to append an item to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing elements in an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the subscript syntax to replace elements in an array. Using the subscript,
    we pick the element of the array we wish to update and then use the assignment
    operator to assign a new value. The following example shows how we will replace
    a value in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You cannot update a value that is outside the current range of the array. Attempting
    to do so will throw the same `Index out of range` exception that was thrown when
    we tried to insert a value outside the range of the array.
  prefs: []
  type: TYPE_NORMAL
- en: Removing elements from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three methods that we can use to remove one or all the elements in
    an array. These methods are `removeLast()`, `removeAtIndex()`, and `removeAll()`.
    The following example shows how to use the three methods to remove elements from
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `removeLast()` and `removeAtIndex()` methods will also return the value
    of the element that it is removing. Therefore, if we want to know the value of
    the item that was removed, we can rewrite the `removeAtIndex` and `removedLast`
    lines to capture the value, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Adding two arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new array by adding two arrays together, we use the addition (`+`)
    operator. The following example shows how to use the addition (`+`) operator to
    create a new array that contains all the elements of two other arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `arrayOne` and `arrayTwo` are left unchanged, while the
    combine array contains the elements from `arrayOne`, followed by the elements
    from `arrayTwo`.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a new array from the original array with the elements in reverse
    order using the `reverse()` method. The original array will remain unchanged by
    the `reverse` method. The following example shows how to use the `reverse()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the elements of `arrayOne` are left unchanged, while
    the `reverse` array will contain all the elements from `arrayOne`, but in the
    reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a subarray from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can retrieve a `subarray` from an existing array by using the subscript
    syntax with a range. The following example shows how to retrieve a range of elements
    from an existing array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `…` operator (three periods) is known as a range operator. The range operator,
    in the preceding code, says I want all the elements, `2` to `4`, inclusively (included
    elements 2 and 4 as well as what is between them). There is another range operator,
    which is `..<`, the same as the `…` range operator, but it excludes the last element.
    The following example shows how to use the `.<` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `subArray` will contain two elements `3` and `4`.
  prefs: []
  type: TYPE_NORMAL
- en: Making bulk changes to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use the subscript syntax with a range operator to change the values of
    multiple elements. The following example shows how to use the subscript syntax
    to change a range of elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the elements at index `1` and `2` will be changed to
    number `12` and `13`. After this, when the code runs, `arrayOne` will contain
    `1`, `12`, `13`, `4`, and `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of elements that you are changing in the range operator does not
    need to match the number of values that you are passing in. Swift makes the bulk
    changes—it first removes the elements defined by the range operator and then inserts
    the new values. The following example demonstrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `arrayOne` starts with five elements. We then say that
    we want to replace the range of elements `1` to `3` inclusively. This causes elements
    `1` to `3` (three elements) to be removed from the array. We then add two elements
    (`12` and `13`) to the array, starting at index `1`. After this is complete, `arrayOne`
    will contain these four elements: `1`, `12`, `13`, and `5`. Let''s see what happens
    if we try to add more elements than we remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `arrayOne` starts with five elements. We then say that
    we want to replace the range of elements `1` to `3` inclusively. This causes elements
    `1` to `3` (three elements) to be removed from the array. We then add four elements
    (`12`, `13`, `14`, and `15`) to the array, starting at index `1`. After this is
    complete, `arrayOne` will contain these six elements: `1`, `12`, `13`, `14`, `15`,
    and `5`.'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms for arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift arrays have several methods that take a closure as the argument. These
    methods transform the array and the closures affect how the array is transformed.
    Closures are self-contained blocks of code that can be passed around, and are
    similar to blocks in Objective-C and lambdas in other languages. We will discuss
    closures in depth in [Chapter 12](ch12.html "Chapter 12. Working with Closures"),
    *Working with Closures*. For now, we just want to get familiar with how the algorithms
    work in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: sortInPlace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The sortInPlace algorithm sorts the array in place. This means when the `sortInPlace()`
    method is used, the original array is replaced by the sorted one. The closure
    takes two arguments (represented by `$0` and `$1`), and it should return a Boolean
    value that indicates whether the first element should be placed before the second
    element. The following code shows how to use the sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will sort the array in increasing order. We can tell this
    because our rule will return `true` if the first number (`$0`) is less than the
    second number (`$1`). Therefore, when the sort algorithm begins, it compares the
    first two numbers (`9` and `3`) and returns `true` if the first number (`9`) is
    less than the second number (`3`). In our case, the rule returns `false`, so the
    numbers are reversed. The algorithm continues sorting, in this manner, until all
    of the numbers are sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example sorted the array in numerically increasing order; if
    we wanted to reverse the order, we would reverse the arguments in the closure.
    The following code shows how to reverse the sort order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When we run this code, `arrayOne` will contain the elements `9`, `8`, `6`, `5`,
    `3`, and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the sortInPlace algorithm sorts the array in place (replaces the original
    array), the `sort` algorithm does not change the original array, it instead creates
    a new array with the sorted elements from the original array. The following example
    shows how to use the sorted algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we run this code, `arrayOne` will contain the original unsorted array (`9`,
    `3`, `6`, `2`, `8`, and `5`) and the sorted array will contain the new sorted
    array (`2`, `3`, `5`, `6`, `8`, and `9`).
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The filter algorithm will return a new array by filtering the original array.
    This is one of the most powerful array algorithms and may end up to be the one
    we use the most. If we need to retrieve a subset of an array, based on a set of
    rules, I recommend using this algorithm rather than trying to write your own method
    to filter the array. The closure takes one argument and it should return a Boolean
    `true` if the element should be included in the new array, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the rule that we are passing to the algorithm returns
    `true` if the number is greater than `3` or less than `7`; therefore, any number
    that is greater than `3` or less than `7` is included in the new filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at another example; this one shows how we can retrieve a
    subset of cities that contain the letter o in their name from an array of cities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the `rangeOfString()` method to return `true`
    if the string contains the letter o. If the method returns `true`, the string
    is included in the filtered array.
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The map algorithm returns a new array that contains the results of applying
    the rules in the closure to each element of the array. The following example shows
    how to use the map algorithm to divide each number by `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the new array contains the numbers `1`, `2`, `3`, and
    `4`, which is the result of dividing each element of the original array by `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new array created by the map algorithm is not required to contain the same
    element types as the original array; however, all the elements in the new array
    must be of the same type. In the following example, the original array contains
    integer values, but the new array created by the map algorithm contains string
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created an array of strings that appends the numbers
    from the original array to the `num:`string.
  prefs: []
  type: TYPE_NORMAL
- en: forEach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use `forEach` to iterate over a sequence. The following example shows
    how we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will print the following results to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: While using the `forEach` method is very easy, it does have some limitations.
    The recommended way to iterate over an array is to use the `for-in` loop, which
    we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can iterate over all elements of an array, in order, with a `for-in` loop.
    We will discuss the `for-in` loop in greater detail in [Chapter 4](ch04.html "Chapter 4. Control
    Flow and Functions"), *Control Flow and Functions*. The `for-in` loop will execute
    one or more statements for each element of the array. The following example shows
    how we would iterate over the elements of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the `for-in` loop iterates over the `arr` array and
    executes the `print(item)` line for each element in the array. If we run this
    code, it will display the following results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There are times when we would like to iterate over an array, as we did in the
    preceding example, but we would also like to know the index as well as the value
    of the element. To do this, we can use the `enumerate` method, which returns a
    tuple (see the *Tuples* section later in this chapter) for each item in the array
    that contains both `index` and `value` of the element. The following example shows
    how to use the `enumerate` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the following results in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have introduced arrays in Swift, let's take a look at what a dictionary
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While dictionaries are not as commonly used as arrays, they have an additional
    functionality that makes them incredibly powerful. A dictionary is a container
    that stores multiple key-value pairs, where all the keys are of the same type,
    and all the values are of the same type. The key is used as a unique identifier
    for the value. A dictionary does not guarantee the order in which the key-value
    pairs are stored since we look up the values by the key, rather than by the index
    of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries are good for storing items that map to unique identifiers, where
    the unique identifier should be used to retrieve the item. As an example, countries
    with their abbreviations are a good example of items that can be stored in a dictionary.
    In the following chart, we show countries with their abbreviations as key-value
    pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| US | United States |'
  prefs: []
  type: TYPE_TB
- en: '| IN | India |'
  prefs: []
  type: TYPE_TB
- en: '| UK | United Kingdom |'
  prefs: []
  type: TYPE_TB
- en: Creating and initializing dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can initialize a dictionary using a dictionary literal, similar to how we
    initialized an array with the array literal. The following example shows how to
    create a dictionary using the key-value pairs in the preceding chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates an immutable dictionary that contains each of the
    key-value pairs in the preceding chart. Just like the array, to create a mutable
    dictionary, we will use the `var` keyword rather than `let`. The following example
    shows how to create a mutable dictionary containing the countries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding two examples, we created a dictionary where the key and value
    were both strings. The compiler inferred that the key and value were strings because
    that was the type of values we put in. If we wanted to create an empty dictionary,
    we would need to tell the compiler what the key and value types are. The following
    examples create various dictionaries with different key-value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to use a custom object as the key in a dictionary, we will need to
    make our custom object conform to the Hashable protocol from Swift's standard
    library. We will discuss protocol and classes in [Chapter 5](ch05.html "Chapter 5. Classes
    and Structures"), *Classes and Structures*, but, for now, just understand that
    it is possible to use custom objects as a key in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing dictionary values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the subscript syntax to retrieve the value for a particular key. If
    the dictionary does not contain the key we are looking for, the dictionary will
    return `nil`; therefore, the variable returned from this lookup is an optional
    variable. The following example shows how to retrieve a value from a dictionary
    using its key in the subscript syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the variable name will contain the string, `United States`.
  prefs: []
  type: TYPE_NORMAL
- en: Counting key or values in a dictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `count` property of the dictionary to get the number of key-value
    pairs in the dictionary. The following example shows how to use the `count` property
    to retrieve the number of key-value pairs in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `cnt` variable will contain the number `3` since
    there are three key-value pairs in the `countries` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Is the dictionary empty?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test whether the dictionary contains any key-value pairs at all, we can
    use the `isEmpty` property. The `isEmpty` property will return `false` if the
    dictionary contains one or more key-value pairs and `true` if it is empty. The
    following example shows how to use the `isEmpty` property to determine whether
    our dictionary contains any key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `isEmpty` property is false as there are three key-value
    pairs in the countries dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the value of a key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the value of a key in a dictionary, we can either use the subscript
    syntax or the `updateValue(value:, forKey:)` method. The `updateValue(value:,
    forKey:)` method has an additional feature that the subscript syntax doesn''t—it
    returns the original value associated with the key prior to changing the value.
    The following example shows how to use both the subscript syntax and the `updateValue(value:,
    forKey:)` method to update the value of a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use the subscript syntax to change the value associated
    with the key `UK` from `United Kingdom` to `Great Britain`. The original value
    of `United Kingdom` was not saved prior to replacing it, so we are unable to see
    what the original value is. We then used the `updateValue(value:, forKey:)` method
    to change the value associated with the key `UK` from `Great Britain to Britain`.
    With the `updateValue(value:, forKey:)` method, the original value of `Great Britain`
    is assigned to the `orig` variable, prior to changing the value in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a key-value pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a new key-value pair to a dictionary, we can use the subscript syntax
    or the same `updateValue(value:, forKey:)` method that we used to update the value
    of a key. If we use the `updateValue(value:, forKey:)` method and the key is not
    currently present in the dictionary, the `updateValue(value:, forKey:)` method
    will add a new key-value pair and return nil. The following example shows how
    to use the subscript syntax and also the `updateValue(value:, forKey:)` method
    to add a new key-value pair to a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the countries dictionary starts with three key-value
    pairs and we then add a fourth key-value pair (`FR/France`) to the dictionary
    using the subscript syntax. We then use the updateValue(`value:, forKey:`) method
    to add a fifth key-value pair (`DE/Germany`) to the dictionary. The `orig` variable
    is set to nil because the countries dictionary did not contain a value associated
    with the `DE` key.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a key-value pair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There may be times when we need to remove values from a dictionary. We can
    do this with the subscript syntax, using the `removeValueForKey()` method or the
    `removeAll()` method. The `removeValueForKey()` method returns the value of the
    key prior to removing it. The `removeAll()` method removes all the elements from
    the dictionary. The following example shows how to use the subscript syntax, the
    `removeValueForKey()` method, and the `removeAll()` method to remove key-value
    pairs from a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `countries` dictionary starts off with three key-value
    pairs. We then set the value associated with the key `IN` to `nil`, which removes
    the key-value pair from the dictionary. We use the `removeValueForKey()` method
    to remove the key associated with the `UK` key. Prior to removing the value associated
    with the `UK` key, the `removeValueForKey()` method saves the value in the `orig`
    variable. Finally, we use the `removeAll()` method to remove all the remaining
    key-value pairs in the countries dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the Set type.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Set type is a generic collection that is similar to the array type. While
    the array type is an ordered collection that may contain duplicate items, the
    Set type is an unordered collection where each item must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the key in a dictionary, the type stored in an array must conform
    to the Hashable protocol. This means that the type must provide a way to compute
    a hash value for itself. All of Swift's basic types, such as String, Double, Int
    and Bool, conform to the Hashable protocol and can be used in a set by default.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we would use the Set type.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of ways in which we can initialize a set. Just like the array
    and dictionary types, Swift needs to know what type of data is going to be stored
    in it. This means that we must either tell Swift the type of data to store in
    the set or initialize it with some data so that it can infer the data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the array and dictionary types, we use the var and let keywords to
    declare if the set is mutable or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Inserting items into a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `insert` method to insert an item into a set. If we attempt to insert
    an item that is already in the set, the item will be ignored and no error will
    be thrown. Here are some examples on how to insert items into a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The number of items in a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `count` property to determine the number of items in a Swift
    Set. Here is an example on how to use the `count` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this code will print the message `"Three items"` to the console
    because the set contains three items.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether a set contains an item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can very easily check to see whether a Set contains an item by using the
    `contains()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `contain` variable is set to True because the
    set does contain the string `"Two"`.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating over a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `for` statement to iterate over the items in a Set. The following
    example shows how we would iterate through the items in a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example would print out each item in the set to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Removing items in a set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can remove a single item or all the items in a set. To remove a single item,
    we would use the `remove()` method, and to remove all the items, the `removeAll()`
    method. The following example shows how to remove items from a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Set operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apple has provided four methods that we can use to construct a set from two
    other sets. These operations can either be performed in place, on one of the sets,
    or used to create a new set. These operations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`union` and `unionInPlace`: These create a set with all the unique vales from
    both sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract` and `subtractInPlace`: These create a set with values from the first
    set that are not in the second set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`intersect` and `intersectInPlace`: These create a set with values that are
    common to both sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exclusiveOr` and `exclusiveOrInPlace`: These create a new set with values
    that are in either set but not in both sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at some examples and see the results we get from each of these
    operations. For all the set operations examples, we will be using the following
    two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s look at our examples. The first example that we will look at is
    using the union method. This method will take the unique values from both sets
    to make another set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `newSetUnion` variable would contain the following values: `"One", "Two",
    "Three", "abc", "def", "ghi"`. Now let''s look at the subtract method. This method
    will create a set with the values from the first set that are not in the second
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `newSetSubtract` variable would contain the values `"Two"`
    and `"Three"` because those are the only two values that are not also in the second
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the intersect method. The intersect method creates a new
    set from the values that are common between the two sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `newSetIntersect` variable will contain the values `"One"`
    and `"abc"` since they are the values that are common between the two sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the `exclusiveOr` method. This method will create a new
    set with the values that are in either set but not in both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `newSetExclusiveOr` variable will contain the values `"Two",
    "Three", "def"` and `"ghi"`.
  prefs: []
  type: TYPE_NORMAL
- en: These four operations (`union`, `subtract`, `intersect`, and `exclusiveor` methods)
    add additional functionality that is not present with arrays. Combined with the
    faster lookup speeds as compared to an array, the Set can be a very useful alternative
    when the order of the collection is not important and the objects in a collection
    must be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tuples group multiple values into a single compound value. Unlike arrays and
    dictionaries, the values in a tuple do not have to be of the same type. The following
    example shows how to define a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we created an unnamed tuple that contains two strings,
    two integers, and one double. We can decompose the values from this tuple into
    a set of variables, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `city` variable will contain `Boston`, the `name`
    variable will contain `Red Sox`, the `wins` variable will contain `97`, the `loses`
    variable will contain `65`, and, finally, the `percent` variable will contain
    `0.599`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also retrieve the values from a tuple by specifying the location of
    the value. The following example shows how we would retrieve the values by their
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid this decomposing step, we can create a named tuple. A named tuple
    associates a name (key) with each element of the tuple. The following example
    shows how to create a named tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the values from a named tuple, we use a dot syntax. In the preceding
    code, we will access the `city` element of the tuple like this: `team.city`. In
    the preceding code, the `team.city` element will contain `Boston`, the `team.name`
    element will contain `Red Sox`, the `team.wins` element will contain `97`, the
    `team.loses` element will contain `65`, and, finally, the `team.percent` element
    will contain `59.9`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples are incredible useful and can be used for all sorts of purposes. I have
    found that they are very useful for replacing classes and structs that are designed
    to simply store data and do not contain any methods. We will learn more about
    classes in [Chapter 5](ch05.html "Chapter 5. Classes and Structures"), *Classes
    and Structures*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cocoa data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this chapter, we have looked at several native Swift data types,
    such as the string, array, and dictionary types. While using these types is definitely
    preferred, as part of the Objective-C interoperability, Apple has provided convenient
    and effective ways to work with Cocoa data types from within our Swift applications.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the Cocoa and Swift data types can be used interchangeably, while others
    are automatically converted between Cocoa and Swift data types. Those data types
    that can be used interchangeably or converted are called bridged data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swift also provides an overlay for working with Foundation data types. This
    lets us work with Foundation data types in a way that feels more like native Swift
    types. If we need to use these Foundation data types, we need to add the following
    import statement to the top of the Swift file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at how to work with some common Cocoa data types.
  prefs: []
  type: TYPE_NORMAL
- en: NSNumber
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift will automatically bridge certain native numeric types, such as Int,
    UInt, Float, Bool, and Double to an `NSNumber` object. This allows us to pass
    these native numeric types to arguments that expect an `NSNumber` object. This
    automatic bridging only works one way because an `NSNumber` object can contain
    various numeric types; therefore, the Swift compiler will not know which numeric
    type to convert the `NSNumber` into. The following examples show how to go from
    a native Swift Int and Double to an `NSNumber`, and how to convert it back to
    the Swift Int and Double. Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, Swift automatically converts the `inum` and `dnum` to
    `NSNumber` objects without any typecasting; however, when we try to convert the
    `NSNumber` objects back to `Int` or `Double` types of Swift, we need to typecast
    the `NSNumber` objects to tell Swift what type of numbers we are converting into.
  prefs: []
  type: TYPE_NORMAL
- en: NSString
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift will automatically bridge its native `String` type to a `NSString` type;
    however, it will not automatically bridge an `NSString` object to the native String
    type. This allows us to pass the native string type to arguments that expect an
    `NSString` object. Therefore, when we use mix and match to integrate the Objective-C
    APIs with our Swift project, it automatically converts `String` types to the `NSString`
    objects when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This automatic bridging allows us to call the `NSString` methods on our Swift
    strings. Swift automatically converts the string to an `NSString` object and calls
    the method. The following example shows how to convert our string value to a C
    string using the `cStringUsingEncoding()` method that comes from the `NSString`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert an `NSString` object to a string type, we will use the `as` keyword.
    Since an `NSString` object can always be converted to a string type, we do not
    need to use the optional version of this typecasting operator (`as?`). The following
    example shows how to convert an `NSString` object to a string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, we convert an `NSString` object to a native Swift string
    type, and then call the `toInt()` method, from the Swift string type, to convert
    the string to an integer, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `num` variable will contain the number `1234` and
    not the string `1234`.
  prefs: []
  type: TYPE_NORMAL
- en: NSArray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift will automatically bridge between the `NSArray` class and the Swift native
    array type. Since the elements of an `NSArray` object are not required to be of
    the same type, when we bridge from an `NSArray` object to a Swift array, the elements
    of the Swift array are set to the `[AnyObject]` type. The `[AnyObject]` type is
    an object that is an instance of an Objective-C or Swift class or can be bridged
    to one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we can create an `NSArray` object in Swift
    that contains both string and Int types and then creates a Swift array from that
    `NSArray` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `nsarr: NSArray` contains four elements—`HI`, `There`,
    `1`, and `2`. In `nsarrNSArray`, two of the elements are string types and two
    are Int types. When we convert the nsarr: `NSArray` to a Swift array, the `arr`
    array becomes an array of `AnyObject` types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `NSArray` contains a specific object type, once it is bridged to a Swift
    array, we can downcast the Swift array of `[AnyObject]` to a Swift array of the
    specific object types. The only catch to this downcasting is if any element of
    the array is not of the object type specified, the downcasting will fail and the
    new array will be set to nil. The following example shows how to downcast an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `newarr` will be an array of strings that contains
    two elements. Now, let''s change the original `NSArray` to include two integers
    as well as the two strings. The new code will now look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Since the original `NSArray` defines an array of both strings and integers,
    when we attempt to downcast the Swift array from an array of `[AnyObject]` to
    an array of string, the downcasting fails and the `newarr` variable is set to
    nil.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `as?` keyword to cast an `NSArray` object as an array type,
    it is recommended that we use optional binding since it is possible to receive
    a nil value. The following example illustrates how to do this cast with optional
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now let's look at the `NSDictionary` object and how we can use it within our
    Swift code.
  prefs: []
  type: TYPE_NORMAL
- en: NSDictionary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use the `as` and `as?` keywords to convert between an `NSDictionary` object
    and a Swift dictionary type. The following example shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we create an `NSDictionary` object that contains two
    key-value pairs. All of the keys and values in this `NSDictionary` object are
    String types. In the second line, the `nsdic2as? [String: String]` converts the
    `NSDictionary` object to a dictionary type where both the keys and the values
    are String types. We then convert the dictionary type back to an `NSDictionaryobject`
    using the `as` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we used optional binding when we converted the `NSDictionary`
    object to a dictionary type because if any of the values in the `NSDictionary`
    object were not of the String type, the conversion would have failed. The following
    example illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the conversion fails because one of the values is an integer
    type and not a String type. When we do the conversion from an `NSDictionary` object
    to a Swift dictionary we use the `as?` keyword because the conversion may fail,
    but when we convert from a Swift dictionary to an `NSDictionary` object, we use
    the `as` keyword because the conversion is always successful.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at how we would use Foundation data types with Swift.
  prefs: []
  type: TYPE_NORMAL
- en: Foundation data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using Foundation data types, Swift provides an overlay that makes interacting
    with them feel like they are native Swift types. We use this overlay to interact
    with Foundation types, such as `CGSize` and `CGRect` for iOS applications (`NSSize`
    and `NSRect` for OS X applications). When developing iOS or OS X applications,
    we will interact with Foundation data types on a regular basis, so it is good
    to see this overlay in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to initialize some Foundation data types. The following
    example defines `NSRange`, `CGRect`, and `NSSize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The overlay also lets us access the properties and functions in a way that
    feels like native Swift types. The following example shows us how to access the
    properties and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we initialize a `CGRect` type. We then change the property
    of `x` from `10` to `20`, retrieve the value of the `maxY` property, and check
    the `isEmpty` property to see whether we have a valid `CGRect` type.
  prefs: []
  type: TYPE_NORMAL
- en: We just barely scratched the surface of the interoperability between Swift and
    Objective-C. We will discuss this interoperability in depth in [Chapter 13](ch13.html
    "Chapter 13. Using Mix and Match"), *Using Mix and Match*, later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered Swift collections, tuples, Foundation, and Cocoa
    data types. Having a good understanding of the native collection types of Swift
    is essential to architect and develop applications in Swift since all but the
    very basic applications use collections to store data in memory.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Swift is exclusively used for developing applications
    in an Apple (iOS or OS X) environment, so it is essential to understand how Swift
    interacts with Cocoa and Foundation types. While we briefly covered this subject
    in this chapter, we will look at this interaction more in depth in [Chapter 13](ch13.html
    "Chapter 13. Using Mix and Match"), *Using Mix and Match*, later in this book.
  prefs: []
  type: TYPE_NORMAL
