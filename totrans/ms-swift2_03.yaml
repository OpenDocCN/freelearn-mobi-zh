- en: Chapter 3. Using Collections and Cocoa Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。使用集合和 Cocoa 数据类型
- en: Once I got past the basic Hello World beginner applications, I quickly began
    to realize the shortcomings of variables, especially with the Mad Libs style applications
    that I was starting to write. These applications requested that the user enter
    in numerous strings, and I was creating a separate variable for each input field
    that the user entered. Having all of these separate variables quickly became very
    cumbersome. I remember talking to a friend about this and he asked me why I was
    not using arrays. At that time, I was not familiar with arrays, so I asked him
    to show me what they were. Even though he had a TI-99/4A and I had a Commodore
    Vic-20, the concept of arrays was the same. Even today, the arrays found in modern
    development languages have the same basic concepts as the arrays I used on my
    Commodore Vic-20\. While it is definitely possible to create a useful application
    without using collections, when used right, collections do make application development
    significantly easier.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我超越了基本的 Hello World 初学者应用程序，我很快就开始意识到变量的不足，尤其是在我刚开始编写的 Mad Libs 风格的应用程序中。这些应用程序要求用户输入多个字符串，我为每个用户输入的字段创建了一个单独的变量。拥有所有这些单独的变量很快就变得非常繁琐。我记得和一个朋友谈论过这件事，他问我为什么不用数组。当时，我对数组不熟悉，所以我让他给我展示一下它们是什么。尽管他有一个
    TI-99/4A，而我有一个 Commodore Vic-20，但数组的概念是相同的。即使今天，现代开发语言中的数组与我在 Commodore Vic-20
    上使用的数组具有相同的基本概念。虽然确实可以不使用集合创建一个有用的应用程序，但正确使用集合确实可以使应用程序开发变得更加容易。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What an array is in Swift and how to use it
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中的数组是什么以及如何使用它
- en: What a dictionary is in Swift and how we can use it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中的字典是什么以及我们如何使用它
- en: What a Set is in Swift and how we can use it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中的集合是什么以及我们如何使用它
- en: What a tuple is in Swift and how we can use it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift 中的元组是什么以及我们如何使用它
- en: How to use Cocoa data types in Swift
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Swift 中使用 Cocoa 数据类型
- en: How to use Foundation data types in Swift
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Swift 中使用 Foundation 数据类型
- en: Swift collection types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 集合类型
- en: A collection is a group or store of data that has a shared significance. Swift
    provides three native collection types for storing data. These collection types
    are arrays, sets, and dictionaries. An array stores the data in an ordered list,
    sets are an unordered collection of unique data, and dictionaries are an unordered
    collection of key/value pairs. In an array, we access the data by the location
    (index) in the array; in a set, we tend to iterate over the set; and dictionaries
    are usually accessed using a unique key.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一组或存储具有共同意义的数据。Swift 提供了三种原生集合类型来存储数据。这些集合类型是数组、集合和字典。数组按顺序存储数据，集合是无序的唯一数据集合，字典是无序的键/值对集合。在数组中，我们通过数组中的位置（索引）访问数据；在集合中，我们倾向于遍历集合；而字典通常使用唯一键来访问。
- en: The data stored in a Swift collection is required to be of the same type. This
    means, as an example, that we are unable to store a string value and an array
    of integers. Since Swift does not allow us to mismatch data types in a collection,
    we can be certain of the data type when we retrieve data from a collection. This
    is another feature, which on the surface might seem like a shortcoming, but is
    actually a design feature that helps eliminate common programming mistakes. We
    will see how to work around this feature by using the `AnyObject` and `Any` aliases
    in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 Swift 集合中的数据必须具有相同的类型。这意味着，例如，我们无法存储一个字符串值和一个整数数组。由于 Swift 不允许我们在集合中混合数据类型，当我们从集合中检索数据时，我们可以确定数据类型。这是另一个表面上看可能像是一个缺点，但实际上是一个设计特性，有助于消除常见的编程错误。在本章中，我们将看到如何通过使用
    `AnyObject` 和 `Any` 别名来绕过这个特性。
- en: Mutability
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变性
- en: For those who are familiar with Objective-C, you will know that there are different
    classes for mutable and immutable collections. For example, to define a mutable
    array, we use the `NSMutableArray` class, and to define an immutable array, we
    use the `NSArray` class. Swift is a little different because it does not contain
    separate classes for mutable and immutable collections. Instead, we define whether
    a collection is constant (immutable) or a variable (mutable) by using the `let`
    and `var` keywords. This should seem familiar since, in Swift, we define constants
    with the `let` keyword and variables with the `var` keyword.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Objective-C 的人来说，你们会知道存在不同的类来表示可变和不可变集合。例如，要定义一个可变数组，我们使用 `NSMutableArray`
    类，而要定义一个不可变数组，我们使用 `NSArray` 类。Swift 与之不同，因为它没有为可变和不可变集合提供单独的类。相反，我们通过使用 `let`
    和 `var` 关键字来定义集合是常量（不可变）还是变量（可变）。这在 Swift 中应该看起来很熟悉，因为，在 Swift 中，我们使用 `let` 关键字定义常量，使用
    `var` 关键字定义变量。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is good practice to create immutable collections unless there is a specific
    need to change the objects within the collection. This allows the compiler to
    optimize the performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的需求需要更改集合中的对象，否则创建不可变集合是一种良好的实践。这允许编译器优化性能。
- en: Let's begin our tour of collections by looking at the most common collection
    type—the array type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的集合之旅，先看看最常见的集合类型——数组类型。
- en: Arrays
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: Arrays are a very common component of modern programming languages and can be
    found virtually in all the modern programming languages. In Swift, arrays are
    an ordered list of objects of the same type. This is different from the `NSArray`
    class in Objective-C, which can contain objects of different types.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是现代编程语言中非常常见的组件，几乎可以在所有现代编程语言中找到。在 Swift 中，数组是相同类型对象的有序列表。这与 Objective-C 中的
    `NSArray` 类不同，后者可以包含不同类型的对象。
- en: When an array is created, we must declare the type of data to be stored in it
    by explicit type declaration or through type inference. Typically, we only explicitly
    declare the data type of an array when we are creating an empty array. If we initialize
    an array with data, we should let the compiler use type inference to infer the
    most appropriate data type for the array.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建数组时，我们必须通过显式类型声明或通过类型推断来声明要存储在其中的数据类型。通常，我们只在创建空数组时显式声明数组的数据类型。如果我们用数据初始化数组，我们应该让编译器使用类型推断来推断最合适的数组数据类型。
- en: Each object in an array is called an element. Each of these elements is stored
    in a set order and can be accessed by its location (index) in the array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每个对象称为一个元素。这些元素按照一定的顺序存储，可以通过其在数组中的位置（索引）来访问。
- en: Creating and initializing arrays
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和初始化数组
- en: 'We can initialize an array with an array literal. An array literal is a set
    of values that we prepopulate the array with. The following example shows how
    to define an immutable array of integers using the `let` keyword:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用数组字面量来初始化一个数组。数组字面量是一组我们预先填充到数组中的值。以下示例展示了如何使用 `let` 关键字定义一个不可变的整数数组：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we mentioned, if we need to create a mutable array, we will use the `var`
    keyword to define the array. The following example shows how to define a mutable
    array:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，如果我们需要创建一个可变数组，我们将使用 `var` 关键字来定义数组。以下示例展示了如何定义一个可变数组：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding two examples, the compiler inferred the type of values stored
    in the array by looking at the type of values stored in the array literal. If
    we needed to create an empty array, we will need to explicitly declare the type
    of values to store in the array. The following example shows how to declare an
    empty array that can be used to store integers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个示例中，编译器通过查看数组字面量中存储的值的类型来推断数组中存储的值的类型。如果我们需要创建一个空数组，我们需要显式声明要存储在数组中的值的类型。以下示例展示了如何声明一个可以用来存储整数的空数组：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding examples, we created arrays with integer values, and the majority
    of the array examples in this chapter will also use integer values; however, we
    can create arrays in Swift with any type. The only rule is that once an array
    is defined as containing a particular type, all the elements in the array must
    be of that type. The following example shows how we would create arrays of various
    data types:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用整数值创建了数组，本章中的大多数数组示例也将使用整数值；然而，我们可以在 Swift 中使用任何类型创建数组。唯一的规则是，一旦定义了一个数组包含特定类型，数组中的所有元素都必须是那种类型。以下示例展示了如何创建各种数据类型的数组：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Swift does provide special type aliases for working with nonspecific types.
    These aliases are `AnyObject` and `Any`. We can use these aliases to define arrays
    whose elements are of different types, like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Swift确实提供了用于处理非特定类型的特殊类型别名。这些别名是`AnyObject`和`Any`。我们可以使用这些别名来定义元素类型不同的数组，如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We should use the `Any` and `AnyObject` aliases only when there is an explicit
    need for this behavior. It is always better to be specific about the types of
    data our collections contain.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只在明确需要这种行为时才使用`Any`和`AnyObject`别名。始终明确我们集合中包含的数据类型是更好的做法。
- en: 'We can also initialize an array to a certain size with all the elements of
    the array set to a predefined value. This can be very useful if we want to create
    an array and prepopulate it with the default values. The following example defines
    an array with seven elements, and each element contains the number `3`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以初始化一个数组，使其具有特定的大小，并且将数组中的所有元素都设置为预定义的值。如果我们想创建一个数组并预先填充默认值，这会非常有用。以下示例定义了一个包含七个元素的数组，每个元素都包含数字`3`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While the most common array is a one-dimensional array, we can also create
    multidimensional arrays. A multidimensional array is really nothing more than
    an array of arrays. For example, a two-dimensional array is an array of arrays,
    while a three-dimensional array is an array of arrays of arrays. The following
    examples show the two ways to create a two-dimensional array in Swift:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最常见的数组是一维数组，但我们也可以创建多维数组。多维数组实际上不过是一个数组的数组。例如，二维数组是一个数组的数组，而三维数组是一个数组的数组的数组。以下示例展示了在Swift中创建二维数组的两种方式：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Accessing the array elements
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组元素
- en: 'We use the subscript syntax to retrieve values from an array. The subscript
    syntax for an array is where a number appears between two square brackets and
    that number specifies the location (index), within the array, of the element we
    wish to retrieve. The following example shows how to retrieve elements from an
    array using the subscript syntax:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下标语法来从数组中检索值。数组的下标语法是，一个数字出现在两个方括号之间，这个数字指定了我们想要检索的元素在数组中的位置（索引）。以下示例展示了如何使用下标语法从数组中检索元素：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we begin by creating an array of integers that contains
    six numbers. We then print out the value at index `0` and `3`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先创建了一个包含六个整数的数组。然后我们打印出索引`0`和`3`的值。
- en: 'If we want to retrieve an individual value within a multidimensional array,
    we will need to provide a subscript for each dimension. If we did not provide
    a subscript for each dimension, we will return an array rather than an individual
    value within the array. The following example shows how we can define a two-dimensional
    array and retrieve an individual value within the two dimensions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从多维数组中检索单个值，我们需要为每个维度提供一个下标。如果我们没有为每个维度提供下标，我们将返回一个数组，而不是数组中的单个值。以下示例展示了我们如何定义一个二维数组，并在两个维度中检索单个值：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we begin by defining a two-dimensional array. When we
    retrieve the value at index `0` of the first dimension (`multiArray[0]`), we retrieve
    the array, `[1,2]`. When we retrieve the value at index `0` of the first dimension
    and index `1` of the second dimension (`multiArray[0][1]`), we retrieve the integer,
    `2`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们首先定义了一个二维数组。当我们检索第一维索引`0`的值（`multiArray[0]`）时，我们检索到的是数组`[1,2]`。当我们检索第一维索引`0`和第二维索引`1`的值（`multiArray[0][1]`）时，我们检索到的是整数`2`。
- en: 'We can retrieve the first and last elements of an array using the `first` and
    `last` properties. The `first` and `last` properties return an optional value
    since the values may be nil if the array is empty. The following example shows
    how to use the `first` and `last` properties to retrieve the first and last elements
    of both single-dimensional and multidimensional arrays:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`first`和`last`属性来检索数组的第一个和最后一个元素。由于数组可能为空，`first`和`last`属性返回的是可选值。以下示例展示了如何使用`first`和`last`属性来检索单维和多维数组的第一和最后一个元素：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Counting the elements of an array
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算数组的元素
- en: 'At times, it is essential to know the number of elements in an array. To retrieve
    the number of elements, we would use the read-only `count` property. The following
    example shows how to use this property to retrieve the number of elements in both
    single-dimensional and multidimensional arrays:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，知道数组中的元素数量是至关重要的。要获取元素数量，我们会使用只读的`count`属性。以下示例展示了如何使用此属性来检索单维和多维数组中的元素数量：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The value that is returned by the `count` property is the number of elements
    in the array and not the largest valid index of the array. For nonempty arrays,
    the largest valid index is the number of elements in the array minus one. This
    is because the first element of the array has an index number of zero. As an example,
    if an array has two elements, the valid indexes are `0` and `1`, while the count
    property would return `2`. The following code illustrates this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`属性返回的是数组中的元素数量，而不是数组的最大有效索引。对于非空数组，最大有效索引是数组元素数量减一。这是因为数组的第一个元素索引号为零。例如，如果一个数组有两个元素，有效的索引是`0`和`1`，而`count`属性将返回`2`。以下代码说明了这一点：'
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we attempt to retrieve an element from an array, using the subscript syntax,
    where the index is outside the range of the array, the application will throw
    an `Array index out of range` error. Therefore, if we are unsure of the size of
    an array, it is good practice to verify that the index is not outside the range
    of the array. The following examples illustrate this concept:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用下标语法从数组中检索一个元素，而该索引超出了数组的范围，应用程序将抛出`Array index out of range`错误。因此，如果我们不确定数组的大小，验证索引是否不在数组范围之外是一种良好的做法。以下示例说明了这个概念：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, the first block of code would throw an `array index out
    of range` error exception because we are attempting to access the value from the
    array `arrayTwo` at index `6`; however, there are only four elements in the array.
    The second example would not throw the `array index out of range` error exception
    because we are checking whether the `arrayOne` array contains more than six elements,
    and if it does not, we do not attempt to access the value at index `6`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一段代码会抛出一个`数组索引超出范围`错误异常，因为我们试图从`arrayTwo`数组中访问索引为`6`的值；然而，该数组中只有四个元素。第二个例子不会抛出`数组索引超出范围`错误异常，因为我们正在检查`arrayOne`数组是否包含超过六个元素，如果没有，我们就不尝试访问索引`6`的值。
- en: Is the array empty?
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组是否为空？
- en: 'To check whether an array is empty (does not contain any elements), we use
    the `isEmpty` property. This property will return `true` if the array is empty,
    or `false` if it has elements. The following example shows how to check whether
    an array is empty or not:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查数组是否为空（不包含任何元素），我们使用`isEmpty`属性。如果数组为空，该属性将返回`true`；如果它包含元素，则返回`false`。以下示例展示了如何检查数组是否为空：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Appending to an array
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追加到数组
- en: 'A static array is somewhat useful, but having the ability to add elements dynamically
    is what makes arrays really useful. To add an item to the end of an array, we
    can use the `append` method. The following example shows how to append an item
    to the end of an array:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数组有些有用，但能够动态地添加元素才是数组真正有用的地方。要向数组的末尾添加一个项目，我们可以使用`append`方法。以下示例展示了如何将项目追加到数组的末尾：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Swift also allows us to use the addition assignment operator (`+=`) to append
    an array to another array. The following example shows how to use the addition
    assignment operator to append an array to the end of another array:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Swift还允许我们使用加法赋值运算符（`+=`）将一个数组追加到另一个数组中。以下示例展示了如何使用加法赋值运算符将数组追加到另一个数组的末尾：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The way you append an element to the end of an array is really up to you. Personally,
    I prefer the assignment operator because, to me, it is a bit easier to read, but
    we will be using both in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将元素追加到数组末尾的方式完全取决于你。我个人更喜欢赋值运算符，因为它对我来说更容易阅读，但在这本书中我们将使用两种方式。
- en: Inserting a value into an array
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组中插入值
- en: 'We can insert a value into an array by using the `insert` method. The `insert`
    method will move all the items, starting at the specified index up one spot, to
    make room for the new element and then inserts the value into the specified index.
    The following example shows how to use the insert method to insert a new value
    into an array:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`insert`方法将值插入到数组中。`insert`方法将移动从指定索引开始的所有项目，向上移动一个位置，为新元素腾出空间，然后将值插入到指定索引。以下示例展示了如何使用`insert`方法将新值插入到数组中：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot insert a value that is outside the current range of the array. Attempting
    to do so will throw an `Index out of range exception`. For example, in the preceding
    code, if we attempt to insert a new integer at index 10, we will receive an `Index
    out of range exception error` because `arrayOne` only contains five elements.
    The exception to this is that we are able to insert an item directly after the
    last element; therefore, we can insert an item at index `6`. However, it is recommended
    that we use the `append` function to append an item to avoid errors.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能插入超出数组当前范围的值。尝试这样做将抛出`索引超出范围异常`。例如，在先前的代码中，如果我们尝试在索引10处插入一个新的整数，我们将收到一个`索引超出范围异常错误`，因为`arrayOne`只包含五个元素。这个例外是我们能够直接在最后一个元素之后插入一个项；因此，我们可以将项插入到索引`6`。然而，建议我们使用`append`函数来追加项以避免错误。
- en: Replacing elements in an array
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换数组中的元素
- en: 'We use the subscript syntax to replace elements in an array. Using the subscript,
    we pick the element of the array we wish to update and then use the assignment
    operator to assign a new value. The following example shows how we will replace
    a value in an array:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下标语法来替换数组中的元素。使用下标，我们选择要更新的数组元素，然后使用赋值运算符分配新值。以下示例展示了我们如何在数组中替换一个值：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot update a value that is outside the current range of the array. Attempting
    to do so will throw the same `Index out of range` exception that was thrown when
    we tried to insert a value outside the range of the array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能更新超出数组当前范围的值。尝试这样做将抛出我们在尝试在数组范围之外插入值时抛出的相同的`索引超出范围`异常。
- en: Removing elements from an array
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中删除元素
- en: 'There are three methods that we can use to remove one or all the elements in
    an array. These methods are `removeLast()`, `removeAtIndex()`, and `removeAll()`.
    The following example shows how to use the three methods to remove elements from
    the array:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三种方法来从数组中删除一个或所有元素。这些方法是`removeLast()`、`removeAtIndex()`和`removeAll()`。以下示例展示了如何使用这三种方法从数组中删除元素：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `removeLast()` and `removeAtIndex()` methods will also return the value
    of the element that it is removing. Therefore, if we want to know the value of
    the item that was removed, we can rewrite the `removeAtIndex` and `removedLast`
    lines to capture the value, as shown in the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeLast()`和`removeAtIndex()`方法也会返回它正在删除的元素的值。因此，如果我们想了解被删除项的值，我们可以重写`removeAtIndex`和`removeLast`行来捕获该值，如下面的示例所示：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Adding two arrays
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加两个数组
- en: 'To create a new array by adding two arrays together, we use the addition (`+`)
    operator. The following example shows how to use the addition (`+`) operator to
    create a new array that contains all the elements of two other arrays:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过将两个数组相加来创建一个新数组，我们使用加法（`+`）运算符。以下示例展示了如何使用加法（`+`）运算符创建一个包含两个其他数组所有元素的新数组：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, `arrayOne` and `arrayTwo` are left unchanged, while the
    combine array contains the elements from `arrayOne`, followed by the elements
    from `arrayTwo`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，`arrayOne`和`arrayTwo`保持不变，而组合数组包含来自`arrayOne`的元素，然后是来自`arrayTwo`的元素。
- en: Reversing an array
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转数组
- en: 'We can create a new array from the original array with the elements in reverse
    order using the `reverse()` method. The original array will remain unchanged by
    the `reverse` method. The following example shows how to use the `reverse()` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`reverse()`方法从原始数组中创建一个新数组，其元素顺序相反。`reverse`方法不会改变原始数组。以下示例展示了如何使用`reverse()`方法：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding code, the elements of `arrayOne` are left unchanged, while
    the `reverse` array will contain all the elements from `arrayOne`, but in the
    reverse order.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码中，`arrayOne`的元素保持不变，而`reverse`数组将包含来自`arrayOne`的所有元素，但顺序相反。
- en: Retrieving a subarray from an array
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中检索子数组
- en: 'We can retrieve a `subarray` from an existing array by using the subscript
    syntax with a range. The following example shows how to retrieve a range of elements
    from an existing array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用带有范围的下标语法从现有数组中检索`子数组`。以下示例展示了如何从现有数组中检索一系列元素：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `…` operator (three periods) is known as a range operator. The range operator,
    in the preceding code, says I want all the elements, `2` to `4`, inclusively (included
    elements 2 and 4 as well as what is between them). There is another range operator,
    which is `..<`, the same as the `…` range operator, but it excludes the last element.
    The following example shows how to use the `.<` operator.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`…` 运算符（三个点）被称为范围运算符。在前面代码中，范围运算符表示我想要所有元素，从 `2` 到 `4`（包括元素 `2` 和 `4` 以及它们之间的所有元素）。还有一个范围运算符，即
    `..<`，它与 `…` 范围运算符相同，但它排除了最后一个元素。以下示例展示了如何使用 `.<` 运算符。'
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example, the `subArray` will contain two elements `3` and `4`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`subArray` 将包含两个元素 `3` 和 `4`。
- en: Making bulk changes to an array
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数组进行批量更改
- en: We can use the subscript syntax with a range operator to change the values of
    multiple elements. The following example shows how to use the subscript syntax
    to change a range of elements.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用下标语法和范围运算符来更改多个元素的值。以下示例展示了如何使用下标语法来更改一系列元素的值。
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, the elements at index `1` and `2` will be changed to
    number `12` and `13`. After this, when the code runs, `arrayOne` will contain
    `1`, `12`, `13`, `4`, and `5`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，索引 `1` 和 `2` 处的元素将被更改为数字 `12` 和 `13`。之后，当代码运行时，`arrayOne` 将包含 `1`、`12`、`13`、`4`
    和 `5`。
- en: 'The number of elements that you are changing in the range operator does not
    need to match the number of values that you are passing in. Swift makes the bulk
    changes—it first removes the elements defined by the range operator and then inserts
    the new values. The following example demonstrates this concept:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在范围运算符中更改的元素数量不需要与传递的值的数量相匹配。Swift 会进行批量更改——它首先移除由范围运算符定义的元素，然后插入新的值。以下示例演示了这一概念：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, `arrayOne` starts with five elements. We then say that
    we want to replace the range of elements `1` to `3` inclusively. This causes elements
    `1` to `3` (three elements) to be removed from the array. We then add two elements
    (`12` and `13`) to the array, starting at index `1`. After this is complete, `arrayOne`
    will contain these four elements: `1`, `12`, `13`, and `5`. Let''s see what happens
    if we try to add more elements than we remove:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`arrayOne` 有五个元素。然后我们说我们想要替换从元素 `1` 到 `3`（包括 `1` 和 `3`）的范围。这导致数组中从元素
    `1` 到 `3`（共三个元素）被移除。然后我们在索引 `1` 处向数组中添加两个元素（`12` 和 `13`）。完成这些操作后，`arrayOne` 将包含以下四个元素：`1`、`12`、`13`
    和 `5`。让我们看看如果我们尝试添加比移除更多的元素会发生什么：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding code, `arrayOne` starts with five elements. We then say that
    we want to replace the range of elements `1` to `3` inclusively. This causes elements
    `1` to `3` (three elements) to be removed from the array. We then add four elements
    (`12`, `13`, `14`, and `15`) to the array, starting at index `1`. After this is
    complete, `arrayOne` will contain these six elements: `1`, `12`, `13`, `14`, `15`,
    and `5`.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`arrayOne` 有五个元素。然后我们说我们想要替换从元素 `1` 到 `3`（包括 `1` 和 `3`）的范围。这导致数组中从元素
    `1` 到 `3`（共三个元素）被移除。然后我们在索引 `1` 处向数组中添加四个元素（`12`、`13`、`14` 和 `15`）。完成这些操作后，`arrayOne`
    将包含以下六个元素：`1`、`12`、`13`、`14`、`15` 和 `5`。
- en: Algorithms for arrays
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组算法
- en: Swift arrays have several methods that take a closure as the argument. These
    methods transform the array and the closures affect how the array is transformed.
    Closures are self-contained blocks of code that can be passed around, and are
    similar to blocks in Objective-C and lambdas in other languages. We will discuss
    closures in depth in [Chapter 12](ch12.html "Chapter 12. Working with Closures"),
    *Working with Closures*. For now, we just want to get familiar with how the algorithms
    work in Swift.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 数组有几种方法，这些方法接受一个闭包作为参数。这些方法会转换数组，而闭包会影响数组如何被转换。闭包是包含代码的独立块，可以传递，类似于 Objective-C
    中的 blocks 和其他语言中的 lambdas。我们将在第 12 章[使用闭包](ch12.html "第 12 章。使用闭包")中深入讨论闭包。现在，我们只想熟悉
    Swift 中算法的工作方式。
- en: sortInPlace
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sortInPlace
- en: 'The sortInPlace algorithm sorts the array in place. This means when the `sortInPlace()`
    method is used, the original array is replaced by the sorted one. The closure
    takes two arguments (represented by `$0` and `$1`), and it should return a Boolean
    value that indicates whether the first element should be placed before the second
    element. The following code shows how to use the sort algorithm:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`sortInPlace`算法在原地排序数组。这意味着当使用`sortInPlace()`方法时，原始数组将被排序后的数组替换。闭包接受两个参数（分别由`$0`和`$1`表示），并且它应该返回一个布尔值，表示第一个元素是否应该放在第二个元素之前。以下代码展示了如何使用排序算法：'
- en: '[PRE27]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code will sort the array in increasing order. We can tell this
    because our rule will return `true` if the first number (`$0`) is less than the
    second number (`$1`). Therefore, when the sort algorithm begins, it compares the
    first two numbers (`9` and `3`) and returns `true` if the first number (`9`) is
    less than the second number (`3`). In our case, the rule returns `false`, so the
    numbers are reversed. The algorithm continues sorting, in this manner, until all
    of the numbers are sorted.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将数组按升序排序。我们可以通过我们的规则来判断，如果第一个数字（`$0`）小于第二个数字（`$1`），则返回`true`。因此，当排序算法开始时，它比较前两个数字（`9`和`3`），如果第一个数字（`9`）小于第二个数字（`3`），则返回`true`。在我们的例子中，规则返回`false`，所以数字被反转。算法以这种方式继续排序，直到所有数字都排序完成。
- en: 'The preceding example sorted the array in numerically increasing order; if
    we wanted to reverse the order, we would reverse the arguments in the closure.
    The following code shows how to reverse the sort order:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例按数值升序排序了数组；如果我们想反转顺序，我们会在闭包中反转参数。以下代码展示了如何反转排序顺序：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When we run this code, `arrayOne` will contain the elements `9`, `8`, `6`, `5`,
    `3`, and `2`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，`arrayOne`将包含元素`9`、`8`、`6`、`5`、`3`和`2`。
- en: sort
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sort`'
- en: 'While the sortInPlace algorithm sorts the array in place (replaces the original
    array), the `sort` algorithm does not change the original array, it instead creates
    a new array with the sorted elements from the original array. The following example
    shows how to use the sorted algorithm:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sortInPlace`算法在原地排序数组（替换原始数组），但`sort`算法不会改变原始数组，它而是创建一个新的数组，包含原始数组中的排序元素。以下示例展示了如何使用排序算法：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we run this code, `arrayOne` will contain the original unsorted array (`9`,
    `3`, `6`, `2`, `8`, and `5`) and the sorted array will contain the new sorted
    array (`2`, `3`, `5`, `6`, `8`, and `9`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此代码时，`arrayOne`将包含原始未排序数组（`9`、`3`、`6`、`2`、`8`和`5`），而排序后的数组将包含新的排序数组（`2`、`3`、`5`、`6`、`8`和`9`）。
- en: filter
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`filter`'
- en: 'The filter algorithm will return a new array by filtering the original array.
    This is one of the most powerful array algorithms and may end up to be the one
    we use the most. If we need to retrieve a subset of an array, based on a set of
    rules, I recommend using this algorithm rather than trying to write your own method
    to filter the array. The closure takes one argument and it should return a Boolean
    `true` if the element should be included in the new array, as shown in the following
    code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`算法将通过过滤原始数组来返回一个新的数组。这是最强大的数组算法之一，最终可能会成为我们使用最多的算法之一。如果我们需要根据一组规则从数组中检索子集，我建议使用此算法，而不是尝试编写自己的方法来过滤数组。闭包接受一个参数，并且如果元素应该包含在新数组中，它应该返回布尔值`true`，如下所示：'
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code, the rule that we are passing to the algorithm returns
    `true` if the number is greater than `3` or less than `7`; therefore, any number
    that is greater than `3` or less than `7` is included in the new filtered array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们传递给算法的规则返回`true`，如果数字大于`3`或小于`7`；因此，任何大于`3`或小于`7`的数字都包含在新的过滤数组中。
- en: 'Let''s take a look at another example; this one shows how we can retrieve a
    subset of cities that contain the letter o in their name from an array of cities:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子；这个例子展示了如何从一个城市数组中检索出名字中包含字母o的子集：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we use the `rangeOfString()` method to return `true`
    if the string contains the letter o. If the method returns `true`, the string
    is included in the filtered array.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`rangeOfString()`方法来返回`true`，如果字符串包含字母o。如果方法返回`true`，则字符串包含在过滤数组中。
- en: map
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`map`'
- en: 'The map algorithm returns a new array that contains the results of applying
    the rules in the closure to each element of the array. The following example shows
    how to use the map algorithm to divide each number by `10`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: map算法返回一个新数组，该数组包含将闭包中的规则应用于数组中每个元素的结果。以下示例展示了如何使用map算法将每个数字除以`10`：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, the new array contains the numbers `1`, `2`, `3`, and
    `4`, which is the result of dividing each element of the original array by `10`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，新数组包含数字`1`、`2`、`3`和`4`，这是通过将原始数组中的每个元素除以`10`得到的结果。
- en: 'The new array created by the map algorithm is not required to contain the same
    element types as the original array; however, all the elements in the new array
    must be of the same type. In the following example, the original array contains
    integer values, but the new array created by the map algorithm contains string
    elements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过map算法创建的新数组不需要包含与原始数组相同的元素类型；然而，新数组中的所有元素必须属于同一类型。在以下示例中，原始数组包含整数值，但通过map算法创建的新数组包含字符串元素：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we created an array of strings that appends the numbers
    from the original array to the `num:`string.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个字符串数组，它将原始数组中的数字追加到`num:`字符串中。
- en: forEach
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forEach
- en: 'We can use `forEach` to iterate over a sequence. The following example shows
    how we would do this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`forEach`来遍历一个序列。以下示例展示了我们如何这样做：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This example will print the following results to the console:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将在控制台打印以下结果：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: While using the `forEach` method is very easy, it does have some limitations.
    The recommended way to iterate over an array is to use the `for-in` loop, which
    we will see in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`forEach`方法非常简单，但它确实有一些限制。推荐遍历数组的方式是使用`for-in`循环，我们将在下一节中看到。
- en: Iterating over an array
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'We can iterate over all elements of an array, in order, with a `for-in` loop.
    We will discuss the `for-in` loop in greater detail in [Chapter 4](ch04.html "Chapter 4. Control
    Flow and Functions"), *Control Flow and Functions*. The `for-in` loop will execute
    one or more statements for each element of the array. The following example shows
    how we would iterate over the elements of an array:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for-in`循环按顺序遍历数组的所有元素。我们将在[第4章](ch04.html "第4章。控制流和函数")中更详细地讨论`for-in`循环，*控制流和函数*。`for-in`循环将为数组中的每个元素执行一个或多个语句。以下示例展示了我们如何遍历数组的元素：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, the `for-in` loop iterates over the `arr` array and
    executes the `print(item)` line for each element in the array. If we run this
    code, it will display the following results in the console:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`for-in`循环遍历`arr`数组，并为数组中的每个元素执行`print(item)`行。如果我们运行此代码，它将在控制台显示以下结果：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are times when we would like to iterate over an array, as we did in the
    preceding example, but we would also like to know the index as well as the value
    of the element. To do this, we can use the `enumerate` method, which returns a
    tuple (see the *Tuples* section later in this chapter) for each item in the array
    that contains both `index` and `value` of the element. The following example shows
    how to use the `enumerate` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望像在前面示例中那样遍历数组，但同时也想了解元素的索引和值。为此，我们可以使用`enumerate`方法，该方法为数组中的每个元素返回一个元组（稍后在本章的*元组*部分将详细介绍），其中包含元素的`index`和`value`。以下示例展示了如何使用`enumerate`函数：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code will display the following results in the console:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在控制台显示以下结果：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we have introduced arrays in Swift, let's take a look at what a dictionary
    is.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Swift中的数组，让我们来看看什么是字典。
- en: Dictionaries
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: While dictionaries are not as commonly used as arrays, they have an additional
    functionality that makes them incredibly powerful. A dictionary is a container
    that stores multiple key-value pairs, where all the keys are of the same type,
    and all the values are of the same type. The key is used as a unique identifier
    for the value. A dictionary does not guarantee the order in which the key-value
    pairs are stored since we look up the values by the key, rather than by the index
    of the value.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字典不如数组常用，但它们具有额外的功能，这使得它们非常强大。字典是一个容器，存储多个键值对，其中所有键都是同一类型，所有值也都是同一类型。键用作值的唯一标识符。由于我们是通过键来查找值，而不是通过值的索引，因此字典不能保证键值对存储的顺序。
- en: 'Dictionaries are good for storing items that map to unique identifiers, where
    the unique identifier should be used to retrieve the item. As an example, countries
    with their abbreviations are a good example of items that can be stored in a dictionary.
    In the following chart, we show countries with their abbreviations as key-value
    pairs:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 字典适用于存储映射到唯一标识符的项目，其中唯一标识符应用于检索项目。例如，国家和它们的缩写是字典中可以存储的项目的好例子。在以下图表中，我们展示了国家和它们的缩写作为键值对：
- en: '| Key | Value |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 键 | 值 |'
- en: '| --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| US | United States |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| US | 美国 |'
- en: '| IN | India |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| IN | 印度 |'
- en: '| UK | United Kingdom |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| UK | 英国 |'
- en: Creating and initializing dictionaries
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和初始化字典
- en: 'We can initialize a dictionary using a dictionary literal, similar to how we
    initialized an array with the array literal. The following example shows how to
    create a dictionary using the key-value pairs in the preceding chart:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典字面量来初始化字典，类似于我们使用数组字面量初始化数组。以下示例展示了如何使用前面图表中的键值对创建字典：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code creates an immutable dictionary that contains each of the
    key-value pairs in the preceding chart. Just like the array, to create a mutable
    dictionary, we will use the `var` keyword rather than `let`. The following example
    shows how to create a mutable dictionary containing the countries:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个包含前面图表中每个键值对的不可变字典。就像数组一样，要创建可变字典，我们将使用 `var` 关键字而不是 `let`。以下示例展示了如何创建包含国家的可变字典：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding two examples, we created a dictionary where the key and value
    were both strings. The compiler inferred that the key and value were strings because
    that was the type of values we put in. If we wanted to create an empty dictionary,
    we would need to tell the compiler what the key and value types are. The following
    examples create various dictionaries with different key-value types:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个例子中，我们创建了一个键和值都是字符串的字典。编译器推断键和值是字符串，因为这是我们放入的类型。如果我们想创建一个空字典，我们需要告诉编译器键和值的类型。以下示例创建具有不同键值类型的各种字典：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If we want to use a custom object as the key in a dictionary, we will need to
    make our custom object conform to the Hashable protocol from Swift's standard
    library. We will discuss protocol and classes in [Chapter 5](ch05.html "Chapter 5. Classes
    and Structures"), *Classes and Structures*, but, for now, just understand that
    it is possible to use custom objects as a key in a dictionary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在字典中使用自定义对象作为键，我们需要让我们的自定义对象符合 Swift 标准库中的 Hashable 协议。我们将在[第 5 章](ch05.html
    "第 5 章。类和结构")*类和结构*中讨论协议和类，但就目前而言，只需了解可以使用自定义对象作为字典的键。
- en: Accessing dictionary values
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问字典值
- en: 'We use the subscript syntax to retrieve the value for a particular key. If
    the dictionary does not contain the key we are looking for, the dictionary will
    return `nil`; therefore, the variable returned from this lookup is an optional
    variable. The following example shows how to retrieve a value from a dictionary
    using its key in the subscript syntax:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下标语法来检索特定键的值。如果字典不包含我们正在寻找的键，字典将返回 `nil`；因此，从这个查找返回的变量是一个可选变量。以下示例展示了如何使用下标语法从字典中检索值：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, the variable name will contain the string, `United States`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，变量名将包含字符串，`United States`。
- en: Counting key or values in a dictionary
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在字典中计数键或值
- en: 'We use the `count` property of the dictionary to get the number of key-value
    pairs in the dictionary. The following example shows how to use the `count` property
    to retrieve the number of key-value pairs in the dictionary:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字典的 `count` 属性来获取字典中键值对的数量。以下示例展示了如何使用 `count` 属性来检索字典中键值对的数量：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, the `cnt` variable will contain the number `3` since
    there are three key-value pairs in the `countries` dictionary.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`cnt` 变量将包含数字 `3`，因为 `countries` 字典中有三个键值对。
- en: Is the dictionary empty?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典是否为空？
- en: 'To test whether the dictionary contains any key-value pairs at all, we can
    use the `isEmpty` property. The `isEmpty` property will return `false` if the
    dictionary contains one or more key-value pairs and `true` if it is empty. The
    following example shows how to use the `isEmpty` property to determine whether
    our dictionary contains any key-value pairs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试字典是否包含任何键值对，我们可以使用 `isEmpty` 属性。如果字典包含一个或多个键值对，则 `isEmpty` 属性将返回 `false`；如果它是空的，则返回
    `true`。以下示例显示了如何使用 `isEmpty` 属性来确定我们的字典是否包含任何键值对：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the preceding code, the `isEmpty` property is false as there are three key-value
    pairs in the countries dictionary.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`isEmpty` 属性为 `false`，因为国家字典中有三个键值对。
- en: Updating the value of a key
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新键的值
- en: 'To update the value of a key in a dictionary, we can either use the subscript
    syntax or the `updateValue(value:, forKey:)` method. The `updateValue(value:,
    forKey:)` method has an additional feature that the subscript syntax doesn''t—it
    returns the original value associated with the key prior to changing the value.
    The following example shows how to use both the subscript syntax and the `updateValue(value:,
    forKey:)` method to update the value of a key:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新字典中键的值，我们可以使用下标语法或 `updateValue(value:, forKey:)` 方法。`updateValue(value:,
    forKey:)` 方法有一个下标语法没有的附加功能——它在更改值之前返回与键关联的原始值。以下示例显示了如何使用下标语法和 `updateValue(value:,
    forKey:)` 方法来更新键的值：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding code, we use the subscript syntax to change the value associated
    with the key `UK` from `United Kingdom` to `Great Britain`. The original value
    of `United Kingdom` was not saved prior to replacing it, so we are unable to see
    what the original value is. We then used the `updateValue(value:, forKey:)` method
    to change the value associated with the key `UK` from `Great Britain to Britain`.
    With the `updateValue(value:, forKey:)` method, the original value of `Great Britain`
    is assigned to the `orig` variable, prior to changing the value in the dictionary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用下标语法将与键 `UK` 关联的值从 `United Kingdom` 更改为 `Great Britain`。在替换之前，我们没有保存
    `United Kingdom` 的原始值，因此我们无法看到原始值是什么。然后我们使用 `updateValue(value:, forKey:)` 方法将与键
    `UK` 关联的值从 `Great Britain` 更改为 `Britain`。使用 `updateValue(value:, forKey:)` 方法，在字典中更改值之前，将
    `Great Britain` 的原始值分配给 `orig` 变量。
- en: Adding a key-value pair
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加键值对
- en: 'To add a new key-value pair to a dictionary, we can use the subscript syntax
    or the same `updateValue(value:, forKey:)` method that we used to update the value
    of a key. If we use the `updateValue(value:, forKey:)` method and the key is not
    currently present in the dictionary, the `updateValue(value:, forKey:)` method
    will add a new key-value pair and return nil. The following example shows how
    to use the subscript syntax and also the `updateValue(value:, forKey:)` method
    to add a new key-value pair to a dictionary:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要向字典中添加一个新的键值对，我们可以使用下标语法或与更新键值值相同的 `updateValue(value:, forKey:)` 方法。如果我们使用
    `updateValue(value:, forKey:)` 方法，并且键当前不在字典中，则 `updateValue(value:, forKey:)`
    方法将添加一个新的键值对并返回 nil。以下示例显示了如何使用下标语法以及 `updateValue(value:, forKey:)` 方法向字典中添加一个新的键值对：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, the countries dictionary starts with three key-value
    pairs and we then add a fourth key-value pair (`FR/France`) to the dictionary
    using the subscript syntax. We then use the updateValue(`value:, forKey:`) method
    to add a fifth key-value pair (`DE/Germany`) to the dictionary. The `orig` variable
    is set to nil because the countries dictionary did not contain a value associated
    with the `DE` key.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，国家字典开始时有三个键值对，然后我们使用下标语法向字典中添加第四个键值对 (`FR/France`)。然后我们使用 `updateValue(value:,
    forKey:)` 方法向字典中添加第五个键值对 (`DE/Germany`)。`orig` 变量被设置为 `nil`，因为国家字典中没有与 `DE` 键关联的值。
- en: Removing a key-value pair
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除键值对
- en: 'There may be times when we need to remove values from a dictionary. We can
    do this with the subscript syntax, using the `removeValueForKey()` method or the
    `removeAll()` method. The `removeValueForKey()` method returns the value of the
    key prior to removing it. The `removeAll()` method removes all the elements from
    the dictionary. The following example shows how to use the subscript syntax, the
    `removeValueForKey()` method, and the `removeAll()` method to remove key-value
    pairs from a dictionary:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要从字典中移除值。我们可以使用下标语法，使用 `removeValueForKey()` 方法或 `removeAll()` 方法来完成此操作。`removeValueForKey()`
    方法返回在移除之前键的值。`removeAll()` 方法从字典中移除所有元素。以下示例展示了如何使用下标语法、`removeValueForKey()`
    方法和 `removeAll()` 方法从字典中移除键值对：
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding code, the `countries` dictionary starts off with three key-value
    pairs. We then set the value associated with the key `IN` to `nil`, which removes
    the key-value pair from the dictionary. We use the `removeValueForKey()` method
    to remove the key associated with the `UK` key. Prior to removing the value associated
    with the `UK` key, the `removeValueForKey()` method saves the value in the `orig`
    variable. Finally, we use the `removeAll()` method to remove all the remaining
    key-value pairs in the countries dictionary.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`countries` 字典最初有三个键值对。然后我们将与键 `IN` 关联的值设置为 `nil`，这将从字典中移除键值对。我们使用 `removeValueForKey()`
    方法来移除与 `UK` 键关联的键。在移除与 `UK` 键关联的值之前，`removeValueForKey()` 方法将值保存在 `orig` 变量中。最后，我们使用
    `removeAll()` 方法来移除 countries 字典中剩余的所有键值对。
- en: Now let's look at the Set type.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看集合类型。
- en: Set
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: The Set type is a generic collection that is similar to the array type. While
    the array type is an ordered collection that may contain duplicate items, the
    Set type is an unordered collection where each item must be unique.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 集合类型是一个类似于数组类型的泛型集合。虽然数组类型是一个有序集合，可能包含重复的元素，但集合类型是一个无序集合，其中每个元素必须是唯一的。
- en: Similar to the key in a dictionary, the type stored in an array must conform
    to the Hashable protocol. This means that the type must provide a way to compute
    a hash value for itself. All of Swift's basic types, such as String, Double, Int
    and Bool, conform to the Hashable protocol and can be used in a set by default.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与字典中的键类似，存储在数组中的类型必须符合 Hashable 协议。这意味着该类型必须提供一种方法来计算自己的哈希值。Swift 的所有基本类型，如
    String、Double、Int 和 Bool，都符合 Hashable 协议，并且默认情况下可以用于集合。
- en: Let's look at how we would use the Set type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用集合类型。
- en: Initializing a set
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化集合
- en: There are a couple of ways in which we can initialize a set. Just like the array
    and dictionary types, Swift needs to know what type of data is going to be stored
    in it. This means that we must either tell Swift the type of data to store in
    the set or initialize it with some data so that it can infer the data type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种初始化集合的方法。就像数组和字典类型一样，Swift 需要知道将要存储的数据类型。这意味着我们必须告诉 Swift 要在集合中存储的数据类型，或者用一些数据初始化它，以便它可以推断数据类型。
- en: 'Just like the array and dictionary types, we use the var and let keywords to
    declare if the set is mutable or not:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像数组和字典类型一样，我们使用 var 和 let 关键字来声明集合是否可变：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Inserting items into a set
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将元素插入到集合中
- en: 'We use the `insert` method to insert an item into a set. If we attempt to insert
    an item that is already in the set, the item will be ignored and no error will
    be thrown. Here are some examples on how to insert items into a set:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `insert` 方法将一个元素插入到集合中。如果我们尝试插入一个已经存在于集合中的元素，该元素将被忽略，并且不会抛出错误。以下是一些如何将元素插入到集合中的示例：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The number of items in a set
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合中的元素数量
- en: 'We can use the `count` property to determine the number of items in a Swift
    Set. Here is an example on how to use the `count` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `count` 属性来确定 Swift 集合中元素的数量。以下是如何使用 `count` 方法的示例：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When executed, this code will print the message `"Three items"` to the console
    because the set contains three items.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此代码时，它将在控制台打印出消息 `"Three items"`，因为集合包含三个元素。
- en: Checking whether a set contains an item
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查集合中是否包含一个元素
- en: 'We can very easily check to see whether a Set contains an item by using the
    `contains()` method, as shown here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `contains()` 方法非常容易地检查一个集合是否包含一个元素，如下所示：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding example, the `contain` variable is set to True because the
    set does contain the string `"Two"`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`contain` 变量被设置为 True，因为集合确实包含字符串 `"Two"`。
- en: Iterating over a set
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历集合
- en: 'We can use the `for` statement to iterate over the items in a Set. The following
    example shows how we would iterate through the items in a set:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `for` 语句遍历 Set 中的项目。以下示例展示了我们如何遍历集合中的项目：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The preceding example would print out each item in the set to the console.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将打印出集合中的每个项目到控制台。
- en: Removing items in a set
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从集合中移除项目
- en: 'We can remove a single item or all the items in a set. To remove a single item,
    we would use the `remove()` method, and to remove all the items, the `removeAll()`
    method. The following example shows how to remove items from a set:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除单个项目或集合中的所有项目。要移除单个项目，我们会使用 `remove()` 方法，要移除所有项目，则使用 `removeAll()` 方法。以下示例展示了如何从集合中移除项目：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Set operations
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: 'Apple has provided four methods that we can use to construct a set from two
    other sets. These operations can either be performed in place, on one of the sets,
    or used to create a new set. These operations are:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果提供了四种方法，我们可以使用这些方法从两个其他集合中构建一个集合。这些操作可以在集合中就地执行，在其中一个集合上执行，或者用于创建一个新集合。这些操作包括：
- en: '`union` and `unionInPlace`: These create a set with all the unique vales from
    both sets'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`union` 和 `unionInPlace`：这些创建一个包含两个集合所有唯一值的集合'
- en: '`subtract` and `subtractInPlace`: These create a set with values from the first
    set that are not in the second set'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract` 和 `subtractInPlace`：这些创建一个包含第一个集合中不在第二个集合中的值的集合'
- en: '`intersect` and `intersectInPlace`: These create a set with values that are
    common to both sets'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intersect` 和 `intersectInPlace`：这些创建一个包含两个集合共有值的集合'
- en: '`exclusiveOr` and `exclusiveOrInPlace`: These create a new set with values
    that are in either set but not in both sets'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclusiveOr` 和 `exclusiveOrInPlace`：这些创建一个新集合，其中包含在任一集合中但不在两个集合中的值'
- en: 'Let''s look at some examples and see the results we get from each of these
    operations. For all the set operations examples, we will be using the following
    two sets:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些示例，并查看从每个操作中得到的每个结果。对于所有集合操作示例，我们将使用以下两个集合：
- en: '[PRE55]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now let''s look at our examples. The first example that we will look at is
    using the union method. This method will take the unique values from both sets
    to make another set:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的示例。我们将首先查看使用 union 方法。这个方法将取两个集合中的唯一值来创建另一个集合：
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `newSetUnion` variable would contain the following values: `"One", "Two",
    "Three", "abc", "def", "ghi"`. Now let''s look at the subtract method. This method
    will create a set with the values from the first set that are not in the second
    set:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`newSetUnion` 变量将包含以下值：`"One", "Two", "Three", "abc", "def", "ghi"`。现在让我们看看
    subtract 方法。这个方法将创建一个集合，其中包含第一个集合中不在第二个集合中的值：'
- en: '[PRE57]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In this example, the `newSetSubtract` variable would contain the values `"Two"`
    and `"Three"` because those are the only two values that are not also in the second
    set.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`newSetSubtract` 变量将包含 `"Two"` 和 `"Three"` 这两个值，因为它们是唯一不在第二个集合中的两个值。
- en: 'Now let''s look at the intersect method. The intersect method creates a new
    set from the values that are common between the two sets:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 intersect 方法。intersect 方法将创建一个新集合，其中包含两个集合之间的公共值：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this example, the `newSetIntersect` variable will contain the values `"One"`
    and `"abc"` since they are the values that are common between the two sets.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`newSetIntersect` 变量将包含 `"One"` 和 `"abc"` 这两个值，因为它们是两个集合之间的公共值。
- en: 'Now let''s look at the `exclusiveOr` method. This method will create a new
    set with the values that are in either set but not in both:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `exclusiveOr` 方法。这个方法将创建一个新集合，其中包含在任一集合中但不在两个集合中的值：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, the `newSetExclusiveOr` variable will contain the values `"Two",
    "Three", "def"` and `"ghi"`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`newSetExclusiveOr` 变量将包含 `"Two", "Three", "def"` 和 `"ghi"`。
- en: These four operations (`union`, `subtract`, `intersect`, and `exclusiveor` methods)
    add additional functionality that is not present with arrays. Combined with the
    faster lookup speeds as compared to an array, the Set can be a very useful alternative
    when the order of the collection is not important and the objects in a collection
    must be unique.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种操作（`union`、`subtract`、`intersect` 和 `exclusiveor` 方法）增加了数组中不存在的一些附加功能。与数组相比，查找速度更快，当集合的顺序不重要且集合中的对象必须是唯一的时候，Set
    可以是一个非常有用的替代品。
- en: Tuples
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'Tuples group multiple values into a single compound value. Unlike arrays and
    dictionaries, the values in a tuple do not have to be of the same type. The following
    example shows how to define a tuple:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 元组将多个值组合成一个单一的复合值。与数组和字典不同，元组中的值不必是同一类型。以下示例展示了如何定义一个元组：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the preceding example, we created an unnamed tuple that contains two strings,
    two integers, and one double. We can decompose the values from this tuple into
    a set of variables, as shown in the following example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个未命名的元组，其中包含两个字符串、两个整数和一个双精度浮点数。我们可以将这个元组中的值分解到一组变量中，如下面的例子所示：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the preceding code, the `city` variable will contain `Boston`, the `name`
    variable will contain `Red Sox`, the `wins` variable will contain `97`, the `loses`
    variable will contain `65`, and, finally, the `percent` variable will contain
    `0.599`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`city` 变量将包含 `Boston`，`name` 变量将包含 `Red Sox`，`wins` 变量将包含 `97`，`loses`
    变量将包含 `65`，最后，`percent` 变量将包含 `0.599`。
- en: 'We could also retrieve the values from a tuple by specifying the location of
    the value. The following example shows how we would retrieve the values by their
    location:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过指定值的地址来从元组中检索值。以下示例展示了如何通过位置检索值：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To avoid this decomposing step, we can create a named tuple. A named tuple
    associates a name (key) with each element of the tuple. The following example
    shows how to create a named tuple:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这一分解步骤，我们可以创建一个命名元组。命名元组将一个名称（键）与元组的每个元素关联起来。以下示例展示了如何创建命名元组：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To access the values from a named tuple, we use a dot syntax. In the preceding
    code, we will access the `city` element of the tuple like this: `team.city`. In
    the preceding code, the `team.city` element will contain `Boston`, the `team.name`
    element will contain `Red Sox`, the `team.wins` element will contain `97`, the
    `team.loses` element will contain `65`, and, finally, the `team.percent` element
    will contain `59.9`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问命名元组中的值，我们使用点语法。在前面代码中，我们将像这样访问元组的 `city` 元素：`team.city`。在前面代码中，`team.city`
    元素将包含 `Boston`，`team.name` 元素将包含 `Red Sox`，`team.wins` 元素将包含 `97`，`team.loses`
    元素将包含 `65`，最后，`team.percent` 元素将包含 `59.9`。
- en: Tuples are incredible useful and can be used for all sorts of purposes. I have
    found that they are very useful for replacing classes and structs that are designed
    to simply store data and do not contain any methods. We will learn more about
    classes in [Chapter 5](ch05.html "Chapter 5. Classes and Structures"), *Classes
    and Structures*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 元组非常有用，可以用于各种目的。我发现它们非常适合替换那些仅用于存储数据且不包含任何方法的类和结构体。我们将在第 5 章[类和结构体](ch05.html
    "第 5 章。类和结构体")中了解更多关于类的内容。
- en: Using Cocoa data types
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Cocoa 数据类型
- en: So far, in this chapter, we have looked at several native Swift data types,
    such as the string, array, and dictionary types. While using these types is definitely
    preferred, as part of the Objective-C interoperability, Apple has provided convenient
    and effective ways to work with Cocoa data types from within our Swift applications.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经探讨了几个原生 Swift 数据类型，如字符串、数组和字典类型。虽然使用这些类型是首选的，但作为 Objective-C
    兼容性的一部分，Apple 已经提供了方便且有效的方法，让我们在 Swift 应用程序中处理 Cocoa 数据类型。
- en: Some of the Cocoa and Swift data types can be used interchangeably, while others
    are automatically converted between Cocoa and Swift data types. Those data types
    that can be used interchangeably or converted are called bridged data types.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Cocoa 和 Swift 数据类型可以互换使用，而另一些则可以在 Cocoa 和 Swift 数据类型之间自动转换。那些可以互换使用或转换的数据类型被称为桥接数据类型。
- en: 'Swift also provides an overlay for working with Foundation data types. This
    lets us work with Foundation data types in a way that feels more like native Swift
    types. If we need to use these Foundation data types, we need to add the following
    import statement to the top of the Swift file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还提供了对 Foundation 数据类型的覆盖，这使得我们能够以更接近原生 Swift 类型的方式处理 Foundation 数据类型。如果我们需要使用这些
    Foundation 数据类型，我们需要在 Swift 文件的顶部添加以下导入语句：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Let's take a look at how to work with some common Cocoa data types.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何处理一些常见的 Cocoa 数据类型。
- en: NSNumber
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSNumber
- en: 'Swift will automatically bridge certain native numeric types, such as Int,
    UInt, Float, Bool, and Double to an `NSNumber` object. This allows us to pass
    these native numeric types to arguments that expect an `NSNumber` object. This
    automatic bridging only works one way because an `NSNumber` object can contain
    various numeric types; therefore, the Swift compiler will not know which numeric
    type to convert the `NSNumber` into. The following examples show how to go from
    a native Swift Int and Double to an `NSNumber`, and how to convert it back to
    the Swift Int and Double. Let''s take a look at the following code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 会自动将某些原生数值类型，如 Int、UInt、Float、Bool 和 Double 转换为 `NSNumber` 对象。这允许我们将这些原生数值类型传递给期望
    `NSNumber` 对象的参数。这种自动转换是单向的，因为 `NSNumber` 对象可以包含各种数值类型；因此，Swift 编译器将不知道要将 `NSNumber`
    转换为哪种数值类型。以下示例展示了如何将原生 Swift Int 和 Double 转换为 `NSNumber`，以及如何将其转换回 Swift Int 和
    Double。让我们看一下以下代码：
- en: '[PRE65]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the preceding code, Swift automatically converts the `inum` and `dnum` to
    `NSNumber` objects without any typecasting; however, when we try to convert the
    `NSNumber` objects back to `Int` or `Double` types of Swift, we need to typecast
    the `NSNumber` objects to tell Swift what type of numbers we are converting into.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，Swift 自动将 `inum` 和 `dnum` 转换为 `NSNumber` 对象，而不需要进行类型转换；然而，当我们尝试将 `NSNumber`
    对象转换回 Swift 的 `Int` 或 `Double` 类型时，我们需要将 `NSNumber` 对象类型转换为告诉 Swift 我们正在转换成哪种类型的数字。
- en: NSString
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`NSString`'
- en: Swift will automatically bridge its native `String` type to a `NSString` type;
    however, it will not automatically bridge an `NSString` object to the native String
    type. This allows us to pass the native string type to arguments that expect an
    `NSString` object. Therefore, when we use mix and match to integrate the Objective-C
    APIs with our Swift project, it automatically converts `String` types to the `NSString`
    objects when needed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 会自动将原生 `String` 类型桥接到 `NSString` 类型；然而，它不会自动将 `NSString` 对象桥接到原生 String
    类型。这允许我们将原生字符串类型传递给期望 `NSString` 对象的参数。因此，当我们混合使用 Objective-C API 与我们的 Swift 项目集成时，它会在需要时自动将
    `String` 类型转换为 `NSString` 对象。
- en: 'This automatic bridging allows us to call the `NSString` methods on our Swift
    strings. Swift automatically converts the string to an `NSString` object and calls
    the method. The following example shows how to convert our string value to a C
    string using the `cStringUsingEncoding()` method that comes from the `NSString`
    type:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动桥接允许我们在 Swift 字符串上调用 `NSString` 方法。Swift 自动将字符串转换为 `NSString` 对象并调用该方法。以下示例展示了如何使用来自
    `NSString` 类型的 `cStringUsingEncoding()` 方法将我们的字符串值转换为 C 字符串：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To convert an `NSString` object to a string type, we will use the `as` keyword.
    Since an `NSString` object can always be converted to a string type, we do not
    need to use the optional version of this typecasting operator (`as?`). The following
    example shows how to convert an `NSString` object to a string type:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `NSString` 对象转换为字符串类型，我们将使用 `as` 关键字。由于 `NSString` 对象始终可以转换为字符串类型，我们不需要使用此类型转换运算符的可选版本
    (`as?`)。以下示例展示了如何将 `NSString` 对象转换为字符串类型：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the next example, we convert an `NSString` object to a native Swift string
    type, and then call the `toInt()` method, from the Swift string type, to convert
    the string to an integer, as shown in the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将 `NSString` 对象转换为原生 Swift 字符串类型，然后调用 Swift 字符串类型的 `toInt()` 方法，将字符串转换为整数，如下所示：
- en: '[PRE68]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In the preceding code, the `num` variable will contain the number `1234` and
    not the string `1234`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`num` 变量将包含数字 `1234`，而不是字符串 `1234`。
- en: NSArray
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`NSArray`'
- en: Swift will automatically bridge between the `NSArray` class and the Swift native
    array type. Since the elements of an `NSArray` object are not required to be of
    the same type, when we bridge from an `NSArray` object to a Swift array, the elements
    of the Swift array are set to the `[AnyObject]` type. The `[AnyObject]` type is
    an object that is an instance of an Objective-C or Swift class or can be bridged
    to one.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 会自动在 `NSArray` 类和 Swift 原生数组类型之间进行桥接。由于 `NSArray` 对象的元素不需要是同一类型，当我们从 `NSArray`
    对象桥接到 Swift 数组时，Swift 数组的元素被设置为 `[AnyObject]` 类型。`[AnyObject]` 类型是一个 Objective-C
    或 Swift 类的实例，或者可以桥接到其中一个。
- en: 'The following example shows how we can create an `NSArray` object in Swift
    that contains both string and Int types and then creates a Swift array from that
    `NSArray` object:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了我们如何在 Swift 中创建一个包含字符串和 Int 类型的 `NSArray` 对象，然后从该 `NSArray` 对象创建一个 Swift
    数组：
- en: '[PRE69]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the preceding code, `nsarr: NSArray` contains four elements—`HI`, `There`,
    `1`, and `2`. In `nsarrNSArray`, two of the elements are string types and two
    are Int types. When we convert the nsarr: `NSArray` to a Swift array, the `arr`
    array becomes an array of `AnyObject` types.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，`nsarr: NSArray` 包含四个元素——`HI`、`There`、`1` 和 `2`。在 `nsarr: NSArray`
    中，有两个元素是字符串类型，两个是 Int 类型。当我们将 nsarr: `NSArray` 转换为 Swift 数组时，`arr` 数组变成了 `AnyObject`
    类型的数组。'
- en: 'If the `NSArray` contains a specific object type, once it is bridged to a Swift
    array, we can downcast the Swift array of `[AnyObject]` to a Swift array of the
    specific object types. The only catch to this downcasting is if any element of
    the array is not of the object type specified, the downcasting will fail and the
    new array will be set to nil. The following example shows how to downcast an array:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `NSArray` 包含特定的对象类型，一旦它被桥接到 Swift 数组，我们就可以将 Swift 数组 `[AnyObject]` 降级为特定对象类型的数组。这个降级的唯一问题是如果数组中的任何元素不是指定的对象类型，降级就会失败，并且新的数组将被设置为
    nil。以下示例展示了如何降级一个数组：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In the preceding example, `newarr` will be an array of strings that contains
    two elements. Now, let''s change the original `NSArray` to include two integers
    as well as the two strings. The new code will now look similar to this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`newarr` 将是一个包含两个元素的字符串数组。现在，让我们将原始的 `NSArray` 改为包含两个整数以及两个字符串。新的代码现在看起来将类似于以下这样：
- en: '[PRE71]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Since the original `NSArray` defines an array of both strings and integers,
    when we attempt to downcast the Swift array from an array of `[AnyObject]` to
    an array of string, the downcasting fails and the `newarr` variable is set to
    nil.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 由于原始 `NSArray` 定义了一个包含字符串和整数的数组，当我们尝试将 Swift 数组从 `[AnyObject]` 数组降级为字符串数组时，降级失败，并且
    `newarr` 变量被设置为 nil。
- en: 'When we use the `as?` keyword to cast an `NSArray` object as an array type,
    it is recommended that we use optional binding since it is possible to receive
    a nil value. The following example illustrates how to do this cast with optional
    binding:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `as?` 关键字将 `NSArray` 对象转换为数组类型时，建议我们使用可选绑定，因为可能会接收到 nil 值。以下示例说明了如何使用可选绑定进行此转换：
- en: '[PRE72]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now let's look at the `NSDictionary` object and how we can use it within our
    Swift code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `NSDictionary` 对象以及我们如何在 Swift 代码中使用它。
- en: NSDictionary
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`NSDictionary`'
- en: 'We use the `as` and `as?` keywords to convert between an `NSDictionary` object
    and a Swift dictionary type. The following example shows how to do this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `as` 和 `as?` 关键字在 `NSDictionary` 对象和 Swift 字典类型之间进行转换。以下示例展示了如何进行此转换：
- en: '[PRE73]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In the previous example, we create an `NSDictionary` object that contains two
    key-value pairs. All of the keys and values in this `NSDictionary` object are
    String types. In the second line, the `nsdic2as? [String: String]` converts the
    `NSDictionary` object to a dictionary type where both the keys and the values
    are String types. We then convert the dictionary type back to an `NSDictionaryobject`
    using the `as` keyword.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的例子中，我们创建了一个包含两个键值对的 `NSDictionary` 对象。这个 `NSDictionary` 对象中的所有键和值都是字符串类型。在第二行，`nsdic2as?
    [String: String]` 将 `NSDictionary` 对象转换为键和值都是字符串类型的字典类型。然后我们使用 `as` 关键字将字典类型转换回
    `NSDictionaryobject`。'
- en: 'In the previous example, we used optional binding when we converted the `NSDictionary`
    object to a dictionary type because if any of the values in the `NSDictionary`
    object were not of the String type, the conversion would have failed. The following
    example illustrates this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当我们从 `NSDictionary` 对象转换为字典类型时，我们使用了可选绑定，因为如果 `NSDictionary` 对象中的任何值不是字符串类型，转换就会失败。以下示例说明了这一点：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, the conversion fails because one of the values is an integer
    type and not a String type. When we do the conversion from an `NSDictionary` object
    to a Swift dictionary we use the `as?` keyword because the conversion may fail,
    but when we convert from a Swift dictionary to an `NSDictionary` object, we use
    the `as` keyword because the conversion is always successful.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，转换失败是因为其中一个值是整型而不是字符串类型。当我们从 `NSDictionary` 对象转换为 Swift 字典时，我们使用 `as?`
    关键字，因为转换可能会失败，但当我们从 Swift 字典转换为 `NSDictionary` 对象时，我们使用 `as` 关键字，因为转换总是成功的。
- en: Now let's look at how we would use Foundation data types with Swift.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用 Swift 中的 Foundation 数据类型。
- en: Foundation data types
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Foundation 数据类型
- en: When using Foundation data types, Swift provides an overlay that makes interacting
    with them feel like they are native Swift types. We use this overlay to interact
    with Foundation types, such as `CGSize` and `CGRect` for iOS applications (`NSSize`
    and `NSRect` for OS X applications). When developing iOS or OS X applications,
    we will interact with Foundation data types on a regular basis, so it is good
    to see this overlay in action.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Foundation 数据类型时，Swift 提供了一个覆盖层，使得与之交互的感觉就像它们是原生的 Swift 类型。我们使用这个覆盖层来与 Foundation
    类型交互，例如 `CGSize` 和 `CGRect` 用于 iOS 应用程序（`NSSize` 和 `NSRect` 用于 OS X 应用程序）。在开发
    iOS 或 OS X 应用程序时，我们将定期与 Foundation 数据类型交互，因此看到这个覆盖层在行动中是很好的。
- en: 'Let''s look at how to initialize some Foundation data types. The following
    example defines `NSRange`, `CGRect`, and `NSSize`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何初始化一些 Foundation 数据类型。以下示例定义了 `NSRange`、`CGRect` 和 `NSSize`：
- en: '[PRE75]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The overlay also lets us access the properties and functions in a way that
    feels like native Swift types. The following example shows us how to access the
    properties and functions:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个覆盖层还允许我们以类似原生 Swift 类型的感觉访问属性和函数。以下示例展示了如何访问属性和函数：
- en: '[PRE76]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In the preceding code, we initialize a `CGRect` type. We then change the property
    of `x` from `10` to `20`, retrieve the value of the `maxY` property, and check
    the `isEmpty` property to see whether we have a valid `CGRect` type.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们初始化了一个 `CGRect` 类型。然后我们将 `x` 属性从 `10` 改为 `20`，检索 `maxY` 属性的值，并检查 `isEmpty`
    属性以确定我们是否有一个有效的 `CGRect` 类型。
- en: We just barely scratched the surface of the interoperability between Swift and
    Objective-C. We will discuss this interoperability in depth in [Chapter 13](ch13.html
    "Chapter 13. Using Mix and Match"), *Using Mix and Match*, later in this book.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是刚刚触及了 Swift 和 Objective-C 之间互操作性的表面。我们将在本书后面的 [第 13 章](ch13.html "第 13 章。使用混合匹配")
    中深入讨论这种互操作性。
- en: Summary
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered Swift collections, tuples, Foundation, and Cocoa
    data types. Having a good understanding of the native collection types of Swift
    is essential to architect and develop applications in Swift since all but the
    very basic applications use collections to store data in memory.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Swift 集合、元组、Foundation 和 Cocoa 数据类型。对 Swift 的原生集合类型有良好的理解对于用 Swift
    架构和开发应用程序至关重要，因为除了非常基础的应用程序之外，所有应用程序都使用集合在内存中存储数据。
- en: At the time of writing this book, Swift is exclusively used for developing applications
    in an Apple (iOS or OS X) environment, so it is essential to understand how Swift
    interacts with Cocoa and Foundation types. While we briefly covered this subject
    in this chapter, we will look at this interaction more in depth in [Chapter 13](ch13.html
    "Chapter 13. Using Mix and Match"), *Using Mix and Match*, later in this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写这本书的时候，Swift 仅用于在苹果（iOS 或 OS X）环境中开发应用程序，因此理解 Swift 如何与 Cocoa 和 Foundation
    类型交互是至关重要的。虽然我们在本章中简要地介绍了这个主题，但我们将在本书后面的 [第 13 章](ch13.html "第 13 章。使用混合匹配")，*使用混合匹配*
    中更深入地探讨这种交互。
