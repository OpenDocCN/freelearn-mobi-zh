<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Building the Messenger Android App – Part I</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Building the Messenger Android App – Part I</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we began building the messenger application by designing and implementing a REST application programming interface that the client messenger application will communicate with. Over the course of implementing the backend API, we covered many things, such as working with Spring Boot, RESTful application programming interfaces and how they work, creating databases with PostgreSQL, and deploying Spring Boot web applications to AWS, to name a few.</p>
<p>In this chapter, we will go one step further in our application development journey by implementing the Android Messenger application and integrating it with the RESTful API we created in <a href="kt-prog-ex_ch04.html">Chapter 4</a><span>,&#160;</span><em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em>. In the process of developing the Messenger Android app, we will learn a vast array of new topics, such as:</p>
<ul>
<li>Building MVP Android applications</li>
<li>Server communication via HTTP</li>
<li>Working with Retrofit</li>
<li>Reactive programming</li>
<li>Using token-based authentication in an Android app</li>
</ul>
<p>Over the course of this chapter, you will learn firsthand how powerful Kotlin is in the Android application development domain. Let's dive into the development of the Messenger app.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing the Messenger app</h1>
                </header>
            
            <article>
                
<p>First, we need to create a new Android Studio project for the application. Create a new Android Studio project with the name <kbd>Messenger</kbd> and the package name <kbd>com.example.messenger</kbd>. Feel free to take a look at <a href="kt-prog-ex_ch01.html">Chapter 1</a>,&#160;<em>The Fundamentals</em>, to refresh your memory on&#160;<span>Android project creation</span>. In the process of project setup, when asked to create a new launcher activity, name the activity <kbd>LoginActivity</kbd> and make it an empty activity.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Including project dependencies</h1>
                </header>
            
            <article>
                
<p>Over the course of this chapter, we will make use of a number of external application dependencies. As such, it is important we include them in the project now. Open your module-level <kbd>build.gradle</kbd> file and add the following dependencies to it:</p>
<pre>dependencies {<br/>  implementation fileTree(<span>dir</span>: <span>'libs'</span>, <span>include</span>: [<span>'*.jar'</span>])<br/>  implementation <span>"org.jetbrains.kotlin:kotlin-stdlib-jre7<br/>                  :</span>$kotlin_version<span>"<br/></span><span>  </span>implementation <span>'com.android.support:appcompat-v7:26.1.0'<br/></span><span>  </span>implementation <span>'com.android.support.constraint:constraint-layout:1.0.2'<br/></span><span>  </span>implementation <span>'com.android.support:recyclerview-v7:26.1.0'<br/></span><span>  </span>implementation <span>'com.android.support:design:26.1.0'<br/></span><span><br/></span><span>  </span>implementation <span>"android.arch.persistence.room:runtime:1.0.0-alpha9-1"<br/></span><span>  </span>implementation <span>"android.arch.persistence.room:rxjava2:1.0.0-alpha9-1"<br/></span><span>  </span>implementation <span>'com.android.support:support-v4:26.1.0'<br/></span><span>  </span>implementation <span>'com.android.support:support-vector-drawable:26.1.0'<br/></span><span>  </span>annotationProcessor <span>"android.arch.persistence.room:compiler<br/>                       :1.0.0-alpha9-1"<br/></span><span><br/></span><span>  </span>implementation <span>"com.squareup.retrofit2:retrofit:2.3.0"<br/></span><span>  </span>implementation <span>"com.squareup.retrofit2:adapter-rxjava2:2.3.0"<br/></span><span>  </span>implementation <span>"com.squareup.retrofit2:converter-gson:2.3.0"<br/></span><span>  </span>implementation <span>"io.reactivex.rxjava2:rxandroid:2.0.1"<br/></span><span><br/></span><span>  </span>implementation <span>'com.github.stfalcon:chatkit:0.2.2'<br/></span><span><br/></span><span>  </span>testImplementation <span>'junit:junit:4.12'<br/></span><span>  </span>androidTestImplementation <span>'com.android.support.test:runner:1.0.1'<br/></span><span>  </span>androidTestImplementation <span>'com.android.support.test.espresso<br/>                             :espresso-core:3.0.1'<br/></span>}</pre>
<p>Ensure that no conflicting Android support library versions exist in the <kbd>build.gradle</kbd> file. Now modify the&#160;<kbd>build.gradle</kbd>&#160;project file to include the <kbd>jcenter</kbd> and Google repositories as well as the Android build tools dependency:</p>
<p><span>Top-level build file where you can add configuration options common to all sub-projects/modules:</span></p>
<pre>buildscript {<br/>  <span>ext</span>.kotlin_version = <span>'1.1.4-3'<br/></span><span>  </span>repositories {<br/>    google()<br/>    jcenter()<br/>  }<br/>  dependencies {<br/>    classpath <span>'com.android.tools.build:gradle:3.0.0-alpha9'<br/></span><span>    </span>classpath <span>"org.jetbrains.kotlin:kotlin-gradle-plugin:</span>$kotlin_version<span>"<br/></span><span>  </span>}<br/>}<br/><br/>allprojects {<br/>  repositories {<br/>    google()<br/>    jcenter()<br/>  }<br/>}<br/><br/>task clean(<span>type</span>: Delete) {<br/>  delete <span>rootProject</span>.<span>buildDir<br/></span>}</pre>
<p>Don't worry, about what the dependencies added for now, all will be revealed over the course of this chapter.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing the Login UI</h1>
                </header>
            
            <article>
                
<p>Once the project is created, create a new package named <kbd>ui</kbd> in the <kbd>com.example.messenger</kbd> application source package. This package will hold all the user-interface-related classes and logic of the Android application. Create a <kbd>login</kbd> package within <kbd>ui</kbd>.&#160; As you may have guessed, this package will hold classes and logic pertaining to the user-login process. Go ahead and move <kbd>LoginActivity</kbd> to the <kbd>login</kbd> package. Having moved <kbd>LoginActivity</kbd>, our first order of business is to create a suitable layout for the login activity.</p>
<p>Locate the <kbd>activity_login.xml</kbd> layout resource file and change the following content:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;LinearLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>    </span><span>tools</span><span>:context=</span><span>".ui.login.LoginActivity"<br/></span><span>    </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span>    </span><span>android</span><span>:paddingTop=</span><span>"32dp"<br/></span><span>    </span><span>android</span><span>:paddingBottom=</span><span>"@dimen/default_margin"<br/></span><span>    </span><span>android</span><span>:paddingStart=</span><span>"@dimen/default_padding"<br/></span><span>    </span><span>android</span><span>:paddingEnd=</span><span>"@dimen/default_padding"<br/></span><span>    </span><span>android</span><span>:gravity=</span><span>"center_horizontal"</span><span>&gt;<br/></span><span>    &lt;</span><span>EditText</span><span><br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/et_username"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"text"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/username"</span><span>/&gt;<br/></span><span>    &lt;</span><span>EditText</span><span><br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/et_password"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"textPassword"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/password"</span><span>/&gt;<br/></span><span>    &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/btn_login"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/login"</span><span>/&gt;<br/></span><span>    &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/btn_sign_up"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:background=</span><span>"@android:color/transparent"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/sign_up_solicitation"</span><span>/&gt;<br/></span><span>    &lt;ProgressBar<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/progress_bar"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:visibility=</span><span>"gone"</span><span>/&gt;<br/></span><span>&lt;/LinearLayout&gt;</span></pre>
<p>There are string and dimension resources that we have made use of here that we have not yet created in the appropriate&#160;<kbd>.xml</kbd>&#160;resource files. We must add these resources at this juncture. While we are at it, we will also include resources that we will require later on in the application development phase so as to eliminate the need to jump back and forth between program files and&#160;<span>resource files</span>. Open the project's string resource file (<kbd>strings.xml</kbd>) and ensure the following resources are added to it:</p>
<pre><span>&lt;resources&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"app_name"</span><span>&gt;</span>Messenger<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"username"</span><span>&gt;</span>Username<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"password"</span><span>&gt;</span>Password<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"login"</span><span>&gt;</span>Login<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"sign_up_solicitation"</span><span>&gt;<br/></span>    Don\'t have an account? Sign up!<br/><span>  &lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"sign_up"</span><span>&gt;</span>Sign up<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"phone_number"</span><span>&gt;</span>Phone number<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"action_settings"</span><span>&gt;</span>settings<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"hint_enter_a_message"</span><span>&gt;</span>Type a message…<span>&lt;/string&gt;<br/></span><span><br/></span><span>  </span><span>&lt;!--  Account settings --&gt;<br/></span><span>  </span><span>&lt;string </span><span>name=</span><span>"title_activity_settings"</span><span>&gt;</span>Settings<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"pref_header_account"</span><span>&gt;</span>Account<span>&lt;/string&gt;<br/></span><span>  &lt;string </span><span>name=</span><span>"action_logout"</span><span>&gt;</span>logout<span>&lt;/string&gt;<br/></span><span>&lt;/resources&gt;<br/></span></pre>
<p>Now create a dimensions resource file (<kbd>dimens.xml</kbd>) and add the following dimension resources to it:</p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;resources&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"default_margin"</span><span>&gt;</span>16dp<span>&lt;/dimen&gt;<br/></span><span>  &lt;dimen </span><span>name=</span><span>"default_padding"</span><span>&gt;</span>16dp<span>&lt;/dimen&gt;<br/></span><span>&lt;/resources&gt;</span></pre>
<p>Now that the necessary project resources have been added, navigate back to <kbd>activity_login.xml</kbd> and toggle the design preview screen to view the layout that has been created:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/36fd17e0-95ab-4357-933c-b2118da19fc8.jpg" style="width:54.50em;height:40.42em;"/></div>
<p>The layout is simple but functional, which is perfect for this simple messenger application we are building.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the login view</h1>
                </header>
            
            <article>
                
<p>Now we have to work on <kbd>LoginActivity</kbd>. As we are building this application utilizing the MVP pattern, <kbd>LoginActivity</kbd> is effectively a view.&#160; Obviously, <kbd>LoginActivity</kbd> is quite different from any generic view. It is a view that is concerned with login procedures. We can identify a set of necessary behaviors that a view presenting a login interface to a user must possess. Such behaviors are:</p>
<ul>
<li>It must show a progress bar to a user when the login is in progress</li>
<li>It must be capable of hiding the progress bar when the need arises</li>
<li>It must be able to show appropriate field errors to users when encountered</li>
<li>It must be able to navigate the user to his home screen</li>
<li>It must be able to navigate an unregistered user to a signup screen</li>
</ul>
<p>Having identified the preceding behaviors, we must ensure that <kbd>LoginActivity</kbd>—as a login view—exhibits such behaviors. A perfect way to do this is to utilize an interface. Create a <kbd>LoginView</kbd> interface in the <kbd>login</kbd> package containing the following content:</p>
<pre><span>package </span>com.example.messenger.ui.login<br/><span><br/></span><span>interface </span>LoginView {<br/>  <span>fun </span><span>showProgress</span>()<br/>  <span>fun </span><span>hideProgress</span>()<br/>  <span>fun </span><span>setUsernameError</span>()<br/>  <span>fun </span><span>setPasswordError</span>()<br/>  <span>fun </span><span>navigateToSignUp</span>()<br/>  <span>fun </span><span>navigateToHome</span>()<br/>}</pre>
<p>So far, so good with <kbd>LoginView</kbd>. There are a few issues with our interface though. A <kbd>LoginView</kbd> must have the ability to bind its layout views to appropriate object representations. In addition, a <kbd>LoginView</kbd> must be able to provide feedback to the user if an authentication error occurs. You may be thinking that neither of these two behaviors should be distinct to a <kbd>LoginView</kbd>. You are right. All views should have the ability to bind layout elements to programmatic objects. In addition, a signup view should also be able to provide the user with some kind of feedback if there is a problem during authentication.</p>
<p>We will create two distinct interfaces to enforce these behaviors. We will name the first interface <kbd>BaseView</kbd>. Create a <kbd>base</kbd> package in <kbd>com.example.messenger.ui</kbd> and add an interface named <kbd>BaseView</kbd> to the package with the following content:</p>
<pre><span>package </span>com.example.messenger.ui.base<br/><br/><span>import </span>android.content.Context<br/><span><br/></span><span>interface </span>BaseView {<br/>  <span>fun </span><span>bindViews</span>()<br/>  <span>fun </span><span>getContext</span>(): Context<br/>}</pre>
<p class="mce-root">The <kbd>BaseView</kbd> interface enforces that an implementing class declares <kbd>bindViews()</kbd> and <kbd>getContext()</kbd> functions for view bindings and context retrievals, respectively.</p>
<p class="mce-root"><span>Now create an&#160;</span><kbd>auth</kbd><span>&#160;package in&#160;</span><kbd>com.example.messenger.ui</kbd><span>&#160;and add an interface named&#160;</span><kbd>AuthView</kbd><span>&#160;to the package with the following content:</span></p>
<pre><span>package </span>com.example.messenger.ui.auth<br/><span><br/></span><span>interface </span>AuthView {<br/>  <span>fun </span><span>showAuthError</span>()<br/>}</pre>
<p>Fantastic job! Now go back to the <kbd>LoginView</kbd> interface and ensure that it extends <kbd>BaseView</kbd> and <kbd>AuthView</kbd>, as follows:</p>
<pre><span>package </span>com.example.messenger.ui.login<br/><br/><span>import </span>com.example.messenger.ui.auth.AuthView<br/><span>import </span>com.example.messenger.ui.base.BaseView<br/><span><br/></span><span>interface </span>LoginView : BaseView<span>, </span>AuthView {<br/>  <span>fun </span><span>showProgress</span>()<br/>  <span>fun </span><span>hideProgress</span>()<br/>  <span>fun </span><span>setUsernameError</span>()<br/>  <span>fun </span><span>setPasswordError</span>()<br/>  <span>fun </span><span>navigateToSignUp</span>()<br/>  <span>fun </span><span>navigateToHome</span>()<br/>}</pre>
<p>By declaring the <kbd>LoginView</kbd> interface as an extension of <kbd>BaseView</kbd> and <kbd>AuthView</kbd>, we ensure that every class that implements <kbd>LoginView</kbd> must declare the&#160;<kbd>bindViews()</kbd>, <kbd>getContext()</kbd>, and <kbd>showAuthError()</kbd> functions in addition to those declared in <kbd>LoginView</kbd>. It is important to note that any class that implements <kbd>LoginView</kbd> is effectively of the&#160;<kbd>LoginView</kbd>, <kbd>BaseView</kbd>, and <kbd>AuthView</kbd>&#160;type. The characteristic of a class possessing many types is known as polymorphism.</p>
<p>Having set up the <kbd>LoginView</kbd>, we can go ahead and work on <kbd>LoginActivity</kbd>. Firstly we will create <kbd>LoginActivity</kbd> to implement the methods declared in&#160; <kbd>BaseView</kbd> and <kbd>AuthView</kbd> after which we will add the methods specific to a <kbd>LoginView</kbd>. <kbd>LoginActivity</kbd> is shown in the following code:</p>
<pre><span>package </span>com.example.messenger.ui.login<br/><br/><span>import </span>android.content.Context<br/><span>import </span>android.content.Intent<br/><span>import </span>android.support.v7.app.AppCompatActivity<br/><span>import </span>android.os.Bundle<br/><span>import </span>android.view.View<br/><span>import </span>android.widget.Button<br/><span>import </span>android.widget.EditText<br/><span>import </span>android.widget.ProgressBar<br/><span>import </span>android.widget.Toast<br/><span>import </span>com.example.messenger.R<br/><br/><span>class </span>LoginActivity : AppCompatActivity()<span>, </span>LoginView<span>, </span>View.OnClickListener {<br/><br/>  <span>private lateinit var </span><span>etUsername</span>: EditText<br/>  <span>private lateinit var </span><span>etPassword</span>: EditText<br/>  <span>private lateinit var </span><span>btnLogin</span>: Button<br/>  <span>private lateinit var </span><span>btnSignUp</span>: Button<br/>  <span>private lateinit var </span><span>progressBar</span>: ProgressBar<br/><br/>  <span>override fun </span><span>onCreate</span>(savedInstanceState: Bundle?) {<br/>    <span>super</span>.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<span>activity_login</span>)<br/><br/>    bindViews()<br/>  }</pre>
<p>Binds layout view object references to view elements when invoked:</p>
<pre><br/>  <span>override fun </span><span>bindViews</span>() {<br/>    <span>etUsername </span>= findViewById(R.id.<span>et_username</span>)<br/>    <span>etPassword </span>= findViewById(R.id.<span>et_password</span>)<br/>    <span>btnLogin </span>= findViewById(R.id.<span>btn_login</span>)<br/>    <span>btnSignUp </span>= findViewById(R.id.<span>btn_sign_up</span>)<br/>    <span>progressBar </span>= findViewById(R.id.<span>progress_bar</span>)<br/>    <span>btnLogin</span>.setOnClickListener(<span>this</span>)<br/>    <span>btnSignUp</span>.setOnClickListener(<span>this</span>)<br/>  }<br/><br/>  /**<br/>    * Shows an appropriate Authentication error message when invoked.<br/>  */<br/>  <span>override fun </span><span>showAuthError</span>() {<br/>    Toast.makeText(<span>this, </span><span>"Invalid username and password combination."</span><span>, </span>Toast.<span>LENGTH_LONG</span>).show()<br/>  }<br/><br/>  <span>override fun </span><span>onClick</span>(view: View) {<br/>       <br/>  }<br/><br/>  <span>override fun </span><span>getContext</span>(): Context {<br/>    <span>return this<br/></span><span>  </span>}<br/>}</pre>
<p>So far so good. We have successfully implemented <kbd>BaseView</kbd> and <kbd>AuthView</kbd> methods in <kbd>LoginActivity</kbd>. We still must work on the <kbd>LoginView</kbd> specific methods <kbd>showProgress()</kbd>, <kbd>hideProgress()</kbd>, <kbd>setUsernameError()</kbd>, <kbd>setPasswordError()</kbd>, <kbd>navigateToSignUp()</kbd> and <kbd>navigateToHome()</kbd>. The required implementation of these&#160; methods is given below. Go ahead and add them to <kbd>LoginActivity</kbd>.</p>
<pre><span>override fun </span><span>hideProgress</span>() {<br/>  <span>progressBar</span>.<span>visibility </span>= View.<span>GONE<br/></span>}<br/><br/><span>override fun </span><span>showProgress</span>() {<br/>  <span>progressBar</span>.<span>visibility </span>= View.<span>VISIBLE<br/></span>}<br/><br/><span>override fun </span><span>setUsernameError</span>() {<br/>  <span>etUsername</span>.<span>error </span>= <span>"Username field cannot be empty"<br/></span>}<br/><br/><span>override fun </span><span>setPasswordError</span>() {<br/>  <span>etPassword</span>.<span>error </span>= <span>"Password field cannot be empty"<br/></span>}<br/><br/><span>override fun </span><span>navigateToSignUp</span>() {<br/>      <br/>}<br/><br/><span>override fun </span><span>navigateToHome</span>() {<br/>        <br/>}</pre>
<p>Adding all the defined methods earlier, you have made the <kbd>LoginActivity</kbd>&#160;class to implement&#160;<kbd>LoginView</kbd> as well as the <kbd>View.OnClickListener</kbd> interface. As such, <kbd>LoginActivity</kbd> provides implementations for functions declared within these interfaces. Notice how the current instance of the <kbd>LoginActivity</kbd> is passed as an argument to <kbd>btnLogin.setOnClickListener()</kbd> via <kbd>this</kbd>. We can do this because we have declared <kbd>LoginActivity</kbd> to implement the <kbd>View.OnClickListener</kbd> interface. As such, <kbd>LoginActivity</kbd> is a valid <kbd>View.OnClickListener</kbd> instance (this is a perfect example of polymorphism at work).&#160;</p>
<p>Now that we have done some reasonable work on the login view, we must create an appropriate model to handle login logic. We must also create the necessary services and data repositories that this model will communicate with. We will first work on the required services and then develop the necessary data repositories before we build the interactor.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the Messenger API service and data repositories</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">A critical thing that we must consider before getting too deep in our application development process is data storage. We must ask ourselves two very important questions: Where will data be stored, and how will the stored data be accessed?</span></p>
<p class="p1"><span class="s1">Pertaining to the location of data storage, data will be stored both locally (on the<span class="Apple-converted-space">&#160;A</span>ndroid device) and remotely (on the Messenger API). The answer to the second question is similarly straightforward. To access stored data, we need to create suitable models, services, and repositories to facilitate data retrieval.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Storing data locally with SharedPreferences</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">First and foremost, we need to take care of local storage. As this is a simple application, we do not need to store much data locally. The only data we need to store on the device are access tokens and user details. We will be using <kbd>SharedPreferences</kbd> to do this.</span></p>
<p class="p1"><span class="s1">First things first, create a <kbd>data</kbd>&#160;package within the application's <kbd>source</kbd> package. We previously identified that we are going to be working with data stored locally and remotely. Hence, create two additional packages within <kbd>data</kbd>. Name the first <kbd>local</kbd> and the second <kbd>remote</kbd>. Similar to the approach that we used for the <em>Tetris</em> application that we created in <a href="kt-prog-ex_ch02.html">Chapter 2</a>,&#160;<em>Building an Android Application – Tetris</em> and <a href="kt-prog-ex_ch03.html">Chapter 3</a>, <em>Implementing Tetris Logic and Functionality</em>, we will be using an <kbd>AppPreferences</kbd> class to persist data locally. Create an <kbd>AppPreferences</kbd> class within <kbd>local</kbd> and populate it with the following content:</span></p>
<pre><span>package </span>com.example.messenger.data.local<br/><br/><span>import </span>android.content.Context<br/><span>import </span>android.content.SharedPreferences<br/><span>import </span>com.example.messenger.data.vo.UserVO<br/><span><br/></span><span>class </span>AppPreferences <span>private constructor</span>() {<br/><br/>  <span>private lateinit var </span><span>preferences</span>: SharedPreferences<br/><br/>  <span>companion object </span>{<br/>    <span>private val </span><span>PREFERENCE_FILE_NAME </span>= <span>"APP_PREFERENCES"<br/></span><span><br/></span><span>    </span><span>fun </span><span>create</span>(context: Context): AppPreferences {<br/>      <span>val </span>appPreferences = AppPreferences()<br/>      appPreferences.<span>preferences </span>= context<br/>      .getSharedPreferences(<span>PREFERENCE_FILE_NAME</span><span>, </span><span>0</span>)<br/>        <span>return </span>appPreferences<br/>      }<br/>    }<br/><br/>    <span>val </span><span>accessToken</span>: String?<br/>      <span>get</span>() = <span>preferences</span>.getString(<span>"ACCESS_TOKEN"</span><span>, null</span>)<br/><br/>    <span>fun </span><span>storeAccessToken</span>(accessToken: String) {<br/>      <span>preferences</span>.edit().<span>putString</span>(<span>"ACCESS_TOKEN"</span><span>, </span>accessToken).apply()<br/>    }<br/><br/>    <span>val </span><span>userDetails</span>: UserVO<br/>    <span>get</span>(): UserVO {</pre>
<p>Returns an instance of <kbd>UserVO</kbd> containing appropriate user details:</p>
<pre>  <span>return </span>UserVO(<br/>    <span>preferences</span>.getLong(<span>"ID"</span><span>, </span><span>0</span>)<span>,<br/></span><span>    </span><span>preferences</span>.getString(<span>"USERNAME"</span><span>, null</span>)<span>,<br/></span><span>    p</span><span>references</span>.getString(<span>"PHONE_NUMBER"</span><span>, null</span>)<span>,<br/></span><span>    </span><span>preferences</span>.getString(<span>"STATUS"</span><span>, null</span>)<span>,<br/></span><span>    </span><span>preferences</span>.getString(<span>"CREATED_AT"</span><span>, null</span>)<br/>  )<br/>}</pre>
<p>Stores user details passed in <kbd>UserVO</kbd> to the application's <kbd>SharedPreferences</kbd> file:</p>
<pre>  <span>fun </span><span>storeUserDetails</span>(user: UserVO) {<br/>    <span>val </span>editor: SharedPreferences.Editor = <span>preferences</span>.edit()<br/><br/>    editor.putLong(<span>"ID"</span><span>, </span>user.<span>id</span>).apply()<br/>    editor.<span>putString</span>(<span>"USERNAME"</span><span>, </span>user.<span>username</span>).apply()<br/>    editor.<span>putString</span>(<span>"PHONE_NUMBER"</span><span>, </span>user.<span>phoneNumber</span>).apply()<br/>    editor.<span>putString</span>(<span>"STATUS"</span><span>, </span>user.<span>status</span>).apply()<br/>    editor.<span>putString</span>(<span>"CREATED_AT"</span><span>, </span>user.<span>createdAt</span>).apply()<br/>  }<br/><br/>  <span>fun </span><span>clear</span>() {<br/>    <span>val </span>editor: SharedPreferences.Editor = <span>preferences</span>.edit()<br/>    editor.clear()<br/>    editor.apply()<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">In&#160;<kbd>AppPreferences</kbd>, we defined the&#160;<kbd>storeAccessToken(String)</kbd>, <kbd>storeUserDetails(UserVO)</kbd>, and <kbd>clear()</kbd> functions. <kbd>storeAccessToken(String)</kbd> will be used to store an access token retrieved from the remote server to the local preferences file. <kbd>storeUserDetails(UserVO)</kbd> takes a user value object (a data object that contains user information) as its only argument and stores the information contained in the value object to the preferences file. The&#160;<kbd>clear()</kbd>&#160;method, as the name implies, clears all values that have been stored in the preferences file. The&#160;<kbd>AppPreferences</kbd>&#160;instance also has <kbd>accessToken</kbd> and<span class="Apple-converted-space">&#160;</span> <kbd>userDetails</kbd> properties, each having specialized getter functions to retrieve their appropriate values.&#160;In addition to this the functions and properties defined in <kbd>AppPreferences</kbd>, we also created a companion object possessing a single <kbd>create(Context)</kbd> function. The&#160;<kbd>create()</kbd>&#160;method, as the name implies, creates and returns a new <kbd>AppPreferences</kbd> instance for use. We made the primary constructor of <kbd>AppPreferences</kbd> private as we require that any class utilizing <kbd>AppPreferences</kbd> make use of <kbd>create()</kbd> for the instantiation of <kbd>AppPreferences</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating value objects</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Similar to what we did when creating the messenger backend, we need to create value objects to model common types of data we will be handling across the application. Create a <kbd>vo</kbd>&#160;package in the <kbd>data</kbd>&#160;package. The value objects we are creating are already familiar to you. In fact, they are exactly the same as those we created during the development of the API. We are going to create <kbd>ConversationListVO</kbd>, <kbd>ConversationVO</kbd>, <kbd>UserListVO</kbd>, <kbd>UserVO</kbd>, and <kbd>MessageVO</kbd>. Create Kotlin files to hold each of these value objects in the <kbd>vo</kbd>&#160;package. Before creating any list value object data models, we have to create the basic models. These models are <kbd>UserVO</kbd>, <kbd>MessageVO</kbd>, and <kbd>ConversationVO</kbd>.</span></p>
<p class="p1"><span class="s1">Create a <kbd>UserVO</kbd> data class, as follows:</span></p>
<pre><span>package </span>com.example.messenger.data.vo<br/><span><br/></span><span>data class </span>UserVO(<br/>  <span>val </span><span>id</span>: Long<span>,<br/></span><span>  val </span><span>username</span>: String<span>,<br/></span><span>  val </span><span>phoneNumber</span>: String<span>,<br/></span><span>  val </span><span>status</span>: String<span>,<br/></span><span>  val </span><span>createdAt</span>: String<br/>)</pre>
<p class="p1"><span class="s1">As we have created value objects in the past, the previous code doesn't need much explaining. Add <kbd>MessageVO</kbd> to your <kbd>MessageVO.kt</kbd> file, as follows:</span></p>
<pre><span>package </span>com.example.messenger.data.vo<br/><span><br/></span><span>data class </span>MessageVO(<br/>  <span>val </span><span>id</span>: Long<span>,<br/></span><span>  val </span><span>senderId</span>: Long<span>,<br/></span><span>  val </span><span>recipientId</span>: Long<span>,<br/></span><span>  val </span><span>conversationId</span>: Long<span>,<br/></span><span>  val </span><span>body</span>: String<span>,<br/></span><span>  val </span><span>createdAt</span>: String<br/>)</pre>
<p class="p1"><span class="s1">Now create a <kbd>ConversationVo</kbd> data class in <kbd>ConversationVO.kt</kbd>, as follows:</span></p>
<pre><span>package </span>com.example.messenger.data.vo<br/><span><br/></span><span>data class </span>ConversationVO(<br/>  <span>val </span><span>conversationId</span>: Long<span>,<br/></span><span>  val </span><span>secondPartyUsername</span>: String<span>,<br/></span><span>  val </span><span>messages</span>: ArrayList&lt;MessageVO&gt;<br/>)</pre>
<p class="p1"><span class="s1">Having created the basic value objects, let's create <kbd>ConversationListVO</kbd> and <kbd>UserListVO</kbd>, shall we? <kbd>ConversationListVO</kbd>&#160;is as follows:</span></p>
<pre><span>package </span>com.example.messenger.data.vo<br/><span><br/></span><span>data class </span>ConversationListVO(<br/>  <span>val </span><span>conversations</span>: List&lt;ConversationVO&gt;<br/>)</pre>
<p class="p1"><span class="s1">The <kbd>ConversationListVO</kbd>&#160;data class has a single&#160;<kbd>conversations</kbd>&#160;property of the&#160;<kbd>List</kbd>&#160;type that can only contain elements of the&#160;<kbd>ConversationVO</kbd>&#160;type. The&#160;<kbd>UserListVO</kbd>&#160;data class is similar to <kbd>ConversationListVO</kbd>, with the exception that it has a user's property, which can only contain elements of the&#160;<kbd>UserVO</kbd>&#160;type instead of a <kbd>conversations</kbd> property. The following is the <kbd>UserListVO</kbd> data class:</span></p>
<pre><span>package </span>com.example.messenger.data.vo<br/><span><br/></span><span>data class </span>UserListVO(<br/>  <span>val </span><span>users</span>: List&lt;UserVO&gt;<br/>)</pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Retrieving remote data</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">We have already established that important data necessary for the functioning the messenger Android App will be stored remotely on the messenger backend. It is imperative that we have an efficient means by which our Android application can access the data held by the backend. To do this, the Messenger application needs to be able to communicate with the API via HTTP.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with a remote server</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">There are a number of ways that communication with a remote server can be achieved in Android. Common networking libraries used across the Android community are <strong>Retrofit</strong>, <strong>OkHttp</strong>, and <strong>Volley</strong>. Each of these libraries has its advantages and drawbacks. We will be making use of Retrofit in this project, but for the sake of knowledge, we will take a look at how to communicate with a remote server using OkHttp.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Communicating with servers using OkHttp</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">OkHttp is an efficient and easy-to-use HTTP client. It supports both synchronous and asynchronous network calls. Using OkHttp on Android is easy. Simply add its dependency to a project's module-level <kbd>build.gradle</kbd> file:</span></p>
<pre class="p1"><span class="s1">implementation 'com.squareup.okhttp3:okhttp:3.9.0'</span></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending requests to a server with OkHttp</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As previously stated, OkHttp's APIs were built with ease of use in mind. As a consequence, sending requests via OkHttp is quick and hassle-free. The following is a <kbd>post(String, String)</kbd> method that takes a URL and JSON request body as its arguments and sends a POST request to the specified URL with the JSON body:</span></p>
<pre class="p1"><span class="s1">fun post(url: String, json: String): String {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val mediaType: MediaType = MediaType.parse("application/json;<br/>                                              charset=utf-8")<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val client:</span><span class="s1">OkHttpClient </span><span class="s1">= OkHttpClient()<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val body: RequestBody = RequestBody.create(mediaType, json)<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>val request: Request = Request.Builder()<br/></span><span class="s1"><span class="Apple-converted-space">                                </span>.url(url)<br/></span><span class="s1"><span class="Apple-converted-space">                                </span>.post(body)<br/></span><span class="s1"><span class="Apple-converted-space">                                </span>.build()<br/><br/></span><span class="s1"><span class="Apple-converted-space">  </span>val response: Response = client.newCall(request).execute()<br/></span><span class="s1"><span class="Apple-converted-space">  </span>return response.body().string()<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1">Using the preceding function is straightforward. Invoke it with appropriate values, as you would any other function:</span></p>
<pre class="p1"><span class="s1">val fullName: String = "John Wayne"<br/></span><span class="s1">val response = post("http://example.com", "{ \"full_name\": $fullName")<br/><br/></span><span class="s1">println(response)</span></pre>
<p class="p1"><span class="s1">Easy, right? Glad you agree. Communicating with a remote server is fun with OkHttp but using Retrofit to do this is even more fun. We are almost ready to work with Retrofit, but, before we explore Retrofit, it's a good idea to properly model the data we will be sending in our HTTP requests.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modeling request data</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">We will make use of data classes to model the HTTP request data we wish to send to our API. Go ahead and create a <kbd>request</kbd> package in the <kbd>remote</kbd>&#160;package. There are four obvious requests that contain data payloads, which we will be sending to the API. These are login requests, message requests, status update requests, and requests containing user data. These four requests will be modeled by <kbd>LoginRequestObject</kbd>, <kbd>MessageRequestObject</kbd>, <kbd>StatusUpdateRequestObject</kbd>, and <kbd>UserRequest</kbd> objects, respectively.</span></p>
<p class="p1"><span class="s1">The following code snippet shows the <kbd>LoginRequestObject</kbd> data class. Go ahead and add it to the <kbd>request</kbd> package and do the same for other request objects that follow:</span></p>
<pre class="p1"><span class="s1">package com.example.messenger.data.remote.request<br/><br/></span><span class="s1">data class LoginRequestObject(<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val username: String,<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val password: String<br/></span><span class="s1">)</span></pre>
<p class="p1"><span class="s1">The <kbd>LoginRequestObject</kbd>&#160;data class possesses the&#160;<kbd>username</kbd> and <kbd>password</kbd> properties because these are the credentials that need to be supplied to the login endpoint of the API. The&#160;<kbd>MessageRequestObject</kbd>&#160;data class is as follows:</span></p>
<pre class="p1"><span class="s1">package com.example.messenger.data.remote.request<br/><br/></span><span class="s1">data class MessageRequestObject(</span><span class="s1">val recipientId: Long, </span><span class="s1">val message: String</span><span class="s1">)</span></pre>
<p class="p1"><span class="s1"><kbd>MessageRequestObject</kbd> possesses<span class="Apple-converted-space">&#160;</span>two properties as well. These are <kbd>recipientId</kbd>—the ID of a user receiving a message<span>—</span>and <kbd>message</kbd> <span>—</span>the body of the message being sent:</span></p>
<pre class="p1"><span class="s1">package com.example.messenger.data.remote.request<br/><br/></span><span class="s1">data class StatusUpdateRequestObject(val status: String)</span></pre>
<p class="p1"><span class="s1">The <kbd>StatusUpdateRequestObject</kbd>&#160;data class has a single <kbd>status</kbd> property. As the name implies, this is the status that a user wants to update their current status message to:</span></p>
<pre class="p1"><span class="s1">package com.example.messenger.data.remote.request<br/><br/></span><span class="s1">data class UserRequestObject(<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val username: String,<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val password: String,<br/></span><span class="s1"><span class="Apple-converted-space">  </span>val phoneNumber: String = ""<br/></span><span class="s1">)</span></pre>
<p class="p1"><span class="s1"><kbd>UserRequestObject</kbd> is similar to <kbd>LoginRequestObject</kbd> with the exception that it contains an additional <kbd>phoneNumber</kbd> property. This request object has varying use cases, such as to contain user signup data being sent to the API.</span></p>
<p class="p1"><span class="s1">Having created the necessary request objects, we can go ahead and create the actual <kbd>MessengerApiService</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the Messenger API service</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">It's time for us to create a service that performs the all-important job of communicating with the Messenger API we created in <a href="kt-prog-ex_ch04.html">Chapter 4</a>, <em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em>. We will be making use of Retrofit and Retrofit's RxJava adapter to create this service. Retrofit is a type-safe HTTP client for Android and Java built by Square Inc., and RxJava is an open source implementation of ReactiveX written in and for Java.</span></p>
<p class="p1"><span class="s1">We added Retrofit to our Android project at the beginning of this chapter with the following line:</span></p>
<pre class="p1"><span class="s1">implementation "com.squareup.retrofit2:retrofit:2.3.0"</span></pre>
<p class="p1"><span class="s1">We also added Retrofit's RxJava adapter dependency to our&#160;module-level <kbd>build.gradle</kbd> script, as follows:</span></p>
<pre class="p1"><span class="s1">implementation "com.squareup.retrofit2:adapter-rxjava2:2.3.0"</span></pre>
<p class="p1"><span class="s1">The first step in creating a service with Retrofit is to define an interface that describes your HTTP API. Create a <kbd>service</kbd> package within your application <kbd>source</kbd> package and add the <kbd>MessengerApiService</kbd> interface, as follows:</span></p>
<pre><span>pa</span><span>ckage </span>com.example.messenger.service<br/><br/><span>import </span>com.example.messenger.data.remote.request.LoginRequestObject<br/><span>import </span>com.example.messenger.data.remote.request.MessageRequestObject<br/><span>import </span>com.example.messenger.data.remote.request.StatusUpdateRequestObject<br/><span>import </span>com.example.messenger.data.remote.request.UserRequestObject<br/><span>import </span>com.example.messenger.data.vo.*<br/><span>import </span>io.reactivex.Observable<br/><span>import </span>okhttp3.ResponseBody<br/><span>import </span>retrofit2.Retrofit<br/><span>import </span>retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory<br/><span>import </span>retrofit2.converter.gson.GsonConverterFactory<br/><span>import </span>retrofit2.http.*<br/><span><br/></span><span>interface </span>MessengerApiService {<br/><br/>  <span>@POST</span>(<span>"login"</span>)<br/>  <span>@Headers</span>(<span>"Content-Type: application/json"</span>)<br/>  <span>fun </span><span>login</span>(<span>@Body </span>user: LoginRequestObject):<br/>           Observable&lt;retrofit2.Response&lt;ResponseBody&gt;&gt;<br/><br/>  <span>@POST</span>(<span>"users/registrations"</span>)<br/>  <span>fun </span><span>createUser</span>(<span>@Body </span>user: UserRequestObject): Observable&lt;UserVO&gt;<br/><br/>  <span>@GET</span>(<span>"users"</span>)<br/>  <span>fun </span><span>listUsers</span>(<span>@Header</span>(<span>"Authorization"</span>) authorization: String):<br/>               Observable&lt;UserListVO&gt;<br/><br/>  <span>@PUT</span>(<span>"users"</span>)<br/>  <span>fun </span><span>updateUserStatus</span>(<br/>    <span>@Body </span>request: StatusUpdateRequestObject<span>,<br/></span><span>    @Header</span>(<span>"Authorization"</span>) authorization: String): Observable&lt;UserVO&gt;<br/><br/>  <span>@GET</span>(<span>"users/{userId}"</span>)<br/>  <span>fun </span><span>showUser</span>(<br/>    <span>@Path</span>(<span>"userId"</span>) userId: Long<span>,<br/></span><span>    @Header</span>(<span>"Authorization"</span>) authorization: String): Observable&lt;UserVO&gt;<br/><br/>  <span>@GET</span>(<span>"users/details"</span>)<br/>  <span>fun </span><span>echoDetails</span>(<span>@Header</span>(<span>"Authorization"</span>) authorization: String): Observable&lt;UserVO&gt;<br/><br/><br/>  <span>@POST</span>(<span>"messages"</span>)<br/>  <span>fun </span><span>createMessage</span>(<br/>    <span>@Body </span>messageRequestObject: MessageRequestObject<span>,<br/></span><span>    @Header</span>(<span>"Authorization"</span>) authorization: String): Observable&lt;MessageVO&gt;<br/><br/>  <span>@GET</span>(<span>"conversations"</span>)<br/>  <span>fun </span><span>listConversations</span>(<span>@Header</span>(<span>"Authorization"</span>) authorization: String):<br/>                       Observable&lt;ConversationListVO&gt;<br/><br/>  <span>@GET</span>(<span>"conversations/{conversationId}"</span>)<br/>  <span>fun </span><span>showConversation</span>(<br/>    <span>@Path</span>(<span>"conversationId"</span>) conversationId: Long<span>,<br/></span><span>    @Header</span>(<span>"Authorization"</span>) authorization: String):Observable&lt;ConversationVO&gt;<br/>}</pre>
<p class="p1"><span class="s1">As can be observed from the preceding code snippet, Retrofit relies on the use of annotations to properly describe HTTP requests to be sent. Take the following snippet, for example:</span></p>
<pre><span>@POST</span>(<span>"login"</span>)<br/><span>@Headers</span>(<span>"Content-Type: application/json"</span>)<br/><span>fun </span><span>login</span>(<span>@Body </span>user: LoginRequestObject): Observable&lt;retrofit2.Response&lt;ResponseBody&gt;&gt;</pre>
<p class="p1"><span class="s1">The <kbd>@POST</kbd> annotation tells Retrofit that this function describes an HTTP POST request that is mapped to the <kbd>/login</kbd> path. The <kbd>@Headers</kbd> annotation is used to specify the headers of the HTTP request. In the HTTP request described in the<span class="Apple-converted-space">&#160;preceding</span> code snippet, the <kbd>Content-Type</kbd> header has been set to <kbd>application/json</kbd>. Hence, the content being sent by this request is JSON.</span></p>
<p class="p1"><span class="s1">The <kbd>@Body</kbd> annotation specifies that the <kbd>user</kbd> argument passed to <kbd>login()</kbd> contains the data of the JSON request body to be sent to the API. <kbd>user</kbd> is of the&#160;<kbd>LoginRequestObject</kbd>&#160;type (we previously created this request object). Lastly, the function is declared to return an <kbd>Observable</kbd> object containing a <kbd>retrofit2.Response</kbd> object.</span></p>
<p class="p1"><span class="s1">Besides the <kbd>@POST</kbd>, <kbd>@Headers</kbd>, and <kbd>@Body</kbd> annotations, we made use of <kbd>@GET</kbd>, <kbd>@PUT</kbd>, <kbd>@Path</kbd>, and <kbd>@Header</kbd>. <kbd>@GET</kbd> and <kbd>@PUT</kbd> are used to specify <kbd>GET</kbd> and <kbd>PUT</kbd> requests, respectively. The <kbd>@Path</kbd> annotation is used to declare a value as a path argument of the HTTP request being sent. Take the&#160;<span>following&#160;</span><kbd>showUser()</kbd> function, for example:</span></p>
<pre><span>@GET</span>(<span>"users/{userId}"</span>)<br/><span>fun </span><span>showUser</span>(<br/>  <span>@Path</span>(<span>"userId"</span>) userId: Long<span>,<br/></span><span>  @Header</span>(<span>"Authorization"</span>) authorization: String): Observable&lt;UserVO&gt;</pre>
<p class="p1"><span class="s1"><kbd>showUser</kbd> is a function that describes a GET request with the <kbd>users/{userId}</kbd> path.&#160;<kbd>{userId}</kbd> is not actually part of the HTTP request path. Retrofit will replace <kbd>{userId}</kbd> with the value passed to the <kbd>userId</kbd> argument of <kbd>showUser()</kbd>. Notice how <kbd>userId</kbd> is annotated with <kbd>@Path("userId")</kbd>. This lets retrofit know that <kbd>userId</kbd> holds a value that should be placed where <kbd>{userId}</kbd> is located in the HTTP request URL path.</span></p>
<p class="p1"><span class="s1"><kbd>@Header</kbd> is similar to <kbd>@Headers</kbd>, with the exception that it is used to specify a single header key-value pair in an HTTP request to be sent. Annotating authorization with <kbd>@Header("Authorization")</kbd> sets the <kbd>Authorization</kbd> header of the HTTP request sent to the value held within authorization.</span></p>
<p class="p1"><span class="s1">Now that we have created an appropriate <kbd>MessengerApiService</kbd> interface to model the HTTP API that our application will communicate with, we need to be able to retrieve an instance of this service. We can easily do this by creating a <kbd>Factory</kbd> companion object that's in charge of the creation of&#160;<kbd>MessengerApiService</kbd>&#160;instances:</span></p>
<pre class="p1"><span class="s1">package com.example.messenger.service<br/><br/></span><span class="s1">import com.example.messenger.data.remote.request.LoginRequestObject<br/></span><span class="s1">import com.example.messenger.data.remote.request.MessageRequestObject<br/></span><span class="s1">import com.example.messenger.data.remote.request.StatusUpdateRequestObject<br/></span><span class="s1">import com.example.messenger.data.remote.request.UserRequestObject<br/></span><span class="s1">import com.example.messenger.data.vo.*<br/></span><span class="s1">import io.reactivex.Observable<br/></span><span class="s1">import okhttp3.ResponseBody<br/></span><span class="s1">import retrofit2.Retrofit<br/></span><span class="s1">import retrofit2.adapter.rxjava2.RxJava2CallAdapterFactory<br/></span><span class="s1">import retrofit2.converter.gson.GsonConverterFactory<br/></span><span class="s1">import retrofit2.http.*<br/><br/></span><span class="s1">interface MessengerApiService {<br/></span><span class="s1"><span class="Apple-converted-space">  </span>…<br/></span><span class="s1"><span class="Apple-converted-space">  </span></span><span class="s1">…<br/></span><span class="s1"><span class="Apple-converted-space">   <br/></span></span><span class="s1"><span class="Apple-converted-space">  </span>companion object Factory {<br/></span><span class="s1"><span class="Apple-converted-space">    </span>private var service: MessengerApiService? = null</span></pre>
<p class="p1"><span class="s1">It returns an instance of <kbd>MessengerApiService</kbd> when invoked. A new instance of <kbd>MessengerApiService</kbd> is created, if one has not been previously created<br/></span></p>
<pre class="p1"><span class="s1"><span class="Apple-converted-space">   </span>fun getInstance(): MessengerApiService {<br/></span><span class="s1"><span class="Apple-converted-space">      </span>if (service == null) {<br/><br/></span><span class="s1"><span class="Apple-converted-space">        </span>val retrofit = Retrofit.Builder()<br/></span><span class="s1"><span class="Apple-converted-space">                 </span>.addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><span class="s1"><span class="Apple-converted-space">                   <br/></span>                 .addConverterFactory(GsonConverterFactory.create())<br/></span><span class="s1"><span class="Apple-converted-space">                 </span>.baseUrl("{AWS_URL}") <br/>                 // replace AWS_URL with URL of AWS EC2 <br/>                 // instance deployed in the previous chapter<br/></span><span class="s1"><span class="Apple-converted-space">                 </span>.build()<br/><br/></span><span class="s1"><span class="Apple-converted-space">        </span>service = retrofit.create(MessengerApiService::class.java)<br/></span><span class="s1"><span class="Apple-converted-space">      </span>}<br/><br/></span><span class="s1"><span class="Apple-converted-space">      </span>return service as MessengerApiService<br/></span><span class="s1"><span class="Apple-converted-space">    </span>}<br/></span><span class="s1"><span class="Apple-converted-space">  </span>}<br/></span><span class="s1">}</span></pre>
<p class="p1"><span class="s1"><kbd>Factory</kbd> possesses a single <kbd>getInstance()</kbd> function that builds and returns an instance of <kbd>MessengerApiService</kbd> when called. An instance of <kbd>Retrofit.Builder</kbd> is used to create the interface. We set<span class="Apple-converted-space">&#160;</span> the <kbd>CallAdapterFactory</kbd> in use to <kbd>RxJava2CallAdapterFactory</kbd> and we set the<span class="Apple-converted-space">&#160;</span><kbd>ConverterFactory</kbd> in use to <kbd>GsonConverterFactory</kbd> (this handles JSON serialization and deserialization). Don't forget to replace <kbd>"{AWS_URL}"</kbd>&#160;with the URL of the Messenger API AWS EC2 instance deployed in <a href="kt-prog-ex_ch04.html">Chapter 4</a>, <em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em>.</span></p>
<p class="p1"><span class="s1">After creating the <kbd>Retrofit.Builder()</kbd> instance successfully, we use it to create an instance of <kbd>MessengerApiService</kbd>, as follows:</span></p>
<pre class="p1"><span class="s1">service = retrofit.create(MessengerApiService::class.java)</span></pre>
<p class="p1"><span class="s1">Lastly, the service is returned for use by <kbd>getInstance()</kbd>. Regardless of the fact that we have created a suitable service to communicate with the Messenger API, it cannot be used to communicate with a network without specifying the necessary permissions in the <kbd>AndroidManifest</kbd>. Open the project's <kbd>AndroidManifest</kbd> and add the following two lines of code within the <kbd>&lt;manifest&gt;&lt;/manifest&gt;</kbd> tag:</span></p>
<pre><span>&lt;uses-permission </span><span>android</span><span>:name=</span><span>"android.permission.INTERNET" </span><span>/&gt;<br/></span><span>&lt;uses-permission </span><span>android</span><span>:name=</span><span>"android.permission.ACCESS_NETWORK_STATE" </span><span>/&gt;</span></pre>
<p class="p1"><span class="s1">Now that we have the messenger service ready to go, it is time that we create appropriate repositories to exploit this service.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing data repositories</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">You are already familiar with repositories, so there is no need for an introduction to them. The repositories we are about to create are similar to those created for the Messenger API in <a href="kt-prog-ex_ch04.html">Chapter 4</a><span>,&#160;</span><em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em>. The only difference is that the data source for the repositories we are about to implement is a remote server, not a database residing on a host.</span></p>
<p class="p1"><span class="s1">Create a <kbd>repository</kbd> package within the <kbd>remote</kbd> package. First and foremost, we are going to implement a user repository to retrieve data pertaining to application users. Add a <kbd>UserRepository</kbd> interface to the repository, as follows:</span></p>
<pre><span>package </span>com.example.messenger.data.remote.repository<br/><br/><span>import </span>com.example.messenger.data.vo.UserListVO<br/><span>import </span>com.example.messenger.data.vo.UserVO<br/><span>import </span>io.reactivex.Observable<br/><span><br/></span><span>interface </span>UserRepository {<br/><br/>  <span>fun </span><span>findById</span>(id: Long): Observable&lt;UserVO&gt;<br/>  <span>fun </span><span>all</span>(): Observable&lt;UserListVO&gt;<br/>  <span>fun </span><span>echoDetails</span>(): Observable&lt;UserVO&gt;<br/>}</pre>
<p class="p1"><span class="s1">As this is an interface, we need to create a class that implements the functions specified within <kbd>UserRepository</kbd>. We will name this class <kbd>UserRepositoryImpl</kbd>. Create a new <kbd>UserRepositoryImpl</kbd> within the repositories package, as follows:</span></p>
<pre><span>package </span>com.example.messenger.data.remote.repository<br/><br/><span>import </span>android.content.Context<br/><span>import </span>com.example.messenger.service.MessengerApiService<br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.data.vo.UserListVO<br/><span>import </span>com.example.messenger.data.vo.UserVO<br/><span>import </span>io.reactivex.Observable<br/><span><br/></span><span>class </span>UserRepositoryImpl(ctx: Context) : UserRepository {<br/><br/>  <span>private val </span><span>preferences</span>: AppPreferences = AppPreferences.create(ctx)<br/>  <span>private val </span><span>service</span>: MessengerApiService = MessengerApiService.getInstance()<br/><br/>  <span>override fun </span><span>findById</span>(id: Long): Observable&lt;UserVO&gt; {<br/>    <span>return </span><span>service</span>.showUser(id<span>, </span><span>preferences</span>.<span>accessToken </span><span>as </span>String)<br/>  }<br/><br/>  <span>override fun </span><span>all</span>(): Observable&lt;UserListVO&gt; {<br/>    <span>return </span><span>service</span>.listUsers(<span>preferences</span>.<span>accessToken </span><span>as </span>String)<br/>  }<br/><br/>  <span>override fun </span><span>echoDetails</span>(): Observable&lt;UserVO&gt; {<br/>    <span>return </span><span>service</span>.echoDetails(<span>preferences</span>.<span>accessToken </span><span>as </span>String)<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">The preceding <kbd>UserRepositoryImpl</kbd>&#160;class has two instance variables: <kbd>preferences</kbd> and <kbd>service</kbd>. The <kbd>preferences</kbd>&#160;variable is an instance of the <kbd>AppPreferences</kbd> class we created earlier and <kbd>service</kbd> is an instance of <kbd>MessengerApiService</kbd> retrieved by the <kbd>getInstance()</kbd> function defined in the <kbd>Factory</kbd> companion object in the <kbd>MessengerApiService</kbd> interface.</span></p>
<p class="p1"><span class="s1"><kbd>UserRepositoryImpl</kbd> provides implementations of the <kbd>findById()</kbd>, <kbd>all()</kbd>, and <kbd>echoDetails()</kbd> functions defined in <kbd>UserRepository</kbd>. The three functions implemented make use of <kbd>service</kbd> to retrieve the required data residing on the server via HTTP-appropriate requests. <kbd>findById()</kbd> calls the <kbd>showUser()</kbd> function in service to send a request to the Messenger API to retrieve the details of the user with the specified user ID. The <kbd>showUser()</kbd> function requires the authorization token of the currently logged-in user as its second argument. We provide this required token via the <kbd>AppPreferences</kbd> instance by passing <kbd>preferences.accessToken</kbd> as the second argument to the function.</span></p>
<p class="p1"><span class="s1">The <kbd>all()</kbd>&#160;function makes use of <kbd>MessengerApiService#listUsers()</kbd> to retrieve all the users that are registered on the messenger service. The&#160;<kbd>echoDetails()</kbd>&#160;function makes use of the <kbd>MessengerApiService#echoDetails()</kbd> function to get the details of the currently logged-in user.</span></p>
<p class="p1"><span class="s1">Let's create a conversation repository to facilitate the access of data pertaining to conversations. Add a <kbd>ConversationRepository</kbd> interface to <kbd>com.example.messenger.data.remote.repository</kbd> with the following content:</span></p>
<pre><span>package </span>com.example.messenger.data.remote.repository<br/><br/><span>import </span>com.example.messenger.data.vo.ConversationListVO<br/><span>import </span>com.example.messenger.data.vo.ConversationVO<br/><span>import </span>io.reactivex.Observable<br/><span><br/></span><span>interface </span>ConversationRepository {<br/>  <span>fun </span><span>findConversationById</span>(id: Long): Observable&lt;ConversationVO&gt;<br/><br/>  <span>fun </span><span>all</span>(): Observable&lt;ConversationListVO&gt;<br/>}</pre>
<p class="p1"><span class="s1">Now create a corresponding <kbd>ConversationRepositoryImpl</kbd> class in the package, as follows:</span></p>
<pre><span>pac</span><span>kage </span>com.example.messenger.data.remote.repository<br/><br/><span>import </span>android.content.Context<br/><span>import </span>com.example.messenger.service.MessengerApiService<br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.data.vo.ConversationListVO<br/><span>import </span>com.example.messenger.data.vo.ConversationVO<br/><span>import </span>io.reactivex.Observable<br/><span><br/></span><span>class </span>ConversationRepositoryImpl(ctx: Context) : ConversationRepository {<br/><br/>  <span>private val </span><span>preferences</span>: AppPreferences = AppPreferences.create(ctx)<br/>  <span>private val </span><span>service</span>: MessengerApiService = MessengerApiService<br/>                                             .getInstance()<br/><br/>  </pre>
<p>It retrieves information pertaining to a conversation with the requested conversation ID from the Messenger API:</p>
<pre>  <span>override fun </span><span>findConversationById</span>(id: Long): Observable&lt;ConversationVO&gt; {<br/>    <span>return </span><span>service</span>.showConversation(id<span>, </span><span>preferences</span>.<span>accessToken </span><span>as </span>String)<br/>  }</pre>
<p>It retrieves all active conversations of current user from API when invoked:</p>
<pre>  <span>override fun </span><span>all</span>(): Observable&lt;ConversationListVO&gt; {<br/>    <span>return </span><span>service</span>.listConversations(<span>preferences</span>.<span>accessToken </span><span>as </span>String)<br/>  }<br/>}</pre>
<p class="p1"><span class="s1"><kbd>findConversationById(Long)</kbd> retrieves the conversation thread with the corresponding ID passed to the function. The <kbd>all()</kbd> function simply retrieves all of the current user's active conversations.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the login interactor</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">It is time to create our login interaction, which will serve as the model that the login presenter will interact with.&#160;</span>Create a<span>&#160;</span><kbd>LoginInteractor</kbd><span>&#160;</span>interface in the<span>&#160;</span><kbd>login</kbd><span>&#160;</span>package containing the following code:</p>
<pre><span>package </span>com.example.messenger.ui.login<br/><br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.ui.auth.AuthInteractor<br/><span><br/></span><span>interface </span>LoginInteractor : AuthInteractor {<br/><br/>  <span>interface </span>OnDetailsRetrievalFinishedListener {<br/>    <span>fun </span><span>onDetailsRetrievalSuccess</span>()<br/>    <span>fun </span><span>onDetailsRetrievalError</span>()<br/>  }<br/><br/>  <span>fun </span><span>login</span>(username: String<span>, </span>password: String<span>, <br/></span>      listener: AuthInteractor.onAuthFinishedListener)<br/><br/>  <span>fun </span><span>retrieveDetails</span>(preferences: AppPreferences<span>,<br/>      </span>listener: OnDetailsRetrievalFinishedListener)<br/>}</pre>
<p>As you may have noticed,<span>&#160;</span><kbd>LoginInteractor</kbd><span>&#160;</span>extends<span>&#160;</span><kbd>AuthInteractor</kbd>.&#160;<span class="s1">This is similar to the way that <kbd>LoginView</kbd> extends <kbd>AuthView</kbd>. The&#160;<kbd>AuthInteractor</kbd>&#160;interface declares behaviors and characteristics that must be implemented by any interactor that handles authentication-related logic. Let's implement the <kbd>AuthInteractor</kbd> interface now.</span></p>
<p>Go ahead and add an<span>&#160;</span><kbd>AuthInteractor</kbd><span>&#160;</span>interface to the <kbd>com.exampla.messenger.auth</kbd> package:</p>
<pre><span>package </span>com.example.messenger.ui.auth<br/><br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.data.remote.vo.UserVO<br/><span><br/></span><span>interface </span>AuthInteractor {<br/><br/>  <span>var </span><span>userDetails</span>: UserVO<br/>  <span>var </span><span>accessToken</span>: String<br/>  <span>var </span><span>submittedUsername</span>: String<br/>  <span>var </span><span>submittedPassword</span>: String<br/><br/>  <span>interface </span>onAuthFinishedListener {<br/>    <span>fun </span><span>onAuthSuccess</span>()<br/>    <span>fun </span><span>onAuthError</span>()<br/>    <span>fun </span><span>onUsernameError</span>()<br/>    <span>fun </span><span>onPasswordError</span>()<br/>  }<br/><br/>  <span>fun </span><span>persistAccessToken</span>(preferences: AppPreferences)<br/><br/>  <span>fun </span><span>persistUserDetails</span>(preferences: AppPreferences)<br/><br/>}</pre>
<p class="p1"><span class="s1">Every interactor that is an <kbd>AuthInteractor</kbd> must have the following fields: <kbd>userDetails</kbd>, <kbd>accessToken</kbd>, <kbd>submittedUsername</kbd>, and <kbd>submittedPassword</kbd>. In addition, an interactor that implements <kbd>AuthInteractor</kbd> must have <kbd>persistAccessToken(AppPreferences)</kbd> and <kbd>persistUserDetails(AppPreferences)</kbd> methods. As the names of the methods suggest, they persist access tokens and user details to the application's <kbd>SharedPreferences</kbd> file. As you might have guessed, we need to create an implementation class for the <kbd>LoginInteractor</kbd>. We will call this class <kbd>LoginInteractorImpl</kbd>.</span></p>
<p class="p1"><span class="s1">The following is the <kbd>LoginInteractorImpl</kbd> class with its implemented <kbd>login()</kbd> method. Add it to the <kbd>login</kbd> package within the <kbd>ui</kbd> package:</span></p>
<pre><span>package </span>com.example.messenger.ui.login<br/><br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.data.remote.request.LoginRequestObject<br/><span>import </span>com.example.messenger.data.vo.UserVO<br/><span>import </span>com.example.messenger.service.MessengerApiService<br/><span>import </span>com.example.messenger.ui.auth.AuthInteractor<br/><span>import </span>io.reactivex.android.schedulers.AndroidSchedulers<br/><span>import </span>io.reactivex.schedulers.Schedulers<br/><br/><span><br/></span><span>class </span>LoginInteractorImpl : LoginInteractor {<br/><br/>  <span>override lateinit var </span><span>userDetails</span>: UserVO<br/>  <span>override lateinit var </span><span>accessToken</span>: String<br/>  <span>override lateinit var </span><span>submittedUsername</span>: String<br/>  <span>override lateinit var </span><span>submittedPassword</span>: String<br/><br/>  <span>private val </span><span>service</span>: MessengerApiService = MessengerApiService<br/>                                             .getInstance()<br/><br/>  <span>override fun </span><span>login</span>(username: String<span>, </span>password: String<span>, <br/></span>                     listener: AuthInteractor.onAuthFinishedListener) {<br/>    <span>when </span>{<br/>     </pre>
<p><span>If an empty <kbd>username</kbd> is submitted in the login form, the <kbd>username</kbd> is invalid.</span> <span>The listener's <kbd>onUsernameError()</kbd> function is called when this happens:</span></p>
<pre>username.<span>isBlank</span>() -&gt; listener.onUsernameError() </pre>
<p><span>Call the listener's <kbd>onPasswordError()</kbd> function when an empty&#160;</span><span><kbd>password</kbd> is submitted:</span></p>
<pre><span> </span>password.<span>isBlank</span>() -&gt; listener.onPasswordError()<br/><span>else </span>-&gt; {     </pre>
<p><span>Initializing model's <kbd>submittedUsername</kbd> and <kbd>submittedPassword</kbd> fields and creating appropriate <kbd>LoginRequestObject</kbd>:</span></p>
<pre><span>submittedUsername </span>= username<br/><span>submittedPassword </span>= password<br/><span>val </span>requestObject = LoginRequestObject(username<span>, </span>password)   </pre>
<p><span>Using <kbd>MessengerApiService</kbd> to send a login request to Messenger API.</span></p>
<pre><span>service</span>.login(requestObject)<br/>       .subscribeOn(Schedulers.io())   <br/><span>         // subscribing Observable to Scheduler thread<br/></span><span>       </span>.observeOn(AndroidSchedulers.mainThread())  <br/><span>          // setting observation to be done on the main thread<br/></span><span>       </span>.subscribe(<span>{ </span>res <span>-&gt;<br/></span><span>         </span><span>if </span>(res.code() != <span>403</span>) {<br/>           <span>accessToken </span>= res.headers()[<span>"Authorization"</span>] <span>as </span>String<br/>           listener.onAuthSuccess()<br/>         } <span>else </span>{<br/>                   </pre>
<p><span>Branched reached when an HTTP 403 (forbidden)</span> <span>status code is returned by the server. This indicates</span> <span>that the login failed and the user is not<br/>
authorized to access the server.</span></p>
<pre><span>            </span>listener.onAuthError()<br/>          }<br/>        <span>}</span><span>, </span><span>{ </span>error <span>-&gt;<br/></span><span>          </span>listener.onAuthError()<br/>          error.printStackTrace()<br/>        <span>}</span>)<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p><kbd>login()</kbd> works by first verifying that the provided <kbd>username</kbd> and <kbd>password</kbd> arguments are not blank. The <kbd>onUsernameError()</kbd> function of the <kbd>onAuthFinishedListener</kbd> is invoked when a blank username is encountered and <kbd>onPasswordError()</kbd> is invoked when a blank password is encountered. If neither the username nor password provided is blank, it then makes use of <kbd>MessengerApiService</kbd> to send a login request to the messenger API. If the login request is successful, then it sets the <kbd>accessToken</kbd> property to the access token retrieved from the <kbd>Authorization</kbd> header of the API response and then invoked the listener's <kbd>onAuthSuccess()</kbd> function. In a scenario when the login request fails, the <kbd>onAuthError()</kbd> listener function is invoked.</p>
<p>Having understood the login process, add the <kbd>retrieveDetails()</kbd>, <kbd>persistAccessToken()</kbd> and <kbd>persistUserDetails()</kbd> methods below to <kbd>LoginInteractorImpl</kbd>:</p>
<pre>  <span>override fun </span><span>retrieveDetails</span>(preferences: AppPreferences<span>,<br/></span>              listener: LoginInteractor.OnDetailsRetrievalFinishedListener) {<br/>    </pre>
<p><span>It retrieves details of user upon initial login:</span></p>
<pre><span>  service</span>.echoDetails(preferences.<span>accessToken </span><span>as </span>String)<br/>         .subscribeOn(Schedulers.io())<br/>         .observeOn(AndroidSchedulers.mainThread())<br/>         .subscribe(<span>{ </span>res <span>-&gt;<br/></span><span>           </span><span>userDetails </span>= res<br/>           listener.onDetailsRetrievalSuccess()<span>}</span><span>,<br/></span><span>         </span><span>{ </span>error <span>-&gt;<br/></span><span>           </span>listener.onDetailsRetrievalError()<br/>           error.printStackTrace()<span>}</span>)<br/>}<br/><br/><span>override fun </span><span>persistAccessToken</span>(preferences: AppPreferences) {<br/>  preferences.storeAccessToken(<span>accessToken</span>)<br/>}<br/><br/><span>override fun </span><span>persistUserDetails</span>(preferences: AppPreferences) {<br/>  preferences.storeUserDetails(<span>userDetails</span>)<br/>}</pre>
<p class="p1"><span class="s1">Make sure to read through the comments in the preceding code snippet carefully. They thoroughly explain the workings of the <kbd>LoginInteractor</kbd>. It is now time to work on the <kbd>LoginPresenter</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the login presenter</h1>
                </header>
            
            <article>
                
<p>A presenter, as we saw in <a href="kt-prog-ex_ch03.html">Chapter 3</a>,&#160;<em>Implementing Tetris Logic and Functionality</em>, is the middleman between a view and a model. It is necessary to create suitable presenters for views to properly facilitate clean view-model interactions. Creating a presenter is fairly easy. We need to first create an interface that properly declares the behaviors that will be exhibited by the presenter. Create a <kbd>LoginPresenter</kbd> interface in the <kbd>login</kbd> package with the following code:</p>
<pre><span>package </span>com.example.messenger.ui.login<br/><span><br/></span><span>interface </span>LoginPresenter {<br/>  <span>fun </span><span>executeLogin</span>(username: String<span>, </span>password: String)<br/>}</pre>
<p>As can be easily seen in the preceding code snippet, we want a class that acts as a <kbd>LoginPresenter</kbd> for a <kbd>LoginView</kbd> to possess an <kbd>executeLogin(String, String)</kbd> function. This function will be called by the view and will then interact with a model handling the login logic for the application. We will need to create a <kbd>LoginPresenterImpl</kbd> class that implements <kbd>LoginPresenter</kbd>:</p>
<pre><span>package </span>com.example.messenger.ui.login<br/><br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.ui.auth.AuthInteractor<br/><span><br/><br/></span><span>class </span>LoginPresenterImpl(<span>private val </span><span>view</span>: LoginView) : <br/>      LoginPresenter<span>, </span>AuthInteractor.onAuthFinishedListener<span>, <br/></span>      LoginInteractor.OnDetailsRetrievalFinishedListener {<br/><span><br/></span><span>  </span><span>private val </span><span>interactor</span>: LoginInteractor = LoginInteractorImpl()<br/>  <span>private val </span><span>preferences</span>: AppPreferences = AppPreferences.create(<span>view</span>.getContext())<br/><br/>  <span>override fun </span><span>onPasswordError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.setPasswordError()<br/>  }<br/><br/>  <span>override fun </span><span>onUsernameError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.setUsernameError()<br/>  }<br/><br/>  <span>override fun </span><span>onAuthSuccess</span>() {<br/>    <span>interactor</span>.persistAccessToken(<span>preferences</span>)<span><br/></span><span>    </span><span>interactor</span>.retrieveDetails(<span>preferences</span><span>, this</span>)<br/>  }<br/><br/>  <span>override fun </span><span>onAuthError</span>() {<br/>    <span>view</span>.showAuthError()<br/>    <span>view</span>.hideProgress()<br/>  }<br/><br/>  <span>override fun </span><span>onDetailsRetrievalSuccess</span>() {<br/>    <span>interactor</span>.persistUserDetails(<span>preferences</span>)<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.navigateToHome()<br/>  }<br/><br/>  <span>override fun </span><span>onDetailsRetrievalError</span>() {<span><br/></span><span>    </span><span>interactor</span>.retrieveDetails(<span>preferences</span><span>, this</span>)<br/>  }<br/><span><br/></span><span>  </span><span>override fun </span><span>executeLogin</span>(username: String<span>, </span>password: String) {<br/>    <span>view</span>.showProgress()<span><br/></span><span>    </span><span>interactor</span>.login(username<span>, </span>password<span>, this</span>)<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>LoginPresenterImpl</kbd>&#160;class implements <kbd>LoginPresenter</kbd>, <kbd>AuthInteractor.onAuthFinishedListener</kbd>, and <kbd>LoginInteractor.OnDetailsRetrievalFinishedListener</kbd>, and, as such, implements all behaviors required by the interfaces. <kbd>LoginPresenterImpl</kbd> overrides seven functions in all:&#160;<kbd>onPasswordError()</kbd>, <kbd>onUsernameError()</kbd>, <kbd>onAuthSuccess()</kbd>, <kbd>onAuthError()</kbd>, <kbd>onDetailsRetrievalSuccess()</kbd>, <kbd>onDetailsRetrievalError()</kbd>, and <kbd>executeLogin(String, String)</kbd>. The interaction between the <kbd>LoginPresenter</kbd> and <kbd>LoginInteractor</kbd> can be seen within the <kbd>onAuthSuccess()</kbd> and <kbd>executeLogin(String, String)</kbd> functions. When a user submits their login details, the <kbd>LoginView</kbd> calls the <kbd>executeLogin(String, String)</kbd> function in <kbd>LoginPresenter</kbd>. In turn, <kbd>LoginPresenter</kbd> uses <kbd>LoginInteractor</kbd> to handle the actual login procedure by calling&#160;the&#160;<kbd>login(String, String)</kbd> function of <kbd>LoginInteractor</kbd>.</span></p>
<p class="p1"><span class="s1">If the user login is successful, the <kbd>onAuthSuccess()</kbd> callback function of <kbd>LoginPresenter</kbd> is invoked by the <kbd>LoginInteractor</kbd>. This then leads to the storing of the access token returned by the server and the retrieval of the logged-in user's account details. When the login request is declined by the server, <kbd>onAuthError()</kbd> is called and an informative error message is displayed to the user.</span></p>
<p class="p1"><span class="s1">When a user's account details are successfully retrieved by the interactor, the <kbd>onDetailsRetrievalSuccess()</kbd> callback of <kbd>LoginPresenter</kbd> is invoked. This leads to the storage of the account details. The progress bar shown to the user over the course of the login is then hidden with <kbd>view.hideProgress()</kbd>, after which the user is navigated to the home screen with <kbd>view.navigateToHome()</kbd>. If the retrieval of user details fails, <kbd>onDetailsRetrievalError()</kbd> is called by <kbd>LoginInteractor</kbd>. The presenter then requests another attempt at retrieving the user's account details by calling <kbd>interactor.retrieveDetails(preferences, this)</kbd> once more.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Finishing the LoginView</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">If you recall, we did not finish our implementation of the <kbd>LoginView</kbd> earlier. Functions such as <kbd>navigateToSignUp()</kbd>, <kbd>navigateToHome()</kbd>, and <kbd>onClick(view: View)</kbd> were left with empty bodies. In addition, the <kbd>LoginView</kbd> did not interact in any way with the <kbd>LoginPresenter</kbd>. Let's fix that now, shall we?</span></p>
<p class="p1"><span class="s1">Fist things first, to navigate a user to the signup screen and home screen, we need views for these screens to exist. We won't concern ourselves with implementing layouts for them now (that will be done in the following sections). We just need them to exist. Create the&#160;<kbd>signup</kbd> and <kbd>main</kbd> packages under <kbd>com.example.messenger.ui</kbd>. Create a new empty activity called <kbd>SignUpActivity</kbd> in the <kbd>signup</kbd> package and an empty activity called <kbd>MainActivity</kbd> within <kbd>main</kbd>.</span></p>
<p class="p1"><span class="s1">Now open&#160;<kbd>LoginActivity.kt</kbd>. We need to modify the previously mentioned functions to perform their respective tasks. In addition, we need to add private properties for a <kbd>LoginPresenter</kbd> instance and an <kbd>AppPreferences</kbd> instance. These changes are made in the following code snippet:</span></p>
<p>Firstly, add the properties below to the top of the <kbd>LoginActivity</kbd> class.</p>
<pre>  <span>private lateinit var </span>progressBar: ProgressBar<br/>  <span>private lateinit var </span>presenter: LoginPresenter <span><br/></span><span>  </span><span>private lateinit var </span>preferences: AppPreferences </pre>
<p>Now modify&#160;<kbd>navigateToSignUp()</kbd><span>,&#160;</span><kbd>navigateToHome()</kbd><span>, and&#160;</span><kbd>onClick(view: View)</kbd><span>&#160;as shown in the following snippet:</span></p>
<pre><span>override fun </span>navigateToSignUp() {<br/>  startActivity(Intent(<span>this, </span>SignUpActivity::<span>class</span>.java))<br/>}<br/><br/><span>override fun </span>navigateToHome() {<br/>  finish()<br/>  startActivity(Intent(<span>this, </span>MainActivity::<span>class</span>.java))<br/>}<br/><br/><span>override fun </span>onClick(view: View) {<br/>  <span>if </span>(view.id == R.id.btn_login) {<span><br/></span><span>    </span>presenter.executeLogin(etUsername.text.toString()<span>,<br/>                           </span>etPassword.text.toString())<br/>  } <span>else if </span>(view.id == R.id.btn_sign_up) {<br/>    navigateToSignUp()<br/>  }<br/>}</pre>
<p class="p1"><span class="s1"><kbd>navigateToSignUp()</kbd> uses an explicit intent to start <kbd>SignUpActivity</kbd> when called. <kbd>navigateToHome()</kbd> operates similarly to <kbd>navigateToSignUp()</kbd><span class="Apple-converted-space">—</span>it starts <kbd>MainActivity</kbd>. A major difference between <kbd>navigateToHome()</kbd> and <kbd>navigateToSignUp()</kbd> is that <kbd>navigateToHome()</kbd>&#160;destroys the current <kbd>LoginActivity</kbd> instance by calling <kbd>finish()</kbd> before starting the <kbd>MainActivity</kbd>.</span></p>
<p class="p1"><span class="s1">The <kbd>onClick()</kbd>&#160;method uses the <kbd>LoginPresenter</kbd> to begin the login process in the scenario that the login button is clicked. Otherwise, if the signup button is clicked, the <kbd>SignUpActivity</kbd> is started with <kbd>navigateToSignUp()</kbd>.</span></p>
<p class="p1"><span class="s1">Great job thus far! We have created the necessary view, presenter, and model for login-related application logic. We need to keep in mind that before we can log in a user, we need to have registered a user on the platform first. Thus, we must implement our signup logic. We will do this in the following section.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Developing the signup UI</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Let's develop the signup user interface. First, we have to implement the necessary views, starting from the layout of <kbd>SignUpActivity</kbd>. We do not need much in terms of elements for our <kbd>SignUpActivity</kbd> layout. We need three input fields to take the username, password, and phone number of a user to be registered. In addition, we need a button to submit the signup form as well as a progress bar to show when the signup is in progress.</span></p>
<p class="p1"><span class="s1">The following is our <kbd>activity_sign_up.xml</kbd> layout:</span></p>
<pre><span>&lt;?</span><span>xml version=</span><span>"1.0" </span><span>encoding=</span><span>"utf-8"</span><span>?&gt;<br/></span><span>&lt;android.support.constraint.ConstraintLayout </span><span>xmlns:</span><span>android</span><span>=</span><span>"http://schemas.android.com/apk/res/android"<br/></span><span>    </span><span>xmlns:</span><span>tools</span><span>=</span><span>"http://schemas.android.com/tools"<br/></span><span>    </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>    </span><span>android</span><span>:layout_height=</span><span>"match_parent"<br/></span><span>    </span><span>tools</span><span>:context=</span><span>".ui.signup.SignUpActivity"<br/></span><span>    </span><span>android</span><span>:paddingTop=</span><span>"@dimen/default_padding"<br/></span><span>    </span><span>android</span><span>:paddingBottom=</span><span>"@dimen/default_padding"<br/></span><span>    </span><span>android</span><span>:paddingStart=</span><span>"@dimen/default_padding"<br/></span><span>    </span><span>android</span><span>:paddingEnd=</span><span>"@dimen/default_padding"<br/></span><span>    </span><span>android</span><span>:orientation=</span><span>"vertical"<br/></span><span>    </span><span>android</span><span>:gravity=</span><span>"center_horizontal"</span><span>&gt;<br/></span><span>    &lt;EditText<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/et_username"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/username"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"text"</span><span>/&gt;<br/></span><span>    &lt;EditText<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/et_phone"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/phone_number"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"phone"</span><span>/&gt;<br/></span><span>    &lt;EditText<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/et_password"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"match_parent"<br/></span><span>        </span><span>android</span><span>:</span><span>layout_height</span><span>=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:hint=</span><span>"@string/password"<br/></span><span>        </span><span>android</span><span>:inputType=</span><span>"textPassword"</span><span>/&gt;<br/></span><span>    &lt;Button<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/btn_sign_up"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:text=</span><span>"@string/sign_up"</span><span>/&gt;<br/></span><span>    &lt;ProgressBar<br/></span><span>        </span><span>android</span><span>:id=</span><span>"@+id/progress_bar"<br/></span><span>        </span><span>android</span><span>:layout_width=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_height=</span><span>"wrap_content"<br/></span><span>        </span><span>android</span><span>:layout_marginTop=</span><span>"@dimen/default_margin"<br/></span><span>        </span><span>android</span><span>:visibility=</span><span>"gone"</span><span>/&gt;<br/></span><span>&lt;/android.support.constraint.ConstraintLayout&gt;</span></pre>
<p class="p1"><span class="s1">The visual translation of the XML layout written earlier is as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="images/3479aa1d-d799-44cf-a594-53284db40d6e.jpg" style="width:16.58em;height:27.58em;"/></div>
<p class="p1"><span class="s1">As you can see, the layout we designed contains all the necessary elements we previously mentioned.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the signup interactor</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">Now we will implement a signup interactor to act as a model that our yet-to-be-implemented signup presenter will communicate with. Create a <kbd>SignUpInteractor</kbd> interface within the <kbd>signup</kbd>&#160;package, as follows:</span></p>
<pre><span>package </span>com.example.messenger.ui.signup<br/><br/><span>import </span>com.example.messenger.ui.auth.AuthInteractor<br/><span><br/><br/></span><span>interface </span>SignUpInteractor : AuthInteractor {<br/><br/>  <span>interface </span>OnSignUpFinishedListener {<br/>    <span>fun </span><span>onSuccess</span>()<br/>    <span>fun </span><span>onUsernameError</span>()<br/>    <span>fun </span><span>onPasswordError</span>()<br/>    <span>fun </span><span>onPhoneNumberError</span>()<br/>    <span>fun </span><span>onError</span>()<br/>  }<br/><br/>  <span>fun </span><span>signUp</span>(username: String<span>, </span>phoneNumber: String<span>, </span>password: String<span>, <br/></span>             listener: OnSignUpFinishedListener)<br/><br/>  <span>fun </span><span>getAuthorization</span>(listener: AuthInteractor.onAuthFinishedListener)<br/>}</pre>
<p class="p1"><span class="s1">You may have noticed that <kbd>SignUpInteractor</kbd> extends <kbd>AuthInteractor</kbd>. Similar to a <kbd>LoginInteractor</kbd>, a <kbd>SignUpInteractor</kbd> requires the use of <kbd>userDetails</kbd>, <kbd>accessToken</kbd>, <kbd>submittedUsername</kbd>, and <kbd>submittedPassword</kbd> properties. In addition, <kbd>SignUpInteractor</kbd> needs to be able to persist the access token of a user as well as their user details by using the&#160;<kbd>persistAccessToken(AppPreferences)</kbd> and <kbd>persistUserDetails(AppPreferences)</kbd> functions, which are declared in the <kbd>AuthInteractor</kbd> interface.</span></p>
<p class="p1"><span class="s1">We created an <kbd>OnSignUpFinishedListener</kbd> interface within <kbd>SignUpInteractor</kbd> declaring callbacks that must be implemented by an <kbd>OnSignUpFinishedListener</kbd>. This listener will be our <kbd>SignUpPresenter</kbd> when we implement it.</span></p>
<p class="p1"><span class="s1">In creating <kbd>SignUpInteractorImpl</kbd>, we shall start first and foremost with its property declarations and the implementation of its <kbd>login()</kbd> method. Create <kbd>SignUpInteractorImpl</kbd>&#160;which is as follows. Ensure that you add it to the same package as <kbd>SignUpInteractor</kbd>:</span></p>
<pre><span>package </span>com.example.messenger.ui.signup<br/><br/><span>import </span>android.text.TextUtils<br/><span>import </span>android.util.Log<br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.data.remote.request.LoginRequestObject<br/><span>import </span>com.example.messenger.data.remote.request.UserRequestObject<br/><span>import </span>com.example.messenger.data.vo.UserVO<br/><span>import </span>com.example.messenger.service.MessengerApiService<br/><span>import </span>com.example.messenger.ui.auth.AuthInteractor<br/><span>import </span>io.reactivex.android.schedulers.AndroidSchedulers<br/><span>import </span>io.reactivex.schedulers.Schedulers<br/><span><br/></span><span>class </span>SignUpInteractorImpl : SignUpInteractor {<br/><br/>  <span>override lateinit var </span><span>userDetails</span>: UserVO<br/>  <span>override lateinit var </span><span>accessToken</span>: String<br/>  <span>override lateinit var </span><span>submittedUsername</span>: String<br/>  <span>override lateinit var </span><span>submittedPassword</span>: String<br/><br/>  <span>private val </span><span>service</span>: MessengerApiService = MessengerApiService<br/>                                             .getInstance()<br/><br/>  <span>override fun </span><span>signUp</span>(username: String<span>, <br/></span>                      phoneNumber: String<span>, </span>password: String<span>,<br/></span><span>                      </span>listener: SignUpInteractor.OnSignUpFinishedListener){<br/>    <span>submittedUsername </span>= username<br/>    <span>submittedPassword </span>= password<br/>    <span>val </span>userRequestObject = UserRequestObject(username<span>, </span>password<span>,<br/>                                              </span>phoneNumber)<br/><br/>    <span>when </span>{<br/>      TextUtils.isEmpty(username) -&gt; listener.onUsernameError()<br/>      TextUtils.isEmpty(phoneNumber) -&gt; listener.onPhoneNumberError()<br/>      TextUtils.isEmpty(password) -&gt; listener.onPasswordError()<br/>      <span>else </span>-&gt; {</pre>
<p><span>Registering a new user to the Messenger platform</span> <span>with the <kbd>MessengerApiService</kbd></span></p>
<pre><span><br/></span><span>        </span><span>service</span>.createUser(userRequestObject)<br/>               .subscribeOn(Schedulers.io())<br/>               .observeOn(AndroidSchedulers.mainThread())<br/>               .subscribe(<span>{ </span>res <span>-&gt;<br/></span><span>          </span><span>userDetails </span>= res<br/>          listener.onSuccess()<br/>        <span>}</span><span>, </span><span>{ </span>error <span>-&gt;<br/></span><span>          </span>listener.onError()<br/>          error.printStackTrace()<br/>        <span>}</span>)<br/>      }<br/>    }<br/>  }<br/>}</pre>
<p>Now add the <kbd>getAuthorization()</kbd>, <kbd>persistAccessToken()</kbd> and <kbd>persistUserDetails()</kbd> methods below to <kbd>SignUpInteractorImpl</kbd>:</p>
<pre>  <span>override fun </span><span>getAuthorization</span>(listener: <br/>                  AuthInteractor.onAuthFinishedListener) {<br/>    <span>val </span>userRequestObject = LoginRequestObject(<span>submittedUsername</span><span>,<br/>                                               </span><span>submittedPassword</span>)<br/><br/>    </pre>
<p><span>Let's log the registered user in to the platform</span> <span>with the <kbd>MessengerApiService</kbd>:</span></p>
<pre><span>    </span><span>service</span>.login(userRequestObject)<br/>           .subscribeOn(Schedulers.io())<br/>           .observeOn(AndroidSchedulers.mainThread())<br/>           .subscribe( <span>{ </span>res <span>-&gt;<br/></span><span>      </span><span>accessToken </span>= res.headers()[<span>"Authorization"</span>] <span>as </span>String<br/><br/>      </pre>
<p><span>Now, user has been successfully logged in.&#160;</span><span>Hence, we invoke listener's <kbd>onAuthSuccess()</kbd></span> <span>callback:</span></p>
<pre><span><br/></span><span>    </span>listener.onAuthSuccess()<br/><br/>  }<span>, </span><span>{ </span>error <span>-&gt;<br/></span><span>    </span>listener.onAuthError()<br/>    error.printStackTrace()<br/>  <span>}</span>)<br/>}<br/><br/><span>override fun </span><span>persistAccessToken</span>(preferences: AppPreferences) {<br/>  preferences.storeAccessToken(<span>accessToken</span>)<br/>}<br/><br/><span>override fun </span><span>persistUserDetails</span>(preferences: AppPreferences) {<br/>  preferences.storeUserDetails(<span>userDetails</span>)<br/>}</pre>
<p class="p1"><span class="s1">The <kbd>SignUpInteractorImpl</kbd>&#160;class is a straightforward implementation of the <kbd>SignUpInteractor</kbd> interface. Lines 19 to 22 contain property declarations for <kbd>userDetails</kbd>, <kbd>accessToken</kbd>, <kbd>submittedUsername</kbd>, and <kbd>submittedPassword</kbd> that must be possessed by an <kbd>AuthInteractor</kbd>. <kbd>signUp(String, String, String, SignUpInteractor.OnSignUpFinishedListener)</kbd> contains the signup logic for the application. If all values submitted by a user are valid, then the user is registered on the platform with the <kbd>createUser(UserRequestObject)</kbd> function of the <kbd>MessengerApiService</kbd>&#160;that we created with Retrofit.</span></p>
<p class="p1"><span class="s1"><kbd>getAuthorization(AuthInteractor.onAuthFinishedListener)</kbd> is called to authorize a newly registered user of the messenger platform. Make sure to peruse the comments within <kbd>SignUpInteractorImpl</kbd> for more information.</span></p>
<p class="p1"><span class="s1">Next on our agenda is the creation of the <kbd>SignUpPresenter</kbd>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the signup presenter</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">As we did when creating the <kbd>LoginPresenter</kbd>, we need to create a <kbd>SignUpPresenter</kbd> interface along with a <kbd>SignUpPresenterImpl</kbd> class. The <kbd>SignUpPresenter</kbd> we are making is in no way complex. For this application, we need our signup presenter to possess a property of the&#160;<kbd>AppPreferences</kbd>&#160;type as well as a function that executes the signup process. The following is the <kbd>SignUpPresenter</kbd> interface:</span></p>
<pre><span>package </span>com.example.messenger.ui.signup<br/><br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span><br/></span><span>interface </span>SignUpPresenter {<br/>  <span>var </span><span>preferences</span>: AppPreferences<br/><br/>  <span>fun </span><span>executeSignUp</span>(username: String<span>, </span>phoneNumber: String<span>, </span>password: String)<br/>}</pre>
<p class="p1"><span class="s1">Now, here is the code for our <kbd>SignUpPresenter</kbd> implementation:</span></p>
<pre><span>package </span>com.example.messenger.ui.signup<br/><br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.ui.auth.AuthInteractor<br/><span><br/></span><span>class </span>SignUpPresenterImpl(<span>private val </span><span>view</span>: SignUpView): SignUpPresenter<span>,<br/></span><span>                          </span>SignUpInteractor.OnSignUpFinishedListener<span>,<br/></span>                          AuthInteractor.onAuthFinishedListener {<br/><br/>  <span>private val </span><span>interactor</span>: SignUpInteractor = SignUpInteractorImpl()<br/>  <span>override var </span><span>preferences</span>: AppPreferences = AppPreferences<br/>                                             .create(<span>view</span>.getContext())</pre>
<p>The <kbd>onSuccess()</kbd>&#160;callback below is invoked when user is successfully signed up:</p>
<pre> <span>override fun </span><span>onSuccess</span>() {<br/>    <span>interactor</span>.getAuthorization(<span>this</span>)<br/>  }</pre>
<p>The callback invoked when an error occurs during user sign up:</p>
<pre><br/>  <span>override fun </span><span>onError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.showSignUpError()<br/>  }<br/><br/>  <span>override fun </span><span>onUsernameError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.setUsernameError()<br/>  }<br/><br/>  <span>override fun </span><span>onPasswordError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.setPasswordError()<br/>  }<br/><br/>  <span>override fun </span><span>onPhoneNumberError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.setPhoneNumberError()<br/>  }<br/><br/>  <span>override fun </span><span>executeSignUp</span>(username: String<span>, </span>phoneNumber: String<span>, <br/></span>                             password: String) {<br/>    <span>view</span>.showProgress()<br/>    <span>interactor</span>.signUp(username<span>, </span>phoneNumber<span>, </span>password<span>, this</span>)<br/>  }<br/><br/>  <span>override fun </span><span>onAuthSuccess</span>() {<br/>    <span>interactor</span>.persistAccessToken(<span>preferences</span>)<br/>    <span>interactor</span>.persistUserDetails(<span>preferences</span>)<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.navigateToHome()<br/>  }<br/><br/>  <span>override fun </span><span>onAuthError</span>() {<br/>    <span>view</span>.hideProgress()<br/>    <span>view</span>.showAuthError()<br/>  }<br/>}</pre>
<p class="p1"><span class="s1">The preceding <kbd>SignUpPresenterImpl</kbd> class implements the <kbd>SignUpPresenter</kbd>, <kbd>SignUpInteractor.OnSignUpFinishedListener</kbd>, and <kbd>AuthInteractor.onAuthFinishedListener</kbd> interfaces, and, as such, provides implementations for a number of required functions. These functions are <kbd>onSuccess()</kbd>, <kbd>onError()</kbd>, <kbd>onUsernameError()</kbd>, <kbd>onPasswordError()</kbd>, <kbd>onPhoneNumberError()</kbd>, <kbd>executeSignUp(String, String, String)</kbd>, <kbd>onAuthSuccess()</kbd>, and <kbd>onAuthError()</kbd>. <kbd>SignUpPresenterImpl</kbd> takes a single argument as its primary constructor. This argument must be of the&#160;<kbd>SignUpView</kbd>&#160;type.</span></p>
<p class="p1"><span class="s1"><kbd>executeSignUp(String, String, String)</kbd> is a function that will be invoked by a <kbd>SignUpView</kbd> to begin the user registration process. <kbd>onSuccess()</kbd> is called when a user's signup request is successful. The function immediately invokes the interactor's <kbd>getAuthorization()</kbd> function to get an access token for the newly registered user. In a scenario when a signup request fails, the <kbd>onError()</kbd> callback is invoked. This hides the progress bar being shown to the user and displays an appropriate error message.</span></p>
<p class="p1"><span class="s1">The <kbd>onUsernameError()</kbd>, <kbd>onPasswordError()</kbd>, and <kbd>onPhoneNumberError()</kbd>&#160;methods are callbacks invoked upon the occurrence of an error in a submitted username, password, or phone number, respectively. <kbd>onAuthSuccess()</kbd> is a callback invoked when the authorization procedure is successful. On the other hand, <kbd>onAuthError()</kbd> is invoked when the authorization fails.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating the signup view</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">It is time to work on the <kbd>SignUpView</kbd>. First we need to create a <kbd>SignUpView</kbd> interface, after which we will make <kbd>SignUpActivity</kbd> implement this interface. Note that in our application, a <kbd>SignUpView</kbd> is an extension of <kbd>BaseView</kbd> and <kbd>AuthView</kbd>. The following is the <kbd>SignUpView</kbd> interface:</span></p>
<pre><span>package </span>com.example.messenger.ui.signup<br/><br/><span>import </span>com.example.messenger.ui.auth.AuthView<br/><span>import </span>com.example.messenger.ui.base.BaseView<br/><span><br/></span><span>interface </span>SignUpView : BaseView<span>, </span>AuthView {<br/><br/>  <span>fun </span><span>showProgress</span>()<br/>  <span>fun </span><span>showSignUpError</span>()<br/>  <span>fun </span><span>hideProgress</span>()<br/>  <span>fun </span><span>setUsernameError</span>()<br/>  <span>fun </span><span>setPhoneNumberError</span>()<br/>  <span>fun </span><span>setPasswordError</span>()<br/>  <span>fun </span><span>navigateToHome</span>()<br/>}</pre>
<p class="p1"><span class="s1">Now we shall modify the <kbd>SignUpActivity</kbd> class in the project to implement the&#160;<kbd>SignUpView</kbd> and make use of the <kbd>SignUpPresenter</kbd>. Add the changes in the following code snippet to <kbd>SignUpActivity</kbd>:</span></p>
<pre><span>package </span>com.example.messenger.ui.signup<br/><br/><span>import </span>android.content.Context<br/><span>import </span>android.content.Intent<br/><span>import </span>android.support.v7.app.AppCompatActivity<br/><span>import </span>android.os.Bundle<br/><span>import </span>android.view.View<br/><span>import </span>android.widget.Button<br/><span>import </span>android.widget.EditText<br/><span>import </span>android.widget.ProgressBar<br/><span>import </span>android.widget.Toast<br/><span>import </span>com.example.messenger.R<br/><span>import </span>com.example.messenger.data.local.AppPreferences<br/><span>import </span>com.example.messenger.ui.main.MainActivity<br/><br/><span>class </span>SignUpActivity : AppCompatActivity()<span>, </span>SignUpView<span>, </span>View.OnClickListener {<br/><br/>  <span>private lateinit var </span><span>etUsername</span>: EditText<br/>  <span>private lateinit var </span><span>etPhoneNumber</span>: EditText<br/>  <span>private lateinit var </span><span>etPassword</span>: EditText<br/>  <span>private lateinit var </span><span>btnSignUp</span>: Button<br/>  <span>private lateinit var </span><span>progressBar</span>: ProgressBar<br/>  <span>private lateinit var </span><span>presenter</span>: SignUpPresenter<br/><br/>  <span>override fun </span><span>onCreate</span>(savedInstanceState: Bundle?) {<br/>    <span>super</span>.onCreate(savedInstanceState)<br/>    setContentView(R.layout.<span>activity_sign_up</span>)<br/>    <span>presenter </span>= SignUpPresenterImpl(<span>this</span>)<br/>    <span>presenter</span>.<span>preferences </span>= AppPreferences.create(<span>this</span>)<br/>    bindViews()<br/>  }<br/><br/>  <span>override fun </span><span>bindViews</span>() {<br/>    <span>etUsername </span>= findViewById(R.id.<span>et_username</span>)<br/>    <span>etPhoneNumber </span>= findViewById(R.id.<span>et_phone</span>)<br/>    <span>etPassword </span>= findViewById(R.id.<span>et_password</span>)<br/>    <span>btnSignUp </span>= findViewById(R.id.<span>btn_sign_up</span>)<br/>    <span>progressBar </span>= findViewById(R.id.<span>progress_bar</span>)<br/>    <span>btnSignUp</span>.setOnClickListener(<span>this</span>)<br/>  }<br/><br/>  <span>override fun </span><span>showProgress</span>() {<br/>    <span>progressBar</span>.<span>visibility </span>= View.<span>VISIBLE<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>hideProgress</span>() {<br/>    <span>progressBar</span>.<span>visibility </span>= View.<span>GONE<br/></span><span>  </span>}<br/><br/>  <span>override fun </span><span>navigateToHome</span>() {<br/>    finish()<br/>    startActivity(Intent(<span>this, </span>MainActivity::<span>class</span>.<span>java</span>))<br/>  }<br/><br/>  <span>override fun </span><span>onClick</span>(view: View) {<br/>    <span>if </span>(view.<span>id </span>== R.id.<span>btn_sign_up</span>) {<br/>      <span>presenter</span>.executeSignUp(<span>etUsername</span>.<span>text</span>.toString()<span>,<br/></span><span>                              </span><span>etPhoneNumber</span>.<span>text</span>.toString()<span>,<br/>                              </span><span>etPassword</span>.<span>text</span>.toString())<br/>    }<br/>  }<br/>}</pre>
<p>Now add the <kbd>setUsernameError()</kbd>, <kbd>setPasswordError()</kbd>, <kbd>showAuthError()</kbd>, <kbd>showSignUpError()</kbd> and <kbd>getContext()</kbd> functions shown below to <kbd>SignUpActivity</kbd>:</p>
<pre><span>override fun </span><span>setUsernameError</span>() {<br/>  <span>etUsername</span>.<span>error </span>= <span>"Username field cannot be empty"<br/></span>}<br/><br/><span>override fun </span><span>setPhoneNumberError</span>() {<br/>  <span>etPhoneNumber</span>.<span>error </span>= <span>"Phone number field cannot be empty"<br/></span>}<br/><br/><span>override fun </span><span>setPasswordError</span>() {<br/>  <span>etPassword</span>.<span>error </span>= <span>"Password field cannot be empty"<br/></span>}<br/><br/><span>override fun </span><span>showAuthError</span>() {<br/>  Toast.makeText(<span>this, </span><span>"An authorization error occurred.<br/>                        Please try again later."</span><span>,<br/></span><span>                 </span>Toast.<span>LENGTH_LONG</span>).show()<br/>}<br/><br/><span>override fun </span><span>showSignUpError</span>() {<br/>  Toast.makeText(<span>this, </span><span>"An unexpected error occurred.<br/>                        Please try again later."</span><span>,<br/></span><span>                 </span>Toast.<span>LENGTH_LONG</span>).show()<br/>}<br/><br/><span>override fun </span><span>getContext</span>(): Context {<br/>  <span>return this<br/></span>}</pre>
<p class="p1"><span class="s1">Great work thus far! At this point, we are half of the way through the development of the Messenger application. You deserve a round of applause for your efforts. But we still have some work to do—especially with the main UI. We will finish up the remainder of the Messenger application in the next chapter.&#160;</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1"><span class="s1">In this chapter, we began the development of the Messenger Android application. In the process of doing so, we covered a vast array of topics. We got down and dirty with the Model-View-Presenter pattern and explored in detail how to create an application utilizing this modern development approach.</span></p>
<p class="p1"><span class="s1">Further into the chapter, we learned about reactive programming and made extensive use of RxJava and RxAndroid. We learned how to communicate with a remote server using OkHttp and Retrofit, after which we took things one step further and implemented a fully functional Retrofit service to communicate with the Messenger API we developed in <a href="kt-prog-ex_ch04.html">Chapter 4</a><span>,&#160;</span><em>Designing and Implementing the Messenger Backend with Spring Boot 2.0</em>.</span></p>
<p class="p1"><span class="s1">In the next chapter, we will finish our work with the Messenger application.</span></p>
<p class="mce-root"></p>
<p class="mce-root"></p>
<p class="mce-root"></p>


            </article>

            
        </section>
    </div>
</body>
</html>