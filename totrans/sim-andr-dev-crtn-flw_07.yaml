- en: '*Chapter 5*: Using Kotlin Flows'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous three chapters, we dove into Kotlin coroutines and learned how
    we can use them for asynchronous programming in Android. We learned about coroutine
    builders, scopes, dispatchers, contexts, and jobs. We then learned how to handle
    coroutine cancelations, timeouts, and exceptions. We also learned how to create
    tests for coroutines in your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next three chapters, we will focus on Kotlin Flow, a new asynchronous
    stream library built on top of Kotlin coroutines. A flow can emit multiple values
    over a length of time instead of just a single value. You can use Flows for streams
    of data, such as real-time location, sensor readings, and live database values.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore Kotlin Flows. We will start by building Kotlin
    Flows. Then, we will look into the various operators you can use for transforming,
    combining, buffering, and doing more with Flows. Finally, we will learn about
    StateFlows and SharedFlows.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Flows in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Flows with Flow builders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using operators with Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffering and combining Flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring StateFlow and SharedFlow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a deeper understanding of using Kotlin
    Flows. You will be able to use Flows for various cases in your Android apps. You
    will also learn about flow builders, operators, combining flows, StateFlow, and
    SharedFlow.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need to download and install the latest version of Android Studio.
    You can find the latest version at [https://developer.android.com/studio](https://developer.android.com/studio).
    For an optimal learning experience, a computer with the following specifications
    is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: Intel Core i5 or equivalent or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB RAM minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB available space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05](https://github.com/PacktPublishing/Simplifying-Android-Development-with-Coroutines-and-Flows/tree/main/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Using Flows in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start by using flows in Android for asynchronous programming.
    Flows are ideal for the parts of your application that involve live data updates.
  prefs: []
  type: TYPE_NORMAL
- en: A Flow of data is represented by the `Flow<String>` is a flow that emits string
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Android Jetpack libraries such as Room, Paging, DataStore, WorkManager, and
    Jetpack Compose include built-in support for Flow.
  prefs: []
  type: TYPE_NORMAL
- en: The Room database library added support for Flows, starting with version 2.2\.
    This allows you to be notified of changes in the database values by using Flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Android application uses a **Data Access Object** (**DAO**) to display
    a list of movies, your project can have a DAO such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By calling the `getMovies` function from `MovieDao`, you can get the list of
    movies from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code will only fetch the list of movies once, after calling `getMovies`.
    You may want your application to automatically update the list of movies whenever
    a movie in the database has been added, removed, or updated. You can do that by
    using Room-KTX and changing your `MovieDao` to use Flow for `getMovies`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this code, every time the `movies` table has a change, `getMovies` will
    emit a new list containing the list of movies from the database. Your application
    can then use that to automatically update the movies displayed in your List or
    `RecyclerView`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `LiveData` and want to convert `LiveData` to `Flow`, or `Flow`
    to `LiveData`, you can use the LiveData KTX.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert `LiveData` to `Flow`, you can use the `LiveData.asFlow()` extension
    function. With the `Flow.asLiveData()` extension function to convert `Flow` to
    `LiveData`. You can add LiveData KTX to your project by including the following
    to your `app/build.gradle` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This adds the LiveData KTX to your project, allowing you to use the `asFlow()`
    and `asLiveData()` extension functions to convert `LiveData` to `Flow` and `Flow`
    to `LiveData`.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party Android libraries now also support Flows; some functions can return
    Flow objects. If you are using RxJava 3 in your project, you can use the `Flow`
    to `Flowable` or `Observable` and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: A flow will only start emitting values when you call the `collect` function.
    The `collect` function is a suspending function, so you should call it from a
    coroutine or another suspending function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `collect()` function was called from the coroutine
    created using the `launch` coroutine builder from `lifecycleScope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `collect{}` function was called on `Flow<Movie>` and returned
    by calling `viewModel.fetchMovies()`. This will cause the Flow to start emitting
    values, and you can then process each value.
  prefs: []
  type: TYPE_NORMAL
- en: The collection of the flow occurs in `CoroutineContext` of the parent coroutine.
    In the previous example, the coroutine context is from `viewModelScope`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change `CoroutineContext` where the Flow is run, you can use the `flowOn()`
    function. If you want to change `Dispatcher` on the Flow in the previous example
    to `Dispatchers.IO)`, you can use `flowOn(Dispatchers.IO)`, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, before collecting the Flow, the dispatcher where the Flow is run was changed
    to `Dispatchers.IO` by calling `flowOn` with `Dispatchers.IO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call `flowOn`, it will only change the preceding functions or operators
    and not the ones after you called it. In the following example, a `map` operator
    was called after the `flowOn` call to change the dispatcher, so its context won’t
    be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `flowOn` will only change the context of the ones preceding
    the call, so the `map` call will not be changed. It will still use the original
    context (which is the one from `lifecycleScope`).
  prefs: []
  type: TYPE_NORMAL
- en: In Android, you can collect Flow in the Fragment or Activity classes to display
    the data in the UI. If the UI goes to the background, your Flow will keep on collecting
    the data. Your app must not continue collecting the Flow and updating the screen
    to prevent memory leaks and avoid wasting resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To safely collect flows in the Android UI layer, you would need to handle the
    lifecycle changes yourself. You can also use `Lifecycle.repeatOnLifecycle` and
    `Flow.flowWithLifecycle`, which are available in the `app/build.gradle` dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This adds the `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Lifecycle.repeatOnLifecycle(state, block)` suspends the parent coroutine until
    the lifecycle is destroyed and executes the suspending `block` of code when the
    lifecycle is at least in `state` you set. When the lifecycle moves out of the
    state, `repeatOnLifecycle` will stop the Flow and restart it when the lifecycle
    moves back to the said state.'
  prefs: []
  type: TYPE_NORMAL
- en: If you used `repeatOnLifecycle` will start collecting the Flow whenever the
    lifecycle is started. It will stop when the lifecycle is stopped, when the `onStop()`
    of the lifecycle is called.
  prefs: []
  type: TYPE_NORMAL
- en: When you use `repeatOnLifecycle` will start collecting the Flow every time the
    lifecycle is resumed and will stop when the lifecycle is paused or when `onPause()`
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to call `Lifecycle.repeatOnLifecycle` on the activity’s `onCreate`
    or on the fragment’s `onViewCreated` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows how you can use `Lifecycle.repeatOnLifecycle` in your Android
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `repeatOnLifecycle` with **Lifecycle.State.STARTED** to start
    collecting the Flow of movies when the lifecycle is started and stop when the
    lifecycle is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `Lifecycle.repeatOnLifecycle` to collect more than one Flow. To
    do so, you must collect them in parallel in different coroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are two Flows: one to collect the movies and the other to collect
    the TV shows. The collections of the Flow are started from separate `launch` coroutine
    builders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only have one Flow to collect, you can also use `Flow.flowWithLifecycle`.
    This emits values from the upstream Flow (the Flow and operators preceding the
    call) when the lifecycle is at least in `Lifecycle.repeatOnLifecycle` internally.
    You can use `Flow.flowWithLifecycle` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you used `flowWithLifecycle` with **Lifecycle.State.STARTED**
    to start collecting the Flow of movies when the lifecycle is started and stop
    if the lifecycle is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned about using Kotlin Flows in your Android app.
    You can use Flow in Android Jetpack libraries such as Room and even in third-party
    libraries. To safely collect flows in the UI layer and prevent memory leaks and
    avoid wasting resources, you can use `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking into the different Flow builders you
    can use to create Flows for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Flows with Flow builders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will start by looking at creating Flows. To create a Flow,
    you can use a Flow builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin Flow API has flow builders that you can use to create Flows. The
    following are the Kotlin Flow builders you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flow {}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flowOf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asFlow()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `flow` builder function creates a new Flow from a suspendable lambda block.
    Inside the block, you can send values using the `emit` function. For example,
    this `fetchMovieTitles` function of `MovieViewModel` returns `Flow<String>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `fetchMovieTitles` created a Flow with the movie titles. It
    iterated over the list of movies from `fetchMoviesFromNetwork` and, for each movie,
    emitted the movie’s title with the `emit` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `flowOf` function, you can create a Flow that produces the specified
    value or `vararg` values. In the following example, the `flowOf` function is used
    to create a Flow of the titles of the top three movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fetchTop3Titles` uses `flowOf` to create a Flow containing the titles
    of the first three movies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `asFlow()` extension function allows you to convert a type into a Flow.
    You can use this on sequences, arrays, ranges, collections, and functional types.
    For example, this `MovieViewModel` has `fetchMovieIds` that returns `Flow<Int>`,
    containing the movie IDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used a `map` function on the list of movies to create a
    list of the movie IDs. The list of movie IDs was then converted to `Flow<String>`
    by using the `asFlow()` extension function on it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how you can create Flows with Flow Builders. In
    the next section, we will check out the various Kotlin Flow operators you can
    use to transform, combine, and do more with Flows.
  prefs: []
  type: TYPE_NORMAL
- en: Using operators with Flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will focus on the various Flow operators. Kotlin Flow has
    built-in operators that you can use with Flows. We can collect flows with terminal
    operators and transform Flows with Intermediate operators.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting Flows with terminal operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will explore the terminal operators you can use on Flows
    to start the collection of a Flow. The `collect` function we used in the previous
    examples is the most used terminal operator. However, there are other built-in
    terminal Flow operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the built-in terminal Flow operators you can use to start
    the collection of the Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toList`: Collects the Flow and converts it into a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toSet`: Collects the Flow and converts it into a set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toCollection`: Collects the Flow and converts it into a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count`: Returns the number of elements in the Flow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`first`: Returns the Flow’s first element or throws a **NoSuchElementException**
    if the Flow was empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firstOrNull`: Returns the Flow’s first element or null if the Flow was empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last`: Returns the Flow’s last element or throws a **NoSuchElementException**
    if the Flow was empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lastOrNull`: Returns the Flow’s last element or null if the Flow was empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single`: Returns the single element emitted or throws an exception if the
    Flow was empty or had more than one value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`singleOrNull`: Returns the single element emitted or null if the Flow was
    empty or had more than one value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reduce`: Applies a function to each item emitted, starting from the first
    element, and returns the accumulated result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fold`: Applies a function to each item emitted, starting from the initial
    value set, and returns the accumulated result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These terminal Flow operators work like the Kotlin collection functions with
    the same name in the standard Kotlin library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `firstOrNull` terminal operator is used instead
    of the `collect` operator to collect the Flow from `ViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Here, `firstOrNull` was used on the Flow to get the first item (or null if the
    Flow was empty), which represents the top movie. It will then be displayed on
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about the Flow terminal operators you can use to
    start collecting from a Flow. In the next section, we will learn how to transform
    Flows with Intermediate operators.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Flows with Intermediate operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will focus on Intermediate flow operators that you can use
    to transform Flows. With Intermediate operators, you can return a new Flow based
    on the original one.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate operators allow you to modify a Flow and return a new one. You
    can chain various operators, and they will be applied sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can transform the Flow by applying operators on them, as you can do with
    Kotlin collections. The following Intermediate operators work similarly to the
    Kotlin collection functions with the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter`: Returns a Flow that selects only the values from the Flow that meet
    the condition you passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterNot`: Returns a Flow that selects only the values from the Flow that
    do not meet the condition you passed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterNotNull`: Returns a Flow that only includes values from the original
    Flow that are not null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filterIsInstance`: Returns a Flow that only includes values from the Flow
    that are instances of the type you specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: Returns a Flow that includes values from the Flow transformed with the
    operation you specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapNotNull`: Like `map` (transforms the Flow using the operation specified)
    but only includes values that are not null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`withIndex`: Returns a Flow that converts each value to an **IndexedValue**
    containing the index of the value and the value itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onEach`: Returns a Flow that performs the specified action on each value before
    they are emitted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runningReduce`: Returns a Flow containing the accumulated values resulting
    from running the operation specified sequentially, starting with the first element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runningFold`: Returns a Flow containing accumulated values resulting from
    running the operation specified sequentially, starting with the initial value
    set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scan`: Like the `runningFold` operator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a `transform` operator that you can use to apply custom or complex
    operations. With the `transform` operator, you can emit values into the new Flow
    by calling the `emit` function with the value to send.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `MovieViewModel` has a `fetchTopMovieTitles` function that
    uses `transform` to return a Flow with the top movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `transform` operator was used in the Flow of movies to
    return a new Flow. The `transform` operator was used to emit only the list of
    movies whose popularity is higher than `0.5`, which means a popularity of more
    than 50%.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also size-limiting operators that you can use with Flow. The following
    are some of these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`drop(x)`: Returns a Flow that ignores the first *x* elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dropWhile`: Returns a Flow that ignores the first elements that meet the condition
    specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take(x)`: Returns a Flow containing the first *x* elements of the Flow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeWhile`: Returns a Flow that includes the first elements that meet the
    condition specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These size-limiting operators also function similarly to the Kotlin collection
    functions with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about Intermediate flow operators. Intermediate
    operators transform a Flow into a new Flow. In the next section, we will learn
    how to buffer and combine Kotlin Flows.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering and combining flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about buffering and combining Kotlin Flows. You
    can buffer and combine Flows with Flow operators. Buffering allows Flow with long-running
    tasks to run independently and avoid race conditions. Combining allows you to
    join different sources of Flows before processing or displaying them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Buffering Kotlin Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn about buffering Kotlin Flows. Buffering allows
    you to run data emission in parallel to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting and collecting data with Flow run sequentially. When a new value is
    emitted, it will be collected. Emission of a new value can only happen once the
    previous data has been collected. If the emission or the collection of data from
    the Flow takes a while to complete, the whole process will take a longer time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With buffering, you can make a Flow’s emission and collection of data run in
    parallel. There are three operators you can use to buffer Flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`buffer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conflate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collectLatest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`buffer()` allows the Flow to emit values while the data is still being collected.
    The emission and collection of data are run in separate coroutines, so it runs
    in parallel. The following is an example of how to use `buffer` with Flows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `buffer` operator was added before calling `collect`. If the `processMovie(movie)`
    function in the collection takes longer, the Flow will emit and buffer the values
    before they are collected and processed.
  prefs: []
  type: TYPE_NORMAL
- en: '`conflate()` is similar to the `buffer()` operator, except with `conflate`,
    the collector will only process the latest value emitted after the previous value
    has been processed. It will ignore the other values previously emitted. Here is
    an example of using `conflate` in a Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: In this example, adding the `conflate` operator will allow us to only process
    the latest value from the Flow and call `processMovie` with that value.
  prefs: []
  type: TYPE_NORMAL
- en: '`collectLatest(action)` is a terminal operator that will collect the Flow the
    same way as `collect`, but whenever a new value is emitted, it will restart the
    action and use this new value. Here is an example of using `collectLatest` in
    a Flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Here, `collectLatest` was used instead of the `collect` terminal operator to
    collect the flow from `viewModel.getTopMovie()`. Whenever a new value is emitted
    by this Flow, it will restart and call `displayMovie` with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to buffer Kotlin Flows with `buffer`, `conflate`,
    and `collectLatest`. In the next section, you will learn about combining multiple
    Flows into a single Flow.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will learn how we can combine Flows. The Kotlin Flow API
    has available operators that you can use to combine multiple flows.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple flows and you want to combine them into one, you can use
    the following Flow operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`combine`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge` is a top-level function that combines the elements from multiple Flows
    of the same type into one. You can pass a `vararg` number of Flows to combine.
    This is useful when you have two or more sources of data that you want to merge
    first before collecting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, there are two Flows from `viewModel.fetchMoviesFromDb`
    and `viewModel.fetchMoviesFromNetwork` combined using `merge`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `merge` was used to combine the Flows from `viewModel.fetchMoviesFromDb`
    and `viewModel.fetchMoviesFromNetwork` before they are collected.
  prefs: []
  type: TYPE_NORMAL
- en: The `zip` operator pairs data from the first Flow to the second Flow into a
    new value using the function you specified. If one Flow has fewer values than
    the other, `zip` will end when the values of this Flow have all been processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows how you can use the `zip` operator to combine two Flows,
    `userFlow` and `taskFlow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you used `zip` to pair each value of `userFlow` to `taskFlow`
    and return a Flow of `AssignedTask` using the `user` and `task` values. This new
    Flow will be collected and then displayed with the `displayAssignedTask` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`combine` pairs data from the first flow to the second flow like `zip` but
    uses the most recent value emitted by each flow. It will continue to run as long
    as a Flow emits a value. There is also a top-level `combine` function that you
    can use for multiple flows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how you can use the `combine` operator to join
    two Flows in your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have two Flows, `yourMessage` and `friendMessage`. The `combine` function
    pairs the most recent value of `yourMessage` and `friendMessage` to create a `Conversation`
    object. Whenever a new value is emitted by either Flow, `combine` will pair the
    latest values and add that to the resulting Flow for collection.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have explored how to combine Flows. In the next section,
    we will focus on `StateFlow` and `SharedFlow` and how we can use them in your
    Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring StateFlow and SharedFlow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will dive into `StateFlow` and `SharedFlow`. `SharedFlow`
    and `StateFlow` are Flows that are hot streams, unlike a normal Kotlin Flow, which
    are cold streams by default.
  prefs: []
  type: TYPE_NORMAL
- en: A Flow is a cold stream of data. Flows only emit values when the values are
    collected. With `SharedFlow` and `StateFlow` hot streams, you can run and emit
    values the moment they are called and even when they have no listeners. `SharedFlow`
    and `StateFlow` are Flows, so you can also use operators on them.
  prefs: []
  type: TYPE_NORMAL
- en: A `SharedFlow` allows you to emit values to multiple listeners. `SharedFlow`
    can be used for one-time events. The tasks that will be done by the `SharedFlow`
    will only be run once and will be shared by the listeners.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `MutableSharedFlow` and then use the `emit` function to send values
    to all the collectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `SharedFlow` is used in `MovieViewModel` for the
    list of movies fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used `SharedFlow` for the message. We used the `emit` function
    to send the error message to the Flow’s listeners.
  prefs: []
  type: TYPE_NORMAL
- en: '`StateFlow` is `SharedFlow`, but it only emits the latest value to its listeners.
    `StateFlow` is initialized with a value (an initial state) and keeps this state.
    You can change the value of `StateFlow` using the mutable version of `StateFlow`,
    `MutableStateFlow`. Updating the value sends the new value to the Flow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android, `StateFlow` can be an alternative to `LiveData`. You can use `StateFlow`
    for `ViewModel`, and your activity or fragment can then collect the value. For
    example, in the following `ViewModel`, `StateFlow` is used for the list of movies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the list of movies fetched from the repository will
    be set to `MutableStateFlow` of `_movies`, which will also change `StateFlow`
    of `movies`. You can then collect `StateFlow` of `movies` in an activity or fragment,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Here, `StateFlow` of `viewModel.movies` will be collected, and then the list
    of movies will be displayed on the screen with the `displayMovies` function.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about `StateFlow` and `SharedFlow` and how
    we can use them in our Android projects.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try what we have learned so far by adding Kotlin Flow to an Android project.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.01 – Using Kotlin Flow in an Android app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this exercise, you will be continuing the movie app you worked on in *Exercise
    4.01 – Adding tests to coroutines in an Android app*. This application displays
    the movies that are currently playing in cinemas. You will be adding Kotlin Flow
    to the project by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the movie app you worked on in *Exercise 4.01 – Adding tests to coroutines
    in an Android app* in Android Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `MovieRepository` class and add a new `fetchMoviesFlow()` function
    that uses a `flow` builder to return a Flow and emits the list of movies from
    `MovieService`, as shown in the following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the same as the `fetchMovies()` function, but this function uses Kotlin
    Flow and will return `Flow<List<Movie>>` to the function or class that will collect
    it. The Flow will emit the list of movies from `movieService.getMovies`, and it
    will flow on the `Dispatchers.IO` dispatcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `MovieViewModel` class, and replace the initialization of the `movies`
    `LiveData` that gets the value from `movieRepository` with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow you to use the value of the `_movies` `MutableStateFlow` as
    the value of the `movies` `StateFlow`, which you will change later when you have
    fetched the list of movies from the Flow in `movieRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the same for the `error` `LiveData`, and replace its initialization with
    the value from `movieRepository` with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will use the value of the `_error` `MutableStateFlow` for the `error` `StateFlow`.
    You will be able to change the value of this `StateFlow` later for handling the
    cases when the Flow encountered an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `loading` and `_loading` variables with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will use the value of the `_loading` `MutableStateFlow` for the `loading`
    `StateFlow`. You will update this later to indicate that the loading of movies
    is ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the `fetchMovies()` function and its content. You will be replacing this
    in the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new `fetchMovies()` function that will collect the Flow from the `movieRepository.fetchMoviesFlow`,
    as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will collect the list of movies from `movieRepository.fetchMoviesFlow`
    and set it to the `_movies` `MutableStateFlow` and the `movies` `StateFlow`. This
    list of movies will then be displayed in `MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app/build.gradle` file. Add the following lines in the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will allow us to use `lifecycleScope` for collecting the flows in `MainActivity`
    later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `MainActivity` and remove the lines of code that observe for the `movies`,
    `error`, and `loading` `LiveData`. Replace them with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will collect `movies` and add them to the list, collect the `error` and
    display a `SnackBar` message if `error` is not empty, and collect `loading` and
    update `progressBar` based on its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application. The app should still display a list of movies (with a
    poster and a title), as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – The movie app with the list of movies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.1_B17773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – The movie app with the list of movies
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have added Kotlin Flow in an Android app by creating a
    `MovieRepository` function that returns the list of movies as a Flow. This Flow
    was then collected by `MovieViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on using Kotlin Flows for asynchronous programming in Android.
    Flows are built on top of Kotlin coroutines. A flow can emit multiple values sequentially,
    instead of just a single value.
  prefs: []
  type: TYPE_NORMAL
- en: We started with learning about how to use Kotlin Flows in your Android app.
    Jetpack libraries such as Room and some third-party libraries support Flow. To
    safely collect flows in the UI layer and prevent memory leaks and avoid wasting
    resources, you can use `Lifecycle.repeatOnLifecycle` and `Flow.flowWithLifecycle`.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to creating Flows with Flow builders. The `flowOf` function
    creates a Flow that emits the value or `vararg` values you provided. You can convert
    collections and functional types to Flow with the `asFlow()` extension function.
    The `flow` builder function creates a new Flow from a suspending lambda block,
    inside which you can send values with `emit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we explored Flow operators and learned how you can use them with Kotlin
    Flows. With terminal operators, you can start the collection of the Flow. Intermediate
    operators allow you to transform a Flow into another Flow.
  prefs: []
  type: TYPE_NORMAL
- en: We then learned about buffering and combining Flows. With the `buffer`, `conflate`,
    and `collectLatest` operators, you can buffer Flows. You can combine Flows with
    the `merge`, `zip`, and `combine` Flow operators.
  prefs: []
  type: TYPE_NORMAL
- en: We then explored `SharedFlow` and `StateFlow`. These can be used in your Android
    projects. With `SharedFlow`, you can emit values to multiple listeners. `StateFlow`
    is `SharedFlow` that only emits the latest value to its listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we worked on an exercise to add Kotlin Flows to an Android application.
    We used a Flow in `MovieRepository`, which was then collected in `MovieViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on how to handle Kotlin Flows cancelations
    and exceptions in your application.
  prefs: []
  type: TYPE_NORMAL
