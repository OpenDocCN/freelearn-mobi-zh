<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Functional Data Structures"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Functional Data Structures</h1></div></div></div><p>We are familiar with imperative data structures. In fact, there are lots of references for imperative data structures in different programming languages. In contrast, there aren't many references for declarative data structures or functional data structures. This is because functional programming languages are not as mainstream as imperative programming languages. Additionally, designing and implementing functional data structures is more difficult in comparison to imperative counterparts because of the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mutability is not recommended in functional programming</li><li class="listitem" style="list-style-type: disc">Functional data structures are expected to be more flexible than their imperative counterparts</li></ul></div><p>Imperative data structures rely heavily on mutability and assignments and making them immutable needs extra development effort. Whenever we change an imperative data structure, we basically override the previous version; however, this is not the case with declarative programming as we expect that both the previous and new versions of the functional data structure will continue to survive and be utilized.</p><p>We might think why bother with functional data structures as they are more difficult to design and implement? There are two answers to this question: first of all, functional data structures are efficient and immutable data structures. Secondly, they support functional programming paradigms. We have already seen an example of these when we were introduced to algebraic data types in <a class="link" href="ch04.html" title="Chapter 4. Enumerations and Pattern Matching">Chapter 4</a>, <span class="emphasis"><em>Enumerations and Pattern Matching</em></span>.</p><p>In this chapter, we will further explore functional data structures with coding examples. The content of this chapter is heavily inspired by <span class="emphasis"><em>Purely Functional Data Structures</em></span>, <span class="emphasis"><em>Chris Okasaki</em></span>, <span class="emphasis"><em>Cambridge University Press</em></span>, which is a great reference on this topic to date and has various examples with ML and Haskell programming languages. Reading Okasaki's book is highly recommended for functional programmers. In this chapter, we will cover the topic and explore some of the examples in Okasaki's book in Swift.</p><p>Particularly, we will utilize structs and enumerations to implement the following functional data structures:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Semigroup</li><li class="listitem" style="list-style-type: disc">Monoid</li><li class="listitem" style="list-style-type: disc">Binary Search Tree</li><li class="listitem" style="list-style-type: disc">Linked list</li><li class="listitem" style="list-style-type: disc">Stack</li><li class="listitem" style="list-style-type: disc">Lazy list</li></ul></div><p>Coding examples for these data structures serve as a presentation of functional programming paradigms and techniques and they are not going to be complete.</p><p>We know that immutability is the most important property of functional data structures. To design and implement immutable data structures, we will not change a functional data structure and instead create a new version that lives along with the previous version. In fact, we will copy the parts that need to be changed without touching the original version of the data structure. So we will use value types such as structs and enumerations to be able to achieve this. In addition, as we will not change the original data structure directly, we will be able to share the original data structure parts with the new structure without being worried about how changing one version would affect the other version. Let's examine how we will achieve this by implementing different functional data structures.</p><div class="section" title="Semigroup"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Semigroup</h1></div></div></div><p>In computer science, a Semigroup is an algebraic structure that has a set and a binary operation that takes two elements in the set and returns a Semigroup that has an associative operation.</p><p>To start, we need to have a set and a specific binary operation, or we can make this behavior generic and define a protocol as follows:</p><pre class="programlisting">protocol Semigroup {&#13;
    func operation(_ element: Self) -&gt; Self&#13;
}&#13;
</pre><p>Any type that conforms to this protocol requires to implement the <code class="literal">operation</code> method. Here, <code class="literal">self</code> presents the type that is conforming to this protocol. For instance, we can extend <code class="literal">Int</code> to conform to the Semigroup protocol and provide a summation on itself:</p><pre class="programlisting">extension Int: Semigroup {&#13;
    func operation(_ element: Int) -&gt; Int {&#13;
        return self + element&#13;
    }&#13;
}&#13;
</pre><p>We can test this as follows:</p><pre class="programlisting">let number: Int = 5&#13;
number.operation(3)&#13;
</pre><p>This test does not ensure the associativity of the binary operations. Let's try this:</p><pre class="programlisting">let numberA: Int = 3&#13;
let numberB: Int = 5&#13;
let numberC: Int = 7&#13;
&#13;
if numberA.operation(numberB.operation(numberC)) == (numberA.operation(&#13;
  numberB)).operation(numberC) {&#13;
    print("Operation is associative")&#13;
}&#13;
</pre><p>The preceding code ensures that our binary operator is associative; therefore, our Semigroup is verified. It does not look very nice though; let's implement an operator for our operation to make it look better and more math friendly:</p><pre class="programlisting">infix operator &lt;&gt; { associativity left precedence 150 }&#13;
&#13;
func &lt;&gt; &lt;S: Semigroup&gt; (x: S, y: S) -&gt; S {&#13;
    return x.operation(y)&#13;
}&#13;
</pre><p>Let's rewrite our test with the <code class="literal">&lt;&gt;</code> operator:</p><pre class="programlisting">if numberA &lt;&gt; (numberB &lt;&gt; numberC) == (numberA &lt;&gt; numberB) &lt;&gt; numberC {&#13;
    print("Operation is associative")&#13;
}&#13;
</pre><p>So far, we extended only <code class="literal">Int</code> but we can extend any type. Let's extend arrays as an example:</p><pre class="programlisting">extension Array: Semigroup {&#13;
    func operation(_ element: Array) -&gt; Array {&#13;
        return self + element&#13;
    }&#13;
}&#13;
</pre><p>The <code class="literal">operation</code> method is very similar to what we have for <code class="literal">Int</code>. The only difference is in the type, which is an array in this case:</p><pre class="programlisting">print([1, 2, 3, 4] &lt;&gt; [5, 6, 7]) // prints "[1, 2, 3, 4, 5, 6, 7]"&#13;
</pre><p>Furthermore we can extend String as follows:</p><pre class="programlisting">extension String: Semigroup {&#13;
    func operation(_ element: String) -&gt; String {&#13;
        return "\(self)\(element)"&#13;
    }&#13;
}</pre><p>We have established a general principle of composition (two objects combining into one) using a protocol. This pattern can be used for different purposes. For instance, we can implement a shorter version of reduce for arrays over Semigroups:</p><pre class="programlisting">func sconcat &lt;S: Semigroup&gt; (initial: S, elements: [S]) -&gt; S {&#13;
    return elements.reduce(initial, combine: &lt;&gt;)&#13;
}&#13;
</pre><p>The <code class="literal">sconcat</code> function name stands for semigroup concat; we can test it as follows:</p><pre class="programlisting">print(sconcat(initial: 0, elements:[1, 2, 3])) // 6&#13;
print(sconcat(initial: "", elements: ["A", "B", "C"])) // ABC&#13;
print(sconcat(initial: [], elements: [[1, 2], [3, 4, 5]])) // [1, 2, 3,&#13;
  4, 5]&#13;
</pre><p>Our last <code class="literal">sconcat</code> example works like <code class="literal">flatMap</code> and flattens elements.</p><p>Finally, our Semigroup becomes the following:</p><pre class="programlisting">infix operator &lt;&gt; { associativity left precedence 150 }&#13;
&#13;
func &lt;&gt; &lt;S: Semigroup&gt; (x: S, y: S) -&gt; S {&#13;
    return x.operation(y)&#13;
}&#13;
&#13;
protocol Semigroup {&#13;
    func operation(_ element: Self) -&gt; Self&#13;
}&#13;
&#13;
extension Int: Semigroup {&#13;
    func operation(_ element: Int) -&gt; Int {&#13;
        return self + element&#13;
    }&#13;
}&#13;
&#13;
extension String : Semigroup {&#13;
    func operation(_ element: String) -&gt; String {&#13;
        return self + element&#13;
    }&#13;
}&#13;
&#13;
extension Array : Semigroup {&#13;
    func operation(_ element: Array) -&gt; Array {&#13;
        return self + element&#13;
    }&#13;
}&#13;
&#13;
func sconcat &lt;S: Semigroup&gt; (initial: S, elements: [S]) -&gt; S {&#13;
    return elements.reduce(initial, combine: &lt;&gt;)&#13;
}&#13;
</pre><p>A Semigroup is a great example of a simple data structure but it is not as popular as a Monoid, which we will examine in the next section.</p></div></div>
<div class="section" title="Monoid"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Monoid</h1></div></div></div><p>In computer science, a Monoid is a set, a binary operation, and an element of the set with the following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Associativity of binary operations</li><li class="listitem" style="list-style-type: disc">The element is the identity</li></ul></div><p>Simply put, a structure is Monoid if the structure is a Semigroup with an element that is the identity. So let's define a new protocol that extends our Semigroup protocol:</p><pre class="programlisting">protocol Monoid: Semigroup {&#13;
    static func identity() -&gt; Self&#13;
}&#13;
&#13;
extension Int: Monoid {&#13;
    static func identity() -&gt; Int {&#13;
        return 0&#13;
    }&#13;
}&#13;
&#13;
extension String: Monoid {&#13;
    static func identity() -&gt; String {&#13;
        return ""&#13;
    }&#13;
}&#13;
&#13;
extension Array: Monoid {&#13;
    static func identity() -&gt; Array {&#13;
        return []&#13;
    }&#13;
}&#13;
</pre><p>We can test our structure as follows:</p><pre class="programlisting">numberA &lt;&gt; Int.identity() // 3&#13;
"A" &lt;&gt; String.identity() // A&#13;
</pre><p>As Monoid has an element, we can use this as an initial and simplify our <code class="literal">reduce</code> method as follows:</p><pre class="programlisting">func mconcat &lt;M: Monoid&gt; (_ elements: [M]) -&gt; M {&#13;
    return elements.reduce(M.identity(), combine: &lt;&gt;)&#13;
}&#13;
</pre><p>Let's test this:</p><pre class="programlisting">print(mconcat([1, 2, 3])) // 6&#13;
print(mconcat(["A", "B", "C"])) // ABC&#13;
print(mconcat([[1, 2], [3, 4, 5]])) // [1, 2, 3, 4, 5]&#13;
</pre></div>
<div class="section" title="Trees"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Trees</h1></div></div></div><p>In computer science, a Tree is a very popular <span class="strong"><strong>abstract data type</strong></span> (<span class="strong"><strong>ADT</strong></span>) or a data structure implementing this ADT that simulates a hierarchical tree structure with a root value and subtrees of the children with a parent node, represented as a set of linked nodes.</p><p>A tree data structure can be defined recursively (locally) as a collection of nodes (starting at a root node), where each node is a data structure consisting of a value, together with a list of references to nodes (the <span class="emphasis"><em>children</em></span>) with the constraints that no reference is duplicated and none point to the root.</p><p>Alternatively, a tree can be defined abstractly as a whole (globally) as an ordered tree, with a value assigned to each node. Both these perspectives are useful: while a tree can be analyzed mathematically as a whole, when actually represented as a data structure, it is usually represented and worked separately by a node (rather than as a list of nodes and an adjacency list of edges between nodes, as one may represent a digraph, for instance). For example, looking at a tree as a whole, one can talk about the <span class="emphasis"><em>parent</em></span> node of a given node, but in general as a data structure, a given node only contains the list of its children but not a reference to its parent (if any).</p><p>In a previous chapter, we implemented a generic binary tree in Swift. The following is an improved version of that:</p><pre class="programlisting">enum Tree&lt;Element: Comparable&gt; {&#13;
    case leaf(Element)&#13;
    indirect case node(lhs: Tree, rhs: Tree)&#13;
}&#13;
</pre><p>We define the <code class="literal">Tree</code> as an <code class="literal">enum</code> with three different cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Leaf</strong></span>: If we are at the end of a branch of the <code class="literal">Tree</code>; simply put, if a node does not have any children, then it is a <code class="literal">Leaf</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Node</strong></span>: A structure that has a left-hand side and right-hand side to it</li></ul></div><p>The following figure presents an example <code class="literal">Tree</code>:</p><p>
</p><div class="mediaobject"><img alt="Trees" src="graphics/image_08_001.jpg"/></div><p>
</p><p>A <code class="literal">Tree</code> is generic and the elements in it are comparable.</p><p>Using this <code class="literal">Tree</code> is as simple as follows:</p><pre class="programlisting">let functionalTree = Tree.node(lhs: Tree.leaf("First"),&#13;
                               rhs: Tree.node(lhs:&#13;
 Tree.leaf("Second"), &#13;
                               rhs: Tree.leaf("Third")))</pre><p>Our <code class="literal">functionalTree</code> is immutable or, in other words, it is persistent. It has a leaf as <code class="literal">lhs</code> and a node with two leaves as <code class="literal">rhs</code>. As this structure is immutable, we will not be worried whether it is going to change or not and we will be able to share this tree with other trees:</p><pre class="programlisting">let secondFT = Tree.node(lhs: functionalTree, rhs: Tree.node(&#13;
                         lhs: Tree.leaf("Fourth"),&#13;
                         rhs: Tree.leaf("Fifth")))&#13;
let thirdFT = Tree.node(lhs: Tree.node(lhs: Tree.leaf("Fourth"),&#13;
                        rhs: Tree.leaf("Fifth")),&#13;
                        rhs: functionalTree)</pre><p>In the preceding examples, we used our first <code class="literal">Tree</code> called <code class="literal">functionalTree</code> as a part of <code class="literal">secondFT</code> and <code class="literal">thirdFT</code>.</p><div class="section" title="Contains"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec51"/>Contains</h2></div></div></div><p>This <code class="literal">Tree</code> is far from complete and needs lots of functionality. For instance, we may need to check whether the <code class="literal">Tree</code> contains a specific value. To be able to do this, we need to add the following method to our <code class="literal">Tree</code>:</p><pre class="programlisting">static func contains(_ key: Element, tree: Tree&lt;Element&gt;) -&gt; Bool {&#13;
    switch tree {&#13;
    case .leaf(let element):&#13;
        return key == element&#13;
    case node(let lhs, let rhs):&#13;
        return contains(key, tree:lhs) || contains(key, tree:rhs)&#13;
    }&#13;
 }&#13;
</pre><p>We can test contains method as the following:</p><pre class="programlisting">let isFound = Tree.contains("First", tree: functionalTree) // will&#13;
  return true</pre></div><div class="section" title="Binary Search Tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec52"/>Binary Search Tree</h2></div></div></div><p>Our assumption in our simple <code class="literal">Tree</code> was that only leaves contain a value. This is not always true. In fact, there are different types of trees with different utilities and a <span class="strong"><strong>Binary Search Tree</strong></span> (<span class="strong"><strong>BST</strong></span>) is one of them.</p><p>In computer science, binary search trees, sometimes called ordered or sorted binary trees, are a particular type of container: data structures that store <span class="emphasis"><em>items</em></span> (such as numbers, names, and so on) in memory. They allow fast lookup, the addition and removal of items, and implementation of either dynamic sets of items or lookup tables that allow finding an item by its key (for example, finding the phone number of a person by name).</p><p>BSTs keep their keys in sorted order so that lookup and other operations can use the principle of binary search: when looking for a key in a tree (or a place to insert a new key), they traverse the tree from root to leaf, making comparisons to keys stored in the nodes of the tree and deciding, based on the comparison, whether to continue searching in the left or right subtrees. On an average, this means that each comparison allows the operations to skip about half of the tree so that each lookup, insertion, or deletion takes time proportional to the logarithm of the number of items stored in the tree. This is much better than the linear time required to find items by key in an (unsorted) array, but slower than the corresponding operations on hash tables.</p><p>Let's improve our simple tree and convert it to a BST:</p><pre class="programlisting">enum BinarySearchTree&lt;Element: Comparable&gt; {&#13;
    case leaf&#13;
    indirect case node(lhs: BinarySearchTree, element: Element,&#13;
                       rhs: BinarySearchTree)&#13;
}&#13;
</pre><p>The <code class="literal">BinarySearchTree</code> tree is very similar to the previous <code class="literal">Tree</code> and the only difference is that <code class="literal">node</code> contains the <code class="literal">element</code> and not the <code class="literal">leaf</code>. Using it is as simple as follows:</p><pre class="programlisting">let functionalBST = BinarySearchTree.node(lhs: BinarySearchTree.node(&#13;
  lhs: BinarySearchTree.leaf, element: 1,&#13;
  rhs: BinarySearchTree.leaf),&#13;
  element: 5, rhs: BinarySearchTree.node(lhs:BinarySearchTree.leaf,&#13;
  element: 9, rhs: BinarySearchTree.leaf))</pre><p>Here, we create a BST as values stored in <code class="literal">lhs</code> are smaller than the root and values stored in <code class="literal">rhs</code> are larger than the root. In this example, <code class="literal">lhs</code> is a BST with <code class="literal">1</code> as value. Root has the value of <code class="literal">5</code> and <code class="literal">rhs</code> is a BST with <code class="literal">9</code> as value which is larger than root value.</p><div class="section" title="Contains"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec53"/>Contains</h3></div></div></div><p>Additionally, our <code class="literal">contains</code> method requires to be modified as it will search only in leaves. Let's improve this, assuming that our Tree is a BST:</p><pre class="programlisting">static func contains(_ item: Element, tree: BinarySearchTree&lt;Element&gt;)&#13;
  -&gt; Bool {&#13;
    switch tree {&#13;
    case .leaf:&#13;
        return false&#13;
    case .node(let lhs, let element, let rhs):&#13;
        if item &lt; element {&#13;
            return contains(item, tree: lhs)&#13;
        } else if item &gt; element {&#13;
            return contains(item, tree: rhs)&#13;
        }&#13;
        return true&#13;
    }&#13;
}&#13;
</pre><p>This method searches for a specific <code class="literal">element</code> and returns <code class="literal">true</code> if it finds it in <code class="literal">node</code>.</p><p>The following presents an example usage of this method:</p><pre class="programlisting">let isFound = BinarySearchTree.contains(9, tree: functionalBST)&#13;
</pre><p>The <code class="literal">isFound</code> variable is going to be <code class="literal">true</code> in this case.</p></div><div class="section" title="Size"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec54"/>Size</h3></div></div></div><p>To make this BST a little more complete, let's implement a property to check for its size:</p><pre class="programlisting">var size: Int {&#13;
    switch self {&#13;
    case .leaf:&#13;
        return 0&#13;
    case .node(let lhs, _, let rhs):&#13;
        return 1 + lhs.size + rhs.size&#13;
    }&#13;
}&#13;
</pre><p>This computed property is going to provide the size of the BST and we can use it as follows:</p><pre class="programlisting">print(functionalBST.size) // prints "3"&#13;
</pre></div><div class="section" title="Elements"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec55"/>Elements</h3></div></div></div><p>It would be great to be able to generate an array from BST elements. This can be done as follows:</p><pre class="programlisting">var elements: [Element] {&#13;
    switch self {&#13;
    case .leaf:&#13;
        return []&#13;
    case .node(let lhs, let element, let rhs):&#13;
        return lhs.elements + [element] + rhs.elements&#13;
    }&#13;
}&#13;
</pre></div><div class="section" title="Empty"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec56"/>Empty</h3></div></div></div><p>We can implement a helper method to generate empty BSTs as follows:</p><pre class="programlisting">static func empty() -&gt; BinarySearchTree {&#13;
    return .leaf&#13;
}&#13;
</pre><p>The following is a computed property to check whether the BST is empty:</p><pre class="programlisting">var isEmpty: Bool {&#13;
    switch self {&#13;
    case .leaf:&#13;
        return true&#13;
    case .node(_, _, _):&#13;
        return false&#13;
    }&#13;
}&#13;
</pre><p>Let's test these functions:</p><pre class="programlisting">let emptyBST = BinarySearchTree&lt;Int&gt;.empty()&#13;
print(emptyBST.isEmpty)&#13;
</pre><p>In the preceding code, we created an empty BST and checked whether it is empty using the <code class="literal">isEmpty</code> property. Obviously, the result is going to be <code class="literal">true</code>.</p><p>This BST implementation is far from complete and requires to be improved by implementing methods to check whether it is a BST.</p><p>At the end, our BST becomes the following:</p><pre class="programlisting">enum BinarySearchTree&lt;Element: Comparable&gt; {&#13;
    case leaf&#13;
    indirect case node(lhs: BinarySearchTree, element: Element,&#13;
                       rhs: BinarySearchTree)&#13;
 &#13;
    var size: Int {&#13;
        switch self {&#13;
        case .leaf:&#13;
            return 0&#13;
        case .node(let lhs, _, let rhs):&#13;
            return 1 + lhs.size + rhs.size&#13;
        }&#13;
    }&#13;
&#13;
    var elements: [Element] {&#13;
        switch self {&#13;
        case .leaf:&#13;
            return []&#13;
        case .node(let lhs, let element, let rhs):&#13;
            return lhs.elements + [element] + rhs.elements&#13;
        }&#13;
    }&#13;
&#13;
    var isEmpty: Bool {&#13;
        switch self {&#13;
        case .leaf:&#13;
            return true&#13;
        case .node(_, _, _):&#13;
            return false&#13;
        }&#13;
    }&#13;
&#13;
    init() {&#13;
        self = .leaf&#13;
    }&#13;
&#13;
    static func empty() -&gt; BinarySearchTree {&#13;
        return .leaf&#13;
    }&#13;
&#13;
    init(element: Element) {&#13;
        self = .node(lhs: .leaf, element: element, rhs: .leaf)&#13;
    }&#13;
&#13;
    static func contains(_ item: Element,&#13;
                           tree: BinarySearchTree&lt;Element&gt;)&#13;
      -&gt; Bool {&#13;
        switch tree {&#13;
        case .leaf:&#13;
            return false&#13;
        case .node(let lhs, let element, let rhs):&#13;
            if item &lt; element {&#13;
                return contains(item, tree: lhs)&#13;
            } else if item &gt; element {&#13;
                return contains(item, tree: rhs)&#13;
            }&#13;
            return true&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>Even though it does not represent a full implementation of a BST, we were able to develop it in a functional style, and we will be able to share and reuse the tree among other trees because they are immutable.</p></div></div></div>
<div class="section" title="Lists"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Lists</h1></div></div></div><p>There are multiple types of lists including linked lists, doubly linked lists, multiple linked lists, circular linked lists, queues, and stacks.</p><p>In this section, we will present a simple linked list that is one of the simplest and most popular data structures in imperative programming languages.</p><p>A linked list is a linear collection of data elements called nodes pointing to the next node using pointers. Linked lists contain their data in a linear and sequential manner. Simply, each node is composed of data and a reference to the next node in the sequence:</p><p>
</p><div class="mediaobject"><img alt="Lists" src="graphics/image_08_002.jpg"/></div><p>
</p><p>Let's start with a simple version:</p><pre class="programlisting">enum LinkedList&lt;Element: Equatable&gt; {&#13;
    case end&#13;
    indirect case node(data: Element, next: LinkedList&lt;Element&gt;)&#13;
}&#13;
</pre><p>Our approach is similar to our BST implementation approach. The difference resides in the <code class="literal">node</code> case that has a <code class="literal">data</code> element and a pointer to its next element, which is also a <code class="literal">LinkedList</code>.</p><div class="section" title="Empty LinkedList"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec53"/>Empty LinkedList</h2></div></div></div><p>Our <code class="literal">LinkedList</code> needs a method to create it as empty:</p><pre class="programlisting">static func empty() -&gt; LinkedList {&#13;
    return .end&#13;
}&#13;
</pre><p>This is as simple as returning <code class="literal">.end</code>.</p></div><div class="section" title="Cons"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec54"/>Cons</h2></div></div></div><p>We need to have a way to append items to <code class="literal">LinkedList</code>, so we implement it as follows:</p><pre class="programlisting">func cons(_ element: Element) -&gt; LinkedList {&#13;
    return .node(data: element, next: self)&#13;
}&#13;
</pre><p>This simple method appends the data to the front of <code class="literal">LinkedList</code>; in other words, it is like a push operation to a stack.
We can test it as follows:</p><pre class="programlisting">let functionalLinkedList = LinkedList&lt;Int&gt;.end.cons(1).cons(2).cons(3)&#13;
print(functionalLinkedList)&#13;
</pre><p>The result of this operation should be the following:</p><pre class="programlisting">node(3, LinkedList&lt;Swift.Int&gt;.node(2, LinkedList&lt;Swift.Int&gt;.node(&#13;
  1, LinkedList&lt;Swift.Int&gt;.end)))</pre><p>Functional programming languages such as Haskell and Scala have operators for cons. It is <code class="literal">:</code> in Haskell and <code class="literal">::</code> in Scala. As we cannot use <code class="literal">:</code> in Swift to define an infix operator, we are going to use <code class="literal">&lt;|</code> instead:</p><pre class="programlisting">infix operator &lt;| { associativity right precedence 100 }&#13;
&#13;
func &lt;| &lt;T&gt;(lhs: T, rhs: LinkedList&lt;T&gt;) -&gt; LinkedList&lt;T&gt; {&#13;
    return .node(data: lhs, next: rhs)&#13;
}&#13;
</pre><p>We will be able to test it as follows:</p><pre class="programlisting">let functionalLLWithCons = 3 &lt;| 2 &lt;| 1 &lt;| .end&#13;
</pre><p>This statement produces the exact same result.</p><p>Again, this <code class="literal">LinkedList</code> is far from complete but we already achieved great reusability as it is functional. We can use/share our <code class="literal">functionalLinkedList</code> with other linked lists without worrying about changes and inconsistencies. Let's examine the following:</p><pre class="programlisting">let secondLL = functionalLinkedList.cons(4)&#13;
let thirdLL = functionalLinkedList.cons(5)&#13;
let fourthLL = LinkedList&lt;Int&gt;.node(data: 1, next: secondLL)&#13;
</pre><p>In the preceding examples, we use <code class="literal">functionalLinkedList</code> and add a new item (<code class="literal">4</code>) to it to obtain <code class="literal">secondLL</code> and <code class="literal">5</code> to obtain <code class="literal">thirdLL</code>. Also, we use <code class="literal">secondLL</code> to create <code class="literal">fourthLL</code>.</p></div><div class="section" title="Contains"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec55"/>Contains</h2></div></div></div><p>To make this <code class="literal">LinkedList</code> a little more interesting, we will develop a contains method similar to the one that we developed for the BST:</p><pre class="programlisting">static func contains(_ key: Element, list: LinkedList&lt;Element&gt;) -&gt; Bool {&#13;
    switch list {&#13;
    case .end:&#13;
        return false&#13;
    case .node(let data, let next):&#13;
        if key == data {&#13;
            return true&#13;
        } else {&#13;
            return contains(key, list: next)&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>This method recursively checks for a specific element in <code class="literal">LinkedList</code> and returns <code class="literal">true</code> if it finds the element:</p><pre class="programlisting">print(LinkedList.contains(1, list: functionalLinkedList))&#13;
</pre><p>The result of this expression is going to be <code class="literal">true</code>.</p></div><div class="section" title="Size"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec56"/>Size</h2></div></div></div><p>We can implement a computed <code class="literal">size</code> property to calculate the size of linked list as follows:</p><pre class="programlisting">var size: Int {&#13;
    switch self {&#13;
    case .node(_, let next):&#13;
        return 1 + next.size&#13;
    case .end:&#13;
        return 0&#13;
    }&#13;
}&#13;
</pre><p>This method recursively goes through <code class="literal">LinkedList</code> and counts the number of nodes:</p><pre class="programlisting">print(functionalLinkedList.size)&#13;
</pre><p>The result is going to be <code class="literal">3</code> in this example.</p></div><div class="section" title="Elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec57"/>Elements</h2></div></div></div><p>We can implement a computed property to provide an array of elements as follows:</p><pre class="programlisting">var elements: [Element] {&#13;
    switch self {&#13;
    case .node(let data, let next):&#13;
        return [data] + next.elements&#13;
    case .end:&#13;
        return []&#13;
    }&#13;
}&#13;
</pre><p>Here, we recur through LinkedList and return an array of data. We will be able to use this property as follows:</p><pre class="programlisting">print(functionalLinkedList.elements)&#13;
</pre><p>This statement prints <code class="literal">[3, 2, 1]</code>.</p></div><div class="section" title="isEmpty"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec58"/>isEmpty</h2></div></div></div><p>Another common operation that <code class="literal">LinkedList</code> requires is a way to check whether it is empty. We can easily implement it in the following way:</p><pre class="programlisting">var isEmpty: Bool {&#13;
    switch self {&#13;
    case .node(_ , _):&#13;
        return false&#13;
    case .end:&#13;
        return true&#13;
    }&#13;
}&#13;
</pre><p>To test this computed property, we will create an empty <code class="literal">LinkedList</code> as follows:</p><pre class="programlisting">let emptyLL = LinkedList&lt;Int&gt;.end&#13;
print(emptyLL.isEmpty)&#13;
&#13;
print(functionalLinkedList.isEmpty)&#13;
</pre><p>In the preceding example, the first <code class="literal">print</code> statement results in <code class="literal">true</code> and the second results in <code class="literal">false</code>.</p></div><div class="section" title="map, filter, and reduce"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>map, filter, and reduce</h2></div></div></div><p>You may have wondered if we are going to be able to apply higher-order functions such as map, filter, and reduce to our linked list. We have implemented our linked list with a recursive <code class="literal">enum</code> and the recursive pattern is well-suited to higher-order functions.</p><p>Let's start with <code class="literal">map</code>:</p><pre class="programlisting">func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; LinkedList&lt;T&gt; {&#13;
    switch self {&#13;
    case .end:&#13;
        return .end&#13;
    case .node(let data, let next):&#13;
        return transform(data) &lt;| next.map(transform)&#13;
    }&#13;
}&#13;
</pre><p>Using this method, we will be able to transform elements in our linked list. Nothing fancy here; we use the same <code class="literal">cons</code> operator that we defined before. The following statement will test our method:</p><pre class="programlisting">let mappedFunctionalLL = functionalLinkedList.map { $0 * 2 }&#13;
</pre><p>The result should be the following:</p><pre class="programlisting">node(6, LinkedList&lt;Swift.Int&gt;.node(4, LinkedList&lt;Swift.Int&gt;.node(&#13;
  2, LinkedList&lt;Swift.Int&gt;.end)))</pre><p>So we can easily multiply elements in our linked list by <code class="literal">2</code>.</p><p>Let's continue with the <code class="literal">filter</code> method:</p><pre class="programlisting">func filter(_ predicate: ((Element) -&gt; Bool)) -&gt; LinkedList&lt;Element&gt; {&#13;
    switch self {&#13;
    case .end:&#13;
        return .end&#13;
    case .node(let data, let next):&#13;
        return predicate(data) ? data &lt;| next.filter(predicate) :&#13;
          next.filter(predicate)&#13;
    }&#13;
}&#13;
</pre><p>Here, we check whether the <code class="literal">predicate</code> yields a result first. If it does, then we apply our <code class="literal">cons</code> operator to the data and recursively <code class="literal">filter</code> the next element. Otherwise, we just recursively apply <code class="literal">filter</code> to the next element. We can test this method as follows:</p><pre class="programlisting">let filteredFunctionalLL = functionalLinkedList.filter { $0 % 2 == 0 }&#13;
</pre><p>In the preceding code example, we <code class="literal">filter</code> our linked list to the ones that are even. This statement results in the following:</p><pre class="programlisting">node(2, LinkedList&lt;Swift.Int&gt;.end)&#13;
</pre><p>It is great to be able to <code class="literal">map</code> and <code class="literal">filter</code> our linked list, but we need to have a <code class="literal">reduce</code> method as well. Let's implement this:</p><pre class="programlisting">func reduce&lt;Value&gt;(_ initial: Value, combine: (Value, Element) -&gt; Value)&#13;
  -&gt; Value {&#13;
    switch self {&#13;
    case .end:&#13;
        return initial&#13;
    case .node(let data, let next):&#13;
        return next.reduce(combine(initial, data), combine: combine)&#13;
    }&#13;
}&#13;
</pre><p>In the preceding code example, we go through the linked list's elements recursively and <code class="literal">reduce</code> the values to a single value. The following code presents a usage example:</p><pre class="programlisting">let reducedFunctionalLL = functionalLinkedList.reduce(0) { $0 + $1}&#13;
</pre><p>The result of this expression is going to be <code class="literal">6</code>.</p><p>At the end, our <code class="literal">LinkedList</code> becomes the following:</p><pre class="programlisting">/// Operator&#13;
infix operator &lt;| { associativity right precedence 100 }&#13;
&#13;
func &lt;| &lt;T&gt;(lhs: T, rhs: LinkedList&lt;T&gt;) -&gt; LinkedList&lt;T&gt; {&#13;
    return .node(data: lhs, next: rhs)&#13;
}&#13;
&#13;
/// LinkedList&#13;
&#13;
enum LinkedList&lt;Element: Equatable&gt; {&#13;
    case end&#13;
    indirect case node(data: Element, next: LinkedList&lt;Element&gt;)&#13;
&#13;
    var size: Int {&#13;
        switch self {&#13;
        case .node(_, let next):&#13;
            return 1 + next.size&#13;
        case .end:&#13;
            return 0&#13;
        }&#13;
    }&#13;
&#13;
    var elements: [Element] {&#13;
        switch self {&#13;
        case .node(let data, let next):&#13;
            return [data] + next.elements&#13;
        case .end:&#13;
            return []&#13;
        }&#13;
    }&#13;
&#13;
    var isEmpty: Bool {&#13;
        switch self {&#13;
        case .node(_ , _):&#13;
            return false&#13;
        case .end:&#13;
            return true&#13;
        }&#13;
    }&#13;
&#13;
    static func empty() -&gt; LinkedList {&#13;
        return .end&#13;
    }&#13;
&#13;
    func cons(_ element: Element) -&gt; LinkedList {&#13;
        return .node(data: element, next: self)&#13;
    }&#13;
 &#13;
    func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; LinkedList&lt;T&gt; {&#13;
        switch self {&#13;
        case .end:&#13;
            return .end&#13;
        case .node(let data, let next):&#13;
            return transform(data) &lt;| next.map(transform)&#13;
        }&#13;
    }&#13;
 &#13;
    func filter(_ predicate: ((Element) -&gt; Bool)) -&gt; LinkedList&lt;Element&gt; {&#13;
        switch self {&#13;
        case .end:&#13;
            return .end&#13;
        case .node(let data, let next):&#13;
            return predicate(data) ? data &lt;| next.filter(predicate)&#13;
              : next.filter(predicate)&#13;
        }&#13;
    }&#13;
 &#13;
    func reduce&lt;Value&gt;(_ initial: Value, combine: (Value, Element)&#13;
      -&gt; Value) -&gt; Value {&#13;
        switch self {&#13;
        case .end:&#13;
            return initial&#13;
        case .node(let data, let next):&#13;
            return next.reduce(combine(initial, data), combine: combine)&#13;
        }&#13;
    }&#13;
 &#13;
    static func contains(_ key: Element, list: LinkedList&lt;Element&gt;)&#13;
      -&gt; Bool {&#13;
        switch list {&#13;
        case .end:&#13;
            return false&#13;
        case .node(let data, let next):&#13;
            if key == data {&#13;
                return true&#13;
            } else {&#13;
                return contains(key, list: next)&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre></div></div>
<div class="section" title="Stacks"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Stacks</h1></div></div></div><p>A stack is a collection that is based on the <span class="strong"><strong>Last In First Out</strong></span> (<span class="strong"><strong>LIFO</strong></span>) policy. </p><p>The following figure presents a sample stack:</p><p>
</p><div class="mediaobject"><img alt="Stacks" src="graphics/image_08_003.jpg"/></div><p>
</p><p>To implement a simple functional stack, we need to provide <code class="literal">push</code>, <code class="literal">pop</code>, <code class="literal">isEmpty</code>, and <code class="literal">size</code> operations. We implemented a functional <code class="literal">LinkedList</code> in the previous section, which can be used to implement a simple functional stack with the following operations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>push</strong></span>: The <code class="literal">cons</code> operation in <code class="literal">LinkedList</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>pop</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>isEmpty</strong></span>: The <code class="literal">isEmpty</code> operation in <code class="literal">LinkedList</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>size</strong></span>: The <code class="literal">size</code> method in <code class="literal">LinkedList</code></li></ul></div><p>As seen here, the only operation that is missing is <code class="literal">pop</code>. Let's implement that:</p><pre class="programlisting">func pop() -&gt; (element: Element, linkedList: LinkedList)? {&#13;
    switch self {&#13;
    case .node(let data, let next):&#13;
        return (data, next)&#13;
    case .end:&#13;
        return nil&#13;
    }&#13;
}&#13;
</pre><p>To test this, we can execute the following:</p><pre class="programlisting">if let (element, linkedList) = functionalLinkedList.pop() {&#13;
    print(element)&#13;
    let newLinkedList = linkedList.pop()&#13;
    print(newLinkedList)&#13;
}&#13;
</pre><p>The result of the first <code class="literal">print</code> will be <code class="literal">3</code> and the result of the second <code class="literal">print</code> will be the following:</p><pre class="programlisting">Optional((2, LinkedList&lt;Swift.Int&gt;.node(1, LinkedList&lt;Swift.Int&gt;.end)))&#13;
</pre><p>This is just an example implementation, and we utilize <code class="literal">Optional</code> Tuple as a return to obtain the popped element as well as the resulting new linked list.</p><p>One more thing that we need to do is to change the name of our <code class="literal">enum</code> to something more generic, such as list.</p><p>Finally, our stack becomes very similar to the list.</p></div>
<div class="section" title="Lazy list"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Lazy list</h1></div></div></div><p>So far, we implemented a linked list and a stack as a list. One of the key concepts in functional programming is the concept of lazy evaluation. We can make our list lazy so that the elements will be evaluated once we access them. We need to change <code class="literal">node</code> in such a way that it will return a function containing List as next, instead of the list itself. The function will be evaluated when it is called; therefore, our list will be lazy.</p><p>We start with modifying our <code class="literal">node</code> case. In our <code class="literal">LinkedList</code> example, <code class="literal">next</code> was of the <code class="literal">LinkedList&lt;Element&gt;</code> type. To make our list lazy, we will modify <code class="literal">next</code> to be a function that returns our List:</p><pre class="programlisting">enum LazyList&lt;Element: Equatable&gt; {&#13;
    case end&#13;
    case node(data: Element, next: () -&gt; LazyList&lt;Element&gt;)&#13;
}&#13;
</pre><p>As we can see in the preceding code, our <code class="literal">Node</code> case is not defined as indirect because <code class="literal">next</code> is not of the <code class="literal">LazyList</code> type and is a reference to a function that returns <code class="literal">LazyList</code>.</p><p>We need to accommodate this change into our properties and methods. It is going to be as easy as changing any <code class="literal">next</code> to <code class="literal">next()</code>. For example, our <code class="literal">size</code> property becomes the following:</p><pre class="programlisting">var size: Int {&#13;
    switch self {&#13;
    case .node(_, let next):&#13;
        return 1 + next().size&#13;
    case .end:&#13;
        return 0&#13;
    }&#13;
}&#13;
</pre><p>If we followed the code and changed it properly, we would see that our <code class="literal">map</code> and <code class="literal">filter</code> do not compile. We need to change the operator as follows:</p><pre class="programlisting">infix operator &lt;|| { associativity right precedence 100 }&#13;
&#13;
func &lt;|| &lt;T&gt;(lhs: T, rhs: () -&gt; LazyList&lt;T&gt;) -&gt; LazyList&lt;T&gt; {&#13;
    return .node(data: lhs, next: rhs)&#13;
}&#13;
</pre><p>Here, we change our <code class="literal">rhs</code> to a function type that matches our LazyList's <code class="literal">next</code>. This change did not fix our <code class="literal">map</code> and <code class="literal">filter</code> problems. It seems that the right-hand side of the <code class="literal">infix</code> operator is evaluated before being passed to it and we do not want this.</p><p>This is because we do not pass a closure to our operator in the <code class="literal">map</code> and <code class="literal">filter</code> methods:</p><pre class="programlisting">func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; LazyList&lt;T&gt; {&#13;
    switch self {&#13;
    case .end:&#13;
        return .end&#13;
    case .node(let data, let next):&#13;
        return transform(data) &lt;|| next().map(transform)&#13;
    }&#13;
}&#13;
</pre><p>In our <code class="literal">map</code> method example, <code class="literal">next().map(transform)</code> is not a closure. If we wrap it in <code class="literal">{ }</code>, then it becomes a closure. We can modify our <code class="literal">infix</code> operator as follows:</p><pre class="programlisting">func &lt;|| &lt;T&gt;(lhs: T, rhs: @autoclosure(escaping) () -&gt; LazyList&lt;T&gt;)&#13;
  -&gt; LazyList&lt;T&gt; {&#13;
    return .node(data: lhs, next: rhs)&#13;
}&#13;
</pre><p>The <code class="literal">@autoclosure</code> attribute creates an automatic closure around the expression. So when we write an expression such as <code class="literal">next().map(transform)</code>, it is automatically wrapped in a closure to become <code class="literal">{ next().map(transform) }</code> before it is passed to our <code class="literal">infix</code> operator.</p><p>Starting in Swift 1.2, <code class="literal">autoclosure</code> defaults to <code class="literal">noescape</code>. This attribute ensures that parameters are not stored for later execution and will not outlive the lifetime of the call. The <code class="literal">noescape</code> implementation adds minor performance optimizations and bypasses the need to annotate properties and methods with <code class="literal">self</code>.</p><p>The <code class="literal">escaping</code> annotation in brackets is necessary in order to signify that the closure will last longer than the lifetime of the scope that it is declared in.</p><p>Finally, we need to change our <code class="literal">cons</code> method by wrapping <code class="literal">self</code> in <code class="literal">{ }</code> as follows:</p><pre class="programlisting">func cons(_ element: Element) -&gt; LazyList {&#13;
    return .node(data: element, next: { self })&#13;
}&#13;
</pre><p>Let's test our <code class="literal">LazyList</code> and see if it works properly:</p><pre class="programlisting">let ourLazyList = 3 &lt;|| 2 &lt;|| 1 &lt;|| LazyList.end // node(3, (Function))&#13;
print(ourLazyList.size) // prints 3&#13;
</pre><p>Our lazy list now becomes as follows:</p><pre class="programlisting">/// Operator&#13;
infix operator &lt;|| { associativity right precedence 100 }&#13;
&#13;
func &lt;|| &lt;T&gt;(lhs: T, rhs: @autoclosure(escaping) () -&gt; LazyList&lt;T&gt;)&#13;
  -&gt; LazyList&lt;T&gt; {&#13;
    return .node(data: lhs, next: rhs)&#13;
}&#13;
&#13;
/// Lazy List&#13;
enum LazyList&lt;Element: Equatable&gt; {&#13;
    case end&#13;
    case node(data: Element, next: () -&gt; LazyList&lt;Element&gt;)&#13;
 &#13;
    var size: Int {&#13;
        switch self {&#13;
        case .node(_, let next):&#13;
            return 1 + next().size&#13;
        case .end:&#13;
            return 0&#13;
        }&#13;
    }&#13;
 &#13;
    var elements: [Element] {&#13;
        switch self {&#13;
        case .node(let data, let next):&#13;
            return [data] + next().elements&#13;
        case .end:&#13;
            return []&#13;
        }&#13;
    }&#13;
 &#13;
    var isEmpty: Bool {&#13;
        switch self {&#13;
        case .node(_ , _):&#13;
            return false&#13;
        case .end:&#13;
            return true&#13;
        }&#13;
    }&#13;
 &#13;
    static func empty() -&gt; LazyList {&#13;
        return .end&#13;
    }&#13;
 &#13;
    func cons(_ element: Element) -&gt; LazyList {&#13;
        return .node(data: element, next: { self })&#13;
    }&#13;
 &#13;
    func removeLast() -&gt; (element: Element, linkedList: LazyList)? {&#13;
        switch self {&#13;
        case .node(let data, let next):&#13;
            return (data, next())&#13;
        case .end:&#13;
            return nil&#13;
        }&#13;
    }&#13;
 &#13;
    func map&lt;T&gt;(_ transform: (Element) -&gt; T) -&gt; LazyList&lt;T&gt; {&#13;
        switch self {&#13;
        case .end:&#13;
            return .end&#13;
        case .node(let data, let next):&#13;
            return transform(data) &lt;|| next().map(transform)&#13;
        }&#13;
    }&#13;
 &#13;
    func filter(_ predicate: ((Element) -&gt; Bool)) -&gt; LazyList&lt;Element&gt; {&#13;
        switch self {&#13;
        case .end:&#13;
            return .end&#13;
        case .node(let data, let next):&#13;
            return predicate(data) ? data &lt;|| next().filter(predicate)&#13;
              : next().filter(predicate)&#13;
        }&#13;
    }&#13;
 &#13;
    func reduce&lt;Value&gt;(_ initial: Value, combine: (Value, Element)&#13;
      -&gt; Value) -&gt; Value {&#13;
        switch self {&#13;
        case .end:&#13;
            return initial&#13;
        case .node(let data, let next):&#13;
            return next().reduce(combine(initial, data), combine: combine)&#13;
        }&#13;
    }&#13;
 &#13;
    static func contains(_ key: Element, list: LazyList&lt;Element&gt;) -&gt; Bool {&#13;
        switch list {&#13;
        case .end:&#13;
            return false&#13;
        case .node(let data, let next):&#13;
            if key == data {&#13;
                return true&#13;
            } else {&#13;
                return contains(key, list: next())&#13;
            }&#13;
        }&#13;
    }&#13;
}&#13;
</pre></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Summary</h1></div></div></div><p>In this chapter, we covered the concept of functional data structures and explored examples of data structures implemented in a functional way, such as Semigroup, Monoid, BST, linked list, stack, and lazy list.</p><p>Even though none of the data structures are complete, they serve as structures that present functional programming paradigms and techniques. It would also be beneficial to examine the performance of any of these data structures.</p><p>In the following chapter, we will cover the importance of immutability by examining its benefits. We will also examine an example of a mutable versus an immutable implementation as well as the means to get and set immutable objects in a functional way, such as copy constructors and lenses.</p></div></body></html>