<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Iteration and Searching Keys"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Iteration and Searching Keys</h1></div></div></div><p>
<a class="link" href="ch03.html" title="Chapter 3. Basic Key-value Operations – Creating and Deleting Data">Chapter 3</a>, <span class="emphasis"><em>Basic Key-value Operations Creating and Deleting Data</em></span>, found that <code class="literal">Put</code>, <code class="literal">Get</code>, and <code class="literal">Delete</code> values by keys was all we needed, but some way of getting more than one value back at a time is generally very useful. If you don't know what data may be in your keys, then you need a way to search for partial matches or just start from the beginning of the database. This ability to search for and iterate through keys in sorted order is what completes LevelDB's ability to be the <a id="id74" class="indexterm"/>foundation of a database. The default sorting order is a <code class="literal">BytewiseComparator</code>, effectively ASCII.</p><div class="section" title="Introducing Sample04 to show you loops and searches"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec20"/>Introducing Sample04 to show you loops and searches</h1></div></div></div><p>
<code class="literal">Sample04</code> uses the <a id="id75" class="indexterm"/>same <code class="literal">LevelDbHelpers.h</code> as before. Please download the entire sample and look at <code class="literal">main04.cpp</code> to see the code in context. Running <code class="literal">Sample04</code> starts by printing the output from the entire database, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/1015OS_04_01.jpg" alt="Introducing Sample04 to show you loops and searches"/><div class="caption"><p>Console output of listing keys</p></div></div><div class="section" title="Creating test records with a loop"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>Creating test records with a loop</h2></div></div></div><p>The test data being used here <a id="id76" class="indexterm"/>was created with a simple loop and forms a linked list as <a id="id77" class="indexterm"/>well. It is explained in more detail in the Simple Relational Style section. The loop creating the test data uses the new C++11 range-based for style of the loop:</p><div class="informalexample"><pre class="programlisting">vector&lt;string&gt; words {"Packt", "Packer", "Unpack", "packing",
"Packt2", "Alpacca"};
stringprevKey;
WriteOptionssyncW; syncW.sync = true;
WriteBatchwb;
for (auto key : words) {
  wb.Put(key, prevKey + "\tsome more content");
  prevKey = key;
}
assert(db-&gt;Write(syncW, &amp;wb).ok() );</pre></div><p>Note how we're using a <code class="literal">string</code> to hang onto the <code class="literal">prevKey</code>. There may be a temptation to use a <code class="literal">Slice</code> here to <a id="id78" class="indexterm"/>refer to the previous value of <code class="literal">key</code>, but remember the warning about a <code class="literal">Slice</code> only having a data pointer. This would be a classic bug introduced with a <code class="literal">Slice</code> pointing to a value that can be changed underneath it!</p><p>We're adding all the keys using a <a id="id79" class="indexterm"/>
<code class="literal">WriteBatch</code> not just for consistency, but also so that the storage engine knows it's getting a bunch <a id="id80" class="indexterm"/>of updates in one go and can optimize the file writing. I will be using the term <span class="strong"><strong>Record</strong></span> regularly <a id="id81" class="indexterm"/>from now on. It's easier to <a id="id82" class="indexterm"/>say than <a id="id83" class="indexterm"/>
<span class="strong"><strong>Key-value Pair</strong></span> and is also indicative of the richer, multi-value data we're storing.</p><div class="section" title="Stepping through all the records with iterators"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Stepping through all the records with iterators</h3></div></div></div><p>The model for multiple record reading in <a id="id84" class="indexterm"/>LevelDB is a simple iteration. Find a starting point and then step forwards or backwards.</p><p>This is done with an <code class="literal">Iterator</code> <a id="id85" class="indexterm"/>object that manages the order and starting point of your stepping through keys and values. You call methods on <code class="literal">Iterator</code> to choose where to start, to step and to get back the key and value. Each <code class="literal">Iterator</code> gets a consistent snapshot of the database, ignoring updates during iteration. Create a new <code class="literal">Iterator</code> to see changes.</p><p>If you have used declarative database APIs such as SQL-based databases, you would be used to performing a query and then operating on the results. Many of these APIs and older, record-oriented databases have a concept of a <a id="id86" class="indexterm"/>
<span class="strong"><strong>cursor</strong></span> which maintains the current position in the results which you can only move forward. Some of them allow you to move the cursor to the previous records. Iterating through individual records may seem clunky and old-fashioned if you are used to getting collections from servers. However, remember LevelDB is a local database. Each step doesn't represent a network operation!</p><p>The <span class="strong"><strong>iterable cursor</strong></span> <a id="id87" class="indexterm"/>approach is all that LevelDB offers, called an <code class="literal">Iterator</code>. If you want some way of mapping a collected set of results directly to a <span class="strong"><strong>listbox</strong></span> or other containers, you will have to implement it on top of the <code class="literal">Iterator</code>, as we will see later.</p><p>Iterating forwards, we just get an <code class="literal">Iterator</code> from our database and jump to the first record with <code class="literal">SeekToFirst()</code>:</p><div class="informalexample"><pre class="programlisting">Iterator* idb = db-&gt;NewIterator(ropt);
for (idb-&gt;SeekToFirst(); idb-&gt;Valid(); idb-&gt;Next())
cout&lt;&lt;idb-&gt;key() &lt;&lt;endl;</pre></div><p>Going backwards is very similar, but inherently less efficient as a storage trade-off:</p><div class="informalexample"><pre class="programlisting">for (idb-&gt;SeekToLast(); idb-&gt;Valid(); idb-&gt;Prev())
cout&lt;&lt;idb-&gt;key() &lt;&lt;endl;</pre></div><p>If you wanted to see the value as well as the keys, <a id="id88" class="indexterm"/>just use the <code class="literal">value()</code> method on the iterator (the test data in <code class="literal">Sample04</code> would make it look a bit confusing so it isn't being done here):</p><div class="informalexample"><pre class="programlisting">cout&lt;&lt;idb-&gt;key() &lt;&lt; " " &lt;&lt;idb-&gt;value()  &lt;&lt;endl;</pre></div><p>Unlike some other programming iterators, there's no concept of a special forward or backward iterator and no obligation to <a id="id89" class="indexterm"/>keep going in the same direction. Consider searching an HR database for the ten highest-paid managers. With a key of <span class="emphasis"><em>Job+Salary</em></span>, you would iterate through a range until you know you have hit the end of the managers, then iterate backwards to get the last ten.</p><p>An iterator is created by <a id="id90" class="indexterm"/>
<code class="literal">NewIterator()</code>, so you have to remember to delete it or it will leak memory. Iteration is over a consistent snapshot of the data, and any data changes through <code class="literal">Put</code>, <code class="literal">Get</code>, or <code class="literal">Delete</code> operations won't show until another <code class="literal">NewIterator()</code> is created.</p></div></div><div class="section" title="Searching for ranges of keys"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>Searching for ranges of keys</h2></div></div></div><p>The second half of the console <a id="id91" class="indexterm"/>output is from our examples of iterating through partial keys, which are case-sensitive by default, with the default <code class="literal">BytewiseComparator</code>.</p><div class="mediaobject"><img src="graphics/1015OS_04_02.jpg" alt="Searching for ranges of keys"/><div class="caption"><p>Console output of searches</p></div></div><p>As we've seen many times, the <a id="id92" class="indexterm"/>
<code class="literal">Get</code> function looks for an <span class="strong"><strong>exact</strong></span> match for a key. However, if you have an <code class="literal">Iterator</code>, you can use <code class="literal">Seek</code> and it will jump to the first key that either matches exactly or is immediately after the partial key you specify.</p><p>If we are just looking for keys with a <a id="id93" class="indexterm"/>common prefix, the optimal comparison is using the <code class="literal">starts_with</code> method of the <code class="literal">Slice</code> class:</p><div class="informalexample"><pre class="programlisting">Void listKeysStarting(Iterator* idb, const Slice&amp; prefix)
{
cout&lt;&lt; "List all keys starting with "
&lt;&lt;prefix.ToString() &lt;&lt;endl;
for (idb-&gt;Seek(prefix);
idb-&gt;Valid() &amp;&amp;idb-&gt;key().starts_with(prefix);
idb-&gt;Next())
cout&lt;&lt;idb-&gt;key() &lt;&lt;endl;
}</pre></div><p>Going backwards is a little bit more complicated. We use a key that is guaranteed to fail. You could think of it as being between the last key starting with our prefix and the next key out of the desired range. When we <a id="id94" class="indexterm"/>
<code class="literal">Seek</code> to that key, we need to step once to the previous key. If that's valid and matching, it's the last key in our range:</p><div class="informalexample"><pre class="programlisting">Void listBackwardsKeysStarting(Iterator* idb, const Slice&amp; prefix)
{
cout&lt;&lt; "List all keys starting with "
&lt;&lt;prefix.ToString() &lt;&lt; " backwards " &lt;&lt;endl;
const string keyAfter = prefix.ToString() + "\xFF";
idb-&gt;Seek(keyAfter);
if (idb-&gt;Valid())
idb-&gt;Prev(); // step to last key with actual prefix
else // no key just after our range, but
idb-&gt;SeekToLast(); // maybe the last key matches?
for(;idb-&gt;Valid() &amp;&amp;idb-&gt;key().starts_with(prefix);
idb-&gt;Prev())
cout&lt;&lt;idb-&gt;key() &lt;&lt;endl;
}</pre></div><p>What if you want to get keys within a range? For the first time, I disagree with the documentation included with LevelDB. Their iteration example shows a similar loop to that shown in the following code, but checks the key values with <code class="literal">idb-&gt;key().ToString() &lt; limit</code>. That is a more expensive way to iterate keys as it's generating a temporary string object for every key being checked, which is expensive if there were thousands in the range:</p><div class="informalexample"><pre class="programlisting">Void listKeys Between(Iterator* idb,
const Slice&amp;startKey, const Slice&amp;endKey)
{
cout&lt;&lt; "List all keys &gt;= " &lt;&lt;startKey.ToString()
&lt;&lt; " and &lt; " &lt;&lt;endKey.ToString() &lt;&lt;endl;
for (idb-&gt;Seek(startKey);
idb-&gt;Valid() &amp;&amp;idb-&gt;key().compare(endKey) &lt; 0; 
idb-&gt;Next())
cout&lt;&lt;idb-&gt;key() &lt;&lt;endl;
}</pre></div><p>We can use another built-in method of <code class="literal">Slice</code>; the <code class="literal">compare()</code> method, which returns a result &lt;0, 0, or &gt;0 to indicate if <code class="literal">Slice</code> is less than, equal to, or greater than the other <code class="literal">Slice</code> it is being compared to. This is <a id="id95" class="indexterm"/>the same semantics as the standard C <code class="literal">memcpy</code>. The code shown in the previous snippet will find keys that are the same, or after the <code class="literal">startKey</code> and are before the <code class="literal">endKey</code>. If you want the range to include the <code class="literal">endKey</code>, change the comparison to <code class="literal">compare(endKey) &lt;= 0</code>.</p><div class="section" title="Linking records in a simple relational style"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Linking records in a simple relational style</h3></div></div></div><p>There are many ways to <a id="id96" class="indexterm"/>implement richer relational indexing which will be discussed later. This simple example shows the value associated with a key storing both, some data and another key value. It is the classic linked list of records:</p><div class="mediaobject"><img src="graphics/1015OS_04_03.jpg" alt="Linking records in a simple relational style"/><div class="caption"><p>The chain of keys followed by storing a key in the value</p></div></div><p>As you can see, each record contains the information to find another related record. In this case, the relationship is just that the records were created in a particular order but it could be any consistent meaning, for example, a parent-child relationship.</p><p>The loop we saw earlier, creating the records composed the record value by storing a combination <code class="literal">prevKey + "\tsome more content</code> (where "some more content") would normally vary per-record. We extract that previous key and use it to navigate to another record:</p><div class="informalexample"><pre class="programlisting">string nextKey;
if (db-&gt;Get(ropt, firstkey, &amp;nextKey).IsNotFound())
return firstkey + " ** not found **";  
string ret = firstkey;
for (;;) {
  string key = value.substr(0, value.find("\t") );     
  if (db-&gt;Get(ropt, key, &amp;value).IsNotFound())
  break;
  ret += " -&gt; " + key;
}
return ret;</pre></div><p>Note how we used a simple tab character as the separator in the record value, between the next key to use and the text which was the real content. This principle is the same as a relational database; key values for other searches are contained in a record. This example only has one kind of a record data. In the next chapter, we will use this technique to build a secondary index where phone number keys are used to find the main record key. If you need to find data, adding multiple keys <a id="id97" class="indexterm"/>is the only way to achieve speed.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter, we learned the concept of an iterator in LevelDB as a way to step through records sorted by their keys. The database became far more useful with searches to get the starting point for the iterator, and samples showing how to efficiently check keys as you step through a range. Finally, we went back to the simple <code class="literal">Get</code> for a key lookup to help implement a linked list through the database. Now, we will leave C++ behind for the world of Objective-C.</p></div></body></html>