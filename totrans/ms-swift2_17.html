<html><head></head><body><div class="chapter" title="Chapter&#xA0;17.&#xA0;Adopting Design Patterns in Swift"><div class="titlepage"><div><div><h1 class="title"><a id="ch17"/>Chapter 17. Adopting Design Patterns in Swift</h1></div></div></div><p>Although the Gang of Four's <span class="emphasis"><em>Design Patterns: Elements of Reusable Object-Oriented Software</em></span> was first published in October 1994, it has only been in the last 6 or 7 years that I started paying attention to design patterns. Like most experienced developers, when I first started reading about design patterns, I recognized a lot of the patterns because I had already been using them without realizing what they were. I would have to say that in the past 6 or 7 years since I first read about design patterns, I did not write a serious application without using at least one of the Gang of Four's design patterns. I will tell you that I am definitely not a design pattern zealot, and actually, if I get into a conversation about design patterns, there is usually only a couple that I can name without having to look them up, but one thing that I do remember is the concepts of the major patterns and the problems they are written to solve. This way, when I encounter one of these problems, I can look up the appropriate pattern and apply it.</p><p>In this chapter, you will learn about the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The difference between reference and value types</li><li class="listitem" style="list-style-type: disc">What design patterns are</li><li class="listitem" style="list-style-type: disc">What types of patterns make up the creational, structural, and behavioral categories of design patterns</li><li class="listitem" style="list-style-type: disc">How to implement the builder, factory method, and singleton creational patterns in Swift</li><li class="listitem" style="list-style-type: disc">How to implement the bridge, façade, and proxy structural patterns in Swift</li><li class="listitem" style="list-style-type: disc">How to implement the strategy and command behavioral patterns in Swift</li></ul></div><div class="section" title="Value versus reference types"><div class="titlepage"><div><div><h1 class="title"><a id="ch17lvl1sec101"/>Value versus reference types</h1></div></div></div><p>In <a class="link" href="ch05.html" title="Chapter 5. Classes and Structures">Chapter 5</a>, <span class="emphasis"><em>Classes and Structures</em></span>, we discussed the difference between value and reference<a class="indexterm" id="id784"/> types. It is important that we understand the basic<a class="indexterm" id="id785"/> differences between the two types, especially when we are architecting our code. Certain design patterns work best with reference types, while other work best with value types; therefore, knowing when to use each type is important in design patterns. With that in mind, let's review the difference between reference and value types.</p><p>A class is a reference type. What this means is that when we pass an instance of a class around our code, we are passing a reference to the original instance. Since we are passing a reference to the original instance, any changes that are made to this instance are reflected back to the original instance.</p><p>Structures, enums, and tuples are all value types. When we pass an instance of a value type, we are passing a copy of the type. This means that any changes made to this copy is not reflected back to the original. Let's take a look at the difference between a value and reference types by looking at some code. We will begin by creating a class named <code class="literal">MyClass</code> and a structure named <code class="literal">MyStruct</code>. Both of these types contain a single property named <code class="literal">number</code> that will be of the Int type:</p><div class="informalexample"><pre class="programlisting">class MyClass {
    var number = 0
}

struct MyStruct {
    var number = 0
}</pre></div><p>Now let's create an instance of the <code class="literal">MyClass</code> class. We will also create a second constant of the <code class="literal">MyClass</code> type that is created from the first instance. We will then change the <code class="literal">number</code> property in one of the instances, and see what the value is in both:</p><div class="informalexample"><pre class="programlisting">let myClass1 = MyClass()
let myClass2 = myClass1

myClass2.number = 5

print("myClass1 = \(myClass1.number)")
print("myClass2 = \(myClass2.number)")</pre></div><p>If we ran this code, we would see the following output:</p><div class="informalexample"><pre class="programlisting">myClass1 = 5
myClass2 = 5</pre></div><p>As we can see, when we changed the <code class="literal">number</code> property in one instance, it changed the value in both. This also means that there is only one instance of the <code class="literal">MyClass</code> class in memory.</p><p>Now let's look <a class="indexterm" id="id786"/>at this same example, but this time, we will<a class="indexterm" id="id787"/> use the <code class="literal">MyStruct</code> structure (value type) rather than the <code class="literal">MyClass</code> class (reference type):</p><div class="informalexample"><pre class="programlisting">var myStruct1 = MyStruct()
var myStruct2 = myStruct1

myStruct2.number = 5

print("myStruct1 = \(myStruct1.number)")
print("myStruct2 = \(myStruct2.number)")</pre></div><p>If we ran this code, we would see the following output:</p><div class="informalexample"><pre class="programlisting">myStruct1 = 0
myStruct2 = 5</pre></div><p>Notice that in this example, when we change the <code class="literal">number</code> property of one instance, it did not change the property in the other. Since the <code class="literal">myStruct2</code> structure was created with a copy of the <code class="literal">myStruct</code> structure, we now have two instances of the <code class="literal">MyStruct</code> structure in memory.</p><p>Also notice that we defined the instances of the <code class="literal">MyClass</code> class as constants with the <code class="literal">let</code> keyword; however, we defined the instances of the <code class="literal">MyStruct</code> structure as variables with the <code class="literal">var</code> keyword.</p><p>When a constant refers to an instance of a reference type, we are unable to change the instance that the constant is referring to; however, we are able to change the values of the properties of that instances, as shown in the previous example. When a constant refers to an instance of a value type, we will not only be unable to change the instance that the constant is referring to, but we will also be unable to change any of the property values. Swift arrays and dictionaries are value types which is why when they are declared constants, they are immutable. This means, in our previous example, in order to change the values of the <code class="literal">number</code> properties, we needed to create the instances of the <code class="literal">MyStruct</code> structures as variables and not constants.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>For some of the design patterns in this chapter, we used structures and for some other, we used classes. The choice to use either a structure or class for these examples is based on the experience of the author. For most of the patterns, the choice of using either a structure or a class should be based on the needs of the individual application. In each section, we will explain why we chose either a structure or a class to help you understand why it was chosen.</p></div></div></div></div>
<div class="section" title="What are design patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch17lvl1sec102"/>What are design patterns</h1></div></div></div><p>Every <a class="indexterm" id="id788"/>experienced developer has a set of informal strategies that shape how he/she designs and writes applications. These strategies are shaped by their past experiences and the obstacles that they have had to overcome in previous projects. Though these developers might swear by their strategies, it does not mean that their strategies have been fully vetted and proven. The use of these strategies also introduces inconsistent implementations between different developers.</p><p>A design pattern identifies a common software development problem and provides a strategy for dealing with it. Over the years, the strategies behind these design patterns have been proven to effectively solve the problem they are intended to solve.</p><p>While there is a lot to like about design patterns, and they are extremely beneficial to developers and architects, they are not the solution for world hunger that some developers make them out to be. Sometimes in your development career, you will probably meet a developer or architect who thinks that design patterns are immutable laws. These developers usually try to force the use of design patterns even when they are not necessary. A good rule of thumb is to make sure that you have a problem to fix before you try to fix it.</p><p>Keep in mind that design patterns are starting points for avoiding and solving common programming problems. We can think of each design pattern as a recipe for a food dish, and just like a good recipe, we can tinker and adjust it to meet our particular taste, but we usually do not want to stray too far from the original recipe because we may mess it up.</p><p>There are also times that we do not have a recipe for a certain dish, just like there are times when there isn't a design pattern to solve the problem we face. In these cases, we can use our knowledge of design patterns and their underlying philosophy to come up with an effective solution to the problem.</p><p>Design patterns can be broken into three categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Creational patterns</strong></span>: These support the<a class="indexterm" id="id789"/> creation of objects</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Structural patterns</strong></span>: These<a class="indexterm" id="id790"/> are concerned with class and object compositions</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Behavioral patterns</strong></span>: These<a class="indexterm" id="id791"/> are concerned with communication between classes</li></ul></div><p>While the Gang of Four defined over 20 design patterns, we are only going to give examples of some of the most popular patterns in this chapter. Let's start off by looking at the creational patterns.</p></div>
<div class="section" title="Creational patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch17lvl1sec103"/>Creational patterns</h1></div></div></div><p>Creational <a class="indexterm" id="id792"/>patterns are design patterns that deal with how an object is created. These patterns create objects in a manner that is suitable for the particular situation. There are two basic ideas behind creational patterns. The first is encapsulating the knowledge of which concrete classes should be created and the second is hiding how the instances of these classes are created. There are five well-known patterns that are part of the creational pattern category:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Abstract factory pattern</strong></span>: This provides<a class="indexterm" id="id793"/> an interface for creating related objects without specifying the concrete class</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Builder pattern</strong></span>: This<a class="indexterm" id="id794"/> separates the construction of a complex object from its representation so the same process can be used to create similar types</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Factory method pattern</strong></span>: This creates objects without exposing the underlying<a class="indexterm" id="id795"/> logic of how the object or which type is created</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Prototype pattern</strong></span>: This creates an object by<a class="indexterm" id="id796"/> cloning an existing one</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Singleton pattern</strong></span>: This allows one and only<a class="indexterm" id="id797"/> one instance of a class for the lifetime of an application</li></ul></div><p>In this chapter, we are going to show you examples of how to use the builder, factory method, and singleton patterns in Swift. Let's start off by looking at one of the most controversial and possibly overused design patterns—the singleton pattern.</p><div class="section" title="The singleton design pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec154"/>The singleton design pattern</h2></div></div></div><p>The use <a class="indexterm" id="id798"/>of the singleton pattern is a fairly controversial subject among certain corners of the development community. One of the main reasons for this is the singleton pattern is probably the most overused and misused pattern. Another reason why this pattern is controversial is that the singleton pattern introduces a global state into an application, which allows the ability to change the object at any point within the application, thereby ignoring the scope. My personal opinion is, if the singleton pattern is used correctly, there is nothing wrong with using it; however, we do need to be careful not to misuse it.</p><p>The singleton pattern restricts the instantiation of a class to one instance for the lifetime of an application. This pattern is very effective when we need exactly one object to coordinate actions within our application. An example of a good use of a singleton is if our application communicates with a remote device over Bluetooth and we also want to maintain that connection throughout our application. While some would say that we can pass the instance of the connection class from one page to the next, that is essentially what a singleton is.</p><p>In my opinion, the singleton pattern, in this instance, is much cleaner because with the singleton pattern, any page that needs the connection can get it without forcing every page to<a class="indexterm" id="id799"/> maintain the instance. This also allows us to maintain the connection without having to reconnect each time we go to another page.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>There are several ways to implement the singleton pattern in Swift. The way that is presented here uses class constants, which were introduced in version 1.2 of Swift.</p></div></div><p>Let's look at how we would implement the singleton pattern with Swift. The following code example shows how to create a singleton class:</p><div class="informalexample"><pre class="programlisting">class MySingleton {
  static let sharedInstance = MySingleton()
  var number = 0
  
  private init() {}

}</pre></div><p>We can see that within the <code class="literal">MySingleton</code> class, we create a static constant named <code class="literal">sharedInstance</code>, which contains an instance of the <code class="literal">MySingleton</code> class. A static constant can be called without having to instantiate the class. Since we declared the <code class="literal">sharedInstance</code> constant static, only one instance will exist throughout the life cycle of the application, thereby creating the singleton pattern.</p><p>We also create a private initiator that will restrict other code from creating another instance of the <code class="literal">MySingleton</code> class.</p><p>Now, let's see how this pattern works. The <code class="literal">MySingleton</code> pattern has another property named <code class="literal">number</code>, which is of the Int type. We will monitor how this property changes as we use the <code class="literal">sharedInstance</code> property to create multiple variables of the <code class="literal">MySingleton</code> type, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var singleA = MySingleton.sharedInstance
var singleB = MySingleton.sharedInstance
var singleC = MySingleton.sharedInstance

singleB.number = 2

print(singleA.number)
print(singleB.number)
print(singleC.number)

singleC.number = 3

print(singleA.number)
print(singleB.number)
print(singleC.number)</pre></div><p>In this <a class="indexterm" id="id800"/>example, we use the <code class="literal">sharedInstance</code> property to create three variables of the <code class="literal">MySingleton</code> type. We initially set the <code class="literal">number</code> property of the second <code class="literal">MySingleton</code> variable (<code class="literal">singleB</code>) to the number <code class="literal">2</code>. When we print out the value of the <code class="literal">number</code> property for <code class="literal">singleA</code>, <code class="literal">singleB</code>, and <code class="literal">singleC</code>, we see that the <code class="literal">number</code> property for all the three equals to <code class="literal">2</code>. We then change the value of the <code class="literal">number</code> property of the third <code class="literal">MySingleton</code> variable (<code class="literal">singleC</code>) to the number <code class="literal">3</code>. When we print out the value of the <code class="literal">number</code> property again, we see that this time, all the three now have the value of <code class="literal">3</code>. Therefore, when we change the value of the <code class="literal">number</code> property in any of the instances, it changes the values for all the three because each variable is pointed to the same instance.</p><p>The singleton pattern can be very useful when we need to maintain the state of an object throughout our application, but be careful not to overuse it. The singleton pattern should not be used unless there is a specific requirement (requirement is the keyword here) for having one, and only one, instance of our class throughout the life cycle of our application. If we are using the singleton pattern simply for convenience, then we are misusing it.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note29"/>Note</h3><p>For the singleton pattern, we created the <code class="literal">MySingleton</code> type as a class (reference type) because we wanted to ensure that only one instance of the type existed throughout our application. If we created the <code class="literal">MySingleton</code> type as a structure (value type), we would run the risk of the existence of multiple instances because structures are value type.</p></div></div><p>Now, let's look at the builder design pattern.</p></div><div class="section" title="The builder design pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec155"/>The builder design pattern</h2></div></div></div><p>The builder<a class="indexterm" id="id801"/> pattern helps us in the creation of complex objects and enforces the process of how these objects are created. With this pattern, we generally separate the creation logic from the complex class and put it in another class. This allows us to use the same construction process to create different representations of the class.</p><p>In this section, we will see how to use the builder pattern by creating a <code class="literal">Burger</code> class and then use various different burger builders to create different types of burgers. Before we see how to use the builder pattern, let's look at how to create a <code class="literal">Burger</code> class without the builder pattern and the problems we'll run into.</p><p>The following code creates a class named <code class="literal">BurgerOld</code> and does not use the builder pattern:</p><div class="informalexample"><pre class="programlisting">class BurgerOld {
    var name: String
    var patties: Int
    var bacon: Bool
    var cheese: Bool
    var pickles: Bool
    var ketchup: Bool
    var mustard: Bool
    var lettuce: Bool
    var tomato: Bool
    
    init(name: String, patties: Int, bacon: Bool, cheese: Bool, pickles: Bool,ketchup: Bool,mustard: Bool,lettuce: Bool,tomato: Bool) {
        self.name = name
        self.patties = patties
        self.bacon = bacon
        self.cheese = cheese
        self.pickles = pickles
        self.ketchup = ketchup
        self.mustard = mustard
        self.lettuce = lettuce
        self.tomato = tomato
    }
}</pre></div><p>In the <code class="literal">BurgerOld</code> class, we have several properties that define what is on the burger and also the<a class="indexterm" id="id802"/> name of the burger. Since we need to know which items are on the burgers and which aren't, when we create an instance of the <code class="literal">BurgerOld</code> class, the initializer requires us to define each item. This can lead to some complex initializations throughout our application, not to mention that if we had more than one standard burger (bacon cheeseburger, cheeseburger, hamburger, and so on), we would need to make sure that we define each correctly. Let's see how to create the instances of the <code class="literal">BurgerOld</code> class:</p><div class="informalexample"><pre class="programlisting">// Create Hamburger
var burgerOld = BurgerOld(name: "Hamburger", patties: 1, bacon: false, cheese: false, pickles: false, ketchup: false, mustard: false, lettuce: false, tomato: false)

// Create Cheeseburger
var burgerOld = BurgerOld(name: "Cheeseburger", patties: 1, bacon: false, cheese: false, pickles: false, ketchup: false, mustard: false, lettuce: false, tomato: false)</pre></div><p>Now, let's look at a better way to do this. We will begin by creating a <code class="literal">BurgerBuilder</code> protocol that will have the following code in it:</p><div class="informalexample"><pre class="programlisting">protocol BurgerBuilder {
    var name: String {get}
    var patties: Int {get}
    var bacon: Bool {get}
    var cheese: Bool {get}
    var pickles: Bool {get}
    var ketchup: Bool {get}
    var mustard: Bool {get}
    var lettuce: Bool {get}
    var tomato: Bool {get}
}</pre></div><p>This <a class="indexterm" id="id803"/>protocol simply defines the nine properties that will be required for any class that implements this protocol. Now, let's create two classes that implement this protocol—the <code class="literal">HamburgerBuilder</code> and <code class="literal">CheeseBurgerBuilder</code> classes:</p><div class="informalexample"><pre class="programlisting">class HamBurgerBuilder: BurgerBuilder {
    let name = "Burger"
    let patties = 1
    let bacon = false
    let cheese = false
    let pickles = true
    let ketchup = true
    let mustard = true
    let lettuce = false
    let tomato = false
}

class CheeseBurgerBuilder: BurgerBuilder {
    let name = "CheeseBurger"
    let patties = 1
    let bacon = false
    let cheese = true
    let pickles = true
    let ketchup = true
    let mustard = true
    let lettuce = false
    let tomato = false
}</pre></div><p>In both the <code class="literal">HamburgerBuilder</code> and <code class="literal">CheeseBurgerBuilder</code> classes, all we are doing is defining the values for each of the required properties. In more complex classes, we might need to initialize other objects that are required by this instance.</p><p>Now, let's look <a class="indexterm" id="id804"/>at our <code class="literal">Burger</code> class that will use implementations of the <code class="literal">BugerBuilder</code> protocol to create instances of itself. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">class Burger {
    var name: String
    var patties: Int
    var bacon: Bool
    var cheese: Bool
    var pickles: Bool
    var ketchup: Bool
    var mustard: Bool
    var lettuce: Bool
    var tomato: Bool

    init(builder: BurgerBuilder) {
        self.name = builder.name
        self.patties = builder.patties
        self.bacon = builder.bacon
        self.cheese = builder.cheese
        self.pickles = builder.pickles
        self.ketchup = builder.ketchup
        self.mustard = builder.mustard
        self.lettuce = builder.lettuce
        self.tomato = builder.tomato
    }

func showBurger() {
    print("Name:    \(name)")
    print("Patties: \(patties)")
    print("Bacon:   \(bacon)")
    print("Cheese:  \(cheese)")
    print("Pickles: \(pickles)")
    print("Ketchup: \(ketchup)")
    print("Mustard: \(mustard)")
    print("Lettuce: \(lettuce)")
    print("Tomato:  \(tomato)")
}
}</pre></div><p>The difference between this <code class="literal">Burger</code> class and the <code class="literal">BurgerOld</code> class, shown earlier in this section, is the initializer. In the previous <code class="literal">BurgerOld</code> class, the initializer took nine arguments—one for each constant defined in the class. In the new <code class="literal">Burger</code> class, the initializer takes one argument, which is an instance of a class that conforms to the <code class="literal">BurgerBuilder</code> protocol. This new initializer allows us to create instances of the <code class="literal">Burger</code> class like this:</p><div class="informalexample"><pre class="programlisting">// Create Hamburger
var myBurger = Burger(builder: HamBurgerBuilder())
myBurger.showBurger()

// Create Cheeseburger with tomatoes
var myCheeseBurgerBuilder = CheeseBurgerBuilder()
var myCheeseBurger = Burger(builder: myCheeseBurgerBuilder)
myCheeseBurger.tomato = false
myCheeseBurger.showBurger()</pre></div><p>If we<a class="indexterm" id="id805"/> compare how we created instances of the new <code class="literal">Burger</code> class to the earlier <code class="literal">BurgerOld</code> class, we can see that it is much easier to create instances of the <code class="literal">Burger</code> class. We also know that we are setting the values for each type of burger correctly because the values are set directly in the builder classes.</p><p>As we can see, the builder pattern helps us to simplify the creation of complex objects. It also ensures that our objects are fully created.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>In this example, for our builder types, we chose to use classes (reference types). There really is not a huge advantage to using either a reference or value type; therefore, the reference type was chosen because it did not make sense to make multiple copies of our builder types.</p></div></div><p>For our last example of a creational pattern, we will look at the factory method pattern.</p></div><div class="section" title="The factory method pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec156"/>The factory method pattern</h2></div></div></div><p>The <a class="indexterm" id="id806"/>factory method pattern uses factory methods to create instance of objects without specifying the exact class that will be created. This allows us to pick the exact class to create at runtime.</p><p>Let's look at how to use the factory method pattern by creating a computer store class that allows us to pick a computer from multiple models. We will begin by creating a protocol named <code class="literal">Computer</code>. Each class that represents a different computer model will implement the <code class="literal">Computer</code> protocol. Here is the code for the <code class="literal">Computer</code> protocol:</p><div class="informalexample"><pre class="programlisting">protocol Computer {
  func getType() -&gt; String
}</pre></div><p>The only method in the <code class="literal">Computer</code> protocol is a method that returns a string type that represents the model of the computer. Now, let's create three concrete classes that implement the <code class="literal">Computer</code> protocol:</p><div class="informalexample"><pre class="programlisting">class MacbookPro: Computer {
  func getType() -&gt; String {
    return "Macbook Pro"
  }
}
class IMac: Computer {
  func getType() -&gt; String {
    return "iMac"
  }
}

class MacMini: Computer {
  func getType() -&gt; String {
    return "MacMini"
  }
}</pre></div><p>Each <a class="indexterm" id="id807"/>of the three classes that implement the <code class="literal">Computer</code> protocol return a unique string type in the <code class="literal">getType()</code> method. This will identify which class was created. Now, let's look at our <code class="literal">ComputerStore</code> class that will create an instance of one of these three classes depending on the type of computer we are looking for. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">class ComputerStore {
  enum ComputerType {
    case Laptop
    case Desktop
    case Headless
  }
   
  func getModel(type: ComputerType) -&gt; Computer {
    switch(type) {
    case ComputerType.Laptop:
      return MacbookPro()
    case ComputerType.Desktop:
      return IMac()
    case ComputerType.Headless:
      return MacMini()  
    }
  }
}</pre></div><p>In the <code class="literal">ComputerStore</code> class, we begin by creating an enum named <code class="literal">ComputerType</code>, which defines the types of computers that we sell. These types are <code class="literal">Laptop</code>, <code class="literal">Desktop</code>, and <code class="literal">Headless</code>.</p><p>The <code class="literal">ComputerStore</code> class has one method and that is the <code class="literal">getModel()</code> method. This method accepts<a class="indexterm" id="id808"/> one argument, which is of the <code class="literal">ComputerType</code> types and returns an instance of a type that conforms to the <code class="literal">Computer</code> protocol, depending on the <code class="literal">ComputerType</code> enum that was passed in. Within this method, we create a <code class="literal">switch</code> statement that will create and return an instance of a class that confirms to the <code class="literal">Computer</code> protocol.</p><p>Now, let's look at how to use the <code class="literal">ComputerStore</code> class:</p><div class="informalexample"><pre class="programlisting">var laptop = store.getModel(.Laptop)
print(laptop.getType())</pre></div><p>In this example, we begin by creating an instance of the <code class="literal">ComputerStore</code> class. We then call the <code class="literal">getModel()</code> method to retrieve an instance of a class that conforms the <code class="literal">Computer</code> protocol by passing in a <code class="literal">ComputerType</code> value. The code that is calling the <code class="literal">getModel()</code> method does not need to know how the backend code selects which type of class to create; all it knows is that it should get a valid instance of a type that conforms to the <code class="literal">Computer</code> protocol or <code class="literal">nil</code>.</p><p>I find myself using this pattern a lot. Anytime we have multiple types that conform to the same protocol, we may want to consider using the factory method pattern to centralize the creation of these objects; otherwise, we may find that we are repeating the object creation code in multiple parts of our application.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>Like the builder pattern, we chose to use classes to represent the different computer types mainly because it does not make sense to create multiple copies of the computer types.</p></div></div><p>One of the key ideas about design patterns, especially the creational patterns, is that we take the logic about how and what to create out of our general code and put it into specific classes or functions. Then, when we need to make changes to our code in the future, the logic is embedded in a single spot and can be easily changed, rather than having the logic in multiple spots throughout our code.</p><p>Now, let's look at the structural design patterns.</p></div></div>
<div class="section" title="Structural design patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch17lvl1sec104"/>Structural design patterns</h1></div></div></div><p>Structural <a class="indexterm" id="id809"/>design patterns describe how classes can be combined to form larger structures. These larger structures can generally be easier to work with and hide a lot of the complexity of the individual classes. Most of the patterns in the structural pattern category involve connections between objects.</p><p>There are <a class="indexterm" id="id810"/>seven well-known patterns that are part of the structural design pattern type:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Adapter</strong></span>: This <a class="indexterm" id="id811"/>allows classes with incompatible interfaces to work together</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bridge</strong></span>: This is <a class="indexterm" id="id812"/>used to separate the abstract elements of a class from the implementation so that the two can vary</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Composite</strong></span>: This <a class="indexterm" id="id813"/>allows us to treat a group of objects as a single object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Decorator</strong></span>: This<a class="indexterm" id="id814"/> lets us add or override behavior in an existing method of an object</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Façade</strong></span>: This <a class="indexterm" id="id815"/>provides a simplified interface for a larger and more complex body of code</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flyweight</strong></span>: This<a class="indexterm" id="id816"/> allows us to reduce the resources needed to create and use a large number of similar objects</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Proxy</strong></span>: This <a class="indexterm" id="id817"/>is a class acting as an interface for another class or classes</li></ul></div><p>In this chapter, we are going to give examples of how to use bridge, façade, and proxy patterns in Swift. Let's start off by looking at the bridge pattern.</p><div class="section" title="The bridge pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec157"/>The bridge pattern</h2></div></div></div><p>The <a class="indexterm" id="id818"/>bridge pattern decouples the abstraction from the implementation so that they can both vary independently. The bridge pattern can also be thought of as a two-layer abstraction.</p><p>In this section, we will show you how to use the bridge pattern by creating a simple universal remote class that can control multiple TV objects. We will begin by creating protocols for both the remote control and the TVs, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">protocol TV {
  var currentChannel: Int {get set}
  
  func turnOn()
  func turnOff()
}

protocol RemoteControl {
  var tv: TV {get set}
  init(tv: TV)
}</pre></div><p>The <code class="literal">TV</code> protocol defines one property and two functions. The <code class="literal">currentChannel</code> property is used to keep track of the current channel that the TV is on. The functions are <code class="literal">turnOn()</code> and <code class="literal">turnOff()</code>,which are used to turn the TV on or off.</p><p>The <code class="literal">RemoteControl</code> protocol defines one property and one initializer. The <code class="literal">tv</code> property holds the instance of the TV that we want to control. The initializer will initiate the remote with a type that conforms to the <code class="literal">TV</code> protocol.</p><p>Now we <a class="indexterm" id="id819"/>will extend both the <code class="literal">TV</code> and <code class="literal">RemoteControl</code> protocols to add common functionalities for types that conform to the protocols. Keep in mind that the functionality added here could be overridden in the types that conform to the protocol:</p><div class="informalexample"><pre class="programlisting">extension TV {
    mutating func changeChannel(channel: Int) {
        self.currentChannel = channel
    }
}

extension RemoteControl {
    func turnOn() {
        tv.turnOn()
    }
    func turnOff() {
        tv.turnOff()
    }
    mutating func setChannel(channel: Int) {
        tv.changeChannel(channel)
    }
    mutating func nextChannel() {
        tv.changeChannel(tv.currentChannel + 1)
    }
    mutating func prevChannel() {
        tv.changeChannel(tv.currentChannel - 1)
    }
}</pre></div><p>In the <code class="literal">TV</code> extension, we are adding a method to change the channel on the TV. In the <code class="literal">RemoteControl</code> extension, we are adding five methods that turn the TV on/off or change the channel on the TV.</p><p>Now, let's look at how to create structures that conform to the <code class="literal">TV</code> protocol. For this, we will define two concrete implementations of the protocol, which are as follows:</p><div class="informalexample"><pre class="programlisting">struct VizioTV: TV {
    
    var currentChannel = 1
    
    func turnOn() {
        print("Vizio On")
    }
    func turnOff() {
        print("Vizio Off")
    }
}

struct SonyTV: TV {
    
    var currentChannel = 1
    
    func turnOn() {
        print("Sony On")
    }
    func turnOff() {
        print("Sony Off")
    }
}</pre></div><p>With this<a class="indexterm" id="id820"/> code, we define both the <code class="literal">SonyTV</code> and <code class="literal">VizioTV</code> implementations of the <code class="literal">TV</code> protocol. Within these structures, we implement all of the requirements for the <code class="literal">TV</code> protocol. We will be using these implementations to tell the universal remote which TV to control. Now, let's see how to implement the <code class="literal">RemoteControl</code> protocol, which is as follows:</p><div class="informalexample"><pre class="programlisting">class MyUniversalRemote: RemoteControl {
    var tv: TV
    
    required init(tv: TV) {
        self.tv = tv
    }
}</pre></div><p>Within the <code class="literal">MyUniversalRemote</code> class, we implement the required initializer for the <code class="literal">Remote</code> protocol.</p><p>To use this pattern, we would begin by creating an instance of the <code class="literal">TV</code> type that we wish to control. We would then use that instance to initiate our remote control type, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var myTv = VizioTV()
var remote = MyUniversalRemote(tv: myTv)
remote.turnOn()
remote.nextChannel()
print("Channel on: \(myTv.currentChannel)")
remote.nextChannel()
print("Channel on: \(myTv.currentChannel)")
remote.turnOff()</pre></div><p>The<a class="indexterm" id="id821"/> bridge pattern can be thought of as two layers of abstraction where the abstraction and implementations should not be bound at compile time. This allows us to define which objects to use at runtime. This also allows us to add more TVs to our <code class="literal">myUniversalRemote</code> class simply by creating new classes that implement the <code class="literal">TV</code> protocol.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>For this pattern, we implemented the types that conform to the <code class="literal">TV</code> protocol using structures. Structures were chosen because it is very easy to create one instance of a TV type and then use it to create multiple instances of the remote control types, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var myTv = VizioTV()
var remoteForTV1 = MyUniversalRemote(tv: myTv)
var remoteForTV2 = MyUniversalRemote (tv: myTv)</pre></div><p>In this example, if the <code class="literal">VizioTV</code> type were implemented with a class, then the both <code class="literal">MyUniversalRemote</code> instances would refer to the same TV rather than different TVs. Therefore, even though we had two TVs, each with separate remotes, both of the remotes would actually on work on one of the TVs.</p><p>There are times when we want this behavior and for those times, we should use classes; however, in my experience, this is usually not the desired behavior.</p></div></div><p>Now, let's look at the next pattern in the structural category—the façade pattern.</p></div><div class="section" title="The façade pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec158"/>The façade pattern</h2></div></div></div><p>The façade <a class="indexterm" id="id822"/>pattern provides a simplified interface to a larger and more complex body of code. This allows us to make our libraries easier to use and understand by hiding some of the complexities. It also allows us to combine multiple API's into a single, easier to use API, which is what we will see in our example.</p><p>In this example, we will make a simplified travel API that combines the hotel, flight, and rental car APIs into a single, easy-to-use interface. We will start off by defining the hotel, flight, and rental car classes, which are as follows:</p><div class="informalexample"><pre class="programlisting">struct HotelBooking {
    static func getHotelNameForDates(to: NSDate, from: NSDate) -&gt; [String]? {
        let hotels = [String]()
        //logic to get hotels
        return hotels
    }
}

struct FlightBooking {
    static func getFlightNameForDates(to: NSDate, from: NSDate) -&gt; [String]? {
        let flights = [String]()
        //logic to get flights
        return flights
    }
}

struct RentalCarBooking {
    static func getRentalCarNameForDates(to: NSDate, from: NSDate) -&gt; [String]? {
        let cars = [String]()
        //logic to get flights
        return cars
    }
}</pre></div><p>In each<a class="indexterm" id="id823"/> of these APIs, we define a single static method that will return a list of items (hotels, flights, or rental cars) that are available for the requested date. We actually do not implement any logic here because we would need to define a data source, and I would prefer to keep the example simple to concentrate on how the pattern works.</p><p>Now, let's look at our <code class="literal">TravelFacade</code> class that will combine these three APIs into a single, easier to use API, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">class TravelFacade {
var hotels: [String]?
var flights: [String]?
var cars: [String]?    

    init(to: NSDate, from: NSDate) {
        hotels = HotelBooking.getHotelNameForDates(to, from: from)
        flights = FlightBooking.getFlightNameForDates(to, from: from)
        cars = RentalCarBooking.getRentalCarNameForDates(to, from: from)
    }
}</pre></div><p>Inside the <code class="literal">TravelFacade</code> class, we create a single initializer that accepts two <code class="literal">NSDate</code> objects as the parameters. We then use those two <code class="literal">NSDate</code> objects to retrieve the hotels, flights, and rental cars that are available for the time period defined by the dates.</p><p>The façade <a class="indexterm" id="id824"/>pattern is very useful when we have a complex API structure that we want to simplify. It is also very useful when we have a series of multiple related APIs, as we saw in our example, to consolidate them in a single API.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>For this pattern, we chose to use structures when we implemented the three booking types; however, which type is used (classes or structures) is really dependent on the individual design of the application. In the <span class="emphasis"><em>The bridge pattern</em></span> section of this chapter, we were able to say that the majority of the time structures would be preferred; however, in this pattern, we really cannot say that either type is preferred the majority of the time.</p></div></div><p>Now, let's look at our last structural pattern, which is the proxy design pattern.</p></div><div class="section" title="The proxy design pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec159"/>The proxy design pattern</h2></div></div></div><p>In the<a class="indexterm" id="id825"/> proxy design pattern, there is one object acting as an interface for other objects. This wrapper class, which is the proxy, can then add functionality to the object, make the object available over a network, or restrict access to the object.</p><p>In this section, we will demonstrate the proxy pattern by creating a house class that we can add multiple floor plans to, where each floor plan represents a different story of the house. Let's begin by creating a <code class="literal">FloorPlanProtocol</code> protocol:</p><div class="informalexample"><pre class="programlisting">protocol FloorPlanProtocol {
  var bedRooms: Int {get set}
  var utilityRooms: Int {get set}
  var bathRooms: Int {get set}
  var kitchen: Int {get set}
  var livingRooms: Int {get set}
}</pre></div><p>In <code class="literal">FloorPlanProtocol</code>, we define five properties that will represent the number of rooms contained in each floor plan. Now, let's create an implementation of the <code class="literal">FloorPlanProtocol</code> protocol named <code class="literal">FloorPlan</code>, which is as follows:</p><div class="informalexample"><pre class="programlisting">struct FloorPlan: FloorPlanProtocol {
  var bedRooms = 0
  var utilityRooms = 0
  var bathRooms = 0
  var kitchen = 0
  var livingRooms = 0
}</pre></div><p>The <code class="literal">FloorPlan</code> class implements all the five properties required from <code class="literal">FloorPlanProtocol</code> and assigns default values to them. Next, we will create the <code class="literal">House</code> class, which will represent a house:</p><div class="informalexample"><pre class="programlisting">class House {
  private var stories = [FloorPlanProtocol]()
  
  func addStory(floorPlan: FloorPlanProtocol) {
    stories.append(floorPlan)
  }
}</pre></div><p>Within<a class="indexterm" id="id826"/> our <code class="literal">House</code> class, we have an array of the <code class="literal">FloorPlanProtocols</code> objects where each floor plan will represent one story of the house. We also have one function named <code class="literal">addStory()</code>, which accepts an instance of an object that conforms to the <code class="literal">FloorPlanProtocol</code> protocol. This function will add the floor plan to the array of the <code class="literal">FloorPlanProtocols</code> protocols.</p><p>If we think about the logic of this class, there is one problem that we might encounter. The problem is that we are allowed to add as many floor plans as we want, which may lead to houses that are 60 or 70 stories high. This would be great if we were building skyscrapers, but we just want to build basic single-family houses. If we want to limit the number of floor plans without changing the <code class="literal">House</code> class (either we cannot change it or we simply do not want to), we can implement the proxy pattern. The following example shows how to implement the <code class="literal">HouseProxy</code> class, where we limit the number of floor plans we can add to the house, which is as follows;</p><div class="informalexample"><pre class="programlisting">class HouseProxy {
 var house = House()

  func addStory(floorPlan: FloorPlanProtocol) -&gt; Bool {
    if house.stories.count &lt; 3 {
      house.addStory(floorPlan)
      return true
    }
    else {
      return false
    }
  }
}</pre></div><p>We begin the <code class="literal">HouseProxy</code> class by creating an instance of the <code class="literal">House</code> class. We then create a method named <code class="literal">addStory()</code> that lets us add a new floor plan to the house. In the <code class="literal">addStory()</code> method, we check whether the number of stories in the house is less than three, and if so, we add the floor plan to the house and return <code class="literal">true</code>. If the number of stories is equal to or greater than three, then we do not add the floor plan to the house and return <code class="literal">false</code>. Let's <a class="indexterm" id="id827"/>see how we use this proxy:</p><div class="informalexample"><pre class="programlisting">var ourHouse = HouseProxy()

var basement = FloorPlan(bedRooms: 0, utilityRooms: 1, bathRooms: 1, kitchen: 0, livingRooms: 1)
var firstStory = FloorPlan(bedRooms: 1, utilityRooms: 0, bathRooms: 2, kitchen: 1, livingRooms: 1)
var secondStory = FloorPlan(bedRooms: 2, utilityRooms: 0, bathRooms: 1, kitchen: 0, livingRooms: 1)
var additionalStory = FloorPlan(bedRooms: 1, utilityRooms: 0, bathRooms: 1, kitchen: 1, livingRooms: 1)

print(ourHouse.addStory(basement))
print(ourHouse.addStory(firstStory))
print(ourHouse.addStory(secondStory))
print(ourHouse.addStory(additionalStory))</pre></div><p>In our example code, we start off by creating an instance of the <code class="literal">HouseProxy</code> class named <code class="literal">ourHouse</code>. We then create four instances of the <code class="literal">FloorPlan</code> class, each with a different number of rooms. Finally, we attempt to add each of the floor plans to the <code class="literal">ourHouse</code> instance. If we then run the code, we see that the first three instances of the <code class="literal">FloorPlan</code> class were added to the house successfully, but the last one wasn't because we are only allowed to add three floors.</p><p>The proxy pattern is very useful when we want to add some additional functionality or error-checking to a class, but we do not want to change the actual class itself.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>For the proxy pattern, we chose to use a class to implement the pattern because normally, we would not want to make copies of the type we are proxying. Instead, we would normally want to maintain the changes made to the instance. This is kind of the reverse of the bridge pattern where, in my experience, the structure would be preferred the majority of the time.</p></div></div><p>Now, let's look at the behavioral design patterns.</p></div></div>
<div class="section" title="Behavioral design patterns"><div class="titlepage"><div><div><h1 class="title"><a id="ch17lvl1sec105"/>Behavioral design patterns</h1></div></div></div><p>Behavioral<a class="indexterm" id="id828"/> design patterns explain how objects interact with each other. These patterns describe how different objects send messages to each other to make things happen.</p><p>There are nine well-known patterns that are part of the structural design pattern type:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Chain of responsibility</strong></span>: This is used to process a variety of requests, each of which <a class="indexterm" id="id829"/>may be delegated to a different handler.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Command</strong></span>: This creates objects that can encapsulate actions or parameters so that they<a class="indexterm" id="id830"/> can be invoked later or by<a class="indexterm" id="id831"/> a different component.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Iterator</strong></span>: This<a class="indexterm" id="id832"/> allows us to access the elements of an object sequentially without exposing the underlying structure.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mediator</strong></span>: This<a class="indexterm" id="id833"/> is used to reduce coupling between classes that communicate with each other.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Memento</strong></span>: This<a class="indexterm" id="id834"/> is used to capture the current state of an object and store it in a manner that can be restored later.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Observer</strong></span>: This <a class="indexterm" id="id835"/>allows an object to publish changes to its state. Other objects can then subscribe so that they can be notified of any changes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>State</strong></span>: This is <a class="indexterm" id="id836"/>used to alter the behavior of an object when its internal state changes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Strategy</strong></span>: This<a class="indexterm" id="id837"/> allows one out of a family of algorithms to be chosen at runtime.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Visitor</strong></span>: This <a class="indexterm" id="id838"/>is a way of separating an algorithm from an object structure.</li></ul></div><p>In this section, we are going to give examples of how to use strategy and command patterns in Swift. Let's start off by looking at the command pattern.</p><div class="section" title="The command design pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec160"/>The command design pattern</h2></div></div></div><p>The <a class="indexterm" id="id839"/>command design pattern lets us define actions that we can execute later. This pattern generally encapsulates all the information needed to call or trigger the actions at a later time.</p><p>In this section, we will demonstrate how to use the command pattern by creating a <code class="literal">Light</code> class. In this example, we will define two commands—<code class="literal">lightOnCommand</code> and <code class="literal">lightOffCommand</code>. We will then use the <code class="literal">turnOnLight()</code> and <code class="literal">turnOffLight()</code> methods to call the commands.</p><p>We will begin by creating a protocol named <code class="literal">Command</code> that all of our commands will need to conform to. Here is the <code class="literal">Command</code> protocol:</p><div class="informalexample"><pre class="programlisting">protocol Command {
  func execute()
}</pre></div><p>This protocol contains one method named <code class="literal">execute</code>, which will be used to execute the command. Now, let's look at our <code class="literal">LightOneCommand</code> and <code class="literal">LightOffCommand</code> classes that the <code class="literal">Light</code> class <a class="indexterm" id="id840"/>will use to turn the light on and off. They are as follows:</p><div class="informalexample"><pre class="programlisting">struct RockerSwitchLightOnCommand: Command {
  func execute() {
    print("Rocker Switch:  Turning Light On")
  }
}

struct RockerSwitchLightOffCommand: Command {
  func execute() {
    print("Rocker Switch:  Turning Light Off")
  }
}
struct PullSwitchLightOnCommand: Command {
  func execute() {
    print("Pull Switch:  Turning Light On")
  }
}

struct PullSwitchLightOffCommand: Command {
  func execute() {
    print("Pull Switch:  Turning Light Off")
  }
}</pre></div><p>The <code class="literal">RockerSwitchLightOffCommand</code>, <code class="literal">RockerSwitchLightOnCommand</code>, <code class="literal">PullSwitchLightOnCommand</code>, and <code class="literal">PullSwitchLightOffCommand</code> commands conform to the <code class="literal">Command</code> protocol by implementing the <code class="literal">execute()</code> method, so we will be able to use them in our <code class="literal">Light</code> class. Now, let's look at how to implement the <code class="literal">Light</code> class:</p><div class="informalexample"><pre class="programlisting">class Light {
  var lightOnCommand: Command
  var lightOffCommand: Command
  
  init(lightOnCommand: Command, lightOffCommand: Command) {
    self.lightOnCommand = lightOnCommand
    self.lightOffCommand = lightOffCommand
  }
  
  func turnOnLight() {
    self.lightOnCommand.execute()
  }
  
  func turnOffLight() {
    self.lightOffCommand.execute()
  }
}</pre></div><p>In the <code class="literal">Light</code> class, we start off by creating two variables named <code class="literal">lightOnCommand</code> and <code class="literal">lightOffCommand</code>, which hold instances of classes that conform to the <code class="literal">Command</code> protocol. We <a class="indexterm" id="id841"/>then create an initiator that lets us set both of the commands when we initiate the class. Finally, we create the <code class="literal">turnOnLight()</code> and <code class="literal">turnOffLight()</code> methods that we will use to turn the light on and off. In these methods, we call the appropriate command to turn the light on or off.</p><p>We would then use the <code class="literal">Light</code> class like this:</p><div class="informalexample"><pre class="programlisting">var on = PullSwitchLightOnCommand()
var off = PullSwitchLightOffCommand()
var light = Light(lightOnCommand: on, lightOffCommand: off)

light.turnOnLight()
light.turnOffLight()

light.lightOnCommand = RockerSwitchLightOnCommand()
light.turnOnLight()</pre></div><p>In this example, we begin by creating an instance of the <code class="literal">PullSwitchLightOnCommand</code> class named <code class="literal">on</code> and an instance of the <code class="literal">PullSwitchLightOffCommand</code> class named <code class="literal">off</code>. We then create an instance of the <code class="literal">Light</code> class using the two commands that we just created and call the <code class="literal">turnOnLight()</code> and <code class="literal">turnOffLight()</code> methods of the <code class="literal">Light</code> instance to turn our light on and off. In the last two lines, we changed the <code class="literal">lightOnCommand</code> method, which was originally set to an instance of the <code class="literal">PullSwitchLightOnCommand</code> class to an instance of the <code class="literal">RockerSwitchLightOnCommand</code> class. The <code class="literal">light</code> instance will now use the <code class="literal">RockerSwitchLightOnCommand</code> class whenever we turn the light on. This allows us to change the functionality of the <code class="literal">Light</code> class during runtime.</p><p>There are a number of benefits of using the command pattern. One of the main benefits is that we are able to set the implementation of the commands at runtime, which also lets us swap the commands out with different implementations that conform to the <code class="literal">Command</code> protocol, as needed throughout the life of the application. Another advantage of the command pattern is that we encapsulate the details of the command implementations within the command classes themselves rather than in the container class.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>For the command pattern, we used structures to implement our command types because it is very easy to create one instance of a command type and then use it to create multiple instances of the <code class="literal">Light</code> class. In that case, if one <code class="literal">Light</code> class changed anything in the command instance, it would then be reflexed in all the instances of the <code class="literal">Light</code> class that used that command instance. Generally, this is not the behavior we want; however, if that is the behavior your application needs, then you should use a class rather than a structure.</p></div></div><p>Now, let's<a class="indexterm" id="id842"/> look at our last design pattern, which is the strategy pattern.</p></div><div class="section" title="The strategy pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch17lvl2sec161"/>The strategy pattern</h2></div></div></div><p>The strategy<a class="indexterm" id="id843"/> pattern is pretty similar to the command pattern in the fact that they both allow us to decouple implementation details from our calling class and also allow us to switch the implementation out at runtime. The big difference is, the strategy pattern is intended to encapsulate algorithms. By swapping out an algorithm, we are expecting the object to perform the same functionality but in a different way. In the command pattern, when we swap out the commands, we are expecting the object to function differently.</p><p>In this section, we will demonstrate the strategy pattern by showing you how we could swap out compression strategies at runtime. Let's begin this example by creating a <code class="literal">CompressionStrategy</code> protocol that each one of our compression classes will conform to. Let's take a look at the following code:</p><div class="informalexample"><pre class="programlisting">protocol CompressionStrategy {
  func compressFiles(filePaths: [String])
}</pre></div><p>This protocol defines one method named <code class="literal">compressFiles()</code> that accepts a single parameter, which is an array of strings that contain the paths of the files to compress. We will now create two structures that conform to the <code class="literal">CompressionStrategy</code> protocol. These classes are the <code class="literal">ZipCompressionStrategy</code> and <code class="literal">RarCompressionStrategy</code> classes, which are as follows:</p><div class="informalexample"><pre class="programlisting">struct ZipCompressionStrategy: CompressionStrategy {
  func compressFiles(filePaths: [String]) {
    print("Using Zip Compression")
  }
}

struct RarCompressionStrategy: CompressionStrategy {
  func compressFiles(filePaths: [String]) {
    print("Using RAR Compression")
  }
}</pre></div><p>Both of these structures implement the <code class="literal">CompressionStrategy</code> protocol by having a method named <code class="literal">compressFiles()</code>, which accepts an array of strings. Within these methods, we simply print out the name of the compression that we are using. Normally, we would <a class="indexterm" id="id844"/>implement the compression logic in these methods.</p><p>Now, let's look at our <code class="literal">CompressContent</code> class that will be called to compress the files:</p><div class="informalexample"><pre class="programlisting">class CompressContent {
  var strategy: CompressionStrategy
  
  init(strategy: CompressionStrategy) {
    self.strategy = strategy
  }
  
  func compressFiles(filePaths: [String]) {
    self.strategy.compressFiles(filePaths)
  }
}</pre></div><p>In this class, we start off by defining a variable named <code class="literal">strategy</code> that will contain an instance of a class that conforms to the <code class="literal">CompressStrategy</code> protocol. We then create an initiator that will be used to set the compression type when the class is initiated. Finally, we create a method named <code class="literal">compressFiles()</code> that accepts an array of strings that contain the paths to the list of files that we wish to compress. In this method, we compress the files using the compression strategy that is set in the strategy variable.</p><p>We will use the <code class="literal">CompressContent</code> class like this:</p><div class="informalexample"><pre class="programlisting">var filePaths = ["file1.txt", "file2.txt"]
var zip = ZipCompressionStrategy()
var rar = RarCompressionStrategy()

var compress = CompressContent(strategy: zip)
compress.compressFiles(filePaths)

compress.strategy = rar
compress.compressFiles(filePaths)</pre></div><p>We begin by creating an array of strings that contain the files we wish to compress. We also create an instance of both the <code class="literal">ZipCompressionStrategy</code> and <code class="literal">RarCompressionStrategy</code> classes. We then create an instance of the <code class="literal">CompressContent</code> class, setting the compression strategy to the <code class="literal">ZipCompressionStrategy</code> instance and call the <code class="literal">compressFiles()</code> method, which will print the <code class="literal">Using zip compression</code> message to the console. We then set the compression strategy to the <code class="literal">RarCompressionStrategy</code> instance and call the <code class="literal">compressFiles()</code> method again, which will print the <code class="literal">Using rar compression</code> message to the console.</p><p>The strategy pattern is really good for setting the algorithms to use at runtime, which also lets us swap the algorithms out with different implementations as needed by the application. Another advantage of the strategy pattern is, we encapsulate the details of the algorithm <a class="indexterm" id="id845"/>within the strategy classes themselves and not in the main implementation class.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Just like the command pattern, we used structures to implement the strategy pattern because it is very easy to create one instance of a strategy type and then use it to create multiple instances of the <code class="literal">CompressContent</code> class. In this case, if anything is changed in the strategy instance, it would be reflexed in all of the <code class="literal">CompressContent</code> types. Generally, this is not the behavior we want; however, if that is the behavior your application needs, then you should use a class rather than a structure.</p></div></div><p>This concludes our tour of design patterns in Swift.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch17lvl1sec106"/>Summary</h1></div></div></div><p>Design patterns are solutions to software design problems that we tend to see over and over again in real-world application designs. These patterns are designed to help us create reusable and flexible code. Design patterns can also make our code easier to read and understand for other developers and also for ourselves when we look back at out code months/years later.</p><p>If we looked at the examples in the chapter carefully, we would notice that one of the backbones of design patterns is protocols. Almost all the design patterns (the singleton design pattern is an exception) use protocols to help us create very flexible and reusable code.</p><p>If this was the first time that you really looked at design patterns, you probably noticed some similarities to strategies that you may have used in the past in your own code. This is expected when experienced developers are first introduced to design patterns. I would also encourage you to read about design patterns more because they will definitely help you to create more flexible and reusable code.</p></div></body></html>