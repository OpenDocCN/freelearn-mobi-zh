<html><head></head><body>
  <div><h1 class="chapterNumber">3</h1>
    <h1 id="_idParaDest-43" class="chapterTitle">Learning about Variables, Constants, Strings, and Operators</h1>
    <p class="normal">The first program I ever wrote was written in BASIC and was the typical Hello World application. This application was exciting at first, but the excitement of printing static text wore off pretty quickly. For my second application, I used BASIC's input command to ask the user for a name and then printed out a custom "hello" message with the name they entered. At the age of 12, it was pretty cool to display <code class="Code-In-Text--PACKT-">Hello Han Solo</code>. This application led me to create numerous Mad Libs-style applications that prompted the user for various words, and then put those words into a story that was displayed after the user had entered all the required words. These applications introduced me to, and taught me, the importance of variables. Every useful application I've created since then has used variables.</p>
    <p class="normal">In this chapter, we will cover the following topics:</p>
    <ul>
      <li class="bullet">What are variables and constants?</li>
      <li class="bullet">What is the difference between explicit and inferred typing?</li>
      <li class="bullet">What are numeric, string, and Boolean types?</li>
      <li class="bullet">Explaining how enumerations work in Swift </li>
      <li class="bullet">Explaining how Swift's operators work</li>
    </ul>
    <p class="normal">We recognize that Swift is becoming very popular on platforms outside of the Apple eco-system. Therefore, starting with this chapter, in the downloadable code samples, we will be including both a Swift playground and a <code class="Code-In-Text--PACKT-">.swift</code> code file for all the sample code. This will enable you to easily try the samples on whichever platform you wish. This is a new feature starting with the <em class="italic">Mastering Swift 5.3</em>, <em class="italic">Sixth Edition</em> book. Let's start our tour of the Swift language by understanding what constants and variables are.</p>
    <h1 id="_idParaDest-44" class="title">Constants and variables</h1>
    <p class="normal">Constants and variables associate an identifier (such as <code class="Code-In-Text--PACKT-">myName</code> or <code class="Code-In-Text--PACKT-">currentTemperature</code>) with a <a id="_idIndexMarker085"/>value of a particular type (such as the <code class="Code-In-Text--PACKT-">String</code> or <code class="Code-In-Text--PACKT-">Integer</code> type), where the identifier can be used to retrieve the value. The difference between a constant and <a id="_idIndexMarker086"/>a variable is that a variable can be updated or changed, while a constant cannot be changed once a value is assigned to it.</p>
    <p class="normal">Constants are good for defining values that you know will never change, like the temperature that water freezes at or the speed of light. Constants are also good for defining a value that we use many times throughout our application, such as a standard font size or the maximum number of characters in a buffer. There will be numerous examples of constants throughout this book, and it is recommended that we use constants rather than variables whenever possible.</p>
    <p class="normal">Variables tend to be more common in software development than constants. This is mainly because developers tend to prefer variables over constants. In Swift, the compiler will warn us if we declare a variable whose value never changes. We can make useful applications without using constants (although it is good practice to use them); however, it is almost impossible to create a useful application without variables.</p>
    <div><p class="Information-Box--PACKT-">The use of constants is encouraged in Swift. If we do not expect or want a value to change, we should declare it as a constant. This adds a very important safety constraint to our code that ensures that the value never changes.</p>
    </div>
    <p class="normal">You can use almost any character in the naming/identifier of a variable or constant (even Unicode characters); however, there are a few rules that you must follow:</p>
    <ul>
      <li class="bullet">An identifier must not contain any whitespace.</li>
      <li class="bullet">It must not contain any mathematical symbols or arrows.</li>
      <li class="bullet">An identifier must not contain private-use or invalid Unicode characters.</li>
      <li class="bullet">It must not contain line or box-drawing characters.</li>
      <li class="bullet">It must not start with a number, but it can contain numbers.</li>
      <li class="bullet">Using a Swift keyword as an identifier is strongly discouraged but if you do, surround it with backticks.</li>
    </ul>
    <p class="normal">Keywords are words that are used by the Swift programming language. Some examples of keywords <a id="_idIndexMarker087"/>that you will see in this chapter are <code class="Code-In-Text--PACKT-">var</code> and <code class="Code-In-Text--PACKT-">let</code>. You should <a id="_idIndexMarker088"/>avoid using Swift keywords as identifiers to avoid confusion when reading your code.</p>
    <h2 id="_idParaDest-45" class="title">Defining constants and variables</h2>
    <p class="normal">Constants <a id="_idIndexMarker089"/>and variables must be defined prior to using them. To define <a id="_idIndexMarker090"/>a constant, you use the <code class="Code-In-Text--PACKT-">let</code> keyword, and to define a variable, you use the <code class="Code-In-Text--PACKT-">var</code> keyword. The following code shows how to define both constants and variables:</p>
    <pre class="programlisting code"><code class="hljs-code">// Constants
let freezingTemperatureOfWaterCelsius = 0
let speedOfLightKmSec = 300000
// Variables
var currentTemperature = 22
var currentSpeed = 55
</code></pre>
    <p class="normal">We can declare multiple constants or variables in a single line by separating them with a comma. For example, we could shrink the preceding four lines of code down to two lines, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">// Constants
let freezingTemperatureOfWaterCelsius = 0, speedOfLightKmSec = 300000
// Variables
var currentTemperature = 22, currentSpeed = 55
</code></pre>
    <p class="normal">We can change the value of a variable to another value of a compatible type; however, as we noted earlier, we cannot change the value of a constant. Let's look at the following playground. Can you tell what is wrong with the code from the error message?</p>
    <figure class="mediaobject"><img src="img/B16683_03_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 3.1: Error thrown as a constant cannot be changed</p>
    <p class="normal">Did you figure out what was wrong with the code? Any physicist can tell you that we cannot change <a id="_idIndexMarker091"/>the speed of light, and in our code, <code class="Code-In-Text--PACKT-">speedOfLightKmSec</code> is a constant, so we cannot change it here either. When we attempted <a id="_idIndexMarker092"/>to change the <code class="Code-In-Text--PACKT-">speedOfLightKmSec</code> constant, an error was thrown. We can change the value of <code class="Code-In-Text--PACKT-">highTemperature</code> without an error because it is a variable. We have mentioned the difference between variables and constants a couple of times because it is a very important concept to grasp, especially when we move on to define mutable and immutable collection types in <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Swift Collections</em>.</p>
    <div><p class="Information-Box--PACKT-">When something is mutable, that means we are able to change it, and when we say something is immutable, that means we are unable to change it.</p>
    </div>
    <h2 id="_idParaDest-46" class="title">Type safety</h2>
    <p class="normal">Swift is a <a id="_idIndexMarker093"/>type-safe language, which means we are required to define the types of the values we are going to store in a variable. We will get an error if we attempt to assign a value to a variable that is of the wrong type. The following playground shows what happens if we attempt to put a string value into a variable that expects integer values:</p>
    <div><p class="Information-Box--PACKT-">We will go over the most popular types later in this chapter.</p>
    </div>
    <figure class="mediaobject"><img src="img/B16683_03_02.png" alt="A screenshot of a computer screen  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.2: Type-safety error in a Swift playground</p>
    <p class="normal">Swift performs <a id="_idIndexMarker094"/>a type check when it compiles code, and so it will flag any mismatched types with an error. The error message in this playground explains quite clearly that we are trying to insert a string value into an integer variable.</p>
    <p class="normal">How does Swift know that the constant <code class="Code-In-Text--PACKT-">integerVar</code> is of the integer type? Swift uses type inference to figure out the appropriate type. Let's look at what type inference is.</p>
    <h2 id="_idParaDest-47" class="title">Type inference</h2>
    <p class="normal">Type inference <a id="_idIndexMarker095"/>allows us to omit the variable type when the variable is defined with an initial value. The compiler will infer the type based on that initial value. For example, in Objective-C, we would define an integer like this:</p>
    <pre class="programlisting code"><code class="hljs-code">int myInt = 1
</code></pre>
    <p class="normal">This tells the compiler that the <code class="Code-In-Text--PACKT-">myInt</code> variable is of the <code class="Code-In-Text--PACKT-">Int</code> type, and that the initial value is the number <code class="Code-In-Text--PACKT-">1</code>. In Swift, we would define the same integer as this:</p>
    <pre class="programlisting code"><code class="hljs-code">var myInt = 1
</code></pre>
    <p class="normal">Swift infers that the variable type is an integer because the initial value is an integer. Let's look at a couple more examples:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = 3.14  // Double type
var y = "Hello"  // String type
var z = true   // Boolean type
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker096"/>preceding example, the compiler will correctly infer that variable <code class="Code-In-Text--PACKT-">x</code> is a <code class="Code-In-Text--PACKT-">Double</code>, variable <code class="Code-In-Text--PACKT-">y</code> is a <code class="Code-In-Text--PACKT-">String</code>, and variable <code class="Code-In-Text--PACKT-">z</code> is a <code class="Code-In-Text--PACKT-">Boolean</code>, based on their initial values. We are able to explicitly define a variable type. However, it is recommended that we only do this if we are not assigning an initial value to a variable.</p>
    <h2 id="_idParaDest-48" class="title">Explicit types</h2>
    <p class="normal">Type inference <a id="_idIndexMarker097"/>is a very nice feature in Swift and is one that you will probably get used to very quickly. However, there are times when we would like to explicitly define a variable's type. For example, in the preceding example, the variable <code class="Code-In-Text--PACKT-">x</code> is inferred to be <code class="Code-In-Text--PACKT-">Double</code>, but what if we wanted the variable type to be <code class="Code-In-Text--PACKT-">Float</code>? We can explicitly define a variable type like this:</p>
    <pre class="programlisting code"><code class="hljs-code">var x:Float = 3.14
</code></pre>
    <p class="normal">Notice the <code class="Code-In-Text--PACKT-">Float</code> declaration (the colon and the word <code class="Code-In-Text--PACKT-">Float</code>) after the variable identifier. This tells the compiler to define this variable to be of the <code class="Code-In-Text--PACKT-">Float</code> type and gives it an initial value of <code class="Code-In-Text--PACKT-">3.14</code>. When we define a variable in this manner, we need to make sure that the initial value is the same type as what we defined the variable to be. If we try to give a variable an initial value that is a different type than what we defined the variable as, then we receive an error. As an example, the following line will throw an error because we are explicitly defining the variable to be that of the <code class="Code-In-Text--PACKT-">Float</code> type, while we are trying to put a <code class="Code-In-Text--PACKT-">String</code> value in it:</p>
    <pre class="programlisting code"><code class="hljs-code">var x: Float = "My str"
</code></pre>
    <p class="normal">We will need to explicitly define the variable type if we are not setting an initial value. For example, the following line of code is invalid because the compiler does not know what type to set the variable <code class="Code-In-Text--PACKT-">x</code> to:</p>
    <pre class="programlisting code"><code class="hljs-code">var x
</code></pre>
    <p class="normal">If we use this code in our application, we will receive a <strong class="keyword">Type annotation missing in pattern</strong> error. If we are not setting an initial value for a variable, we are required to define the variable type, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">var x: Int
</code></pre>
    <p class="normal">Now that <a id="_idIndexMarker098"/>we have seen how to explicitly define a variable type, let's look at some of the most commonly used types.</p>
    <h1 id="_idParaDest-49" class="title">Numeric types</h1>
    <p class="normal">Swift contains <a id="_idIndexMarker099"/>many of the standard numeric types that are suitable for storing various integer and floating-point values. Let's start by looking at the integer type.</p>
    <h2 id="_idParaDest-50" class="title">Integer types</h2>
    <p class="normal">An integer is a <a id="_idIndexMarker100"/>whole number and can be either signed (positive, negative, or zero) or unsigned (positive or zero). Swift provides several <strong class="keyword">Integer</strong> types <a id="_idIndexMarker101"/>of different sizes. <em class="italic">Table 3.1</em> shows the value ranges for the different integer types on a 64-bit system:</p>
    <table id="table001-1" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Type</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Minimum</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Maximum</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Int8</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">-128</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">127</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Int16</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">-32,768</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">32,767</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Int32</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">-2,147,483,648</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">2,147,483,647</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Int64</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">- 9,223,372,036,854,775,808</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">9,223,372,036,854,775,807</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">Int</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">- 9,223,372,036,854,775,808</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">9,223,372,036,854,775,807</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">UInt8</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">255</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">UInt16</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">65,535</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">UInt32</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">4,294,967,295</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">UInt64</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">18,446,744,073,709,551,615</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-"><code class="Code-In-Text--PACKT-">UInt</code></p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">18,446,744,073,709,551,615</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.1: Different Integer types available on Swift</p>
    <p class="normal">You may notice from the chart that unsigned integers begin with a U (<code class="Code-In-Text--PACKT-">UInt</code>, <code class="Code-In-Text--PACKT-">UInt8</code>â€¦), while signed integers do not (<code class="Code-In-Text--PACKT-">Int</code>, <code class="Code-In-Text--PACKT-">Int8</code>). </p>
    <p class="normal">Unless there is a specific reason to define the size of an integer, I would recommend using the standard <code class="Code-In-Text--PACKT-">Int</code> or <code class="Code-In-Text--PACKT-">UInt</code> types. This will save you from needing to convert between different types of integers later.</p>
    <p class="normal">In Swift, the <code class="Code-In-Text--PACKT-">Integer</code> type and other numerical types are actually named types and are implemented in the Swift standard library using structures. This gives us a consistent mechanism for the<a id="_idIndexMarker102"/> memory management of all the data types, as well as properties that we can access. For the preceding chart, I retrieved the minimum and maximum <a id="_idIndexMarker103"/>values of each <code class="Code-In-Text--PACKT-">Integer</code> type using the <code class="Code-In-Text--PACKT-">min</code> and <code class="Code-In-Text--PACKT-">max</code> properties of the <code class="Code-In-Text--PACKT-">Integer</code> types. Look at the following playground to see how these values were retrieved:</p>
    <figure class="mediaobject"><img src="img/B16683_03_03.png" alt="A screenshot of a computer  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.3: Ranges of different numerical types</p>
    <p class="normal">Integers can also be represented as binary, octal, and hexadecimal numbers. We just need to add a prefix to the number to tell the compiler which base the number should be in. The <a id="_idIndexMarker104"/>prefix takes the form of a zero, followed by the base specifier. <em class="italic">Table 3.2</em> shows the prefix for each numerical base:</p>
    <table id="table002" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
      </colgroup>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Base</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Prefix</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Decimal</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">None</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Binary</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0b</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Octal</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0o</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Hexadecimal</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">0x</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 3.2: Prefixes for each numerical base</p>
    <p class="normal">The following <a id="_idIndexMarker105"/>playground shows how the number 95 is represented in each of the numerical bases:</p>
    <figure class="mediaobject"><img src="img/B16683_03_04.png" alt="A screenshot of a computer screen  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.4: Defining values with different numerical bases</p>
    <p class="Layout-Information--PACKT-">Swift also allows us to insert arbitrary underscores in our numeric literals. This can improve the readability of our code without changing the underlying value. As an example, if we were defining the speed of light, which is constant, we could define it like this:</p>
    <pre class="programlisting code"><code class="hljs-code">let speedOfLightKmSec = 300_000
</code></pre>
    <p class="normal">The Swift compiler will ignore these underscores and interpret this value as if the underscores were not there.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Integer</code> type in Swift has a method named <code class="Code-In-Text--PACKT-">isMultiple(of:)</code>, which can be very useful. This method <a id="_idIndexMarker106"/>allows us to check if one number is the multiple <a id="_idIndexMarker107"/>of another number. Prior to this method, we would have used the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">let number = 4
if number % 2 == 0 { 
    print("Even")
} else {
    print("Odd")
}
</code></pre>
    <p class="normal">Now, we can use the <code class="Code-In-Text--PACKT-">isMultiple(of:)</code> method like this:</p>
    <pre class="programlisting code"><code class="hljs-code">let number = 4
if number.isMultiple(of: 2) { 
    print("Even")
} else {
    print("Odd")
}
</code></pre>
    <p class="normal">While this new method really doesn't eliminate a lot of code, it does make our code much easier to read and understand. Now, let's look at floating-point and <code class="Code-In-Text--PACKT-">Double</code> types.</p>
    <h2 id="_idParaDest-51" class="title">Floating-point and Double values</h2>
    <p class="normal">A floating-point <a id="_idIndexMarker108"/>number is a number with a decimal <a id="_idIndexMarker109"/>component. There are two standard floating-point types <a id="_idIndexMarker110"/>in Swift: <code class="Code-In-Text--PACKT-">Float</code> and <code class="Code-In-Text--PACKT-">Double</code>. The <code class="Code-In-Text--PACKT-">Float</code> type represents <a id="_idIndexMarker111"/>a 32-bit floating-point number, while the <code class="Code-In-Text--PACKT-">Double</code> type represents a 64-bit floating-point number. While the <code class="Code-In-Text--PACKT-">Float</code> type is a 32-bit floating-point number, Swift actually supports four floating-point types. These are <code class="Code-In-Text--PACKT-">Float16</code>, <code class="Code-In-Text--PACKT-">Float32</code>, <code class="Code-In-Text--PACKT-">Float64</code>, and <code class="Code-In-Text--PACKT-">Float80</code>. Remember, when the <code class="Code-In-Text--PACKT-">Float</code> type is used, it is a 32-bit floating-point number; if you want to use the other precisions, you will need to define it.</p>
    <p class="normal">Swift 5.3, with Swift Evolution SE-0277, added the <code class="Code-In-Text--PACKT-">Float16</code> type to the Swift language because it is commonly used in graphics programming and also machine learning.</p>
    <p class="normal">It is recommended that we use the <code class="Code-In-Text--PACKT-">Double</code> type over the <code class="Code-In-Text--PACKT-">Float</code> type unless there is a specific reason to use the latter. The <code class="Code-In-Text--PACKT-">Double</code> type has a precision of at least 15 decimal digits, while the <code class="Code-In-Text--PACKT-">Float</code> type's precision can be as small as six decimal digits. Let's look at an example <a id="_idIndexMarker112"/>of how this can affect our application without us knowing. <em class="italic">Figure 3.5</em> shows <a id="_idIndexMarker113"/>the results of what happens <a id="_idIndexMarker114"/>if we add two decimal numbers together <a id="_idIndexMarker115"/>using both a <code class="Code-In-Text--PACKT-">Float</code> type and a <code class="Code-In-Text--PACKT-">Double</code> type:</p>
    <figure class="mediaobject"><img src="img/B16683_03_05.png" alt="A screenshot of a computer screen  Description automatically generated"/><a id="_idIndexMarker116"/><a id="_idIndexMarker117"/><a id="_idIndexMarker118"/></figure>
    <p class="packt_figref">Figure 3.5: Calculations in Float and Double</p>
    <p class="normal">As we can see from the preceding screenshot, the first two decimal numbers that we are adding contain nine digits past the decimal point; however, the results in the <code class="Code-In-Text--PACKT-">Float</code> type only contain seven digits, while the results in the <code class="Code-In-Text--PACKT-">Double</code> type contain the full nine digits. This loss of precision can cause issues if we are working with currency or other numbers that need accurate calculations, as we can see when we compare the results in the second set of numbers.</p>
    <p class="normal">Note that when you use type inference for a decimal number, Swift will default to a <code class="Code-In-Text--PACKT-">Double</code> type rather than a <code class="Code-In-Text--PACKT-">Float</code> type.</p>
    <p class="normal">What if we have two variables, where one is an integer and the other is a double? Do you think we can add them as the following code shows?</p>
    <pre class="programlisting code"><code class="hljs-code">var a: Int = 3
var b: Double = 0.14
var c = a + b
</code></pre>
    <p class="normal">If we put the preceding code into a playground, we would receive the following error:</p>
    <pre class="programlisting con"><code class="hljs-con">operator '+' cannot be applied to operands of type Int and Double
</code></pre>
    <p class="normal">This error <a id="_idIndexMarker119"/>lets us know that we are trying to add two different types of numbers, which <a id="_idIndexMarker120"/>is not allowed. To add an <code class="Code-In-Text--PACKT-">Int</code> and a <code class="Code-In-Text--PACKT-">Double</code> type <a id="_idIndexMarker121"/>together, we need to convert the integer <a id="_idIndexMarker122"/>value into a double value. The following code shows how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">var a: Int = 3
var b: Double = 0.14
var c = Double(a) + b
</code></pre>
    <p class="normal">Notice how we use the <code class="Code-In-Text--PACKT-">Double()</code> function to initialize a <code class="Code-In-Text--PACKT-">Double</code> value with the <code class="Code-In-Text--PACKT-">Int</code> value. All numeric types in Swift have an initializer to do these types of conversion. These <a id="_idIndexMarker123"/>initializers are called <strong class="keyword">convenience initializers</strong>, similar to the <code class="Code-In-Text--PACKT-">Double()</code> function shown in the preceding code sample. For example, the following code shows how you can initialize a <code class="Code-In-Text--PACKT-">Float</code> or <code class="Code-In-Text--PACKT-">uint16</code> value with an integer value:</p>
    <pre class="programlisting code"><code class="hljs-code">var intVar = 32
var floatVar = Float(intVar)
var uint16Var = UInt16(intVar)
</code></pre>
    <p class="normal">Generally, when we are adding two different types together, we will want to convert the number with the least floating-point precision, like an integer or float, to the type with the highest precision, like a double.</p>
    <h1 id="_idParaDest-52" class="title">The Boolean type</h1>
    <p class="normal"><strong class="keyword">Boolean</strong> values are often referred to as logical values because they can be either <code class="Code-In-Text--PACKT-">true</code> or <code class="Code-In-Text--PACKT-">false</code>. Swift <a id="_idIndexMarker124"/>has a built-in <code class="Code-In-Text--PACKT-">Boolean</code> type that accepts one of the two built-in Boolean constants: <code class="Code-In-Text--PACKT-">true</code> and <code class="Code-In-Text--PACKT-">false</code>.</p>
    <p class="normal">Boolean constants and variables can be defined like this:</p>
    <pre class="programlisting code"><code class="hljs-code">let swiftIsCool = true
var itIsRaining = false
</code></pre>
    <p class="normal">Boolean values are especially useful when working with conditional statements, such as the <code class="Code-In-Text--PACKT-">if</code>, <code class="Code-In-Text--PACKT-">while</code>, and <code class="Code-In-Text--PACKT-">guard</code> statements. For example, what do you think this code would do?</p>
    <pre class="programlisting code"><code class="hljs-code">let isSwiftCool = true
var isItRaining = false
if isSwiftCool {
    print("YEA, I cannot wait to learn it")
}
if isItRaining {
    print("Get a rain coat")
}
</code></pre>
    <p class="normal">If you answered that this code would print out <code class="Code-In-Text--PACKT-">YEA, I cannot wait to learn it</code>, then you would be correct. This line is printed out because the <code class="Code-In-Text--PACKT-">isSwiftCool</code> Boolean type is set to <code class="Code-In-Text--PACKT-">true</code>, while the <code class="Code-In-Text--PACKT-">isItRaining</code> variable is set to <code class="Code-In-Text--PACKT-">false</code>; therefore, the <code class="Code-In-Text--PACKT-">Get a rain coat</code> message is not printed. </p>
    <p class="normal">In most languages, if we wanted to toggle the value of a Boolean variable, we would have to do something like this:</p>
    <pre class="programlisting code"><code class="hljs-code">isItRaining = !isItRaining
</code></pre>
    <p class="normal">In Swift, the Boolean type has a method called <code class="Code-In-Text--PACKT-">toggle()</code> that lets us toggle the value of the variable. This is used if we do not know the value that's stored in the variable. For example, if the <code class="Code-In-Text--PACKT-">isItRaining</code> constant was a variable instead and we wanted to change the value, but we did not know what it actually was, we could use the following line of code to change it:</p>
    <pre class="programlisting code"><code class="hljs-code">isItRaining.toggle()
</code></pre>
    <p class="normal">As with the Integer's <code class="Code-In-Text--PACKT-">isMultiple(of:)</code> method, this makes our code much easier to read <a id="_idIndexMarker125"/>and understand. Now, let's look at the <code class="Code-In-Text--PACKT-">String</code> type.</p>
    <h1 id="_idParaDest-53" class="title">The String type</h1>
    <p class="normal">A <strong class="keyword">string</strong> is <a id="_idIndexMarker126"/>an ordered collection of characters, such as <code class="Code-In-Text--PACKT-">Hello</code> or <code class="Code-In-Text--PACKT-">Swift</code>, and is represented by the <code class="Code-In-Text--PACKT-">String</code> type. We have seen several examples of strings in this book, and therefore the following code should look familiar. This code shows how to define two strings:</p>
    <pre class="programlisting code"><code class="hljs-code">var stringOne = "Hello"
var stringTwo = "World"
</code></pre>
    <p class="normal">We can also create a string using a multiline string literal. The following code shows how we can do that:</p>
    <pre class="programlisting code"><code class="hljs-code">var multiLine = """
This is a multiline string literal.
This shows how we can create a string over multiple lines.
"""
</code></pre>
    <p class="normal">Notice that we put three double quotes around the multiline string. We can use quotes in our multiline string to quote specific text. The following code shows how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">var multiLine = """
This is a multiline string literal.
This shows how we can create a string over multiple lines.
Jon says, "multiline string literals are cool"
"""
</code></pre>
    <p class="normal">Since a string is an ordered collection of characters, we can iterate through each character of a string. The following code shows how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">var stringOne = "Hello"
for char in stringOne {
    print(char)
}
</code></pre>
    <p class="normal">The preceding code will display the results that are shown in the following screenshot:</p>
    <figure class="mediaobject"><img src="img/B16683_03_06.png" alt="A screenshot of a computer screen  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.6: Iterating through the string's characters</p>
    <p class="normal">We can <a id="_idIndexMarker127"/>also use the <code class="Code-In-Text--PACKT-">map()</code> function, as shown in <em class="italic">Figure 3.6</em>, of the <code class="Code-In-Text--PACKT-">String</code> type to retrieve each character, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">stringOne.map {
    print($0)
}
</code></pre>
    <p class="normal">We will look at the <code class="Code-In-Text--PACKT-">map()</code> method and how it works later on in this book.</p>
    <p class="normal">There are two ways in which we can add one string to another. We can concatenate them or include them in-line. To concatenate two strings, we can use the <code class="Code-In-Text--PACKT-">+</code> or <code class="Code-In-Text--PACKT-">+=</code> operators. The following code shows both ways in which we can concatenate two strings. The first example appends <code class="Code-In-Text--PACKT-">stringB</code> to the end of <code class="Code-In-Text--PACKT-">stringA</code>, and the results are put into the new <code class="Code-In-Text--PACKT-">stringC</code> variable. The second example appends <code class="Code-In-Text--PACKT-">string</code> directly to the end of <code class="Code-In-Text--PACKT-">stringA</code>, without creating a new string:</p>
    <pre class="programlisting code"><code class="hljs-code">var stringC = stringA + stringB
stringA += string
</code></pre>
    <p class="normal">To include a string in-line with another string, we use a special sequence of characters: <code class="Code-In-Text--PACKT-">\()</code>. The following code shows how to include a string interpolation with another string:</p>
    <pre class="programlisting code"><code class="hljs-code">var stringA = "Jon"
var stringB = "Hello \(stringA)"
</code></pre>
    <p class="normal">In the previous example, <code class="Code-In-Text--PACKT-">stringB</code> will contain the message <code class="Code-In-Text--PACKT-">Hello Jon</code>, because Swift will replace the <code class="Code-In-Text--PACKT-">\(stringA)</code> sequence of characters with the value of the <code class="Code-In-Text--PACKT-">stringA</code> variable.</p>
    <p class="normal">Starting with Swift 5, we have the ability to create raw strings. In previous versions of Swift, if we wanted to include quotes or backslashes in a string, we had to <em class="italic">escape</em> it out using a backslash, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">let str = "The main character said \"hello\""
</code></pre>
    <p class="normal">With a raw string, the double quotes and backslashes are treated as part of the string literal, and so we do not need to escape them. The following example shows how to do this:</p>
    <pre class="programlisting code"><code class="hljs-code">let str1 = #"The main character said "hello""#
</code></pre>
    <p class="normal">Notice the hashtag <a id="_idIndexMarker128"/>and double quotes at the start and end of the string. That tells Swift that this is a raw string. This makes it much easier to read what the string actually contains. If we wanted to append another string in-line, as we did previously, we would use the <code class="Code-In-Text--PACKT-">\#()</code> character sequence. The following code illustrates this:</p>
    <pre class="programlisting code"><code class="hljs-code">let ans = 42
var str2 = #"The answer is \#(ans)"#
</code></pre>
    <p class="normal">The result of this code would be a <code class="Code-In-Text--PACKT-">str2</code> variable containing the following string: <strong class="keyword">The answer is 42</strong>.</p>
    <p class="normal">In Swift, we define the mutability of variables and collections by using the <code class="Code-In-Text--PACKT-">var</code> and <code class="Code-In-Text--PACKT-">let</code> keywords. If we define a string as a variable using <code class="Code-In-Text--PACKT-">var</code>, the string is mutable, meaning that we can change and edit the value. If we define a string as a constant using <code class="Code-In-Text--PACKT-">let</code>, the string is immutable, meaning that we cannot change or edit the value once it is set. The following code shows the difference between a mutable and an immutable string:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = "Hello" 
let y = "HI"
var z = " World"
//This is valid because x is mutable
x += z
//This is invalid because y is not mutable.
y += z
</code></pre>
    <p class="normal">Strings in Swift have two methods that can convert the case of the string. These methods are <code class="Code-In-Text--PACKT-">lowercased()</code> and <code class="Code-In-Text--PACKT-">uppercased()</code>. The following example demonstrates these methods:</p>
    <pre class="programlisting code"><code class="hljs-code">var stringOne = "hElLo"
print("Lowercase String:	\(stringOne.lowercased())")
print("Uppercase String:	\(stringOne.uppercased())")
</code></pre>
    <p class="normal">If we run this code, the results will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Lowercase String: hello
Uppercase String: HELLO
</code></pre>
    <p class="normal">Swift provides <a id="_idIndexMarker129"/>four ways to compare a string; these are string equality, prefix equality, suffix equality, and <code class="Code-In-Text--PACKT-">isEmpty</code>. The following example demonstrates these:</p>
    <figure class="mediaobject"><img src="img/B16683_03_07.png" alt="A screenshot of a computer screen  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 3.7: String comparison methods in Swift</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">isEmpty()</code> method checks to see if the string contains any characters or not. The string equality (<code class="Code-In-Text--PACKT-">==</code>) checks to see if the characters (which are case-sensitive) in the two strings are the same. The prefix and suffix equality checks to see if the string starts with or ends with a specific string. The prefix and suffix equality is case-sensitive as well.</p>
    <p class="normal">We can replace all the occurrences of a target string with another string, which is done with the <code class="Code-In-Text--PACKT-">replacingOccurrances(of:)</code> method. The following code demonstrates this:</p>
    <pre class="programlisting code"><code class="hljs-code">var stringOne = "one,to,three,four"
var stringTwo = stringOne.replacingOccurrences(of: "to", with: "two")
print(stringTwo)
</code></pre>
    <p class="normal">The preceding example will print <code class="Code-In-Text--PACKT-">one, two, three, four</code> to the screen because we are replacing all the occurrences of <code class="Code-In-Text--PACKT-">to</code> with <code class="Code-In-Text--PACKT-">two</code> in the <code class="Code-In-Text--PACKT-">stringOne</code> variable.</p>
    <div><p class="Information-Box--PACKT-">Note that the <code class="Code-In-Text--PACKT-">replacingOccurrences(of:)</code> method is only available on Apple platforms and is not available for other platforms.</p>
    </div>
    <p class="normal">We can also retrieve substrings and individual characters from our strings; however, when we retrieve a substring from a string, that substring is an instance of the <code class="Code-In-Text--PACKT-">Substring</code> type and not the <code class="Code-In-Text--PACKT-">String</code> type. The <code class="Code-In-Text--PACKT-">Substring</code> type contains most of the same methods as the <code class="Code-In-Text--PACKT-">String</code> type, so you can use them in a similar way. Unlike <code class="Code-In-Text--PACKT-">String</code> types, however, they are <a id="_idIndexMarker130"/>meant to be used only for short periods of time, only while we are working with the value. If you need to use a <code class="Code-In-Text--PACKT-">Substring</code> type for a long period of time, you should convert it into a <code class="Code-In-Text--PACKT-">String</code> type. The following example shows how we can work with substrings:</p>
    <pre class="programlisting code"><code class="hljs-code">var path = "/one/two/three/four"
//Create start and end indexes
let startIndex = path.index(path.startIndex, offsetBy: 4)
let endIndex = path.index(path.startIndex, offsetBy: 14)
let sPath = path[startIndex ..&lt; endIndex] //returns the "/two/three"
//convert the substring to a string 
let newStr = String(sPath)
path[..&lt;startIndex]    //returns the "/one"
path[endIndex...]     //returns the "/four"
path.last
path.first
</code></pre>
    <p class="normal">In the preceding example, we used the subscript path to retrieve the substring between a start and end index. The indices are created with the <code class="Code-In-Text--PACKT-">index(_: offsetBy:)</code> function. The first property in the <code class="Code-In-Text--PACKT-">index(_: offsetBy:)</code> function gives the index of where we wish to start, and the <code class="Code-In-Text--PACKT-">offsetBy</code> property tells us how much to increase the index by.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">path[..&lt;startIndex]</code> line creates a substring from the beginning of the string to the index, while the <code class="Code-In-Text--PACKT-">path[endIndex...]</code> line creates a substring from the index to the end of the string. We then use the last property to get the last character of the string and the first property to get the first character.</p>
    <div><p class="Information-Box--PACKT-">The <code class="Code-In-Text--PACKT-">..&lt;</code> operator that we saw in the previous example is known as a <strong class="keyword">half-open range operator</strong>. We <a id="_idIndexMarker131"/>will look at the different range operators at the end of this chapter. </p>
    </div>
    <p class="normal">We can <a id="_idIndexMarker132"/>retrieve the number of characters in a string by using the <code class="Code-In-Text--PACKT-">count</code> property. The following example shows how you can use this function:</p>
    <pre class="programlisting code"><code class="hljs-code">var path = "/one/two/three/four"
var length = path.count
</code></pre>
    <p class="normal">This completes our whirlwind tour of strings. We went through these properties and functions very quickly, but we will be using strings extensively throughout this book, so there will be a lot of code to help you get familiar with them.</p>
    <h1 id="_idParaDest-54" class="title">Tuples</h1>
    <p class="normal">Tuples group <a id="_idIndexMarker133"/>multiple values into a single compound type. These values are not required to be of the same type.</p>
    <p class="normal">The following example shows how to define a tuple:</p>
    <pre class="programlisting code"><code class="hljs-code">var team = ("Boston", "Red Sox", 97, 65, 59.9)
</code></pre>
    <p class="normal">In the preceding example, an unnamed tuple was created that contains two strings, two integers, and one double. The values of the tuple can be decomposed into a set of variables, as shown in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code">var team = ("Boston", "Red Sox", 97, 65, 59.9)
var (city, name, wins, losses, percent) = team
</code></pre>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">city</code> variable will contain <code class="Code-In-Text--PACKT-">Boston</code>, the <code class="Code-In-Text--PACKT-">name</code> variable will contain <code class="Code-In-Text--PACKT-">Red Sox</code>, the <code class="Code-In-Text--PACKT-">wins</code> variable will contain <code class="Code-In-Text--PACKT-">97</code>, the <code class="Code-In-Text--PACKT-">losses</code> variable will contain <code class="Code-In-Text--PACKT-">65</code>, and finally the <code class="Code-In-Text--PACKT-">percent</code> variable will contain <code class="Code-In-Text--PACKT-">59.9</code>.</p>
    <p class="normal">The values of the tuple can also be retrieved by specifying the location of the value. The following example shows how we can retrieve values by their location:</p>
    <pre class="programlisting code"><code class="hljs-code">var team = ("Boston", "Red Sox", 97, 65, 59.9)
var city = team.0
var name = team.1
var wins = team.2
var losses = team.3
var percent = team.4
</code></pre>
    <p class="normal">Naming tuples, known as <strong class="keyword">named tuples</strong>, allows us to avoid the decomposition step. A named tuple <a id="_idIndexMarker134"/>associates a name (key) with each element of the tuple. The following example shows how to create a named tuple:</p>
    <pre class="programlisting code"><code class="hljs-code">var team = (city:"Boston", name:"Red Sox", wins:97, losses:65, percent:59.9)
</code></pre>
    <p class="normal">Values from <a id="_idIndexMarker135"/>a named tuple can be accessed using the dot syntax. In the preceding code, we can access the <code class="Code-In-Text--PACKT-">city</code> element of the tuple like this: <code class="Code-In-Text--PACKT-">team.city</code>. In the preceding code, the <code class="Code-In-Text--PACKT-">team.city</code> element will contain <code class="Code-In-Text--PACKT-">Boston</code>.</p>
    <p class="normal">Tuples are incredibly useful and can be used for all sorts of purposes. I have found that they are very useful for replacing classes and structures that are designed to simply store data and do not contain any methods. They are also very useful for returning multiple values, of different types, from a function. Now, let's look at enumerations.</p>
    <h1 id="_idParaDest-55" class="title">Enumerations</h1>
    <p class="normal">Enumerations (also known as <strong class="keyword">enums</strong>) are a special data type that enables us to group related types <a id="_idIndexMarker136"/>together and use them in a type-safe manner. Enumerations in Swift are not tied to integer values as they are in other languages, such as C or Java. In Swift, we are able to define an enumeration with a type (string, character, integer, or floating-point value) and then define its actual value (known as the <strong class="keyword">raw value</strong>). Enumerations <a id="_idIndexMarker137"/>also support features that are traditionally only supported by classes, such as computed properties and instance methods. We will discuss these advanced features in depth in <em class="chapterRef">Chapter 7</em>, <em class="italic">Classes, Structures, and Protocols</em>. In this section, we will look at the traditional features of enumerations.</p>
    <p class="normal">We will define an enumeration that contains a list of <code class="Code-In-Text--PACKT-">Planets</code>, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">enum Planets {
    case mercury
    case venus
    case earth
    case mars
    case Jupiter
    case Saturn
    case Uranus
    case neptune
}
</code></pre>
    <div><p class="Information-Box--PACKT-">Note: When defining the enumeration type, the name of the enumeration should be uppercase, like other types. The member values can be uppercase or lowercase; however, it should be preferred to use lowercase.</p>
    </div>
    <p class="normal">The values defined in an enumeration are considered to be the member values (or simply the members) of the enumeration. In most cases, you will see the member values defined like <a id="_idIndexMarker138"/>they are in the preceding example because it is easy to read; however, there is a shorter version. This shorter version lets us define multiple members in a single line, separated by commas, as the following example shows:</p>
    <pre class="programlisting code"><code class="hljs-code">enum Planets {
case mercury, venus, earth, mars, jupiter
case saturn, uranus, neptune
}
</code></pre>
    <p class="normal">We can then use the <code class="Code-In-Text--PACKT-">Planets</code> enumeration like this:</p>
    <pre class="programlisting code"><code class="hljs-code">var planetWeLiveOn = Planets.earth
var furthestPlanet = Planets.neptune
</code></pre>
    <p class="normal">The type for the <code class="Code-In-Text--PACKT-">planetWeLiveOn</code> and <code class="Code-In-Text--PACKT-">furthestPlanet</code> variables is inferred when we initialize the variable with one of the member values of the <code class="Code-In-Text--PACKT-">Planets</code> enumeration. Once the variable type is inferred, we can then assign a new value without the <code class="Code-In-Text--PACKT-">Planets</code> prefix, as shown here:</p>
    <pre class="programlisting code"><code class="hljs-code">planetWeLiveOn = .mars
</code></pre>
    <p class="normal">We can compare an enumeration value using the traditional equals (<code class="Code-In-Text--PACKT-">==</code>) operator or by using a <code class="Code-In-Text--PACKT-">switch</code> statement.</p>
    <div><p class="Information-Box--PACKT-">Note: We will learn about the Swift <code class="Code-In-Text--PACKT-">switch</code> statement in <em class="chapterRef">Chapter 6</em>, <em class="italic">Control Flow</em>, later in this book. For now, we wanted to illustrate its use with the enumeration type.</p>
    </div>
    <p class="normal">The following <a id="_idIndexMarker139"/>example shows how to use the equals operator and the <code class="Code-In-Text--PACKT-">switch</code> statement with an enum:</p>
    <pre class="programlisting code"><code class="hljs-code">// Using the traditional == operator
if planetWeLiveOn == .earth {
    print("Earth it is")
}
// Using the switch statement
switch planetWeLiveOn {
case .mercury:
    print("We live on Mercury, it is very hot!")
case .venus:
    print("We live on Venus, it is very hot!")
case .earth:
    print("We live on Earth, just right")
case .mars:
    print("We live on Mars, a little cold")
default:
    print("Where do we live?")
}
</code></pre>
    <p class="normal">Enumerations can come prepopulated with raw values, which are required to be of the same type. The following example shows how to define an enumeration with string values:</p>
    <pre class="programlisting code"><code class="hljs-code">enum Devices: String {
    case MusicPlayer = "iPod"
    case Phone = "iPhone"
    case Tablet = "iPad"
}
print("We are using an \(Devices.Tablet.rawValue)")
</code></pre>
    <p class="normal">The preceding example creates an enumeration with three types of devices. We then use the <code class="Code-In-Text--PACKT-">rawValue</code> property to retrieve the stored value for the <code class="Code-In-Text--PACKT-">Tablet</code> member of the <code class="Code-In-Text--PACKT-">Devices</code> enumeration. This example will print a message saying, <code class="Code-In-Text--PACKT-">We are using an iPad</code>.</p>
    <p class="normal">Let's create another <code class="Code-In-Text--PACKT-">Planets</code> enumeration, but this time, we'll assign numbers to the members, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">enum Planets: Int {
    case Mercury = 1
    case Venus
    case Warth
    case Mars
    case Jupiter
    case Saturn
    case Uranus
    case Neptune
}
print("Earth is planet number \(Planets.earth.rawValue)")
</code></pre>
    <p class="normal">The big <a id="_idIndexMarker140"/>difference between these last two enumeration examples is that in the second example, we only assign a value to the first member (<code class="Code-In-Text--PACKT-">mercury</code>). If integers are used for the raw values of an enumeration, then we do not have to assign a value to each member. If no value is present, the raw values will be auto-incremented.</p>
    <p class="normal">In Swift, enumerations can also have associated values. Associated values allow us to store additional information, along with member values. This additional information can vary each time we use the member. It can also be of any type, and the types can be different for each member. Let's look at how we might use associate types by defining a <code class="Code-In-Text--PACKT-">Product</code> enumeration, which contains two types of products:</p>
    <pre class="programlisting code"><code class="hljs-code">enum Product {
    case Book(Double, Int, Int)
    case Puzzle(Double, Int)
}
var masterSwift = Product.Book(49.99, 2017, 310) 
var worldPuzzle = Product.Puzzle(9.99, 200)
switch masterSwift {
case .Book(let price, let year, let pages):
    print("Mastering Swift was published in \(year) for the price of \(price) and has \(pages) pages")
case .Puzzle(let price, let pieces):
    print("Mastering Swift is a puzzle with \(pieces) and sells for \(price)")
}
switch worldPuzzle {
case .Book(let price, let year, let pages):
    print("World Puzzle was published in \(year) for the price of \(price) and has \(pages) pages")
case .Puzzle(let price, let pieces):
    print("World Puzzle is a puzzle with \(pieces) and sells for \(price)")
}
</code></pre>
    <p class="normal">In the preceding example, we begin by defining a <code class="Code-In-Text--PACKT-">Product</code> enumeration with two members: <code class="Code-In-Text--PACKT-">Book</code> and <code class="Code-In-Text--PACKT-">Puzzle</code>. The <code class="Code-In-Text--PACKT-">Book</code> member has associated values of the <code class="Code-In-Text--PACKT-">Double</code>, <code class="Code-In-Text--PACKT-">Int</code>, and <code class="Code-In-Text--PACKT-">Int</code> types, while the <code class="Code-In-Text--PACKT-">Puzzle</code> member has associated values of the <code class="Code-In-Text--PACKT-">Double</code> and <code class="Code-In-Text--PACKT-">Int</code> types. Notice that we are using named associated types, where we assign a name for each associated type. We then create two products, <code class="Code-In-Text--PACKT-">masterSwift</code> and <code class="Code-In-Text--PACKT-">worldPuzzle</code>. We assign the <code class="Code-In-Text--PACKT-">masterSwift</code> variable a value of <code class="Code-In-Text--PACKT-">Product.Book</code> with the associated values of <code class="Code-In-Text--PACKT-">49.99</code>, <code class="Code-In-Text--PACKT-">2017</code>, and <code class="Code-In-Text--PACKT-">310</code>. We then assign the <code class="Code-In-Text--PACKT-">worldPuzzle</code> variable a value of <code class="Code-In-Text--PACKT-">Product.Puzzle</code> with the associated values of <code class="Code-In-Text--PACKT-">9.99</code> and <code class="Code-In-Text--PACKT-">200</code>.</p>
    <p class="normal">We can <a id="_idIndexMarker141"/>then check the <code class="Code-In-Text--PACKT-">Product</code> enumeration using a <code class="Code-In-Text--PACKT-">switch</code> statement, as we did in an earlier example. We then extract the associated values within the <code class="Code-In-Text--PACKT-">switch</code> statement. In this example, we extracted the associated values as constants with the <code class="Code-In-Text--PACKT-">let</code> keyword, but you can also extract the associated values as variables with the <code class="Code-In-Text--PACKT-">var</code> keyword.</p>
    <p class="normal">If you put the previous code into a playground, the following results will be displayed:</p>
    <pre class="programlisting con"><code class="hljs-con">"Master Swift was published in 2017 for the price of 49.99 and has 310 pages"
"World Puzzle is a puzzle with 200 and sells for 9.99"
</code></pre>
    <p class="normal">We are able to opt into the conformance of the <code class="Code-In-Text--PACKT-">Comparable</code> protocols with our enumerations that have no associated values or associated values, which themselves conform to the <code class="Code-In-Text--PACKT-">Comparable</code> protocol. By conforming to the <code class="Code-In-Text--PACKT-">Comparable</code> protocol, we are able to compare cases of the same enum using the <code class="Code-In-Text--PACKT-">&lt;</code> and <code class="Code-In-Text--PACKT-">&gt;</code> operators. Let's see how this works:</p>
    <div><p class="Information-Box--PACKT-">Don't worry if you do not understand what protocols are or how a type can conform to them at this point. We will be going over protocols in <em class="chapterRef">Chapter 9</em>, <em class="italic">Protocols and Protocol Extensions</em>.</p>
    </div>
    <pre class="programlisting code"><code class="hljs-code">enum Grades: Comparable {
    case f
    case d
    case c
    case b
    case a
}
let acceptableGrade = Grades.c
let testOneGrade = Grades.b
if  testOneGrade &lt; acceptableGrade {
    print("Grade is unacceptable")
}
else {
    Print("Grade is acceptable")
}
</code></pre>
    <p class="normal">In the previous code, we defined an enumeration that defined the different grade levels. By <code class="Code-In-Text--PACKT-">adding : Comparable</code> after the enumeration declaration, we are adding conformance to the <code class="Code-In-Text--PACKT-">Comparable</code> protocol. We then created a constant that defined what our acceptable grade level was. We are now able to compare any variable that contains a <code class="Code-In-Text--PACKT-">Grades</code> value with the <code class="Code-In-Text--PACKT-">acceptableGrade</code> constant to make sure it contains an acceptable grade, as shown in our example.</p>
    <p class="normal">Synthesized Comparable conformance for enumerations was added to Swift in version 5.3 with Swift Evolution SE-0266 and is one of the features I am most excited about. It allows us to <a id="_idIndexMarker142"/>conform to the <code class="Code-In-Text--PACKT-">Comparable</code> protocol with our enumerations, without having to write the code, to conform to the protocol ourselves.</p>
    <p class="normal">In future chapters in this book, we will look at additional features of enumerations and see why they can be so powerful. So far in this book, we have used operators in a number of examples. Let's take a closer look at them.</p>
    <h1 id="_idParaDest-56" class="title">Operators</h1>
    <p class="normal">An operator is a symbol or combination of symbols that we can use to check, change, or combine values. We have used operators in most of the examples so far in this book, but we did <a id="_idIndexMarker143"/>not specifically call them operators. In this section, we will show you how to use most of the basic operators that Swift supports.</p>
    <p class="normal">Swift supports most standard C operators and also improves on some of them to eliminate several common coding errors. For example, the assignment operator does not return a value, which prevents it from being used where we are meant to use the equality operator, which is two equal signs (<code class="Code-In-Text--PACKT-">==</code>).</p>
    <p class="normal">Let's look at the operators in Swift.</p>
    <h2 id="_idParaDest-57" class="title">The assignment operator</h2>
    <p class="normal">The assignment <a id="_idIndexMarker144"/>operator initializes or updates a variable. Here <a id="_idIndexMarker145"/>is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">var A = var B
</code></pre>
    <p class="normal">Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">let x = 1
var y = "Hello"
a = b
</code></pre>
    <h2 id="_idParaDest-58" class="title">Comparison operators</h2>
    <p class="normal">The comparison <a id="_idIndexMarker146"/>operators return a Boolean value <a id="_idIndexMarker147"/>of <code class="Code-In-Text--PACKT-">true</code> if the statement is <code class="Code-In-Text--PACKT-">true</code> or a Boolean value of <code class="Code-In-Text--PACKT-">false</code> if the statement is not <code class="Code-In-Text--PACKT-">true</code>.</p>
    <p class="normal">Here are some prototypes:</p>
    <pre class="programlisting code"><code class="hljs-code">Equality:  varA == varB
Not equal:  varA != varB 
Greater than:  varA &gt; varB 
Less than:  varA &lt; varB
Greater than or equal to: varA &gt;= varB
Less than or equal to: varA &lt;= varB
</code></pre>
    <p class="normal">Here are some examples:</p>
    <pre class="programlisting code"><code class="hljs-code">2 == 1 //false, 2 does not equal 1
2 != 1 //true, 2 does not equal 1
2 &gt; 1 //true, 2 is greater than 1
2 &lt; 1 //false, 2 is not less than 1
2 &gt;= 1 //true, 2 is greater or equal to 1
2 &lt;= 1 //false, 2 is not less or equal to 1
</code></pre>
    <h2 id="_idParaDest-59" class="title">Arithmetic operators</h2>
    <p class="normal">The arithmetic <a id="_idIndexMarker148"/>operators perform the four basic mathematical <a id="_idIndexMarker149"/>operations. Here are some prototypes:</p>
    <pre class="programlisting code"><code class="hljs-code">Addition: varA + varB
Subtraction: varA - varB
Multiplication: varA * varB
Division: varA / varB
</code></pre>
    <p class="normal">Here are some examples:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = 4 + 2  //x will equal 6
var x = 4 â€“ 2  //x will equal 2
var x = 4 * 2  //x will equal 8
var x = 4 / 2  //x will equal 2
var x = "Hello " + "world"  //x will equal "Hello World"
</code></pre>
    <h2 id="_idParaDest-60" class="title">The remainder operator</h2>
    <p class="normal">The remainder <a id="_idIndexMarker150"/>operator calculates the remainder if the <a id="_idIndexMarker151"/>first operand is divided by the second operand. In other languages, this is sometimes referred to as the modulo or modulus operator.</p>
    <p class="normal">Here is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">varA % varB
</code></pre>
    <p class="normal">Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = 10 % 3  //x will equal 1
var x = 10 % 6  //x will equal 4
</code></pre>
    <h2 id="_idParaDest-61" class="title">Compound assignment operators</h2>
    <p class="normal">The compound <a id="_idIndexMarker152"/>assignment operators combine an <a id="_idIndexMarker153"/>arithmetic operator with an assignment operator.</p>
    <p class="normal">Here are some prototypes:</p>
    <pre class="programlisting code"><code class="hljs-code">varA += varB
varA -= varB
varA *= varB
varA /= varB
</code></pre>
    <p class="normal">Here are some examples:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = 6
x += 2  //x now is 8
x -= 2  //x now is 4
x *= 2  //x now is 12
x /= 2  //x now is 3
</code></pre>
    <h2 id="_idParaDest-62" class="title">The closed range operator</h2>
    <p class="normal">The closed <a id="_idIndexMarker154"/>range operator defines a range that runs <a id="_idIndexMarker155"/>from the first number to the second number. The numbers are separated by three dots.</p>
    <p class="normal">Here is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">(a...b)
</code></pre>
    <p class="normal">Here is an example. Note that we will cover the <code class="Code-In-Text--PACKT-">for</code> loop in <em class="chapterRef">Chapter 6</em>, <em class="italic">Control Flow</em>:</p>
    <pre class="programlisting code"><code class="hljs-code">for i in 1...3 {
    print("Number: \(i)")
}
</code></pre>
    <p class="normal">This example would print out the following:</p>
    <pre class="programlisting code"><code class="hljs-code">Number: 1
Number: 2
Number: 3
</code></pre>
    <h2 id="_idParaDest-63" class="title">The half-open range operator</h2>
    <p class="normal">The half-open <a id="_idIndexMarker156"/>range operator defines a range that runs from <a id="_idIndexMarker157"/>the first number to one, minus the second number. The numbers are separated by two dots and the less than sign.</p>
    <p class="normal">Here is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">(a..&lt;b)
</code></pre>
    <p class="normal">Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">for i in 1..&lt;3 { 
    print("Number: \(i)")
}
</code></pre>
    <p class="normal">This example would print out the following:</p>
    <pre class="programlisting con"><code class="hljs-con">Number: 1
Number: 2
</code></pre>
    <div><p class="Information-Box--PACKT-">Notice that in the closed range operator, the line <code class="Code-In-Text--PACKT-">Number: 3</code> was printed out, but with the half open range operator, it wasn't.</p>
    </div>
    <p class="normal">There are also one-side range operators that we use with arrays. We will look at those in <em class="chapterRef">Chapter 5</em>, <em class="italic">Using Swift Collections</em>.</p>
    <h2 id="_idParaDest-64" class="title">The ternary conditional operator</h2>
    <p class="normal">The <a id="_idIndexMarker158"/>ternary conditional operator assigns a value to <a id="_idIndexMarker159"/>a variable based on the evaluation of a comparison operator or <code class="Code-In-Text--PACKT-">Boolean</code> value.</p>
    <p class="normal">Here is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">(boolValue ? valueA : valueB)
</code></pre>
    <p class="normal">Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = 2
var y = 3
var z = (y &gt;x ? "Y is greater" : "X is greater")  //z equals "Y is greater"
</code></pre>
    <h2 id="_idParaDest-65" class="title">The logical NOT operator</h2>
    <p class="normal">The <a id="_idIndexMarker160"/>logical <code class="Code-In-Text--PACKT-">NOT</code> operator inverts a <code class="Code-In-Text--PACKT-">Boolean</code> value. Here is <a id="_idIndexMarker161"/>a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">varA = !varB
</code></pre>
    <p class="normal">Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = true
var y = !x	  //y equals false
</code></pre>
    <h2 id="_idParaDest-66" class="title">The logical AND operator</h2>
    <p class="normal">The <a id="_idIndexMarker162"/>logical <code class="Code-In-Text--PACKT-">AND</code> operator returns <code class="Code-In-Text--PACKT-">true</code> if both operands are <code class="Code-In-Text--PACKT-">true</code>; otherwise, it returns <code class="Code-In-Text--PACKT-">false</code>.</p>
    <p class="normal">Here <a id="_idIndexMarker163"/>is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">varA &amp;&amp; varB
</code></pre>
    <p class="normal">Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = true 
var y = false
var z = x &amp;&amp; y  //z equals false
</code></pre>
    <h2 id="_idParaDest-67" class="title">The logical OR operator</h2>
    <p class="normal">The <a id="_idIndexMarker164"/>logical <code class="Code-In-Text--PACKT-">OR</code> operator returns <code class="Code-In-Text--PACKT-">true</code> if either of the operands are <code class="Code-In-Text--PACKT-">true</code>. Here is a prototype:</p>
    <pre class="programlisting code"><code class="hljs-code">varA || varB
</code></pre>
    <p class="normal">Here is <a id="_idIndexMarker165"/>an example:</p>
    <pre class="programlisting code"><code class="hljs-code">var x = true
var y = false
var z = x|| y  //z is true
</code></pre>
    <p class="normal">For those who are familiar with C or similar languages, these operators should look pretty familiar. For those of you who aren't that familiar with the C operators, rest assured that, once you begin using them frequently, they will become second nature.</p>
    <h1 id="_idParaDest-68" class="title">Summary</h1>
    <p class="normal">In this chapter, we covered topics ranging from variables and constants to data types and operators. The items in this chapter will act as the foundation for every application that you write; therefore, it is important to understand the concepts we discussed here.</p>
    <p class="normal">In this chapter, we have seen that we should prefer constants to variables when the value is not going to change. Swift will give you a compile-time warning if you set but never change a variable's value. We also saw that we should prefer type inference over declaring a type.</p>
    <p class="normal">Numeric and string types, which are implemented as primitives in other languages, are named types that are implemented with structures in Swift. In future chapters, you will see why this is important. One of the most important things to remember from this chapter is that, if a variable contains a nil value, you must declare it as an optional.</p>
    <p class="normal">In the next chapter, we will look at Swift optional types. The optional type in Swift can be one of the hardest concepts to grasp if you are used to languages that don't use them.</p>
  </div>
</body></html>