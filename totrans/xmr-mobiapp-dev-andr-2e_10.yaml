- en: Chapter 10. Adding the Camera App Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another exciting feature of mobile computing is that most Android devices have
    some types of camera that can be used to capture photos and/or videos. This chapter
    will walk you through the steps required to add the ability to capture and upload
    a picture of a POI and will include the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Approaches to integrate with a device camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camera permissions and features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing and displaying a photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading an image using an HTTP multipart form upload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking an integration approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Android platform provides two different ways to integrate a device''s camera
    feature to your app:'
  prefs: []
  type: TYPE_NORMAL
- en: Using existing camera apps to integrate using the `Intent` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own custom activity that interacts directly with the camera using
    the Android API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second approach allows a high degree of control over how the camera view
    is presented to the user, and how the user interacts with the view. However, the
    first approach is very straightforward to implement as it reuses the existing
    device camera apps to capture the picture. We will go with the `Intent` method
    as it represents a very practical way to add camera integration.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions and features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting into the details of integrating the device camera feature, we
    will discuss more about the general permissions and features related to the camera
    in more depth. The following table contains the various permissions that may be
    required. In our case, we need not specify any of these because we are using the
    `Intent` method, where the external camera app will capture the picture for us.
    The external camera app needs to specify the required camera permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: Permission
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: '`CAMERA`'
  prefs: []
  type: TYPE_NORMAL
- en: This is required for apps that request permission to use the device's camera;
    this is not required if you make use of the `Intent` method
  prefs: []
  type: TYPE_NORMAL
- en: '`WRITE_EXTERNAL_STORAGE`'
  prefs: []
  type: TYPE_NORMAL
- en: This permission is required to save images or videos to the device's external
    storage (SD card)
  prefs: []
  type: TYPE_NORMAL
- en: '`RECORD_AUDIO`'
  prefs: []
  type: TYPE_NORMAL
- en: If your app records audio with video capture
  prefs: []
  type: TYPE_NORMAL
- en: Camera-specific features can be set up in an app's manifest file using the `&lt;uses-feature&gt;`
    element. The `&lt;uses-feature&gt;` declaration is used to inform about the set
    of hardware and software features on which your application depends. You may specify
    the `required=true` to declare that your application cannot function without the
    declared feature. The feature declaration is used for information purpose only.
    There is no validation done by the Android system before installing the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table depicts the set of features you may define in your application
    manifest declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: Feature
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs: []
  type: TYPE_NORMAL
- en: '`android.hardware.camera`'
  prefs: []
  type: TYPE_NORMAL
- en: The application uses the device's camera. If the device supports multiple cameras,
    the application uses the camera that faces away from the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '`android.hardware.camera.autofocus`'
  prefs: []
  type: TYPE_NORMAL
- en: Subfeature. The application uses the device camera's autofocus capability.
  prefs: []
  type: TYPE_NORMAL
- en: '`android.hardware.camera.flash`'
  prefs: []
  type: TYPE_NORMAL
- en: Subfeature. The application uses the device camera's flash.
  prefs: []
  type: TYPE_NORMAL
- en: '`android.hardware.camera.front`'
  prefs: []
  type: TYPE_NORMAL
- en: Subfeature. The application uses a front-facing camera on the device.
  prefs: []
  type: TYPE_NORMAL
- en: '`android.hardware.camera.any`'
  prefs: []
  type: TYPE_NORMAL
- en: The application uses at least one camera, which can face in any direction. Use
    this in preference to `android.hardware.camera` if a back-facing camera is not
    required.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will not specify any features as requirements, but at runtime,
    we will check whether an external app is available to capture a photo.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using the emulator for development, you will need to configure it
    to have a camera. If the computer you are using has a webcam, the emulator can
    use it as the camera; otherwise, you can choose to have an emulated camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the emulator for a camera, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the main menu, navigate to **Tools** and open **Android Emulator Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the emulator you have been working with and choose **Edit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the middle of the Edit AVD dialog, you will see two dropdowns; one for **Front
    Camera** and one for **Back Camera**. Make your selections and click on **OK**:![](img/aJ42xZHe.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending the data service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we have decided to use an external camera app to capture the picture,
    it will take care of saving the picture after it has been captured. We will have
    to provide the storage path where the image will be saved. To save the POI images,
    we will use a naming scheme such as `poiimage&lt;poi id&gt;.jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now extend the `POIService` class with the following additional methods.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GetFileName()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s implement the `GetFileName()` method in `POIService.cs` that will take
    care of providing the absolute path for saving the images in device memory. The
    absolute path includes the location and the filename. The image files will be
    named as `poiimage&lt;poi id&gt;.jpg`. The following listing shows how the filename
    can be constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Implementing GetImage()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous sections, the saving of an image can be done by
    the camera intent. However, we need to write two helper methods to read and delete
    the image from device storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the `GetImage()` helper method that will be used to read the POI
    image from the device memory location, where it was saved earlier. Add the following
    listing to the `POIService.cs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implementing DeleteImage()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a user deletes the `poi` object by clicking on the delete action bar button,
    currently the POI will be deleted from the server. It is a good idea to delete
    the corresponding POI image from device memory once the delete from the server
    side is successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following helper method is used to delete the image based on its POI ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this chapter, we are not dealing with the delete POI; however, to incorporate
    the changes as described earlier, you need to call the `DeleteImage()` method
    in `DeletePOIAsync()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Capturing an image from POIDetailFragment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to take on the task of capturing a photo. This will involve
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new user interface widgets to initiate capturing a photo and displaying
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a photo intent to navigate to an external camera app to capture a photo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the results of the photo intent and displaying a photo once it is
    successfully captured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following sections describe the details of each step.
  prefs: []
  type: TYPE_NORMAL
- en: Adding UI elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few new UI elements that we will need to add to support capturing
    an image; we need an `ImageButton` element to initiate the process of capturing
    an image, and we also need an `ImageView` element to display the captured POI
    image. The `ImageButton` widget can be added adjacent to the location and map
    buttons, and the `ImageView` element can be placed as the first widget above the
    **Name** field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows the definition of the `ImageView`, which should be
    placed inside the `LinearLayout` before the POI name text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a private reference object in `POIDetailFragment` and assign the reference
    in `OnCreateView()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, we need a button that initiates the camera. We will start by copying the
    `ic_new_picture.png` icon from the `assets` folder to the project's `drawable`
    folder and adding it to the project in the same manner, as we did in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following button definition to the `LinearLayout` that contains the
    other two buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding layout changes should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/qvGeG67L.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a private reference object in `POIDetailFragment` and assign the reference
    in `OnCreateView()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding code snippets, we are assigning the `NewPhotoClicked()`
    event listener to the `photoImageButton` button. We will complete the `NewPhotoClicked()`
    method implementation in the following sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the camera Intent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start an external camera app to capture a photo, we rely on the `Intent`
    class again, this time combined with an action. The following listing depicts
    creating an `Intent` class with the image capture action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `MediaStore` class contains the metadata for all the available media on
    both internal and external storage devices. The `MediaStore.ActionImageCapture`
    action tells the Android platform that you want to capture a photo and are willing
    to use any existing app that provides these capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for registered camera apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Chapter 9, *Making POIApp Location Aware*, we used `PackageManager` to check
    whether there is a map app installed to handle our intent. We now need to perform
    the same check for an app that can handle our `ActionImageCapture` intent. The
    following listing shows the logic we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Providing additional information with the Intent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start the intent, we need to provide some information to the camera
    app that processes our request; specifically, a filename and location, and the
    maximum size of the resulting photo. You must be careful about providing the value
    of the maximum size; this can be a potential threat that can cause out of memory
    exceptions. We do this by adding `Extras` to the intent. The `MediaStore` class
    defines a number of standard `Extras` that can be added to an intent to control
    how an external app fulfils the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Providing a filename and location
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MediaStore.ExtraOutput` extra can be used to control the filename and location
    that the external camera app should use in order to capture an image. We previously
    added the `GetFileName()` method in the `POIService` class to provide the file
    path information. However, the camera app expects the file path as an instance
    of `Android.Net.Uri`; and hence, we will need to convert the string path to an
    instance of `Android.Net.Uri`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a two-step process. First, we create a `Java.IO.File` object using
    the string path from the data service and then create an `Android.Net.Uri` object.
    The following listing shows how to accomplish the construction of the URI and
    set up the `MediaStore.ExtraOutput` extra:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Providing a size limit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `MediaStore.ExtraSizeLimit` extra limits the image size. It is much more
    straightforward to set up as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Starting the Intent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to invoke the camera app by starting the intent by calling
    the `StartActivity()` method. Unlike the map app, in the case of a camera intent,
    we expect the results back from the activity. We are expecting the camera app
    to provide either a photo or a notification that the user cancelled to capture
    the photo. This can be accomplished by calling `StartActivityForResult()` by passing
    in the intent. The `StartActivityForResults()` method works in conjunction with
    an `OnActivityResult()` activity callback to communicate the results of the intent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing depicts the calling of `StartActivityForResult()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the second parameter of `StartActivityForResult()`. It is an integer
    value named `requestCode` that will be returned as a parameter to `OnActivityResult()`
    in the callback and help you identify the original reason for launching an intent.
    The best practice is to define a constant value to pass in for each `requestCode`
    that could potentially cause `OnActivityResult()` to be called.
  prefs: []
  type: TYPE_NORMAL
- en: Note that when we call the `StartActivityForResult()` method from the fragment,
    the result will always be returned to the `OnActivityResult()` method of the activity
    that hosts `POIDetailsFragment`. However, in this case, we are looking for the
    results in `POIDetailsFragment` itself. For this, we need to override the `OnActivityResult()`
    method in all of the hosting activities, and call `base.OnActivityResult` to fire
    the callback to the `OnActivityResult()` method declared on the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the NewPhotoClicked() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have covered a number of topics related to starting the camera app in a
    somewhat fragmented fashion. The following listing is the complete implementation
    of `NewPhotoClicked()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Processing the results of the Intent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initiating activity is notified of the results of an intent via the `OnActivityResult()`
    callback method. Let''s add the following callback to both `POIListActivity` and
    `POIDetailActivity` to trigger the callback back to `POIDetailFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s override the `OnActivityResult` method in the `POIDetailFragment`
    class. The following listing shows the signature of the `OnActivityResult()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We discussed `requestCode` in the previous section. The `resultCode` parameter
    indicates the result of the intent that was launched and is of type **Result**,
    which can have the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: Value
  prefs: []
  type: TYPE_NORMAL
- en: Meaning
  prefs: []
  type: TYPE_NORMAL
- en: '`RESULT_OK`'
  prefs: []
  type: TYPE_NORMAL
- en: The activity completed the request successfully
  prefs: []
  type: TYPE_NORMAL
- en: '`REQUEST_CANCELED`'
  prefs: []
  type: TYPE_NORMAL
- en: The activity was canceled, generally, by a user action
  prefs: []
  type: TYPE_NORMAL
- en: '`REQUEST_FIRST_USER`'
  prefs: []
  type: TYPE_NORMAL
- en: The first value that can be used for a custom meaning
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter, `data`, is of type `Intent` and can be used to pass additional
    information back from the activity that was launched. In our case, we are only
    concerned with `requestCode` and `resultCode`. The following listing shows the
    implementation of `OnActivityResult()` in `POIDetailFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when `resultCode` is `RESULT_OK`, we load the photo that was captured
    into a Bitmap object and then set the image for `_poiImageView`. This causes the
    image to be displayed at the top of the `POIDetailFragment` layout. If `resultCode`
    is not `RESULT_OK`, we display a toast message to the user, indicating that the
    action was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: We are making use of `GetImage()` in `POIService` to retrieve the image from
    the memory. It is a simple utility method that accepts a POI ID and loads `Android.Graphics.Bitmap`
    using the Android utility class `BitmapFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have added a lot of code. Run `POIApp`, and from the `POIDetails`
    page, click on the add image button to invoke the camera. Notice that the captured
    image will be displayed on the `POIDetails` screen.
  prefs: []
  type: TYPE_NORMAL
- en: Upload an image using an HTTP multipart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last functionality we are left to incorporate in the `POIApp` sample application
    is to upload the captured POI image to the server. Currently, we are saving only
    the POI details on Cloud, and the POI images are stored locally on the user's
    device memory. It would be nice to upload the image to the server so that we don't
    lose the images when a user deletes them locally from a device.
  prefs: []
  type: TYPE_NORMAL
- en: If the user has captured the photo of the POI and it is available locally on
    the device memory, then the save action will post the image along with the data
    using multipart form upload. Otherwise, it will post just the POI JSON data for
    the save operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we create a multipart form data request, let''s first understand the
    web service API specification. The following block describes the web service API
    requirements for a multipart form upload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the preceding API specification uses the `multipart/form-data` encoding
    type. Earlier in this book, for uploading the POI JSON object we used the HTTP
    `POST` method, but now we need to send the POI data along with the Bitmap stream,
    which cannot be uploaded with the `POST` method. We need to use `multipart/form-data`
    encoding type through which we can attach an image, along with several other message
    contents.
  prefs: []
  type: TYPE_NORMAL
- en: A standard delimiter called `boundary` separates each part of a multipart message.
    Each part of the message can define its own standard headers, such as `Content-Type`
    and `Content-Disposition`, providing the name of the file whose value it contains.
    The multipart delimiters and header fields are always 7-bit ASCII, in any case.
    The content of the image is present right below the `Content-Type` header, followed
    by the value of the POI JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed information on multipart `Content-Type`, search for **RFC
    1341(MIME)** and visit [http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html](http://www.w3.org/Protocols/rfc1341/7_2_Multipart.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the API specification to upload the image along with
    the POI data, let''s proceed with the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an overloaded method for `CreateOrUpdatePOIAsync()` in the `POIService`
    class that takes two arguments: object of `PointOfInterest`, and the POI image
    `bitmap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following snippets to convert the POI object to a JSON object and then
    to `StringContent`. I don''t need to give you an explanation as we have already
    done a similar thing while posting the POI data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now convert the Bitmap image to a byte array in order to send it as `ByteArrayContent`
    via the multipart form upload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that the `bitmap.Compress()` writes a compressed version of the Bitmap
    to the specified stream. The second integer argument indicates the compression
    quality ranging from `0` to `100`, where `0` means low quality and `100` being
    the maximum (lowest quality).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following additional content headers such as media content type and
    content disposition. The POI image name is sent in the `poiimage&lt;poid&gt;.jpg`
    format. The server that saves the image in the database will use this name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we are ready with both the POI data and and image content, we can
    add both the chunks to the `MultipartFormDataContent`. The `boundary` is a random
    string used as a delimiter to separate each part of the message body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a string constant that represents the web service endpoint to upload
    the POI image using multipart:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s now proceed to upload the form content to the server using the `HttpClient`
    class in the `PostAsync()` method. The following code snippet demonstrates posting
    data to the server using the `HttpClient` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result of the upload request is sent back to the `POIDetailFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the method ready to upload the image along with the POI JSON
    data, let's change the logic in the `POIDetailFragment` class in the `SavePOI()`
    method. Currently, the save action validates the user input and calls `CreateOrUpdatePOIAsync()`
    by passing the POI object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if the user has captured the POI image using the camera, let''s instead
    call the newly created overridden version of `CreateOrUpdatePOIAsync()` by passing
    the Bitmap, POI, and activity instance. Add the following logic to the `SavePOI()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our application memory efficient, it is a good idea to dispose the
    Bitmap instance after you''re done with it. Add the following code to dispose
    the Bitmap memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We have now completed the `POIApp` app that exercises many of the Xamarin.Android
    features you will need to utilize for developing a professional app. While the
    app is relatively simple in nature, we hope that it provides a good starter guide
    for the Android app development. I wish you good luck with the Xamain.Android
    development! Happy coding!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we completed `POIApp` by adding integration with the camera.
    We now have an app that demonstrates many of the features of the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we will discuss the various app distribution channels and
    steps to prepare your application for deployment.
  prefs: []
  type: TYPE_NORMAL
