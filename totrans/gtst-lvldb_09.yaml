- en: Chapter 9. A Document Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is going to take some of the theory we just discussed in the previous
    chapters and show the use of richer record structures and multiple keys for a
    document database. It uses the extended APLevelDBSS framework for these searches
    and building keys, including a word index.
  prefs: []
  type: TYPE_NORMAL
- en: This is a fairly simple document database but would be enough to keep track
    of a range of books and publications as well as local PDF or other files. The
    process of building lists of each and entering their details is very similar to
    what we covered in the `Sample06` GUI used in the previous chapter. One GUI technique
    for OS X that is new to this application is how to get references to files by
    dragging and dropping them on our window, so the details behind that are discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The samples so far haven't covered how to handle more than one database. We
    used fixed paths to a known database location. Opening others is covered here
    including discussing the package idiom of iOS and OS X that treats folders as
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: Key design for searching the document database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to retrieve documents by title, keyword, and author so have keys for
    each as shown in the following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![Key design for searching the document database](img/1015OS_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Typical NoSQL-style data and relationships in the document database
  prefs: []
  type: TYPE_NORMAL
- en: In a relational database, more tables would be used to track the authors, making
    it easier to work out co-authoring, but that is not the only pattern that can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Storing multiple values nested inside a JSON or other encoded value is a typical
    noSQL pattern and helps simplify the keys. This schema also simplifies a little
    by ignoring identical author names that are actually different people. Note that
    we don't have any explicit keys to track that people are co-authors.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the schema using APLevelDBSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The schema definition matching the previous diagram is shown in the following
    code, using a property for each key to define the parts of keys. The `docKey`
    also defines the `valueFields` which define the minimum content for the record
    to support keys and our GUI. Unlike classical relational schemas, there may be
    more fields in any individual record than we define:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The schema handling of APLevelDBSS will reconcile the key definitions so anything
    with a `partFromPath` will use the path string to navigate to the original data,
    mapping `doc.desc` to the `doc` key and then a `desc` field within.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the `wordKey` has a `valueGenerator` block that generates multiple
    values, using the `uniqueWordsFromString` shown in the following code. We regard
    all keys as potentially generating zero or multiple values either from a block
    or as a side effect of their path such as `doc.authors.name` matching a list of
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding word generator is vastly simpler than a production-quality generator
    that would use **stemming** to match words with the same base, such as plurals.
    It should also have a **stop-word list** to skip words rather than just checking
    `length >=3` characters.
  prefs: []
  type: TYPE_NORMAL
- en: The field of extracting text for indexing has a huge body of work. You can read
    about stemming algorithms and download BSD-licensed source for the Snowball algorithm,
    successor to the classic Porter algorithm, at [http://snowball.tartarus.org/index.php](http://snowball.tartarus.org/index.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two major open source projects that use text indexing are Sphinx and Solr;
    part of Lucene. Packt Publishing have many books covering them including: [http://www.packtpub.com/sphinx-search-beginners-guide/book](http://www.packtpub.com/sphinx-search-beginners-guide/book)
    and [http://www.packtpub.com/apache-solr-4-cookbook/book](http://www.packtpub.com/apache-solr-4-cookbook/book).'
  prefs: []
  type: TYPE_NORMAL
- en: Database fields for tracking documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Documents are identified by a URL that might be referring externally to an
    Internet resource or to a local file. As far as the database is concerned, this
    is just another string value. The OS X sample allows you to drag a document and
    drop it on the window, by registering to handle the `NSURLPboardType` and adding
    two handler methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once the preceding code sets the text field `docURL` we use it with the database
    as if it were a string value the user had typed into an entry field.
  prefs: []
  type: TYPE_NORMAL
- en: Databases as documents via packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our previous database samples created a database in a temporary location. Most
    applications need a database that behaves more like a document itself, which allows
    us to copy it around and open multiple databases. `Sample09` is such an `NSDocument`
    application, supporting independent collections of authors and other documents.
    Remember, we use a property to track our database—nothing prevents an application
    having multiple such properties and open databases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike a typical document-based app, we must have the database operating as
    soon as we have a new window—we will save continuously rather than on-demand.
    To ensure this happens, the `NSWindowController` can trigger the **Save As** panel
    with `[[self document] saveDocumentAs:self]` to get to choose a location for the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: The complication occurs in how to handle the fact that a database is really
    stored in a directory of many files. Apple's *Bundle Programming Guide* describes
    how to create a **Document Package** which is a way of treating a specially named
    directory as if it were a single document. We use `leveldb` as an extension but
    you can choose your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'First edit the `xxx-info.plist` file and add two entries to `CFBundleDocumentTypes`:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `LSTypeIsPackage` set to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `CFBundleTypeExtensions` with the desired extension, `leveldb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you compile and run that program, you will find that any directory named
    with that extension, such as `blah.leveldb`, will now appear as a single item
    in the finder and you have to right-click and choose **Show Package Contents**
    to navigate within. Hooking up the `NSDocument` subclass to open a database within
    that directory needs two overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In both of the preceding methods, we end up getting a full path from an OS X
    function that supplied the user with a GUI for selecting a file or **Save as**
    location. Inside OS X that may be a sandboxed location—we were just handed back
    a usable path as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learnt another key design exercise with the schema including two sources
    of multiple keys—word indexing and multiple authors. Typical drag-and-drop desktop
    behavior was shown to add file links in OS X, so you could see how a file URL
    becomes just a string value in a database. We finally saw how to have multiple
    databases opened and treated as single document on desktop, rather than being
    in fixed locations. Now, we will delve deeper into LevelDB and learn more about
    design trade-offs and settings.
  prefs: []
  type: TYPE_NORMAL
