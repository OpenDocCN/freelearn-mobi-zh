<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Nodes in Sprite Kit"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Nodes in Sprite Kit</h1></div></div></div><p>In the last chapter, we learnt about how to use sprites in a game in various ways. We discussed about the physical properties of sprites, textures of sprites, and various other properties, such as color property, lighting, shader, and so on. We also learned about working with texture objects and had an introduction to texture atlases.</p><p>In the previous chapter, we implemented the <code class="literal">SKSprite</code> class which is a subclass of the <code class="literal">SKNode</code> class; that's why <code class="literal">SKSprite</code> is a node itself, inheriting <code class="literal">SKNode</code> properties. In this chapter, we will study about nodes, which play an important role in understanding the tree structure of a game. Further, we will discuss about types of nodes in the Sprite Kit and their uses in detail.</p><div class="section" title="All you need to know about nodes"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec39"/>All you need to know about nodes</h1></div></div></div><p>We have discussed many <a id="id162" class="indexterm"/>things about nodes so far. Almost everything you are making in a game with Sprite Kit is a node. Scenes that we are presenting to view are instances of the <code class="literal">SKScene</code> class, which is a subclass of the <code class="literal">SKEffectNode</code> class, which is itself a subclass of the <code class="literal">SKNode</code> class. Indirectly, <code class="literal">SKScene</code> is a subclass of the <code class="literal">SKNode</code> class.</p><p>As a game follows the node tree formation, a scene acts like a root node and the other nodes are used as its children. It should be remembered that although <code class="literal">SKNode</code> is a base class for the node you see in a scene, it itself does not draw anything. It only provides some basic features to its subclass nodes. All the visual content we see in a Sprite Kit made game, is drawn by using the appropriate <code class="literal">SKNode</code> subclasses.</p><p>Following are some subclasses of <code class="literal">SKNode</code> classes, which are used for different behaviors in a Sprite Kit-based game:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SKSpriteNode</code>: This class is used to instantiate a texture sprite in the game; this is a familiar node class<a id="id163" class="indexterm"/> referred to frequently in <a class="link" href="ch03.html" title="Chapter 3. Sprites">Chapter 3</a>, <span class="emphasis"><em>Sprites</em></span>. <code class="literal">SKVideoNode</code>, this class is used to play video content in a scene.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKLabelNode</code>: This class is <a id="id164" class="indexterm"/>used to draw labels in a game, with many customizing options, such as font type, font size, font color, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKShapeNode</code>: This class is used<a id="id165" class="indexterm"/> to make a shape based on a path, at run time. For example, drawing a line or making a drawing game.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKEmitterNode</code>: This class is <a id="id166" class="indexterm"/>used for emitting particle effects in a scene, with many options, such as position, number of particles, color, and so on.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKCropNode</code>: This class is<a id="id167" class="indexterm"/> basically used for cropping its child nodes, using a mask. Using this, you can selectively block areas of a layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKEffectNode</code>: <code class="literal">SKEffectNode</code> is the parent of the <code class="literal">SKScene</code> class and the subclass of the <code class="literal">SKNode</code> class. It is <a id="id168" class="indexterm"/>used for applying an image filter to its children.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKLightNode</code>: <code class="literal">SKLightNode</code> class<a id="id169" class="indexterm"/> is used to make light and shadow effects in scene.</li><li class="listitem" style="list-style-type: disc"><code class="literal">SKFieldNode</code>: This is a useful feature of Sprite Kit. You can define a portion of scene with some physical <a id="id170" class="indexterm"/>properties, for example, in space game, having a gravity effect on a black hole, which attracts the things which are nearby.</li></ul></div><p>So, these are the basic subclasses of <code class="literal">SKNode</code> which are used frequently in Sprite Kit. <code class="literal">SKNode</code> provides some basic properties to its subclasses, which are used to view a node inside a scene, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">position</code>: This sets up<a id="id171" class="indexterm"/> the position of a node in a scene</li><li class="listitem" style="list-style-type: disc"><code class="literal">xScale</code>: This scales in the <a id="id172" class="indexterm"/>width of a node</li><li class="listitem" style="list-style-type: disc"><code class="literal">yScale</code>: This scales in<a id="id173" class="indexterm"/> the height of a node</li><li class="listitem" style="list-style-type: disc"><code class="literal">zRotation</code>: This facilitates the<a id="id174" class="indexterm"/> rotation of a node in a clockwise or anti-clockwise direction</li><li class="listitem" style="list-style-type: disc"><code class="literal">frame</code>: <code class="literal">frame</code> is a rectangle containing the nodes <a id="id175" class="indexterm"/>content along with its x-scale, y-scale and z-rotation properties, ignoring the nodes children</li></ul></div><p>We know that the <code class="literal">SKNode</code> class does not draw anything by itself. So, what is the use of it? Well, we can use <code class="literal">SKNode</code> instances to manage our other nodes in different layers separately, or we can use them to manage different nodes in the same layer. Let's take a look at how we can do this.</p><div class="section" title="Using the SKNode object in the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Using the SKNode object in the game</h2></div></div></div><p>Now, we will discover what the <a id="id176" class="indexterm"/>various aspects of <code class="literal">SKNode</code> are used for. Say you have to make a body from different parts of sprites, such as a car. You can make it from sprites of wheels and body. The wheels and body of a car run in synchronization<a id="id177" class="indexterm"/> with each other, so that one controls their action together, rather than manage each part separately. This can be done by adding them as a child of the <code class="literal">SKNode</code> class object and updating this node to control the activity of the car.</p><p>The <code class="literal">SKNode</code> class object can be used for layering purposes in a game. Suppose we have three layers in our game: the foreground layer, which represents foreground sprites, the middle layer, which represents the middle sprites, and the background layer which represents background sprites.</p><p>If we want a parallax effect in our game, we will have to update each sprite's position separately or we can make three <code class="literal">SKNode</code> objects, referring to each layer, and add the sprites to their respective nodes. Now we have to update only these three nodes' position and the sprites will update their position automatically.</p><p>The <code class="literal">SKNode</code> class can be used to make some kind of check point in a game, which is hidden but performs or triggers some event when a player crosses them, such as a level end, bonus, or death trap.</p><p>We can remove or add the whole sub tree inside a node and perform the necessary functions, such as rotating, scaling, positioning, and so on.</p><p>Well, as we described that we can use the <code class="literal">SKNode</code> object as checkpoints in the game, it is important to recognize them in your scene. So, how we do that? Well the <code class="literal">SKNode</code> class provides a property for<a id="id178" class="indexterm"/> this. Let's find out more about it.</p></div><div class="section" title="Recognizing a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/>Recognizing a node</h2></div></div></div><p>The <code class="literal">SKNode</code> class provides a property with a name, to recognize the correct node. It takes string as a parameter. Either you can search a node by its name or you can use one of the two methods provided by <code class="literal">SKNode</code>, which <a id="id179" class="indexterm"/>are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">func childNodeWithName(name:String) -&gt; SKNode</code>: This function takes the name string as a parameter, and if it finds a node with a specific name, it returns that node or else it returns nil. If there is more than one node sharing the same name, it <a id="id180" class="indexterm"/>will return the first node in the search.</li><li class="listitem" style="list-style-type: disc"><code class="literal">func enumerateChildNodesWithName(name:String, usingBlock:((SKNode!,UnsafeMutablePointer&lt;ObjCBool&gt;)-&gt;Void)!)</code>: When you need all the nodes sharing the same name, use this function. This function takes the name and block as a parameter. In <code class="literal">usingBlock</code>, you need to provide two parameters. One matching node, and the other a pointer of type Boolean. In our game, if you remember, we used the <code class="literal">name</code> property inside <code class="literal">PlayButton</code> to recognize the node when a user taps on it. It's a very useful property to search for the desired node.</li></ul></div><p>So, let's have a quick look at other properties or methods of the <code class="literal">SKNode</code> class.</p></div><div class="section" title="Initializing a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/>Initializing a node</h2></div></div></div><p>There are two initializers to make<a id="id181" class="indexterm"/> an instance of <code class="literal">SKNode</code>. Both are available in iOS 8.0 or later.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">convenience init (fileNamed filename: String)</code>: This initializer is used for making a node by loading <a id="id182" class="indexterm"/>an archive file from main bundle. For this, you have to pass a file name with an <code class="literal">sks</code> extension in the main bundle.</li><li class="listitem" style="list-style-type: disc"><code class="literal">init()</code>: It is used to make a simple<a id="id183" class="indexterm"/> node without any parameter. It is useful for layering purposes in a game.</li></ul></div><p>As we already discussed the positioning of a node, let's discuss some functions and properties that are used to build a node tree.</p></div><div class="section" title="Building a node tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Building a node tree</h2></div></div></div><p>
<code class="literal">SKNode</code> provides some functions and <a id="id184" class="indexterm"/>properties to work with a node tree. Following are some of the functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">addChild(node:SKNode)</code>: This is a very common function and is used mostly to make a node tree<a id="id185" class="indexterm"/> structure. We already used it to add nodes to scenes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">insertChild(node:SKNode,atIndex index: Int)</code>: This is used when you have to insert a child in a specific<a id="id186" class="indexterm"/> position in the array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeFromParent()</code>: This simply<a id="id187" class="indexterm"/> removes a node from its parent.</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeAllChildren()</code>: This is used<a id="id188" class="indexterm"/> when you have to clear all the children in a node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeChildrenInArray(nodes:[AnyObject]!)</code>: This takes an array of <code class="literal">SKNode</code> objects and removes it from the<a id="id189" class="indexterm"/> receiving node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">inParentHierarchy(parent:SKNode) -&gt; Bool</code>: It takes an <code class="literal">SKNode</code> object to check as a parent of the<a id="id190" class="indexterm"/> receiving node, and returns a Boolean value according to that condition.</li></ul></div><p>There are some useful properties used in a node tree, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">children</code>: This is a read only<a id="id191" class="indexterm"/> property. It contains the receiving node's children in the array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">parent</code>: This is also a read only<a id="id192" class="indexterm"/> property. It contain the reference of the parent of the receiving node, and if there is none, then it returns nil.</li><li class="listitem" style="list-style-type: disc"><code class="literal">scene</code>: This too is a read only property. If the node is embedded in the scene, it will contain the<a id="id193" class="indexterm"/> reference of the scene, otherwise nil.</li></ul></div><p>In a game, we need some specific task on a node, such as changing its position from one point to another, changing sprites in a sequence, and so on. These tasks are done using actions on node. Let's talk about them now.</p></div><div class="section" title="Actions on a node tree"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Actions on a node tree</h2></div></div></div><p>Actions are required for <a id="id194" class="indexterm"/>some specific tasks in a game. For this, the <code class="literal">SKNode</code> class provides some basic functions, which are as follows.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">runAction(action:SKAction!)</code>: This function takes an <code class="literal">SKAction</code> class object as a parameter and performs the<a id="id195" class="indexterm"/> action on the receiving node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">runAction(action:SKAction!,completion block: (() -&gt; Void)!)</code>: This function takes an <code class="literal">SKAction</code> class object and a compilation block as object. When the action completes, it calls the block.</li><li class="listitem" style="list-style-type: disc"> <code class="literal">runAction(action:SKAction,withKey key:String!)</code>: This function takes an <code class="literal">SKAction</code> class object and a unique key, to identify this action and perform it on the receiving node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">actionForKey(key:String) -&gt; SKAction?</code>: This takes a <code class="literal">String</code> key as a parameter and returns an associative <code class="literal">SKAction</code> object for that key identifier. This happens if it exists, otherwise it returns nil.</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasActions() -&gt; Bool</code>: Through this action, if the node has any executing action, it returns <code class="literal">true</code>, or else <code class="literal">false</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeAllActions()</code>: This function removes all actions from the receiving node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeActionForKey(key:String)</code>: This takes <code class="literal">String</code> name as key and removes an action associated with that key, if it exists.</li></ul></div><p>Some useful properties to <a id="id196" class="indexterm"/>control these actions are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">speed</code>: This is used to speed<a id="id197" class="indexterm"/> up or speed down the action motion. The default value is <code class="literal">1.0</code> to run at normal speed; with increasing value, speed increases.</li><li class="listitem" style="list-style-type: disc"><code class="literal">paused</code>: This Boolean value determines whether an action on the node should be paused or <a id="id198" class="indexterm"/>resumed.</li></ul></div><p>Sometimes, we require changing a point coordinate system according to a node inside a scene. The <code class="literal">SKNode</code> class provides two functions to interchange a point's coordinate system with respect to a node in a scene. Let's talk about them.</p></div><div class="section" title="The coordinate system of a node"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>The coordinate system of a node</h2></div></div></div><p>We can convert a point with<a id="id199" class="indexterm"/> respect to the coordinate system of any node tree. The functions to do that, are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">convertPoint(point:CGPoint, fromNode node : SKNode) -&gt; CGPoint</code>: This takes a point in another node's coordinate system and the other node as its parameter, and returns a converted point according to the receiving node's coordinate system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">convertPoint(point:CGPoint, toNode node:SKNode) -&gt;CGPoint</code>: It takes a point in the<a id="id200" class="indexterm"/> receiving node's coordinate system and the other nodes in the node tree as its parameters, and returns the same point converted according to the other node's coordinate system.</li></ul></div><p>We can also determine<a id="id201" class="indexterm"/> if a point is inside a node's area or not.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">containsPoint(p:CGPoint) -&gt; Bool</code>: This returns the Boolean value according to the position of a point inside or outside of a receiving node's bounding box.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nodeAtPoint(p:CGPoint) -&gt; SKNode</code>: This returns the deepest descendant node that intersects the point. If that is not there, then it returns the receiver node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">nodesAtPoint(p:CGPoint) -&gt; [AnyObject]</code>: This returns an array of all the <code class="literal">SKNode</code> objects in the subtree that intersect the point. If no nodes intersect the point, an empty array is returned.</li></ul></div><p>Apart from these, the <code class="literal">SKNode</code> class provides some other functions and properties too. Let's talk about them.</p></div><div class="section" title="Other functions and properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Other functions and properties</h2></div></div></div><p>Some other functions and properties of the <code class="literal">SKNode</code> class are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">intersectsNode(node:SKNode) -&gt; Bool</code>: As the name suggests, it returns a Boolean value according to the<a id="id202" class="indexterm"/> intersection of the receiving node and another node from the function parameter.</li><li class="listitem" style="list-style-type: disc"><code class="literal">physicsBody</code>: It is a property of the <code class="literal">SKNode</code> class. The default value is nil, which means that this<a id="id203" class="indexterm"/> node will not take part in any physical simulation in the scene. If it contains any physical body, then it will change its position and rotation in accordance with the physical simulation in the scene.</li><li class="listitem" style="list-style-type: disc"><code class="literal">userData : NSMutableDictionary?</code>: The <code class="literal">userData</code> property is used to store data for a node in a<a id="id204" class="indexterm"/> dictionary form. We can store position, rotation, and many custom data sets about the node inside it.</li><li class="listitem" style="list-style-type: disc"><code class="literal">constraints: [AnyObject]?</code>: It contains an array of constraints <code class="literal">SKConstraint</code> objects to the<a id="id205" class="indexterm"/> receiving node. Constraints are used to limit the position or rotation of a node inside a scene.</li><li class="listitem" style="list-style-type: disc"><code class="literal">reachConstraints: SKReachConstraints?</code>: This is basically used to make restricted values for<a id="id206" class="indexterm"/> the receiving node by making an <code class="literal">SKReachConstraints</code> object. For example, to make joints move in a human body.</li><li class="listitem" style="list-style-type: disc">Node blending modes: The <code class="literal">SKNode</code> class declares an <code class="literal">enum SKBlendMode</code> of the <code class="literal">int</code> type to blend the receiving node's color by using source and destination pixel colors. The constant's used for this are as follows:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Alpha</code>: It is used to<a id="id207" class="indexterm"/> blend source and destination colors by multiplying the source alpha value</li><li class="listitem" style="list-style-type: disc"><code class="literal">Add</code>: It is used to add the source and destination colors</li><li class="listitem" style="list-style-type: disc"><code class="literal">Subtract</code>: It is used to subtract the source color from the destination color</li><li class="listitem" style="list-style-type: disc"><code class="literal">Multiply</code>: It is used to multiply the source color by the destination color</li><li class="listitem" style="list-style-type: disc"><code class="literal">MultiplyX2</code>: It is used to multiply the source color by the destination color, and after that, the resulting color is doubled</li><li class="listitem" style="list-style-type: disc"><code class="literal">Screen</code>: It is used to multiply the inverted source and the destination<a id="id208" class="indexterm"/> color respectively and it then inverts the final result color</li><li class="listitem" style="list-style-type: disc"><code class="literal">Replace</code>: It is used to replace the destination color by source color</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">calculateAccumulatedFrame()-&gt;CGRect</code>: We know that a node does not draw anything by itself, but if a node has descendants that draw content, then we may be required to know<a id="id209" class="indexterm"/> the overall frame size of that node. This function calculates the frame that contains the content of the receiver node and all of its descendants.</li></ul></div><p>Now, we are ready to see some basic <code class="literal">SKNode</code> subclasses in action. The classes we are going to discuss are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">SKLabelNode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SKCropNode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SKShapeNode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SKEmitterNode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SKLightNode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">SKVideoNode</code></li></ul></div><p>To study these classes, we are going to create six different <code class="literal">SKScene</code> subclasses in our project, so that we can learn them separately.</p><p>Now, having learned in detail about nodes, we can proceed further to utilize the concept of nodes in a game.</p></div></div></div>
<div class="section" title="Creating subclasses for our Platformer game"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Creating subclasses for our Platformer game</h1></div></div></div><p>With the theoretical understanding<a id="id210" class="indexterm"/> of nodes, one wonders how this concept is helpful in developing a game. To understand the development of a game using the concept of Nodes, we now go ahead with writing and executing code for our <span class="emphasis"><em>Platformer</em></span> game.</p><p>Create the subclasses of different nodes in Xcode, following the given steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">From the main menu, select <span class="strong"><strong>New File</strong></span> | <span class="strong"><strong>Swift</strong></span> | <span class="strong"><strong>Save As</strong></span> | <span class="strong"><strong>NodeMenuScene.swift</strong></span>:<p>Make sure <span class="strong"><strong>Platformer</strong></span> is ticked as the target. Now <span class="strong"><strong>Create</strong></span> and <span class="strong"><strong>Open</strong></span> and make the <code class="literal">NodeMenuScene</code> class by subclassing <code class="literal">SKScene</code>.</p></li><li class="listitem">Following the previous same steps as, make <code class="literal">CropScene</code>, <code class="literal">ShapeScene</code>, <code class="literal">ParticleScene</code>, <code class="literal">LightScene</code>, and <code class="literal">VideoNodeScene</code> files, respectively.</li><li class="listitem">Open the <code class="literal">GameViewController.swift</code> file and replace the <code class="literal">viewDidLoad</code> function by typing out the following code:<div class="informalexample"><pre class="programlisting">override func viewDidLoad() {
        super.viewDidLoad()

        let menuscene = NodeMenuScene()

        let skview = view as SKView

        skview.showsFPS = true
        skview.showsNodeCount = true
        skview.ignoresSiblingOrder = true
        menuscene.scaleMode = .ResizeFill

        menuscene.anchorPoint = CGPoint(x: 0.5, y: 0.5)
        menuscene.size = view.bounds.size
        skview.presentScene(menuscene)

    }</pre></div></li></ol></div><p>In this code, we just called our <code class="literal">NodeMenuScene</code> class from the <code class="literal">GameViewController</code> class. Now, it's time to add <a id="id211" class="indexterm"/>some code to the <code class="literal">NodeMenuScene</code> class.</p><div class="section" title="NodeMenuScene"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>NodeMenuScene</h2></div></div></div><p>Open the <code class="literal">NodeMenuScene.swift</code> file and type in the code as shown next. Do not worry about the length of the code; as<a id="id212" class="indexterm"/> this code is for creating the node <a id="id213" class="indexterm"/>menu screen, most of the functions are similar to creating buttons:</p><div class="informalexample"><pre class="programlisting">import Foundation
import SpriteKit

let BackgroundImage = "BG"
let FontFile = "Mackinaw1"

let sKCropNode = "SKCropNode"

let sKEmitterNode = "SKEmitterNode"

let sKLightNode = "SKLightNode"
let sKShapeNode = "SKShapeNode"
let sKVideoNode = "SKVideoNode"
class NodeMenuScene: SKScene {

    let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
    var labelNode : SKNode?
    var backgroundNode : SKNode?



    override func didMoveToView(view: SKView) {
        backgroundNode = getBackgroundNode()
        backgroundNode!.zPosition = 0
        self.addChild(backgroundNode!)
        labelNode = getLabelNode()
        labelNode?.zPosition = 1
        self.addChild(labelNode!)


    }
        func getBackgroundNode() -&gt; SKNode {
        var bgnode = SKNode()
        var bgSprite = SKSpriteNode(imageNamed: "BG")
        bgSprite.xScale = self.size.width/bgSprite.size.width
        bgSprite.yScale = self.size.height/bgSprite.size.height
        bgnode.addChild(bgSprite)
        return bgnode
    }
    func getLabelNode() -&gt; SKNode {
    var labelNode = SKNode()
        var cropnode = SKLabelNode(fontNamed: FontFile)
        cropnode.fontColor = UIColor.whiteColor()
        cropnode.name = sKCropNode
        cropnode.text = sKCropNode
        cropnode.position = CGPointMake(CGRectGetMinX(self.frame)+cropnode.frame.width/2, CGRectGetMaxY(self.frame)-cropnode.frame.height)
        labelNode.addChild(cropnode)
        var emitternode = SKLabelNode(fontNamed: FontFile)
        emitternode.fontColor = UIColor.blueColor()
        emitternode.name = sKEmitterNode
        emitternode.text = sKEmitterNode
        emitternode.position = CGPointMake(CGRectGetMinX(self.frame) + emitternode.frame.width/2 , CGRectGetMidY(self.frame) - emitternode.frame.height/2)
        labelNode.addChild(emitternode)

        var lightnode = SKLabelNode(fontNamed: FontFile)
        lightnode.fontColor = UIColor.whiteColor()
        lightnode.name = sKLightNode
        lightnode.text = sKLightNode
        lightnode.position = CGPointMake(CGRectGetMaxX(self.frame) - lightnode.frame.width/2 , CGRectGetMaxY(self.frame) - lightnode.frame.height)
        labelNode.addChild(lightnode)
        
        var shapetnode = SKLabelNode(fontNamed: FontFile)
        shapetnode.fontColor = UIColor.greenColor()
        shapetnode.name = sKShapeNode
        shapetnode.text = sKShapeNode
        shapetnode.position = CGPointMake(CGRectGetMaxX(self.frame) - shapetnode.frame.width/2 , CGRectGetMidY(self.frame) - shapetnode.frame.height/2)
        labelNode.addChild(shapetnode)

        var videonode = SKLabelNode(fontNamed: FontFile)
        videonode.fontColor = UIColor.blueColor()
        videonode.name = sKVideoNode
        videonode.text = sKVideoNode
        videonode.position = CGPointMake(CGRectGetMaxX(self.frame) - videonode.frame.width/2 , CGRectGetMinY(self.frame) )
        labelNode.addChild(videonode)

        return labelNode
    }
    var once:Bool = true
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        if !once {
            return
        }
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == sKCropNode {
                once = false
                var scene = CropScene()
                scene.anchorPoint = CGPointMake(0.5, 0.5)
                scene.scaleMode = .ResizeFill
                scene.size = self.size
                self.view?.presentScene(scene, transition:transitionEffect)
            }

            else if node.name == sKEmitterNode {
                once = false
                var scene = ParticleScene()
                scene.anchorPoint = CGPointMake(0.5, 0.5)
                scene.scaleMode = .ResizeFill
                scene.size = self.size
                self.view?.presentScene(scene, transition:transitionEffect)
            }
            else if node.name == sKLightNode {
                once = false
                var scene = LightScene()
                scene.scaleMode = .ResizeFill
                scene.size = self.size
                scene.anchorPoint = CGPointMake(0.5, 0.5)
                self.view?.presentScene(scene , transition:transitionEffect)
            }
            else if node.name == sKShapeNode {
                once = false
                var scene = ShapeScene()
                scene.scaleMode = .ResizeFill
                scene.size = self.size

                scene.anchorPoint = CGPointMake(0.5, 0.5)
                self.view?.presentScene(scene, transition:transitionEffect)
            }
            else if node.name == sKVideoNode {
                once = false
                var scene = VideoNodeScene()
                scene.scaleMode = .ResizeFill
                scene.size = self.size
                scene.anchorPoint = CGPointMake(0.5, 0.5)
                self.view?.presentScene(scene , transition:transitionEffect)
            }
        }
    }
}</pre></div><p>We will get the<a id="id214" class="indexterm"/> following screen from the previous code:</p><div class="mediaobject"><img src="graphics/4201_04_01.jpg" alt="NodeMenuScene"/><div class="caption"><p>The screen is obtained when we execute the NodeMenuScene.swift file</p></div></div><p>In the preceding code, after <code class="literal">import</code> statements, we defined some <code class="literal">String</code> variables. We are going to use these<a id="id215" class="indexterm"/> variables as <code class="literal">Label</code> names in the scene .We also added our font name as a string variable. Inside this class, we made two node references: one for background and the other for those labels which we are going to use in this scene. We are using these two nodes to make layers in our game. It is best to categorize the nodes in a scene, so that we can optimize the code. We make an <code class="literal">SKTransition</code> object reference of the flip horizontal effect. You can use other transition effects too.</p><p>Inside the <code class="literal">didMoveToView()</code> function, we just get the node and add it to our scene and set their <code class="literal">z</code> position.</p><p>Now, if we look at the <code class="literal">getBackgroundNode()</code> function, we can see that we made a node by the <code class="literal">SKNode</code> class instance, a background by the <code class="literal">SKSpriteNode</code> class instance, and then added it to the node and returned it. If you see the syntax of this function, you will see <code class="literal">-&gt; SKNode</code>. It means that this function returns an <code class="literal">SKNode</code> object.</p><p>The same goes in the function, <code class="literal">getLabelNode()</code>. It also returns a node containing all the <code class="literal">SKLabelNode</code> class objects. We have given a font and a name to these labels and set the position of them in the screen. The <code class="literal">SKLabelNode</code> class is used to make labels in Sprite Kit with many customizable options.</p><p>In the <code class="literal">touchBegan()</code> function, we get the information on which Label is touched, and we then call the appropriate scene with transitions.</p><p>With this, we have <a id="id216" class="indexterm"/>created a scene with the transition effect. By tapping on each button, you can see the transition effect.</p><div class="section" title="CropScene"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec01"/>CropScene</h3></div></div></div><p>In this scene, we are going to use the <code class="literal">SKCropNode</code> class object. This class is used to mask one node on another. We are going to use our play sprite as a mask and our background image as an image that is to be rendered according to the masking area. Open the <code class="literal">CropScene.swift</code> file and type<a id="id217" class="indexterm"/> in the code, as shown next:</p><div class="informalexample"><pre class="programlisting">import Foundation
import SpriteKit
class CropScene : SKScene {
    var play : SKSpriteNode?
    override func didMoveToView(view: SKView) {
        play = SKSpriteNode(imageNamed: "Play")
        var crop = SKCropNode()
        crop.maskNode = play
        crop.addChild(SKSpriteNode(imageNamed: "BG"))
        addChild(crop)
        addBackLabel()
    }
    func addBackLabel() {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "BACK"
        backbutton.text = "BACK"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))
       self.addChild(backbutton)
    }
    var once:Bool = true
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == "BACK" {
                if once {
                    once = false
                    let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
                    var scene = NodeMenuScene()
                    scene.anchorPoint = CGPointMake(0.5, 0.5)
                    scene.scaleMode = .ResizeFill
                    scene.size = self.size
                    self.view?.presentScene(scene, transition:transitionEffect)
                }
            }
        }
    }
}</pre></div><p>We will get the following<a id="id218" class="indexterm"/> screen, with the preceding code:</p><div class="mediaobject"><img src="graphics/4201_04_02.jpg" alt="CropScene"/><div class="caption"><p>The preceding screen is obtained when we execute the Cropscene.swift file</p></div></div><p>In this code, we just added a label for the back press of the <code class="literal">SKLabelNode</code> class object.</p><p>In this class, we added play image to the mask node of the <code class="literal">SKCropNode</code> object and added a background to<a id="id219" class="indexterm"/> this crop node. If you click on the <code class="literal">SKCropNode</code> label in the <code class="literal">NodeMenuScene</code>, you will see that the play image is working as a mask over the background image.</p></div><div class="section" title="ShapeScene"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec02"/>ShapeScene</h3></div></div></div><p>Now, open the <code class="literal">ShapeScene.swift</code> file and <a id="id220" class="indexterm"/>add the following code to create the <code class="literal">SKShapeNode</code> class:</p><div class="informalexample"><pre class="programlisting">import Foundation
import SpriteKit
class ShapeScene : SKScene {
    override func didMoveToView(view: SKView) {

            var shape = SKShapeNode()
            var path = CGPathCreateMutable()
            CGPathMoveToPoint(path, nil, 0, 0)
        CGPathAddLineToPoint(path, nil, 10  , 100)
        CGPathAddLineToPoint(path, nil, 20, 0)
        CGPathAddLineToPoint(path, nil, 10, -10)
        CGPathAddLineToPoint(path, nil, 0, 0)
        shape.path = path
        shape.fillColor = UIColor.redColor()
        shape.lineWidth = 4
        addChild(shape)
        addBackLabel()
    }
    func addBackLabel() {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "BACK"
        backbutton.text = "BACK"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))
        self.addChild(backbutton)
    }
    var once:Bool = true
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == "BACK" {
                if once {
                    once = false
                    let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
                    var scene = NodeMenuScene()
                    scene.anchorPoint = CGPointMake(0.5, 0.5)
                    scene.scaleMode = .ResizeFill
                    scene.size = self.size
                    self.view?.presentScene(scene, transition:transitionEffect)
                }
            }
        }
    }
}</pre></div><p>We will get the following screen with the previous code:</p><div class="mediaobject"><img src="graphics/4201_04_03.jpg" alt="ShapeScene"/><div class="caption"><p>This screen is obtained when we execute the ShapeScene.swift file</p></div></div><p>The <code class="literal">SKShapeNode</code> class is basically used to make runtime graphics in scene. In this example, we have created<a id="id221" class="indexterm"/> a drawing of four lines and then filled it with a color by using the <code class="literal">fillColor</code> property.</p></div><div class="section" title="ParticleScene"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec03"/>ParticleScene</h3></div></div></div><p>Now, open the <code class="literal">ParticleScene.swift</code> file and <a id="id222" class="indexterm"/>add the following code to create the <code class="literal">SKEmitterNode</code> class:</p><div class="informalexample"><pre class="programlisting">import Foundation.
import SpriteKit
class ParticleScene : SKScene {
    var emitternode :SKEmitterNode?
    override func didMoveToView(view: SKView) {
    var path = NSBundle.mainBundle().pathForResource("MagicParticle", ofType: "sks")
    emitternode = NSKeyedUnarchiver.unarchiveObjectWithFile(path!) as? SKEmitterNode
        self.addChild(emitternode!)
  addBackLabel()
    }
    func addBackLabel() {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "BACK"
        backbutton.text = "BACK"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))
        self.addChild(backbutton)
   }
    var once:Bool = true
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch:AnyObject in touches {
           var location = touch.locationInNode(self)
           emitternode?.position = location
           let node = self.nodeAtPoint(location)
            if node.name == "BACK" {
                if once {
                    once = false
                    let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
                    var scene = NodeMenuScene()
                    scene.anchorPoint = CGPointMake(0.5, 0.5)
                    scene.scaleMode = .ResizeFill
                    scene.size = self.size
                    self.view?.presentScene(scene, transition:transitionEffect)
                }
            }
       }
    }
}</pre></div><p>We get the following<a id="id223" class="indexterm"/> screen with the previous code:</p><div class="mediaobject"><img src="graphics/4201_04_04.jpg" alt="ParticleScene"/><div class="caption"><p>This screen is obtained when we execute the ParticleScene.swift file</p></div></div><p>We used the <code class="literal">SKEmitterNode</code> class object for the particle effect. Sprite Kit gives you many predefined particle<a id="id224" class="indexterm"/> effects. You can customize them according to your requirements. To make a particle effect, follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Right click on project explorer, <span class="strong"><strong>New File</strong></span> | <span class="strong"><strong>Resource</strong></span> | <span class="strong"><strong>SpriteKit Particle File</strong></span>.</li><li class="listitem">Choose a particle template from the list and then click on <span class="strong"><strong>Next</strong></span>.</li><li class="listitem"><span class="strong"><strong>Save As</strong></span>, name your particle system. We named it <code class="literal">MagicParticle</code>, in our project. Make sure that in the <span class="strong"><strong>Targets</strong></span> option, the <span class="strong"><strong>Platformer</strong></span> (project) is selected before you click on the <span class="strong"><strong>Create</strong></span> button.</li></ol></div><p>In the <span class="strong"><strong>Project Navigator</strong></span>, on the left side of screen, you will see the <code class="literal">MagicParticle.sks</code> file. If you click on this file, you can see the particle effect in the editor window. Now, on the right side panel, many options are available for particle, color, shape, and so on. You can select any value as per your liking.</p></div><div class="section" title="LightScene"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec04"/>LightScene</h3></div></div></div><p>Now, open the <code class="literal">LightScene.swift</code> file <a id="id225" class="indexterm"/>and add the following code to create the <code class="literal">SKLightNode</code> class:</p><div class="informalexample"><pre class="programlisting">import Foundation
import SpriteKit
class LightScene : SKScene {
    var lightNode : SKLightNode?
    override func didMoveToView(view: SKView) {
        var background = SKSpriteNode(imageNamed: "BG")
        background.zPosition = 0.5
        var scaleX =  self.size.width/background.size.width
        var scaleY =  self.size.height/background.size.height
        background.xScale = scaleX
        background.yScale = scaleY
        addChild(background)
        println(background.size)
        var playbutton = SKSpriteNode(imageNamed: "Play")
        playbutton.zPosition = 1
        playbutton.size = CGSizeMake(100, 100)
        playbutton.position = CGPointMake(-200, 0)
        addChild(playbutton)
        var playbutton2 = SKSpriteNode(imageNamed: "Play")
        playbutton2.zPosition = 1
        playbutton2.size = CGSizeMake(100, 100)
        playbutton2.position = CGPointMake(0, 100)
        addChild(playbutton2)
        var playbutton3 = SKSpriteNode(imageNamed: "Play")
        playbutton3.zPosition = 1
        playbutton3.size = CGSizeMake(100, 100)
        playbutton3.position = CGPointMake(200, 0)
        addChild(playbutton3)
        lightNode = SKLightNode()
        lightNode!.categoryBitMask = 1
        lightNode!.falloff = 1
        lightNode!.ambientColor = UIColor.greenColor()
        lightNode!.lightColor = UIColor.redColor()
        lightNode!.shadowColor = UIColor.blueColor()
        lightNode!.zPosition = 1
        addChild(lightNode!)
        playbutton.shadowCastBitMask = 1
        playbutton2.shadowCastBitMask = 1
        playbutton3.shadowCastBitMask = 1
        background.lightingBitMask = 1;
        addBackLabel()
    }
    func addBackLabel() {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "BACK"
        backbutton.text = "BACK"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))
        backbutton.zPosition = 3
        self.addChild(backbutton)
    }
    var once:Bool = true
    override func touchesMoved(touches: NSSet, withEvent event: UIEvent) {
        for touch : AnyObject in touches {
            let location = touch.locationInNode(self)
            lightNode!.position = location
            let node = self.nodeAtPoint(location)
            if node.name == "BACK" {
                if once {
                    once = false
                    let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
                    var scene = NodeMenuScene()
                    scene.anchorPoint = CGPointMake(0.5, 0.5)
                    scene.scaleMode = .ResizeFill
                    scene.size = self.size
                    self.view?.presentScene(scene, transition:transitionEffect)
                }
            }
        }
    }
}</pre></div><p>We will get the following screen, using the preceding code:</p><div class="mediaobject"><img src="graphics/4201_04_05.jpg" alt="LightScene"/><div class="caption"><p>The preceding screen is obtained when we execute the LightScene.swift file</p></div></div><p>In this class, we used a light source and set bitmasks to images. If you run the project, you will see that the background color is being affected by the lighting source, and other play images <a id="id226" class="indexterm"/>are casting shadows in the opposite direction. If you click on scene, the lighting source will change its position and shadows will also change themselves according to the source.</p></div><div class="section" title="VideoNodeScene"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec05"/>VideoNodeScene</h3></div></div></div><p>Now, open the <a id="id227" class="indexterm"/>
<code class="literal">VideoNodeScene.swift</code> file and add the following code to create the <code class="literal">SKVideoNode</code> class:</p><div class="informalexample"><pre class="programlisting">import Foundation
import SpriteKit
import AVFoundation
class VideoNodeScene : SKScene {
    var playonce :Bool = false
    var videoNode : SKVideoNode?
    override func didMoveToView(view: SKView) {
        var background = SKSpriteNode(imageNamed: "BG")
        background.zPosition = 0
        var scaleX =  self.size.width/background.size.width
        var scaleY =  self.size.height/background.size.height
        background.xScale = scaleX
        background.yScale = scaleY
        addChild(background)
        var fileurl = NSURL.fileURLWithPath(NSBundle.mainBundle().pathForResource
("Movie", ofType: "m4v")!)
        var player = AVPlayer(URL: fileurl)
        videoNode = SKVideoNode(AVPlayer: player)
        videoNode?.size = CGSizeMake(200, 150)
        videoNode?.zPosition = 1
        videoNode?.name = "Video"
        self.addChild(videoNode!)
        addBackLabel()
    }
    func addBackLabel() {
        var backbutton = SKLabelNode(fontNamed: FontFile)
        backbutton.fontColor = UIColor.blueColor()
        backbutton.name = "BACK"
        backbutton.text = "BACK"
        backbutton.position = CGPointMake(CGRectGetMinX(self.frame) + backbutton.frame.width/2 , CGRectGetMinY(self.frame))

        self.addChild(backbutton)
    }
    var once:Bool = true
    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            let node = self.nodeAtPoint(location)
            if node.name == videoNode?.name {
                if !playonce {
                        videoNode?.play()
                    playonce = true
                }

            }
            if node.name == "BACK" {
                if once {
                    once = false
                    let transitionEffect = SKTransition.flipHorizontalWithDuration(1.0)
                    var scene = NodeMenuScene()
                    scene.anchorPoint = CGPointMake(0.5, 0.5)
                    scene.scaleMode = .ResizeFill
                    scene.size = self.size
                    self.view?.presentScene(scene, transition:transitionEffect)
                }
            }
    }
    }

}</pre></div><p>We will get the<a id="id228" class="indexterm"/> following screen:</p><div class="mediaobject"><img src="graphics/4201_04_06.jpg" alt="VideoNodeScene"/><div class="caption"><p>The preceding screen is obtained when we execute the LightScene.swift file</p></div></div><p>To use audio and video in our scene, we have imported <code class="literal">AVFoundation</code> into our code. We have added a video file with the <code class="literal">.m4v</code> format in our project. We have used a file named <code class="literal">Movie.a4v</code> for this project. So, we are done with the coding part for this chapter. We learned six majorly<a id="id229" class="indexterm"/> used subclasses of <code class="literal">SKNode</code>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we learned about nodes in detail. We discussed many properties and functions of the <code class="literal">SKNode</code> class of Sprite Kit, along with its usage. Also, we discussed about the building of a node tree, and actions on a node tree. Now we are familiar with the major subclasses of <code class="literal">SKNode</code>, namely <code class="literal">SKLabelNode</code>, <code class="literal">SKCropNode</code>, <code class="literal">SKShapeNode</code>, <code class="literal">SKEmitterNode</code>, <code class="literal">SKLightNode</code>, and <code class="literal">SKVideoNode</code>, along with their implementation in our game.</p><p>In the next chapter, we will learn the basics of adding physics simulation in a Sprite Kit game. We will also learn about adding physics to the different nodes in our game. </p></div></body></html>