- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following recipes will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying default values in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using named arguments in functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the `RecyclerView` Adapter in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating getter setters in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing variable arguments to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function as a parameter to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring a `static` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `use` keyword in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Closure in Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function literals with receivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are the building blocks of any code. They help make our programs more
    modular, secure, and easy to understand. Functions are crucial in object-oriented
    programming as they play an important role in abstraction and encapsulation (two
    very important design principles). Kotlin brings a lot of updates to the way we
    use functions. It makes functional programming easier with the help of chaining
    and lambdas. In this chapter, we will learn recipes that will help us work with
    functions. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Specifying default values in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you come from the Java world, you might remember that we can''t specify
    a default value to methods. This means that we can''t do something like this in
    Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We need to write two methods for it, and it is known as *method overloading:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, suppose you have a function with three different kinds of parameters,
    such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you''ll have seven instances of method overloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin provides you with default values in the methods by which you can prevent
    an insane amount of method overloading. Some people might say, "Hey, why don't
    we use the builder pattern instead of method overloading?". Those people are right,
    but Kotlin's way is easier than that. Let's see how!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, parameters of functions can have default values, and they are used
    when the corresponding argument is omitted. This, in turn, reduces the number
    of overloads. The preceding example with three different types of parameters can
    be resolved easily in Kotlin with a lot less code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the mentioned code in the editor, run it, and check the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we didn't have to implement four different methods, and we could
    map the arguments. The default parameters are used when we don't call the methods
    by providing explicit parameters, so when you don't pass any parameters, it just
    uses all the default ones. With the help of named arguments, we can decrease the
    number of methods even further, but we will cover this in the next recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One thing to note is that default arguments will also work with constructors.
    So you can have a class declaration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about a data class, head on to the [Chapter 11](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e1822868-fcb7-4623-8727-eb961254acdf.xhtml), *How
    to create data class recipe.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can declare objects, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with the help of default values in the constructors, we are
    avoiding the need to implement multiple constructors, which we used to do in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that there is a catch here. We won''t be able to do this if you are
    creating objects in Java. This means that doing things as shown in the following
    code will not be accepted by Java. Now I know you''ll be like "What happened to
    100% interoperability with Java ?!":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We just need to do a small modification if we want to expose multiple overloads
    to Java callers, that is—namely adding `@JvmOverloads` to the constructors and
    functions with default values so that the preceding class declaration becomes
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, our method becomes this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a small price to pay, but the `@JvmOverloads` annotation helps our constructors
    and functions to have default values, called from the Java world too.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want our code to work only in the Kotlin world, then we don't need the
    `@JvmOverloads` annotation because Kotlin has its own rules by which it can work
    with default values in constructors and functions. Adding the `@JvmOverloads`
    annotation creates all the necessary overloads. So if you decompile your Kotlin
    bytecode, you will see all the overloaded versions of constructors and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using named arguments in functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe can be thought of as an extension to the previous recipe, *Specifying
    default values in functions*. Default parameters and named arguments in the function
    together can bring down the number of method overloads by a huge amount. We've
    already seen how to use default parameters in functions; now, let's see how to
    use name arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another step forward to reduce the number of overloads and increase code readability
    is to use named arguments. Let''s take look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the same example of the `foo` function, here''s how we can use named
    arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output that you will get by running the preceding code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The named arguments prevent us from overloads and also make our code much more
    readable. Also, we don''t need to put in all the arguments. What I mean is, if
    you just had two parameters—`a` and `c`—then you would have to do something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You have to add a default value to fill the space between `a` and `c`. However,
    with named arguments, you are able to use `foo(a=1,c="Custom string")` without
    needing default arguments in between.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One key thing to note is that when we call a function with both positional and
    named arguments, we need to place the positional arguments before the first named
    one. For example, the `foo(1,b = 0.1)` call is allowed, but `foo(a = 1, 0.1)`
    is not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default values and named arguments can bring down the number of overloads
    needed to a minimum, making the code size small and improving the code's readability.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RecyclerView Adapter in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RecyclerView` is among the most widely used elements in Android development.
    It is essentially used to display data in a list using an adapter. In this recipe,
    we will learn how to leverage great things in Kotlin to make `RecyclerView` much
    more efficient. We will also be using `DiffUtils`. It is available from 24.02\.
    According to the documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: DiffUtil is a utility class that can calculate the difference between two lists
    and output a list of update operations that converts the first list into the second
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The definition is self-explainatory. The `notifyDatasetChanged`is a very expensive
    operation of the adapter. The `DiffUtils` only updates the parts that were changed,
    unlike `notifyDatasetChanged`, which updates the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new Android project in Android Studio. You can also clone the [https://gitlab.com/aanandshekharroy/kotlin-cookbook](https://gitlab.com/aanandshekharroy/kotlin-cookbook) repository and
    check out the 1-recycler-view-in-kotlin branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this app, we will be creating a simple list of different Android flavors
    released by Google, something like what''s seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b54683bd-ccf2-4456-94b3-81583e451185.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is a floating action button; clicking it will update the
    order of the list. We will be updating the list (`RecyclerView`), but we will
    update it using `DiffUtils` instead of the `notifyDatasetChanged` method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s now follow these steps to create the app we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a list of Android flavors. So, we will first create
    a data class that takes in image and name of flavor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the type of image as `Int` because we will be using the IDs
    of drawable items. In the `drawable` folder, we will be keeping all the required
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will create a list of Android flavors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create an adapter. We will name it `AndroidFlavourAdapter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is quite standard for the general implementation of `RecyclerView`,
    except for the two things.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of these is the `loadImage` function, which is not a native function but
    an extension function, whose implementation is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Another thing is that we have defined the list of `AndroidFlavours` in the
    adapters. The `flavoursList` in the adapter is an `observable` property. This
    means the listener gets notified of changes to this property. Hence, we get the
    following construct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever we try to assign a value to the `flavourItems` variable, the
    construct under the `{ .. }` block is run, and we have old and new values to do
    an operation if we want. In this case, we will do it using the `notifyChanges` method.
    Let''s look at the `notifyChanges` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: I will explain the preceding code in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s set up the adapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shuffle` function will just randomize the order of the list of `AndroidFlavours`.
    The `.shuffle()` function is not a native function provided by Kotlin or Java, but
    an extension function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's dive into the `DiffUtils`. The `DiffUtils` requires two arrays/lists,
    one of which should be the old list and the other should be the new list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getNewListSize()`: This returns the size of the new list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getOldListSize()`: This method returns the size of the old list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`areItemsTheSame()`: This method is used to determine whether two objects represent
    the same item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`areContentsTheSame()`: This method is used to determine whether the two objects
    contain the same data. In our implementation, we are returning true if both objects
    have the same name and image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getChangePayload()`: When `areItemsTheSame()` returns true and `areContentsTheSame()`
    returns false, then `DiffUtils` calls this method to get the payload of changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our implementation of the preceding method, we are adding the change of
    name and image in the payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, after the diff calculation, the `DiffUtils` object dispatches the
    changes to the Adapter. To do that, we call the `dispatchUpdatesTo` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the changes from the data in the payload, you need to override `onBindViewHolder` *(*`holder:
    FlavourViewHolder`*,* `position: Int`*,* `payloads: MutableList<Any>?`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The changes in the payload are dispatched using the `notifyItemRangeChanged` method
    of the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documentation states that the `DiffUtils` might take some time to process
    the diff between two lists if the lists are too big, so this must be calculated
    on a background thread, for example, using `RxJava`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating getter setters in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have worked with Java, you probably know what a *getter-setter* is. Java
    has fields and getter-setters are the methods that are used to **access **(getter)
    and **modify **(setter) member variables. They are an essential part of encapsulation
    (one of the design principles).
  prefs: []
  type: TYPE_NORMAL
- en: However, in Kotlin, we don't have any fields, but we have **properties** instead.
    A property can have a custom implementation of an **accessor** and a **mutator.**
    In this recipe, we will see how we can implement custom accessors and mutators.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with. We will be using examples to
    understand the custom getter-setters of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to understand how custom getter-setters work in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a Kotlin `property` looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So if you use something like `val a =1`, you get a default `getter` and `setter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we can create a custom `getter`. Suppose we have a property
    whose value depends on another property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you''ll see the output in the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03cb3100-9ee4-4b7d-8892-2d2cc59edbf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we can modify the getter in the `get` method of the property.
    If the property type is inferred from the getter, we can also do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The result will be the same, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Java, we used to do something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to pull this off in Kotlin, it will look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dce9a56d-ffa5-4a0d-9573-69d304ed95b6.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we will get a warning from IDE suggesting that it is a recursive
    call. Why? Because when you are trying to set a value using`.isListBig`, you are
    already using a setter inside a setter, hence the **recursive cycle**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In order to get away from this recursive call and still implement a setter,
    you need the `field` keyword. So the preceding implementation will look something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When you initialize `isListBig` while declaring the property, the value is assigned
    to the backing field without invoking the setter. The `field` keyword is used
    to access the backing field, and it will be generated for a property if it uses
    the default implementation of at least one of the accessors, or if a custom accessor
    references it through the `field` identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to restrict the access of your setter, you can do so with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, suppose you are using some sort of dependency injection. You can do it
    with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `set`, you can also have a custom implementation of `get`.  Let''s
    look at an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say that we are trying to access the `name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you''ll see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60f65486-b3f3-440f-aca3-691f96c2f84f.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that we have used `field` in the `get()` method too. It's the same backing
    field that we explained earlier.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing to note here is that you cannot implement a custom getter or setter
    for your property in the constructor. You need to declare a property in the body
    of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One key thing to note here is that you need to keep the visibility of the getter
    exactly similar to the visibility of the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is perfectly valid, though it's redundant to place the same
    access modifier again, hence it's better to omit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The setter, on the other hand, can have an access modifier less permissive
    than the property. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is valid because the access modifier of the setter, `private`,
    is less permissive than the property''s access modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, however, is not valid, as `protected` is less permissive
    than `public`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing variable arguments to a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of scenarios in which we need to pass variable arguments to
    a function. In Kotlin, we can do that using the `vararg` modifier. In this recipe,
    we will go through all the ways of doing that. We will look at a few examples
    to demonstrate how to use this feature of Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install the preferred development environment that compiles and
    runs Kotlin. You can also use the command line for this purpose, for which you
    need Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    for your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go through the following steps, where we demonstrate how to pass a variable
    number of arguments to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `vararg`, we can pass comma-separated arguments to a function, where
    we have defined the single argument to a method as `vararg`, as in the following
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you already have an array of values, you can directly pass it using
    the `*` spread operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So basically, `vararg` tells the compiler to take the passed arguments and wrap
    them into an array.
  prefs: []
  type: TYPE_NORMAL
- en: The spread operator, on the other hand, simply tells the compiler to unwrap
    array members and pass them as separate arguments. The spread operator—that is, `*`–is
    put just before the name of the array being passed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, obviously one may always need to pass other arguments, named arguments,
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example code, we try to pass another argument other than `vararg`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next example, the first argument is similar to the `vararg` type, but
    it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'So usually, `vararg` is the last argument passed, but what if we want to pass
    other arguments after `vararg`? We can, but they have to be named. That is why
    the following code will not compile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It does not compile because the last string passed in it is considered part
    of `vararg`, and the compiler throws an error because we did not pass the value
    of `c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do it correctly, we need to pass `c` as a named argument, just as shown
    here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vararg` modifier tells the compiler to take all comma-separated arguments
    and wrap them into an array, while `*`—that is the spread operator—unwraps elements
    of the array and passes them as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we want the first argument to have a default value, like in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We want all arguments to be considered as part of `vararg`, but the compiler
    reads the first argument as `b`. In this case, naming the passed arguments can
    solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the compiler understands that the value of `b` is not
    passed, and it takes the default value. Similarly, if you want to have two `vararg`
    in your function, you will need to pass named arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Passing a function as a parameter to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin gives us the power to declare *high-order functions*. In a high-order
    function, we can pass and return functions as parameters. This is an extremely
    useful feature and makes our code much more easy to work with. In fact, many of
    the Kotlin library’s functions are high order, such as `map`. In Kotlin, we can
    declare functions and function references as values that are then passed in to
    the function. In this section, we will first understand how to declare lambdas
    and then how to pass them into a function.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/) to
    compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    as the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s follow these steps to understand the working of high-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by understanding how we declare functions as lambdas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we declared two lambdas: one (`funcMultiply`)
    that takes two integers and returns an integer, and another (`funcSayHi`) lambda
    that takes a string and returns a unit—that is, it returns nothing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Although we did not need to declare the type of arguments and the return type
    in the preceding example, in some cases we need to explicitly declare the argument
    types and return types. We do this in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'So now that we have a general idea of how lambdas work, let''s try and pass
    one in another function—that is, we will try a high-order function. Check out
    this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Yup, it is as simple as that—create a function lambda and pass it into the function.
    So this is just one aspect of a high-order function—that is, we can pass a function
    as an argument to the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another use of high-order functions is to return a function. Consider the following
    example where we need a function that transforms the total price of an order according
    to certain conditions. Kind of like in an e-commerce site, but way simpler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note how we need to change functions that we apply based on certain conditions
    so that we return a function that suits the conditions. We assign the returned
    function to a variable and then we can just put `append ()` in front of the variable
    to use it as a function, just like we did with the lambdas. This works because
    the high-order function is essentially returning a lambda.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, we can assign a function to a variable, and then we can pass it into
    a function or return it from a function. This is because it's essentially declared
    like a variable. This is done using a lambda declaration of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a static function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Static functions** are very useful as they help us prevent copying the same
    methods in multiple objects so you can follow the **don''t repeat yourself** (**DRY**)
    rule. They are also useful when you don''t need to create an instance of an object.
    In Kotlin, we don''t have static methods/functions and variables, like we did
    in Java, but we can still achieve the same results. Let''s see how!'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with. We will be learning about static
    functions by going through the examples and their workings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the use cases of static methods is that we can prevent multiple copying
    of the same methods in different classes, and also that we don't need to create
    an object of the enclosing class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin recommends creating package-level functions. If you are coming from
    the Java world, this probably won''t make any sense to you as this isn''t supported
    in Java. Let''s see how it''s done in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to create a Kotlin file with the `.kt` extension and just declare
    the method that you''ll be using in many places. I have created a `SampleClass.kt`
    file and have added a method that we will be calling from other classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I''ll call this method from `HelloWorld.kt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Since the function was present in `packageA`, we used the `import` statement.
    This way, we followed DRY and didn't need to create an instance of any class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another way to do it is by putting methods or variables in an object declaration.
    So we can modify the `SameClass.kt` into the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Any method or variable under object declaration will work as a `static` method
    or variable. In order to access it, we can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is much like how we call static methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, suppose you want the class name as a qualifier and access elements
    of the class. You can still use it using the `companion` keyword. Here''s how
    it will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to call the method under the `companion` object, you''ll need to
    access it like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Companion` seems like an eyesore to you, you can use the `@JvmStatic` annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can access it using `SampleClass.foo()`, just like you do in a Kotlin
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the use keyword in Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some situations where if you use a resource (for example, a file)
    then you have to take care of its lifecycle so that you don't leak resources.
    For example, if you read from a file, you need to close it after use, or else
    you'll leave it in an unstable state. Java 7 brought an update that could handle
    this without a need to handle it explicitly. Kotlin also provides this feature,
    but in a much easier way. It does so by using the `use` method. We will learn about
    this in the following recipe. So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take the following steps to understand the `use` function of Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the `use` keyword, we will need to go back to Java. Prior to
    Java 7, managing the resources that needed to be closed was a bit cumbersome.
    For example, look at the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Let's examine the preceding code. We know an exception can be thrown inside
    the `try` block when we use the `input` object. However, it can also be thrown
    in the `finally` block, because we are trying to close the `input` object. Now,
    the `finally` block will be called whether or not the `try` block throws an exception.
    Suppose both the `try` and `finally` blocks throw exceptions—which one of the
    two will propagate? The answer is that the exception will be thrown in the `finally`
    block, even if the exception of `try` would make more sense here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Java 7 brought an update to this problem by introducing the try-with-resource
    construct, which looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: When the `try` block finishes executing, the `FileInputStream` object is closed
    automatically. Also, if both the operations—`input.read()` and the closing of
    the input object—throw exceptions, the exception thrown by `input.read()` will
    propagate. The `use` keyword of Kotlin does the exact same work. In this section,
    we will see how.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the preceding example, we saw in Java will look something like the following
    in Kotlin if we implement the `use` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`use` accepts a function literal and is defined as an extension on an instance
    of closeable. It will close down the resource, just like the try-with-resources
    construct, after the function'
  prefs: []
  type: TYPE_NORMAL
- en: has completed, whether an exception was raised or not.
  prefs: []
  type: TYPE_NORMAL
- en: Working with closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MDN ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures))
    says this:'
  prefs: []
  type: TYPE_NORMAL
- en: '“A closure is a special kind of object that combines two things: a function,
    and the environment in which that function was created. The environment consists
    of any local variables that were in-scope at the time the closure was created”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closures** in functional programming are the functions that are *aware* of
    their surroundings. By this, I mean that a closure function has access to the
    variables and parameters defined in the outer scope. Remember that in Java and
    traditional procedural programming, the variables were tied to the scope, and
    as soon as the block got executed, local properties were blown out of the memory.
    Java 8 lambdas can access outer variables, but can''t modify them, and this limits
    the capabilities if you try to do functional programming in Java 8\. Let''s take
    a look at an example where we work with closures in Kotlin.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will be using IntelliJ IDEA for writing and executing our code. You can use
    whatever development environment you are comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will simply create an array of integers and calculate its
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `sum` variable is defined in the outer scope;
    still, we are able to access and modify it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to learn more about high-order functions or closures, head on to
    the *Passing a function as a parameter to another* recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Function literals with receivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Function literal** is a function that is not declared but that is passed
    in as an expression. Lambdas and anonymous functions are function literals. In
    Kotlin, we can call a function literal with a receiver object, and we can call
    methods on the receiver object inside the body of the function literal, quite
    like extension functions. In this recipe, we will learn how to use function literals
    with receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/) to
    compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    for development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to understand function literals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple function literal on a `String`, which returns a
    string added to the receiver string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: A function literal has access to the receiver it has been called on, and it
    can access methods associated with that receiver.
  prefs: []
  type: TYPE_NORMAL
- en: We can also pass the receiver as a parameter in an ordinary function, where
    the first parameter is for a receiver. This can be useful in scenarios where we
    need to use an ordinary function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So `String.(String) -> Int` is similar to `(String, String) -> Int` is compatible.
    Check out the following example :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If the receiver type can be inferred, then lambda can be used as the function
    literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'So basically, we can call a function literal on a receiver object, and inside
    the body of the function, we can access and call methods on a receiver object,
    similar to an extension function in Kotlin. The following is the syntax for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Working with anonymous functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Kotlin, we can have functions as expressions by creating lambdas. Lambdas
    are function literals—that is, they are not declared as they are expressions and
    can be passed as parameters. However, we cannot declare return types in lambdas.
    Although the return type is inferred automatically by Kotlin compiler in most
    cases, for cases where it cannot be inferred on its own or it needs to be declared
    explicitly, we use anonymous functions. In this recipe, we will see how to use
    anonymous functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    for the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following steps, we will learn about anonymous functions with the help
    of some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by declaring a function as a lambda:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, we have declared two lambdas: one (`funcMultiply`)
    that takes two integers and returns an integer, and another (`funcSayHi`) lambda
    that takes a string and returns a unit—that is, it returns nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although in the preceding example we did not need to declare the type of arguments
    and return type, in some cases we need to explicitly declare the argument types
    and return types. We do that in the following way, by means of an anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we have a general idea of how anonymous functions work. Now, let''s
    try and pass one in another function—that is, we will try a high-order function.
    Check out this code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'So basically, an anonymous function is declared just like a regular function,
    but without a name. The body can be an expression, as in the following example,
    or a block, as in the preceding example. One thing to note is that parameters
    are always passed inside the parentheses in the case of anonymous functions, unlike
    in lambda expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting difference between a lambda and an anonymous function is
    that in a lambda, the return statement returns from the enclosing function, whereas
    in an anonymous function, it simply returns from the function itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One can omit the parameter type and return type from an anonymous function as
    well if it can be inferred on its own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Anonymous functions can access and modify variables inside their closures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So basically, one can declare an anonymous function just like a regular function
    without a name (hence, the name anonymous). It can be an expression or a code
    block.
  prefs: []
  type: TYPE_NORMAL
