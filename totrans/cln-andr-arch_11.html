<html><head></head><body>
		<div><h1 id="_idParaDest-86"><em class="italic"><a id="_idTextAnchor090"/>Chapter 8</em>: Implementing an MVVM Architecture</h1>
			<p>In this chapter, we will look at how data can be presented by Android applications to end users. We will look over the available architecture patterns for data presentation and analyze the differences between them. Later, we will look at the <strong class="bold">Model-View-ViewModel (MVVM)</strong> pattern, the role it plays in separating business logic and user interface updates, and how we can implement it using <strong class="bold">Android Architecture Components</strong>. Finally, we will look at how we can split the presentation layer across multiple library modules. In the exercises of this chapter, we will integrate the layers built in the previous chapters with a presentation layer built using MVVM, we will create a presentation layer that will plug into the domain layer to fetch and update the data, and we will also look at how we handle common logic between different modules in the presentation layer. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Presenting data in Android applications</li>
				<li>Presenting data with MVVM</li>
				<li>Presenting data in multiple modules</li>
			</ul>
			<p>By the end of the chapter, you will be able to implement the MVVM architecture pattern in an Android application using the ViewModel architecture component and be able to split the presentation layer into separate library modules.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>This chapter has the following hardware and software requirements:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3FZJWIl">https://bit.ly/3FZJWIl</a></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor092"/>Presenting data in Android applications</h1>
			<p>In this section, we will look at <a id="_idIndexMarker528"/>various architecture patterns suitable for presenting data in an Android application and analyze their benefits and <a id="_idIndexMarker529"/>drawbacks.</p>
			<p>Early Android applications relied <a id="_idIndexMarker530"/>on a pattern similar to the <code>android.widget.View</code> hierarchy, and the Model is responsible for managing the application's data. The relationship between the components would look something like the following:</p>
			<div><div><img src="img/Figure_8.01_B18320.jpg" alt="Figure 8.1 – Android MVC relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Android MVC relationship</p>
			<p>From <em class="italic">Figure 8.1</em>, we can see that the Controller represented by the activity would interact with the Model to fetch and manipulate the data, and then it would update the View with the relevant information. </p>
			<p>The idea is to have each <code>Activity</code> sandboxed as much as possible so that they can be offered and shared between multiple applications (like how the Camera application is opened by other applications to take photos and offer those photos to those applications). Because of this, activities need to be started using intents and not by instantiating them. By removing the ability to instantiate an <code>Activity</code> directly, we lose the ability to inject dependencies through the constructor. Another factor we need to consider is that activities have life cycle states, and we inherit these states in each <code>Activity</code> in our application. All these factors combined make an <code>Activity</code> very hard or next to impossible to unit<a id="_idIndexMarker531"/> test unless we use a library such as <strong class="bold">Robolectric</strong> or rely on instrumented tests on an Android device or emulator. Both options are slow and, in the case of instrumented tests, can be expensive when we need to run the tests in testing<a id="_idIndexMarker532"/> clouds such as <strong class="bold">Firebase Test Lab</strong>. </p>
			<p>To solve the problem of unit testing logic that was present in activities and later fragments, various<a id="_idIndexMarker533"/> adaptations of the <code>Activity</code> along with the <code>android.widget.View</code> hierarchy becomes the View, the Presenter is responsible for fetching <a id="_idIndexMarker536"/>the data from the model and performing the logic required, updating the View, and the Model has the same responsibility as in MVC to handle the application's data. The relationship between these components looks like the following figure:</p>
			<div><div><img src="img/Figure_8.02_B18320.jpg" alt="Figure 8.2 – MVP relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – MVP relationship</p>
			<p>The interesting aspect of the relationship between the components is the relationship between the Presenter and the View, which goes both ways. The Presenter will update the View with the relevant data, but the View will also invoke the Presenter, if necessary for user interactions. Because of the relationship between the two components, the definition of a contract is required, which looks like the following:</p>
			<pre>interface Presenter {
    fun loadUsers()
    fun validateInput(text: String)
}
interface View {
    fun showUsers(users: List&lt;User&gt;)
    fun showInputError(error: String)
} </pre>
			<p>Here, we<a id="_idIndexMarker537"/> have a <code>View</code> interface and a <code>Presenter</code> interface. The implementation of the <code>Presenter</code> might look <a id="_idIndexMarker538"/>something like this:</p>
			<pre>class PresenterImpl(
    private val view: View,
    private val getUsersUseCase: GetUsersUseCase
) : Presenter {
    private val scope = CoroutineScope(Dispatchers.Main)
    override fun loadUsers() {
        scope.launch {
            getUsersUseCase.execute()
                .collect { users -&gt;
                    view.showUsers(users)
                }
        }
    }
    override fun validateInput(text: String) {
        if (text.isEmpty()) {
            view.showInputError("Invalid input")
        }
    }
}</pre>
			<p>Here, the <code>PresenterImpl</code> class has a dependency on the <code>View</code> and on a <code>GetUsersUseCase</code> object, which<a id="_idIndexMarker539"/> will return a <code>Flow</code> object containing a list of users. When the <code>Presenter</code> receives the list of users, it will call the <code>showUsers</code> method <a id="_idIndexMarker540"/>from the <code>View</code>. When the <code>validateInput</code> method is called, the <code>Presenter</code> will check whether the text is empty and invoke the <code>showInputError</code> method from the <code>View</code> with an error message. The implementation of the <code>View</code> might look like the following:</p>
			<pre>class MainActivity : ComponentActivity(), View {
    @Inject
    private lateinit var presenter: Presenter
    private lateinit var usersAdapter: UsersAdapter
    private lateinit var editText: EditText
    private lateinit var errorView: TextView
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        …
        editText.addTextChangedListener(object : 
            TextWatcher {
            …
            override fun afterTextChanged(s: Editable?) {
                presenter.validateInput(s?.toString().orEmpty())
            }
        })
        presenter.loadUsers()
    }
    override fun showUsers(users: List&lt;User&gt;) {
        usersAdapter.add(users)
    }
    override fun showInputError(error: String) {
        errorView.text = error
    }
}</pre>
			<p>Here, we<a id="_idIndexMarker541"/> implement the <code>View</code> interface in <code>MainActivity</code>; in the implementation of the methods, we call the<a id="_idIndexMarker542"/> appropriate <code>View-</code> related classes to show the relevant data, such as showing the error message for an invalid input in a <code>TextView</code> object and setting the data in a <code>RecyclerView.Adapter</code> object. For validating the input, when the text changes in an <code>EditText</code> object, it will invoke the <code>Presenter</code> to validate the new text. The <code>Presenter</code> dependency will be injected using some form of dependency injection. </p>
			<p>Because presenters will end up <a id="_idIndexMarker543"/>performing background operations, we<a id="_idIndexMarker544"/> run the risk of causing <code>Context</code> leaks. This means that we need to factor the life cycle of the <code>Activity</code> into the MVP contract. To achieve this, we will need to define a <code>close</code> method in the <code>Presenter</code>:</p>
			<pre>interface Presenter {
    …
    fun close()
}</pre>
			<p>In the preceding snippet, we added the <code>close</code> method, which will be called in the <code>onDestroy</code> method of the <code>Activity</code> as follows:</p>
			<pre>override fun onDestroy() {
        presenter.close()
        super.onDestroy()
}</pre>
			<p>The implementation of the <code>close</code> method will have to clean up all the resources that might cause any leaks:</p>
			<pre>class PresenterImpl(
    private val view: View,
    private val getUsersUseCase: GetUsersUseCase
) : Presenter {
    private val scope = CoroutineScope(Dispatchers.Main)
    …
    override fun close() {
        scope.cancel()
    }
}</pre>
			<p>Here, we are canceling the subscription to the <code>Flow</code> object so that we will not receive any updates after the <code>Activity</code> is destroyed. </p>
			<p>In this section, we have looked <a id="_idIndexMarker545"/>at previous architecture patterns used<a id="_idIndexMarker546"/> in Android applications, from the MVC-like approach that was used in early Android applications to MVP, which aimed to solve some of the problems of the initial approach. Although MVP was popular in the past and is still present in some Android applications, it has slowly been phased out, mainly because of the release of Android Architecture Components, which rely on the MVVM pattern, and additionally, Jetpack Compose, which works better with data flows, which are more suited to MVVM. In the section that follows, we will look at the MVVM architecture pattern and how it is different from MVP as a concept. </p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor093"/>Presenting data with MVVM</h1>
			<p>In this section, we will analyze the <strong class="bold">Model-View-ViewModel</strong> architecture pattern and how it is implemented for <a id="_idIndexMarker547"/>Android applications.</p>
			<p>MVVM represents a different <a id="_idIndexMarker548"/>approach to the Humble Object pattern, which attempts to extract the logic out of activities and fragments. In MVVM, the View is represented by activities and fragments as it was in MVP, the Model plays the same role, managing the data, and the ViewModel sits between the two by requesting the data from the Model when the View requires it. The relationship between the three is as follows:</p>
			<div><div><img src="img/Figure_8.03_B18320.jpg" alt="Figure 8.3 – MVVM relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – MVVM relationship</p>
			<p>In <em class="italic">Figure 8.3</em>, we see a unidirectional relationship between the three components. The View has a dependency on the ViewModel, and the ViewModel has a dependency on the Model. This allows for more flexibility because multiple Views can use the same ViewModel. For the data to be updated in the View, MVVM requires an implementation of the <strong class="bold">Observer</strong> pattern. This means that the ViewModel uses an <strong class="bold">Observable</strong>, which the View will subscribe to and react to changes in the data. </p>
			<p>To develop Android applications, we have the possibility of using the Android Architecture Components libraries, which provide a <code>ViewModel</code> class that solves the issue of activity and fragment life cycles, combined with coroutine extensions useful for subscribing to flows or coroutines to stop the emission of data when the activities and fragments are in invalid <a id="_idIndexMarker549"/>states for data to be displayed and to avoid context leaks.</p>
			<p>From the<a id="_idIndexMarker550"/> perspective of <code>LiveData</code> (which acts as the observable that the View can subscribe to). An example of a <code>ViewModel</code> class might look like the following:</p>
			<pre>class MyViewModel(
    private val getUsersUseCase: GetUsersUserUseCase
) : ViewModel() {
    private val _usersFlow =
        MutableStateFlow&lt;List&lt;UiUser&gt;&gt;(listOf&lt;UiUser&gt;())
    val usersFlow: StateFlow&lt;List&lt;UiUser&gt;&gt; = _usersFlow
    fun load() {
        viewModelScope.launch {
            getUsersUseCase.execute()
                .map {
                    // Convert List&lt;User&gt; to List&lt;UiUser&gt;
                }
                .collect {
                    _usersFlow.value = it
                }
        }
    }
}</pre>
			<p>Here, we load a list of <code>User</code> objects <a id="_idIndexMarker554"/>and then keep that list inside a <code>StateFlow</code> object. This <code>StateFlow</code> object replaces <code>LiveData</code> and <a id="_idIndexMarker555"/>represents the observable that the View will subscribe to. When the View requires the list of users, it will invoke the <code>load</code> method.</p>
			<p>In this section, we have analyzed the MVVM architecture pattern and the difference between it and the MVP pattern. In the following section, we will look at how we can present data using MVVM inside an Android application.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>Exercise 08.01 – Implementing MVVM</h2>
			<p>Modify <em class="italic">Exercise 07.02</em>, <em class="italic">Building a local data source</em>, of <a href="B18320_07_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 7</em></a>, <em class="italic">Building Data Sources</em>, so that a new <a id="_idIndexMarker556"/>module called <code>presentation-posts</code> is created. The module will be responsible for displaying the data from <code>GetPostsWithUsersWithInteractionUseCase</code> using MVVM. The data will be displayed in the following format:</p>
			<ul>
				<li>A header with the following text: "Total click count: x" where x is the number of clicks taken from the <code>totalClicks</code> field in the <code>Interaction</code> class</li>
				<li>A list of posts where each row contains the following: "Author: x" and "Title: y" where x is the <code>name</code> field in the <code>User</code> class, and y is the <code>title</code> field in the <code>Post</code> class</li>
				<li>A loading view for when the data is being loaded</li>
				<li>A <code>Snackbar</code> view for when there is an error</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ol>
				<li>Create the <code>presentation-post</code> module.</li>
				<li>Create a new sealed class called <code>UiState</code>, which will have as subclasses <code>Loading</code>, <code>Error</code> (which will hold an error message), and <code>Success</code> (which will hold the post data).</li>
				<li>Create a new class called <code>PostListItemModel</code>, which will have <code>id</code>, <code>author</code>, and <code>name</code> as fields.</li>
				<li>Create a new class called <code>PostListModel</code>, which will have a <code>headerText</code> field and a list of <code>PostListItemModel</code> objects.</li>
				<li>Create a new class called <code>PostListConverter</code>, which will convert a <code>Result.Success</code> object into a <code>UiState.Success</code>, which holds the <code>PostListModel</code> object and will convert a <code>Result.Error</code> object into a <code>UiState.Error</code> object.</li>
				<li>Create a new class called <code>PostListViewModel</code>, which will load the data from <code>GetPostsWithUsersWithInteractionUseCase</code>, convert the data using <code>PostListConverter</code>, and store <code>UiState</code> in <code>StateFlow</code>.</li>
				<li>Create a new Kotlin file, which will contain <code>@Composable</code> methods responsible for drawing the UI.</li>
				<li>Modify <code>MainActivity</code> in the <code>app</code> module so that it will display the list of posts.</li>
			</ol>
			<p>Follow these steps to <a id="_idIndexMarker557"/>complete the exercise:</p>
			<ol>
				<li value="1">Create a new module called <code>presentation-post</code>, which will be an Android library module.</li>
				<li>Make sure that in the top-level <code>build.gradle</code> file, the following dependencies are set:<pre>buildscript {
    …
    dependencies {
        classpath gradlePlugins.android
        classpath gradlePlugins.kotlin
        classpath gradlePlugins.hilt
    }
}</pre></li>
				<li>In the same file, add the persistence libraries to the library mappings:<pre>buildscript {
    ext {
        …
        versions = [
                …
                viewModel            : "2.4.0",
                navigationCompose    : "2.4.0-rc01",
                hiltNavigationCompose: "1.0.0-rc01",
                …
        ]
        …
        androidx = [
                …
                viewModelKtx           : "androidx.
                    lifecycle:lifecycle-viewmodel-
                        ktx:${versions.viewModel}",
                viewModelCompose       : "androidx.
                    lifecycle:lifecycle-viewmodel- 
                       compose:${versions.viewModel}",
                navigationCompose      : "androidx.
                navigation:navigation-compose:$
                    {versions.navigationCompose}",
                hiltNavigationCompose  : "androidx.
                    hilt:hilt-navigation-compose:$
                     {versions.hiltNavigationCompose}"
        ]
        …
    }
    …
}</pre></li>
			</ol>
			<p>Here, we have added dependencies for the ViewModel library as well as the Navigation library (which will be used in later exercises).</p>
			<ol>
				<li value="4">In the <code>build.gradle</code> file of the <code>presentation-post</code> module, make sure that the following <a id="_idIndexMarker558"/>plugins are present:<pre>plugins {
    id 'com.android.library'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>In the same file, change the configurations to the ones defined in the top-level <code>build.gradle</code> file:<pre>android {
    compileSdk defaultCompileSdkVersion
    defaultConfig {
        minSdk defaultMinSdkVersion
        targetSdk defaultTargetSdkVersion
        …
    }
    …
    compileOptions {
        sourceCompatibility javaCompileVersion
        targetCompatibility javaCompileVersion
    }
    kotlinOptions {
        jvmTarget = jvmTarget
        useIR = true
    }
    buildFeatures {
        compose true
    }
    composeOptions {
        kotlinCompilerExtensionVersion versions.
            compose
    }
}</pre></li>
			</ol>
			<p>Here, we keep the same configuration consistent with the other modules in the application, and we<a id="_idIndexMarker559"/> integrate the Jetpack Compose configuration.</p>
			<ol>
				<li value="6">In the same file, add the dependencies to the networking libraries and domain modules:<pre>dependencies {
    implementation(project(path: ":domain"))
    implementation coroutines.coroutinesAndroid
    implementation androidx.composeUi
    implementation androidx.composeMaterial
    implementation androidx.viewModelKtx
    implementation androidx.viewModelCompose
    implementation androidx.lifecycleRuntimeKtx
    implementation androidx.navigationCompose
    implementation di.hiltAndroid
    kapt di.hiltCompiler
    testImplementation test.junit
    testImplementation test.coroutines
    testImplementation test.mockito
}</pre></li>
				<li>In the <code>presentation-post</code> module, create a package called <code>list</code>.</li>
				<li>In the <code>list</code> package, create<a id="_idIndexMarker560"/> the <code>UiState</code> class:<pre>sealed class UiState&lt;T : Any&gt; {
    object Loading : UiState&lt;Nothing&gt;()
    data class Error&lt;T : Any&gt;(val errorMessage: 
        String) : UiState&lt;T&gt;()
    data class Success&lt;T : Any&gt;(val data: T) : 
        UiState&lt;T&gt;()
}</pre></li>
				<li>In the same package, create a file called <code>PostListModels</code>.</li>
				<li>In the <code>PostListModels</code> file, create the <code>PostListItemModel</code> class:<pre>data class PostListItemModel(
    val id: Long,
    val userId: Long,
    val authorName: String,
    val title: String
)</pre></li>
				<li>In the same file, create the <code>PostListModel</code> class:<pre>data class PostListModel(
    val headerText: String = "",
    val items: List&lt;PostListItemModel&gt; = listOf()
)</pre></li>
				<li>In the <code>presentation-post</code> module, in the <code>src/main</code> folder, create a folder called <code>res</code>.</li>
				<li>In the <code>res</code> folder, create a new folder called <code>values</code>.</li>
				<li>In the <code>values</code> folder, create a<a id="_idIndexMarker561"/> file called <code>strings.xml</code>.</li>
				<li>In the <code>strings.xml</code> file, add the following strings:<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;string name="total_click_count"&gt;Total click 
        count: %d&lt;/string&gt;
    &lt;string name="author"&gt;Author: %s&lt;/string&gt;
    &lt;string name="title"&gt;Title: %s&lt;/string&gt;
&lt;/resources&gt;</pre></li>
				<li>In the <code>list</code> package, create the <code>PostListConverter</code> class:<pre>class PostListConverter @Inject constructor(@ApplicationContext private val context: Context) {
    fun convert(postListResult: Result
        &lt;GetPostsWithUsersWithInteractionUseCase.
            Response&gt;): UiState&lt;PostListModel&gt; {
        return when (postListResult) {
            is Result.Error -&gt; {
                UiState.Error(postListResult.
                 exception.localizedMessage.orEmpty())
            }
            is Result.Success -&gt; {
                UiState.Success(PostListModel(
                    headerText = context.getString(
                        R.string.total_click_count,
                        postListResult.data.
                            interaction.totalClicks
                    ),
                    items = postListResult.data.
                        posts.map {
                        PostListItemModel(
                            it.post.id,
                            it.user.id,
                            context.getString(R.string.author, it.user.name),
                            context.getString(R.string.title, it.post.title)
                        )
                    }
                ))
            }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we convert the <code>Result.Success</code> and <code>Result.Error</code> objects into equivalent <code>UiState</code> objects, which will be used to display the information to the user.</p>
			<ol>
				<li value="17">In the <code>list</code> package, create<a id="_idIndexMarker562"/> the <code>PostListViewModel</code> class:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    private val useCase: 
        GetPostsWithUsersWithInteractionUseCase,
    private val converter: PostListConverter
) : ViewModel() {
    private val _postListFlow =
        MutableStateFlow&lt;UiState
            &lt;PostListModel&gt;&gt;(UiState.Loading)
    val postListFlow: 
        StateFlow&lt;UiState&lt;PostListModel&gt;&gt; = 
            _postListFlow
    fun loadPosts() {
        viewModelScope.launch {
            useCase.execute
              (GetPostsWithUsersWithInteractionUseCase
                   .Request)
                .map {
                    converter.convert(it)
                }
                .collect {
                    _postListFlow.value = it
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we get the list of posts and users from the <code>GetPostsWithUsersInteractionUseCase</code> object, then we convert it to the <code>UiState</code> object, and finally, we update <code>StateFlow</code> with the <code>UiState</code> object.</p>
			<ol>
				<li value="18">In the <code>list</code> package, create a file called <code>PostListScreen</code>.</li>
				<li>In the <code>PostListScreen</code> file, add<a id="_idIndexMarker563"/> a method to display a loading widget and a <code>Snackbar</code> method:<pre>@Composable
fun Error(errorMessage: String) {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Bottom
    ) {
        Snackbar {
            Text(text = errorMessage)
        }
    }
}
@Composable
fun Loading() {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = 
            Alignment.CenterHorizontally,
    ) {
        CircularProgressIndicator()
    }
}</pre></li>
				<li>In the same file, add a <a id="_idIndexMarker564"/>method to display the list of posts and the header:<pre>@Composable
fun PostList(
    postListModel: PostListModel
) {
    LazyColumn(modifier = Modifier.padding(16.dp)) {
        item(postListModel.headerText) {
            Column(modifier = Modifier.padding(16.dp)) {
                Text(text = postListModel.headerText)
            }
        }
        items(postListModel.items) { item -&gt;
            Column(
                modifier = Modifier
                    .padding(16.dp)
            ) {
                Text(text = item.authorName)
                Text(text = item.title)
            }
        }
    }
}</pre></li>
				<li>In the same file, add a method that will monitor the value of <code>postListFlow</code> and invoke one of the<a id="_idIndexMarker565"/> preceding three methods, depending on the value of the state:<pre>@Composable
fun PostListScreen(
    viewModel: PostListViewModel
) {
    viewModel.loadPosts()
    viewModel.postListFlow.collectAsState().value.let { state -&gt;
        when (state) {
            is UiState.Loading -&gt; {
                Loading()
            }
            is UiState.Error -&gt; {
                Error(state.errorMessage)
            }
            is UiState.Success -&gt; {
                PostList(state.data)
            }
        }
    }
}</pre></li>
				<li>In the <code>build.gradle</code> file of the <code>app</code> module, make sure that the following plugins are<a id="_idIndexMarker566"/> added:<pre>plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}</pre></li>
				<li>In the same file, make sure that the following dependencies are added:<pre>dependencies {
    implementation(project(path: ":presentation-
        post"))
    implementation(project(path: ":domain"))
    implementation(project(path: ":data-remote"))
    implementation(project(path: ":data-local"))
    implementation(project(path: ":data-repository"))
    implementation androidx.core
    implementation androidx.appCompat
    implementation material.material
    implementation androidx.composeUi
    implementation androidx.composeMaterial
    implementation androidx.composeUiToolingPreview
    implementation androidx.lifecycleRuntimeKtx
    implementation androidx.composeActivity
    implementation androidx.navigationCompose
    implementation androidx.hiltNavigationCompose
    implementation di.hiltAndroid
    kapt di.hiltCompiler
    testImplementation test.junit
}</pre></li>
				<li>In the <code>app</code> module, create a package called <code>injection</code>.</li>
				<li>In the <code>injection</code> package, create<a id="_idIndexMarker567"/> a class called <code>AppModule</code>:<pre>@Module
@InstallIn(SingletonComponent::class)
class AppModule {
    @Provides
    fun provideUseCaseConfiguration() = 
        UseCase.Configuration(Dispatchers.IO)
}</pre></li>
			</ol>
			<p>Here, we provide a <code>UseCase.Configuration</code> dependency, which will be injected into all the <code>UseCase</code> subclasses. </p>
			<ol>
				<li value="26">In the <code>app</code> module, create a class called <code>PostApplication</code>:<pre>@HiltAndroidApp
class PostApplication : Application()</pre></li>
				<li>Add the <code>PostApplication</code> class to the <code>AndroidManifest.xml</code> file of the <code>app</code> module:<pre>    &lt;application
        …
        android:name=".PostApplication"
        …
   &gt;</pre></li>
				<li>Modify the <code>MainActivity</code> class so that it will use the navigation library to go to the <code>PostListScreen</code> function <a id="_idIndexMarker568"/>from the <code>presentation-post</code> module:<pre>@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            CleanAppTheme {
                Surface(color = MaterialTheme.
                    colors.background) {
                    val navController = 
                        rememberNavController()
                    App(navController = navController)
                }
            }
        }
    }
}
@Composable
fun App(navController: NavHostController) {
    NavHost(navController, startDestination = 
        "/posts") {
        composable(route = "/posts") {
            PostListScreen(hiltViewModel())
        }
    }
}</pre></li>
			</ol>
			<p>If we run the application, we<a id="_idIndexMarker569"/> should see the following screen:</p>
			<div><div><img src="img/Figure_8.04_B18320.jpg" alt="Figure 8.4 – Output of Exercise 08.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Output of Exercise 08.01</p>
			<p>We can see the list of post titles and the author's name for each post. The total click count is, for now, 0 because we haven't connected any logic and are yet to modify that value. We will add that logic in the exercises that follow. If an error occurs while loading this list, then we will see a<a id="_idIndexMarker570"/> snackbar with the description of the <code>Exception</code> object, and while the data is loaded, an indeterminate progress bar will be displayed.</p>
			<p>In this section, we have implemented the presentation layer of an Android application using the MVVM architecture pattern and connected the layer to the domain layer of the application to display data to the user. In the section that follows, we will expand this layer across multiple modules and see how we can navigate between screens in different modules.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor095"/>Presenting data in multiple modules</h1>
			<p>In this section, we will look at how we can separate the presentation layer into<a id="_idIndexMarker571"/> multiple modules, how we can handle the interaction between these modules, and how they can share the same data.</p>
			<p>When developing Android applications, we can group screens into different modules. For example, we can group a login or registration flow inside a library module called <em class="italic">authentication</em>, or if we have a settings section, we can group those screens inside a separate module. Sometimes these screens will have commonalities with the rest of the application, such as using the same loading progress bar or the same error mechanism. Other times, these screens must navigate to screens from other modules. The question we now need to ask is how this can happen without creating a dependency between the two modules or other modules that<a id="_idIndexMarker572"/> are on the same level. Having a direct dependency on these modules will risk creating a cyclic dependency as shown here: </p>
			<div><div><img src="img/Figure_8.05_B18320.jpg" alt="Figure 8.5 – Module cyclic dependency&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Module cyclic dependency</p>
			<p>In <em class="italic">Figure 8.5</em>, we show what might<a id="_idIndexMarker573"/> happen if we want to navigate from the <code>:auth</code> module to the <code>:settings</code> module and vice versa. This currently is impossible because of the cyclic dependency between the two modules. To solve this issue, we will need to create a new module. This module will hold the common logic shared between the two modules and common data. This will look like the following figure:</p>
			<div><div><img src="img/Figure_8.06_B18320.jpg" alt="Figure 8.6 – Common presentation module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Common presentation module</p>
			<p>In <em class="italic">Figure 8.6</em>, we added the <code>:common</code> module, which will hold reusable views or <code>@Composable</code> functions and the navigation data from the app. Over time, this module will grow, so it can be split into <a id="_idIndexMarker574"/>different modules holding different common features of the app (navigation, UI, common logic, and so on). </p>
			<p>If we are using Jetpack Compose for our <a id="_idIndexMarker575"/>application, then we can rely on the work done in <em class="italic">Exercise 03.02 – Navigating using Jetpack Compose</em> of <a href="B18320_03_ePub.xhtml#_idTextAnchor055"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Data Presentation on Android</em>, where we defined the following structure for the app navigation: </p>
			<pre>private const val ROUTE_USERS = "users"
private const val ROUTE_USER = "users/%s"
private const val ARG_USER_NAME = "name"
sealed class AppNavigation(val route: String, val 
    argumentName: String = "") {
    object Users : AppNavigation(ROUTE_USERS)
    object User : AppNavigation(String.format(ROUTE_USER, 
        "{$ARG_USER_NAME}"), ARG_USER_NAME) {
        fun routeForName(name: String) = 
            String.format(ROUTE_USER, name)
    }
}</pre>
			<p>The <code>routeForName</code> method was called from the <code>Users</code> screen when a user in the list was clicked, and then the <code>NavHost</code> method would use that route to open the <code>User</code> screen. When dealing with<a id="_idIndexMarker576"/> multiple modules, the routes that will be shared by the modules can be stored in the <code>:common</code> module so that each module will have<a id="_idIndexMarker577"/> access to the route. The <code>:app</code> module, which will have <code>NavHost</code>, will then be able to navigate between each screen.</p>
			<p>When it comes to handling common logic between different modules, such as displaying the same error or loading views, we can declare the composable functions inside the <code>:common</code> module:</p>
			<pre>@Composable
fun Error(errorMessage: String) {
    …
}
@Composable
fun Loading() {
    …
} </pre>
			<p>If the same state is shared between the different screens in the different modules, we can have something like the following:</p>
			<pre>@Composable
fun &lt;T&gt; CommonScreen(state: State&lt;T&gt;, onSuccess: 
    @Composable (T) -&gt; Unit) {
    when (result) {
        is State.Success -&gt; {
            onSuccess(result.data)
        }
        is State.Error -&gt; {
            Error(result.errorMessage)
        }
        is State.Loading -&gt; {
            Loading()
        }
    }
}</pre>
			<p>Here, we will check the current state and display the common error and loading views, leaving the screens themselves to only concern themselves with the successful state.</p>
			<p>In this section, we have looked at how we can split the presentation layer into multiple modules and how to <a id="_idIndexMarker578"/>handle the common elements between these modules. In the following section, we will look at an exercise on how to achieve this. Splitting the<a id="_idIndexMarker579"/> presentation layer into multiple modules will decrease application build times because Gradle caching will only rebuild modules that contain changes. Another benefit comes in the form of drawing boundaries around the application's scope, which will be beneficial when it comes to exporting only certain features of an application.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor096"/>Exercise 08.02 – Multi-module data presentation </h2>
			<p>Modify <em class="italic">Exercise 08.01 – Implementing MVVM</em> so that two new<a id="_idIndexMarker580"/> modules are created: <code>presentation-post</code> and <code>presentation-common</code>. </p>
			<p>The <code>presentation-common</code> module<a id="_idIndexMarker581"/> will have the following:</p>
			<ul>
				<li>The <code>UiState</code> class, which will be moved from the <code>presentation-post</code> module.</li>
				<li><code>CommonResultConverter</code>, which will be an abstract class with two methods: <code>convert</code>, which is a concrete method that will convert the <code>Result</code> object into a <code>UiState</code> object, and <code>convertSuccess</code>, which is an abstract method used to convert the data from <code>Result.Success</code>.</li>
				<li><code>CommonScreen</code>, which will have the <code>@Composable</code> method for displaying the different types of <code>UiState</code> and two additional methods for displaying the error snackbar and the progress bar. The two methods will be moved from <code>PostListScreen</code>.</li>
				<li><code>AppNavigation</code>, which will hold the routes to navigate to the list of posts, a single post, and a single user.</li>
				<li>The <code>presentation-post</code> module will have an additional package to display the information of a single post in the following format: Title: x and Body: y, where x is the title of a post and y is the body of the post. To display this information, a new <code>ViewModel</code> and <code>Converter</code> class will need to be created, which will convert the data from <code>GetPostUseCase</code>. When the author text is clicked, the app will navigate to the user screen, and when the <code>Post</code> list item is clicked, the app will navigate to the post screen. When either of these is clicked, <code>UpdateInteractionUseCase</code> is invoked to increase the number of clicks, which will then be reflected in the list header.</li>
				<li><code>presentation-user</code> will display the information about a single user in the following format: Name: x, Username: y, and Email: z, where x, y, and z are represented by the information inside the <code>User</code> entity. The user data will be loaded from <code>GetUserUseCase</code>.</li>
				<li>The <code>app</code> module will be updated to handle the navigation between all these screens.</li>
			</ul>
			<p>To complete this exercise, you will<a id="_idIndexMarker582"/> need to do the following:</p>
			<ol>
				<li value="1">Create the <code>presentation-common</code> module.</li>
				<li>Move the <code>UiState</code> class and the <code>Error</code> and <code>Loading</code> <code>@Composable</code> functions and create a new <code>@Composable</code> function, which will handle each type of <code>UiState</code> object inside the <code>CommonScreen</code> file.</li>
				<li>Create the <code>CommonResultConverter</code> class.</li>
				<li>Create the <code>AppNavigation</code> class.</li>
				<li>Modify the classes in <code>presentation-post</code> to reuse the preceding classes and methods.</li>
				<li>Create the <code>PostScreen</code>, <code>PostViewModel</code>, <code>PostConverter</code>, and <code>PostModel</code> classes responsible for displaying the information about a single post.</li>
				<li>Create the <code>presentation-user</code> module.</li>
				<li>Create the <code>UserScreen</code>, <code>UserViewModel</code>, <code>UserConverter</code>, and <code>UserModel</code> classes responsible for<a id="_idIndexMarker583"/> displaying the information about a single post.</li>
				<li>Implement the navigation between the screens.</li>
				<li>Add the logic to update the number of clicks inside <code>PostListViewModel</code>.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Create the <code>presentation-common</code> and <code>presentation-user</code> Android library modules.</li>
				<li>Apply steps 3–5 from <em class="italic">Exercise 08.01 – Implementing MVVM</em> for each of these new modules.</li>
				<li>In the <code>build.gradle</code> file of the <code>presentation-post</code> and <code>presentation-user</code> modules, make<a id="_idIndexMarker584"/> sure that the<a id="_idIndexMarker585"/> dependency to <code>presentation-common</code> is added:<pre>dependencies {
    …
    implementation(project(path: ":presentation-common"))
    …
}</pre></li>
				<li>In the <code>presentation-common</code> module, create a new package called <code>state</code>.</li>
				<li>Move the <code>UiState</code> class into the preceding package.</li>
				<li>In the same package, create the <code>CommonResultConverter</code> class:<pre>abstract class CommonResultConverter&lt;T : Any, R : Any&gt; {
    fun convert(result: Result&lt;T&gt;): UiState&lt;R&gt; {
        return when (result) {
            is Result.Error -&gt; {
                UiState.Error(result.exception.
                    localizedMessage.orEmpty())
            }
            is Result.Success -&gt; {
                UiState.Success(convertSuccess
                    (result.data))
            }
        }
    }
    abstract fun convertSuccess(data: T): R
}</pre></li>
			</ol>
			<p>Here, we return <code>UiState.Error</code> for any <code>Result.Error</code> object with the exception message, and for <code>Result.Success</code>, we return <code>UiState.Success</code> and use an abstraction for the data inside the <code>Result.Success</code> object. This<a id="_idIndexMarker586"/> represents a solution for how we <a id="_idIndexMarker587"/>can extract the common logic for displaying the error.</p>
			<ol>
				<li value="7">Modify the <code>PostListConverter</code> class from the <code>presentation-post</code> module so that it will extend <code>CommonResultConverter</code> and provide an implementation for the <code>convertSuccess</code> method:<pre>class PostListConverter @Inject constructor (@ApplicationContext private val context: Context) :
    CommonResultConverter&lt;GetPostsWithUsersWithInteraction
    UseCase.Response, PostListModel&gt;() {
    override fun convertSuccess(data: 
        GetPostsWithUsersWithInteractionUseCase.
            Response): PostListModel {
        return PostListModel(
            headerText = context.getString(
                R.string.total_click_count,
                data.interaction.totalClicks
            ),
            items = data.posts.map {
                PostListItemModel(
                    it.post.id,
                    it.user.id,
                    context.getString(R.string.author, 
                        it.user.name),
                    context.getString(R.string.title, 
                        it.post.title)
                )
            }
        )
    }
}</pre></li>
			</ol>
			<p>Here, we only deal with converting <code>GetPostsWithUsersWithInteractionUseCase.Response</code> into <code>PostListModel</code>, allowing the <a id="_idIndexMarker588"/>parent class to handle the error<a id="_idIndexMarker589"/> only.</p>
			<ol>
				<li value="8">In the <code>state</code> package from the <code>presentation-common</code> module, create a new file called <code>CommonScreen</code>.</li>
				<li>In the <code>CommonScreen</code> file, add a <code>CommonScreen</code> <code>@Composable</code> method, which will check <code>UiState</code> and invoke <code>Error</code> for <code>UiState.Error</code> and <code>Loading</code> for <code>UiState.Loading</code>:<pre>@Composable
fun &lt;T : Any&gt; CommonScreen(state: UiState&lt;T&gt;, onSuccess: @Composable (T) -&gt; Unit) {
    when (state) {
        is UiState.Loading -&gt; {
            Loading()
        }
        is UiState.Error -&gt; {
            Error(errorMessage = state.errorMessage)
        }
        is UiState.Success -&gt; {
            onSuccess(state.data)
        }
    }
}</pre></li>
				<li>Move the <code>Error</code> and <code>Loading</code> <code>@Composable</code> functions from <code>PostListScreen</code> into <a id="_idIndexMarker590"/>the <code>CommonScreen</code> file.</li>
				<li>Modify the <code>PostListScreen</code> <code>@Composable</code> method from the<code> presentation-post</code> module<a id="_idIndexMarker591"/> so that it will use the <code>CommonScreen</code> method:<pre>@Composable
fun PostListScreen(
    viewModel: PostListViewModel
) {
    viewModel.loadPosts()
    viewModel.postListFlow.collectAsState().value.let 
        { state -&gt;
        CommonScreen(state = state) {
            PostList(postListModel = it)
        }
    }
}</pre></li>
			</ol>
			<p>Now the entire logic for converting and showing the list of posts will only deal with the associated objects, leaving the error and loading scenarios in the <code>presentation-common</code> module.</p>
			<ol>
				<li value="12">In <code>presentation-common</code>, create a new package called <code>navigation</code>.</li>
				<li>In the <code>navigation</code> package, create a class called <code>PostInput</code>:<pre>data class PostInput(val postId: Long)</pre></li>
			</ol>
			<p>This class is meant to represent <a id="_idIndexMarker592"/>the input that the post screen will require to load its data.</p>
			<ol>
				<li value="14">In the same package, create a class called <code>UserInput</code>:<pre>data class UserInput(val userId: Long)</pre></li>
			</ol>
			<p>This class is meant to<a id="_idIndexMarker593"/> represent the input that the user screen will require to load its data.</p>
			<ol>
				<li value="15">In the same package, create a new class called <code>NavRoutes</code>:<pre>private const val ROUTE_POSTS = "posts"
private const val ROUTE_POST = "posts/%s"
private const val ROUTE_USER = "users/%s"
private const val ARG_POST_ID = "postId"
private const val ARG_USER_ID = "userId"
sealed class NavRoutes(
    val route: String,
    val arguments: List&lt;NamedNavArgument&gt; = 
        emptyList()
) {
    …
}</pre></li>
			</ol>
			<p>Here, we define the paths for each screen. The posts screen will have no arguments, but the user <a id="_idIndexMarker594"/>and post screens will require the <code>postId</code> and <code>userId</code> values.</p>
			<ol>
				<li value="16">Create the <code>Posts</code> class<a id="_idIndexMarker595"/> in the <code>NavRoutes</code> class:<pre>sealed class NavRoutes(
    val route: String,
    val arguments: List&lt;NamedNavArgument&gt; = 
        emptyList()
) {
    object Posts : NavRoutes(ROUTE_POSTS)
}</pre></li>
				<li>Create the <code>Post</code> class in the <code>NavRoutes</code> class:<pre>sealed class NavRoutes(
    val route: String,
    val arguments: List&lt;NamedNavArgument&gt; = 
        emptyList()
) {
    object Post : NavRoutes(
        route = String.format(ROUTE_POST, 
            "{$ARG_POST_ID}"),
        arguments = listOf(navArgument(ARG_POST_ID) {
            type = NavType.LongType
        })
    ) {
        fun routeForPost(postInput: PostInput) = 
           String.format(ROUTE_POST, postInput.postId)
        fun fromEntry(entry: NavBackStackEntry): 
            PostInput {
            return PostInput(entry.arguments?.
                getLong(ARG_POST_ID) ?: 0L)
        }
    }
}</pre></li>
			</ol>
			<p>Here, we will need to break down <a id="_idIndexMarker596"/>the <code>Post</code> input into the arguments for the URL. The <code>routeForPost</code> method will create a <code>/posts/1</code> URL for a <code>Post</code> object that has the ID <code>1</code>. The <code>fromEntry</code> method will re-assemble the <code>PostInput</code> object from the navigation entry object. The reason we are taking this approach is that the <a id="_idIndexMarker597"/>navigation library discourages the use of <code>Parcelable</code>, which means that passing data between different screens will have to be done through the URL. To avoid any issues with keeping track of the arguments across multiple modules, we can instead <a id="_idIndexMarker598"/>use objects and keep the logic to read from arguments and construct the arguments isolated to this class.</p>
			<ol>
				<li value="18">Create the <code>User</code> class inside <a id="_idIndexMarker599"/>the <code>NavRoutes</code> class:<pre>sealed class NavRoutes(
    val route: String,
    val arguments: List&lt;NamedNavArgument&gt; = emptyList()
) {
    object User : NavRoutes(
        route = String.format(ROUTE_USER, 
            "{$ARG_USER_ID}"),
        arguments = listOf(navArgument(ARG_USER_ID) {
            type = NavType.LongType
        })
    ) {
        fun routeForUser(userInput: UserInput) = 
           String.format(ROUTE_USER, userInput.userId)
        fun fromEntry(entry: NavBackStackEntry): 
            UserInput {
            return UserInput(entry.arguments?.getLong
                (ARG_USER_ID) ?: 0L)
        }
    }
}</pre></li>
			</ol>
			<p>Here, we apply the same principle as we did for the <code>Post</code> class.</p>
			<ol>
				<li value="19">Create a new package <a id="_idIndexMarker600"/>called <code>single</code> in the <code>presentation-post</code> module.</li>
				<li>In the <code>single</code> package, create the <code>PostModel</code> class:<pre>data class PostModel(
    val title: String,
    val body: String
)</pre></li>
				<li>In the <code>single</code> package, create<a id="_idIndexMarker601"/> the <code>PostConverter</code> class:<pre>class PostConverter @Inject constructor(@ApplicationContext private val context: Context) :
    CommonResultConverter&lt;GetPostUseCase.Response, 
        PostModel&gt;() {
    override fun convertSuccess(data: 
        GetPostUseCase.Response): PostModel {
        return PostModel(
            context.getString(R.string.title, 
                data.post.title),
            context.getString(R.string.body, 
                data.post.body)
        )
    }
}</pre></li>
				<li>Add the <code>body</code> string to <code>strings.xml</code> of the <code>presentation-post</code> module:<pre>&lt;resources&gt;
    …
    &lt;string name="body"&gt;Body: %s&lt;/string&gt;
&lt;/resources&gt;</pre></li>
				<li>In<a id="_idIndexMarker602"/> the <code>single</code> package, create<a id="_idIndexMarker603"/> the <code>PostViewModel</code> class:<pre>@HiltViewModel
class PostViewModel @Inject constructor(
    private val postUseCase: GetPostUseCase,
    private val postConverter: PostConverter
) : ViewModel() {
    private val _postFlow =
        MutableStateFlow&lt;UiState&lt;PostModel&gt;&gt;(UiState.Loading)
    val postFlow: StateFlow&lt;UiState&lt;PostModel&gt;&gt; = 
        _postFlow
    fun loadPost(postId: Long) {
        viewModelScope.launch {
            postUseCase.execute(GetPostUseCase.
                Request(postId))
                .map {
                    postConverter.convert(it)
                }
                .collect {
                    _postFlow.value = it
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we are using <code>GetPostUseCase</code> to load the information about a particular post and are using<a id="_idIndexMarker604"/> the converter defined earlier to convert the data into <code>PostModel</code>, which <a id="_idIndexMarker605"/>will be set in the <code>Flow</code> object.</p>
			<ol>
				<li value="24">In the <code>single</code> package, create the <code>PostScreen</code> file, which will display the post information:<pre>@Composable
fun PostScreen(
    viewModel: PostViewModel,
    postInput: PostInput
) {
    viewModel.loadPost(postInput.postId)
    viewModel.postFlow.collectAsState().value.let { 
        result -&gt;
        CommonScreen(result) { postModel -&gt;
            Post(postModel)
        }
    }
}
@Composable
fun Post(postModel: PostModel) {
    Column(modifier = Modifier.padding(16.dp)) {
        Text(text = postModel.title)
        Text(text = postModel.body)
    }
}</pre></li>
			</ol>
			<p>Here, we follow the same <a id="_idIndexMarker606"/>principle as for the <code>PostListScreen</code> file, where we split into two methods, <code>PostScreen</code> for observing the <code>UiState</code> object and <code>PostListScreen</code> to deal with<a id="_idIndexMarker607"/> drawing the user interface.</p>
			<ol>
				<li value="25">In the <code>presentation-user</code> module, create a new package called <code>single</code>.</li>
				<li>In the <code>single</code> package, create a new class called <code>UserModel</code>:<pre>data class UserModel(
    val name: String,
    val username: String,
    val email: String
)</pre></li>
				<li>In the <code>single</code> package, create a new class called <code>UserConverter</code>:<pre>class UserConverter @Inject constructor(@ApplicationContext private val context: Context) :
    CommonResultConverter&lt;GetUserUseCase.Response, 
        UserModel&gt;() {
    
    override fun convertSuccess(data: GetUserUseCase.
        Response): UserModel {
        return UserModel(
            context.getString(R.string.name,
                data.user.name),
            context.getString(R.string.username, 
                data.user.username),
            context.getString(R.string.email, 
                data.user.email)
        )
    }
}</pre></li>
				<li>Create the <code>res/values/strings.xml</code> file<a id="_idIndexMarker608"/> inside the <code>main</code> folder in<a id="_idIndexMarker609"/> the <code>presentation-user</code> module:<pre>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;string name="name"&gt;Name: %s&lt;/string&gt;
    &lt;string name="username"&gt;Username: %s&lt;/string&gt;
    &lt;string name="email"&gt;Email: %s&lt;/string&gt;
&lt;/resources&gt;</pre></li>
				<li>Inside the <code>single</code> package, create <code>UserViewModel</code>:<pre>@HiltViewModel
class UserViewModel @Inject constructor(
    private val userUseCase: GetUserUseCase,
    private val converter: UserConverter
) : ViewModel() {
    private val _userFlow =
        MutableStateFlow&lt;UiState&lt;UserModel&gt;&gt;
            (UiState.Loading)
    val userFlow: StateFlow&lt;UiState&lt;UserModel&gt;&gt; = 
        _userFlow
    fun loadUser(userId: Long) {
        viewModelScope.launch {
            userUseCase.execute
                (GetUserUseCase.Request(userId))
                .map {
                    converter.convert(it)
                }
                .collect {
                    _userFlow.value = it
                }
        }
    }
}</pre></li>
			</ol>
			<p>Here, we take the user data from <code>GetUserUseCase</code>, convert it using <code>UserConverter</code>, and post<a id="_idIndexMarker610"/> the result in the <code>Flow</code> object.</p>
			<ol>
				<li value="30">In the <code>single</code> package, create<a id="_idIndexMarker611"/> the <code>UserScreen</code> file:<pre>@Composable
fun UserScreen(
    viewModel: UserViewModel,
    userInput: UserInput
) {
    viewModel.loadUser(userInput.userId)
    viewModel.userFlow.collectAsState().value.let { 
        result -&gt;
        CommonScreen(result) { userModel -&gt;
            User(userModel)
        }
    }
}
@Composable
fun User(userModel: UserModel) {
    Column(modifier = Modifier.padding(16.dp)) {
        Text(text = userModel.name)
        Text(text = userModel.username)
        Text(text = userModel.email)
    }
}</pre></li>
			</ol>
			<p>Here, we take the same approach as<a id="_idIndexMarker612"/> the other screens, where in one method, we subscribe to changes in <code>UiState</code>, and in the other, we display the<a id="_idIndexMarker613"/> user information.</p>
			<ol>
				<li value="31">Add the click listeners in <code>PostListScreen</code>:<pre>@Composable
fun PostList(
    postListModel: PostListModel,
    <strong class="bold">onRowClick: (PostListItemModel) -&gt; Unit</strong>,
    <strong class="bold">onAuthorClick: (PostListItemModel) -&gt; Unit</strong>
) {
    LazyColumn(modifier = Modifier.padding(16.dp)) {
        …
        items(postListModel.items) { item -&gt;
            Column(modifier = Modifier
                .padding(16.dp)
                <strong class="bold">.clickable {</strong>
                    <strong class="bold">onRowClick(item)</strong>
                <strong class="bold">}</strong>) {
                <strong class="bold">ClickableText(text = AnnotatedString(</strong>
<strong class="bold">                    text =</strong> <strong class="bold">item.authorName), onClick =  </strong>
<strong class="bold">                {</strong>
                    <strong class="bold">onAuthorClick(item)</strong>
                <strong class="bold">})</strong>
                Text(text = item.title)
            }
        }
    }
}</pre></li>
			</ol>
			<p>In the preceding snippet, we specify click listeners for when the row is clicked and for when the author is clicked. Because we are applying state hoisting, we want to propagate the click listeners to the caller of the <code>PostList</code> method. To achieve this, we define a<a id="_idIndexMarker614"/> parameter for each click listener as a<a id="_idIndexMarker615"/> lambda function that has as input the row data and requires no result. More information about lambdas can be found here: <a href="https://kotlinlang.org/docs/lambdas.html#function-types">https://kotlinlang.org/docs/lambdas.html#function-types</a>.</p>
			<ol>
				<li value="32">Modify the <code>PostListScreen</code> <code>@Composable</code> method so that when the user is clicked, we navigate to the user screen, and when the row is clicked, we navigate to the post:<pre>@Composable
fun PostListScreen(
    viewModel: PostListViewModel,
    navController: NavController
) {
    viewModel.loadPosts()
    viewModel.postListFlow.collectAsState().value.let 
        { state -&gt;
        CommonScreen(state = state) {
            PostList(it, { postListItem -&gt;
                navController.navigate(NavRoutes.Post.
                    routeForPost(PostInput
                        (postListItem.id)))
            }) { postListItem -&gt;
                navController.navigate(NavRoutes.User.
                    routeForUser(UserInput
                        (postListItem.userId)))
            }
        }
    }
}</pre></li>
				<li>In <code>build.gradle</code> of the <code>app</code> module, make<a id="_idIndexMarker616"/> sure that the dependencies to <code>presentation-common</code> and <code>presentation-user</code> are <a id="_idIndexMarker617"/>added:<pre>dependencies {
    …
    implementation(project(path: ":presentation-
        user"))
    implementation(project(path: ":presentation-
        common"))
    …
}</pre></li>
				<li>In the <code>MainActivity</code> file, modify the <code>App</code> method so that the navigation between the different screens is implemented:<pre>@Composable
fun App(navController: NavHostController) {
    NavHost(navController, startDestination = 
        NavRoutes.Posts.route) {
        composable(route = NavRoutes.Posts.route) {
            PostListScreen(hiltViewModel(), 
                navController)
        }
        composable(
            route = NavRoutes.Post.route,
            arguments = NavRoutes.Post.arguments
        ) {
            PostScreen(
                hiltViewModel(),
                NavRoutes.Post.fromEntry(it)
            )
        }
        composable(
            route = NavRoutes.User.route,
            arguments = NavRoutes.User.arguments
        ) {
            UserScreen(
                hiltViewModel(),
                NavRoutes.User.fromEntry(it)
            )
        }
    }
}</pre></li>
			</ol>
			<p>Here, we add all the screens<a id="_idIndexMarker618"/> in the application to the navigation graph, and in the case of <code>UserScreen</code> and <code>PostScreen</code>, we extract the <code>UserInput</code> and <code>PostInput</code> objects from the navigation graph entries. We will <a id="_idIndexMarker619"/>now need to add the interaction.</p>
			<ol>
				<li value="35">Add an <code>Interaction</code> field inside <code>PostListModel</code>:<pre>data class PostListModel(
    …
    val interaction: Interaction
)</pre></li>
				<li>Modify <code>PostListConverter</code> to include the <code>interaction</code> field:<pre>class PostListConverter @Inject constructor (@ApplicationContext private val context: Context) :
    CommonResultConverter&lt;GetPostsWithUsersWithInteraction
    UseCase.Response, PostListModel&gt;() {
    override fun convertSuccess(data: 
        GetPostsWithUsersWithInteractionUseCase.
            Response): PostListModel {
        return PostListModel(
            …
            interaction = data.interaction
        )
    }
}</pre></li>
				<li>Add a reference to <code>UpdateInteractionUseCase</code> in <code>PostListViewModel</code> and a method to<a id="_idIndexMarker620"/> update the<a id="_idIndexMarker621"/> interaction:<pre>@HiltViewModel
class PostListViewModel @Inject constructor(
    …
    <strong class="bold">private val updateInteractionUseCase:</strong> 
        <strong class="bold">UpdateInteractionUseCase</strong>
) : ViewModel() {
    …
    fun updateInteraction(interaction: Interaction) {
        viewModelScope.launch {
            updateInteractionUseCase.execute(
                UpdateInteractionUseCase.Request(
                    interaction.copy(
                        totalClicks = interaction.
                            totalClicks + 1
                    )
                )
            ).collect()
        }
    }
}</pre></li>
				<li>Modify the <code>PostListScreen</code> <code>@Composable</code> method<a id="_idIndexMarker622"/> so that it will call to update the interaction for each click:<pre>@Composable
fun PostListScreen(
    viewModel: PostListViewModel,
    navController: NavController
) {
    …
    viewModel.postListFlow.collectAsState().value.let 
        { state -&gt;
        CommonScreen(state = state) {
            PostList(it, { postListItem -&gt;
                <strong class="bold">viewModel.updateInteraction(it.interaction)</strong>
                …
            }) { postListItem -&gt;
                <strong class="bold">viewModel.updateInteraction(it.interaction)</strong>
                …
            }
        }
    }
}</pre></li>
			</ol>
			<p>If we run<a id="_idIndexMarker623"/> the application, we will see<a id="_idIndexMarker624"/> an output like the one in the following figure:</p>
			<div><div><img src="img/Figure_8.07_B18320.jpg" alt="Figure 8.7 – Output of Exercise 08.02&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Output of Exercise 08.02</p>
			<p>We can see from <em class="italic">Figure 8.7</em> that when the row is clicked, we are taken to the screen displaying the post information, and when the author is clicked, we are taken to the user information. By placing the <code>NavRoutes</code> class in the <code>presentation-common</code> module, we can navigate from the post list on a screen located in the same module (post) and a screen located in a different module (user). The solution of creating additional modules is a good way to <a id="_idIndexMarker625"/>avoid cyclic dependencies not <a id="_idIndexMarker626"/>only for modules in the presentation layer but also for modules in the other layers as well. </p>
			<p>In this exercise, we have learned how to split the presentation layer into separate modules and how we can use a common module to hold shared logic and data required by all the modules in the layer. This is a technique that can be used for other layers in the application if we want them split up as well.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor097"/>Summary</h1>
			<p>In this chapter, we explored the presentation layer of an Android application and a few different approaches for implementing this layer, such as MVC, MVP, and MVVM. We decided to focus on the MVVM approach because of the many benefits involving the life cycle and the compatibility with Jetpack Compose. We then looked at what happens when we want to split the presentation layer across multiple modules and how we can solve the common logic between these modules. In the chapter that follows, we will further build upon the MVVM pattern and study the <strong class="bold">Model-View-Intent</strong> (<strong class="bold">MVI</strong>) pattern, which further takes advantage of the Observable pattern to incorporate the user actions into states that can be observed. </p>
		</div>
	</body></html>