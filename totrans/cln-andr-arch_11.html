<html><head></head><body>
		<div id="_idContainer051">
			<h1 id="_idParaDest-86"><em class="italic"><a id="_idTextAnchor090"/>Chapter 8</em>: Implementing an MVVM Architecture</h1>
			<p>In this chapter, we will look at how data can be presented by Android applications to end users. We will look over the available architecture patterns for data presentation and analyze the differences between them. Later, we will look at the <strong class="bold">Model-View-ViewModel (MVVM)</strong> pattern, the role it plays in separating business logic and user interface updates, and how we can implement it using <strong class="bold">Android Architecture Components</strong>. Finally, we will look at how we can split the presentation layer across multiple library modules. In the exercises of this chapter, we will integrate the layers built in the previous chapters with a presentation layer built using MVVM, we will create a presentation layer that will plug into the domain layer to fetch and update the data, and we will also look at how we handle common logic between different modules in the presentation layer. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Presenting data in Android applications</li>
				<li>Presenting data with MVVM</li>
				<li>Presenting data in multiple modules</li>
			</ul>
			<p>By the end of the chapter, you will be able to implement the MVVM architecture pattern in an Android application using the ViewModel architecture component and be able to split the presentation layer into separate library modules.</p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor091"/>Technical requirements</h1>
			<p>This chapter has the following hardware and software requirements:</p>
			<ul>
				<li>Android Studio Arctic Fox 2020.3.1 Patch 3</li>
			</ul>
			<p>The code files for this chapter can be found here: <a href="https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8">https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter8</a>.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3FZJWIl">https://bit.ly/3FZJWIl</a></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor092"/>Presenting data in Android applications</h1>
			<p>In this section, we will look at <a id="_idIndexMarker528"/>various architecture patterns suitable for presenting data in an Android application and analyze their benefits and <a id="_idIndexMarker529"/>drawbacks.</p>
			<p>Early Android applications relied <a id="_idIndexMarker530"/>on a pattern similar to the <strong class="bold">Model-View-Controller (MVC)</strong> architecture pattern, where an activity is the Controller, the View is represented by the <strong class="source-inline">android.widget.View</strong> hierarchy, and the Model is responsible for managing the application's data. The relationship between the components would look something like the following:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_8.01_B18320.jpg" alt="Figure 8.1 – Android MVC relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Android MVC relationship</p>
			<p>From <em class="italic">Figure 8.1</em>, we can see that the Controller represented by the activity would interact with the Model to fetch and manipulate the data, and then it would update the View with the relevant information. </p>
			<p>The idea is to have each <strong class="source-inline">Activity</strong> sandboxed as much as possible so that they can be offered and shared between multiple applications (like how the Camera application is opened by other applications to take photos and offer those photos to those applications). Because of this, activities need to be started using intents and not by instantiating them. By removing the ability to instantiate an <strong class="source-inline">Activity</strong> directly, we lose the ability to inject dependencies through the constructor. Another factor we need to consider is that activities have life cycle states, and we inherit these states in each <strong class="source-inline">Activity</strong> in our application. All these factors combined make an <strong class="source-inline">Activity</strong> very hard or next to impossible to unit<a id="_idIndexMarker531"/> test unless we use a library such as <strong class="bold">Robolectric</strong> or rely on instrumented tests on an Android device or emulator. Both options are slow and, in the case of instrumented tests, can be expensive when we need to run the tests in testing<a id="_idIndexMarker532"/> clouds such as <strong class="bold">Firebase Test Lab</strong>. </p>
			<p>To solve the problem of unit testing logic that was present in activities and later fragments, various<a id="_idIndexMarker533"/> adaptations of the <strong class="bold">Humble Object</strong> pattern emerged. More information about the pattern can be found here: <a href="http://xunitpatterns.com/Humble%20Object.html">http://xunitpatterns.com/Humble%20Object.html</a>. The idea was to separate as much as possible the logic<a id="_idIndexMarker534"/> present in activities into separate objects and unit test those objects. One of the most popular solutions was the <strong class="bold">Model-View-Presenter</strong> (<strong class="bold">MVP</strong>) architecture<a id="_idIndexMarker535"/> pattern. In this pattern, the <strong class="source-inline">Activity</strong> along with the <strong class="source-inline">android.widget.View</strong> hierarchy becomes the View, the Presenter is responsible for fetching <a id="_idIndexMarker536"/>the data from the model and performing the logic required, updating the View, and the Model has the same responsibility as in MVC to handle the application's data. The relationship between these components looks like the following figure:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_8.02_B18320.jpg" alt="Figure 8.2 – MVP relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – MVP relationship</p>
			<p>The interesting aspect of the relationship between the components is the relationship between the Presenter and the View, which goes both ways. The Presenter will update the View with the relevant data, but the View will also invoke the Presenter, if necessary for user interactions. Because of the relationship between the two components, the definition of a contract is required, which looks like the following:</p>
			<p class="source-code">interface Presenter {</p>
			<p class="source-code">    fun loadUsers()</p>
			<p class="source-code">    fun validateInput(text: String)</p>
			<p class="source-code">}</p>
			<p class="source-code">interface View {</p>
			<p class="source-code">    fun showUsers(users: List&lt;User&gt;)</p>
			<p class="source-code">    fun showInputError(error: String)</p>
			<p class="source-code">} </p>
			<p>Here, we<a id="_idIndexMarker537"/> have a <strong class="source-inline">View</strong> interface and a <strong class="source-inline">Presenter</strong> interface. The implementation of the <strong class="source-inline">Presenter</strong> might look <a id="_idIndexMarker538"/>something like this:</p>
			<p class="source-code">class PresenterImpl(</p>
			<p class="source-code">    private val view: View,</p>
			<p class="source-code">    private val getUsersUseCase: GetUsersUseCase</p>
			<p class="source-code">) : Presenter {</p>
			<p class="source-code">    private val scope = CoroutineScope(Dispatchers.Main)</p>
			<p class="source-code">    override fun loadUsers() {</p>
			<p class="source-code">        scope.launch {</p>
			<p class="source-code">            getUsersUseCase.execute()</p>
			<p class="source-code">                .collect { users -&gt;</p>
			<p class="source-code">                    view.showUsers(users)</p>
			<p class="source-code">                }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun validateInput(text: String) {</p>
			<p class="source-code">        if (text.isEmpty()) {</p>
			<p class="source-code">            view.showInputError("Invalid input")</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, the <strong class="source-inline">PresenterImpl</strong> class has a dependency on the <strong class="source-inline">View</strong> and on a <strong class="source-inline">GetUsersUseCase</strong> object, which<a id="_idIndexMarker539"/> will return a <strong class="source-inline">Flow</strong> object containing a list of users. When the <strong class="source-inline">Presenter</strong> receives the list of users, it will call the <strong class="source-inline">showUsers</strong> method <a id="_idIndexMarker540"/>from the <strong class="source-inline">View</strong>. When the <strong class="source-inline">validateInput</strong> method is called, the <strong class="source-inline">Presenter</strong> will check whether the text is empty and invoke the <strong class="source-inline">showInputError</strong> method from the <strong class="source-inline">View</strong> with an error message. The implementation of the <strong class="source-inline">View</strong> might look like the following:</p>
			<p class="source-code">class MainActivity : ComponentActivity(), View {</p>
			<p class="source-code">    @Inject</p>
			<p class="source-code">    private lateinit var presenter: Presenter</p>
			<p class="source-code">    private lateinit var usersAdapter: UsersAdapter</p>
			<p class="source-code">    private lateinit var editText: EditText</p>
			<p class="source-code">    private lateinit var errorView: TextView</p>
			<p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">        super.onCreate(savedInstanceState)</p>
			<p class="source-code">        …</p>
			<p class="source-code">        editText.addTextChangedListener(object : </p>
			<p class="source-code">            TextWatcher {</p>
			<p class="source-code">            …</p>
			<p class="source-code">            override fun afterTextChanged(s: Editable?) {</p>
			<p class="source-code">                presenter.validateInput(s?.toString().orEmpty())</p>
			<p class="source-code">            }</p>
			<p class="source-code">        })</p>
			<p class="source-code">        presenter.loadUsers()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun showUsers(users: List&lt;User&gt;) {</p>
			<p class="source-code">        usersAdapter.add(users)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    override fun showInputError(error: String) {</p>
			<p class="source-code">        errorView.text = error</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we<a id="_idIndexMarker541"/> implement the <strong class="source-inline">View</strong> interface in <strong class="source-inline">MainActivity</strong>; in the implementation of the methods, we call the<a id="_idIndexMarker542"/> appropriate <strong class="source-inline">View-</strong> related classes to show the relevant data, such as showing the error message for an invalid input in a <strong class="source-inline">TextView</strong> object and setting the data in a <strong class="source-inline">RecyclerView.Adapter</strong> object. For validating the input, when the text changes in an <strong class="source-inline">EditText</strong> object, it will invoke the <strong class="source-inline">Presenter</strong> to validate the new text. The <strong class="source-inline">Presenter</strong> dependency will be injected using some form of dependency injection. </p>
			<p>Because presenters will end up <a id="_idIndexMarker543"/>performing background operations, we<a id="_idIndexMarker544"/> run the risk of causing <strong class="source-inline">Context</strong> leaks. This means that we need to factor the life cycle of the <strong class="source-inline">Activity</strong> into the MVP contract. To achieve this, we will need to define a <strong class="source-inline">close</strong> method in the <strong class="source-inline">Presenter</strong>:</p>
			<p class="source-code">interface Presenter {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    fun close()</p>
			<p class="source-code">}</p>
			<p>In the preceding snippet, we added the <strong class="source-inline">close</strong> method, which will be called in the <strong class="source-inline">onDestroy</strong> method of the <strong class="source-inline">Activity</strong> as follows:</p>
			<p class="source-code">override fun onDestroy() {</p>
			<p class="source-code">        presenter.close()</p>
			<p class="source-code">        super.onDestroy()</p>
			<p class="source-code">}</p>
			<p>The implementation of the <strong class="source-inline">close</strong> method will have to clean up all the resources that might cause any leaks:</p>
			<p class="source-code">class PresenterImpl(</p>
			<p class="source-code">    private val view: View,</p>
			<p class="source-code">    private val getUsersUseCase: GetUsersUseCase</p>
			<p class="source-code">) : Presenter {</p>
			<p class="source-code">    private val scope = CoroutineScope(Dispatchers.Main)</p>
			<p class="source-code">    …</p>
			<p class="source-code">    override fun close() {</p>
			<p class="source-code">        scope.cancel()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we are canceling the subscription to the <strong class="source-inline">Flow</strong> object so that we will not receive any updates after the <strong class="source-inline">Activity</strong> is destroyed. </p>
			<p>In this section, we have looked <a id="_idIndexMarker545"/>at previous architecture patterns used<a id="_idIndexMarker546"/> in Android applications, from the MVC-like approach that was used in early Android applications to MVP, which aimed to solve some of the problems of the initial approach. Although MVP was popular in the past and is still present in some Android applications, it has slowly been phased out, mainly because of the release of Android Architecture Components, which rely on the MVVM pattern, and additionally, Jetpack Compose, which works better with data flows, which are more suited to MVVM. In the section that follows, we will look at the MVVM architecture pattern and how it is different from MVP as a concept. </p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor093"/>Presenting data with MVVM</h1>
			<p>In this section, we will analyze the <strong class="bold">Model-View-ViewModel</strong> architecture pattern and how it is implemented for <a id="_idIndexMarker547"/>Android applications.</p>
			<p>MVVM represents a different <a id="_idIndexMarker548"/>approach to the Humble Object pattern, which attempts to extract the logic out of activities and fragments. In MVVM, the View is represented by activities and fragments as it was in MVP, the Model plays the same role, managing the data, and the ViewModel sits between the two by requesting the data from the Model when the View requires it. The relationship between the three is as follows:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_8.03_B18320.jpg" alt="Figure 8.3 – MVVM relationship&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – MVVM relationship</p>
			<p>In <em class="italic">Figure 8.3</em>, we see a unidirectional relationship between the three components. The View has a dependency on the ViewModel, and the ViewModel has a dependency on the Model. This allows for more flexibility because multiple Views can use the same ViewModel. For the data to be updated in the View, MVVM requires an implementation of the <strong class="bold">Observer</strong> pattern. This means that the ViewModel uses an <strong class="bold">Observable</strong>, which the View will subscribe to and react to changes in the data. </p>
			<p>To develop Android applications, we have the possibility of using the Android Architecture Components libraries, which provide a <strong class="source-inline">ViewModel</strong> class that solves the issue of activity and fragment life cycles, combined with coroutine extensions useful for subscribing to flows or coroutines to stop the emission of data when the activities and fragments are in invalid <a id="_idIndexMarker549"/>states for data to be displayed and to avoid context leaks.</p>
			<p>From the<a id="_idIndexMarker550"/> perspective of <strong class="bold">Clean Architecture</strong>, MVVM sits on the <strong class="bold">Interface Adapter</strong> layer. It has the role of fetching the data from<a id="_idIndexMarker551"/> the <strong class="bold">Use Case</strong> layer and <a id="_idIndexMarker552"/>converting the entities into <a id="_idIndexMarker553"/>objects that the <strong class="bold">Framework</strong> layer requires. It also handles changes to the data triggered by the user and converts this data back into entities, passing it back to the Use Case layer. In <a href="B18320_03_ePub.xhtml#_idTextAnchor055"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Data Presentation on Android</em>, we discussed the Android Architecture Components libraries and saw how we can implement ViewModels combined with <strong class="source-inline">LiveData</strong> (which acts as the observable that the View can subscribe to). An example of a <strong class="source-inline">ViewModel</strong> class might look like the following:</p>
			<p class="source-code">class MyViewModel(</p>
			<p class="source-code">    private val getUsersUseCase: GetUsersUserUseCase</p>
			<p class="source-code">) : ViewModel() {</p>
			<p class="source-code">    private val _usersFlow =</p>
			<p class="source-code">        MutableStateFlow&lt;List&lt;UiUser&gt;&gt;(listOf&lt;UiUser&gt;())</p>
			<p class="source-code">    val usersFlow: StateFlow&lt;List&lt;UiUser&gt;&gt; = _usersFlow</p>
			<p class="source-code">    fun load() {</p>
			<p class="source-code">        viewModelScope.launch {</p>
			<p class="source-code">            getUsersUseCase.execute()</p>
			<p class="source-code">                .map {</p>
			<p class="source-code">                    // Convert List&lt;User&gt; to List&lt;UiUser&gt;</p>
			<p class="source-code">                }</p>
			<p class="source-code">                .collect {</p>
			<p class="source-code">                    _usersFlow.value = it</p>
			<p class="source-code">                }</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we load a list of <strong class="source-inline">User</strong> objects <a id="_idIndexMarker554"/>and then keep that list inside a <strong class="source-inline">StateFlow</strong> object. This <strong class="source-inline">StateFlow</strong> object replaces <strong class="source-inline">LiveData</strong> and <a id="_idIndexMarker555"/>represents the observable that the View will subscribe to. When the View requires the list of users, it will invoke the <strong class="source-inline">load</strong> method.</p>
			<p>In this section, we have analyzed the MVVM architecture pattern and the difference between it and the MVP pattern. In the following section, we will look at how we can present data using MVVM inside an Android application.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>Exercise 08.01 – Implementing MVVM</h2>
			<p>Modify <em class="italic">Exercise 07.02</em>, <em class="italic">Building a local data source</em>, of <a href="B18320_07_ePub.xhtml#_idTextAnchor082"><em class="italic">Chapter 7</em></a>, <em class="italic">Building Data Sources</em>, so that a new <a id="_idIndexMarker556"/>module called <strong class="source-inline">presentation-posts</strong> is created. The module will be responsible for displaying the data from <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase</strong> using MVVM. The data will be displayed in the following format:</p>
			<ul>
				<li>A header with the following text: "Total click count: x" where x is the number of clicks taken from the <strong class="source-inline">totalClicks</strong> field in the <strong class="source-inline">Interaction</strong> class</li>
				<li>A list of posts where each row contains the following: "Author: x" and "Title: y" where x is the <strong class="source-inline">name</strong> field in the <strong class="source-inline">User</strong> class, and y is the <strong class="source-inline">title</strong> field in the <strong class="source-inline">Post</strong> class</li>
				<li>A loading view for when the data is being loaded</li>
				<li>A <strong class="source-inline">Snackbar</strong> view for when there is an error</li>
			</ul>
			<p>To complete this exercise, you will need to do the following:</p>
			<ol>
				<li>Create the <strong class="source-inline">presentation-post</strong> module.</li>
				<li>Create a new sealed class called <strong class="source-inline">UiState</strong>, which will have as subclasses <strong class="source-inline">Loading</strong>, <strong class="source-inline">Error</strong> (which will hold an error message), and <strong class="source-inline">Success</strong> (which will hold the post data).</li>
				<li>Create a new class called <strong class="source-inline">PostListItemModel</strong>, which will have <strong class="source-inline">id</strong>, <strong class="source-inline">author</strong>, and <strong class="source-inline">name</strong> as fields.</li>
				<li>Create a new class called <strong class="source-inline">PostListModel</strong>, which will have a <strong class="source-inline">headerText</strong> field and a list of <strong class="source-inline">PostListItemModel</strong> objects.</li>
				<li>Create a new class called <strong class="source-inline">PostListConverter</strong>, which will convert a <strong class="source-inline">Result.Success</strong> object into a <strong class="source-inline">UiState.Success</strong>, which holds the <strong class="source-inline">PostListModel</strong> object and will convert a <strong class="source-inline">Result.Error</strong> object into a <strong class="source-inline">UiState.Error</strong> object.</li>
				<li>Create a new class called <strong class="source-inline">PostListViewModel</strong>, which will load the data from <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase</strong>, convert the data using <strong class="source-inline">PostListConverter</strong>, and store <strong class="source-inline">UiState</strong> in <strong class="source-inline">StateFlow</strong>.</li>
				<li>Create a new Kotlin file, which will contain <strong class="source-inline">@Composable</strong> methods responsible for drawing the UI.</li>
				<li>Modify <strong class="source-inline">MainActivity</strong> in the <strong class="source-inline">app</strong> module so that it will display the list of posts.</li>
			</ol>
			<p>Follow these steps to <a id="_idIndexMarker557"/>complete the exercise:</p>
			<ol>
				<li value="1">Create a new module called <strong class="source-inline">presentation-post</strong>, which will be an Android library module.</li>
				<li>Make sure that in the top-level <strong class="source-inline">build.gradle</strong> file, the following dependencies are set:<p class="source-code">buildscript {</p><p class="source-code">    …</p><p class="source-code">    dependencies {</p><p class="source-code">        classpath gradlePlugins.android</p><p class="source-code">        classpath gradlePlugins.kotlin</p><p class="source-code">        classpath gradlePlugins.hilt</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, add the persistence libraries to the library mappings:<p class="source-code">buildscript {</p><p class="source-code">    ext {</p><p class="source-code">        …</p><p class="source-code">        versions = [</p><p class="source-code">                …</p><p class="source-code">                viewModel            : "2.4.0",</p><p class="source-code">                navigationCompose    : "2.4.0-rc01",</p><p class="source-code">                hiltNavigationCompose: "1.0.0-rc01",</p><p class="source-code">                …</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">        androidx = [</p><p class="source-code">                …</p><p class="source-code">                viewModelKtx           : "androidx.</p><p class="source-code">                    lifecycle:lifecycle-viewmodel-</p><p class="source-code">                        ktx:${versions.viewModel}",</p><p class="source-code">                viewModelCompose       : "androidx.</p><p class="source-code">                    lifecycle:lifecycle-viewmodel- </p><p class="source-code">                       compose:${versions.viewModel}",</p><p class="source-code">                navigationCompose      : "androidx.</p><p class="source-code">                navigation:navigation-compose:$</p><p class="source-code">                    {versions.navigationCompose}",</p><p class="source-code">                hiltNavigationCompose  : "androidx.</p><p class="source-code">                    hilt:hilt-navigation-compose:$</p><p class="source-code">                     {versions.hiltNavigationCompose}"</p><p class="source-code">        ]</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have added dependencies for the ViewModel library as well as the Navigation library (which will be used in later exercises).</p>
			<ol>
				<li value="4">In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">presentation-post</strong> module, make sure that the following <a id="_idIndexMarker558"/>plugins are present:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.library'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    id 'dagger.hilt.android.plugin'</p><p class="source-code">}</p></li>
				<li>In the same file, change the configurations to the ones defined in the top-level <strong class="source-inline">build.gradle</strong> file:<p class="source-code">android {</p><p class="source-code">    compileSdk defaultCompileSdkVersion</p><p class="source-code">    defaultConfig {</p><p class="source-code">        minSdk defaultMinSdkVersion</p><p class="source-code">        targetSdk defaultTargetSdkVersion</p><p class="source-code">        …</p><p class="source-code">    }</p><p class="source-code">    …</p><p class="source-code">    compileOptions {</p><p class="source-code">        sourceCompatibility javaCompileVersion</p><p class="source-code">        targetCompatibility javaCompileVersion</p><p class="source-code">    }</p><p class="source-code">    kotlinOptions {</p><p class="source-code">        jvmTarget = jvmTarget</p><p class="source-code">        useIR = true</p><p class="source-code">    }</p><p class="source-code">    buildFeatures {</p><p class="source-code">        compose true</p><p class="source-code">    }</p><p class="source-code">    composeOptions {</p><p class="source-code">        kotlinCompilerExtensionVersion versions.</p><p class="source-code">            compose</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we keep the same configuration consistent with the other modules in the application, and we<a id="_idIndexMarker559"/> integrate the Jetpack Compose configuration.</p>
			<ol>
				<li value="6">In the same file, add the dependencies to the networking libraries and domain modules:<p class="source-code">dependencies {</p><p class="source-code">    implementation(project(path: ":domain"))</p><p class="source-code">    implementation coroutines.coroutinesAndroid</p><p class="source-code">    implementation androidx.composeUi</p><p class="source-code">    implementation androidx.composeMaterial</p><p class="source-code">    implementation androidx.viewModelKtx</p><p class="source-code">    implementation androidx.viewModelCompose</p><p class="source-code">    implementation androidx.lifecycleRuntimeKtx</p><p class="source-code">    implementation androidx.navigationCompose</p><p class="source-code">    implementation di.hiltAndroid</p><p class="source-code">    kapt di.hiltCompiler</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">    testImplementation test.coroutines</p><p class="source-code">    testImplementation test.mockito</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">presentation-post</strong> module, create a package called <strong class="source-inline">list</strong>.</li>
				<li>In the <strong class="source-inline">list</strong> package, create<a id="_idIndexMarker560"/> the <strong class="source-inline">UiState</strong> class:<p class="source-code">sealed class UiState&lt;T : Any&gt; {</p><p class="source-code">    object Loading : UiState&lt;Nothing&gt;()</p><p class="source-code">    data class Error&lt;T : Any&gt;(val errorMessage: </p><p class="source-code">        String) : UiState&lt;T&gt;()</p><p class="source-code">    data class Success&lt;T : Any&gt;(val data: T) : </p><p class="source-code">        UiState&lt;T&gt;()</p><p class="source-code">}</p></li>
				<li>In the same package, create a file called <strong class="source-inline">PostListModels</strong>.</li>
				<li>In the <strong class="source-inline">PostListModels</strong> file, create the <strong class="source-inline">PostListItemModel</strong> class:<p class="source-code">data class PostListItemModel(</p><p class="source-code">    val id: Long,</p><p class="source-code">    val userId: Long,</p><p class="source-code">    val authorName: String,</p><p class="source-code">    val title: String</p><p class="source-code">)</p></li>
				<li>In the same file, create the <strong class="source-inline">PostListModel</strong> class:<p class="source-code">data class PostListModel(</p><p class="source-code">    val headerText: String = "",</p><p class="source-code">    val items: List&lt;PostListItemModel&gt; = listOf()</p><p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">presentation-post</strong> module, in the <strong class="source-inline">src/main</strong> folder, create a folder called <strong class="source-inline">res</strong>.</li>
				<li>In the <strong class="source-inline">res</strong> folder, create a new folder called <strong class="source-inline">values</strong>.</li>
				<li>In the <strong class="source-inline">values</strong> folder, create a<a id="_idIndexMarker561"/> file called <strong class="source-inline">strings.xml</strong>.</li>
				<li>In the <strong class="source-inline">strings.xml</strong> file, add the following strings:<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p><p class="source-code">&lt;resources&gt;</p><p class="source-code">    &lt;string name="total_click_count"&gt;Total click </p><p class="source-code">        count: %d&lt;/string&gt;</p><p class="source-code">    &lt;string name="author"&gt;Author: %s&lt;/string&gt;</p><p class="source-code">    &lt;string name="title"&gt;Title: %s&lt;/string&gt;</p><p class="source-code">&lt;/resources&gt;</p></li>
				<li>In the <strong class="source-inline">list</strong> package, create the <strong class="source-inline">PostListConverter</strong> class:<p class="source-code">class PostListConverter @Inject constructor(@ApplicationContext private val context: Context) {</p><p class="source-code">    fun convert(postListResult: Result</p><p class="source-code">        &lt;GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">            Response&gt;): UiState&lt;PostListModel&gt; {</p><p class="source-code">        return when (postListResult) {</p><p class="source-code">            is Result.Error -&gt; {</p><p class="source-code">                UiState.Error(postListResult.</p><p class="source-code">                 exception.localizedMessage.orEmpty())</p><p class="source-code">            }</p><p class="source-code">            is Result.Success -&gt; {</p><p class="source-code">                UiState.Success(PostListModel(</p><p class="source-code">                    headerText = context.getString(</p><p class="source-code">                        R.string.total_click_count,</p><p class="source-code">                        postListResult.data.</p><p class="source-code">                            interaction.totalClicks</p><p class="source-code">                    ),</p><p class="source-code">                    items = postListResult.data.</p><p class="source-code">                        posts.map {</p><p class="source-code">                        PostListItemModel(</p><p class="source-code">                            it.post.id,</p><p class="source-code">                            it.user.id,</p><p class="source-code">                            context.getString(R.string.author, it.user.name),</p><p class="source-code">                            context.getString(R.string.title, it.post.title)</p><p class="source-code">                        )</p><p class="source-code">                    }</p><p class="source-code">                ))</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we convert the <strong class="source-inline">Result.Success</strong> and <strong class="source-inline">Result.Error</strong> objects into equivalent <strong class="source-inline">UiState</strong> objects, which will be used to display the information to the user.</p>
			<ol>
				<li value="17">In the <strong class="source-inline">list</strong> package, create<a id="_idIndexMarker562"/> the <strong class="source-inline">PostListViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    private val useCase: </p><p class="source-code">        GetPostsWithUsersWithInteractionUseCase,</p><p class="source-code">    private val converter: PostListConverter</p><p class="source-code">) : ViewModel() {</p><p class="source-code">    private val _postListFlow =</p><p class="source-code">        MutableStateFlow&lt;UiState</p><p class="source-code">            &lt;PostListModel&gt;&gt;(UiState.Loading)</p><p class="source-code">    val postListFlow: </p><p class="source-code">        StateFlow&lt;UiState&lt;PostListModel&gt;&gt; = </p><p class="source-code">            _postListFlow</p><p class="source-code">    fun loadPosts() {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            useCase.execute</p><p class="source-code">              (GetPostsWithUsersWithInteractionUseCase</p><p class="source-code">                   .Request)</p><p class="source-code">                .map {</p><p class="source-code">                    converter.convert(it)</p><p class="source-code">                }</p><p class="source-code">                .collect {</p><p class="source-code">                    _postListFlow.value = it</p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we get the list of posts and users from the <strong class="source-inline">GetPostsWithUsersInteractionUseCase</strong> object, then we convert it to the <strong class="source-inline">UiState</strong> object, and finally, we update <strong class="source-inline">StateFlow</strong> with the <strong class="source-inline">UiState</strong> object.</p>
			<ol>
				<li value="18">In the <strong class="source-inline">list</strong> package, create a file called <strong class="source-inline">PostListScreen</strong>.</li>
				<li>In the <strong class="source-inline">PostListScreen</strong> file, add<a id="_idIndexMarker563"/> a method to display a loading widget and a <strong class="source-inline">Snackbar</strong> method:<p class="source-code">@Composable</p><p class="source-code">fun Error(errorMessage: String) {</p><p class="source-code">    Column(</p><p class="source-code">        modifier = Modifier.fillMaxSize(),</p><p class="source-code">        verticalArrangement = Arrangement.Bottom</p><p class="source-code">    ) {</p><p class="source-code">        Snackbar {</p><p class="source-code">            Text(text = errorMessage)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">@Composable</p><p class="source-code">fun Loading() {</p><p class="source-code">    Column(</p><p class="source-code">        modifier = Modifier.fillMaxSize(),</p><p class="source-code">        verticalArrangement = Arrangement.Center,</p><p class="source-code">        horizontalAlignment = </p><p class="source-code">            Alignment.CenterHorizontally,</p><p class="source-code">    ) {</p><p class="source-code">        CircularProgressIndicator()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, add a <a id="_idIndexMarker564"/>method to display the list of posts and the header:<p class="source-code">@Composable</p><p class="source-code">fun PostList(</p><p class="source-code">    postListModel: PostListModel</p><p class="source-code">) {</p><p class="source-code">    LazyColumn(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">        item(postListModel.headerText) {</p><p class="source-code">            Column(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">                Text(text = postListModel.headerText)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        items(postListModel.items) { item -&gt;</p><p class="source-code">            Column(</p><p class="source-code">                modifier = Modifier</p><p class="source-code">                    .padding(16.dp)</p><p class="source-code">            ) {</p><p class="source-code">                Text(text = item.authorName)</p><p class="source-code">                Text(text = item.title)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the same file, add a method that will monitor the value of <strong class="source-inline">postListFlow</strong> and invoke one of the<a id="_idIndexMarker565"/> preceding three methods, depending on the value of the state:<p class="source-code">@Composable</p><p class="source-code">fun PostListScreen(</p><p class="source-code">    viewModel: PostListViewModel</p><p class="source-code">) {</p><p class="source-code">    viewModel.loadPosts()</p><p class="source-code">    viewModel.postListFlow.collectAsState().value.let { state -&gt;</p><p class="source-code">        when (state) {</p><p class="source-code">            is UiState.Loading -&gt; {</p><p class="source-code">                Loading()</p><p class="source-code">            }</p><p class="source-code">            is UiState.Error -&gt; {</p><p class="source-code">                Error(state.errorMessage)</p><p class="source-code">            }</p><p class="source-code">            is UiState.Success -&gt; {</p><p class="source-code">                PostList(state.data)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">app</strong> module, make sure that the following plugins are<a id="_idIndexMarker566"/> added:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.application'</p><p class="source-code">    id 'kotlin-android'</p><p class="source-code">    id 'kotlin-kapt'</p><p class="source-code">    id 'dagger.hilt.android.plugin'</p><p class="source-code">}</p></li>
				<li>In the same file, make sure that the following dependencies are added:<p class="source-code">dependencies {</p><p class="source-code">    implementation(project(path: ":presentation-</p><p class="source-code">        post"))</p><p class="source-code">    implementation(project(path: ":domain"))</p><p class="source-code">    implementation(project(path: ":data-remote"))</p><p class="source-code">    implementation(project(path: ":data-local"))</p><p class="source-code">    implementation(project(path: ":data-repository"))</p><p class="source-code">    implementation androidx.core</p><p class="source-code">    implementation androidx.appCompat</p><p class="source-code">    implementation material.material</p><p class="source-code">    implementation androidx.composeUi</p><p class="source-code">    implementation androidx.composeMaterial</p><p class="source-code">    implementation androidx.composeUiToolingPreview</p><p class="source-code">    implementation androidx.lifecycleRuntimeKtx</p><p class="source-code">    implementation androidx.composeActivity</p><p class="source-code">    implementation androidx.navigationCompose</p><p class="source-code">    implementation androidx.hiltNavigationCompose</p><p class="source-code">    implementation di.hiltAndroid</p><p class="source-code">    kapt di.hiltCompiler</p><p class="source-code">    testImplementation test.junit</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">app</strong> module, create a package called <strong class="source-inline">injection</strong>.</li>
				<li>In the <strong class="source-inline">injection</strong> package, create<a id="_idIndexMarker567"/> a class called <strong class="source-inline">AppModule</strong>:<p class="source-code">@Module</p><p class="source-code">@InstallIn(SingletonComponent::class)</p><p class="source-code">class AppModule {</p><p class="source-code">    @Provides</p><p class="source-code">    fun provideUseCaseConfiguration() = </p><p class="source-code">        UseCase.Configuration(Dispatchers.IO)</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we provide a <strong class="source-inline">UseCase.Configuration</strong> dependency, which will be injected into all the <strong class="source-inline">UseCase</strong> subclasses. </p>
			<ol>
				<li value="26">In the <strong class="source-inline">app</strong> module, create a class called <strong class="source-inline">PostApplication</strong>:<p class="source-code">@HiltAndroidApp</p><p class="source-code">class PostApplication : Application()</p></li>
				<li>Add the <strong class="source-inline">PostApplication</strong> class to the <strong class="source-inline">AndroidManifest.xml</strong> file of the <strong class="source-inline">app</strong> module:<p class="source-code">    &lt;application</p><p class="source-code">        …</p><p class="source-code">        android:name=".PostApplication"</p><p class="source-code">        …</p><p class="source-code">   &gt;</p></li>
				<li>Modify the <strong class="source-inline">MainActivity</strong> class so that it will use the navigation library to go to the <strong class="source-inline">PostListScreen</strong> function <a id="_idIndexMarker568"/>from the <strong class="source-inline">presentation-post</strong> module:<p class="source-code">@AndroidEntryPoint</p><p class="source-code">class MainActivity : ComponentActivity() {</p><p class="source-code">    override fun onCreate(savedInstanceState: Bundle?) {</p><p class="source-code">        super.onCreate(savedInstanceState)</p><p class="source-code">        setContent {</p><p class="source-code">            CleanAppTheme {</p><p class="source-code">                Surface(color = MaterialTheme.</p><p class="source-code">                    colors.background) {</p><p class="source-code">                    val navController = </p><p class="source-code">                        rememberNavController()</p><p class="source-code">                    App(navController = navController)</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">@Composable</p><p class="source-code">fun App(navController: NavHostController) {</p><p class="source-code">    NavHost(navController, startDestination = </p><p class="source-code">        "/posts") {</p><p class="source-code">        composable(route = "/posts") {</p><p class="source-code">            PostListScreen(hiltViewModel())</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>If we run the application, we<a id="_idIndexMarker569"/> should see the following screen:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_8.04_B18320.jpg" alt="Figure 8.4 – Output of Exercise 08.01&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Output of Exercise 08.01</p>
			<p>We can see the list of post titles and the author's name for each post. The total click count is, for now, 0 because we haven't connected any logic and are yet to modify that value. We will add that logic in the exercises that follow. If an error occurs while loading this list, then we will see a<a id="_idIndexMarker570"/> snackbar with the description of the <strong class="source-inline">Exception</strong> object, and while the data is loaded, an indeterminate progress bar will be displayed.</p>
			<p>In this section, we have implemented the presentation layer of an Android application using the MVVM architecture pattern and connected the layer to the domain layer of the application to display data to the user. In the section that follows, we will expand this layer across multiple modules and see how we can navigate between screens in different modules.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor095"/>Presenting data in multiple modules</h1>
			<p>In this section, we will look at how we can separate the presentation layer into<a id="_idIndexMarker571"/> multiple modules, how we can handle the interaction between these modules, and how they can share the same data.</p>
			<p>When developing Android applications, we can group screens into different modules. For example, we can group a login or registration flow inside a library module called <em class="italic">authentication</em>, or if we have a settings section, we can group those screens inside a separate module. Sometimes these screens will have commonalities with the rest of the application, such as using the same loading progress bar or the same error mechanism. Other times, these screens must navigate to screens from other modules. The question we now need to ask is how this can happen without creating a dependency between the two modules or other modules that<a id="_idIndexMarker572"/> are on the same level. Having a direct dependency on these modules will risk creating a cyclic dependency as shown here: </p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_8.05_B18320.jpg" alt="Figure 8.5 – Module cyclic dependency&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Module cyclic dependency</p>
			<p>In <em class="italic">Figure 8.5</em>, we show what might<a id="_idIndexMarker573"/> happen if we want to navigate from the <strong class="source-inline">:auth</strong> module to the <strong class="source-inline">:settings</strong> module and vice versa. This currently is impossible because of the cyclic dependency between the two modules. To solve this issue, we will need to create a new module. This module will hold the common logic shared between the two modules and common data. This will look like the following figure:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_8.06_B18320.jpg" alt="Figure 8.6 – Common presentation module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Common presentation module</p>
			<p>In <em class="italic">Figure 8.6</em>, we added the <strong class="source-inline">:common</strong> module, which will hold reusable views or <strong class="source-inline">@Composable</strong> functions and the navigation data from the app. Over time, this module will grow, so it can be split into <a id="_idIndexMarker574"/>different modules holding different common features of the app (navigation, UI, common logic, and so on). </p>
			<p>If we are using Jetpack Compose for our <a id="_idIndexMarker575"/>application, then we can rely on the work done in <em class="italic">Exercise 03.02 – Navigating using Jetpack Compose</em> of <a href="B18320_03_ePub.xhtml#_idTextAnchor055"><em class="italic">Chapter 3</em></a>, <em class="italic">Understanding Data Presentation on Android</em>, where we defined the following structure for the app navigation: </p>
			<p class="source-code">private const val ROUTE_USERS = "users"</p>
			<p class="source-code">private const val ROUTE_USER = "users/%s"</p>
			<p class="source-code">private const val ARG_USER_NAME = "name"</p>
			<p class="source-code">sealed class AppNavigation(val route: String, val </p>
			<p class="source-code">    argumentName: String = "") {</p>
			<p class="source-code">    object Users : AppNavigation(ROUTE_USERS)</p>
			<p class="source-code">    object User : AppNavigation(String.format(ROUTE_USER, </p>
			<p class="source-code">        "{$ARG_USER_NAME}"), ARG_USER_NAME) {</p>
			<p class="source-code">        fun routeForName(name: String) = </p>
			<p class="source-code">            String.format(ROUTE_USER, name)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">routeForName</strong> method was called from the <strong class="source-inline">Users</strong> screen when a user in the list was clicked, and then the <strong class="source-inline">NavHost</strong> method would use that route to open the <strong class="source-inline">User</strong> screen. When dealing with<a id="_idIndexMarker576"/> multiple modules, the routes that will be shared by the modules can be stored in the <strong class="source-inline">:common</strong> module so that each module will have<a id="_idIndexMarker577"/> access to the route. The <strong class="source-inline">:app</strong> module, which will have <strong class="source-inline">NavHost</strong>, will then be able to navigate between each screen.</p>
			<p>When it comes to handling common logic between different modules, such as displaying the same error or loading views, we can declare the composable functions inside the <strong class="source-inline">:common</strong> module:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Error(errorMessage: String) {</p>
			<p class="source-code">    …</p>
			<p class="source-code">}</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun Loading() {</p>
			<p class="source-code">    …</p>
			<p class="source-code">} </p>
			<p>If the same state is shared between the different screens in the different modules, we can have something like the following:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun &lt;T&gt; CommonScreen(state: State&lt;T&gt;, onSuccess: </p>
			<p class="source-code">    @Composable (T) -&gt; Unit) {</p>
			<p class="source-code">    when (result) {</p>
			<p class="source-code">        is State.Success -&gt; {</p>
			<p class="source-code">            onSuccess(result.data)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        is State.Error -&gt; {</p>
			<p class="source-code">            Error(result.errorMessage)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        is State.Loading -&gt; {</p>
			<p class="source-code">            Loading()</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Here, we will check the current state and display the common error and loading views, leaving the screens themselves to only concern themselves with the successful state.</p>
			<p>In this section, we have looked at how we can split the presentation layer into multiple modules and how to <a id="_idIndexMarker578"/>handle the common elements between these modules. In the following section, we will look at an exercise on how to achieve this. Splitting the<a id="_idIndexMarker579"/> presentation layer into multiple modules will decrease application build times because Gradle caching will only rebuild modules that contain changes. Another benefit comes in the form of drawing boundaries around the application's scope, which will be beneficial when it comes to exporting only certain features of an application.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor096"/>Exercise 08.02 – Multi-module data presentation </h2>
			<p>Modify <em class="italic">Exercise 08.01 – Implementing MVVM</em> so that two new<a id="_idIndexMarker580"/> modules are created: <strong class="source-inline">presentation-post</strong> and <strong class="source-inline">presentation-common</strong>. </p>
			<p>The <strong class="source-inline">presentation-common</strong> module<a id="_idIndexMarker581"/> will have the following:</p>
			<ul>
				<li>The <strong class="source-inline">UiState</strong> class, which will be moved from the <strong class="source-inline">presentation-post</strong> module.</li>
				<li><strong class="source-inline">CommonResultConverter</strong>, which will be an abstract class with two methods: <strong class="source-inline">convert</strong>, which is a concrete method that will convert the <strong class="source-inline">Result</strong> object into a <strong class="source-inline">UiState</strong> object, and <strong class="source-inline">convertSuccess</strong>, which is an abstract method used to convert the data from <strong class="source-inline">Result.Success</strong>.</li>
				<li><strong class="source-inline">CommonScreen</strong>, which will have the <strong class="source-inline">@Composable</strong> method for displaying the different types of <strong class="source-inline">UiState</strong> and two additional methods for displaying the error snackbar and the progress bar. The two methods will be moved from <strong class="source-inline">PostListScreen</strong>.</li>
				<li><strong class="source-inline">AppNavigation</strong>, which will hold the routes to navigate to the list of posts, a single post, and a single user.</li>
				<li>The <strong class="source-inline">presentation-post</strong> module will have an additional package to display the information of a single post in the following format: Title: x and Body: y, where x is the title of a post and y is the body of the post. To display this information, a new <strong class="source-inline">ViewModel</strong> and <strong class="source-inline">Converter</strong> class will need to be created, which will convert the data from <strong class="source-inline">GetPostUseCase</strong>. When the author text is clicked, the app will navigate to the user screen, and when the <strong class="source-inline">Post</strong> list item is clicked, the app will navigate to the post screen. When either of these is clicked, <strong class="source-inline">UpdateInteractionUseCase</strong> is invoked to increase the number of clicks, which will then be reflected in the list header.</li>
				<li><strong class="source-inline">presentation-user</strong> will display the information about a single user in the following format: Name: x, Username: y, and Email: z, where x, y, and z are represented by the information inside the <strong class="source-inline">User</strong> entity. The user data will be loaded from <strong class="source-inline">GetUserUseCase</strong>.</li>
				<li>The <strong class="source-inline">app</strong> module will be updated to handle the navigation between all these screens.</li>
			</ul>
			<p>To complete this exercise, you will<a id="_idIndexMarker582"/> need to do the following:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">presentation-common</strong> module.</li>
				<li>Move the <strong class="source-inline">UiState</strong> class and the <strong class="source-inline">Error</strong> and <strong class="source-inline">Loading</strong> <strong class="source-inline">@Composable</strong> functions and create a new <strong class="source-inline">@Composable</strong> function, which will handle each type of <strong class="source-inline">UiState</strong> object inside the <strong class="source-inline">CommonScreen</strong> file.</li>
				<li>Create the <strong class="source-inline">CommonResultConverter</strong> class.</li>
				<li>Create the <strong class="source-inline">AppNavigation</strong> class.</li>
				<li>Modify the classes in <strong class="source-inline">presentation-post</strong> to reuse the preceding classes and methods.</li>
				<li>Create the <strong class="source-inline">PostScreen</strong>, <strong class="source-inline">PostViewModel</strong>, <strong class="source-inline">PostConverter</strong>, and <strong class="source-inline">PostModel</strong> classes responsible for displaying the information about a single post.</li>
				<li>Create the <strong class="source-inline">presentation-user</strong> module.</li>
				<li>Create the <strong class="source-inline">UserScreen</strong>, <strong class="source-inline">UserViewModel</strong>, <strong class="source-inline">UserConverter</strong>, and <strong class="source-inline">UserModel</strong> classes responsible for<a id="_idIndexMarker583"/> displaying the information about a single post.</li>
				<li>Implement the navigation between the screens.</li>
				<li>Add the logic to update the number of clicks inside <strong class="source-inline">PostListViewModel</strong>.</li>
			</ol>
			<p>Follow these steps to complete the exercise:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">presentation-common</strong> and <strong class="source-inline">presentation-user</strong> Android library modules.</li>
				<li>Apply steps 3–5 from <em class="italic">Exercise 08.01 – Implementing MVVM</em> for each of these new modules.</li>
				<li>In the <strong class="source-inline">build.gradle</strong> file of the <strong class="source-inline">presentation-post</strong> and <strong class="source-inline">presentation-user</strong> modules, make<a id="_idIndexMarker584"/> sure that the<a id="_idIndexMarker585"/> dependency to <strong class="source-inline">presentation-common</strong> is added:<p class="source-code">dependencies {</p><p class="source-code">    …</p><p class="source-code">    implementation(project(path: ":presentation-common"))</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">presentation-common</strong> module, create a new package called <strong class="source-inline">state</strong>.</li>
				<li>Move the <strong class="source-inline">UiState</strong> class into the preceding package.</li>
				<li>In the same package, create the <strong class="source-inline">CommonResultConverter</strong> class:<p class="source-code">abstract class CommonResultConverter&lt;T : Any, R : Any&gt; {</p><p class="source-code">    fun convert(result: Result&lt;T&gt;): UiState&lt;R&gt; {</p><p class="source-code">        return when (result) {</p><p class="source-code">            is Result.Error -&gt; {</p><p class="source-code">                UiState.Error(result.exception.</p><p class="source-code">                    localizedMessage.orEmpty())</p><p class="source-code">            }</p><p class="source-code">            is Result.Success -&gt; {</p><p class="source-code">                UiState.Success(convertSuccess</p><p class="source-code">                    (result.data))</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    abstract fun convertSuccess(data: T): R</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we return <strong class="source-inline">UiState.Error</strong> for any <strong class="source-inline">Result.Error</strong> object with the exception message, and for <strong class="source-inline">Result.Success</strong>, we return <strong class="source-inline">UiState.Success</strong> and use an abstraction for the data inside the <strong class="source-inline">Result.Success</strong> object. This<a id="_idIndexMarker586"/> represents a solution for how we <a id="_idIndexMarker587"/>can extract the common logic for displaying the error.</p>
			<ol>
				<li value="7">Modify the <strong class="source-inline">PostListConverter</strong> class from the <strong class="source-inline">presentation-post</strong> module so that it will extend <strong class="source-inline">CommonResultConverter</strong> and provide an implementation for the <strong class="source-inline">convertSuccess</strong> method:<p class="source-code">class PostListConverter @Inject constructor (@ApplicationContext private val context: Context) :</p><p class="source-code">    CommonResultConverter&lt;GetPostsWithUsersWithInteraction</p><p class="source-code">    UseCase.Response, PostListModel&gt;() {</p><p class="source-code">    override fun convertSuccess(data: </p><p class="source-code">        GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">            Response): PostListModel {</p><p class="source-code">        return PostListModel(</p><p class="source-code">            headerText = context.getString(</p><p class="source-code">                R.string.total_click_count,</p><p class="source-code">                data.interaction.totalClicks</p><p class="source-code">            ),</p><p class="source-code">            items = data.posts.map {</p><p class="source-code">                PostListItemModel(</p><p class="source-code">                    it.post.id,</p><p class="source-code">                    it.user.id,</p><p class="source-code">                    context.getString(R.string.author, </p><p class="source-code">                        it.user.name),</p><p class="source-code">                    context.getString(R.string.title, </p><p class="source-code">                        it.post.title)</p><p class="source-code">                )</p><p class="source-code">            }</p><p class="source-code">        )</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we only deal with converting <strong class="source-inline">GetPostsWithUsersWithInteractionUseCase.Response</strong> into <strong class="source-inline">PostListModel</strong>, allowing the <a id="_idIndexMarker588"/>parent class to handle the error<a id="_idIndexMarker589"/> only.</p>
			<ol>
				<li value="8">In the <strong class="source-inline">state</strong> package from the <strong class="source-inline">presentation-common</strong> module, create a new file called <strong class="source-inline">CommonScreen</strong>.</li>
				<li>In the <strong class="source-inline">CommonScreen</strong> file, add a <strong class="source-inline">CommonScreen</strong> <strong class="source-inline">@Composable</strong> method, which will check <strong class="source-inline">UiState</strong> and invoke <strong class="source-inline">Error</strong> for <strong class="source-inline">UiState.Error</strong> and <strong class="source-inline">Loading</strong> for <strong class="source-inline">UiState.Loading</strong>:<p class="source-code">@Composable</p><p class="source-code">fun &lt;T : Any&gt; CommonScreen(state: UiState&lt;T&gt;, onSuccess: @Composable (T) -&gt; Unit) {</p><p class="source-code">    when (state) {</p><p class="source-code">        is UiState.Loading -&gt; {</p><p class="source-code">            Loading()</p><p class="source-code">        }</p><p class="source-code">        is UiState.Error -&gt; {</p><p class="source-code">            Error(errorMessage = state.errorMessage)</p><p class="source-code">        }</p><p class="source-code">        is UiState.Success -&gt; {</p><p class="source-code">            onSuccess(state.data)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Move the <strong class="source-inline">Error</strong> and <strong class="source-inline">Loading</strong> <strong class="source-inline">@Composable</strong> functions from <strong class="source-inline">PostListScreen</strong> into <a id="_idIndexMarker590"/>the <strong class="source-inline">CommonScreen</strong> file.</li>
				<li>Modify the <strong class="source-inline">PostListScreen</strong> <strong class="source-inline">@Composable</strong> method from the<strong class="source-inline"> presentation-post</strong> module<a id="_idIndexMarker591"/> so that it will use the <strong class="source-inline">CommonScreen</strong> method:<p class="source-code">@Composable</p><p class="source-code">fun PostListScreen(</p><p class="source-code">    viewModel: PostListViewModel</p><p class="source-code">) {</p><p class="source-code">    viewModel.loadPosts()</p><p class="source-code">    viewModel.postListFlow.collectAsState().value.let </p><p class="source-code">        { state -&gt;</p><p class="source-code">        CommonScreen(state = state) {</p><p class="source-code">            PostList(postListModel = it)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Now the entire logic for converting and showing the list of posts will only deal with the associated objects, leaving the error and loading scenarios in the <strong class="source-inline">presentation-common</strong> module.</p>
			<ol>
				<li value="12">In <strong class="source-inline">presentation-common</strong>, create a new package called <strong class="source-inline">navigation</strong>.</li>
				<li>In the <strong class="source-inline">navigation</strong> package, create a class called <strong class="source-inline">PostInput</strong>:<p class="source-code">data class PostInput(val postId: Long)</p></li>
			</ol>
			<p>This class is meant to represent <a id="_idIndexMarker592"/>the input that the post screen will require to load its data.</p>
			<ol>
				<li value="14">In the same package, create a class called <strong class="source-inline">UserInput</strong>:<p class="source-code">data class UserInput(val userId: Long)</p></li>
			</ol>
			<p>This class is meant to<a id="_idIndexMarker593"/> represent the input that the user screen will require to load its data.</p>
			<ol>
				<li value="15">In the same package, create a new class called <strong class="source-inline">NavRoutes</strong>:<p class="source-code">private const val ROUTE_POSTS = "posts"</p><p class="source-code">private const val ROUTE_POST = "posts/%s"</p><p class="source-code">private const val ROUTE_USER = "users/%s"</p><p class="source-code">private const val ARG_POST_ID = "postId"</p><p class="source-code">private const val ARG_USER_ID = "userId"</p><p class="source-code">sealed class NavRoutes(</p><p class="source-code">    val route: String,</p><p class="source-code">    val arguments: List&lt;NamedNavArgument&gt; = </p><p class="source-code">        emptyList()</p><p class="source-code">) {</p><p class="source-code">    …</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we define the paths for each screen. The posts screen will have no arguments, but the user <a id="_idIndexMarker594"/>and post screens will require the <strong class="source-inline">postId</strong> and <strong class="source-inline">userId</strong> values.</p>
			<ol>
				<li value="16">Create the <strong class="source-inline">Posts</strong> class<a id="_idIndexMarker595"/> in the <strong class="source-inline">NavRoutes</strong> class:<p class="source-code">sealed class NavRoutes(</p><p class="source-code">    val route: String,</p><p class="source-code">    val arguments: List&lt;NamedNavArgument&gt; = </p><p class="source-code">        emptyList()</p><p class="source-code">) {</p><p class="source-code">    object Posts : NavRoutes(ROUTE_POSTS)</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Post</strong> class in the <strong class="source-inline">NavRoutes</strong> class:<p class="source-code">sealed class NavRoutes(</p><p class="source-code">    val route: String,</p><p class="source-code">    val arguments: List&lt;NamedNavArgument&gt; = </p><p class="source-code">        emptyList()</p><p class="source-code">) {</p><p class="source-code">    object Post : NavRoutes(</p><p class="source-code">        route = String.format(ROUTE_POST, </p><p class="source-code">            "{$ARG_POST_ID}"),</p><p class="source-code">        arguments = listOf(navArgument(ARG_POST_ID) {</p><p class="source-code">            type = NavType.LongType</p><p class="source-code">        })</p><p class="source-code">    ) {</p><p class="source-code">        fun routeForPost(postInput: PostInput) = </p><p class="source-code">           String.format(ROUTE_POST, postInput.postId)</p><p class="source-code">        fun fromEntry(entry: NavBackStackEntry): </p><p class="source-code">            PostInput {</p><p class="source-code">            return PostInput(entry.arguments?.</p><p class="source-code">                getLong(ARG_POST_ID) ?: 0L)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we will need to break down <a id="_idIndexMarker596"/>the <strong class="source-inline">Post</strong> input into the arguments for the URL. The <strong class="source-inline">routeForPost</strong> method will create a <strong class="source-inline">/posts/1</strong> URL for a <strong class="source-inline">Post</strong> object that has the ID <strong class="source-inline">1</strong>. The <strong class="source-inline">fromEntry</strong> method will re-assemble the <strong class="source-inline">PostInput</strong> object from the navigation entry object. The reason we are taking this approach is that the <a id="_idIndexMarker597"/>navigation library discourages the use of <strong class="source-inline">Parcelable</strong>, which means that passing data between different screens will have to be done through the URL. To avoid any issues with keeping track of the arguments across multiple modules, we can instead <a id="_idIndexMarker598"/>use objects and keep the logic to read from arguments and construct the arguments isolated to this class.</p>
			<ol>
				<li value="18">Create the <strong class="source-inline">User</strong> class inside <a id="_idIndexMarker599"/>the <strong class="source-inline">NavRoutes</strong> class:<p class="source-code">sealed class NavRoutes(</p><p class="source-code">    val route: String,</p><p class="source-code">    val arguments: List&lt;NamedNavArgument&gt; = emptyList()</p><p class="source-code">) {</p><p class="source-code">    object User : NavRoutes(</p><p class="source-code">        route = String.format(ROUTE_USER, </p><p class="source-code">            "{$ARG_USER_ID}"),</p><p class="source-code">        arguments = listOf(navArgument(ARG_USER_ID) {</p><p class="source-code">            type = NavType.LongType</p><p class="source-code">        })</p><p class="source-code">    ) {</p><p class="source-code">        fun routeForUser(userInput: UserInput) = </p><p class="source-code">           String.format(ROUTE_USER, userInput.userId)</p><p class="source-code">        fun fromEntry(entry: NavBackStackEntry): </p><p class="source-code">            UserInput {</p><p class="source-code">            return UserInput(entry.arguments?.getLong</p><p class="source-code">                (ARG_USER_ID) ?: 0L)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we apply the same principle as we did for the <strong class="source-inline">Post</strong> class.</p>
			<ol>
				<li value="19">Create a new package <a id="_idIndexMarker600"/>called <strong class="source-inline">single</strong> in the <strong class="source-inline">presentation-post</strong> module.</li>
				<li>In the <strong class="source-inline">single</strong> package, create the <strong class="source-inline">PostModel</strong> class:<p class="source-code">data class PostModel(</p><p class="source-code">    val title: String,</p><p class="source-code">    val body: String</p><p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">single</strong> package, create<a id="_idIndexMarker601"/> the <strong class="source-inline">PostConverter</strong> class:<p class="source-code">class PostConverter @Inject constructor(@ApplicationContext private val context: Context) :</p><p class="source-code">    CommonResultConverter&lt;GetPostUseCase.Response, </p><p class="source-code">        PostModel&gt;() {</p><p class="source-code">    override fun convertSuccess(data: </p><p class="source-code">        GetPostUseCase.Response): PostModel {</p><p class="source-code">        return PostModel(</p><p class="source-code">            context.getString(R.string.title, </p><p class="source-code">                data.post.title),</p><p class="source-code">            context.getString(R.string.body, </p><p class="source-code">                data.post.body)</p><p class="source-code">        )</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">body</strong> string to <strong class="source-inline">strings.xml</strong> of the <strong class="source-inline">presentation-post</strong> module:<p class="source-code">&lt;resources&gt;</p><p class="source-code">    …</p><p class="source-code">    &lt;string name="body"&gt;Body: %s&lt;/string&gt;</p><p class="source-code">&lt;/resources&gt;</p></li>
				<li>In<a id="_idIndexMarker602"/> the <strong class="source-inline">single</strong> package, create<a id="_idIndexMarker603"/> the <strong class="source-inline">PostViewModel</strong> class:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostViewModel @Inject constructor(</p><p class="source-code">    private val postUseCase: GetPostUseCase,</p><p class="source-code">    private val postConverter: PostConverter</p><p class="source-code">) : ViewModel() {</p><p class="source-code">    private val _postFlow =</p><p class="source-code">        MutableStateFlow&lt;UiState&lt;PostModel&gt;&gt;(UiState.Loading)</p><p class="source-code">    val postFlow: StateFlow&lt;UiState&lt;PostModel&gt;&gt; = </p><p class="source-code">        _postFlow</p><p class="source-code">    fun loadPost(postId: Long) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            postUseCase.execute(GetPostUseCase.</p><p class="source-code">                Request(postId))</p><p class="source-code">                .map {</p><p class="source-code">                    postConverter.convert(it)</p><p class="source-code">                }</p><p class="source-code">                .collect {</p><p class="source-code">                    _postFlow.value = it</p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we are using <strong class="source-inline">GetPostUseCase</strong> to load the information about a particular post and are using<a id="_idIndexMarker604"/> the converter defined earlier to convert the data into <strong class="source-inline">PostModel</strong>, which <a id="_idIndexMarker605"/>will be set in the <strong class="source-inline">Flow</strong> object.</p>
			<ol>
				<li value="24">In the <strong class="source-inline">single</strong> package, create the <strong class="source-inline">PostScreen</strong> file, which will display the post information:<p class="source-code">@Composable</p><p class="source-code">fun PostScreen(</p><p class="source-code">    viewModel: PostViewModel,</p><p class="source-code">    postInput: PostInput</p><p class="source-code">) {</p><p class="source-code">    viewModel.loadPost(postInput.postId)</p><p class="source-code">    viewModel.postFlow.collectAsState().value.let { </p><p class="source-code">        result -&gt;</p><p class="source-code">        CommonScreen(result) { postModel -&gt;</p><p class="source-code">            Post(postModel)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">@Composable</p><p class="source-code">fun Post(postModel: PostModel) {</p><p class="source-code">    Column(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">        Text(text = postModel.title)</p><p class="source-code">        Text(text = postModel.body)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we follow the same <a id="_idIndexMarker606"/>principle as for the <strong class="source-inline">PostListScreen</strong> file, where we split into two methods, <strong class="source-inline">PostScreen</strong> for observing the <strong class="source-inline">UiState</strong> object and <strong class="source-inline">PostListScreen</strong> to deal with<a id="_idIndexMarker607"/> drawing the user interface.</p>
			<ol>
				<li value="25">In the <strong class="source-inline">presentation-user</strong> module, create a new package called <strong class="source-inline">single</strong>.</li>
				<li>In the <strong class="source-inline">single</strong> package, create a new class called <strong class="source-inline">UserModel</strong>:<p class="source-code">data class UserModel(</p><p class="source-code">    val name: String,</p><p class="source-code">    val username: String,</p><p class="source-code">    val email: String</p><p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">single</strong> package, create a new class called <strong class="source-inline">UserConverter</strong>:<p class="source-code">class UserConverter @Inject constructor(@ApplicationContext private val context: Context) :</p><p class="source-code">    CommonResultConverter&lt;GetUserUseCase.Response, </p><p class="source-code">        UserModel&gt;() {</p><p class="source-code">    </p><p class="source-code">    override fun convertSuccess(data: GetUserUseCase.</p><p class="source-code">        Response): UserModel {</p><p class="source-code">        return UserModel(</p><p class="source-code">            context.getString(R.string.name,</p><p class="source-code">                data.user.name),</p><p class="source-code">            context.getString(R.string.username, </p><p class="source-code">                data.user.username),</p><p class="source-code">            context.getString(R.string.email, </p><p class="source-code">                data.user.email)</p><p class="source-code">        )</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">res/values/strings.xml</strong> file<a id="_idIndexMarker608"/> inside the <strong class="source-inline">main</strong> folder in<a id="_idIndexMarker609"/> the <strong class="source-inline">presentation-user</strong> module:<p class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</p><p class="source-code">&lt;resources&gt;</p><p class="source-code">    &lt;string name="name"&gt;Name: %s&lt;/string&gt;</p><p class="source-code">    &lt;string name="username"&gt;Username: %s&lt;/string&gt;</p><p class="source-code">    &lt;string name="email"&gt;Email: %s&lt;/string&gt;</p><p class="source-code">&lt;/resources&gt;</p></li>
				<li>Inside the <strong class="source-inline">single</strong> package, create <strong class="source-inline">UserViewModel</strong>:<p class="source-code">@HiltViewModel</p><p class="source-code">class UserViewModel @Inject constructor(</p><p class="source-code">    private val userUseCase: GetUserUseCase,</p><p class="source-code">    private val converter: UserConverter</p><p class="source-code">) : ViewModel() {</p><p class="source-code">    private val _userFlow =</p><p class="source-code">        MutableStateFlow&lt;UiState&lt;UserModel&gt;&gt;</p><p class="source-code">            (UiState.Loading)</p><p class="source-code">    val userFlow: StateFlow&lt;UiState&lt;UserModel&gt;&gt; = </p><p class="source-code">        _userFlow</p><p class="source-code">    fun loadUser(userId: Long) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            userUseCase.execute</p><p class="source-code">                (GetUserUseCase.Request(userId))</p><p class="source-code">                .map {</p><p class="source-code">                    converter.convert(it)</p><p class="source-code">                }</p><p class="source-code">                .collect {</p><p class="source-code">                    _userFlow.value = it</p><p class="source-code">                }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we take the user data from <strong class="source-inline">GetUserUseCase</strong>, convert it using <strong class="source-inline">UserConverter</strong>, and post<a id="_idIndexMarker610"/> the result in the <strong class="source-inline">Flow</strong> object.</p>
			<ol>
				<li value="30">In the <strong class="source-inline">single</strong> package, create<a id="_idIndexMarker611"/> the <strong class="source-inline">UserScreen</strong> file:<p class="source-code">@Composable</p><p class="source-code">fun UserScreen(</p><p class="source-code">    viewModel: UserViewModel,</p><p class="source-code">    userInput: UserInput</p><p class="source-code">) {</p><p class="source-code">    viewModel.loadUser(userInput.userId)</p><p class="source-code">    viewModel.userFlow.collectAsState().value.let { </p><p class="source-code">        result -&gt;</p><p class="source-code">        CommonScreen(result) { userModel -&gt;</p><p class="source-code">            User(userModel)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">@Composable</p><p class="source-code">fun User(userModel: UserModel) {</p><p class="source-code">    Column(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">        Text(text = userModel.name)</p><p class="source-code">        Text(text = userModel.username)</p><p class="source-code">        Text(text = userModel.email)</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we take the same approach as<a id="_idIndexMarker612"/> the other screens, where in one method, we subscribe to changes in <strong class="source-inline">UiState</strong>, and in the other, we display the<a id="_idIndexMarker613"/> user information.</p>
			<ol>
				<li value="31">Add the click listeners in <strong class="source-inline">PostListScreen</strong>:<p class="source-code">@Composable</p><p class="source-code">fun PostList(</p><p class="source-code">    postListModel: PostListModel,</p><p class="source-code">    <strong class="bold">onRowClick: (PostListItemModel) -&gt; Unit</strong>,</p><p class="source-code">    <strong class="bold">onAuthorClick: (PostListItemModel) -&gt; Unit</strong></p><p class="source-code">) {</p><p class="source-code">    LazyColumn(modifier = Modifier.padding(16.dp)) {</p><p class="source-code">        …</p><p class="source-code">        items(postListModel.items) { item -&gt;</p><p class="source-code">            Column(modifier = Modifier</p><p class="source-code">                .padding(16.dp)</p><p class="source-code">                <strong class="bold">.clickable {</strong></p><p class="source-code">                    <strong class="bold">onRowClick(item)</strong></p><p class="source-code">                <strong class="bold">}</strong>) {</p><p class="source-code">                <strong class="bold">ClickableText(text = AnnotatedString(</strong></p><p class="source-code"><strong class="bold">                    text =</strong> <strong class="bold">item.authorName), onClick =  </strong></p><p class="source-code"><strong class="bold">                {</strong></p><p class="source-code">                    <strong class="bold">onAuthorClick(item)</strong></p><p class="source-code">                <strong class="bold">})</strong></p><p class="source-code">                Text(text = item.title)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>In the preceding snippet, we specify click listeners for when the row is clicked and for when the author is clicked. Because we are applying state hoisting, we want to propagate the click listeners to the caller of the <strong class="source-inline">PostList</strong> method. To achieve this, we define a<a id="_idIndexMarker614"/> parameter for each click listener as a<a id="_idIndexMarker615"/> lambda function that has as input the row data and requires no result. More information about lambdas can be found here: <a href="https://kotlinlang.org/docs/lambdas.html#function-types">https://kotlinlang.org/docs/lambdas.html#function-types</a>.</p>
			<ol>
				<li value="32">Modify the <strong class="source-inline">PostListScreen</strong> <strong class="source-inline">@Composable</strong> method so that when the user is clicked, we navigate to the user screen, and when the row is clicked, we navigate to the post:<p class="source-code">@Composable</p><p class="source-code">fun PostListScreen(</p><p class="source-code">    viewModel: PostListViewModel,</p><p class="source-code">    navController: NavController</p><p class="source-code">) {</p><p class="source-code">    viewModel.loadPosts()</p><p class="source-code">    viewModel.postListFlow.collectAsState().value.let </p><p class="source-code">        { state -&gt;</p><p class="source-code">        CommonScreen(state = state) {</p><p class="source-code">            PostList(it, { postListItem -&gt;</p><p class="source-code">                navController.navigate(NavRoutes.Post.</p><p class="source-code">                    routeForPost(PostInput</p><p class="source-code">                        (postListItem.id)))</p><p class="source-code">            }) { postListItem -&gt;</p><p class="source-code">                navController.navigate(NavRoutes.User.</p><p class="source-code">                    routeForUser(UserInput</p><p class="source-code">                        (postListItem.userId)))</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">build.gradle</strong> of the <strong class="source-inline">app</strong> module, make<a id="_idIndexMarker616"/> sure that the dependencies to <strong class="source-inline">presentation-common</strong> and <strong class="source-inline">presentation-user</strong> are <a id="_idIndexMarker617"/>added:<p class="source-code">dependencies {</p><p class="source-code">    …</p><p class="source-code">    implementation(project(path: ":presentation-</p><p class="source-code">        user"))</p><p class="source-code">    implementation(project(path: ":presentation-</p><p class="source-code">        common"))</p><p class="source-code">    …</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">MainActivity</strong> file, modify the <strong class="source-inline">App</strong> method so that the navigation between the different screens is implemented:<p class="source-code">@Composable</p><p class="source-code">fun App(navController: NavHostController) {</p><p class="source-code">    NavHost(navController, startDestination = </p><p class="source-code">        NavRoutes.Posts.route) {</p><p class="source-code">        composable(route = NavRoutes.Posts.route) {</p><p class="source-code">            PostListScreen(hiltViewModel(), </p><p class="source-code">                navController)</p><p class="source-code">        }</p><p class="source-code">        composable(</p><p class="source-code">            route = NavRoutes.Post.route,</p><p class="source-code">            arguments = NavRoutes.Post.arguments</p><p class="source-code">        ) {</p><p class="source-code">            PostScreen(</p><p class="source-code">                hiltViewModel(),</p><p class="source-code">                NavRoutes.Post.fromEntry(it)</p><p class="source-code">            )</p><p class="source-code">        }</p><p class="source-code">        composable(</p><p class="source-code">            route = NavRoutes.User.route,</p><p class="source-code">            arguments = NavRoutes.User.arguments</p><p class="source-code">        ) {</p><p class="source-code">            UserScreen(</p><p class="source-code">                hiltViewModel(),</p><p class="source-code">                NavRoutes.User.fromEntry(it)</p><p class="source-code">            )</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we add all the screens<a id="_idIndexMarker618"/> in the application to the navigation graph, and in the case of <strong class="source-inline">UserScreen</strong> and <strong class="source-inline">PostScreen</strong>, we extract the <strong class="source-inline">UserInput</strong> and <strong class="source-inline">PostInput</strong> objects from the navigation graph entries. We will <a id="_idIndexMarker619"/>now need to add the interaction.</p>
			<ol>
				<li value="35">Add an <strong class="source-inline">Interaction</strong> field inside <strong class="source-inline">PostListModel</strong>:<p class="source-code">data class PostListModel(</p><p class="source-code">    …</p><p class="source-code">    val interaction: Interaction</p><p class="source-code">)</p></li>
				<li>Modify <strong class="source-inline">PostListConverter</strong> to include the <strong class="source-inline">interaction</strong> field:<p class="source-code">class PostListConverter @Inject constructor (@ApplicationContext private val context: Context) :</p><p class="source-code">    CommonResultConverter&lt;GetPostsWithUsersWithInteraction</p><p class="source-code">    UseCase.Response, PostListModel&gt;() {</p><p class="source-code">    override fun convertSuccess(data: </p><p class="source-code">        GetPostsWithUsersWithInteractionUseCase.</p><p class="source-code">            Response): PostListModel {</p><p class="source-code">        return PostListModel(</p><p class="source-code">            …</p><p class="source-code">            interaction = data.interaction</p><p class="source-code">        )</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Add a reference to <strong class="source-inline">UpdateInteractionUseCase</strong> in <strong class="source-inline">PostListViewModel</strong> and a method to<a id="_idIndexMarker620"/> update the<a id="_idIndexMarker621"/> interaction:<p class="source-code">@HiltViewModel</p><p class="source-code">class PostListViewModel @Inject constructor(</p><p class="source-code">    …</p><p class="source-code">    <strong class="bold">private val updateInteractionUseCase:</strong> </p><p class="source-code">        <strong class="bold">UpdateInteractionUseCase</strong></p><p class="source-code">) : ViewModel() {</p><p class="source-code">    …</p><p class="source-code">    fun updateInteraction(interaction: Interaction) {</p><p class="source-code">        viewModelScope.launch {</p><p class="source-code">            updateInteractionUseCase.execute(</p><p class="source-code">                UpdateInteractionUseCase.Request(</p><p class="source-code">                    interaction.copy(</p><p class="source-code">                        totalClicks = interaction.</p><p class="source-code">                            totalClicks + 1</p><p class="source-code">                    )</p><p class="source-code">                )</p><p class="source-code">            ).collect()</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Modify the <strong class="source-inline">PostListScreen</strong> <strong class="source-inline">@Composable</strong> method<a id="_idIndexMarker622"/> so that it will call to update the interaction for each click:<p class="source-code">@Composable</p><p class="source-code">fun PostListScreen(</p><p class="source-code">    viewModel: PostListViewModel,</p><p class="source-code">    navController: NavController</p><p class="source-code">) {</p><p class="source-code">    …</p><p class="source-code">    viewModel.postListFlow.collectAsState().value.let </p><p class="source-code">        { state -&gt;</p><p class="source-code">        CommonScreen(state = state) {</p><p class="source-code">            PostList(it, { postListItem -&gt;</p><p class="source-code">                <strong class="bold">viewModel.updateInteraction(it.interaction)</strong></p><p class="source-code">                …</p><p class="source-code">            }) { postListItem -&gt;</p><p class="source-code">                <strong class="bold">viewModel.updateInteraction(it.interaction)</strong></p><p class="source-code">                …</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>If we run<a id="_idIndexMarker623"/> the application, we will see<a id="_idIndexMarker624"/> an output like the one in the following figure:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_8.07_B18320.jpg" alt="Figure 8.7 – Output of Exercise 08.02&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Output of Exercise 08.02</p>
			<p>We can see from <em class="italic">Figure 8.7</em> that when the row is clicked, we are taken to the screen displaying the post information, and when the author is clicked, we are taken to the user information. By placing the <strong class="source-inline">NavRoutes</strong> class in the <strong class="source-inline">presentation-common</strong> module, we can navigate from the post list on a screen located in the same module (post) and a screen located in a different module (user). The solution of creating additional modules is a good way to <a id="_idIndexMarker625"/>avoid cyclic dependencies not <a id="_idIndexMarker626"/>only for modules in the presentation layer but also for modules in the other layers as well. </p>
			<p>In this exercise, we have learned how to split the presentation layer into separate modules and how we can use a common module to hold shared logic and data required by all the modules in the layer. This is a technique that can be used for other layers in the application if we want them split up as well.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor097"/>Summary</h1>
			<p>In this chapter, we explored the presentation layer of an Android application and a few different approaches for implementing this layer, such as MVC, MVP, and MVVM. We decided to focus on the MVVM approach because of the many benefits involving the life cycle and the compatibility with Jetpack Compose. We then looked at what happens when we want to split the presentation layer across multiple modules and how we can solve the common logic between these modules. In the chapter that follows, we will further build upon the MVVM pattern and study the <strong class="bold">Model-View-Intent</strong> (<strong class="bold">MVI</strong>) pattern, which further takes advantage of the Observable pattern to incorporate the user actions into states that can be observed. </p>
		</div>
	</body></html>