- en: Chapter 9. User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。用户界面
- en: While it may seem that we have created the bulk of our game, there is one very
    important thing that is still missing — the **User Interface** (UI). Creating
    UIs is very important, as this is the real look and feel that your game will have
    for your users. If you have a generic interface, no matter how your models look,
    the game will feel generic. There are many ways that you can design a UI in Unity,
    but most of those are designed for desktop applications and will perform poorly
    on mobile devices. We will examine the standard Unity library facility for building
    our UI and we will build a UI with the Prime31 UIToolkit.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然可能看起来我们已经创建了游戏的大部分内容，但还有一个非常重要的东西仍然缺失——**用户界面**（UI）。创建UI非常重要，因为这将是您的游戏对用户呈现的真实外观和感觉。如果您有一个通用的界面，无论您的模型看起来如何，游戏都会显得很普通。您可以在Unity中设计UI的许多方法，但其中大多数是为桌面应用程序设计的，在移动设备上表现不佳。我们将检查标准的Unity库设施来构建我们的UI，并使用Prime31
    UIToolkit构建一个UI。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Use the native Unity interface system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生的Unity界面系统
- en: Explore the popular third-party Prime31 UIToolkit approach for generating interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索流行的第三方Prime31 UIToolkit方法来生成界面
- en: After we finish this chapter we will have all of the tools at our disposal to
    create almost any type of game we want to create.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这一章之后，我们将拥有创建几乎所有我们想要创建的游戏所需的所有工具。
- en: So lets get on with it...
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧...
- en: Important preliminary points
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要预备要点
- en: This chapter assumes that you understand the basic concepts of tools such as
    GIMP and Photoshop including layers, masks, and fills. While the screens in the
    chapter will be focussed primarily on Photoshop, all of the concepts utilized
    here are easily transferrable to other software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经理解了诸如GIMP和Photoshop等工具的基本概念，包括图层、蒙版和填充。虽然本章中的屏幕将主要关注Photoshop，但这里使用的所有概念都很容易转移到其他软件。
- en: Translating the design
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译设计
- en: The design sketch of Battlecry's user interface design should be able to display
    some simple assets for displaying the player's current health, the score of the
    game, a joystick, and an action button.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 战吼用户界面设计的草图应该能够显示一些简单的资产，用于显示玩家的当前健康、游戏的分数、摇杆和动作按钮。
- en: '![Translating the design](img/978-1-84969-040-9_9_1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![翻译设计](img/978-1-84969-040-9_9_1.jpg)'
- en: We covered the joystick and action button in the Input chapter so we can focus
    on the health display and showing the score. We need a nice font for displaying
    text and some images to show the health. In addition, we will want to build a
    main menu for the game that will consist of a button to start the game and one
    that will show the credits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“输入”章节中已经涵盖了摇杆和动作按钮，因此我们可以专注于健康显示和显示分数。我们需要一个漂亮的字体来显示文本，以及一些图像来显示健康。此外，我们还想为游戏构建一个主菜单，它将包括一个开始游戏的按钮和一个显示信用额的按钮。
- en: Immediate mode game user interfaces
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时模式游戏用户界面
- en: The Unity game engine provides developers with a complete integrated system
    for game user interface (GUI) development. These GUIs are built using an immediate
    mode approach to defining the GUI and responding to its events. For most games
    this will not be an issue and will be one of the easiest ways for you to put a
    HUD and simple controls on the screen. However, as it is an immediate mode API,
    the developer is very close to the mechanics of how the UI operates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity游戏引擎为开发者提供了一个完整的集成系统，用于游戏用户界面（GUI）开发。这些GUI是通过即时模式方法来定义GUI并响应其事件构建的。对于大多数游戏来说，这不会成为问题，并且将是您将HUD和简单控制放置在屏幕上最容易的方式之一。然而，由于它是一个即时模式API，开发者非常接近UI操作的机制。
- en: As an example, we can look at how to construct a simple GUI that displays a
    button on the screen. As you might have guessed, since there are no tools, and
    as we're in immediate mode, we have to manually specify the layout for the components
    on the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看看如何构建一个简单的GUI，在屏幕上显示一个按钮。正如你可能猜到的，由于没有工具，并且我们处于即时模式，我们必须手动指定屏幕上组件的布局。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Despite how different this may feel from hopping into Flash, Photoshop, Objective-C,
    or your favorite GUI framework, immediate mode GUIs are nothing new. In a traditional
    GUI framework, you setup your GUI components in a variety of classes and then
    setup callbacks and messaging systems so that the event loop can relay data from
    the components to the actual application logic that will handle the events. So
    what's wrong with this, you may ask. At the end of the day you will find that
    you have code all over your application — especially if you're really trying to
    be object-oriented and are designing your application for reuse.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能与跳入Flash、Photoshop、Objective-C或你最喜欢的GUI框架的感觉不同，但即时模式GUI并不是什么新鲜事物。在传统的GUI框架中，你会在各种类中设置你的GUI组件，然后设置回调和消息系统，以便事件循环可以将数据从组件传递到处理事件的实际应用程序逻辑。那么，这有什么问题吗？你可能想知道。最终你会发现，你的应用程序到处都是代码——特别是如果你真的试图做到面向对象，并且为重用设计你的应用程序的话。
- en: While this is something that makes sense for a complex business application
    that may have to change its layout dynamically based on user-type, screen resolution,
    or the data being used, that is not the problem that we're trying to solve with
    our game. You will find that an immediate mode GUI is very compact, with all of
    the logic that makes your game work generally in a small number of places. Any
    state data necessary for the UI is made available to all of the interface components
    without the need for querying or passing data. This makes the application easier
    to follow and is very performance friendly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于可能需要根据用户类型、屏幕分辨率或使用的数据动态更改布局的复杂商业应用程序来说是有意义的，但这并不是我们试图通过我们的游戏解决的问题。你会发现即时模式GUI非常紧凑，所有使你的游戏工作的逻辑通常都在少数几个地方。任何必要的状态数据都会提供给所有界面组件，无需查询或传递数据。这使得应用程序更容易跟踪，并且对性能非常友好。
- en: Time for action — Creating the menu background
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 创建菜单背景
- en: The first thing we need to do is create a background for the main menu of our
    game. This will give us a chance to see how to setup Unity GUI components. To
    keep things simple, initially we will start with the main menu.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们游戏的主菜单创建一个背景。这将给我们一个机会看到如何设置Unity GUI组件。为了使事情简单，最初我们将从主菜单开始。
- en: Create a new scene called **MainMenu**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**MainMenu**的新场景。
- en: As this is a military style game we can use a simple camouflage texture for
    the background of our main menu.![Time for action — Creating the menu background](img/978-1-84969-040-9_9_2.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个军事风格的游戏，我们可以为我们的主菜单背景使用简单的迷彩纹理。![行动时间 — 创建菜单背景](img/978-1-84969-040-9_9_2.jpg)
- en: On top of this we will display the buttons for our game. While it is possible
    for us to modify our existing **GameIntro** scene to handle a main menu, it is
    better from a design perspective to create a standalone scene for the main menu.
    This will aid the development workflow as content creators can work on this scene
    in isolation.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此之上，我们将显示我们游戏的按钮。虽然我们可以修改现有的**GameIntro**场景以处理主菜单，但从设计角度来看，最好创建一个独立的主菜单场景。这将有助于开发工作流程，因为内容创作者可以独立地工作在这个场景上。
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_3.jpg)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 创建菜单背景](img/978-1-84969-040-9_9_3.jpg)'
- en: After adding our **MainMenu** scene we need to make a change to our `PlayIntroMovie`
    script to have it load the **MainMenu** scene instead of just dropping directly
    into the game.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加我们的**MainMenu**场景后，我们需要对`PlayIntroMovie`脚本进行修改，使其加载**MainMenu**场景而不是直接进入游戏。
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is to import the texture that we will be using for the background.
    In the project folder for this chapter you will find the asset `army_camo.jpg`.
    If you drag this into Unity it will be imported and ready for use. However, there
    are a few settings we want to change for our iOS release. If you display the **Inspector**
    settings for the asset you will find that it is imported at 1024x1024\. However,
    for our iOS game, we don't want such a large texture simply as a background.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们要用于背景的纹理导入。在本章的项目文件夹中，你可以找到资产`army_camo.jpg`。如果你将其拖入Unity中，它将被导入并准备好使用。然而，对于我们的iOS发布版本，我们不想仅仅作为背景使用如此大的纹理。如果你显示该资产的**检查器**设置，你会发现它是以1024x1024的分辨率导入的。然而，对于我们的iOS游戏，我们不想使用如此大的纹理作为背景。
- en: Override the settings for this texture for our iOS device by selecting the iPhone
    icon and checking the box to override the settings for iPhone. Set the **Max Size**
    for this texture to **512** and click on the **Apply** button.![Time for action
    — Creating the menu background](img/978-1-84969-040-9_9_4.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now our texture for iOS will only be 512x512, while it can be 1024x1024 for
    other platforms. From a workflow perspective this is important, as you will want
    to override your assets for the platform you're deploying to, while not creating
    entirely new assets for each platform.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our next step is to make this image the background of the scene. Select the
    texture that we just imported in the **Project** view and create a **GUI Texture**.![Time
    for action — Creating the menu background](img/978-1-84969-040-9_9_5.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the scale of our background texture to (1,1,1) so that it is scaled to
    fill the screen. Since a **GUITexture** is a Unity UI construct specifically for
    UI elements, all of its position and scale is done in screen space as opposed
    to world space. By setting this to **1** in all dimensions. We're telling Unity
    to fill the screen with our **GUITexture**. The Z-axis in this case is the same
    as for prior chapters. If you need to draw other items in front of the background,
    they simply need to have a lower Z value than the background.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We did not have to make the **GUITexture** a child of the camera for this to
    happen.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_6.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Run the project and you will see a camouflage texture that fills the entire
    screen.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_7.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just created a background for our main menu scene. As you have noticed,
    this item is not parented to any part of the scene and will display without respect
    to any other items in the scene. Now we can move on to adding buttons to our menu.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Putting the menu on the screen
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the immediate mode GUI work with Unity we simply need to provide one
    function in a script, `OnGUI`. Like any other script we will attach our UI script
    to a **GameObject** that is located in the scene and Unity will call it every
    frame to ensure that any GUI events that have happened during that frame are processed.
    One obvious warning is that this means that your GUI loops should be tight loops
    and highly optimized; you shouldn't be performing complex time-consuming computations
    inside the GUI code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at our main menu example we know that we have two simple buttons
    that need to perform very specific actions when clicked. Thus, from a pseudo code
    perspective, we know that our application simply needs a basic if/else condition
    to examine the two controls that we're using.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example `MainMenuButton` and `CreditsMenuButton` represent two GUI controls
    that we will define in our script that will cause the main scene or credits scene
    to be opened respectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Adding buttons to the GUI
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Import the two textures from the assets folder `BTN_StartGame` and `BTN_Credits`.
    These will be used to build our main menu.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will also notice that these textures are somewhat larger than the buttons
    they contain. This was done because by default Unity will expect that your textures
    are some power of 2\. We will address this limitation later.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_8.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Create an empty game object called **Menu Object**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going back to our original foray into scripting, we know that we need some game
    object in our scene in order for our script to run. Since this object doesn't
    need to be displayed, or have any particular game functionality, we can simply
    insert an empty game object into the scene and attach our script to that.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_9.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As we are going to be building an immediate mode GUI, it follows that we're
    going to have some script that drives the display of our GUI. Create a script
    called `MainMenu` and attach it to the **MenuObject** game object.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define two public variables in the `MainMenu` script, which will allow us to
    specify the button textures for the main menu commands.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we originally imported the textures for our buttons Unity imported them
    as Texture2Ds. If we configure our script to take in Texture2Ds we can use the
    Unity GUI to configure the textures we want to display as opposed to having to
    hard code this value in our code. We can accomplish this by defining public attributes
    on the class which defines our script.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next we need to update our `OnGUI` method to display the buttons for the main
    menu. We want the Texture2Ds we imported earlier to show up as buttons in our
    interface so we need to use the Unity GUI system to render them as buttons.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity has an easy to use `GUI.Button` class that performs this function. `GUI.
    Button` allows us to create a button on the interface with coordinates that are
    in screen space. We do this by defining a rectangle `(Rect)` with the position
    on the screen where this button will be drawn as the first two arguments and the
    width and height as the second two components.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When combined with the normal `GUI.Button()` method call we get the following:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are creating a new button at the upper left corner of the screen with
    a size of 256x256 and defining the `mainMenuButton` as the Texture2D that should
    be drawn in this button.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_13.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next we need to tell the Unity GUI to perform an action in response to someone
    pressing that button. As in the pseudo code, this involves wrapping the button
    with an if statement — which will be evaluated in the `OnGUI`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `creditsMenuButton` and center the buttons on the screen by updating
    the Rects for the original `GUI.Buttons`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While there are other ways to do this in Unity using GUI Groups, this will
    suit our purposes better as an instructional tool. If we render our scene now,
    we will find two buttons which contain our button textures:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然在Unity中使用GUI组还有其他方法来做这件事，但这种方法更适合作为教学工具。如果我们现在渲染场景，我们会发现两个包含我们的按钮纹理的按钮：
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_10.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 向GUI添加按钮](img/978-1-84969-040-9_9_10.jpg)'
- en: 'Pressing these buttons will show some debug text in the console:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按压这些按钮将在控制台显示一些调试文本：
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_14.jpg)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 向GUI添加按钮](img/978-1-84969-040-9_9_14.jpg)'
- en: While this allows our buttons to be rendered, there is more GUI Button being
    rendered than we want. The Unity GUI has its own style engine defined in `GUIStyle`
    , which determines how a button should be drawn. As we have baked the look and
    feel of our buttons into the textures themselves, we don't need Unity to display
    any of this style.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这允许我们的按钮被渲染，但渲染的GUI按钮比我们想要的要多。Unity GUI在其`GUIStyle`中定义了自己的样式引擎，它决定了按钮应该如何绘制。由于我们已经将按钮的外观和感觉烘焙到纹理本身中，我们不需要Unity显示任何这种样式。
- en: Update the `GUIStyle` of the `GUI.Buttons` so that they have no associated style.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`GUI.Button`的`GUIStyle`，使其没有关联的样式。
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_11.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 向GUI添加按钮](img/978-1-84969-040-9_9_11.jpg)'
- en: By making this simple change we will get the GUI rendered exactly how we intended.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过进行这个简单的更改，我们将能够以我们期望的方式渲染GUI。
- en: Update the script to load the Unity levels when the buttons are pressed.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新脚本以在按钮按下时加载Unity级别。
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By making the call to `Application.LoadLevel` as we have previously, we now
    have a mechanism for pressing a button in the interface and having Unity load
    a particular scene.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像之前那样调用`Application.LoadLevel`，我们现在有一个机制，即通过界面按下按钮，Unity加载特定的场景。
- en: What just happened?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just constructed a simple immediate mode GUI to display the main menu
    for our game. We have accomplished this by using the Unity GUI system and building
    a script which renders our GUI. Under the covers, what Unity is doing is drawing
    our scene every frame, based upon the script. It is important to note that if
    you were to change the script so that, programmatically, it were to display certain
    things based upon some setting or every third frame, Unity will do that because
    it is processing the UI script each and every frame. Accordingly it is important
    to not perform any extremely complex operations in the `OnGUI` method as it could
    result in a substantial performance slowdown.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个简单的即时模式GUI，用于显示我们游戏的主菜单。我们通过使用Unity GUI系统和构建一个渲染我们的GUI的脚本来实现这一点。在幕后，Unity正在根据脚本每帧绘制我们的场景。重要的是要注意，如果你更改脚本，使其程序性地根据某些设置或每三帧显示某些内容，Unity会这样做，因为它会每帧处理UI脚本。因此，在`OnGUI`方法中执行任何非常复杂的操作都可能导致性能显著下降。
- en: A better way — UIToolkit
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的方法 — UIToolkit
- en: One of the issues with the current implementation of the Unity GUI library is
    that it was designed for PC users and doesn't take into account any of the limitations
    of mobile devices. While it performs well enough in some situations, in most situations
    the number of draw calls it generates are enough to wreck the performance of your
    game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Unity GUI库当前实现的一个问题是，它是为PC用户设计的，没有考虑到移动设备的任何限制。虽然在某些情况下性能足够好，但在大多数情况下，它生成的绘制调用数量足以破坏你游戏的性能。
- en: In our previous example it is not possible to really see the impact of the performance
    slowdown because we aren't doing any rendering that is intense enough to impact
    the frame rate. As our scene is pretty static, one wouldn't be able to visually
    measure the result. However, if we look at our statistics we can see that even
    for this very modest GUI we're utilizing three draw calls — one for each GUI component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，由于我们没有进行任何足够强烈的渲染来影响帧率，因此无法真正看到性能下降的影响。由于我们的场景相当静态，因此无法直观地测量结果。然而，如果我们查看我们的统计数据，我们可以看到，即使是这个非常简单的GUI，我们也正在使用三个绘制调用——每个GUI组件一个。
- en: '![A better way — UIToolkit](img/978-1-84969-040-9_9_15.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![更好的方法 — UIToolkit](img/978-1-84969-040-9_9_15.jpg)'
- en: This may not seem like much now, but as you learn more in the chapter on optimization,
    this is a substantial amount of work that the iOS device is doing. So what if
    we could accomplish the same amount of work within a single draw call? What if
    we could have only one draw call regardless of the number of GUI elements we're
    drawing? Enter Prime31's UIToolkit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Prime31 UIToolkit
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download **code'n'web TexturePackerPro** essentials by visiting the website:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_16.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the latest available version of TexturePacker from the download list
    and install TexturePacker:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_17.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag the UI buttons for the credits menu and the start game menu into
    the interface. You can do this by dragging the images into the Sprites menu on
    the right-hand side of the interface:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_18.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to use the minimum amount of texture memory possible so set the **Max.
    width** and **Max. height** to the smallest power of 2 possible. Your texture
    will still need to be square so you're looking for the smallest number that box
    width and height can be set to simultaneously. In our case it is 512\. If **TexturePacker**
    cannot find a way to fit your textures into that size it will turn the text red.![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_19.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One benefit that you may not have noticed at this point is that before we were
    creating textures as large power of 2 textures so that Unity would accept them.
    Here TexturePacker is identifying the empty space in the textures and optimizing
    the amount of space each texture takes. In this case we actually have additional
    space where we could pack more textures if we needed to.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Output settings** (scroll the left pane to the bottom) set the **Data
    format** to **JSON** (Javascript Object Notation) and set the directory to your
    project's `Assets` folder. Set the name of the file as `gui` and change the extension
    of the `.json` file to `.txt`, as Unity expects text assets to end with a `.txt`
    extension.![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_20.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Publish** button in the toolbar and the appropriate files will be
    created in your `Assets` folder.![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_21.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now done with everything we need from TexturePacker.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Download the UIToolkit library from Prime31's github repository by visiting
    the website at [https://github.com/prime31/UIToolkit:](http://https://github.com/prime31/UIToolkit)![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_22.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select download and choose the .unitypackage option:![Time for action — Prime31
    UIToolkit](img/978-1-84969-040-9_9_23.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After it downloads, install the Unity package, importing all of the items in
    it:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_24.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that we can examine the 2 different approaches to render GUIs separately,
    create a new scene for this approach, and name it UIToolkit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure that our UI components are segregated from the rest of our scene,
    we want to put them on a particular layer in Unity. Layers are collections of
    components that can be accessed or manipulated as a collection. If you are familiar
    with Photoshop, the concept is similar.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, create a new Layer for our GUI to be drawn on by accessing the Layers
    through **Edit | Project Settings** | **Tags:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_25.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **User Layer 8** and set the Layer name to **UI Layer:**![Time for action
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_26.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty game object, name it **GUIObject** and set its position to 0,0,0:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_27.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `Plugins` folder in the **Project** view and you will find the **UIToolkit
    library. Expand UIToolkit** and drag the UI script onto the **GUIObject:**![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_28.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MainCamera** object in the **Hierarchy** view and remove the **UILayer**
    from the **Culling Mask** to ensure that the UI does not get drawn more than once:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_29.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you select the **UILayer** the **Culling Mask** should be displayed as
    **Mixed** as shown in the following screenshot:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_30.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty game object called **UIToolkit** and make it a child of the
    **GUIObject** we created earlier that contains the UI script:![Time for action
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_31.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **UIToolkit** script from the `UIToolkit plugins` folder onto the UIToolkit
    game object in the **Hierarchy** view:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_32.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **GUIObject** node in the **Hierarchy** view to bring up its inspector.
    Tell it we want the UI to be drawn on the **UILayer** by selecting the drop-down
    next to the **UILayer** entry and selecting the layer that the UI is to be drawn
    on — which we have also called **UILayer:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_33.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To wrap up our configuration we need to tell **UIToolkit** which TexturePacker
    config we're using. Select the **UIToolkit** node in the **Hierarchy** view to
    bring up its inspector. In the **Texture Packer Config Name** enter the name of
    the config that we saved, in this case **gui:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_34.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're ready to create our GUI using the textures we used in Texture Packer.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a Script called `UIToolkitGUI` and let''s add a button to the screen
    using this new approach:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `UIToolkitGUI` 的脚本，并使用这种新方法在屏幕上添加一个按钮：
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the UIToolkit button class takes a normal button state and a pressed
    button state. As we didn't have both we just used the same texture for both. The
    last two arguments are the position on the screen where we want this button to
    show up.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，UIToolkit按钮类接受一个正常按钮状态和一个按下按钮状态。由于我们没有两者，所以我们只是使用了相同的纹理。最后两个参数是我们希望在屏幕上显示此按钮的位置。
- en: Press play and our button will show up on the screen.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放，我们的按钮将显示在屏幕上。
- en: What just happened?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just created our GUI using the open source and free library UIToolkit from
    Prime31\. We have accomplished the same thing as our original menu, but with a
    single draw call. While we could have accomplished similar with UnityGUI, the
    performance would have gotten progressively worse the more complex the user interface
    became, as each control added and each GUIStyle rendered results in another draw
    call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用Prime31的开源免费库UIToolkit创建了我们的GUI。我们实现了与原始菜单相同的功能，但只需要一个绘制调用。虽然我们也可以使用UnityGUI实现类似的功能，但随着用户界面的越来越复杂，性能会逐渐下降，因为每个控件的增加和每个GUIStyle的渲染都会导致另一个绘制调用。
- en: In addition, we've come up with a more optimal way to get textures into the
    UI. Unity, by default, will not allow you to use a non-power of 2 texture for
    rendering which will result in lots of wasted texture memory at each texture.
    With this approach we can pack a large number of textures into a single larger
    texture, which is in itself more efficient, and render textures of wildly different
    shapes without sacrificing much in texture memory efficiency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提出了一种更优化的方法来将纹理放入UI。默认情况下，Unity不允许您使用非2的幂纹理进行渲染，这将导致每个纹理都有大量的浪费纹理内存。使用这种方法，我们可以将大量纹理打包到一个更大的纹理中，这本身就更高效，并且可以渲染形状迥异的纹理，而不会在纹理内存效率上牺牲太多。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have learned how to build a UI for our game. We have explored
    setting up a UI using the Unity GUI APIs, as well as setting up a UI using the
    leading third party plugin Prime31 UIToolkit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为我们的游戏构建UI。我们探讨了使用Unity GUI API设置UI，以及使用领先的第三方插件Prime31 UIToolkit设置UI。
- en: 'Specifically, we covered:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to build an immediate mode GUI with the standard GUI library
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用标准GUI库构建即时模式GUI
- en: How to build a GUI using the Prime31 UIToolkit
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Prime31 UIToolkit构建GUI
- en: Some concerns about GUI performance
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GUI性能的一些担忧
- en: Now that we are finished putting together the UI, we need to handle more complex
    gameplay scripting for our game — which is the focus of our next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了UI的组装，我们需要为我们的游戏处理更复杂的游戏脚本——这是我们下一章的重点。
