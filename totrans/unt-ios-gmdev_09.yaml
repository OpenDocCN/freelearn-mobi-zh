- en: Chapter 9. User Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it may seem that we have created the bulk of our game, there is one very
    important thing that is still missing — the **User Interface** (UI). Creating
    UIs is very important, as this is the real look and feel that your game will have
    for your users. If you have a generic interface, no matter how your models look,
    the game will feel generic. There are many ways that you can design a UI in Unity,
    but most of those are designed for desktop applications and will perform poorly
    on mobile devices. We will examine the standard Unity library facility for building
    our UI and we will build a UI with the Prime31 UIToolkit.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the native Unity interface system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore the popular third-party Prime31 UIToolkit approach for generating interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After we finish this chapter we will have all of the tools at our disposal to
    create almost any type of game we want to create.
  prefs: []
  type: TYPE_NORMAL
- en: So lets get on with it...
  prefs: []
  type: TYPE_NORMAL
- en: Important preliminary points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you understand the basic concepts of tools such as
    GIMP and Photoshop including layers, masks, and fills. While the screens in the
    chapter will be focussed primarily on Photoshop, all of the concepts utilized
    here are easily transferrable to other software.
  prefs: []
  type: TYPE_NORMAL
- en: Translating the design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design sketch of Battlecry's user interface design should be able to display
    some simple assets for displaying the player's current health, the score of the
    game, a joystick, and an action button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Translating the design](img/978-1-84969-040-9_9_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We covered the joystick and action button in the Input chapter so we can focus
    on the health display and showing the score. We need a nice font for displaying
    text and some images to show the health. In addition, we will want to build a
    main menu for the game that will consist of a button to start the game and one
    that will show the credits.
  prefs: []
  type: TYPE_NORMAL
- en: Immediate mode game user interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Unity game engine provides developers with a complete integrated system
    for game user interface (GUI) development. These GUIs are built using an immediate
    mode approach to defining the GUI and responding to its events. For most games
    this will not be an issue and will be one of the easiest ways for you to put a
    HUD and simple controls on the screen. However, as it is an immediate mode API,
    the developer is very close to the mechanics of how the UI operates.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we can look at how to construct a simple GUI that displays a
    button on the screen. As you might have guessed, since there are no tools, and
    as we're in immediate mode, we have to manually specify the layout for the components
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Despite how different this may feel from hopping into Flash, Photoshop, Objective-C,
    or your favorite GUI framework, immediate mode GUIs are nothing new. In a traditional
    GUI framework, you setup your GUI components in a variety of classes and then
    setup callbacks and messaging systems so that the event loop can relay data from
    the components to the actual application logic that will handle the events. So
    what's wrong with this, you may ask. At the end of the day you will find that
    you have code all over your application — especially if you're really trying to
    be object-oriented and are designing your application for reuse.
  prefs: []
  type: TYPE_NORMAL
- en: While this is something that makes sense for a complex business application
    that may have to change its layout dynamically based on user-type, screen resolution,
    or the data being used, that is not the problem that we're trying to solve with
    our game. You will find that an immediate mode GUI is very compact, with all of
    the logic that makes your game work generally in a small number of places. Any
    state data necessary for the UI is made available to all of the interface components
    without the need for querying or passing data. This makes the application easier
    to follow and is very performance friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Creating the menu background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is create a background for the main menu of our
    game. This will give us a chance to see how to setup Unity GUI components. To
    keep things simple, initially we will start with the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene called **MainMenu**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As this is a military style game we can use a simple camouflage texture for
    the background of our main menu.![Time for action — Creating the menu background](img/978-1-84969-040-9_9_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On top of this we will display the buttons for our game. While it is possible
    for us to modify our existing **GameIntro** scene to handle a main menu, it is
    better from a design perspective to create a standalone scene for the main menu.
    This will aid the development workflow as content creators can work on this scene
    in isolation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_3.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: After adding our **MainMenu** scene we need to make a change to our `PlayIntroMovie`
    script to have it load the **MainMenu** scene instead of just dropping directly
    into the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to import the texture that we will be using for the background.
    In the project folder for this chapter you will find the asset `army_camo.jpg`.
    If you drag this into Unity it will be imported and ready for use. However, there
    are a few settings we want to change for our iOS release. If you display the **Inspector**
    settings for the asset you will find that it is imported at 1024x1024\. However,
    for our iOS game, we don't want such a large texture simply as a background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the settings for this texture for our iOS device by selecting the iPhone
    icon and checking the box to override the settings for iPhone. Set the **Max Size**
    for this texture to **512** and click on the **Apply** button.![Time for action
    — Creating the menu background](img/978-1-84969-040-9_9_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now our texture for iOS will only be 512x512, while it can be 1024x1024 for
    other platforms. From a workflow perspective this is important, as you will want
    to override your assets for the platform you're deploying to, while not creating
    entirely new assets for each platform.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Our next step is to make this image the background of the scene. Select the
    texture that we just imported in the **Project** view and create a **GUI Texture**.![Time
    for action — Creating the menu background](img/978-1-84969-040-9_9_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the scale of our background texture to (1,1,1) so that it is scaled to
    fill the screen. Since a **GUITexture** is a Unity UI construct specifically for
    UI elements, all of its position and scale is done in screen space as opposed
    to world space. By setting this to **1** in all dimensions. We're telling Unity
    to fill the screen with our **GUITexture**. The Z-axis in this case is the same
    as for prior chapters. If you need to draw other items in front of the background,
    they simply need to have a lower Z value than the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We did not have to make the **GUITexture** a child of the camera for this to
    happen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Run the project and you will see a camouflage texture that fills the entire
    screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just created a background for our main menu scene. As you have noticed,
    this item is not parented to any part of the scene and will display without respect
    to any other items in the scene. Now we can move on to adding buttons to our menu.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the menu on the screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make the immediate mode GUI work with Unity we simply need to provide one
    function in a script, `OnGUI`. Like any other script we will attach our UI script
    to a **GameObject** that is located in the scene and Unity will call it every
    frame to ensure that any GUI events that have happened during that frame are processed.
    One obvious warning is that this means that your GUI loops should be tight loops
    and highly optimized; you shouldn't be performing complex time-consuming computations
    inside the GUI code.
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at our main menu example we know that we have two simple buttons
    that need to perform very specific actions when clicked. Thus, from a pseudo code
    perspective, we know that our application simply needs a basic if/else condition
    to examine the two controls that we're using.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example `MainMenuButton` and `CreditsMenuButton` represent two GUI controls
    that we will define in our script that will cause the main scene or credits scene
    to be opened respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Adding buttons to the GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Import the two textures from the assets folder `BTN_StartGame` and `BTN_Credits`.
    These will be used to build our main menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will also notice that these textures are somewhat larger than the buttons
    they contain. This was done because by default Unity will expect that your textures
    are some power of 2\. We will address this limitation later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Create an empty game object called **Menu Object**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going back to our original foray into scripting, we know that we need some game
    object in our scene in order for our script to run. Since this object doesn't
    need to be displayed, or have any particular game functionality, we can simply
    insert an empty game object into the scene and attach our script to that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_9.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: As we are going to be building an immediate mode GUI, it follows that we're
    going to have some script that drives the display of our GUI. Create a script
    called `MainMenu` and attach it to the **MenuObject** game object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define two public variables in the `MainMenu` script, which will allow us to
    specify the button textures for the main menu commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we originally imported the textures for our buttons Unity imported them
    as Texture2Ds. If we configure our script to take in Texture2Ds we can use the
    Unity GUI to configure the textures we want to display as opposed to having to
    hard code this value in our code. We can accomplish this by defining public attributes
    on the class which defines our script.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next we need to update our `OnGUI` method to display the buttons for the main
    menu. We want the Texture2Ds we imported earlier to show up as buttons in our
    interface so we need to use the Unity GUI system to render them as buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity has an easy to use `GUI.Button` class that performs this function. `GUI.
    Button` allows us to create a button on the interface with coordinates that are
    in screen space. We do this by defining a rectangle `(Rect)` with the position
    on the screen where this button will be drawn as the first two arguments and the
    width and height as the second two components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When combined with the normal `GUI.Button()` method call we get the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are creating a new button at the upper left corner of the screen with
    a size of 256x256 and defining the `mainMenuButton` as the Texture2D that should
    be drawn in this button.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next we need to tell the Unity GUI to perform an action in response to someone
    pressing that button. As in the pseudo code, this involves wrapping the button
    with an if statement — which will be evaluated in the `OnGUI`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `creditsMenuButton` and center the buttons on the screen by updating
    the Rects for the original `GUI.Buttons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While there are other ways to do this in Unity using GUI Groups, this will
    suit our purposes better as an instructional tool. If we render our scene now,
    we will find two buttons which contain our button textures:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Pressing these buttons will show some debug text in the console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: While this allows our buttons to be rendered, there is more GUI Button being
    rendered than we want. The Unity GUI has its own style engine defined in `GUIStyle`
    , which determines how a button should be drawn. As we have baked the look and
    feel of our buttons into the textures themselves, we don't need Unity to display
    any of this style.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update the `GUIStyle` of the `GUI.Buttons` so that they have no associated style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: By making this simple change we will get the GUI rendered exactly how we intended.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update the script to load the Unity levels when the buttons are pressed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By making the call to `Application.LoadLevel` as we have previously, we now
    have a mechanism for pressing a button in the interface and having Unity load
    a particular scene.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just constructed a simple immediate mode GUI to display the main menu
    for our game. We have accomplished this by using the Unity GUI system and building
    a script which renders our GUI. Under the covers, what Unity is doing is drawing
    our scene every frame, based upon the script. It is important to note that if
    you were to change the script so that, programmatically, it were to display certain
    things based upon some setting or every third frame, Unity will do that because
    it is processing the UI script each and every frame. Accordingly it is important
    to not perform any extremely complex operations in the `OnGUI` method as it could
    result in a substantial performance slowdown.
  prefs: []
  type: TYPE_NORMAL
- en: A better way — UIToolkit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the issues with the current implementation of the Unity GUI library is
    that it was designed for PC users and doesn't take into account any of the limitations
    of mobile devices. While it performs well enough in some situations, in most situations
    the number of draw calls it generates are enough to wreck the performance of your
    game.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example it is not possible to really see the impact of the performance
    slowdown because we aren't doing any rendering that is intense enough to impact
    the frame rate. As our scene is pretty static, one wouldn't be able to visually
    measure the result. However, if we look at our statistics we can see that even
    for this very modest GUI we're utilizing three draw calls — one for each GUI component.
  prefs: []
  type: TYPE_NORMAL
- en: '![A better way — UIToolkit](img/978-1-84969-040-9_9_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This may not seem like much now, but as you learn more in the chapter on optimization,
    this is a substantial amount of work that the iOS device is doing. So what if
    we could accomplish the same amount of work within a single draw call? What if
    we could have only one draw call regardless of the number of GUI elements we're
    drawing? Enter Prime31's UIToolkit.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action — Prime31 UIToolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Download **code'n'web TexturePackerPro** essentials by visiting the website:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the latest available version of TexturePacker from the download list
    and install TexturePacker:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag the UI buttons for the credits menu and the start game menu into
    the interface. You can do this by dragging the images into the Sprites menu on
    the right-hand side of the interface:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to use the minimum amount of texture memory possible so set the **Max.
    width** and **Max. height** to the smallest power of 2 possible. Your texture
    will still need to be square so you're looking for the smallest number that box
    width and height can be set to simultaneously. In our case it is 512\. If **TexturePacker**
    cannot find a way to fit your textures into that size it will turn the text red.![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One benefit that you may not have noticed at this point is that before we were
    creating textures as large power of 2 textures so that Unity would accept them.
    Here TexturePacker is identifying the empty space in the textures and optimizing
    the amount of space each texture takes. In this case we actually have additional
    space where we could pack more textures if we needed to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Output settings** (scroll the left pane to the bottom) set the **Data
    format** to **JSON** (Javascript Object Notation) and set the directory to your
    project's `Assets` folder. Set the name of the file as `gui` and change the extension
    of the `.json` file to `.txt`, as Unity expects text assets to end with a `.txt`
    extension.![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Publish** button in the toolbar and the appropriate files will be
    created in your `Assets` folder.![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now done with everything we need from TexturePacker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Download the UIToolkit library from Prime31's github repository by visiting
    the website at [https://github.com/prime31/UIToolkit:](http://https://github.com/prime31/UIToolkit)![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select download and choose the .unitypackage option:![Time for action — Prime31
    UIToolkit](img/978-1-84969-040-9_9_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After it downloads, install the Unity package, importing all of the items in
    it:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_24.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that we can examine the 2 different approaches to render GUIs separately,
    create a new scene for this approach, and name it UIToolkit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure that our UI components are segregated from the rest of our scene,
    we want to put them on a particular layer in Unity. Layers are collections of
    components that can be accessed or manipulated as a collection. If you are familiar
    with Photoshop, the concept is similar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Unity, create a new Layer for our GUI to be drawn on by accessing the Layers
    through **Edit | Project Settings** | **Tags:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **User Layer 8** and set the Layer name to **UI Layer:**![Time for action
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_26.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an empty game object, name it **GUIObject** and set its position to 0,0,0:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expand the `Plugins` folder in the **Project** view and you will find the **UIToolkit
    library. Expand UIToolkit** and drag the UI script onto the **GUIObject:**![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MainCamera** object in the **Hierarchy** view and remove the **UILayer**
    from the **Culling Mask** to ensure that the UI does not get drawn more than once:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you select the **UILayer** the **Culling Mask** should be displayed as
    **Mixed** as shown in the following screenshot:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new empty game object called **UIToolkit** and make it a child of the
    **GUIObject** we created earlier that contains the UI script:![Time for action
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_31.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **UIToolkit** script from the `UIToolkit plugins` folder onto the UIToolkit
    game object in the **Hierarchy** view:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **GUIObject** node in the **Hierarchy** view to bring up its inspector.
    Tell it we want the UI to be drawn on the **UILayer** by selecting the drop-down
    next to the **UILayer** entry and selecting the layer that the UI is to be drawn
    on — which we have also called **UILayer:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_33.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To wrap up our configuration we need to tell **UIToolkit** which TexturePacker
    config we're using. Select the **UIToolkit** node in the **Hierarchy** view to
    bring up its inspector. In the **Texture Packer Config Name** enter the name of
    the config that we saved, in this case **gui:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_34.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're ready to create our GUI using the textures we used in Texture Packer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a Script called `UIToolkitGUI` and let''s add a button to the screen
    using this new approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the UIToolkit button class takes a normal button state and a pressed
    button state. As we didn't have both we just used the same texture for both. The
    last two arguments are the position on the screen where we want this button to
    show up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press play and our button will show up on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created our GUI using the open source and free library UIToolkit from
    Prime31\. We have accomplished the same thing as our original menu, but with a
    single draw call. While we could have accomplished similar with UnityGUI, the
    performance would have gotten progressively worse the more complex the user interface
    became, as each control added and each GUIStyle rendered results in another draw
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we've come up with a more optimal way to get textures into the
    UI. Unity, by default, will not allow you to use a non-power of 2 texture for
    rendering which will result in lots of wasted texture memory at each texture.
    With this approach we can pack a large number of textures into a single larger
    texture, which is in itself more efficient, and render textures of wildly different
    shapes without sacrificing much in texture memory efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have learned how to build a UI for our game. We have explored
    setting up a UI using the Unity GUI APIs, as well as setting up a UI using the
    leading third party plugin Prime31 UIToolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build an immediate mode GUI with the standard GUI library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a GUI using the Prime31 UIToolkit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some concerns about GUI performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we are finished putting together the UI, we need to handle more complex
    gameplay scripting for our game — which is the focus of our next chapter.
  prefs: []
  type: TYPE_NORMAL
