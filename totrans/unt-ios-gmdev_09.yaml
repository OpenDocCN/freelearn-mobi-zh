- en: Chapter 9. User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。用户界面
- en: While it may seem that we have created the bulk of our game, there is one very
    important thing that is still missing — the **User Interface** (UI). Creating
    UIs is very important, as this is the real look and feel that your game will have
    for your users. If you have a generic interface, no matter how your models look,
    the game will feel generic. There are many ways that you can design a UI in Unity,
    but most of those are designed for desktop applications and will perform poorly
    on mobile devices. We will examine the standard Unity library facility for building
    our UI and we will build a UI with the Prime31 UIToolkit.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 虽然可能看起来我们已经创建了游戏的大部分内容，但还有一个非常重要的东西仍然缺失——**用户界面**（UI）。创建UI非常重要，因为这将是您的游戏对用户呈现的真实外观和感觉。如果您有一个通用的界面，无论您的模型看起来如何，游戏都会显得很普通。您可以在Unity中设计UI的许多方法，但其中大多数是为桌面应用程序设计的，在移动设备上表现不佳。我们将检查标准的Unity库设施来构建我们的UI，并使用Prime31
    UIToolkit构建一个UI。
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Use the native Unity interface system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原生的Unity界面系统
- en: Explore the popular third-party Prime31 UIToolkit approach for generating interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索流行的第三方Prime31 UIToolkit方法来生成界面
- en: After we finish this chapter we will have all of the tools at our disposal to
    create almost any type of game we want to create.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成这一章之后，我们将拥有创建几乎所有我们想要创建的游戏所需的所有工具。
- en: So lets get on with it...
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧...
- en: Important preliminary points
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要预备要点
- en: This chapter assumes that you understand the basic concepts of tools such as
    GIMP and Photoshop including layers, masks, and fills. While the screens in the
    chapter will be focussed primarily on Photoshop, all of the concepts utilized
    here are easily transferrable to other software.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经理解了诸如GIMP和Photoshop等工具的基本概念，包括图层、蒙版和填充。虽然本章中的屏幕将主要关注Photoshop，但这里使用的所有概念都很容易转移到其他软件。
- en: Translating the design
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 翻译设计
- en: The design sketch of Battlecry's user interface design should be able to display
    some simple assets for displaying the player's current health, the score of the
    game, a joystick, and an action button.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 战吼用户界面设计的草图应该能够显示一些简单的资产，用于显示玩家的当前健康、游戏的分数、摇杆和动作按钮。
- en: '![Translating the design](img/978-1-84969-040-9_9_1.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![翻译设计](img/978-1-84969-040-9_9_1.jpg)'
- en: We covered the joystick and action button in the Input chapter so we can focus
    on the health display and showing the score. We need a nice font for displaying
    text and some images to show the health. In addition, we will want to build a
    main menu for the game that will consist of a button to start the game and one
    that will show the credits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“输入”章节中已经涵盖了摇杆和动作按钮，因此我们可以专注于健康显示和显示分数。我们需要一个漂亮的字体来显示文本，以及一些图像来显示健康。此外，我们还想为游戏构建一个主菜单，它将包括一个开始游戏的按钮和一个显示信用额的按钮。
- en: Immediate mode game user interfaces
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 即时模式游戏用户界面
- en: The Unity game engine provides developers with a complete integrated system
    for game user interface (GUI) development. These GUIs are built using an immediate
    mode approach to defining the GUI and responding to its events. For most games
    this will not be an issue and will be one of the easiest ways for you to put a
    HUD and simple controls on the screen. However, as it is an immediate mode API,
    the developer is very close to the mechanics of how the UI operates.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Unity游戏引擎为开发者提供了一个完整的集成系统，用于游戏用户界面（GUI）开发。这些GUI是通过即时模式方法来定义GUI并响应其事件构建的。对于大多数游戏来说，这不会成为问题，并且将是您将HUD和简单控制放置在屏幕上最容易的方式之一。然而，由于它是一个即时模式API，开发者非常接近UI操作的机制。
- en: As an example, we can look at how to construct a simple GUI that displays a
    button on the screen. As you might have guessed, since there are no tools, and
    as we're in immediate mode, we have to manually specify the layout for the components
    on the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以看看如何构建一个简单的GUI，在屏幕上显示一个按钮。正如你可能猜到的，由于没有工具，并且我们处于即时模式，我们必须手动指定屏幕上组件的布局。
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Despite how different this may feel from hopping into Flash, Photoshop, Objective-C,
    or your favorite GUI framework, immediate mode GUIs are nothing new. In a traditional
    GUI framework, you setup your GUI components in a variety of classes and then
    setup callbacks and messaging systems so that the event loop can relay data from
    the components to the actual application logic that will handle the events. So
    what's wrong with this, you may ask. At the end of the day you will find that
    you have code all over your application — especially if you're really trying to
    be object-oriented and are designing your application for reuse.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能与跳入Flash、Photoshop、Objective-C或你最喜欢的GUI框架的感觉不同，但即时模式GUI并不是什么新鲜事物。在传统的GUI框架中，你会在各种类中设置你的GUI组件，然后设置回调和消息系统，以便事件循环可以将数据从组件传递到处理事件的实际应用程序逻辑。那么，这有什么问题吗？你可能想知道。最终你会发现，你的应用程序到处都是代码——特别是如果你真的试图做到面向对象，并且为重用设计你的应用程序的话。
- en: While this is something that makes sense for a complex business application
    that may have to change its layout dynamically based on user-type, screen resolution,
    or the data being used, that is not the problem that we're trying to solve with
    our game. You will find that an immediate mode GUI is very compact, with all of
    the logic that makes your game work generally in a small number of places. Any
    state data necessary for the UI is made available to all of the interface components
    without the need for querying or passing data. This makes the application easier
    to follow and is very performance friendly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于可能需要根据用户类型、屏幕分辨率或使用的数据动态更改布局的复杂商业应用程序来说是有意义的，但这并不是我们试图通过我们的游戏解决的问题。你会发现即时模式GUI非常紧凑，所有使你的游戏工作的逻辑通常都在少数几个地方。任何必要的状态数据都会提供给所有界面组件，无需查询或传递数据。这使得应用程序更容易跟踪，并且对性能非常友好。
- en: Time for action — Creating the menu background
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 — 创建菜单背景
- en: The first thing we need to do is create a background for the main menu of our
    game. This will give us a chance to see how to setup Unity GUI components. To
    keep things simple, initially we will start with the main menu.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们游戏的主菜单创建一个背景。这将给我们一个机会看到如何设置Unity GUI组件。为了使事情简单，最初我们将从主菜单开始。
- en: Create a new scene called **MainMenu**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**MainMenu**的新场景。
- en: As this is a military style game we can use a simple camouflage texture for
    the background of our main menu.![Time for action — Creating the menu background](img/978-1-84969-040-9_9_2.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于这是一个军事风格的游戏，我们可以为我们的主菜单背景使用简单的迷彩纹理。![行动时间 — 创建菜单背景](img/978-1-84969-040-9_9_2.jpg)
- en: On top of this we will display the buttons for our game. While it is possible
    for us to modify our existing **GameIntro** scene to handle a main menu, it is
    better from a design perspective to create a standalone scene for the main menu.
    This will aid the development workflow as content creators can work on this scene
    in isolation.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此之上，我们将显示我们游戏的按钮。虽然我们可以修改现有的**GameIntro**场景以处理主菜单，但从设计角度来看，最好创建一个独立的主菜单场景。这将有助于开发工作流程，因为内容创作者可以独立地工作在这个场景上。
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_3.jpg)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 创建菜单背景](img/978-1-84969-040-9_9_3.jpg)'
- en: After adding our **MainMenu** scene we need to make a change to our `PlayIntroMovie`
    script to have it load the **MainMenu** scene instead of just dropping directly
    into the game.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加我们的**MainMenu**场景后，我们需要对`PlayIntroMovie`脚本进行修改，使其加载**MainMenu**场景而不是直接进入游戏。
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The next step is to import the texture that we will be using for the background.
    In the project folder for this chapter you will find the asset `army_camo.jpg`.
    If you drag this into Unity it will be imported and ready for use. However, there
    are a few settings we want to change for our iOS release. If you display the **Inspector**
    settings for the asset you will find that it is imported at 1024x1024\. However,
    for our iOS game, we don't want such a large texture simply as a background.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们要用于背景的纹理导入。在本章的项目文件夹中，你可以找到资产`army_camo.jpg`。如果你将其拖入Unity中，它将被导入并准备好使用。然而，对于我们的iOS发布版本，我们不想仅仅作为背景使用如此大的纹理。如果你显示该资产的**检查器**设置，你会发现它是以1024x1024的分辨率导入的。然而，对于我们的iOS游戏，我们不想使用如此大的纹理作为背景。
- en: Override the settings for this texture for our iOS device by selecting the iPhone
    icon and checking the box to override the settings for iPhone. Set the **Max Size**
    for this texture to **512** and click on the **Apply** button.![Time for action
    — Creating the menu background](img/978-1-84969-040-9_9_4.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择iPhone图标并勾选覆盖iPhone设置的复选框，为我们的iOS设备覆盖此纹理的设置。将此纹理的**最大尺寸**设置为**512**，然后点击**应用**按钮。![执行动作
    — 创建菜单背景](img/978-1-84969-040-9_9_4.jpg)
- en: Now our texture for iOS will only be 512x512, while it can be 1024x1024 for
    other platforms. From a workflow perspective this is important, as you will want
    to override your assets for the platform you're deploying to, while not creating
    entirely new assets for each platform.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们为iOS的纹理将只有512x512，而其他平台可以是1024x1024。从工作流程的角度来看，这一点很重要，因为你将想要覆盖你部署到平台的资源，而不为每个平台创建全新的资源。
- en: Our next step is to make this image the background of the scene. Select the
    texture that we just imported in the **Project** view and create a **GUI Texture**.![Time
    for action — Creating the menu background](img/978-1-84969-040-9_9_5.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是将此图像设置为场景的背景。在**项目**视图中选择我们刚刚导入的纹理，并创建一个**GUI Texture**。![执行动作 — 创建菜单背景](img/978-1-84969-040-9_9_5.jpg)
- en: Change the scale of our background texture to (1,1,1) so that it is scaled to
    fill the screen. Since a **GUITexture** is a Unity UI construct specifically for
    UI elements, all of its position and scale is done in screen space as opposed
    to world space. By setting this to **1** in all dimensions. We're telling Unity
    to fill the screen with our **GUITexture**. The Z-axis in this case is the same
    as for prior chapters. If you need to draw other items in front of the background,
    they simply need to have a lower Z value than the background.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的背景纹理的缩放比例更改为(1,1,1)，以便它填充整个屏幕。由于**GUITexture**是Unity UI构建的专门用于UI元素的构造，因此其位置和缩放都是在屏幕空间中完成的，而不是在世界空间中。通过将所有维度设置为**1**，我们告诉Unity用我们的**GUITexture**填充屏幕。在这个情况下，Z轴与之前章节相同。如果你需要在背景之前绘制其他项目，它们只需要具有比背景更低的Z值。
- en: Note
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We did not have to make the **GUITexture** a child of the camera for this to
    happen.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不需要将**GUITexture**作为相机的子对象来实现这一点。
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_6.jpg)'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行动作 — 创建菜单背景](img/978-1-84969-040-9_9_6.jpg)'
- en: Run the project and you will see a camouflage texture that fills the entire
    screen.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行项目，你将看到一个填充整个屏幕的迷彩纹理。
- en: '![Time for action — Creating the menu background](img/978-1-84969-040-9_9_7.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![执行动作 — 创建菜单背景](img/978-1-84969-040-9_9_7.jpg)'
- en: What just happened?
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just created a background for our main menu scene. As you have noticed,
    this item is not parented to any part of the scene and will display without respect
    to any other items in the scene. Now we can move on to adding buttons to our menu.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为主菜单场景创建了一个背景。正如你所注意到的，此项目没有成为场景任何部分的子对象，并且将不考虑场景中的其他项目而显示。现在我们可以继续向菜单中添加按钮。
- en: Putting the menu on the screen
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将菜单显示在屏幕上
- en: To make the immediate mode GUI work with Unity we simply need to provide one
    function in a script, `OnGUI`. Like any other script we will attach our UI script
    to a **GameObject** that is located in the scene and Unity will call it every
    frame to ensure that any GUI events that have happened during that frame are processed.
    One obvious warning is that this means that your GUI loops should be tight loops
    and highly optimized; you shouldn't be performing complex time-consuming computations
    inside the GUI code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使即时模式GUI与Unity协同工作，我们只需在脚本中提供一个函数，即`OnGUI`。就像任何其他脚本一样，我们将把我们的UI脚本附加到场景中位于某个位置的**GameObject**上，Unity会每帧调用它以确保处理该帧期间发生的任何GUI事件。一个明显的警告是，这意味着你的GUI循环应该是紧凑的循环并且高度优化；你不应该在GUI代码中执行复杂且耗时的计算。
- en: If we look back at our main menu example we know that we have two simple buttons
    that need to perform very specific actions when clicked. Thus, from a pseudo code
    perspective, we know that our application simply needs a basic if/else condition
    to examine the two controls that we're using.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们的主菜单示例，我们知道我们有两个简单的按钮，当点击时需要执行非常特定的操作。因此，从伪代码的角度来看，我们知道我们的应用程序只需要一个基本的if/else条件来检查我们正在使用的两个控件。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example `MainMenuButton` and `CreditsMenuButton` represent two GUI controls
    that we will define in our script that will cause the main scene or credits scene
    to be opened respectively.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MainMenuButton`和`CreditsMenuButton`代表我们将要在脚本中定义的两个GUI控件，分别用于打开主场景或信用场景。
- en: Time for action — Adding buttons to the GUI
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加按钮到GUI的行动时间
- en: Import the two textures from the assets folder `BTN_StartGame` and `BTN_Credits`.
    These will be used to build our main menu.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从资源文件夹中导入两个纹理`BTN_StartGame`和`BTN_Credits`。这些纹理将用于构建我们的主菜单。
- en: You will also notice that these textures are somewhat larger than the buttons
    they contain. This was done because by default Unity will expect that your textures
    are some power of 2\. We will address this limitation later.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还会注意到这些纹理比包含的按钮要大一些。这是因为在默认情况下，Unity会期望你的纹理是2的幂。我们将在稍后解决这个问题。
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_8.jpg)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加按钮到GUI的行动时间](img/978-1-84969-040-9_9_8.jpg)'
- en: Create an empty game object called **Menu Object**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为**Menu Object**的空游戏对象。
- en: Going back to our original foray into scripting, we know that we need some game
    object in our scene in order for our script to run. Since this object doesn't
    need to be displayed, or have any particular game functionality, we can simply
    insert an empty game object into the scene and attach our script to that.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回到我们最初的脚本探索，我们知道我们需要在场景中有一个游戏对象，以便我们的脚本能够运行。由于这个对象不需要显示，或具有任何特定的游戏功能，我们只需将一个空游戏对象插入场景，并将我们的脚本附加到该对象。
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_9.jpg)'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加按钮到GUI的行动时间](img/978-1-84969-040-9_9_9.jpg)'
- en: As we are going to be building an immediate mode GUI, it follows that we're
    going to have some script that drives the display of our GUI. Create a script
    called `MainMenu` and attach it to the **MenuObject** game object.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将构建即时模式的GUI，因此我们可以推断出我们将需要一些脚本来驱动GUI的显示。创建一个名为`MainMenu`的脚本并将其附加到**MenuObject**游戏对象。
- en: Define two public variables in the `MainMenu` script, which will allow us to
    specify the button textures for the main menu commands.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainMenu`脚本中定义两个公共变量，这将允许我们指定主菜单命令的按钮纹理。
- en: When we originally imported the textures for our buttons Unity imported them
    as Texture2Ds. If we configure our script to take in Texture2Ds we can use the
    Unity GUI to configure the textures we want to display as opposed to having to
    hard code this value in our code. We can accomplish this by defining public attributes
    on the class which defines our script.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们最初导入按钮纹理时，Unity将它们导入为Texture2D。如果我们配置我们的脚本以接受Texture2D，我们可以使用Unity GUI配置我们想要显示的纹理，而不是在代码中硬编码此值。我们可以通过在定义脚本的类中定义公共属性来实现这一点。
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next we need to update our `OnGUI` method to display the buttons for the main
    menu. We want the Texture2Ds we imported earlier to show up as buttons in our
    interface so we need to use the Unity GUI system to render them as buttons.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新我们的`OnGUI`方法以显示主菜单的按钮。我们希望之前导入的Texture2D作为按钮显示在我们的界面中，因此我们需要使用Unity
    GUI系统将它们渲染为按钮。
- en: Unity has an easy to use `GUI.Button` class that performs this function. `GUI.
    Button` allows us to create a button on the interface with coordinates that are
    in screen space. We do this by defining a rectangle `(Rect)` with the position
    on the screen where this button will be drawn as the first two arguments and the
    width and height as the second two components.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Unity有一个易于使用的`GUI.Button`类，它执行此功能。`GUI.Button`允许我们在界面中创建一个按钮，其坐标位于屏幕空间中。我们通过定义一个矩形`(Rect)`来实现，其中按钮将被绘制在屏幕上的位置作为前两个参数，宽度和高度作为后两个组件。
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When combined with the normal `GUI.Button()` method call we get the following:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当与正常的`GUI.Button()`方法调用结合时，我们得到以下结果：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we are creating a new button at the upper left corner of the screen with
    a size of 256x256 and defining the `mainMenuButton` as the Texture2D that should
    be drawn in this button.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建一个位于屏幕左上角、大小为256x256的新按钮，并将`mainMenuButton`定义为应该绘制在这个按钮中的Texture2D。
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_13.jpg)'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![添加按钮到GUI的行动时间](img/978-1-84969-040-9_9_13.jpg)'
- en: Next we need to tell the Unity GUI to perform an action in response to someone
    pressing that button. As in the pseudo code, this involves wrapping the button
    with an if statement — which will be evaluated in the `OnGUI`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉Unity GUI在有人按下该按钮时执行操作。正如伪代码所示，这涉及到将按钮包裹在一个if语句中——该语句将在`OnGUI`中评估。
- en: Add the `creditsMenuButton` and center the buttons on the screen by updating
    the Rects for the original `GUI.Buttons`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`creditsMenuButton`并将按钮居中，通过更新原始`GUI.Buttons`的Rects来实现。
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'While there are other ways to do this in Unity using GUI Groups, this will
    suit our purposes better as an instructional tool. If we render our scene now,
    we will find two buttons which contain our button textures:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然在Unity中使用GUI组还有其他方法来做这件事，但这种方法更适合作为教学工具。如果我们现在渲染场景，我们会发现两个包含我们的按钮纹理的按钮：
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_10.jpg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 向GUI添加按钮](img/978-1-84969-040-9_9_10.jpg)'
- en: 'Pressing these buttons will show some debug text in the console:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按压这些按钮将在控制台显示一些调试文本：
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_14.jpg)'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 向GUI添加按钮](img/978-1-84969-040-9_9_14.jpg)'
- en: While this allows our buttons to be rendered, there is more GUI Button being
    rendered than we want. The Unity GUI has its own style engine defined in `GUIStyle`
    , which determines how a button should be drawn. As we have baked the look and
    feel of our buttons into the textures themselves, we don't need Unity to display
    any of this style.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这允许我们的按钮被渲染，但渲染的GUI按钮比我们想要的要多。Unity GUI在其`GUIStyle`中定义了自己的样式引擎，它决定了按钮应该如何绘制。由于我们已经将按钮的外观和感觉烘焙到纹理本身中，我们不需要Unity显示任何这种样式。
- en: Update the `GUIStyle` of the `GUI.Buttons` so that they have no associated style.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`GUI.Button`的`GUIStyle`，使其没有关联的样式。
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Time for action — Adding buttons to the GUI](img/978-1-84969-040-9_9_11.jpg)'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 — 向GUI添加按钮](img/978-1-84969-040-9_9_11.jpg)'
- en: By making this simple change we will get the GUI rendered exactly how we intended.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过进行这个简单的更改，我们将能够以我们期望的方式渲染GUI。
- en: Update the script to load the Unity levels when the buttons are pressed.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新脚本以在按钮按下时加载Unity级别。
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By making the call to `Application.LoadLevel` as we have previously, we now
    have a mechanism for pressing a button in the interface and having Unity load
    a particular scene.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像之前那样调用`Application.LoadLevel`，我们现在有一个机制，即通过界面按下按钮，Unity加载特定的场景。
- en: What just happened?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We have just constructed a simple immediate mode GUI to display the main menu
    for our game. We have accomplished this by using the Unity GUI system and building
    a script which renders our GUI. Under the covers, what Unity is doing is drawing
    our scene every frame, based upon the script. It is important to note that if
    you were to change the script so that, programmatically, it were to display certain
    things based upon some setting or every third frame, Unity will do that because
    it is processing the UI script each and every frame. Accordingly it is important
    to not perform any extremely complex operations in the `OnGUI` method as it could
    result in a substantial performance slowdown.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚构建了一个简单的即时模式GUI，用于显示我们游戏的主菜单。我们通过使用Unity GUI系统和构建一个渲染我们的GUI的脚本来实现这一点。在幕后，Unity正在根据脚本每帧绘制我们的场景。重要的是要注意，如果你更改脚本，使其程序性地根据某些设置或每三帧显示某些内容，Unity会这样做，因为它会每帧处理UI脚本。因此，在`OnGUI`方法中执行任何非常复杂的操作都可能导致性能显著下降。
- en: A better way — UIToolkit
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更好的方法 — UIToolkit
- en: One of the issues with the current implementation of the Unity GUI library is
    that it was designed for PC users and doesn't take into account any of the limitations
    of mobile devices. While it performs well enough in some situations, in most situations
    the number of draw calls it generates are enough to wreck the performance of your
    game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Unity GUI库当前实现的一个问题是，它是为PC用户设计的，没有考虑到移动设备的任何限制。虽然在某些情况下性能足够好，但在大多数情况下，它生成的绘制调用数量足以破坏你游戏的性能。
- en: In our previous example it is not possible to really see the impact of the performance
    slowdown because we aren't doing any rendering that is intense enough to impact
    the frame rate. As our scene is pretty static, one wouldn't be able to visually
    measure the result. However, if we look at our statistics we can see that even
    for this very modest GUI we're utilizing three draw calls — one for each GUI component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，由于我们没有进行任何足够强烈的渲染来影响帧率，因此无法真正看到性能下降的影响。由于我们的场景相当静态，因此无法直观地测量结果。然而，如果我们查看我们的统计数据，我们可以看到，即使是这个非常简单的GUI，我们也正在使用三个绘制调用——每个GUI组件一个。
- en: '![A better way — UIToolkit](img/978-1-84969-040-9_9_15.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![更好的方法 — UIToolkit](img/978-1-84969-040-9_9_15.jpg)'
- en: This may not seem like much now, but as you learn more in the chapter on optimization,
    this is a substantial amount of work that the iOS device is doing. So what if
    we could accomplish the same amount of work within a single draw call? What if
    we could have only one draw call regardless of the number of GUI elements we're
    drawing? Enter Prime31's UIToolkit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能看起来并不多，但随着你在优化章节中学到更多，这是iOS设备正在做的大量工作。那么如果我们能在单个draw call中完成同样多的工作会怎样？如果我们能不管我们绘制多少GUI元素都只有一个draw
    call会怎样？Prime31的UIToolkit就出现了。
- en: Time for action — Prime31 UIToolkit
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间 — Prime31 UIToolkit
- en: Download **code'n'web TexturePackerPro** essentials by visiting the website:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_16.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问网站：[https://github.com/prime31/UIToolkit](http://https://github.com/prime31/UIToolkit)下载**code'n'web
    TexturePackerPro**基本功能。
- en: Select the latest available version of TexturePacker from the download list
    and install TexturePacker:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_17.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下载列表中选择TexturePacker的最新可用版本并安装TexturePacker：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_17.jpg)
- en: Next, drag the UI buttons for the credits menu and the start game menu into
    the interface. You can do this by dragging the images into the Sprites menu on
    the right-hand side of the interface:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_18.jpg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将信用菜单和开始游戏菜单的UI按钮拖入界面。你可以通过将图像拖入界面右侧的 Sprites 菜单来完成此操作：![执行时间 — Prime31
    UIToolkit](img/978-1-84969-040-9_9_18.jpg)
- en: We want to use the minimum amount of texture memory possible so set the **Max.
    width** and **Max. height** to the smallest power of 2 possible. Your texture
    will still need to be square so you're looking for the smallest number that box
    width and height can be set to simultaneously. In our case it is 512\. If **TexturePacker**
    cannot find a way to fit your textures into that size it will turn the text red.![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_19.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望使用尽可能少的纹理内存，所以将**最大宽度**和**最大高度**设置为可能的最小2的幂次。你的纹理仍然需要是正方形，所以你在寻找可以同时设置盒子的宽度和高度的
    smallest number。在我们的例子中是512。如果**TexturePacker**找不到将你的纹理放入该大小的方法，它将把文本变成红色。![执行时间
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_19.jpg)
- en: One benefit that you may not have noticed at this point is that before we were
    creating textures as large power of 2 textures so that Unity would accept them.
    Here TexturePacker is identifying the empty space in the textures and optimizing
    the amount of space each texture takes. In this case we actually have additional
    space where we could pack more textures if we needed to.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段你可能还没有注意到的一个好处是，在我们之前创建纹理时，我们是以2的幂次大的纹理来创建的，这样Unity才能接受它们。在这里，TexturePacker正在识别纹理中的空白区域，并优化每个纹理所占用的空间。在这种情况下，我们实际上有额外的空间，如果我们需要的话，可以打包更多的纹理。
- en: In the **Output settings** (scroll the left pane to the bottom) set the **Data
    format** to **JSON** (Javascript Object Notation) and set the directory to your
    project's `Assets` folder. Set the name of the file as `gui` and change the extension
    of the `.json` file to `.txt`, as Unity expects text assets to end with a `.txt`
    extension.![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_20.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**输出设置**（滚动左侧面板到底部）中将**数据格式**设置为**JSON**（JavaScript对象表示法）并将目录设置为项目的`Assets`文件夹。将文件名设置为`gui`并将`.json`文件的扩展名更改为`.txt`，因为Unity期望文本资源以`.txt`扩展名结尾。![执行时间
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_20.jpg)
- en: Press the **Publish** button in the toolbar and the appropriate files will be
    created in your `Assets` folder.![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_21.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏中按下**发布**按钮，将在你的`Assets`文件夹中创建适当的文件。![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_21.jpg)
- en: We are now done with everything we need from TexturePacker.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经完成了从TexturePacker需要的所有事情。
- en: Download the UIToolkit library from Prime31's github repository by visiting
    the website at [https://github.com/prime31/UIToolkit:](http://https://github.com/prime31/UIToolkit)![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_22.jpg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问[https://github.com/prime31/UIToolkit](http://https://github.com/prime31/UIToolkit)网站下载UIToolkit库。
- en: Select download and choose the .unitypackage option:![Time for action — Prime31
    UIToolkit](img/978-1-84969-040-9_9_23.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择下载并选择.unitypackage选项：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_23.jpg)
- en: After it downloads, install the Unity package, importing all of the items in
    it:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_24.jpg)
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，安装Unity包，导入其中的所有项目：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_24.jpg)
- en: So that we can examine the 2 different approaches to render GUIs separately,
    create a new scene for this approach, and name it UIToolkit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了分别检查渲染GUI的两种不同方法，为这种方法创建一个新的场景，并将其命名为UIToolkit。
- en: To make sure that our UI components are segregated from the rest of our scene,
    we want to put them on a particular layer in Unity. Layers are collections of
    components that can be accessed or manipulated as a collection. If you are familiar
    with Photoshop, the concept is similar.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们的UI组件与场景中的其他部分分离，我们希望在Unity中将其放置在特定的层上。层是一组组件的集合，可以作为一个集合进行访问或操作。如果你熟悉Photoshop，这个概念是相似的。
- en: In Unity, create a new Layer for our GUI to be drawn on by accessing the Layers
    through **Edit | Project Settings** | **Tags:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_25.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，通过访问**编辑 | 项目设置** | **标签**来创建一个新的层，以便我们的GUI可以绘制：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_25.jpg)
- en: Select **User Layer 8** and set the Layer name to **UI Layer:**![Time for action
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_26.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**用户层8**，并将层名称设置为**UI层**：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_26.jpg)
- en: Create an empty game object, name it **GUIObject** and set its position to 0,0,0:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_27.jpg)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的游戏对象，命名为**GUIObject**，并将其位置设置为0,0,0：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_27.jpg)
- en: Expand the `Plugins` folder in the **Project** view and you will find the **UIToolkit
    library. Expand UIToolkit** and drag the UI script onto the **GUIObject:**![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_28.jpg)
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**视图中展开`插件`文件夹，你将找到**UIToolkit库**。展开UIToolkit，并将UI脚本拖放到**GUIObject:**![执行时间
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_28.jpg)
- en: Select the **MainCamera** object in the **Hierarchy** view and remove the **UILayer**
    from the **Culling Mask** to ensure that the UI does not get drawn more than once:![Time
    for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_29.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中选择**MainCamera**对象，并从**裁剪遮罩**中移除**UILayer**，以确保UI不会绘制两次：![执行时间 —
    Prime31 UIToolkit](img/978-1-84969-040-9_9_29.jpg)
- en: Once you select the **UILayer** the **Culling Mask** should be displayed as
    **Mixed** as shown in the following screenshot:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_30.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择**UILayer**，**裁剪遮罩**应显示为**混合**，如下截图所示：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_30.jpg)
- en: Create a new empty game object called **UIToolkit** and make it a child of the
    **GUIObject** we created earlier that contains the UI script:![Time for action
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_31.jpg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空游戏对象，命名为**UIToolkit**，并将其设置为之前创建的包含UI脚本的**GUIObject**的子对象：![执行时间 — Prime31
    UIToolkit](img/978-1-84969-040-9_9_31.jpg)
- en: Drag the **UIToolkit** script from the `UIToolkit plugins` folder onto the UIToolkit
    game object in the **Hierarchy** view:![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_32.jpg)
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UIToolkit plugins`文件夹中的**UIToolkit**脚本拖放到**层次结构**视图中的UIToolkit游戏对象上：![执行时间
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_32.jpg)
- en: Select the **GUIObject** node in the **Hierarchy** view to bring up its inspector.
    Tell it we want the UI to be drawn on the **UILayer** by selecting the drop-down
    next to the **UILayer** entry and selecting the layer that the UI is to be drawn
    on — which we have also called **UILayer:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_33.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**视图中选择**GUIObject**节点，以显示其检查器。告诉它我们希望UI在**UILayer**上绘制，通过选择**UILayer**条目旁边的下拉菜单并选择UI要绘制的层——我们也将它命名为**UILayer**：![执行时间
    — Prime31 UIToolkit](img/978-1-84969-040-9_9_33.jpg)
- en: To wrap up our configuration we need to tell **UIToolkit** which TexturePacker
    config we're using. Select the **UIToolkit** node in the **Hierarchy** view to
    bring up its inspector. In the **Texture Packer Config Name** enter the name of
    the config that we saved, in this case **gui:**![Time for action — Prime31 UIToolkit](img/978-1-84969-040-9_9_34.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的配置，我们需要告诉**UIToolkit**我们正在使用哪个TexturePacker配置。在**层次结构**视图中选择**UIToolkit**节点以显示其检查器。在**Texture
    Packer Config Name**中输入我们保存的配置名称，在本例中为**gui**：![执行时间 — Prime31 UIToolkit](img/978-1-84969-040-9_9_34.jpg)
- en: Now we're ready to create our GUI using the textures we used in Texture Packer.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们准备使用在Texture Packer中使用的纹理来创建我们的GUI。
- en: 'Create a Script called `UIToolkitGUI` and let''s add a button to the screen
    using this new approach:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `UIToolkitGUI` 的脚本，并使用这种新方法在屏幕上添加一个按钮：
- en: '[PRE9]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the UIToolkit button class takes a normal button state and a pressed
    button state. As we didn't have both we just used the same texture for both. The
    last two arguments are the position on the screen where we want this button to
    show up.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，UIToolkit按钮类接受一个正常按钮状态和一个按下按钮状态。由于我们没有两者，所以我们只是使用了相同的纹理。最后两个参数是我们希望在屏幕上显示此按钮的位置。
- en: Press play and our button will show up on the screen.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放，我们的按钮将显示在屏幕上。
- en: What just happened?
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: We just created our GUI using the open source and free library UIToolkit from
    Prime31\. We have accomplished the same thing as our original menu, but with a
    single draw call. While we could have accomplished similar with UnityGUI, the
    performance would have gotten progressively worse the more complex the user interface
    became, as each control added and each GUIStyle rendered results in another draw
    call.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚使用Prime31的开源免费库UIToolkit创建了我们的GUI。我们实现了与原始菜单相同的功能，但只需要一个绘制调用。虽然我们也可以使用UnityGUI实现类似的功能，但随着用户界面的越来越复杂，性能会逐渐下降，因为每个控件的增加和每个GUIStyle的渲染都会导致另一个绘制调用。
- en: In addition, we've come up with a more optimal way to get textures into the
    UI. Unity, by default, will not allow you to use a non-power of 2 texture for
    rendering which will result in lots of wasted texture memory at each texture.
    With this approach we can pack a large number of textures into a single larger
    texture, which is in itself more efficient, and render textures of wildly different
    shapes without sacrificing much in texture memory efficiency.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还提出了一种更优化的方法来将纹理放入UI。默认情况下，Unity不允许您使用非2的幂纹理进行渲染，这将导致每个纹理都有大量的浪费纹理内存。使用这种方法，我们可以将大量纹理打包到一个更大的纹理中，这本身就更高效，并且可以渲染形状迥异的纹理，而不会在纹理内存效率上牺牲太多。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have learned how to build a UI for our game. We have explored
    setting up a UI using the Unity GUI APIs, as well as setting up a UI using the
    leading third party plugin Prime31 UIToolkit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何为我们的游戏构建UI。我们探讨了使用Unity GUI API设置UI，以及使用领先的第三方插件Prime31 UIToolkit设置UI。
- en: 'Specifically, we covered:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了：
- en: How to build an immediate mode GUI with the standard GUI library
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用标准GUI库构建即时模式GUI
- en: How to build a GUI using the Prime31 UIToolkit
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Prime31 UIToolkit构建GUI
- en: Some concerns about GUI performance
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GUI性能的一些担忧
- en: Now that we are finished putting together the UI, we need to handle more complex
    gameplay scripting for our game — which is the focus of our next chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了UI的组装，我们需要为我们的游戏处理更复杂的游戏脚本——这是我们下一章的重点。
