- en: Chapter 2. Foundation Framework – Growing Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about modules and how they change the way we
    import frameworks into our files. We will cover both, the new and the old classes
    of the Foundation Framework, starting with the brand new `NSProgress` class. We
    will see some of the major improvements to the existing classes including `NSArray`
    and the `firstObject` method, `NSTimer`'s new property for managing tolerance,
    the additional encodings now supported by `NSData`, and lastly new ways to manage
    URLs with `NSURLUtilities`. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Why Foundation matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Foundation is the core framework of Objective-C. Without it, developing iOS
    applications would not be possible. Foundation defines the base layer of all classes,
    as well as functionality for basic data types, including strings, arrays, and
    dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Changes made to the Foundation Framework can range from minor enhancements to
    the introduction of completely new classes. iOS 7 is no exception to this and
    Apple has provided some great new features that we will explore in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing applications using Xcode and the iOS SDK, you may have noticed
    that it has never been a requirement to import commonly used header files, such
    as `UIViewController.h` or `UIView.h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open any file in any project, and navigate to any view-controller based `.h`
    file in the project. The very first line of code will read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: As an iOS developer, you have probably written hundreds of `#import` statements
    in any one project. When the compiler reaches an import statement, it literally
    inserts every line of code found in the imported header file. In the previous
    example of the first line of code, `UIKit.h` imports all header files available
    in the UIKit Framework; so, you don't have to worry about which header file should
    be imported for different instances.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever taken a look at all of the files included in UIKit, you will
    see that they total over 11,000 lines of code. This means that each file importing
    `UIKit.h` will grow by 11,000 lines of code. This is less than ideal; however,
    Apple provides one solution with **precompiled header** (**PCH**) files.
  prefs: []
  type: TYPE_NORMAL
- en: Precompiled headers – a partial solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each project you create will automatically generate its own PCH file in the
    supporting files group. During the preprocessing phase of compilation, the PCH
    file will load and cache the specified headers to import. The following is an
    example of a PCH file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Your application may require a specific framework or class in multiple files.
    Rather than importing the file individually (and repeatedly), adding the import
    statement to the PCH file will precompute and cache a majority of the work during
    the preprocessing phase of compilation. This allows each file to be pulled from
    the cache when available.
  prefs: []
  type: TYPE_NORMAL
- en: Although this method works well, when importing the Apple frameworks, you must
    always remember to link the frameworks to your project. Failing to do so will
    result in a number of errors thrown by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Modules – smart importing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the introduction of iOS 7, Apple has introduced a new way to handle precompiling
    frameworks with modules. Instead of replacing an import statement with every line
    of code, a module encapsulates a framework into a self-contained block. Modules
    are precompiled in the same way import statements are precompiled in the PCH file;
    however, using modules will automatically link the proper framework and provide
    the exact same speed boost to compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Modules are enabled by default in all new projects created using Xcode 5\. For
    older projects, you can enable modules in your project's build settings by searching
    for modules and setting **Enable Modules (C and Objective-C)** to **Yes**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modules – smart importing](img/0319OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that modules have been turned on, you can start using the new syntax to
    import frameworks. At the top of the `.h` file you wish to import, simply type
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That's all that is required in your code. Xcode will automatically link the
    required framework (in this case, `QuartzCore`) and provide you with all of the
    speed boosts for compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you can import specific header files based on need. You may,
    for instance, only require the `CoreAnimation` headers provided by `QuartzCore`.
    You can easily import these headers by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, Xcode will automatically convert `#import` statements to `@import`
    for you at runtime. Although convenient, it is still recommended you update to
    new syntax whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that modules currently only support Apple frameworks.
    Custom classes and third-party frameworks still require the traditional method
    or the PCH file.
  prefs: []
  type: TYPE_NORMAL
- en: NSProgress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS 7 introduces a completely new class to the Foundation framework, `NSProgress`.
    Using `NSProgress` involves treating each task of an action as a milestone of
    completion. By doing so, you, the developer, can track progress directly in code
    and perform individual tasks for each milestone.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to perform a particular action, you may require four separate
    tasks to be completed. Each task is capable of monitoring its own progress, and
    will report once the task is complete. In our example, this would increase the
    percent of completion to 25.
  prefs: []
  type: TYPE_NORMAL
- en: '`NSProgress` uses **Key Value Observing** (**KVO**) to provide notifications
    related to progress. These notifications can be used to update a UI component
    displaying progress to the user, such as a progress bar or label. The following
    code is a very simple implementation that demonstrates working with `NSProgress`
    to report progress in a localized manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: NSArray
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using `NSArray`, you must ensure that all supplied indexes are within range
    and not beyond the length of the array. When retrieving an element using an index,
    the index must be between zero and a number (the number being the total items
    in the array); otherwise, an exception will be thrown. A common use case of this
    involves grabbing the first or last object from an array.
  prefs: []
  type: TYPE_NORMAL
- en: '`NSArray` has always had the following method to obtain the last object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, grabbing the first object of an array required checks to ensure
    that the index was within the bounds of the array, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the preceding example is rather small, you can see how more complex
    implementations can be complicated and time consuming. Thankfully, with iOS 7,
    Apple has finally made public a previously private method for `NSArray` to grab
    the first object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This handy method will allow you to quickly access the first object of any array
    without the hassle. Additionally, if the array is empty, this method will return
    `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: NSTimer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is a common practice to perform periodic tasks using `NSTimer`. The following
    is an example use of `NSTimer` to perform a task in two-second intervals and repeats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The issue with this method is that the CPU is consistently active in order to
    perform the desired task repeatedly. When using multiple timers at once, it is
    possible (although unlikely) that it may reduce the performance of the CPU for
    the rest of your application. It is always best practice to run tests on your
    applications to find such possibilities and use safeguards wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Apple has added a new tolerance property to `NSTimer` to reduce the strain on
    the CPU when using `NSTimers`. This property will tell the application how late
    a timer is allowed to fire when it has surpassed its scheduled interval. As a
    result, the application will be able to group actions together to reduce CPU strain.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new property can be accessed and set with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting this property will help create safeguards for your CPU usage related
    to timers.
  prefs: []
  type: TYPE_NORMAL
- en: NSData
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application uses data in some way or another. In some instances, you may
    require the ability to manipulate individual bytes of data. `NSData` encapsulates
    these raw bytes to allow for easy manipulation using built-in methods.
  prefs: []
  type: TYPE_NORMAL
- en: With iOS 7, `NSData` now adds support for Base64 encoding and decoding; a group
    of ACSII format binary-to-text encoding schemes. These schemes are most commonly
    used to transfer data between media that only support text-based data transfer.
    Encoding images from JSON-based responses from a web API is the most common use
    for these schemes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to iOS 7, developers were required to use a third-party library or build
    their own from scratch. Apple has made it exceptionally easy to use these encoding
    methods with the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first two methods are focused on UTF-8 encoded data, while the remaining
    two deal directly with string values. Both pairs of methods provide the same functionality;
    however, each use case may provide better performance.
  prefs: []
  type: TYPE_NORMAL
- en: NSURLUtilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Foundation Framework includes many different methods related to handling
    URLs; however, most API's related to manipulating these URLs are based on `NSString`
    because `NSURL` is an immutable class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this issue, Apple has introduced `NSURLComponents` to allow
    for manipulation of URL objects. With `NSURLComponents`, `NSURL` can be treated
    as a mutable object that allows direct manipulation. The following code snippet
    is an example use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code will output the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://somewebsite.com/somepath?queryParameter=parameterValue`'
  prefs: []
  type: TYPE_NORMAL
- en: Using `NSURLComponents`, you may now directly manipulate `NSURL` values without
    the use of `NSString`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the major updates to the Foundation Framework.
    It is always recommended that you stay up to date with the advancements to Objective-C
    and Apple's core frameworks. With this knowledge, you now have the tools to build
    more efficient and better-performing applications!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of the new features found in Foundation,
    it's time to start building our application. In the next chapter, we will begin
    building our interface using the new Auto Layout features in iOS 7.
  prefs: []
  type: TYPE_NORMAL
