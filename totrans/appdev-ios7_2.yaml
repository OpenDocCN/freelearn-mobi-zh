- en: Chapter 2. Foundation Framework – Growing Up
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 基础框架 – 成长
- en: In this chapter, we will learn about modules and how they change the way we
    import frameworks into our files. We will cover both, the new and the old classes
    of the Foundation Framework, starting with the brand new `NSProgress` class. We
    will see some of the major improvements to the existing classes including `NSArray`
    and the `firstObject` method, `NSTimer`'s new property for managing tolerance,
    the additional encodings now supported by `NSData`, and lastly new ways to manage
    URLs with `NSURLUtilities`. Let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习模块以及它们如何改变我们将框架导入文件的方式。我们将涵盖 Foundation 框架的新旧类，从全新的 `NSProgress` 类开始。我们将看到对现有类的一些主要改进，包括
    `NSArray` 和 `firstObject` 方法，`NSTimer` 的新属性用于管理容差，`NSData` 现在支持的附加编码，以及最后使用 `NSURLUtilities`
    管理URL的新方法。让我们开始吧！
- en: Why Foundation matters
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 Foundation 很重要
- en: Foundation is the core framework of Objective-C. Without it, developing iOS
    applications would not be possible. Foundation defines the base layer of all classes,
    as well as functionality for basic data types, including strings, arrays, and
    dictionaries.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Foundation 是 Objective-C 的核心框架。没有它，开发 iOS 应用程序将是不可能的。Foundation 定义了所有类的底层，以及包括字符串、数组和字典在内的基本数据类型的功能。
- en: Changes made to the Foundation Framework can range from minor enhancements to
    the introduction of completely new classes. iOS 7 is no exception to this and
    Apple has provided some great new features that we will explore in this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Foundation 框架所做的更改可能从微小的增强到完全新类的引入。iOS 7 也不例外，Apple 提供了一些我们将在本章中探索的出色新功能。
- en: Modules
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: While developing applications using Xcode and the iOS SDK, you may have noticed
    that it has never been a requirement to import commonly used header files, such
    as `UIViewController.h` or `UIView.h`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Xcode 和 iOS SDK 开发应用程序时，你可能已经注意到，导入常用头文件，如 `UIViewController.h` 或 `UIView.h`，从未是必需的。
- en: 'Open any file in any project, and navigate to any view-controller based `.h`
    file in the project. The very first line of code will read as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 打开任何项目中的任何文件，导航到基于视图控制器 `.h` 文件。代码的第一行将如下所示：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户中下载所有示例代码文件。[http://www.packtpub.com](http://www.packtpub.com)。如果你在其他地方购买了这本书，你可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support) 并注册以直接将文件通过电子邮件发送给你。
- en: As an iOS developer, you have probably written hundreds of `#import` statements
    in any one project. When the compiler reaches an import statement, it literally
    inserts every line of code found in the imported header file. In the previous
    example of the first line of code, `UIKit.h` imports all header files available
    in the UIKit Framework; so, you don't have to worry about which header file should
    be imported for different instances.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 iOS 开发者，你可能在一个项目中编写了数百个 `#import` 语句。当编译器遇到一个导入语句时，它实际上会插入导入头文件中找到的每一行代码。在前面代码的第一行示例中，`UIKit.h`
    导入了 UIKit 框架中可用的所有头文件；因此，你不必担心为不同的实例导入哪个头文件。
- en: If you have ever taken a look at all of the files included in UIKit, you will
    see that they total over 11,000 lines of code. This means that each file importing
    `UIKit.h` will grow by 11,000 lines of code. This is less than ideal; however,
    Apple provides one solution with **precompiled header** (**PCH**) files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经查看过 UIKit 中包含的所有文件，你会发现它们的总代码行数超过 11,000 行。这意味着每个导入 `UIKit.h` 的文件将增加 11,000
    行代码。这并不理想；然而，Apple 提供了一个解决方案，即 **预编译头文件**（**PCH**）。
- en: Precompiled headers – a partial solution
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预编译头文件 – 一种部分解决方案
- en: 'Each project you create will automatically generate its own PCH file in the
    supporting files group. During the preprocessing phase of compilation, the PCH
    file will load and cache the specified headers to import. The following is an
    example of a PCH file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的每个项目都会在支持文件组中自动生成自己的 PCH 文件。在编译预处理阶段，PCH 文件将加载并缓存指定的头文件以导入。以下是一个 PCH 文件的示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your application may require a specific framework or class in multiple files.
    Rather than importing the file individually (and repeatedly), adding the import
    statement to the PCH file will precompute and cache a majority of the work during
    the preprocessing phase of compilation. This allows each file to be pulled from
    the cache when available.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序可能需要在多个文件中需要特定的框架或类。而不是逐个导入文件（并重复导入），将导入语句添加到 PCH 文件中将在编译的预处理阶段预先计算并缓存大部分工作。这使得当可用时，每个文件都可以从缓存中提取。
- en: Although this method works well, when importing the Apple frameworks, you must
    always remember to link the frameworks to your project. Failing to do so will
    result in a number of errors thrown by the compiler.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法效果很好，但在导入 Apple 框架时，你必须始终记得将框架链接到你的项目中。否则，编译器将抛出许多错误。
- en: Modules – smart importing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块 – 智能导入
- en: With the introduction of iOS 7, Apple has introduced a new way to handle precompiling
    frameworks with modules. Instead of replacing an import statement with every line
    of code, a module encapsulates a framework into a self-contained block. Modules
    are precompiled in the same way import statements are precompiled in the PCH file;
    however, using modules will automatically link the proper framework and provide
    the exact same speed boost to compilation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 iOS 7 的推出，Apple 引入了一种新的处理模块预编译框架的方法。而不是用每行代码替换导入语句，模块将框架封装到一个自包含的块中。模块的预编译方式与
    PCH 文件中导入语句的预编译方式相同；然而，使用模块将自动链接正确的框架并提供与编译加速相同的速度提升。
- en: Modules are enabled by default in all new projects created using Xcode 5\. For
    older projects, you can enable modules in your project's build settings by searching
    for modules and setting **Enable Modules (C and Objective-C)** to **Yes**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Xcode 5 创建的所有新项目中，模块默认启用。对于旧项目，你可以在项目的构建设置中通过搜索模块并将 **Enable Modules (C
    and Objective-C)** 设置为 **Yes** 来启用模块。
- en: '![Modules – smart importing](img/0319OT_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![模块 – 智能导入](img/0319OT_02_01.jpg)'
- en: 'Now that modules have been turned on, you can start using the new syntax to
    import frameworks. At the top of the `.h` file you wish to import, simply type
    the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模块已被启用，你可以开始使用新的语法来导入框架。在你要导入的 `.h` 文件顶部，只需输入以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all that is required in your code. Xcode will automatically link the
    required framework (in this case, `QuartzCore`) and provide you with all of the
    speed boosts for compilation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的代码中所需的所有内容。Xcode 将自动链接所需的框架（在这种情况下，`QuartzCore`）并为你提供所有编译加速。
- en: 'Additionally, you can import specific header files based on need. You may,
    for instance, only require the `CoreAnimation` headers provided by `QuartzCore`.
    You can easily import these headers by typing the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以根据需要导入特定的头文件。例如，你可能只需要 `QuartzCore` 提供的 `CoreAnimation` 头文件。你可以轻松地通过输入以下代码来导入这些头文件：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Additionally, Xcode will automatically convert `#import` statements to `@import`
    for you at runtime. Although convenient, it is still recommended you update to
    new syntax whenever possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Xcode 将在运行时自动将 `#import` 语句转换为 `@import`。尽管方便，但仍然建议尽可能更新到新语法。
- en: It is also important to note that modules currently only support Apple frameworks.
    Custom classes and third-party frameworks still require the traditional method
    or the PCH file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，当前模块仅支持 Apple 框架。自定义类和第三方框架仍然需要传统方法或 PCH 文件。
- en: NSProgress
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSProgress
- en: iOS 7 introduces a completely new class to the Foundation framework, `NSProgress`.
    Using `NSProgress` involves treating each task of an action as a milestone of
    completion. By doing so, you, the developer, can track progress directly in code
    and perform individual tasks for each milestone.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 7 在 Foundation 框架中引入了一个全新的类 `NSProgress`。使用 `NSProgress` 涉及将每个动作的任务视为完成的里程碑。通过这样做，作为开发者的你可以在代码中直接跟踪进度并执行每个里程碑的单独任务。
- en: For instance, to perform a particular action, you may require four separate
    tasks to be completed. Each task is capable of monitoring its own progress, and
    will report once the task is complete. In our example, this would increase the
    percent of completion to 25.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了执行特定的动作，你可能需要完成四个单独的任务。每个任务都能够监控自己的进度，并在任务完成后报告。在我们的例子中，这将使完成百分比增加到 25%。
- en: '`NSProgress` uses **Key Value Observing** (**KVO**) to provide notifications
    related to progress. These notifications can be used to update a UI component
    displaying progress to the user, such as a progress bar or label. The following
    code is a very simple implementation that demonstrates working with `NSProgress`
    to report progress in a localized manner:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSProgress` 使用 **键值观察**（**KVO**）来提供与进度相关的通知。这些通知可以用来更新显示给用户的 UI 组件，例如进度条或标签。以下是一个非常简单的实现示例，展示了如何使用
    `NSProgress` 以本地化的方式报告进度：'
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: NSArray
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSArray
- en: When using `NSArray`, you must ensure that all supplied indexes are within range
    and not beyond the length of the array. When retrieving an element using an index,
    the index must be between zero and a number (the number being the total items
    in the array); otherwise, an exception will be thrown. A common use case of this
    involves grabbing the first or last object from an array.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `NSArray` 时，你必须确保所有提供的索引都在范围内，并且不超过数组的长度。在通过索引检索元素时，索引必须在零和数字之间（该数字是数组中的总项目数）；否则，将抛出异常。这种常见用例包括从数组中获取第一个或最后一个对象。
- en: '`NSArray` has always had the following method to obtain the last object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSArray` 一直都有以下方法来获取最后一个对象：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Previously, grabbing the first object of an array required checks to ensure
    that the index was within the bounds of the array, as shown in the following code
    snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，获取数组中的第一个对象需要检查索引是否在数组范围内，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Although the preceding example is rather small, you can see how more complex
    implementations can be complicated and time consuming. Thankfully, with iOS 7,
    Apple has finally made public a previously private method for `NSArray` to grab
    the first object:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子相当小，但你也可以看到更复杂的实现可能会很复杂且耗时。幸运的是，随着 iOS 7 的发布，苹果终于公开了一个之前私有的 `NSArray`
    方法来获取第一个对象：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This handy method will allow you to quickly access the first object of any array
    without the hassle. Additionally, if the array is empty, this method will return
    `nil`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个便捷的方法将允许你快速访问任何数组中的第一个对象，而无需麻烦。此外，如果数组为空，此方法将返回 `nil`。
- en: NSTimer
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSTimer
- en: 'It is a common practice to perform periodic tasks using `NSTimer`. The following
    is an example use of `NSTimer` to perform a task in two-second intervals and repeats:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSTimer` 执行周期性任务是一种常见做法。以下是一个使用 `NSTimer` 在两秒间隔内执行任务并重复的示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The issue with this method is that the CPU is consistently active in order to
    perform the desired task repeatedly. When using multiple timers at once, it is
    possible (although unlikely) that it may reduce the performance of the CPU for
    the rest of your application. It is always best practice to run tests on your
    applications to find such possibilities and use safeguards wherever possible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是 CPU 会持续活跃以重复执行所需的任务。当同时使用多个计时器时，虽然可能性不大，但可能会降低应用程序其余部分的 CPU 性能。始终最好在应用程序上进行测试以找到此类可能性，并在可能的情况下使用安全措施。
- en: Apple has added a new tolerance property to `NSTimer` to reduce the strain on
    the CPU when using `NSTimers`. This property will tell the application how late
    a timer is allowed to fire when it has surpassed its scheduled interval. As a
    result, the application will be able to group actions together to reduce CPU strain.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为 `NSTimer` 添加了一个新的容差属性，以减少使用 `NSTimers` 时对 CPU 的压力。此属性将告诉应用程序，当计时器超过了其预定间隔时，允许计时器延迟多长时间才触发。因此，应用程序可以将操作组合在一起以减少
    CPU 压力。
- en: 'This new property can be accessed and set with the following methods:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新属性可以通过以下方法访问和设置：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Setting this property will help create safeguards for your CPU usage related
    to timers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设置此属性将有助于为与计时器相关的 CPU 使用情况创建安全措施。
- en: NSData
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSData
- en: Every application uses data in some way or another. In some instances, you may
    require the ability to manipulate individual bytes of data. `NSData` encapsulates
    these raw bytes to allow for easy manipulation using built-in methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都以某种方式使用数据。在某些情况下，你可能需要能够操作数据的单个字节。`NSData` 封装了这些原始字节，以便可以使用内置方法轻松操作。
- en: With iOS 7, `NSData` now adds support for Base64 encoding and decoding; a group
    of ACSII format binary-to-text encoding schemes. These schemes are most commonly
    used to transfer data between media that only support text-based data transfer.
    Encoding images from JSON-based responses from a web API is the most common use
    for these schemes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 7中，`NSData`现在增加了对Base64编码和解码的支持；一组ASCII格式二进制到文本编码方案。这些方案最常用于在仅支持基于文本数据传输的媒体之间传输数据。从基于JSON的Web
    API响应中编码图像是这些方案最常见的使用场景。
- en: 'Prior to iOS 7, developers were required to use a third-party library or build
    their own from scratch. Apple has made it exceptionally easy to use these encoding
    methods with the following methods:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 7之前，开发者需要使用第三方库或从头开始构建自己的库。苹果通过以下方法使使用这些编码方法变得异常简单：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first two methods are focused on UTF-8 encoded data, while the remaining
    two deal directly with string values. Both pairs of methods provide the same functionality;
    however, each use case may provide better performance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法专注于UTF-8编码的数据，而剩下的两种则直接处理字符串值。这两对方法提供相同的功能；然而，每种用例可能提供更好的性能。
- en: NSURLUtilities
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NSURLUtilities
- en: The Foundation Framework includes many different methods related to handling
    URLs; however, most API's related to manipulating these URLs are based on `NSString`
    because `NSURL` is an immutable class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 基础框架包括许多与处理URL相关的不同方法；然而，大多数与操作这些URL相关的API都是基于`NSString`，因为`NSURL`是一个不可变类。
- en: 'In order to fix this issue, Apple has introduced `NSURLComponents` to allow
    for manipulation of URL objects. With `NSURLComponents`, `NSURL` can be treated
    as a mutable object that allows direct manipulation. The following code snippet
    is an example use case:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，苹果引入了`NSURLComponents`以允许操作URL对象。使用`NSURLComponents`，`NSURL`可以被视为一个可变对象，允许直接操作。以下代码片段是一个示例用例：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this code will output the following to the console:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将在控制台输出以下内容：
- en: '`http://somewebsite.com/somepath?queryParameter=parameterValue`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://somewebsite.com/somepath?queryParameter=parameterValue`'
- en: Using `NSURLComponents`, you may now directly manipulate `NSURL` values without
    the use of `NSString`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NSURLComponents`，你现在可以直接操作`NSURL`值，而无需使用`NSString`。
- en: Summary
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the major updates to the Foundation Framework.
    It is always recommended that you stay up to date with the advancements to Objective-C
    and Apple's core frameworks. With this knowledge, you now have the tools to build
    more efficient and better-performing applications!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Foundation框架的一些主要更新。始终建议您关注Objective-C和苹果核心框架的进步。有了这些知识，你现在有了构建更高效、性能更好的应用程序的工具！
- en: Now that we have a better understanding of the new features found in Foundation,
    it's time to start building our application. In the next chapter, we will begin
    building our interface using the new Auto Layout features in iOS 7.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Foundation中的新特性有了更好的理解，是时候开始构建我们的应用程序了。在下一章中，我们将开始使用iOS 7中的新自动布局功能来构建我们的界面。
