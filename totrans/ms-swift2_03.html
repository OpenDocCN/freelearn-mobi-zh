<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Using Collections and Cocoa Data Types</h1></div></div></div><p>Once I got past the basic Hello World beginner applications, I quickly began to realize the shortcomings of variables, especially with the Mad Libs style applications that I was starting to write. These applications requested that the user enter in numerous strings, and I was creating a separate variable for each input field that the user entered. Having all of these separate variables quickly became very cumbersome. I remember talking to a friend about this and he asked me why I was not using arrays. At that time, I was not familiar with arrays, so I asked him to show me what they were. Even though he had a TI-99/4A and I had a Commodore Vic-20, the concept of arrays was the same. Even today, the arrays found in modern development languages have the same basic concepts as the arrays I used on my Commodore Vic-20. While it is definitely possible to create a useful application without using collections, when used right, collections do make application development significantly easier.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What an array is in Swift and how to use it</li><li class="listitem" style="list-style-type: disc">What a dictionary is in Swift and how we can use it</li><li class="listitem" style="list-style-type: disc">What a Set is in Swift and how we can use it</li><li class="listitem" style="list-style-type: disc">What a tuple is in Swift and how we can use it</li><li class="listitem" style="list-style-type: disc">How to use Cocoa data types in Swift</li><li class="listitem" style="list-style-type: disc">How to use Foundation data types in Swift</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Swift collection types</h1></div></div></div><p>A<a class="indexterm" id="id121"/> collection<a class="indexterm" id="id122"/> is a group or store of data that has a shared significance. Swift provides three native collection types for storing data. These collection types are arrays, sets, and dictionaries. An array stores the data in an ordered list, sets are an unordered collection of unique data, and dictionaries are an unordered collection of key/value pairs. In an array, we access the data by the location (index) in the array; in a set, we tend to iterate over the set; and dictionaries are usually accessed using a unique key.</p><p>The data<a class="indexterm" id="id123"/> stored in a Swift collection is required to be of the same type. This means, as an example, that we are unable to store a string value and an array of integers. Since Swift does not allow us to mismatch data types in a collection, we can be certain of the data type when we retrieve data from a collection. This is another feature, which on the surface might seem like a shortcoming, but is actually a design feature that helps eliminate common programming mistakes. We will see how to work around this feature by using the <code class="literal">AnyObject</code> and <code class="literal">Any</code> aliases in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Mutability</h1></div></div></div><p>For those<a class="indexterm" id="id124"/> who are familiar with Objective-C, you will know that there are different classes for mutable and immutable collections. For example, to define a mutable array, we use the <code class="literal">NSMutableArray</code> class, and to define an immutable array, we use the <code class="literal">NSArray</code> class. Swift is a little different because it does not contain separate classes for mutable and immutable collections. Instead, we define whether a collection is constant (immutable) or a variable (mutable) by using the <code class="literal">let</code> and <code class="literal">var</code> keywords. This should seem familiar since, in Swift, we define constants with the <code class="literal">let</code> keyword and variables with the <code class="literal">var</code> keyword.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>It is good practice to create immutable collections unless there is a specific need to change the objects within the collection. This allows the compiler to optimize the performance.</p></div></div><p>Let's begin our tour of collections by looking at the most common collection type—the array type.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Arrays</h1></div></div></div><p>Arrays<a class="indexterm" id="id125"/> are a very common component of modern programming languages and can be found virtually in all the modern programming languages. In Swift, arrays are an ordered list of objects of the same type. This is different from the <code class="literal">NSArray</code> class in Objective-C, which can contain objects of different types.</p><p>When an array is created, we must declare the type of data to be stored in it by explicit type declaration or through type inference. Typically, we only explicitly declare the data type of an array when we are creating an empty array. If we initialize an array with data, we should let the compiler use type inference to infer the most appropriate data type for the array.</p><p>Each object<a class="indexterm" id="id126"/> in an array is called an element. Each of these elements is stored in a set order and can be accessed by its location (index) in the array.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Creating and initializing arrays</h2></div></div></div><p>We<a class="indexterm" id="id127"/> can initialize <a class="indexterm" id="id128"/>an array with an array literal. An array literal is a set of values that we prepopulate the array with. The following example shows how to define an immutable array of integers using the <code class="literal">let</code> keyword:</p><div><pre class="programlisting">let arrayOne = [1,2,3]</pre></div><p>As we mentioned, if we need to create a mutable array, we will use the <code class="literal">var</code> keyword to define the array. The following example shows how to define a mutable array:</p><div><pre class="programlisting">var arrayTwo = [4,5,6]</pre></div><p>In the preceding two examples, the compiler inferred the type of values stored in the array by looking at the type of values stored in the array literal. If we needed to create an empty array, we will need to explicitly declare the type of values to store in the array. The following example shows how to declare an empty array that can be used to store integers:</p><div><pre class="programlisting">var arrayThree = [Int]()</pre></div><p>In the preceding examples, we created arrays with integer values, and the majority of the array examples in this chapter will also use integer values; however, we can create arrays in Swift with any type. The only rule is that once an array is defined as containing a particular type, all the elements in the array must be of that type. The following example shows how we would create arrays of various data types:</p><div><pre class="programlisting">var arrayOne = [String]()
var arrayTwo = [Double]()
var arrayThree = [MyObject]()</pre></div><p>Swift does provide special type aliases for working with nonspecific types. These aliases are <code class="literal">AnyObject</code> and <code class="literal">Any</code>. We can use these aliases to define arrays whose elements are of different types, like this:</p><div><pre class="programlisting">var myArray: [AnyObject] = [1,"Two"]</pre></div><p>We should use the <code class="literal">Any</code> and <code class="literal">AnyObject</code> aliases only when there is an explicit need for this behavior. It is always better to be specific about the types of data our collections contain.</p><p>We can also initialize an array to a certain size with all the elements of the array set to a predefined value. This can be very useful if we want to create an array and prepopulate it with the default values. The following example defines an array with seven elements, and each element contains the number <code class="literal">3</code>:</p><div><pre class="programlisting">var arrayFour = [Int](count: 7, repeatedValue: 3)</pre></div><p>While the <a class="indexterm" id="id129"/>most <a class="indexterm" id="id130"/>common array is a one-dimensional array, we can also create multidimensional arrays. A multidimensional array is really nothing more than an array of arrays. For example, a two-dimensional array is an array of arrays, while a three-dimensional array is an array of arrays of arrays. The following examples show the two ways to create a two-dimensional array in Swift:</p><div><pre class="programlisting">var multiArrayOne = [[1,2],[3,4],[5,6]]
var multiArrayTwo = [[Int]]()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Accessing the array elements</h2></div></div></div><p>We use the<a class="indexterm" id="id131"/> subscript syntax to retrieve values from an array. The subscript syntax for an array is where a number appears between two square brackets and that number specifies the location (index), within the array, of the element we wish to retrieve. The following example shows how to retrieve elements from an array using the subscript syntax:</p><div><pre class="programlisting">let arrayOne = [1,2,3,4,5,6]
print(arrayOne[0])  //Displays '1'
print(arrayOne[3])  //Displays '4'</pre></div><p>In the preceding code, we begin by creating an array of integers that contains six numbers. We then print out the value at index <code class="literal">0</code> and <code class="literal">3</code>.</p><p>If we want to retrieve an individual value within a multidimensional array, we will need to provide a subscript for each dimension. If we did not provide a subscript for each dimension, we will return an array rather than an individual value within the array. The following example shows how we can define a two-dimensional array and retrieve an individual value within the two dimensions:</p><div><pre class="programlisting">var multiArray = [[1,2],[3,4],[5,6]]
var arr = multiArray[0] //arr contains the array [1,2]
var value = multiArray[0][1] //value contains 2</pre></div><p>In the preceding code, we begin by defining a two-dimensional array. When we retrieve the value at index <code class="literal">0</code> of the first dimension (<code class="literal">multiArray[0]</code>), we retrieve the array, <code class="literal">[1,2]</code>. When we retrieve the value at index <code class="literal">0</code> of the first dimension and index <code class="literal">1</code> of the second dimension (<code class="literal">multiArray[0][1]</code>), we retrieve the integer, <code class="literal">2</code>.</p><p>We can retrieve the first and last elements of an array using the <code class="literal">first</code> and <code class="literal">last</code> properties. The <code class="literal">first</code> and <code class="literal">last</code> properties return an optional value since the values may be nil if the array is empty. The following example shows how to use the <code class="literal">first</code> and <code class="literal">last</code> properties to retrieve the first and last elements of both single-dimensional and multidimensional <a class="indexterm" id="id132"/>arrays:</p><div><pre class="programlisting">let arrayOne = [1,2,3,4,5,6]
var first = arrayOne.first  //first contains 1
var last = arrayOne.last  //last contains 6

let multiArray = [[1,2],[3,4],[5,6]]
var arrFirst1 = multiArray[0].first //arrFirst1 contains 1
var arrFirst2 = multiArray.first //arrFirst2 contains[1,2]
var arrLast1 = multiArray[0].last //arrLast1 contains 2
var arrLast2 = multiArray.last  //arrLast2 contains [5,6]</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Counting the elements of an array</h2></div></div></div><p>At times, it is<a class="indexterm" id="id133"/> essential to know the number of elements in an array. To retrieve the number of elements, we would use the read-only <code class="literal">count</code> property. The following example shows how to use this property to retrieve the number of elements in both single-dimensional and multidimensional arrays:</p><div><pre class="programlisting">let arrayOne = [1,2,3]
let multiArrayOne = [[3,4],[5,6],[7,8]]
print(arrayOne.count)  //Displays 3
print(multiArrayOne.count)  //Displays 3 for the three arrays
print(multiArrayOne[0].count)  //Displays 2 for the two elements</pre></div><p>The value that is returned by the <code class="literal">count</code> property is the number of elements in the array and not the largest valid index of the array. For nonempty arrays, the largest valid index is the number of elements in the array minus one. This is because the first element of the array has an index number of zero. As an example, if an array has two elements, the valid indexes are <code class="literal">0</code> and <code class="literal">1</code>, while the count property would return <code class="literal">2</code>. The following code illustrates this:</p><div><pre class="programlisting">let arrayOne = [0,1]
print(arrayOne[0])  //Displays 0
print(arrayOne[1])  //Displays 1
print(arrayOne.count) //Displays 2</pre></div><p>If we attempt to retrieve an element from an array, using the subscript syntax, where the index is outside the range of the array, the application will throw an <code class="literal">Array index out of range</code> error. Therefore, if we are unsure of the size of an array, it is good practice to verify that the index is not outside the range of the array. The following examples illustrate this concept:</p><div><pre class="programlisting">//This example will throw an array index out of range error
var arrayTwo = [1,2,3,4]
print(arrayTwo[6])

//This example will not throw an array index out of range error
var arrayOne = [1,2,3,4]
if (arrayOne.count&gt; 6) {
    print(arrayOne[6])
}</pre></div><p>In the preceding<a class="indexterm" id="id134"/> code, the first block of code would throw an <code class="literal">array index out of range</code> error exception because we are attempting to access the value from the array <code class="literal">arrayTwo</code> at index <code class="literal">6</code>; however, there are only four elements in the array. The second example would not throw the <code class="literal">array index out of range</code> error exception because we are checking whether the <code class="literal">arrayOne</code> array contains more than six elements, and if it does not, we do not attempt to access the value at index <code class="literal">6</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Is the array empty?</h2></div></div></div><p>To check <a class="indexterm" id="id135"/>whether an array is empty (does not contain any elements), we use the <code class="literal">isEmpty</code> property. This property will return <code class="literal">true</code> if the array is empty, or <code class="literal">false</code> if it has elements. The following example shows how to check whether an array is empty or not:</p><div><pre class="programlisting">var arrayOne = [1,2]
var arrayTwo = [Int]()
arrayOne.isEmpty  //Returns false because the array is not empty
arrayTwo.isEmpty  //Returns true because the array is empty</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Appending to an array</h2></div></div></div><p>A static array<a class="indexterm" id="id136"/> is somewhat useful, but having the ability to add elements dynamically is what makes arrays really useful. To add an item to the end of an array, we can use the <code class="literal">append</code> method. The following example shows how to append an item to the end of an array:</p><div><pre class="programlisting">var arrayOne = [1,2]
arrayOne.append(3)  //arrayOne will now contain 1, 2 and 3</pre></div><p>Swift also allows us to use the addition assignment operator (<code class="literal">+=</code>) to append an array to another array. The following example shows how to use the addition assignment operator to append an array to the end of another array:</p><div><pre class="programlisting">var arrayOne = [1,2]
arrayOne += [3,4]  //arrayOne will now contain 1, 2, 3 and 4</pre></div><p>The way you append an element to the end of an array is really up to you. Personally, I prefer the assignment operator because, to me, it is a bit easier to read, but we will be using both in this book.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Inserting a value into an array</h2></div></div></div><p>We can<a class="indexterm" id="id137"/> insert a value into an array by using the <code class="literal">insert</code> method. The <code class="literal">insert</code> method will move all the items, starting at the specified index up one spot, to make room for the new element and then inserts the value into the specified index. The following example shows how to use the insert method to insert a new value into an array:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5]
arrayOne.insert(10, atIndex: 3) //arrayOne now contains 1, 2, 3, 10, 4 and 5</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>You cannot insert a value that is outside the current range of the array. Attempting to do so will throw an <code class="literal">Index out of range exception</code>. For example, in the preceding code, if we attempt to insert a new integer at index 10, we will receive an <code class="literal">Index out of range exception error</code> because <code class="literal">arrayOne</code> only contains five elements. The exception to this is that we are able to insert an item directly after the last element; therefore, we can insert an item at index <code class="literal">6</code>. However, it is recommended that we use the <code class="literal">append</code> function to append an item to avoid errors.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Replacing elements in an array</h2></div></div></div><p>We use<a class="indexterm" id="id138"/> the subscript syntax to replace elements in an array. Using the subscript, we pick the element of the array we wish to update and then use the assignment operator to assign a new value. The following example shows how we will replace a value in an array:</p><div><pre class="programlisting">var arrayOne = [1,2,3]
arrayOne[1] = 10  //arrayOne now contains 1,10,3</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>You cannot update a value that is outside the current range of the array. Attempting to do so will throw the same <code class="literal">Index out of range</code> exception that was thrown when we tried to insert a value outside the range of the array.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Removing elements from an array</h2></div></div></div><p>There are<a class="indexterm" id="id139"/> three methods that we can use to remove one or all the elements in an array. These methods are <code class="literal">removeLast()</code>, <code class="literal">removeAtIndex()</code>, and <code class="literal">removeAll()</code>. The following example shows how to use the three methods to remove elements from the array:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5]
arrayOne.removeLast()  //arrayOne now contains 1, 2, 3 and 4
arrayOne.removeAtIndex(2)  //arrayOne now contains 1, 2 and 4
arrayOne.removeAll()  //arrayOne is now empty</pre></div><p>The <code class="literal">removeLast()</code> and <code class="literal">removeAtIndex()</code> methods will also return the value of the element that it is <a class="indexterm" id="id140"/>removing. Therefore, if we want to know the value of the item that was removed, we can rewrite the <code class="literal">removeAtIndex</code> and <code class="literal">removedLast</code> lines to capture the value, as shown in the following example:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5]
var removed1 = arrayOne.removeLast()  //removed1 contains the value 5
var removed = arrayOne.removeAtIndex(2)  //removed contains the value 3</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Adding two arrays</h2></div></div></div><p>To create a <a class="indexterm" id="id141"/>new array by adding two arrays together, we use the addition (<code class="literal">+</code>) operator. The following example shows how to use the addition (<code class="literal">+</code>) operator to create a new array that contains all the elements of two other arrays:</p><div><pre class="programlisting">let arrayOne = [1,2]
let arrayTwo = [3,4]
var combine = arrayOne + arrayTwo //combine contains 1, 2, 3 and 4</pre></div><p>In the preceding code, <code class="literal">arrayOne</code> and <code class="literal">arrayTwo</code> are left unchanged, while the combine array contains the elements from <code class="literal">arrayOne</code>, followed by the elements from <code class="literal">arrayTwo</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec49"/>Reversing an array</h2></div></div></div><p>We can<a class="indexterm" id="id142"/> create a new array from the original array with the elements in reverse order using the <code class="literal">reverse()</code> method. The original array will remain unchanged by the <code class="literal">reverse</code> method. The following example shows how to use the <code class="literal">reverse()</code> method:</p><div><pre class="programlisting">var arrayOne = [1,2,3]
var reverse = arrayOne.reverse() //reverse contains 3,2 and 1</pre></div><p>In the preceding code, the elements of <code class="literal">arrayOne</code> are left unchanged, while the <code class="literal">reverse</code> array will contain all the elements from <code class="literal">arrayOne</code>, but in the reverse order.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec50"/>Retrieving a subarray from an array</h2></div></div></div><p>We can <a class="indexterm" id="id143"/>retrieve a <code class="literal">subarray</code> from an existing array by using the subscript syntax with a range. The following example shows how to retrieve a range of elements from an existing array:</p><div><pre class="programlisting">let arrayOne = [1,2,3,4,5]
var subArray = arrayOne[2…4] //subArray contains 3, 4 and 5</pre></div><p>The <code class="literal">…</code> operator (three periods) is known as a range operator. The range operator, in the preceding code, says<a class="indexterm" id="id144"/> I want all the elements, <code class="literal">2</code> to <code class="literal">4</code>, inclusively (included elements 2 and 4 as well as what is between them). There is another range operator, which is <code class="literal">..&lt;</code>, the same as the <code class="literal">…</code> range operator, but it excludes the last element. The following example shows how to use the <code class="literal">.&lt;</code> operator.</p><div><pre class="programlisting">let arrayOne = [1,2,3,4,5]
var subArray = arrayOne[2..&lt;4] //subArray contains 3 and 4</pre></div><p>In the preceding example, the <code class="literal">subArray</code> will contain two elements <code class="literal">3</code> and <code class="literal">4</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec51"/>Making bulk changes to an array</h2></div></div></div><p>We can use the <a class="indexterm" id="id145"/>subscript syntax with a range operator to change the values of multiple elements. The following example shows how to use the subscript syntax to change a range of elements.</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5]
arrayOne[1…2] = [12,13]//arrayOne contains 1,12,13,4 and 5</pre></div><p>In the preceding code, the elements at index <code class="literal">1</code> and <code class="literal">2</code> will be changed to number <code class="literal">12</code> and <code class="literal">13</code>. After this, when the code runs, <code class="literal">arrayOne</code> will contain <code class="literal">1</code>, <code class="literal">12</code>, <code class="literal">13</code>, <code class="literal">4</code>, and <code class="literal">5</code>.</p><p>The number of elements that you are changing in the range operator does not need to match the number of values that you are passing in. Swift makes the bulk changes—it first removes the elements defined by the range operator and then inserts the new values. The following example demonstrates this concept:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5]
arrayOne[1…3] = [12,13]
//arrayOne now contains 1, 12, 13 and 5 (four elements)</pre></div><p>In the preceding code, <code class="literal">arrayOne</code> starts with five elements. We then say that we want to replace the range of elements <code class="literal">1</code> to <code class="literal">3</code> inclusively. This causes elements <code class="literal">1</code> to <code class="literal">3</code> (three elements) to be removed from the array. We then add two elements (<code class="literal">12</code> and <code class="literal">13</code>) to the array, starting at index <code class="literal">1</code>. After this is complete, <code class="literal">arrayOne</code> will contain these four elements: <code class="literal">1</code>, <code class="literal">12</code>, <code class="literal">13</code>, and <code class="literal">5</code>. Let's see what happens if we try to add more elements than we remove:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5]
arrayOne[1...3] = [12,13,14,15]
//arrayOne now contains 1, 12, 13, 14, 15 and 5 (six elements)</pre></div><p>In the preceding code, <code class="literal">arrayOne</code> starts with five elements. We then say that we want to replace the range of elements <code class="literal">1</code> to <code class="literal">3</code> inclusively. This causes elements <code class="literal">1</code> to <code class="literal">3</code> (three elements) to be removed from the array. We then add four elements (<code class="literal">12</code>, <code class="literal">13</code>, <code class="literal">14</code>, and <code class="literal">15</code>) to the array, starting at index <code class="literal">1</code>. After this is complete, <code class="literal">arrayOne</code> will contain these six elements: <code class="literal">1</code>, <code class="literal">12</code>, <code class="literal">13</code>, <code class="literal">14</code>, <code class="literal">15</code>, and <code class="literal">5</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec52"/>Algorithms for arrays</h2></div></div></div><p>Swift arrays <a class="indexterm" id="id146"/>have several methods that take a closure as the argument. These methods transform the array and the closures affect how the array is transformed. Closures are self-contained blocks of code that can be passed around, and are similar to blocks in Objective-C and lambdas in other languages. We will discuss closures in depth in <a class="link" href="ch12.html" title="Chapter 12. Working with Closures">Chapter 12</a>, <em>Working with Closures</em>. For now, we just want to get familiar with how the algorithms work in Swift.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>sortInPlace</h3></div></div></div><p>The <a class="indexterm" id="id147"/>sortInPlace algorithm sorts the array in place. This means when the <code class="literal">sortInPlace()</code> method is used, the original array is replaced by the sorted one. The closure takes two arguments (represented by <code class="literal">$0</code> and <code class="literal">$1</code>), and it should return a Boolean value that indicates whether the first element should be placed before the second element. The following code shows how to use the sort algorithm:</p><div><pre class="programlisting">var arrayOne = [9,3,6,2,8,5]
arrayOne.sortInPlace(){ $0 &lt; $1 }
//arrayOne contains 2,3,5,6,8 and 9</pre></div><p>The preceding code will sort the array in increasing order. We can tell this because our rule will return <code class="literal">true</code> if the first number (<code class="literal">$0</code>) is less than the second number (<code class="literal">$1</code>). Therefore, when the sort algorithm begins, it compares the first two numbers (<code class="literal">9</code> and <code class="literal">3</code>) and returns <code class="literal">true</code> if the first number (<code class="literal">9</code>) is less than the second number (<code class="literal">3</code>). In our case, the rule returns <code class="literal">false</code>, so the numbers are reversed. The algorithm continues sorting, in this manner, until all of the numbers are sorted.</p><p>The preceding example sorted the array in numerically increasing order; if we wanted to reverse the order, we would reverse the arguments in the closure. The following code shows how to reverse the sort order:</p><div><pre class="programlisting">var arrayOne = [9,3,6,2,8,5]
arrayOne.sortInPlace(){ $1 &lt; $0 }
//arrayOne contains 9,8,6,5,3 and 2</pre></div><p>When we run this code, <code class="literal">arrayOne</code> will contain the elements <code class="literal">9</code>, <code class="literal">8</code>, <code class="literal">6</code>, <code class="literal">5</code>, <code class="literal">3</code>, and <code class="literal">2</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec04"/>sort</h3></div></div></div><p>While the <a class="indexterm" id="id148"/>sortInPlace algorithm sorts the array in place (replaces the original array), the <code class="literal">sort</code> algorithm does not change the original array, it instead creates a new array with the sorted elements from the original array. The following example shows how to use the sorted algorithm:</p><div><pre class="programlisting">var arrayOne = [9,3,6,2,8,5]
let sorted = arrayOne.sort(){ $0 &lt; $1 }
//sorted contains 2,3,5,6,8 and 9
//arrayOne contains 9,3,6,2,8 and 5</pre></div><p>When we run<a class="indexterm" id="id149"/> this code, <code class="literal">arrayOne</code> will contain the original unsorted array (<code class="literal">9</code>, <code class="literal">3</code>, <code class="literal">6</code>, <code class="literal">2</code>, <code class="literal">8</code>, and <code class="literal">5</code>) and the sorted array will contain the new sorted array (<code class="literal">2</code>, <code class="literal">3</code>, <code class="literal">5</code>, <code class="literal">6</code>, <code class="literal">8</code>, and <code class="literal">9</code>).</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec05"/>filter</h3></div></div></div><p>The <a class="indexterm" id="id150"/>filter algorithm will return a new array by filtering the original array. This is one of the most powerful array algorithms and may end up to be the one we use the most. If we need to retrieve a subset of an array, based on a set of rules, I recommend using this algorithm rather than trying to write your own method to filter the array. The closure takes one argument and it should return a Boolean <code class="literal">true</code> if the element should be included in the new array, as shown in the following code:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5,6,7,8,9]
let filtered = arrayFiltered.filter{$0 &gt; 3 &amp;&amp; $0 &lt; 7}
//filtered contains 4,5 and 6</pre></div><p>In the preceding code, the rule that we are passing to the algorithm returns <code class="literal">true</code> if the number is greater than <code class="literal">3</code> or less than <code class="literal">7</code>; therefore, any number that is greater than <code class="literal">3</code> or less than <code class="literal">7</code> is included in the new filtered array.</p><p>Let's take a look at another example; this one shows how we can retrieve a subset of cities that contain the letter o in their name from an array of cities:</p><div><pre class="programlisting">var city = ["Boston", "London", "Chicago", "Atlanta"]
let filtered = city.filter{$0.rangeOfString("o") != nil}
//filtered contains "Boston", "London" and "Chicago"</pre></div><p>In the preceding code, we use the <code class="literal">rangeOfString()</code> method to return <code class="literal">true</code> if the string contains the letter o. If the method returns <code class="literal">true</code>, the string is included in the filtered array.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec06"/>map</h3></div></div></div><p>The <a class="indexterm" id="id151"/>map algorithm returns a new array that contains the results of applying the rules in the closure to each element of the array. The following example shows how to use the map algorithm to divide each number by <code class="literal">10</code>:</p><div><pre class="programlisting">var arrayOne = [10, 20, 30, 40]
let applied = arrayOne.map{ $0 / 10}
//applied contains 1,2,3 and 4</pre></div><p>In the preceding code, the new array contains the numbers <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, and <code class="literal">4</code>, which is the result of dividing each element of the original array by <code class="literal">10</code>.</p><p>The new array created by the map algorithm is not required to contain the same element types as the original array; however, all the elements in the new array must be of the same type. In the following example, the original array contains integer values, but the new array <a class="indexterm" id="id152"/>created by the map algorithm contains string elements:</p><div><pre class="programlisting">var arrayOne = [1, 2, 3, 4]
let applied = arrayOne.map{ "num:\($0)"}
//applied contains "num:1", "num:2", "num:3" and "num:4"</pre></div><p>In the preceding code, we created an array of strings that appends the numbers from the original array to the <code class="literal">num:</code>string.</p></div><div><div><div><div><h3 class="title"><a id="ch03lvl3sec07"/>forEach</h3></div></div></div><p>We can use<a class="indexterm" id="id153"/> <code class="literal">forEach</code> to iterate over a sequence. The following example shows how we would do this:</p><div><pre class="programlisting">var arrayOne = [10, 20, 30, 40]
arrayOne.forEach{ print($0) }</pre></div><p>This example will print the following results to the console:</p><div><pre class="programlisting">10
20
30
40</pre></div><p>While using the <code class="literal">forEach</code> method is very easy, it does have some limitations. The recommended way to iterate over an array is to use the <code class="literal">for-in</code> loop, which we will see in the next section.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec53"/>Iterating over an array</h2></div></div></div><p>We can <a class="indexterm" id="id154"/>iterate over all elements of an array, in order, with a <code class="literal">for-in</code> loop. We will discuss the <code class="literal">for-in</code> loop in greater detail in <a class="link" href="ch04.html" title="Chapter 4. Control Flow and Functions">Chapter 4</a>, <em>Control Flow and Functions</em>. The <code class="literal">for-in</code> loop will execute one or more statements for each element of the array. The following example shows how we would iterate over the elements of an array:</p><div><pre class="programlisting">var arr = ["one", "two", "three"]
for item in arr {
    print(item)
}</pre></div><p>In the preceding example, the <code class="literal">for-in</code> loop iterates over the <code class="literal">arr</code> array and executes the <code class="literal">print(item)</code> line for each element in the array. If we run this code, it will display the following results in the console:</p><div><pre class="programlisting">one
two
three</pre></div><p>There are times when we would like to iterate over an array, as we did in the preceding example, but we would also like to know the index as well as the value of the element. To do this, we <a class="indexterm" id="id155"/>can use the <code class="literal">enumerate</code> method, which returns a tuple (see the <em>Tuples</em> section later in this chapter) for each item in the array that contains both <code class="literal">index</code> and <code class="literal">value</code> of the element. The following example shows how to use the <code class="literal">enumerate</code> function:</p><div><pre class="programlisting">var arr = ["one", "two", "three"]
for (index,value) in arr.arr.enumerate() {
    print"\(index) \(value)")
}</pre></div><p>The preceding code will display the following results in the console:</p><div><pre class="programlisting">0 one
1 two
2 three</pre></div><p>Now that we have introduced arrays in Swift, let's take a look at what a dictionary is.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Dictionaries</h1></div></div></div><p>While dictionaries<a class="indexterm" id="id156"/> are not as commonly used as arrays, they have an additional functionality that makes them incredibly powerful. A dictionary is a container that stores multiple key-value pairs, where all the keys are of the same type, and all the values are of the same type. The key is used as a unique identifier for the value. A dictionary does not guarantee the order in which the key-value pairs are stored since we look up the values by the key, rather than by the index of the value.</p><p>Dictionaries are good for storing items that map to unique identifiers, where the unique identifier should be used to retrieve the item. As an example, countries with their abbreviations are a good example of items that can be stored in a dictionary. In the following chart, we show countries with their abbreviations as key-value pairs:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Key</p>
</th><th style="text-align: left" valign="bottom">
<p>Value</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>US</p>
</td><td style="text-align: left" valign="top">
<p>United States</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>IN</p>
</td><td style="text-align: left" valign="top">
<p>India</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>UK</p>
</td><td style="text-align: left" valign="top">
<p>United Kingdom</p>
</td></tr></tbody></table></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec54"/>Creating and initializing dictionaries</h2></div></div></div><p>We can<a class="indexterm" id="id157"/> initialize <a class="indexterm" id="id158"/>a dictionary using a dictionary literal, similar to how we initialized an array with the array literal. The following example shows how to create a dictionary using the key-value pairs in the preceding chart:</p><div><pre class="programlisting">let countries = ["US":"UnitedStates","IN":"India","UK":"UnitedKingdom"]</pre></div><p>The preceding code creates an immutable dictionary that contains each of the key-value pairs in the preceding chart. Just like the array, to create a mutable dictionary, we will use the <code class="literal">var</code> keyword rather than <code class="literal">let</code>. The following example shows how to create a mutable dictionary containing the countries:</p><div><pre class="programlisting">var countries = ["US":"UnitedStates","IN":"India","UK":"United Kingdom"]</pre></div><p>In the preceding two examples, we created a dictionary where the key and value were both strings. The compiler inferred that the key and value were strings because that was the type of values we put in. If we wanted to create an empty dictionary, we would need to tell the compiler what the key and value types are. The following examples create various dictionaries with different key-value types:</p><div><pre class="programlisting">var dic1 = [String:String]()
var dic2 = [Int:String]()
var dic3 = [String:MyObject]()</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>If we want to use a custom object as the key in a dictionary, we will need to make our custom object conform to the Hashable protocol from Swift's standard library. We will discuss protocol and classes in <a class="link" href="ch05.html" title="Chapter 5. Classes and Structures">Chapter 5</a>, <em>Classes and Structures</em>, but, for now, just understand that it is possible to use custom objects as a key in a dictionary.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec55"/>Accessing dictionary values</h2></div></div></div><p>We use the <a class="indexterm" id="id159"/>subscript syntax to retrieve the value for a particular key. If the dictionary does not contain the key we are looking for, the dictionary will return <code class="literal">nil</code>; therefore, the variable returned from this lookup is an optional variable. The following example shows how to retrieve a value from a dictionary using its key in the subscript syntax:</p><div><pre class="programlisting">let countries = ["US":"United States", "IN":"India","UK":"United Kingdom"]
var name = countries["US"]</pre></div><p>In the preceding code, the variable name will contain the string, <code class="literal">United States</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec56"/>Counting key or values in a dictionary</h2></div></div></div><p>We use<a class="indexterm" id="id160"/> the <code class="literal">count</code> property of the dictionary to get the number of key-value pairs in the dictionary. The following example shows how to use the <code class="literal">count</code> property to retrieve the number <a class="indexterm" id="id161"/>of key-value pairs in the dictionary:</p><div><pre class="programlisting">let countries = ["US":"United States", "IN":"India","UK":"United Kingdom"];
var cnt = countries.count  //cnt contains 3</pre></div><p>In the preceding code, the <code class="literal">cnt</code> variable will contain the number <code class="literal">3</code> since there are three key-value pairs in the <code class="literal">countries</code> dictionary.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec57"/>Is the dictionary empty?</h2></div></div></div><p>To test <a class="indexterm" id="id162"/>whether the dictionary contains any key-value pairs at all, we can use the <code class="literal">isEmpty</code> property. The <code class="literal">isEmpty</code> property will return <code class="literal">false</code> if the dictionary contains one or more key-value pairs and <code class="literal">true</code> if it is empty. The following example shows how to use the <code class="literal">isEmpty</code> property to determine whether our dictionary contains any key-value pairs:</p><div><pre class="programlisting">let countries = ["US":"United States", "IN":"India","UK":"United Kingdom"]
var empty = countries.isEmpty</pre></div><p>In the preceding code, the <code class="literal">isEmpty</code> property is false as there are three key-value pairs in the countries dictionary.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec58"/>Updating the value of a key</h2></div></div></div><p>To update the<a class="indexterm" id="id163"/> value of a key in a dictionary, we can either use the subscript syntax or the <code class="literal">updateValue(value:, forKey:)</code> method. The <code class="literal">updateValue(value:, forKey:)</code> method has an additional feature that the subscript syntax doesn't—it returns the original value associated with the key prior to changing the value. The following example shows how to use both the subscript syntax and the <code class="literal">updateValue(value:, forKey:)</code> method to update the value of a key:</p><div><pre class="programlisting">var countries = ["US":"United States", "IN":"India","UK":"United Kingdom"]

countries["UK"] = "Great Britain"
//The value of UK is now set to "Great Britain"

var orig = countries.updateValue("Britain", forKey: "UK")
//The value of UK is now set to "Britain" and orig now contains "Great Britain"</pre></div><p>In the preceding code, we use the subscript syntax to change the value associated with the key <code class="literal">UK</code> from <code class="literal">United Kingdom</code> to <code class="literal">Great Britain</code>. The original value of <code class="literal">United Kingdom</code> was not saved prior to replacing it, so we are unable to see what the original value is. We then used the <code class="literal">updateValue(value:, forKey:)</code> method to change the value associated <a class="indexterm" id="id164"/>with the key <code class="literal">UK</code> from <code class="literal">Great Britain to Britain</code>. With the <code class="literal">updateValue(value:, forKey:)</code> method, the original value of <code class="literal">Great Britain</code> is assigned to the <code class="literal">orig</code> variable, prior to changing the value in the dictionary.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Adding a key-value pair</h2></div></div></div><p>To add a <a class="indexterm" id="id165"/>new key-value pair to a dictionary, we can use the subscript syntax or the same <code class="literal">updateValue(value:, forKey:)</code> method that we used to update the value of a key. If we use the <code class="literal">updateValue(value:, forKey:)</code> method and the key is not currently present in the dictionary, the <code class="literal">updateValue(value:, forKey:)</code> method will add a new key-value pair and return nil. The following example shows how to use the subscript syntax and also the <code class="literal">updateValue(value:, forKey:)</code> method to add a new key-value pair to a dictionary:</p><div><pre class="programlisting">var countries = ["US":"United States", "IN":"India","UK":"United Kingdom"]

countries["FR"] = "France" //The value of "FR" is set to "France"

var orig = countries.updateValue("Germany", forKey: "DE")
//The value of "DE" is set to "Germany" and orig is nil</pre></div><p>In the preceding code, the countries dictionary starts with three key-value pairs and we then add a fourth key-value pair (<code class="literal">FR/France</code>) to the dictionary using the subscript syntax. We then use the updateValue(<code class="literal">value:, forKey:</code>) method to add a fifth key-value pair (<code class="literal">DE/Germany</code>) to the dictionary. The <code class="literal">orig</code> variable is set to nil because the countries dictionary did not contain a value associated with the <code class="literal">DE</code> key.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>Removing a key-value pair</h2></div></div></div><p>There may be<a class="indexterm" id="id166"/> times when we need to remove values from a dictionary. We can do this with the subscript syntax, using the <code class="literal">removeValueForKey()</code> method or the <code class="literal">removeAll()</code> method. The <code class="literal">removeValueForKey()</code> method returns the value of the key prior to removing it. The <code class="literal">removeAll()</code> method removes all the elements from the dictionary. The following example shows how to use the subscript syntax, the <code class="literal">removeValueForKey()</code> method, and the <code class="literal">removeAll()</code> method to remove key-value pairs from a dictionary:</p><div><pre class="programlisting">var countries = ["US":"United States", "IN":"India","UK":"United Kingdom"];

countries["IN"] = nil //The "IN" key/value pair is removed

var orig = countries.removeValueForKey("UK")
//The "UK" key value pair is removed and orig contains "United Kingdom"

countries.removeAll() //Removes all key/value pairs from the countries dictionary</pre></div><p>In the<a class="indexterm" id="id167"/> preceding code, the <code class="literal">countries</code> dictionary starts off with three key-value pairs. We then set the value associated with the key <code class="literal">IN</code> to <code class="literal">nil</code>, which removes the key-value pair from the dictionary. We use the <code class="literal">removeValueForKey()</code> method to remove the key associated with the <code class="literal">UK</code> key. Prior to removing the value associated with the <code class="literal">UK</code> key, the <code class="literal">removeValueForKey()</code> method saves the value in the <code class="literal">orig</code> variable. Finally, we use the <code class="literal">removeAll()</code> method to remove all the remaining key-value pairs in the countries dictionary.</p><p>Now let's look at the Set type.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Set</h1></div></div></div><p>The <a class="indexterm" id="id168"/>Set type is a generic collection that is similar to the array type. While the array type is an ordered collection that may contain duplicate items, the Set type is an unordered collection where each item must be unique.</p><p>Similar to the key in a dictionary, the type stored in an array must conform to the Hashable protocol. This means that the type must provide a way to compute a hash value for itself. All of Swift's basic types, such as String, Double, Int and Bool, conform to the Hashable protocol and can be used in a set by default.</p><p>Let's look at how we would use the Set type.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>Initializing a set</h2></div></div></div><p>There are a<a class="indexterm" id="id169"/> couple of ways in which we can initialize a set. Just like the array and dictionary types, Swift needs to know what type of data is going to be stored in it. This means that we must either tell Swift the type of data to store in the set or initialize it with some data so that it can infer the data type.</p><p>Just like the array and dictionary types, we use the var and let keywords to declare if the set is mutable or not:</p><div><pre class="programlisting">//Initializes an empty Set of the String type
var mySet = Set&lt;String&gt;() 

//Initializes a mutable set of the String type with initial values
var mySet = Set(["one", "two", "three"])

//Creates aimmutable set of the String type.
let mySet = Set(["one", "two", "three"])</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>Inserting items into a set</h2></div></div></div><p>We use <a class="indexterm" id="id170"/>the <code class="literal">insert</code> method to insert an item into a set. If we attempt to insert an item that is already in the set, the item will be ignored and no error will be thrown. Here are some examples on how to insert items into a set:</p><div><pre class="programlisting">var mySet = Set&lt;String&gt;() 
mySet.insert("One")
mySet.insert("Two")
mySet.insert("Three")</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>The number of items in a set</h2></div></div></div><p>We <a class="indexterm" id="id171"/>can use the <code class="literal">count</code> property to determine the number of items in a Swift Set. Here is an example on how to use the <code class="literal">count</code> method:</p><div><pre class="programlisting">var mySet = Set&lt;String&gt;() 
mySet.insert("One")
mySet.insert("Two")
mySet.insert("Three")
print("\(mySet.count) items")</pre></div><p>When executed, this code will print the message <code class="literal">"Three items"</code> to the console because the set contains three items.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Checking whether a set contains an item</h2></div></div></div><p>We can very easily <a class="indexterm" id="id172"/>check to see whether a Set contains an item by using the <code class="literal">contains()</code> method, as shown here:</p><div><pre class="programlisting">var mySet = Set&lt;String&gt;() 
mySet.insert("One")
mySet.insert("Two")
mySet.insert("Three")
var contain = mySet.contains("Two")</pre></div><p>In the preceding example, the <code class="literal">contain</code> variable is set to True because the set does contain the string <code class="literal">"Two"</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>Iterating over a set</h2></div></div></div><p>We can <a class="indexterm" id="id173"/>use the <code class="literal">for</code> statement to iterate over the items in a Set. The following example shows how we would iterate through the items in a set:</p><div><pre class="programlisting">for item inmySet {
    print(item)
}</pre></div><p>The preceding example would print out each item in the set to the console.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>Removing items in a set</h2></div></div></div><p>We can remove a <a class="indexterm" id="id174"/>single item or all the items in a set. To remove a single item, we would use the <code class="literal">remove()</code> method, and to remove all the items, the <code class="literal">removeAll()</code> method. The following example shows how to remove items from a set:</p><div><pre class="programlisting">//The remove method will return and remove an item from a set
var item = mySet.remove("Two")

//The removeAll method will remove all items from a set
mySet.removeAll()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>Set operations</h2></div></div></div><p>Apple has <a class="indexterm" id="id175"/>provided four methods that we can use to construct a set from two other sets. These operations can either be performed in place, on one of the sets, or used to create a new set. These operations are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">union</code> and <code class="literal">unionInPlace</code>: These create<a class="indexterm" id="id176"/> a set with all the unique vales<a class="indexterm" id="id177"/> from both sets</li><li class="listitem" style="list-style-type: disc"><code class="literal">subtract</code> and <code class="literal">subtractInPlace</code>: These create<a class="indexterm" id="id178"/> a set with values from the first set that <a class="indexterm" id="id179"/>are not in the second set</li><li class="listitem" style="list-style-type: disc"><code class="literal">intersect</code> and <code class="literal">intersectInPlace</code>: These create a<a class="indexterm" id="id180"/> set with<a class="indexterm" id="id181"/> values that are common to both sets</li><li class="listitem" style="list-style-type: disc"><code class="literal">exclusiveOr</code> and <code class="literal">exclusiveOrInPlace</code>: These create <a class="indexterm" id="id182"/>a new <a class="indexterm" id="id183"/>set with values that are in either set but not in both sets</li></ul></div><p>Let's look at some examples and see the results we get from each of these operations. For all the set operations examples, we will be using the following two sets:</p><div><pre class="programlisting">var mySet1 = Set(["One", "Two", "Three", "abc"])
var mySet2 = Set(["abc","def","ghi", "One"])</pre></div><p>Now let's look at our examples. The first example that we will look at is using the union method. This method will take the unique values from both sets to make another set:</p><div><pre class="programlisting">var newSetUnion = mySet1.union(mySet2)</pre></div><p>The <code class="literal">newSetUnion</code> variable would contain the following values: <code class="literal">"One", "Two", "Three", "abc", "def", "ghi"</code>. Now let's look at the subtract method. This method will create a <a class="indexterm" id="id184"/>set with the values from the first set that are not in the second set:</p><div><pre class="programlisting">var newSetSubtract = mySet1.subtract(mySet2)</pre></div><p>In this example, the <code class="literal">newSetSubtract</code> variable would contain the values <code class="literal">"Two"</code> and <code class="literal">"Three"</code> because those are the only two values that are not also in the second set.</p><p>Now let's look at the intersect method. The intersect method creates a new set from the values that are common between the two sets:</p><div><pre class="programlisting">var newSetIntersect = mySet1.intersect(mySet2)</pre></div><p>In this example, the <code class="literal">newSetIntersect</code> variable will contain the values <code class="literal">"One"</code> and <code class="literal">"abc"</code> since they are the values that are common between the two sets.</p><p>Now let's look at the <code class="literal">exclusiveOr</code> method. This method will create a new set with the values that are in either set but not in both:</p><div><pre class="programlisting">//newSetExclusiveOr = {"Two", "Three", "def", "ghi"}
var newSetExclusiveOr = mySet1.exclusiveOr(mySet2)</pre></div><p>In this example, the <code class="literal">newSetExclusiveOr</code> variable will contain the values <code class="literal">"Two", "Three", "def"</code> and <code class="literal">"ghi"</code>.</p><p>These four operations (<code class="literal">union</code>, <code class="literal">subtract</code>, <code class="literal">intersect</code>, and <code class="literal">exclusiveor</code> methods) add additional functionality that is not present with arrays. Combined with the faster lookup speeds as compared to an array, the Set can be a very useful alternative when the order of the collection is not important and the objects in a collection must be unique.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Tuples</h1></div></div></div><p>Tuples group<a class="indexterm" id="id185"/> multiple values into a single compound value. Unlike arrays and dictionaries, the values in a tuple do not have to be of the same type. The following example shows how to define a tuple:</p><div><pre class="programlisting">var team = ("Boston", "Red Sox", 97, 65, 59.9)</pre></div><p>In the preceding example, we created an unnamed tuple that contains two strings, two integers, and one double. We can decompose the values from this tuple into a set of variables, as shown in the following example:</p><div><pre class="programlisting">var team = ("Boston", "Red Sox", 97, 65, 59.9)
var (city, name, wins, loses, percent) = team</pre></div><p>In the <a class="indexterm" id="id186"/>preceding code, the <code class="literal">city</code> variable will contain <code class="literal">Boston</code>, the <code class="literal">name</code> variable will contain <code class="literal">Red Sox</code>, the <code class="literal">wins</code> variable will contain <code class="literal">97</code>, the <code class="literal">loses</code> variable will contain <code class="literal">65</code>, and, finally, the <code class="literal">percent</code> variable will contain <code class="literal">0.599</code>.</p><p>We could also retrieve the values from a tuple by specifying the location of the value. The following example shows how we would retrieve the values by their location:</p><div><pre class="programlisting">var team = ("Boston", "Red Sox", 97, 65, 59.9)
var city = team.0
var name = team.1
var wins = team.2
var loses = team.3
var percent = team.4</pre></div><p>To avoid this decomposing step, we can create a named tuple. A named tuple associates a name (key) with each element of the tuple. The following example shows how to create a named tuple:</p><div><pre class="programlisting">var team = (city:"Boston", name:"Red Sox", wins:97, loses:65, percent:59.9)</pre></div><p>To access the values from a named tuple, we use a dot syntax. In the preceding code, we will access the <code class="literal">city</code> element of the tuple like this: <code class="literal">team.city</code>. In the preceding code, the <code class="literal">team.city</code> element will contain <code class="literal">Boston</code>, the <code class="literal">team.name</code> element will contain <code class="literal">Red Sox</code>, the <code class="literal">team.wins</code> element will contain <code class="literal">97</code>, the <code class="literal">team.loses</code> element will contain <code class="literal">65</code>, and, finally, the <code class="literal">team.percent</code> element will contain <code class="literal">59.9</code>.</p><p>Tuples are incredible useful and can be used for all sorts of purposes. I have found that they are very useful for replacing classes and structs that are designed to simply store data and do not contain any methods. We will learn more about classes in <a class="link" href="ch05.html" title="Chapter 5. Classes and Structures">Chapter 5</a>, <em>Classes and Structures</em>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Using Cocoa data types</h1></div></div></div><p>So far, in this <a class="indexterm" id="id187"/>chapter, we have looked at several native Swift data types, such as the string, array, and dictionary types. While using these types is definitely preferred, as part of the Objective-C interoperability, Apple has provided convenient and effective ways to work with Cocoa data types from within our Swift applications.</p><p>Some of the Cocoa and Swift data types can be used interchangeably, while others are automatically converted between Cocoa and Swift data types. Those data types that can be used interchangeably or converted are called bridged data types.</p><p>Swift also provides an overlay for working with Foundation data types. This lets us work with Foundation data types in a way that feels more like native Swift types. If we need to use these Foundation data types, we need to add the following import statement to the top of the Swift file:</p><div><pre class="programlisting">import Foundation</pre></div><p>Let's take a<a class="indexterm" id="id188"/> look at how to work with some common Cocoa data types.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>NSNumber</h2></div></div></div><p>Swift will <a class="indexterm" id="id189"/>automatically bridge certain native numeric types, such as Int, UInt, Float, Bool, and Double to an <code class="literal">NSNumber</code> object. This allows us to pass these native numeric types to arguments that expect an <code class="literal">NSNumber</code> object. This automatic bridging only works one way because an <code class="literal">NSNumber</code> object can contain various numeric types; therefore, the Swift compiler will not know which numeric type to convert the <code class="literal">NSNumber</code> into. The following examples show how to go from a native Swift Int and Double to an <code class="literal">NSNumber</code>, and how to convert it back to the Swift Int and Double. Let's take a look at the following code:</p><div><pre class="programlisting">var inum = 7    //Creates an Int
var dnum = 10.6 //Creates a Double
var insnum: NSNumber = inum  //Bridges the Int to a NSNumber
var dnsnum: NSNumber = dnum  //Bridges the Double to a NSNumber
var newint = Int(insnum)       //Creates an Int from a NSNumber
var newdouble = Double(dnsnum) //Creates a Double from a NSNumber</pre></div><p>In the preceding code, Swift automatically converts the <code class="literal">inum</code> and <code class="literal">dnum</code> to <code class="literal">NSNumber</code> objects without any typecasting; however, when we try to convert the <code class="literal">NSNumber</code> objects back to <code class="literal">Int</code> or <code class="literal">Double</code> types of Swift, we need to typecast the <code class="literal">NSNumber</code> objects to tell Swift what type of numbers we are converting into.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>NSString</h2></div></div></div><p>Swift will <a class="indexterm" id="id190"/>automatically bridge its native <code class="literal">String</code> type to a <code class="literal">NSString</code> type; however, it will not automatically bridge an <code class="literal">NSString</code> object to the native String type. This allows us to pass the native string type to arguments that expect an <code class="literal">NSString</code> object. Therefore, when we use mix and match to integrate the Objective-C APIs with our Swift project, it automatically converts <code class="literal">String</code> types to the <code class="literal">NSString</code> objects when needed.</p><p>This automatic bridging allows us to call the <code class="literal">NSString</code> methods on our Swift strings. Swift automatically converts the string to an <code class="literal">NSString</code> object and calls the method. The following example shows how to convert our string value to a C string using the <code class="literal">cStringUsingEncoding()</code> method that comes from the <code class="literal">NSString</code> type:</p><div><pre class="programlisting">var str = "Hello World from Swift"
str.cStringUsingEncoding(NSUTF8StringEncoding)</pre></div><p>To convert<a class="indexterm" id="id191"/> an <code class="literal">NSString</code> object to a string type, we will use the <code class="literal">as</code> keyword. Since an <code class="literal">NSString</code> object can always be converted to a string type, we do not need to use the optional version of this typecasting operator (<code class="literal">as?</code>). The following example shows how to convert an <code class="literal">NSString</code> object to a string type:</p><div><pre class="programlisting">func testFunc(test: String) {
    print(test)
}
var nsstr: NSString = "abc"
testFunc(nsstr as String)</pre></div><p>In the next example, we convert an <code class="literal">NSString</code> object to a native Swift string type, and then call the <code class="literal">toInt()</code> method, from the Swift string type, to convert the string to an integer, as shown in the following code:</p><div><pre class="programlisting">var nsstr: NSString = "1234"
var num = Int(nsstr as String)//num contains the number 1234</pre></div><p>In the preceding code, the <code class="literal">num</code> variable will contain the number <code class="literal">1234</code> and not the string <code class="literal">1234</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>NSArray</h2></div></div></div><p>Swift will a<a class="indexterm" id="id192"/>utomatically bridge between the <code class="literal">NSArray</code> class and the Swift native array type. Since the elements of an <code class="literal">NSArray</code> object are not required to be of the same type, when we bridge from an <code class="literal">NSArray</code> object to a Swift array, the elements of the Swift array are set to the <code class="literal">[AnyObject]</code> type. The <code class="literal">[AnyObject]</code> type is an object that is an instance of an Objective-C or Swift class or can be bridged to one.</p><p>The following example shows how we can create an <code class="literal">NSArray</code> object in Swift that contains both string and Int types and then creates a Swift array from that <code class="literal">NSArray</code> object:</p><div><pre class="programlisting">var nsarr: NSArray = ["HI","There", 1,2]
var arr = nsarr as? [AnyObject]</pre></div><p>In the preceding code, <code class="literal">nsarr: NSArray</code> contains four elements—<code class="literal">HI</code>, <code class="literal">There</code>, <code class="literal">1</code>, and <code class="literal">2</code>. In <code class="literal">nsarrNSArray</code>, two of the elements are string types and two are Int types. When we convert the nsarr: <code class="literal">NSArray</code> to a Swift array, the <code class="literal">arr</code> array becomes an array of <code class="literal">AnyObject</code> types.</p><p>If the <code class="literal">NSArray</code> contains a specific object type, once it is bridged to a Swift array, we can downcast the Swift array of <code class="literal">[AnyObject]</code> to a Swift array of the specific object types. The only catch to this downcasting is if any element of the array is not of the object type specified, the downcasting will fail and the new array will be set to nil. The following example shows how to downcast an array:</p><div><pre class="programlisting">var nsarr: NSArray = ["HI","There"]
var arr = nsarr as [AnyObject]
var newarr = arr as? [String]</pre></div><p>In the <a class="indexterm" id="id193"/>preceding example, <code class="literal">newarr</code> will be an array of strings that contains two elements. Now, let's change the original <code class="literal">NSArray</code> to include two integers as well as the two strings. The new code will now look similar to this:</p><div><pre class="programlisting">var nsarr: NSArray = ["HI","There", 1, 2]
var arr = nsarr as [AnyObject]
var newarr = arr as? [String]</pre></div><p>Since the original <code class="literal">NSArray</code> defines an array of both strings and integers, when we attempt to downcast the Swift array from an array of <code class="literal">[AnyObject]</code> to an array of string, the downcasting fails and the <code class="literal">newarr</code> variable is set to nil.</p><p>When we use the <code class="literal">as?</code> keyword to cast an <code class="literal">NSArray</code> object as an array type, it is recommended that we use optional binding since it is possible to receive a nil value. The following example illustrates how to do this cast with optional binding:</p><div><pre class="programlisting">var nsarr: NSArray = ["HI","There", 1,2]
if let arr = nsarr as? [String] {
    // arr is a native Swift array type.
}</pre></div><p>Now let's look at the <code class="literal">NSDictionary</code> object and how we can use it within our Swift code.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>NSDictionary</h2></div></div></div><p>We use the <code class="literal">as</code> and <code class="literal">as?</code> keywords to <a class="indexterm" id="id194"/>convert between an <code class="literal">NSDictionary</code> object and a Swift dictionary type. The following example shows how to do this:</p><div><pre class="programlisting">var nsdic: NSDictionary = ["one":"HI", "two":"There"]
if let dic = nsdic as? [String: String] {
    var newDic = dicasNSDictionary
}</pre></div><p>In the previous example, we create an <code class="literal">NSDictionary</code> object that contains two key-value pairs. All of the keys and values in this <code class="literal">NSDictionary</code> object are String types. In the second line, the <code class="literal">nsdic2as? [String: String]</code> converts the <code class="literal">NSDictionary</code> object to a dictionary type where both the keys and the values are String types. We then convert the dictionary type back to an <code class="literal">NSDictionaryobject</code> using the <code class="literal">as</code> keyword.</p><p>In the previous example, we used optional binding when we converted the <code class="literal">NSDictionary</code> object to a dictionary type because if any of the values in the <code class="literal">NSDictionary</code> object were not of the String type, the conversion would have failed. The following example illustrates this:</p><div><pre class="programlisting">var nsdic2: NSDictionary = ["one":"HI", "two":2]
if let dic2 = nsdic2 as? [String:String] {
    // Would not reach this because
    // conversion failed
}</pre></div><p>In this example, the<a class="indexterm" id="id195"/> conversion fails because one of the values is an integer type and not a String type. When we do the conversion from an <code class="literal">NSDictionary</code> object to a Swift dictionary we use the <code class="literal">as?</code> keyword because the conversion may fail, but when we convert from a Swift dictionary to an <code class="literal">NSDictionary</code> object, we use the <code class="literal">as</code> keyword because the conversion is always successful.</p><p>Now let's look at how we would use Foundation data types with Swift.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Foundation data types</h1></div></div></div><p>When using <a class="indexterm" id="id196"/>Foundation data types, Swift provides an overlay that makes interacting with them feel like they are native Swift types. We use this overlay to interact with Foundation types, such as <code class="literal">CGSize</code> and <code class="literal">CGRect</code> for iOS applications (<code class="literal">NSSize</code> and <code class="literal">NSRect</code> for OS X applications). When developing iOS or OS X applications, we will interact with Foundation data types on a regular basis, so it is good to see this overlay in action.</p><p>Let's look at how to initialize some Foundation data types. The following example defines <code class="literal">NSRange</code>, <code class="literal">CGRect</code>, and <code class="literal">NSSize</code>:</p><div><pre class="programlisting">var range = NSRange(location: 3, length: 5)
var rect = CGRect(x: 10, y: 10, width: 20, height: 20)
var size = NSSize(width: 20, height: 40)</pre></div><p>The overlay also lets us access the properties and functions in a way that feels like native Swift types. The following example shows us how to access the properties and functions:</p><div><pre class="programlisting">var rect = CGRect(x: 10, y: 10, width: 20, height: 20)
rect.origin.x = 20 
//Changes the X value from 10 to 20

var rectMaxY = rect.maxY
//rectMaxY contains 30 (value of y + value of height)

var validRect = rect.isEmpty
//validRect contains false because rect is valid.</pre></div><p>In the preceding code, we initialize a <code class="literal">CGRect</code> type. We then change the property of <code class="literal">x</code> from <code class="literal">10</code> to <code class="literal">20</code>, retrieve the value of the <code class="literal">maxY</code> property, and check the <code class="literal">isEmpty</code> property to see whether we have a valid <code class="literal">CGRect</code> type.</p><p>We just barely<a class="indexterm" id="id197"/> scratched the surface of the interoperability between Swift and Objective-C. We will discuss this interoperability in depth in <a class="link" href="ch13.html" title="Chapter 13. Using Mix and Match">Chapter 13</a>, <em>Using Mix and Match</em>, later in this book.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we covered Swift collections, tuples, Foundation, and Cocoa data types. Having a good understanding of the native collection types of Swift is essential to architect and develop applications in Swift since all but the very basic applications use collections to store data in memory.</p><p>At the time of writing this book, Swift is exclusively used for developing applications in an Apple (iOS or OS X) environment, so it is essential to understand how Swift interacts with Cocoa and Foundation types. While we briefly covered this subject in this chapter, we will look at this interaction more in depth in <a class="link" href="ch13.html" title="Chapter 13. Using Mix and Match">Chapter 13</a>, <em>Using Mix and Match</em>, later in this book.</p></div></body></html>