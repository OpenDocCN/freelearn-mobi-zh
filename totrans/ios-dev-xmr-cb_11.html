<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Graphics and Animation"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Graphics and Animation</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Animating views</li><li class="listitem" style="list-style-type: disc">Transforming views</li><li class="listitem" style="list-style-type: disc">Animating images</li><li class="listitem" style="list-style-type: disc">Animating layers</li><li class="listitem" style="list-style-type: disc">Drawing lines and curves</li><li class="listitem" style="list-style-type: disc">Drawing shapes</li><li class="listitem" style="list-style-type: disc">Drawing text</li><li class="listitem" style="list-style-type: disc">A simple drawing app</li><li class="listitem" style="list-style-type: disc">Creating an image context</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec96"/>Introduction</h1></div></div></div><p>In this chapter, we are going to discuss custom drawing and animations. The iOS SDK contains two very useful frameworks for these tasks: Core Graphics and Core Animation.</p><p>These two frameworks simplify the process of animating UI elements and drawing 2D graphics on them. The effective usage of these two frameworks will make a difference between a dull and stunning app. After all, these two frameworks play a very important role in making the iOS platform unique in its kind.</p><p>We will learn how to provide simple or even more complicated animations for controls to provide a unique user experience. We will also see how to custom draw lines, curves, shapes, and text on the screen. Finally, with all the examples provided, we will create two drawing apps.</p></div></div>
<div class="section" title="Animating views"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec97"/>Animating views</h1></div></div></div><p>In this recipe, we will learn how to take advantage of UIKit animations to move a <code class="literal">UILabel</code> on the screen.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec388"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">ViewAnimationApp</code>. Add a label and button on the view of the controller.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec389"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Enter the<a id="id658" class="indexterm"/> following code in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.lblOutput.BackgroundColor = UIColor.Green;
this.btnAnimate.TouchUpInside += (sender, e) =&gt; {
  RectangleF labelFrame = this.lblOutput.Frame;
  labelFrame.Y = 380f;
  UIView.Animate(1d, 0d, UIViewAnimationOptions.CurveEaseInOut, 
    () =&gt; this.lblOutput.Frame = labelFrame, 
    () =&gt; {
      this.lblOutput.Text = "Animation ended!";
      this.lblOutput.BackgroundColor = UIColor.Red;
    });
};</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap on the <span class="strong"><strong>Animate!</strong></span> button and watch the label transitioning to the lower part of the view.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec390"/>How it works...</h2></div></div></div><p>The <code class="literal">UIView</code> class contains a number of various static methods that provide animation functionality. In this example, we simply change the position of a label with an animation.</p><p>To animate the change of the view, we call the static <code class="literal">UIView.Animate</code> method as follows:</p><div class="informalexample"><pre class="programlisting">UIView.Animate(1d, 0d, UIViewAnimationOptions.CurveEaseInOut, 
    () =&gt; this.lblOutput.Frame = labelFrame, 
    () =&gt; {
      this.lblOutput.Text = "Animation ended!";
      this.lblOutput.BackgroundColor = UIColor.Red;
    });</pre></div><p>The following list explains the parameters of the <code class="literal">UIView.Animate</code> method, individually:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Duration</strong></span>: This specifies the duration of the animation in seconds.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Delay</strong></span>: This indicates the number of seconds before the animation starts. Set it to zero for the animation to start immediately.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Options</strong></span>: This includes the various options for animation. In this example, we pass <code class="literal">UIViewAnimationOptions.CurveEaseInOut</code>, which applies an easing curve to the animation.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Animation</strong></span>: This is an <code class="literal">NSAction</code> delegate with the changes that will be animated. In this example, we set the modified frame to the label as follows:<div class="informalexample"><pre class="programlisting">() =&gt; this.lblOutput.Frame = labelFrame,</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Completion</strong></span>: This is an <code class="literal">NSAction</code> delegate, which will be called after the animation is complete.</li></ul></div><p>We can <a id="id659" class="indexterm"/>combine multiple <code class="literal">UIViewAnimationOptions</code> values. For example, if we wanted the animation to repeat indefinitely, we would pass <code class="literal">UIViewAnimationOptions.CurveEaseInOut | UIViewAnimationOptions.Repeat</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec391"/>There's more...</h2></div></div></div><p>Xamarin.iOS also offers an asynchronous method for <code class="literal">UIView</code> animations. This method is as follows:</p><div class="informalexample"><pre class="programlisting">await UIView.AnimateAsync(1, () =&gt; this.lblOutput.Frame = labelFrame);</pre></div><p>However, there are no <code class="literal">delay</code> and <code class="literal">options</code> parameters with the asynchronous method.</p><div class="section" title="Animatable properties"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec97"/>Animatable properties</h3></div></div></div><p>UIKit animations <a id="id660" class="indexterm"/>support a specific set of <code class="literal">UIView</code> properties. These properties are called <span class="strong"><strong>animatable</strong></span> properties. Following is a list of <code class="literal">UIView</code> properties that can be animated:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Frame</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Bounds</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Center</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Transform</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Alpha</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">BackgroundColor</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ContentStretch</code></li></ul></div></div></div></div>
<div class="section" title="Transforming views"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec98"/>Transforming views</h1></div></div></div><p>In this recipe, we will rotate a <code class="literal">UILabel</code> by applying a transformation. Furthermore, the rotation will be <a id="id661" class="indexterm"/>animated.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec392"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">TransformViewApp</code>. Add a label and a button on the controller.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec393"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">MonoTouch.CoreGraphics</code> namespace in the <code class="literal">TransformViewAppViewController.cs</code> file as follows:<div class="informalexample"><pre class="programlisting">using MonoTouch.CoreGraphics;</pre></div></li><li class="listitem">Enter the following <code class="literal">ViewDidLoad</code> method in the <code class="literal">TransformViewAppViewController</code> class:<div class="informalexample"><pre class="programlisting">private double rotationAngle;
public override void ViewDidLoad ()
{
  base.ViewDidLoad ();
  this.btnRotate.TouchUpInside += async (sender, e) =&gt; {
    this.rotationAngle += 90;
    CGAffineTransform rotation = 
    CGAffineTransform.MakeRotation((float)this.DegreesToRadians(this.rotationAngle));
    await UIView.AnimateAsync(0.5d, () =&gt; this.lblOutput.Transform = rotation);
    this.lblOutput.Text = string.Format("Rotated to {0} degrees.", this.rotationAngle);
    if (this.rotationAngle &gt;= 360) {
      this.rotationAngle = 0;
      this.lblOutput.Transform = CGAffineTransform.MakeIdentity();
    }
  };
}</pre></div></li><li class="listitem">Add the following method:<div class="informalexample"><pre class="programlisting">public double DegreesToRadians(double degrees)
{
  return (degrees * Math.PI / 180);
}</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap the button and watch the label rotate. The following screenshot displays that the label rotated 270 degrees:<div class="mediaobject"><img src="graphics/8924OT_11_01.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec394"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.CoreGraphics</code> namespace is a wrapper around the <code class="literal">CoreGraphics</code> framework. This <a id="id662" class="indexterm"/>framework is the basic graphics framework of iOS.</p><p>To rotate a view, we need a transformation object that will be applied to the view through its <code class="literal">Transform</code> property as follows:</p><div class="informalexample"><pre class="programlisting">CGAffineTransform rotation = CGAffineTransform.MakeRotation((float)this.DegreesToRadians(this.rotationAngle));</pre></div><p>The transformation object is an instance of the <code class="literal">CGAffineTransform</code> class and is initialized through the <code class="literal">MakeRotation</code> static method. This method accepts a float value of the angle of rotation we want to be applied, in radians. The <code class="literal">DegreesToRadians</code> method can be used to convert degrees to radians. After creating the transformation object, we assign it to the label's <code class="literal">Transform</code> property inside the animation handler as follows:</p><div class="informalexample"><pre class="programlisting">await UIView.AnimateAsync(0.5d, () =&gt; this.lblOutput.Transform = rotation);</pre></div><p>Note that we need to increment the rotation angle each time the button is pressed, because the transformation we apply is not being autoincremented. If we apply another rotational transformation object with the same angle, there will be no effect since it is basically the same transformation.</p><p>When the label has been rotated to a full circle (360 degrees), we reset the <code class="literal">rotationAngle</code> value and the transformation object as follows:</p><div class="informalexample"><pre class="programlisting">this.rotationAngle = 0;
this.lblOutput.Transform = CGAffineTransform.MakeIdentity();</pre></div><p>The <code class="literal">MakeIdentity</code> static method creates an identity transformation object, which is the default<a id="id663" class="indexterm"/> transformation of all views, before applying transformation objects to them.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec395"/>There's more...</h2></div></div></div><p>The <code class="literal">CGAffineTransform</code> class contains various static methods for creating transformation objects. These are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">CGAffineTransformInvert</code>: This inverts a current transformation and returns the result</li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeIdentity</code>: This creates an identity transformation</li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeRotation</code>: This creates a rotation transformation</li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeScale</code>: This creates a scaling transformation</li><li class="listitem" style="list-style-type: disc"><code class="literal">MakeTranslation</code>: This creates a translation transformation</li><li class="listitem" style="list-style-type: disc"><code class="literal">Multiply</code>: This multiplies two transformations and returns the result</li></ul></div><div class="section" title="Transformation and Frame"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec98"/>Transformation and Frame</h3></div></div></div><p>After applying transformations on a view, its <code class="literal">Frame</code> property must not be taken into account, as its <a id="id664" class="indexterm"/>value will be undefined. If there is a need for altering the view's size or position after a transformation has been applied, use the <code class="literal">Bounds</code> and <code class="literal">Center</code> properties, respectively.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec396"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Animating views</em></span> and <span class="emphasis"><em>Animating layers</em></span> recipes</li></ul></div></div></div>
<div class="section" title="Animating images"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec99"/>Animating images</h1></div></div></div><p>In this<a id="id665" class="indexterm"/> recipe, we will create a simple slideshow of images using the built-in animation feature of <code class="literal">UIImageView</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec397"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">ImageAnimationApp</code>. Add a <code class="literal">UIImageView</code> and two buttons on the controller. The sample <a id="id666" class="indexterm"/>project for this task contains three images. Add two or more images to the project and make sure that their <span class="strong"><strong>Build Action</strong></span> is set to <span class="strong"><strong>Content</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec398"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Enter the following code in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.imgView.ContentMode = UIViewContentMode.ScaleAspectFit;
this.imgView.AnimationImages = new UIImage[] {
  UIImage.FromFile("Kastoria.jpg"),
  UIImage.FromFile("Parga02.jpg"),
  UIImage.FromFile("Toroni.jpg")
};
this.imgView.AnimationDuration = 3;
this.imgView.AnimationRepeatCount = 10;
this.btnStart.TouchUpInside += (sender, e) =&gt; {
  if (!this.imgView.IsAnimating) {
    this.imgView.StartAnimating();
  }
};
this.btnStop.TouchUpInside += (sender, e) =&gt; {
  if (this.imgView.IsAnimating) {
    this.imgView.StopAnimating();
  }
};</pre></div></li><li class="listitem">Compile and run the app on the simulator. Tap the <span class="strong"><strong>Start animating</strong></span> button to start the animation.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec399"/>How it works...</h2></div></div></div><p>The <code class="literal">UIImageView</code> class can accept an array of <code class="literal">UIImage</code> objects and automatically display them in a sequence.</p><p>To load the images that the view will animate, assign an array of the images to its <code class="literal">AnimationImages</code> property as follows:</p><div class="informalexample"><pre class="programlisting">this.imageView.AnimationImages = new UIImage[] {
  UIImage.FromFile("Kastoria.jpg"),
  UIImage.FromFile("Parga02.jpg"),
  UIImage.FromFile("Toroni.jpg")
};</pre></div><p>The sequence in which the images will be displayed is defined by their order in the array. After setting the images that will be animated, we set the duration of the animation in seconds and the number of times it will occur as follows:</p><div class="informalexample"><pre class="programlisting">this.imageView.AnimationDuration = 3;
this.imageView.AnimationRepeatCount = 10;</pre></div><p>To start or <a id="id667" class="indexterm"/>stop the animation, call the <code class="literal">StartAnimating</code> or <code class="literal">StopAnimating</code> methods, respectively.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec400"/>There's more...</h2></div></div></div><p>There is no relation between the <code class="literal">AnimationImages</code> and <code class="literal">Image</code> properties of the <code class="literal">UIImageView</code> class. The image set to the <code class="literal">Image</code> property of the <code class="literal">UIImageView</code> class will not be displayed while the animation takes place.</p><div class="section" title="Checking for animation"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec99"/>Checking for animation</h3></div></div></div><p>To determine if an<a id="id668" class="indexterm"/> animation is taking place, check the <code class="literal">IsAnimating</code> property of <code class="literal">UIImageView</code>.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec401"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Animating views</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Displaying images</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. User Interface – Views">Chapter 2</a>, <span class="emphasis"><em>User Interface – Views</em></span></li></ul></div></div></div>
<div class="section" title="Animating layers"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec100"/>Animating layers</h1></div></div></div><p>In this recipe, we will learn how to use the Core Animation framework to copy a <code class="literal">UILabel</code> on the <a id="id669" class="indexterm"/>screen by animating its layer.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec402"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">LayerAnimation</code>. Add two labels and a button on the controller. Set the text and background color for the first label and a different background color for the second label.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec403"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">MonoTouch.CoreAnimation</code> namespace in the <code class="literal">LayerAnimationViewController.cs</code> file as follows:<div class="informalexample"><pre class="programlisting">using MonoTouch.CoreAnimation;</pre></div></li><li class="listitem">Add a field of the <code class="literal">CALayer</code> type in the class as follows:<div class="informalexample"><pre class="programlisting">private CALayer copyLayer;</pre></div></li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method:<div class="informalexample"><pre class="programlisting">this.btnCopy.TouchUpInside += (s, e) =&gt; {
  this.lblTarget.Text = string.Empty;
  this.lblTarget.BackgroundColor = UIColor.Blue;
  this.copyLayer = new CALayer();
  this.copyLayer.Frame = this.lblSource.Frame;
  this.copyLayer.Contents = this.lblSource.Layer.Contents;
  this.View.Layer.AddSublayer(this.copyLayer);
  CABasicAnimation positionAnimation = CABasicAnimation.FromKeyPath("position");
  positionAnimation.To = NSValue.FromPointF(this.lblTarget.Center);
  positionAnimation.Duration = 1;
  positionAnimation.RemovedOnCompletion = true;
  positionAnimation.TimingFunction = CAMediaTimingFunction.FromName(CAMediaTimingFunction.EaseInEaseOut);
  positionAnimation.AnimationStopped += delegate {
    this.lblTarget.BackgroundColor = this.lblSource.BackgroundColor;
    this.lblTarget.Text = this.lblSource.Text;
    this.lblTarget.TextColor = this.lblSource.TextColor;
   this.copyLayer.RemoveFromSuperLayer();
  } ;
  CABasicAnimation sizeAnimation = CABasicAnimation.FromKeyPath("bounds");
  sizeAnimation.To = NSValue.FromRectangleF(new RectangleF(0f, 0f, this.lblSource.Bounds.Width * 2f, this.lblSource.Bounds.Height * 2));
  sizeAnimation.Duration = positionAnimation.Duration / 2;
  sizeAnimation.RemovedOnCompletion = true;
  sizeAnimation.AutoReverses = true;
  this.copyLayer.AddAnimation(positionAnimation, "PositionAnimation");
this.copyLayer.AddAnimation(sizeAnimation, "SizeAnimation");
} ;</pre></div></li><li class="listitem">Compile and<a id="id670" class="indexterm"/> run the app on the simulator. Tap the <span class="strong"><strong>Copy label</strong></span> button to copy the contents of the first label to the second label, with animation. The following screenshot was captured while the process of copying was taking place:<div class="mediaobject"><img src="graphics/8924OT_11_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec404"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.CoreAnimation</code> namespace is a wrapper around the Core Animation framework.</p><p>Every view <a id="id671" class="indexterm"/>has a <code class="literal">Layer</code> property, which returns the view's <code class="literal">CALayer</code> object. In this task, we are creating an animation that graphically displays the contents of the label that are being copied from one label to another.</p><p>Instead of creating another label and moving it with a <code class="literal">UIView</code> animation, we will create a layer and move that instead. We create the layer by setting its <code class="literal">Frame</code> and <code class="literal">Contents</code> property; the latter is set from the source label's layer. We then add the layer to the main view's layer with the <code class="literal">AddSublayer</code> method. After this point, the main view contains a layer that displays the same contents and is on top of the source label. We will do all this with the help of the following code:</p><div class="informalexample"><pre class="programlisting">  this.copyLayer = new CALayer();
  this.copyLayer.Frame = this.lblSource.Frame;
  this.copyLayer.Contents = this.lblSource.Layer.Contents;
  this.View.Layer.AddSublayer(this.copyLayer);</pre></div><p>To animate the transition from the source label to the target label, we will use the <code class="literal">CABasicAnimation</code> class. The highlighted part of the code in step 3 shows how to initialize and set up the instances of the class. The <code class="literal">FromKeyPath</code> static method creates a new instance, accepting the name of the layer's property as a parameter; this name will be animated. The <code class="literal">To</code> property represents the value to which the property will be animated. The <code class="literal">Duration</code> property represents the duration of the animation in seconds, while the <code class="literal">RemovedOnCompletion</code> property declares that the animation object should be removed from the<a id="id672" class="indexterm"/> layer when the animation finishes. The <code class="literal">TimingFunction</code> property sets the behavior of the animation. The <code class="literal">AnimationStopped</code> event is triggered when the animation finishes. Inside the handler we assign to it, we set the contents of the source label to the target label, thus completing the copy. The <code class="literal">AutoReverses</code> property states that when the value of the <code class="literal">To</code> property has been reached, the animation should be reversed. It is this property that gives the effect of the label getting bigger and subsequently smaller when it reaches its final position.</p><p>The animations start when they are added to the layer as follows:</p><div class="informalexample"><pre class="programlisting">this.copyLayer.AddAnimation(positionAnimation, "PositionAnimation");
this.copyLayer.AddAnimation(sizeAnimation, "SizeAnimation");</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec405"/>There's more...</h2></div></div></div><p>A list of strings that the <code class="literal">FromKeyPath</code> method accepts can be found at <a class="ulink" href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2">https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/CoreAnimation_guide/Key-ValueCodingExtensions/Key-ValueCodingExtensions.html#//apple_ref/doc/uid/TP40004514-CH12-SW2</a>.</p><p>Apart from the <code class="literal">To</code> property, the <code class="literal">CABasicAnimation</code> class has two more properties for defining the animation: <code class="literal">From</code> and <code class="literal">By</code>. They are all of the <code class="literal">NSObject</code> type, but the actual values that should be assigned to them should be of the <code class="literal">NSValue</code> type. The <code class="literal">NSValue</code> class contains various static methods for creating instances of it.</p><div class="section" title="Layers"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec100"/>Layers</h3></div></div></div><p>Layers <a id="id673" class="indexterm"/>are very powerful and efficient objects that can be used for both drawing and animations. Using layers to perform animations on views, instead of the actual views themselves, is strongly suggested.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec406"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Animating views</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Drawing lines and curves"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec101"/>Drawing lines and curves</h1></div></div></div><p>In this recipe, we<a id="id674" class="indexterm"/> will implement custom drawing to draw two lines <a id="id675" class="indexterm"/>on a <code class="literal">UIView</code> class.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec407"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">DrawLineApp</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec408"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new class to the project and name it <code class="literal">DrawingView</code>. Derive it from <code class="literal">UIView</code> as follows:<div class="informalexample"><pre class="programlisting">public class DrawingView : UIView</pre></div></li><li class="listitem">Add the following <code class="literal">using</code> directives in the <code class="literal">DrawingView.cs</code> file:<div class="informalexample"><pre class="programlisting">using MonoTouch.CoreGraphics;
using MonoTouch.UIKit;
using System.Drawing;</pre></div></li><li class="listitem">Add the following constructor to the class:<div class="informalexample"><pre class="programlisting">public DrawingView(RectangleF frame) : base(frame) {}</pre></div></li><li class="listitem">Override the <code class="literal">Draw</code> method of <code class="literal">UIView</code> and implement it with the following code:<div class="informalexample"><pre class="programlisting">public override void Draw (RectangleF rect)
{
  base.Draw (rect);
  Console.WriteLine("DrawingView draw!");
  CGContext context = UIGraphics.GetCurrentContext();
  context.SetLineWidth(5f);
  context.SetStrokeColorWithColor(UIColor.Green.CGColor);
  context.AddLines(new PointF[] { 
    new PointF(0f, this.Bounds.Height),
    new PointF(this.Bounds.Width, 0f)
  } );
  context.StrokePath();
  context.SetStrokeColorWithColor(UIColor.Red.CGColor);
  context.MoveTo(0, this.Bounds.Height);
  context.AddCurveToPoint(0f, this.Bounds.Height, 50f, this.Bounds.Height / 2f, this.Bounds.Width, 0f);
  context.StrokePath();
}</pre></div></li><li class="listitem">In the <code class="literal">ViewDidLoad</code> override of <code class="literal">DrawLineAppViewController</code>, initialize and add the view as follows:<div class="informalexample"><pre class="programlisting">DrawingView drawingView = new DrawingView(new RectangleF(0f, 20f, this.View.Bounds.Width, this.View.Bounds.Height));
drawingView.BackgroundColor = UIColor.Gray;
this.View.AddSubview(drawingView);</pre></div></li><li class="listitem">Compile and run the app on the simulator. The result should be similar to the one <a id="id676" class="indexterm"/>shown<a id="id677" class="indexterm"/> in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_11_03.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec409"/>How it works...</h2></div></div></div><p>The <code class="literal">MonoTouch.CoreGraphics</code> namespace is a wrapper around the native Core Graphics framework. The Core Graphics framework contains the necessary objects for custom drawing on views.</p><p>To draw on a view, we have to override its <code class="literal">Draw(RectangleF)</code> method as follows:</p><div class="informalexample"><pre class="programlisting">public override void Draw (RectangleF rect)</pre></div><p>Inside <a id="id678" class="indexterm"/>the <code class="literal">Draw</code> method, we need an instance of the current graphics <a id="id679" class="indexterm"/>context as follows:</p><div class="informalexample"><pre class="programlisting">CGContext context = UIGraphics.GetCurrentContext();</pre></div><p>A graphics context is represented by the <code class="literal">CGContext</code> class. The <code class="literal">UIGraphics.GetCurrentContext</code> static method returns an instance of the current context.</p><p>The <code class="literal">CGContext</code> class contains various methods that allow us to draw on the view. We need to set the line width, the color, and then add the type of drawing as follows:</p><div class="informalexample"><pre class="programlisting">context.SetLineWidth(5f);
context.SetStrokeColorWithColor(UIColor.Green.CGColor);
context.AddLines(new PointF[] { 
  new PointF(0f, this.Bounds.Height),
  new PointF(this.Bounds.Width, 0f)
} );</pre></div><p>To add a line, we use the <code class="literal">AddLines</code> method that accepts an array of <code class="literal">PointF</code> structs, containing the start and end points of each line. Just adding the lines to the context is not enough. To present the drawing on the view, we call the <code class="literal">StrokePath</code> method as follows:</p><div class="informalexample"><pre class="programlisting">context.StrokePath();</pre></div><p>To add another item to the drawing, we repeat the steps accordingly. The <code class="literal">MoveTo</code> method moves the current point so that the additional item will have a starting point for the curve.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec410"/>There's more...</h2></div></div></div><p>The <code class="literal">Draw</code> method is being called by the runtime when it needs to draw the contents of a view. We can only get the instance of the current graphics context inside the <code class="literal">Draw</code> method. We should not call it directly, since the <code class="literal">UIGraphics.GetCurrentContext</code> method will return <code class="literal">null</code> if we do. If we need to force the runtime to call the <code class="literal">Draw</code> method, we need to call <code class="literal">SetNeedsDisplay()</code>. Care should be taken when calling it, since drawing operations are expensive in terms of CPU usage.</p><p>When there is no need for causing the entire view area to be redrawn, we can call the <code class="literal">SetNeedsDisplayInRect</code> method, passing a <code class="literal">RectangleF</code> object in the coordinate system of the view area that we want to update.</p><div class="section" title="Graphics context on a UIImageView class"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec101"/>Graphics context on a UIImageView class</h3></div></div></div><p>The current graphics context<a id="id680" class="indexterm"/> of a <code class="literal">UIImageView</code> object is reserved for drawing the contents of the image. Calling <code class="literal">SetNeedsDisplay</code> on a custom view deriving from <code class="literal">UIImageView</code> has the same effect as calling the <code class="literal">Draw</code> method directly. If we need to draw on a custom image view, we have to either add another view on top of it and draw on that or draw on a custom layer and add it to the view's main layer.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec411"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Drawing text</em></span> recipe</li><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Creating a custom view</em></span> recipe in <a class="link" href="ch02.html" title="Chapter 2. User Interface – Views">Chapter 2</a>, <span class="emphasis"><em>User Interfaces – Views</em></span></li></ul></div></div></div>
<div class="section" title="Drawing shapes"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec102"/>Drawing shapes</h1></div></div></div><p>Following the <a id="id681" class="indexterm"/>example from the previous recipe, we will draw a circle and square on the screen.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec412"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">DrawShapeApp</code>. Add a custom view to the project, like we did in the previous task, and name it <code class="literal">DrawingView</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec413"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Override the <code class="literal">Draw</code> method of the <code class="literal">DrawingView</code> class and implement it with the following code:<div class="informalexample"><pre class="programlisting">CGContext context = UIGraphics.GetCurrentContext();
context.SetFillColorWithColor(UIColor.Blue.CGColor);
context.SetShadow(new SizeF(10f, 10f), 5f);
context.AddEllipseInRect(new RectangleF(100f, 100f, 100f, 100f));
context.FillPath();
context.SetFillColorWithColor(UIColor.Red.CGColor);
context.AddRect(new RectangleF(150f, 150f, 100f, 100f));
context.FillPath();</pre></div></li><li class="listitem">In the <code class="literal">ViewDidLoad</code> method of the <code class="literal">DrawShapeAppViewController</code> class, initialize and display the view with the following code:<div class="informalexample"><pre class="programlisting">DrawingView drawView = new DrawingView(new RectangleF(0f, 20f, this.View.Bounds.Width, this.View.Bounds.Height));
drawView.BackgroundColor = UIColor.DarkGray;
this.View.AddSubview(drawView);</pre></div></li><li class="listitem">Compile and run the app on the simulator. The result on the screen should be similar to the one shown in the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_11_04.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec414"/>How it works...</h2></div></div></div><p>To draw<a id="id682" class="indexterm"/> shapes on a view, we need to call the appropriate method. We first set the fill color of the <code class="literal">CGContext</code> instance as follows:</p><div class="informalexample"><pre class="programlisting">context.SetFillColorWithColor(UIColor.Blue.CGColor);</pre></div><p>To draw a circle, we call the <code class="literal">AddEllipseInRect</code> method, passing a <code class="literal">RectangleF</code> object that contains the bounding rectangle of the circle as follows:</p><div class="informalexample"><pre class="programlisting">context.AddEllipseInRect(new RectangleF(100f, 100f, 100f, 100f));</pre></div><p>Whether the shape will be an ellipse or an absolute circle is defined through the bounding rectangle's size. We then call the <code class="literal">FillPath</code> method as follows:</p><div class="informalexample"><pre class="programlisting">context.FillPath();</pre></div><p>The shadow effect is defined by the <code class="literal">SetShadow</code> method as follows:</p><div class="informalexample"><pre class="programlisting">context.SetShadow(new SizeF(10f, 10f), 5f);</pre></div><p>The first parameter, which is of the <code class="literal">SizeF</code> type, defines the offset of the shadow, while the second parameter defines the amount of blur, in points.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec415"/>There's more...</h2></div></div></div><p>When <a id="id683" class="indexterm"/>the <code class="literal">SetShadow</code> method is called, all objects that are added to the context are displayed with a shadow. To remove the shadow, call the <code class="literal">SetShadowWithColor</code> method, passing either a fully transparent color or null for the color parameter.</p><div class="section" title="Transparent colors"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec102"/>Transparent colors</h3></div></div></div><p>To fill a <a id="id684" class="indexterm"/>shape with a transparent color, create a <code class="literal">CGColor</code> instance with the appropriate values as follows:</p><div class="informalexample"><pre class="programlisting">context.SetFillColorWithColor(new CGColor(1f, 0f, 0f, 0.5f));</pre></div><p>This will create a red color with its alpha value set to 50 percent.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec416"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Drawing lines and curves</em></span> recipe</li></ul></div></div></div>
<div class="section" title="Drawing text"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec103"/>Drawing text</h1></div></div></div><p>In this recipe, we will learn how to draw styled text with an outline on a view.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec417"/>Getting ready</h2></div></div></div><p>Create a<a id="id685" class="indexterm"/> new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">DrawTextApp</code>. Add a custom view to the project, similar to the one we created in the previous recipe, and name it <code class="literal">DrawingView</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec418"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement the following <code class="literal">Draw</code> method override in the <code class="literal">DrawingView</code> class:<div class="informalexample"><pre class="programlisting">CGContext context = UIGraphics.GetCurrentContext();
PointF location = new PointF(10f, 100f);
UIFont font = UIFont.FromName("Verdana-Bold", 28f);
NSString drawText = new NSString("This text is drawn!");
context.SetTextDrawingMode(CGTextDrawingMode.Stroke);
context.SetStrokeColorWithColor(UIColor.Black.CGColor);
context.SetLineWidth(4f);
drawText.DrawString(location, font);
context.SetTextDrawingMode(CGTextDrawingMode.Fill);
context.SetFillColorWithColor(UIColor.Yellow.CGColor);
drawText.DrawString(location, font);</pre></div></li><li class="listitem">In the <code class="literal">ViewDidLoad</code> method of the controller, initialize and display the <code class="literal">DrawingView</code> method as follows:<div class="informalexample"><pre class="programlisting">DrawingView drawView = new DrawingView(new RectangleF(0f, 20f, this.View.Bounds.Width, this.View.Bounds.Height));
drawView.BackgroundColor = UIColor.DarkGray;
this.View.AddSubview(drawView);</pre></div></li><li class="listitem">Compile <a id="id686" class="indexterm"/>and run the app on the simulator. The text will be displayed on the screen. The result should be similar to the following screenshot:<div class="mediaobject"><img src="graphics/8924OT_11_05.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec419"/>How it works...</h2></div></div></div><p>The <code class="literal">NSString</code> class contains the very useful <code class="literal">DrawString</code> method, which draws the text it contains to the current context. To provide the outline effect, we call the <code class="literal">SetTextDrawingMode</code> method as follows:</p><div class="informalexample"><pre class="programlisting">context.SetTextDrawingMode(CGTextDrawingMode.Stroke);</pre></div><p>We pass the <code class="literal">CGTextDrawingMode.Stroke</code> value. We then set the color and width of the outline to the graphics context and draw it text on the screen as follows:</p><div class="informalexample"><pre class="programlisting">context.SetStrokeColorWithColor(UIColor.Black.CGColor);
context.SetLineWidth(4f);
drawText.DrawString(location, font);</pre></div><p>The <code class="literal">SetStrokeColorWithColor</code> method sets the color of the stroke, and the <code class="literal">SetLineWidth</code> method sets the width of the stroke. Calling the <code class="literal">DrawString</code> method of <code class="literal">NSString</code> draws the text in the graphics context in the specified location and with the specified font.</p><p>Similarly, to fill the text, we set the text drawing mode to <code class="literal">Fill</code> as follows:</p><div class="informalexample"><pre class="programlisting">context.SetTextDrawingMode(CGTextDrawingMode.Fill);</pre></div><p>For the fill, we are not concerned about the line's width, so we just need to call the <code class="literal">DrawString</code> method once more as follows:</p><div class="informalexample"><pre class="programlisting">drawText.DrawString(location, font);</pre></div><p>The <code class="literal">DrawString</code> method is overloaded. The overload we use here accepts a <code class="literal">PointF</code> struct, which represents the location of the string in the view's coordinate system and a <code class="literal">UIFont</code> instance <a id="id687" class="indexterm"/>that represents the font by which the text will be rendered on the screen.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec420"/>There's more...</h2></div></div></div><p>Drawing text on the screen with the <code class="literal">DrawString</code> method is very simple and the quickest way to do it. For more complex functionality, such as customizing the layout of the text, its appearance, and <a id="id688" class="indexterm"/>many more, we need to use the <span class="strong"><strong>CoreText framework</strong></span>. This is accessible in Xamarin.iOS through the <code class="literal">MonoTouch.CoreText</code> namespace.</p><div class="section" title="Size of the drawn text"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec103"/>Size of the drawn text</h3></div></div></div><p>The <code class="literal">DrawString</code> method of the <code class="literal">NSString</code> class returns the size of the bounding rectangle<a id="id689" class="indexterm"/> of the text. We can, however, get the size of the text before drawing it through the <code class="literal">StringSize</code> method as follows:</p><div class="informalexample"><pre class="programlisting">Console.WriteLine("Text size: {0}", drawText.StringSize(UIFont.FromName("Verdana-Bold", 28f)));</pre></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec421"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Drawing lines and curves</em></span> and <span class="emphasis"><em>Drawing shapes</em></span> recipes</li></ul></div></div></div>
<div class="section" title="A simple drawing app"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec104"/>A simple drawing app</h1></div></div></div><p>In this<a id="id690" class="indexterm"/> recipe, we will use the techniques we learned to create a drawing app.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec422"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">FingerDrawingApp</code>. Once again, we will need a custom view. Add a class deriving from <code class="literal">UIView</code> and name it <code class="literal">CanvasView</code>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec423"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Implement <a id="id691" class="indexterm"/>the <code class="literal">CanvasView</code> class with the following code:<div class="informalexample"><pre class="programlisting">public class CanvasView : UIView
{
  public CanvasView (RectangleF frame) : base(frame)
  {
    this.drawPath = new CGPath();
  }
  private PointF touchLocation;
  private PointF previousTouchLocation;
  private CGPath drawPath;
  private bool fingerDraw;
  public override void TouchesBegan (NSSet touches, UIEvent evt)
  {
    base.TouchesBegan (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    this.fingerDraw = true;
    this.touchLocation = touch.LocationInView(this);
    this.previousTouchLocation = touch.PreviousLocationInView(this);
    this.SetNeedsDisplay();
  }
  public override void TouchesMoved (NSSet touches, UIEvent evt)
  {
    base.TouchesMoved (touches, evt);
    UITouch touch = touches.AnyObject as UITouch;
    this.touchLocation = touch.LocationInView(this);
    this.previousTouchLocation = touch.PreviousLocationInView(this);
    this.SetNeedsDisplay();
  }
  public override void Draw (RectangleF rect)
  {
    base.Draw (rect);
    if (this.fingerDraw)
    {
      using (CGContext context = UIGraphics.GetCurrentContext())
      {
        context.SetStrokeColorWithColor(UIColor.Blue.CGColor);
        context.SetLineWidth(5f);
        context.SetLineJoin(CGLineJoin.Round);
        context.SetLineCap(CGLineCap.Round);
        this.drawPath.MoveToPoint(this.previousTouchLocation);
        this.drawPath.AddLineToPoint(this.touchLocation);
        context.AddPath(this.drawPath);
        context.DrawPath(CGPathDrawingMode.Stroke);
      }
    }
  }
}</pre></div></li><li class="listitem">In <a id="id692" class="indexterm"/>the <code class="literal">ViewDidLoad</code> method of the <code class="literal">FingerDrawingAppViewController</code> class, initialize and show the canvas as follows:<div class="informalexample"><pre class="programlisting">CanvasView canvasView = new CanvasView(new RectangleF(0f, 20f, this.View.Bounds.Width, this.View.Bounds.Height));
canvasView.BackgroundColor = UIColor.Gray;
this.View.AddSubview(canvasView);</pre></div></li><li class="listitem">Compile and run the app on the simulator or on the device. Touch-and-drag your finger (or click-and-drag with the cursor) and start drawing. The following screenshot displays a sketch drawn in this app:<div class="mediaobject"><img src="graphics/8924OT_11_06.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec424"/>How it works...</h2></div></div></div><p>In this<a id="id693" class="indexterm"/> task, we are combining touch events and custom drawing to create a simple drawing app. When the user touches and moves the finger on the screen, we keep the information of the touch location points and use them in the <code class="literal">Draw</code> method to draw lines.</p><p>After setting the touch locations to the class fields, we call <code class="literal">SetNeedsDisplay</code> to force the <code class="literal">Draw</code> method to be called. The <code class="literal">fingerDraw</code> variable is used to determine that the <code class="literal">Draw</code> method was called by a touch on the screen and not by the runtime when the view is first loaded.</p><p>Every<a id="id694" class="indexterm"/> time we call a method to draw something to a graphics context, the previous drawings in this context are cleared. To avoid this behavior, we use a <code class="literal">CGPath</code> object. We can add various drawing objects in <code class="literal">CGPath</code> and display these object on the screen by adding it to the graphics context. So, every time the user moves their finger on the screen, the new lines defined by the touch location points are added to the path, and the path is drawn on the current context.</p><p>Note that we need to hold information of both the current touch location and the previous one. This is because the <code class="literal">AddLineToPoint</code> method accepts one point, which defines the end point of the line, assuming that there already is a point in the path. The starting point of each line is defined by calling <code class="literal">MoveToPoint</code>, passing the previous touch location point.</p><p>The path that is drawn on the screen by sliding the finger on it is basically comprised of a series of consecutive straight lines. The result, however, is a smooth path that follows the finger movement, because the <code class="literal">TouchesMoved</code> method is triggered every time there is a single movement of the finger on the screen.</p><p>After adding the line to the path, we add it to the context and draw it in the graphics context, hence showing it on the screen as follows:</p><div class="informalexample"><pre class="programlisting">context.AddPath(this.drawPath);
context.DrawPath(CGPathDrawingMode.Stroke);</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec425"/>There's more...</h2></div></div></div><p>Two new <code class="literal">CGContext</code> methods are introduced in this task: <code class="literal">SetLineJoin</code> and <code class="literal">SetLineCap</code>. The <code class="literal">SetLineJoin</code> method sets how each line will be joined to the previous one, while the <code class="literal">SetLineCap</code> method sets the appearance of the endpoint of a line.</p><p>The values that they accept are explained in the following two tables:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SetLineJoin</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CGLineJoin.Miter</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Joins two lines with an angled corner</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CGLineJoin.Round</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Joins two lines with a rounded end</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CGLineJoin.Bevel</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Joins two lines with a squared end</p>
</td></tr></tbody></table></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SetLineCap</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CGLineCap.Butt</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The line will end with a squared edge on the endpoint</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CGLineCap.Round</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The line will end with a rounded edge that expands beyond the endpoint</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CGLineCap.Square</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The line will end with a squared edge that expands beyond the endpoint</p>
</td></tr></tbody></table></div><div class="section" title="Clear the drawing"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec104"/>Clear the drawing</h3></div></div></div><p>To clear the drawing, we simply have to set the <code class="literal">fingerDraw</code> variable to <code class="literal">false</code> and call <code class="literal">SetNeedsDisplay</code>. This way, the <code class="literal">Draw</code> method will be called without our custom drawing code, clearing<a id="id695" class="indexterm"/> the current context.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec426"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Drawing lines and curves</em></span>, <span class="emphasis"><em>Drawing shapes</em></span>, and <span class="emphasis"><em>Drawing text</em></span> recipes</li></ul></div></div></div>
<div class="section" title="Creating an image context"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec105"/>Creating an image context</h1></div></div></div><p>In this recipe, we will extend the finger-drawing app we created earlier by providing a save <a id="id696" class="indexterm"/>functionality for the drawings that the user will create.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec427"/>Getting ready</h2></div></div></div><p>Create a new <span class="strong"><strong>Single View Application</strong></span> in Xamarin Studio and name it <code class="literal">ImageContextApp</code>. Add the <code class="literal">CanvasView</code> class we created in the earlier task to the project. Don't forget to change the namespace in the <code class="literal">CanvasView.cs</code> file to correspond to the namespace of the new project.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec428"/>How to do it...</h2></div></div></div><p>Perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following methods in the <code class="literal">CanvasView</code> class:<div class="informalexample"><pre class="programlisting">public UIImage GetDrawingImage()
{
  UIImage toReturn = null;
  UIGraphics.BeginImageContext(this.Bounds.Size);
  using (CGContext context = UIGraphics.GetCurrentContext())
  {
    context.SetStrokeColorWithColor(UIColor.Blue.CGColor);
    context.SetLineWidth(10f);
    context.SetLineJoin(CGLineJoin.Round);
    context.SetLineCap(CGLineCap.Round);
    context.AddPath(this.drawPath);
    context.DrawPath(CGPathDrawingMode.Stroke);
    toReturn = UIGraphics.GetImageFromCurrentImageContext();
  }
  UIGraphics.EndImageContext();
  return toReturn;
}
public void ClearDrawing()
{
  this.fingerDraw = false;
  this.drawPath.Dispose();
  this.drawPath = new CGPath();
  this.SetNeedsDisplay();
}</pre></div></li><li class="listitem">Add<a id="id697" class="indexterm"/> two buttons on the view of the controller. One button will be used for saving the drawing and the other one for clearing the canvas.</li><li class="listitem">Add the following code in the <code class="literal">ViewDidLoad</code> method of the <code class="literal">ImageContextAppViewController</code> class:<div class="informalexample"><pre class="programlisting">CanvasView canvasView = new CanvasView(new RectangleF(0f, 0f, this.btnSave.Frame.Top - 10f, this.View.Bounds.Width));
canvasView.BackgroundColor = UIColor.Gray;
this.View.AddSubview(canvasView);
this.btnSave.TouchUpInside += (sender, e) =&gt; {
  UIImage drawingImage = canvasView.GetDrawingImage();
  drawingImage.SaveToPhotosAlbum((img, err) =&gt; {
    if (null != err)
    {
      Console.WriteLine("Error saving image! {0}", err.LocalizedDescription);
    }
  });
};
this.btnClear.TouchUpInside += (sender, e) =&gt; canvasView.ClearDrawing ();</pre></div></li><li class="listitem">Compile and run the app on the simulator. Draw something on the canvas and tap the <span class="strong"><strong>Save drawing</strong></span> button to save your drawing. Tap on the <span class="strong"><strong>Clear canvas</strong></span> button to clear the canvas. You can then check the simulator's photo albums for your drawing.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec429"/>How it works...</h2></div></div></div><p>Using the <code class="literal">UIGraphics</code> class, we can create an image context through which we can retrieve our drawing in a <code class="literal">UIImage</code> object.</p><p>To create an image context, we call the <code class="literal">BeginImageContext</code> static method inside the <code class="literal">GetDrawingImage</code> method, passing the size that we want the image context to have, as follows:</p><div class="informalexample"><pre class="programlisting">UIGraphics.BeginImageContext(this.Bounds.Size);</pre></div><p>The <a id="id698" class="indexterm"/>current context is now the image context we created with the <code class="literal">BeginImageContext</code> call. We then repeat the code we have in the <code class="literal">Draw</code> method; only this time, there is no need to add new lines to the path. We simply add the path that we already have to the context and draw it.</p><p>After adding the path, we get the context image by calling the <code class="literal">GetImageFromCurrentContext</code> method as follows:</p><div class="informalexample"><pre class="programlisting">toReturn = UIGraphics.GetImageFromCurrentImageContext();</pre></div><p>Finally, we have to end the image context block and return the <code class="literal">UIImage</code> object as follows:</p><div class="informalexample"><pre class="programlisting">UIGraphics.EndImageContext();
return toReturn;</pre></div><p>To clear the drawing from the screen, we simply have to set the <code class="literal">fingerDraw</code> variable to <code class="literal">false</code> and dispose and prepare our <code class="literal">CGPath</code> object for reuse inside the <code class="literal">ClearDrawing</code> method as follows:</p><div class="informalexample"><pre class="programlisting">this.fingerDraw = false;
this.drawPath.Dispose();
this.drawPath = new CGPath();</pre></div><p>To reflect the clearing on the screen immediately, we call the <code class="literal">SetNeedsDisplay</code> method as follows:</p><div class="informalexample"><pre class="programlisting">this.SetNeedsDisplay();</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec430"/>There's more...</h2></div></div></div><p>We cannot create an image context inside the <code class="literal">Draw</code> method. This is because when we call the <code class="literal">BeginImageContext</code> method, a context is actually created, but the view's default context remains as the current context. Hence, the <code class="literal">GetImageFromCurrentImageContext</code> method would return <code class="literal">null</code>.</p><div class="section" title="Drawing on UIImageView"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec105"/>Drawing on UIImageView</h3></div></div></div><p>The<a id="id699" class="indexterm"/> technique discussed here can be used to draw on custom <code class="literal">UIImageView</code> objects. To display the drawing when the finger slides on the screen, we would simply have to set its <code class="literal">Image</code> property<a id="id700" class="indexterm"/> to the image we get from the image context.</p></div><div class="section" title="Background on saved drawings"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec106"/>Background on saved drawings</h3></div></div></div><p>You will notice that although we are setting the <code class="literal">CanvasView</code> background to gray, the saved <a id="id701" class="indexterm"/>drawings are with a white background. This is because the view's background color is not included in the drawing. To include it, we would just have to draw a rectangle to the graphics context. This rectangle should be of the same color as the background color.</p></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec431"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Drawing lines and curves</em></span>, <span class="emphasis"><em>Drawing shapes</em></span>, <span class="emphasis"><em>Drawing text</em></span>, and <span class="emphasis"><em>A simple drawing app</em></span> recipes</li></ul></div></div></div></body></html>